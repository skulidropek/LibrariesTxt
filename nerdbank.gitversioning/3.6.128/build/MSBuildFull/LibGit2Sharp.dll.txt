public class LibGit2Sharp.AfterRebaseStepInfo : object {
    [CompilerGeneratedAttribute]
private RebaseStepInfo <StepInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Commit <Commit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasPatchAlreadyApplied>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompletedStepIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalStepCount>k__BackingField;
    public RebaseStepInfo StepInfo { get; private set; }
    public Commit Commit { get; private set; }
    public bool WasPatchAlreadyApplied { get; private set; }
    public long CompletedStepIndex { get; private set; }
    public long TotalStepCount { get; private set; }
    internal AfterRebaseStepInfo(RebaseStepInfo stepInfo, Commit commit, long completedStepIndex, long totalStepCount);
    internal AfterRebaseStepInfo(RebaseStepInfo stepInfo, long completedStepIndex, long totalStepCount);
    [CompilerGeneratedAttribute]
public virtual RebaseStepInfo get_StepInfo();
    [CompilerGeneratedAttribute]
private void set_StepInfo(RebaseStepInfo value);
    [CompilerGeneratedAttribute]
public virtual Commit get_Commit();
    [CompilerGeneratedAttribute]
private void set_Commit(Commit value);
    [CompilerGeneratedAttribute]
public virtual bool get_WasPatchAlreadyApplied();
    [CompilerGeneratedAttribute]
private void set_WasPatchAlreadyApplied(bool value);
    [CompilerGeneratedAttribute]
public virtual long get_CompletedStepIndex();
    [CompilerGeneratedAttribute]
private void set_CompletedStepIndex(long value);
    [CompilerGeneratedAttribute]
public virtual long get_TotalStepCount();
    [CompilerGeneratedAttribute]
private void set_TotalStepCount(long value);
}
public class LibGit2Sharp.AmbiguousSpecificationException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public AmbiguousSpecificationException(string message);
    public AmbiguousSpecificationException(string format, Object[] args);
    public AmbiguousSpecificationException(string message, Exception innerException);
    protected AmbiguousSpecificationException(SerializationInfo info, StreamingContext context);
    internal virtual GitErrorCode get_ErrorCode();
}
public abstract class LibGit2Sharp.ArchiverBase : object {
    public virtual void BeforeArchiving(Tree tree, ObjectId oid, DateTimeOffset modificationTime);
    public virtual void AfterArchiving(Tree tree, ObjectId oid, DateTimeOffset modificationTime);
    internal void OrchestrateArchiving(Tree tree, ObjectId oid, DateTimeOffset modificationTime);
    private void ArchiveTree(IEnumerable`1<TreeEntry> tree, string path, DateTimeOffset modificationTime);
    protected abstract virtual void AddTreeEntry(string path, TreeEntry entry, DateTimeOffset modificationTime);
}
internal static class LibGit2Sharp.AssemblyCommitIds : object {
    public static string LibGit2CommitSha;
    public static string LibGit2SharpCommitSha;
}
public class LibGit2Sharp.BareRepositoryException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public BareRepositoryException(string message);
    public BareRepositoryException(string format, Object[] args);
    public BareRepositoryException(string message, Exception innerException);
    protected BareRepositoryException(SerializationInfo info, StreamingContext context);
    internal BareRepositoryException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
public class LibGit2Sharp.BeforeRebaseStepInfo : object {
    [CompilerGeneratedAttribute]
private RebaseStepInfo <StepInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StepIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalStepCount>k__BackingField;
    public RebaseStepInfo StepInfo { get; private set; }
    public long StepIndex { get; private set; }
    public long TotalStepCount { get; private set; }
    internal BeforeRebaseStepInfo(RebaseStepInfo stepInfo, long stepIndex, long totalStepCount);
    [CompilerGeneratedAttribute]
public virtual RebaseStepInfo get_StepInfo();
    [CompilerGeneratedAttribute]
private void set_StepInfo(RebaseStepInfo value);
    [CompilerGeneratedAttribute]
public virtual long get_StepIndex();
    [CompilerGeneratedAttribute]
private void set_StepIndex(long value);
    [CompilerGeneratedAttribute]
public virtual long get_TotalStepCount();
    [CompilerGeneratedAttribute]
private void set_TotalStepCount(long value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.BlameHunk : object {
    private static LambdaEqualityHelper`1<BlameHunk> equalityHelper;
    [CompilerGeneratedAttribute]
private int <LineCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FinalStartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Signature <FinalSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialStartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Signature <InitialSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InitialPath>k__BackingField;
    private Lazy`1<Commit> finalCommit;
    private Lazy`1<Commit> origCommit;
    public int LineCount { get; private set; }
    public int FinalStartLineNumber { get; private set; }
    public Signature FinalSignature { get; private set; }
    public Commit FinalCommit { get; }
    public int InitialStartLineNumber { get; private set; }
    public Signature InitialSignature { get; private set; }
    public Commit InitialCommit { get; }
    public string InitialPath { get; private set; }
    private string DebuggerDisplay { get; }
    internal BlameHunk(IRepository repository, git_blame_hunk* rawHunk);
    private static BlameHunk();
    public virtual bool ContainsLine(int line);
    [CompilerGeneratedAttribute]
public virtual int get_LineCount();
    [CompilerGeneratedAttribute]
private void set_LineCount(int value);
    [CompilerGeneratedAttribute]
public virtual int get_FinalStartLineNumber();
    [CompilerGeneratedAttribute]
private void set_FinalStartLineNumber(int value);
    [CompilerGeneratedAttribute]
public virtual Signature get_FinalSignature();
    [CompilerGeneratedAttribute]
private void set_FinalSignature(Signature value);
    public virtual Commit get_FinalCommit();
    [CompilerGeneratedAttribute]
public virtual int get_InitialStartLineNumber();
    [CompilerGeneratedAttribute]
private void set_InitialStartLineNumber(int value);
    [CompilerGeneratedAttribute]
public virtual Signature get_InitialSignature();
    [CompilerGeneratedAttribute]
private void set_InitialSignature(Signature value);
    public virtual Commit get_InitialCommit();
    [CompilerGeneratedAttribute]
public virtual string get_InitialPath();
    [CompilerGeneratedAttribute]
private void set_InitialPath(string value);
    private string get_DebuggerDisplay();
    public sealed virtual bool Equals(BlameHunk other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(BlameHunk left, BlameHunk right);
    public static bool op_Inequality(BlameHunk left, BlameHunk right);
}
[DefaultMemberAttribute("Item")]
public class LibGit2Sharp.BlameHunkCollection : object {
    private IRepository repo;
    private List`1<BlameHunk> hunks;
    public BlameHunk Item { get; }
    internal BlameHunkCollection(Repository repo, RepositoryHandle repoHandle, string path, BlameOptions options);
    public virtual BlameHunk get_Item(int idx);
    public virtual BlameHunk HunkForLine(int line);
    public virtual IEnumerator`1<BlameHunk> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class LibGit2Sharp.BlameOptions : object {
    [CompilerGeneratedAttribute]
private BlameStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private object <StartingAt>k__BackingField;
    [CompilerGeneratedAttribute]
private object <StoppingAt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLine>k__BackingField;
    public BlameStrategy Strategy { get; public set; }
    public object StartingAt { get; public set; }
    public object StoppingAt { get; public set; }
    public int MinLine { get; public set; }
    public int MaxLine { get; public set; }
    [CompilerGeneratedAttribute]
public BlameStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(BlameStrategy value);
    [CompilerGeneratedAttribute]
public object get_StartingAt();
    [CompilerGeneratedAttribute]
public void set_StartingAt(object value);
    [CompilerGeneratedAttribute]
public object get_StoppingAt();
    [CompilerGeneratedAttribute]
public void set_StoppingAt(object value);
    [CompilerGeneratedAttribute]
public int get_MinLine();
    [CompilerGeneratedAttribute]
public void set_MinLine(int value);
    [CompilerGeneratedAttribute]
public int get_MaxLine();
    [CompilerGeneratedAttribute]
public void set_MaxLine(int value);
}
public enum LibGit2Sharp.BlameStrategy : Enum {
    public int value__;
    public static BlameStrategy Default;
}
public class LibGit2Sharp.Blob : GitObject {
    private ILazy`1<long> lazySize;
    private ILazy`1<bool> lazyIsBinary;
    public long Size { get; }
    public bool IsBinary { get; }
    internal Blob(Repository repo, ObjectId id);
    public virtual long get_Size();
    public virtual bool get_IsBinary();
    public virtual Stream GetContentStream();
    public virtual Stream GetContentStream(FilteringOptions filteringOptions);
    public virtual string GetContentText();
    public virtual string GetContentText(Encoding encoding);
    public virtual string GetContentText(FilteringOptions filteringOptions);
    public virtual string GetContentText(FilteringOptions filteringOptions, Encoding encoding);
    private static string ReadToEnd(Stream stream, Encoding encoding);
}
[DefaultMemberAttribute("Item")]
public class LibGit2Sharp.Branch : ReferenceWrapper`1<Commit> {
    private Lazy`1<Branch> trackedBranch;
    public TreeEntry Item { get; }
    public bool IsRemote { get; }
    public Branch TrackedBranch { get; }
    public bool IsTracking { get; }
    public BranchTrackingDetails TrackingDetails { get; }
    public bool IsCurrentRepositoryHead { get; }
    public Commit Tip { get; }
    public ICommitLog Commits { get; }
    public string UpstreamBranchCanonicalName { get; }
    public string RemoteName { get; }
    internal Branch(Repository repo, Reference reference, string canonicalName);
    internal Branch(Repository repo, Reference reference);
    private Branch(Repository repo, Reference reference, Func`2<Reference, string> canonicalNameSelector);
    public virtual TreeEntry get_Item(string relativePath);
    public virtual bool get_IsRemote();
    public virtual Branch get_TrackedBranch();
    public virtual bool get_IsTracking();
    public virtual BranchTrackingDetails get_TrackingDetails();
    public virtual bool get_IsCurrentRepositoryHead();
    public virtual Commit get_Tip();
    public virtual ICommitLog get_Commits();
    public virtual string get_UpstreamBranchCanonicalName();
    public virtual string get_RemoteName();
    private string UpstreamBranchCanonicalNameFromLocalBranch();
    private string RemoteNameFromLocalBranch();
    private string RemoteNameFromRemoteTrackingBranch();
    private Branch ResolveTrackedBranch();
    private static bool IsRemoteBranch(string canonicalName);
    protected virtual string Shorten();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.BranchCollection : object {
    internal Repository repo;
    public Branch Item { get; }
    private string DebuggerDisplay { get; }
    internal BranchCollection(Repository repo);
    public virtual Branch get_Item(string name);
    private static string ShortToLocalName(string name);
    private static string ShortToRemoteName(string name);
    private static string ShortToRefName(string name);
    private Branch BuildFromReferenceName(string canonicalName);
    public virtual IEnumerator`1<Branch> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Branch Add(string name, string committish);
    public virtual Branch Add(string name, Commit commit);
    public virtual Branch Add(string name, Commit commit, bool allowOverwrite);
    public virtual Branch Add(string name, string committish, bool allowOverwrite);
    public virtual void Remove(string name);
    public virtual void Remove(string name, bool isRemote);
    public virtual void Remove(Branch branch);
    public virtual Branch Rename(string currentName, string newName);
    public virtual Branch Rename(string currentName, string newName, bool allowOverwrite);
    public virtual Branch Rename(Branch branch, string newName);
    public virtual Branch Rename(Branch branch, string newName, bool allowOverwrite);
    public virtual Branch Update(Branch branch, Action`1[] actions);
    private static bool LooksLikeABranchName(string referenceName);
    private string get_DebuggerDisplay();
}
public class LibGit2Sharp.BranchTrackingDetails : object {
    private HistoryDivergence historyDivergence;
    public Nullable`1<int> AheadBy { get; }
    public Nullable`1<int> BehindBy { get; }
    public Commit CommonAncestor { get; }
    internal BranchTrackingDetails(Repository repo, Branch branch);
    public virtual Nullable`1<int> get_AheadBy();
    public virtual Nullable`1<int> get_BehindBy();
    public virtual Commit get_CommonAncestor();
}
public class LibGit2Sharp.BranchUpdater : object {
    private Repository repo;
    private Branch branch;
    unknown string TrackedBranch {public set; }
    unknown string UpstreamBranch {public set; }
    unknown string Remote {public set; }
    internal BranchUpdater(Repository repo, Branch branch);
    public virtual void set_TrackedBranch(string value);
    public virtual void set_UpstreamBranch(string value);
    public virtual void set_Remote(string value);
    private void UnsetUpstream();
    private void SetUpstream(string upstreamBranchName);
    private void SetUpstreamBranch(string mergeBranchName);
    private void SetUpstreamRemote(string remoteName);
    private void GetUpstreamInformation(string canonicalName, String& remoteName, String& mergeBranchName);
}
[FlagsAttribute]
public enum LibGit2Sharp.BuiltInFeatures : Enum {
    public int value__;
    public static BuiltInFeatures None;
    public static BuiltInFeatures Threads;
    public static BuiltInFeatures Https;
    public static BuiltInFeatures Ssh;
    public static BuiltInFeatures NSec;
}
public abstract class LibGit2Sharp.Certificate : object {
}
public class LibGit2Sharp.CertificateSsh : Certificate {
    public Byte[] HashMD5;
    public Byte[] HashSHA1;
    public bool HasMD5;
    public bool HasSHA1;
    internal CertificateSsh(git_certificate_ssh* cert);
    internal IntPtr ToPointer();
}
public class LibGit2Sharp.CertificateX509 : Certificate {
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    public X509Certificate Certificate { get; private set; }
    internal CertificateX509(git_certificate_x509* cert);
    internal CertificateX509(X509Certificate cert);
    [CompilerGeneratedAttribute]
public virtual X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate value);
    internal IntPtr ToPointers(IntPtr& dataPtr);
}
public enum LibGit2Sharp.ChangeKind : Enum {
    public int value__;
    public static ChangeKind Unmodified;
    public static ChangeKind Added;
    public static ChangeKind Deleted;
    public static ChangeKind Modified;
    public static ChangeKind Renamed;
    public static ChangeKind Copied;
    public static ChangeKind Ignored;
    public static ChangeKind Untracked;
    public static ChangeKind TypeChanged;
    public static ChangeKind Unreadable;
    public static ChangeKind Conflicted;
}
internal class LibGit2Sharp.CheckoutCallbacks : object {
    private CheckoutProgressHandler onCheckoutProgress;
    private CheckoutNotifyHandler onCheckoutNotify;
    public progress_cb CheckoutProgressCallback { get; }
    public checkout_notify_cb CheckoutNotifyCallback { get; }
    private CheckoutCallbacks(CheckoutProgressHandler onCheckoutProgress, CheckoutNotifyHandler onCheckoutNotify);
    public progress_cb get_CheckoutProgressCallback();
    public checkout_notify_cb get_CheckoutNotifyCallback();
    internal static CheckoutCallbacks From(CheckoutProgressHandler onCheckoutProgress, CheckoutNotifyHandler onCheckoutNotify);
    private void OnGitCheckoutProgress(IntPtr str, UIntPtr completedSteps, UIntPtr totalSteps, IntPtr payload);
    private int OnGitCheckoutNotify(CheckoutNotifyFlags why, IntPtr pathPtr, IntPtr baselinePtr, IntPtr targetPtr, IntPtr workdirPtr, IntPtr payloadPtr);
}
public class LibGit2Sharp.CheckoutConflictException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public CheckoutConflictException(string message);
    public CheckoutConflictException(string format, Object[] args);
    public CheckoutConflictException(string message, Exception innerException);
    protected CheckoutConflictException(SerializationInfo info, StreamingContext context);
    internal CheckoutConflictException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
public enum LibGit2Sharp.CheckoutFileConflictStrategy : Enum {
    public int value__;
    public static CheckoutFileConflictStrategy Normal;
    public static CheckoutFileConflictStrategy Ours;
    public static CheckoutFileConflictStrategy Theirs;
    public static CheckoutFileConflictStrategy Merge;
    public static CheckoutFileConflictStrategy Diff3;
}
[FlagsAttribute]
public enum LibGit2Sharp.CheckoutModifiers : Enum {
    public int value__;
    public static CheckoutModifiers None;
    public static CheckoutModifiers Force;
}
[FlagsAttribute]
public enum LibGit2Sharp.CheckoutNotifyFlags : Enum {
    public int value__;
    public static CheckoutNotifyFlags None;
    public static CheckoutNotifyFlags Conflict;
    public static CheckoutNotifyFlags Dirty;
    public static CheckoutNotifyFlags Updated;
    public static CheckoutNotifyFlags Untracked;
    public static CheckoutNotifyFlags Ignored;
}
public class LibGit2Sharp.CheckoutOptions : object {
    [CompilerGeneratedAttribute]
private CheckoutModifiers <CheckoutModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutNotifyFlags <CheckoutNotifyFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutNotifyHandler <OnCheckoutNotify>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutProgressHandler <OnCheckoutProgress>k__BackingField;
    public CheckoutModifiers CheckoutModifiers { get; public set; }
    public CheckoutNotifyFlags CheckoutNotifyFlags { get; public set; }
    public CheckoutNotifyHandler OnCheckoutNotify { get; public set; }
    public CheckoutProgressHandler OnCheckoutProgress { get; public set; }
    private CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.CheckoutStrategy { get; }
    [CompilerGeneratedAttribute]
public CheckoutModifiers get_CheckoutModifiers();
    [CompilerGeneratedAttribute]
public void set_CheckoutModifiers(CheckoutModifiers value);
    [CompilerGeneratedAttribute]
public sealed virtual CheckoutNotifyFlags get_CheckoutNotifyFlags();
    [CompilerGeneratedAttribute]
public void set_CheckoutNotifyFlags(CheckoutNotifyFlags value);
    [CompilerGeneratedAttribute]
public CheckoutNotifyHandler get_OnCheckoutNotify();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutNotify(CheckoutNotifyHandler value);
    [CompilerGeneratedAttribute]
public CheckoutProgressHandler get_OnCheckoutProgress();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutProgress(CheckoutProgressHandler value);
    private sealed virtual override CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.get_CheckoutStrategy();
    private sealed virtual override CheckoutCallbacks LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.GenerateCallbacks();
}
public class LibGit2Sharp.CherryPickOptions : MergeAndCheckoutOptionsBase {
    [CompilerGeneratedAttribute]
private int <Mainline>k__BackingField;
    public int Mainline { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Mainline();
    [CompilerGeneratedAttribute]
public void set_Mainline(int value);
}
public class LibGit2Sharp.CherryPickResult : object {
    [CompilerGeneratedAttribute]
private Commit <Commit>k__BackingField;
    [CompilerGeneratedAttribute]
private CherryPickStatus <Status>k__BackingField;
    public Commit Commit { get; private set; }
    public CherryPickStatus Status { get; private set; }
    internal CherryPickResult(CherryPickStatus status, Commit commit);
    [CompilerGeneratedAttribute]
public virtual Commit get_Commit();
    [CompilerGeneratedAttribute]
private void set_Commit(Commit value);
    [CompilerGeneratedAttribute]
public virtual CherryPickStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(CherryPickStatus value);
}
public enum LibGit2Sharp.CherryPickStatus : Enum {
    public int value__;
    public static CherryPickStatus CherryPicked;
    public static CherryPickStatus Conflicts;
}
public class LibGit2Sharp.CloneOptions : FetchOptionsBase {
    [CompilerGeneratedAttribute]
private bool <IsBare>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Checkout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BranchName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecurseSubmodules>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutProgressHandler <OnCheckoutProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private FetchOptions <FetchOptions>k__BackingField;
    public bool IsBare { get; public set; }
    public bool Checkout { get; public set; }
    public string BranchName { get; public set; }
    public bool RecurseSubmodules { get; public set; }
    public CheckoutProgressHandler OnCheckoutProgress { get; public set; }
    public FetchOptions FetchOptions { get; public set; }
    private CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.CheckoutStrategy { get; }
    private CheckoutNotifyFlags LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.CheckoutNotifyFlags { get; }
    [CompilerGeneratedAttribute]
public bool get_IsBare();
    [CompilerGeneratedAttribute]
public void set_IsBare(bool value);
    [CompilerGeneratedAttribute]
public bool get_Checkout();
    [CompilerGeneratedAttribute]
public void set_Checkout(bool value);
    [CompilerGeneratedAttribute]
public string get_BranchName();
    [CompilerGeneratedAttribute]
public void set_BranchName(string value);
    [CompilerGeneratedAttribute]
public bool get_RecurseSubmodules();
    [CompilerGeneratedAttribute]
public void set_RecurseSubmodules(bool value);
    [CompilerGeneratedAttribute]
public CheckoutProgressHandler get_OnCheckoutProgress();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutProgress(CheckoutProgressHandler value);
    [CompilerGeneratedAttribute]
public FetchOptions get_FetchOptions();
    [CompilerGeneratedAttribute]
public void set_FetchOptions(FetchOptions value);
    private sealed virtual override CheckoutCallbacks LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.GenerateCallbacks();
    private sealed virtual override CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.get_CheckoutStrategy();
    private sealed virtual override CheckoutNotifyFlags LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.get_CheckoutNotifyFlags();
}
public static class LibGit2Sharp.Commands : object {
    public static Branch Checkout(IRepository repository, string committishOrBranchSpec);
    public static Branch Checkout(IRepository repository, string committishOrBranchSpec, CheckoutOptions options);
    public static Branch Checkout(IRepository repository, Branch branch);
    public static Branch Checkout(IRepository repository, Branch branch, CheckoutOptions options);
    public static Branch Checkout(IRepository repository, Commit commit);
    public static Branch Checkout(IRepository repository, Commit commit, CheckoutOptions options);
    public static void Checkout(IRepository repository, Tree tree, CheckoutOptions checkoutOptions, string refLogHeadSpec);
    private static RemoteHandle RemoteFromNameOrUrl(RepositoryHandle repoHandle, string remote);
    public static void Fetch(Repository repository, string remote, IEnumerable`1<string> refspecs, FetchOptions options, string logMessage);
    public static MergeResult Pull(Repository repository, Signature merger, PullOptions options);
    public static void Remove(IRepository repository, string path);
    public static void Remove(IRepository repository, string path, bool removeFromWorkingDirectory);
    public static void Remove(IRepository repository, string path, bool removeFromWorkingDirectory, ExplicitPathsOptions explicitPathsOptions);
    public static void Remove(IRepository repository, IEnumerable`1<string> paths);
    public static void Remove(IRepository repository, IEnumerable`1<string> paths, bool removeFromWorkingDirectory, ExplicitPathsOptions explicitPathsOptions);
    private static void RemoveFilesAndFolders(IRepository repository, IEnumerable`1<string> pathsList);
    private static IEnumerable`1<string> RemoveStagedItems(IRepository repository, IEnumerable`1<string> paths, bool removeFromWorkingDirectory, ExplicitPathsOptions explicitPathsOptions);
    public static void Stage(IRepository repository, string path);
    public static void Stage(IRepository repository, string path, StageOptions stageOptions);
    public static void Stage(IRepository repository, IEnumerable`1<string> paths);
    public static void Stage(IRepository repository, IEnumerable`1<string> paths, StageOptions stageOptions);
    public static void Unstage(IRepository repository, string path);
    public static void Unstage(IRepository repository, string path, ExplicitPathsOptions explicitPathsOptions);
    public static void Unstage(IRepository repository, IEnumerable`1<string> paths);
    public static void Unstage(IRepository repository, IEnumerable`1<string> paths, ExplicitPathsOptions explicitPathsOptions);
    public static void Move(IRepository repository, string sourcePath, string destinationPath);
    public static void Move(IRepository repository, IEnumerable`1<string> sourcePaths, IEnumerable`1<string> destinationPaths);
    private static bool Enumerate(IEnumerator`1<string> leftEnum, IEnumerator`1<string> rightEnum);
    private static IDictionary`2<Tuple`2<string, FileStatus>, Tuple`2<string, FileStatus>> PrepareBatch(IRepository repository, IEnumerable`1<string> leftPaths, IEnumerable`1<string> rightPaths);
    private static Tuple`2<string, FileStatus> BuildFrom(IRepository repository, string path);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Commit : GitObject {
    private GitObjectLazyGroup group1;
    private GitObjectLazyGroup group2;
    private ILazy`1<Tree> lazyTree;
    private ILazy`1<Signature> lazyAuthor;
    private ILazy`1<Signature> lazyCommitter;
    private ILazy`1<string> lazyMessage;
    private ILazy`1<string> lazyMessageShort;
    private ILazy`1<string> lazyEncoding;
    private ParentsCollection parents;
    private Lazy`1<IEnumerable`1<Note>> lazyNotes;
    public TreeEntry Item { get; }
    public string Message { get; }
    public string MessageShort { get; }
    public string Encoding { get; }
    public Signature Author { get; }
    public Signature Committer { get; }
    public Tree Tree { get; }
    public IEnumerable`1<Commit> Parents { get; }
    public IEnumerable`1<Note> Notes { get; }
    private string DebuggerDisplay { get; }
    internal Commit(Repository repo, ObjectId id);
    public virtual TreeEntry get_Item(string relativePath);
    public virtual string get_Message();
    public virtual string get_MessageShort();
    public virtual string get_Encoding();
    public virtual Signature get_Author();
    public virtual Signature get_Committer();
    public virtual Tree get_Tree();
    public virtual IEnumerable`1<Commit> get_Parents();
    public virtual IEnumerable`1<Note> get_Notes();
    private IEnumerable`1<Note> RetrieveNotesOfCommit(ObjectId oid);
    private static string RetrieveEncodingOf(ObjectHandle obj);
    public static string PrettifyMessage(string message, char commentChar);
    private string get_DebuggerDisplay();
    public static SignatureInfo ExtractSignature(Repository repo, ObjectId id, string field);
    public static SignatureInfo ExtractSignature(Repository repo, ObjectId id);
    public static string CreateBuffer(Signature author, Signature committer, string message, Tree tree, IEnumerable`1<Commit> parents, bool prettifyMessage, Nullable`1<char> commentChar);
}
public class LibGit2Sharp.CommitFilter : object {
    [CompilerGeneratedAttribute]
private CommitSortStrategies <SortBy>k__BackingField;
    [CompilerGeneratedAttribute]
private object <IncludeReachableFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ExcludeReachableFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FirstParentOnly>k__BackingField;
    public CommitSortStrategies SortBy { get; public set; }
    public object IncludeReachableFrom { get; public set; }
    internal IList`1<object> SinceList { get; }
    public object ExcludeReachableFrom { get; public set; }
    internal IList`1<object> UntilList { get; }
    public bool FirstParentOnly { get; public set; }
    [CompilerGeneratedAttribute]
public CommitSortStrategies get_SortBy();
    [CompilerGeneratedAttribute]
public void set_SortBy(CommitSortStrategies value);
    [CompilerGeneratedAttribute]
public object get_IncludeReachableFrom();
    [CompilerGeneratedAttribute]
public void set_IncludeReachableFrom(object value);
    internal IList`1<object> get_SinceList();
    [CompilerGeneratedAttribute]
public object get_ExcludeReachableFrom();
    [CompilerGeneratedAttribute]
public void set_ExcludeReachableFrom(object value);
    internal IList`1<object> get_UntilList();
    [CompilerGeneratedAttribute]
public bool get_FirstParentOnly();
    [CompilerGeneratedAttribute]
public void set_FirstParentOnly(bool value);
    private static IList`1<object> ToList(object obj);
}
public class LibGit2Sharp.CommitLog : object {
    private Repository repo;
    private CommitFilter queryFilter;
    public CommitSortStrategies SortedBy { get; }
    internal CommitLog(Repository repo);
    internal CommitLog(Repository repo, CommitFilter queryFilter);
    public sealed virtual CommitSortStrategies get_SortedBy();
    public sealed virtual IEnumerator`1<Commit> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ICommitLog QueryBy(CommitFilter filter);
    public sealed virtual IEnumerable`1<LogEntry> QueryBy(string path);
    public sealed virtual IEnumerable`1<LogEntry> QueryBy(string path, CommitFilter filter);
}
public class LibGit2Sharp.CommitOptions : object {
    [CompilerGeneratedAttribute]
private bool <AmendPreviousCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowEmptyCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrettifyMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <CommentaryChar>k__BackingField;
    public bool AmendPreviousCommit { get; public set; }
    public bool AllowEmptyCommit { get; public set; }
    public bool PrettifyMessage { get; public set; }
    public Nullable`1<char> CommentaryChar { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AmendPreviousCommit();
    [CompilerGeneratedAttribute]
public void set_AmendPreviousCommit(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowEmptyCommit();
    [CompilerGeneratedAttribute]
public void set_AllowEmptyCommit(bool value);
    [CompilerGeneratedAttribute]
public bool get_PrettifyMessage();
    [CompilerGeneratedAttribute]
public void set_PrettifyMessage(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_CommentaryChar();
    [CompilerGeneratedAttribute]
public void set_CommentaryChar(Nullable`1<char> value);
}
public class LibGit2Sharp.CommitRewriteInfo : object {
    [CompilerGeneratedAttribute]
private Signature <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private Signature <Committer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public Signature Author { get; public set; }
    public Signature Committer { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public Signature get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(Signature value);
    [CompilerGeneratedAttribute]
public Signature get_Committer();
    [CompilerGeneratedAttribute]
public void set_Committer(Signature value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public static CommitRewriteInfo From(Commit commit);
    public static CommitRewriteInfo From(Commit commit, Signature author);
    public static CommitRewriteInfo From(Commit commit, string message);
    public static CommitRewriteInfo From(Commit commit, Signature author, Signature committer);
    public static CommitRewriteInfo From(Commit commit, Signature author, Signature committer, string message);
}
[FlagsAttribute]
public enum LibGit2Sharp.CommitSortStrategies : Enum {
    public int value__;
    public static CommitSortStrategies None;
    public static CommitSortStrategies Topological;
    public static CommitSortStrategies Time;
    public static CommitSortStrategies Reverse;
}
public class LibGit2Sharp.CompareOptions : object {
    [CompilerGeneratedAttribute]
private int <ContextLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InterhunkLines>k__BackingField;
    [CompilerGeneratedAttribute]
private SimilarityOptions <Similarity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeUnmodified>k__BackingField;
    [CompilerGeneratedAttribute]
private DiffAlgorithm <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentHeuristic>k__BackingField;
    public int ContextLines { get; public set; }
    public int InterhunkLines { get; public set; }
    public SimilarityOptions Similarity { get; public set; }
    public bool IncludeUnmodified { get; public set; }
    public DiffAlgorithm Algorithm { get; public set; }
    public bool IndentHeuristic { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ContextLines();
    [CompilerGeneratedAttribute]
public void set_ContextLines(int value);
    [CompilerGeneratedAttribute]
public int get_InterhunkLines();
    [CompilerGeneratedAttribute]
public void set_InterhunkLines(int value);
    [CompilerGeneratedAttribute]
public SimilarityOptions get_Similarity();
    [CompilerGeneratedAttribute]
public void set_Similarity(SimilarityOptions value);
    [CompilerGeneratedAttribute]
public bool get_IncludeUnmodified();
    [CompilerGeneratedAttribute]
public void set_IncludeUnmodified(bool value);
    [CompilerGeneratedAttribute]
public DiffAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(DiffAlgorithm value);
    [CompilerGeneratedAttribute]
public bool get_IndentHeuristic();
    [CompilerGeneratedAttribute]
public void set_IndentHeuristic(bool value);
}
public class LibGit2Sharp.Configuration : object {
    private FilePath repoConfigPath;
    private FilePath globalConfigPath;
    private FilePath xdgConfigPath;
    private FilePath systemConfigPath;
    private FilePath programDataConfigPath;
    private ConfigurationHandle configHandle;
    private static IDictionary`2<Type, Action`3<string, object, ConfigurationHandle>> configurationTypedUpdater;
    internal Configuration(Repository repository, string repositoryConfigurationFileLocation, string globalConfigurationFileLocation, string xdgConfigurationFileLocation, string systemConfigurationFileLocation);
    private static Configuration();
    private void Init(Repository repository);
    private FilePath NormalizeConfigPath(FilePath path);
    public static Configuration BuildFrom(string repositoryConfigurationFileLocation);
    public static Configuration BuildFrom(string repositoryConfigurationFileLocation, string globalConfigurationFileLocation);
    public static Configuration BuildFrom(string repositoryConfigurationFileLocation, string globalConfigurationFileLocation, string xdgConfigurationFileLocation);
    public static Configuration BuildFrom(string repositoryConfigurationFileLocation, string globalConfigurationFileLocation, string xdgConfigurationFileLocation, string systemConfigurationFileLocation);
    public virtual bool HasConfig(ConfigurationLevel level);
    public sealed virtual void Dispose();
    public virtual bool Unset(string key);
    public virtual bool Unset(string key, ConfigurationLevel level);
    public virtual bool UnsetAll(string key);
    public virtual bool UnsetAll(string key, ConfigurationLevel level);
    protected virtual void Dispose(bool disposing);
    public virtual ConfigurationEntry`1<T> Get(String[] keyParts);
    public virtual ConfigurationEntry`1<T> Get(string firstKeyPart, string secondKeyPart, string thirdKeyPart);
    public virtual ConfigurationEntry`1<T> Get(string key);
    public virtual ConfigurationEntry`1<T> Get(string key, ConfigurationLevel level);
    public virtual T GetValueOrDefault(string key);
    public virtual T GetValueOrDefault(string key, T defaultValue);
    public virtual T GetValueOrDefault(string key, ConfigurationLevel level);
    public virtual T GetValueOrDefault(string key, ConfigurationLevel level, T defaultValue);
    public virtual T GetValueOrDefault(String[] keyParts);
    public virtual T GetValueOrDefault(String[] keyParts, T defaultValue);
    public virtual T GetValueOrDefault(string firstKeyPart, string secondKeyPart, string thirdKeyPart);
    public virtual T GetValueOrDefault(string firstKeyPart, string secondKeyPart, string thirdKeyPart, T defaultValue);
    public virtual T GetValueOrDefault(string key, Func`1<T> defaultValueSelector);
    public virtual T GetValueOrDefault(string key, ConfigurationLevel level, Func`1<T> defaultValueSelector);
    public virtual T GetValueOrDefault(String[] keyParts, Func`1<T> defaultValueSelector);
    public virtual T GetValueOrDefault(string firstKeyPart, string secondKeyPart, string thirdKeyPart, Func`1<T> defaultValueSelector);
    private static T ValueOrDefault(ConfigurationEntry`1<T> value, T defaultValue);
    private static T ValueOrDefault(ConfigurationEntry`1<T> value, Func`1<T> defaultValueSelector);
    public virtual void Set(string key, T value);
    public virtual void Set(string key, T value, ConfigurationLevel level);
    public virtual void Add(string key, string value);
    public virtual void Add(string key, string value, ConfigurationLevel level);
    public virtual IEnumerable`1<ConfigurationEntry`1<string>> Find(string regexp);
    public virtual IEnumerable`1<ConfigurationEntry`1<string>> Find(string regexp, ConfigurationLevel level);
    private ConfigurationHandle RetrieveConfigurationHandle(ConfigurationLevel level, bool throwIfStoreHasNotBeenFound, ConfigurationHandle fromHandle);
    private static Action`3<string, object, ConfigurationHandle> GetUpdater(Action`3<ConfigurationHandle, string, T> setter);
    public virtual IEnumerator`1<ConfigurationEntry`1<string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IEnumerable`1<ConfigurationEntry`1<string>> BuildConfigEntries();
    internal static ConfigurationEntry`1<string> BuildConfigEntry(IntPtr entryPtr);
    public virtual Signature BuildSignature(DateTimeOffset now);
    internal Signature BuildSignatureOrThrow(DateTimeOffset now);
    private ConfigurationHandle Snapshot();
    public virtual void WithinTransaction(Action action);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.ConfigurationEntry`1 : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationLevel <Level>k__BackingField;
    public string Key { get; private set; }
    public T Value { get; private set; }
    public ConfigurationLevel Level { get; private set; }
    private string DebuggerDisplay { get; }
    protected internal ConfigurationEntry`1(string key, T value, ConfigurationLevel level);
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public virtual T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    [CompilerGeneratedAttribute]
public virtual ConfigurationLevel get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(ConfigurationLevel value);
    private string get_DebuggerDisplay();
}
public enum LibGit2Sharp.ConfigurationLevel : Enum {
    public int value__;
    public static ConfigurationLevel Local;
    public static ConfigurationLevel Global;
    public static ConfigurationLevel Xdg;
    public static ConfigurationLevel System;
    public static ConfigurationLevel ProgramData;
}
public class LibGit2Sharp.Conflict : object {
    private IndexEntry ancestor;
    private IndexEntry ours;
    private IndexEntry theirs;
    private static LambdaEqualityHelper`1<Conflict> equalityHelper;
    public IndexEntry Ancestor { get; }
    public IndexEntry Ours { get; }
    public IndexEntry Theirs { get; }
    internal Conflict(IndexEntry ancestor, IndexEntry ours, IndexEntry theirs);
    private static Conflict();
    public virtual IndexEntry get_Ancestor();
    public virtual IndexEntry get_Ours();
    public virtual IndexEntry get_Theirs();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Conflict other);
    public virtual int GetHashCode();
    public static bool op_Equality(Conflict left, Conflict right);
    public static bool op_Inequality(Conflict left, Conflict right);
}
[DefaultMemberAttribute("Item")]
public class LibGit2Sharp.ConflictCollection : object {
    private Index index;
    public Conflict Item { get; }
    public IndexReucEntryCollection ResolvedConflicts { get; }
    public IndexNameEntryCollection Names { get; }
    internal ConflictCollection(Index index);
    public virtual Conflict get_Item(string path);
    public virtual IndexReucEntryCollection get_ResolvedConflicts();
    public virtual IndexNameEntryCollection get_Names();
    private List`1<Conflict> AllConflicts();
    public virtual IEnumerator`1<Conflict> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.ContentChanges : object {
    private StringBuilder patchBuilder;
    [CompilerGeneratedAttribute]
private int <LinesAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinesDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Line> <AddedLines>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Line> <DeletedLines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBinaryComparison>k__BackingField;
    public int LinesAdded { get; internal set; }
    public int LinesDeleted { get; internal set; }
    public List`1<Line> AddedLines { get; }
    public List`1<Line> DeletedLines { get; }
    public string Patch { get; }
    public bool IsBinaryComparison { get; private set; }
    private string DebuggerDisplay { get; }
    internal ContentChanges(Repository repo, Blob oldBlob, Blob newBlob, GitDiffOptions options);
    internal ContentChanges(bool isBinaryComparison);
    internal void AppendToPatch(string patch);
    [CompilerGeneratedAttribute]
public virtual int get_LinesAdded();
    [CompilerGeneratedAttribute]
internal virtual void set_LinesAdded(int value);
    [CompilerGeneratedAttribute]
public virtual int get_LinesDeleted();
    [CompilerGeneratedAttribute]
internal virtual void set_LinesDeleted(int value);
    [CompilerGeneratedAttribute]
public virtual List`1<Line> get_AddedLines();
    [CompilerGeneratedAttribute]
public virtual List`1<Line> get_DeletedLines();
    public virtual string get_Patch();
    [CompilerGeneratedAttribute]
public virtual bool get_IsBinaryComparison();
    [CompilerGeneratedAttribute]
private void set_IsBinaryComparison(bool value);
    private int FileCallback(git_diff_delta* delta, float progress, IntPtr payload);
    private int HunkCallback(git_diff_delta* delta, GitDiffHunk hunk, IntPtr payload);
    private int LineCallback(git_diff_delta* delta, GitDiffHunk hunk, GitDiffLine line, IntPtr payload);
    private string get_DebuggerDisplay();
}
public class LibGit2Sharp.ContentChangeStats : object {
    [CompilerGeneratedAttribute]
private int <LinesAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinesDeleted>k__BackingField;
    public int LinesAdded { get; private set; }
    public int LinesDeleted { get; private set; }
    internal ContentChangeStats(int added, int deleted);
    [CompilerGeneratedAttribute]
public virtual int get_LinesAdded();
    [CompilerGeneratedAttribute]
private void set_LinesAdded(int value);
    [CompilerGeneratedAttribute]
public virtual int get_LinesDeleted();
    [CompilerGeneratedAttribute]
private void set_LinesDeleted(int value);
}
internal class LibGit2Sharp.Core.ArrayMarshaler`1 : object {
    private IntPtr[] ptrs;
    public int Count { get; }
    public ArrayMarshaler`1(T[] objs);
    public int get_Count();
    public IntPtr[] ToArray();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class LibGit2Sharp.Core.BlameStrategyExtensions : object {
    [ExtensionAttribute]
public static GitBlameOptionFlags ToGitBlameOptionFlags(BlameStrategy strategy);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class LibGit2Sharp.Core.checkout_notify_cb : MulticastDelegate {
    public checkout_notify_cb(object object, IntPtr method);
    public virtual int Invoke(CheckoutNotifyFlags why, IntPtr path, IntPtr baseline, IntPtr target, IntPtr workdir, IntPtr payload);
    public virtual IAsyncResult BeginInvoke(CheckoutNotifyFlags why, IntPtr path, IntPtr baseline, IntPtr target, IntPtr workdir, IntPtr payload, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.CheckoutStrategy : Enum {
    public int value__;
    public static CheckoutStrategy GIT_CHECKOUT_NONE;
    public static CheckoutStrategy GIT_CHECKOUT_SAFE;
    public static CheckoutStrategy GIT_CHECKOUT_FORCE;
    public static CheckoutStrategy GIT_CHECKOUT_RECREATE_MISSING;
    public static CheckoutStrategy GIT_CHECKOUT_ALLOW_CONFLICTS;
    public static CheckoutStrategy GIT_CHECKOUT_REMOVE_UNTRACKED;
    public static CheckoutStrategy GIT_CHECKOUT_REMOVE_IGNORED;
    public static CheckoutStrategy GIT_CHECKOUT_UPDATE_ONLY;
    public static CheckoutStrategy GIT_CHECKOUT_DONT_UPDATE_INDEX;
    public static CheckoutStrategy GIT_CHECKOUT_NO_REFRESH;
    public static CheckoutStrategy GIT_CHECKOUT_SKIP_UNMERGED;
    public static CheckoutStrategy GIT_CHECKOUT_USE_OURS;
    public static CheckoutStrategy GIT_CHECKOUT_USE_THEIRS;
    public static CheckoutStrategy GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH;
    public static CheckoutStrategy GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES;
    public static CheckoutStrategy GIT_CHECKOUT_DONT_OVERWRITE_IGNORED;
    public static CheckoutStrategy GIT_CHECKOUT_CONFLICT_STYLE_MERGE;
    public static CheckoutStrategy GIT_CHECKOUT_CONFLICT_STYLE_DIFF3;
    public static CheckoutStrategy GIT_CHECKOUT_DONT_REMOVE_EXISTING;
    public static CheckoutStrategy GIT_CHECKOUT_DONT_WRITE_INDEX;
    public static CheckoutStrategy GIT_CHECKOUT_UPDATE_SUBMODULES;
    public static CheckoutStrategy GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED;
}
[UnmanagedFunctionPointerAttribute("2")]
internal class LibGit2Sharp.Core.diff_notify_cb : MulticastDelegate {
    public diff_notify_cb(object object, IntPtr method);
    public virtual int Invoke(IntPtr diff_so_far, IntPtr delta_to_add, IntPtr matched_pathspec, IntPtr payload);
    public virtual IAsyncResult BeginInvoke(IntPtr diff_so_far, IntPtr delta_to_add, IntPtr matched_pathspec, IntPtr payload, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class LibGit2Sharp.Core.diff_progress_cb : MulticastDelegate {
    public diff_progress_cb(object object, IntPtr method);
    public virtual int Invoke(IntPtr diff_so_far, IntPtr old_path, IntPtr new_path, IntPtr payload);
    public virtual IAsyncResult BeginInvoke(IntPtr diff_so_far, IntPtr old_path, IntPtr new_path, IntPtr payload, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal abstract class LibGit2Sharp.Core.EncodingMarshaler : object {
    private Encoding encoding;
    protected EncodingMarshaler(Encoding encoding);
    public sealed virtual void CleanUpManagedData(object managedObj);
    public virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual int GetNativeDataSize();
    public virtual IntPtr MarshalManagedToNative(object managedObj);
    public virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public static IntPtr FromManaged(Encoding encoding, string value);
    public static void Cleanup(IntPtr pNativeData);
    public static string FromNative(Encoding encoding, IntPtr pNativeData);
    public static string FromNative(Encoding encoding, Byte* pNativeData);
    public static string FromNative(Encoding encoding, IntPtr pNativeData, int length);
    public static string FromBuffer(Encoding encoding, Byte[] buffer);
    public static string FromBuffer(Encoding encoding, Byte[] buffer, int length);
}
[DebuggerStepThroughAttribute]
internal static class LibGit2Sharp.Core.Ensure : object {
    private static Dictionary`2<GitErrorCode, Func`3<string, GitErrorCategory, LibGit2SharpException>> GitErrorsToLibGit2SharpExceptions;
    private static Ensure();
    public static void ArgumentNotNull(object argumentValue, string argumentName);
    public static void ArgumentNotNullOrEmptyEnumerable(IEnumerable`1<T> argumentValue, string argumentName);
    public static void ArgumentNotNullOrEmptyString(string argumentValue, string argumentName);
    public static void ArgumentDoesNotContainZeroByte(string argumentValue, string argumentName);
    public static void ArgumentNotZeroIntPtr(IntPtr argumentValue, string argumentName);
    public static void ArgumentIsExpectedIntPtr(IntPtr argumentValue, IntPtr expectedValue, string argumentName);
    private static void HandleError(int result);
    public static void ZeroResult(int result);
    public static void BooleanResult(int result);
    public static void Int32Result(int result);
    public static void ArgumentConformsTo(T argumentValue, Func`2<T, bool> checker, string argumentName);
    public static void ArgumentPositiveInt32(long argumentValue, string argumentName);
    public static void GitObjectIsNotNull(GitObject gitObject, string identifier);
}
[ExtensionAttribute]
internal static class LibGit2Sharp.Core.EnumExtensions : object {
    [ExtensionAttribute]
public static bool HasAny(Enum enumInstance, IEnumerable`1<Enum> entries);
}
internal class LibGit2Sharp.Core.FastForwardCheckoutOptionsAdapter : object {
    private IConvertableToGitCheckoutOpts internalOptions;
    public CheckoutStrategy CheckoutStrategy { get; }
    public CheckoutNotifyFlags CheckoutNotifyFlags { get; }
    internal FastForwardCheckoutOptionsAdapter(IConvertableToGitCheckoutOpts internalOptions);
    public sealed virtual CheckoutCallbacks GenerateCallbacks();
    public sealed virtual CheckoutStrategy get_CheckoutStrategy();
    public sealed virtual CheckoutNotifyFlags get_CheckoutNotifyFlags();
}
internal enum LibGit2Sharp.Core.FetchPruneStrategy : Enum {
    public int value__;
    public static FetchPruneStrategy FromConfigurationOrDefault;
    public static FetchPruneStrategy Prune;
    public static FetchPruneStrategy NoPrune;
}
internal class LibGit2Sharp.Core.FileHistory : object {
    private static List`1<CommitSortStrategies> AllowedSortStrategies;
    private Repository _repo;
    private string _path;
    private CommitFilter _queryFilter;
    internal FileHistory(Repository repo, string path);
    internal FileHistory(Repository repo, string path, CommitFilter queryFilter);
    private static FileHistory();
    public sealed virtual IEnumerator`1<LogEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("LibGit2Sharp.Core.FileHistory/<FullHistory>d__8")]
private static IEnumerable`1<LogEntry> FullHistory(IRepository repo, string path, CommitFilter filter);
    private static void DetermineParentPaths(IRepository repo, Commit currentCommit, string currentPath, IDictionary`2<Commit, string> map);
    private static string ParentPath(IRepository repo, Commit currentCommit, string currentPath, Commit parentCommit);
}
internal class LibGit2Sharp.Core.FilePath : object {
    internal static FilePath Empty;
    private static char posixDirectorySeparatorChar;
    private string native;
    private string posix;
    public string Native { get; }
    public string Posix { get; }
    private FilePath(string path);
    private static FilePath();
    public string get_Native();
    public string get_Posix();
    public virtual string ToString();
    public static FilePath op_Implicit(string path);
    private static string Replace(string path, char oldChar, char newChar);
    public sealed virtual bool Equals(FilePath other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class LibGit2Sharp.Core.FilePathExtensions : object {
    [ExtensionAttribute]
internal static FilePath Combine(FilePath filePath, string childPath);
    [ExtensionAttribute]
internal static bool IsNullOrEmpty(FilePath filePath);
}
internal class LibGit2Sharp.Core.git_annotated_commit : ValueType {
}
internal class LibGit2Sharp.Core.git_blame : ValueType {
}
internal class LibGit2Sharp.Core.git_blame_hunk : ValueType {
    public UIntPtr lines_in_hunk;
    public git_oid final_commit_id;
    public UIntPtr final_start_line_number;
    public git_signature* final_signature;
    public git_oid orig_commit_id;
    public Char* orig_path;
    public UIntPtr orig_start_line_number;
    public git_signature* orig_signature;
    public byte boundary;
}
internal class LibGit2Sharp.Core.git_blame_options : object {
    public UInt32 version;
    public GitBlameOptionFlags flags;
    public ushort min_match_characters;
    public git_oid newest_commit;
    public git_oid oldest_commit;
    public UIntPtr min_line;
    public UIntPtr max_line;
}
internal class LibGit2Sharp.Core.git_certificate : ValueType {
    public GitCertificateType type;
}
internal class LibGit2Sharp.Core.git_certificate_ssh : ValueType {
    public GitCertificateType cert_type;
    public GitCertificateSshType type;
    [FixedBufferAttribute("System.Byte", "16")]
public <HashMD5>e__FixedBuffer HashMD5;
    [FixedBufferAttribute("System.Byte", "20")]
public <HashSHA1>e__FixedBuffer HashSHA1;
}
internal class LibGit2Sharp.Core.git_certificate_x509 : ValueType {
    public GitCertificateType cert_type;
    public Byte* data;
    public UIntPtr len;
}
internal class LibGit2Sharp.Core.git_config : ValueType {
}
internal class LibGit2Sharp.Core.git_describe_result : ValueType {
}
internal class LibGit2Sharp.Core.git_diff : ValueType {
}
internal class LibGit2Sharp.Core.git_diff_delta : ValueType {
    public ChangeKind status;
    public GitDiffFlags flags;
    public ushort similarity;
    public ushort nfiles;
    public git_diff_file old_file;
    public git_diff_file new_file;
}
internal class LibGit2Sharp.Core.git_diff_file : ValueType {
    public git_oid Id;
    public Char* Path;
    public long Size;
    public GitDiffFlags Flags;
    public ushort Mode;
    public ushort IdAbbrev;
}
internal class LibGit2Sharp.Core.git_filter_source : ValueType {
    public git_repository* repository;
    public Char* path;
    public git_oid oid;
}
internal class LibGit2Sharp.Core.git_index : ValueType {
}
internal class LibGit2Sharp.Core.git_index_conflict_iterator : ValueType {
}
internal class LibGit2Sharp.Core.git_index_entry : ValueType {
    internal static ushort GIT_IDXENTRY_VALID;
    public git_index_mtime ctime;
    public git_index_mtime mtime;
    public UInt32 dev;
    public UInt32 ino;
    public UInt32 mode;
    public UInt32 uid;
    public UInt32 gid;
    public UInt32 file_size;
    public git_oid id;
    public ushort flags;
    public ushort extended_flags;
    public Char* path;
}
internal class LibGit2Sharp.Core.git_index_mtime : ValueType {
    public int seconds;
    public UInt32 nanoseconds;
}
internal class LibGit2Sharp.Core.git_index_name_entry : ValueType {
    public Char* ancestor;
    public Char* ours;
    public Char* theirs;
}
internal class LibGit2Sharp.Core.git_index_reuc_entry : ValueType {
    public UInt32 AncestorMode;
    public UInt32 OurMode;
    public UInt32 TheirMode;
    public git_oid AncestorId;
    public git_oid OurId;
    public git_oid TheirId;
    public Char* Path;
}
internal class LibGit2Sharp.Core.git_note : ValueType {
}
internal class LibGit2Sharp.Core.git_object : ValueType {
}
internal class LibGit2Sharp.Core.git_odb : ValueType {
}
internal class LibGit2Sharp.Core.git_odb_stream : ValueType {
}
internal class LibGit2Sharp.Core.git_oid : ValueType {
    public static int Size;
    [FixedBufferAttribute("System.Byte", "20")]
public <Id>e__FixedBuffer Id;
}
internal class LibGit2Sharp.Core.git_packbuilder : ValueType {
}
internal class LibGit2Sharp.Core.git_patch : ValueType {
}
internal class LibGit2Sharp.Core.git_push_update : ValueType {
    public Char* src_refname;
    public Char* dst_refname;
    public git_oid src;
    public git_oid dst;
}
internal class LibGit2Sharp.Core.git_rebase : ValueType {
}
internal class LibGit2Sharp.Core.git_rebase_operation : ValueType {
    internal RebaseStepOperation type;
    internal git_oid id;
    internal Char* exec;
}
internal class LibGit2Sharp.Core.git_reference : ValueType {
}
internal class LibGit2Sharp.Core.git_reflog : ValueType {
}
internal class LibGit2Sharp.Core.git_reflog_entry : ValueType {
}
internal class LibGit2Sharp.Core.git_refspec : ValueType {
}
internal class LibGit2Sharp.Core.git_remote : ValueType {
}
internal class LibGit2Sharp.Core.git_remote_head : ValueType {
    public int Local;
    public git_oid Oid;
    public git_oid Loid;
    public Char* Name;
    public Char* SymrefTarget;
}
internal class LibGit2Sharp.Core.git_repository : ValueType {
}
internal class LibGit2Sharp.Core.git_revwalk : ValueType {
}
internal class LibGit2Sharp.Core.git_signature : ValueType {
    public Char* name;
    public Char* email;
    public git_time when;
}
internal class LibGit2Sharp.Core.git_status_entry : ValueType {
    public FileStatus status;
    public git_diff_delta* head_to_index;
    public git_diff_delta* index_to_workdir;
}
internal class LibGit2Sharp.Core.git_status_list : ValueType {
}
internal class LibGit2Sharp.Core.git_submodule : ValueType {
}
internal class LibGit2Sharp.Core.git_time : ValueType {
    public long time;
    public int offset;
}
internal class LibGit2Sharp.Core.git_tree_entry : ValueType {
}
internal class LibGit2Sharp.Core.git_treebuilder : ValueType {
}
internal class LibGit2Sharp.Core.git_worktree : ValueType {
}
internal class LibGit2Sharp.Core.git_worktree_add_options : object {
    public UInt32 version;
    public int locked;
    public IntPtr ref;
}
internal class LibGit2Sharp.Core.git_worktree_prune_options : object {
    public UInt32 version;
    public GitWorktreePruneOptionFlags flags;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitBlameOptionFlags : Enum {
    public int value__;
    public static GitBlameOptionFlags GIT_BLAME_NORMAL;
    public static GitBlameOptionFlags GIT_BLAME_TRACK_COPIES_SAME_FILE;
    public static GitBlameOptionFlags GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES;
    public static GitBlameOptionFlags GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES;
    public static GitBlameOptionFlags GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES;
    public static GitBlameOptionFlags GIT_BLAME_FIRST_PARENT;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitBranchType : Enum {
    public int value__;
    public static GitBranchType GIT_BRANCH_LOCAL;
    public static GitBranchType GIT_BRANCH_REMOTE;
    public static GitBranchType GIT_BRANCH_ALL;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitCertificateSshType : Enum {
    public int value__;
    public static GitCertificateSshType MD5;
    public static GitCertificateSshType SHA1;
}
internal enum LibGit2Sharp.Core.GitCertificateType : Enum {
    public int value__;
    public static GitCertificateType None;
    public static GitCertificateType X509;
    public static GitCertificateType Hostkey;
    public static GitCertificateType StrArray;
}
internal class LibGit2Sharp.Core.GitCheckoutOpts : ValueType {
    public UInt32 version;
    public CheckoutStrategy checkout_strategy;
    public int DisableFilters;
    public UInt32 DirMode;
    public UInt32 FileMode;
    public int FileOpenFlags;
    public CheckoutNotifyFlags notify_flags;
    public checkout_notify_cb notify_cb;
    public IntPtr notify_payload;
    public progress_cb progress_cb;
    public IntPtr progress_payload;
    public GitStrArray paths;
    public IntPtr baseline;
    public IntPtr baseline_index;
    public IntPtr target_directory;
    public IntPtr ancestor_label;
    public IntPtr our_label;
    public IntPtr their_label;
    public perfdata_cb perfdata_cb;
    public IntPtr perfdata_payload;
}
internal class LibGit2Sharp.Core.GitCheckoutOptsWrapper : object {
    [CompilerGeneratedAttribute]
private GitCheckoutOpts <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutCallbacks <Callbacks>k__BackingField;
    private GitStrArrayManaged PathArray;
    public GitCheckoutOpts Options { get; public set; }
    public CheckoutCallbacks Callbacks { get; private set; }
    public GitCheckoutOptsWrapper(IConvertableToGitCheckoutOpts options, FilePath[] paths);
    [CompilerGeneratedAttribute]
public GitCheckoutOpts get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(GitCheckoutOpts value);
    [CompilerGeneratedAttribute]
public CheckoutCallbacks get_Callbacks();
    [CompilerGeneratedAttribute]
private void set_Callbacks(CheckoutCallbacks value);
    public sealed virtual void Dispose();
    internal static CheckoutStrategy CheckoutStrategyFromFileConflictStrategy(CheckoutFileConflictStrategy fileConflictStrategy);
}
internal class LibGit2Sharp.Core.GitCherryPickOptions : object {
    public UInt32 Version;
    public UInt32 Mainline;
    public GitMergeOpts MergeOpts;
    public GitCheckoutOpts CheckoutOpts;
}
internal enum LibGit2Sharp.Core.GitCloneLocal : Enum {
    public int value__;
    public static GitCloneLocal CloneLocalAuto;
    public static GitCloneLocal CloneLocal;
    public static GitCloneLocal CloneNoLocal;
    public static GitCloneLocal CloneLocalNoLinks;
}
internal class LibGit2Sharp.Core.GitCloneOptions : ValueType {
    public UInt32 Version;
    public GitCheckoutOpts CheckoutOpts;
    public GitFetchOptions FetchOpts;
    public int Bare;
    public GitCloneLocal Local;
    public IntPtr CheckoutBranch;
    public IntPtr RepositoryCb;
    public IntPtr RepositoryCbPayload;
    public IntPtr RemoteCb;
    public IntPtr RemoteCbPayload;
}
internal class LibGit2Sharp.Core.GitConfigEntry : ValueType {
    public Char* namePtr;
    public Char* valuePtr;
    public UInt32 include_depth;
    public UInt32 level;
    public Void* freePtr;
    public Void* payloadPtr;
}
internal class LibGit2Sharp.Core.GitCredential : ValueType {
    public GitCredentialType credtype;
    public IntPtr free;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitCredentialType : Enum {
    public int value__;
    public static GitCredentialType UserPassPlaintext;
    public static GitCredentialType SshKey;
    public static GitCredentialType SshCustom;
    public static GitCredentialType Default;
    public static GitCredentialType SshInteractive;
    public static GitCredentialType Username;
    public static GitCredentialType SshMemory;
}
internal class LibGit2Sharp.Core.GitCredentialUserpass : ValueType {
    public GitCredential parent;
    public Char* username;
    public Char* password;
}
internal class LibGit2Sharp.Core.GitDescribeFormatOptions : ValueType {
    public UInt32 Version;
    public UInt32 MinAbbreviatedSize;
    public bool AlwaysUseLongFormat;
    public IntPtr DirtySuffix;
}
internal class LibGit2Sharp.Core.GitDescribeOptions : ValueType {
    public UInt32 Version;
    public UInt32 MaxCandidatesTags;
    public DescribeStrategy DescribeStrategy;
    public IntPtr Pattern;
    public bool OnlyFollowFirstParent;
    public bool ShowCommitOidAsFallback;
}
internal class LibGit2Sharp.Core.GitDiffBinary : object {
    public UInt32 ContainsData;
    public GitDiffBinaryFile OldFile;
    public GitDiffBinaryFile NewFile;
}
internal class LibGit2Sharp.Core.GitDiffBinaryFile : object {
    public GitDiffBinaryType Type;
    public IntPtr Data;
    public UIntPtr DataLen;
    public UIntPtr InflatedLen;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitDiffBinaryType : Enum {
    public int value__;
    public static GitDiffBinaryType GIT_DIFF_BINARY_NONE;
    public static GitDiffBinaryType GIT_DIFF_BINARY_LITERAL;
    public static GitDiffBinaryType GIT_DIFF_BINARY_DELTA;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitDiffFindFlags : Enum {
    public int value__;
    public static GitDiffFindFlags GIT_DIFF_FIND_BY_CONFIG;
    public static GitDiffFindFlags GIT_DIFF_FIND_RENAMES;
    public static GitDiffFindFlags GIT_DIFF_FIND_RENAMES_FROM_REWRITES;
    public static GitDiffFindFlags GIT_DIFF_FIND_COPIES;
    public static GitDiffFindFlags GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED;
    public static GitDiffFindFlags GIT_DIFF_FIND_REWRITES;
    public static GitDiffFindFlags GIT_DIFF_BREAK_REWRITES;
    public static GitDiffFindFlags GIT_DIFF_FIND_AND_BREAK_REWRITES;
    public static GitDiffFindFlags GIT_DIFF_FIND_FOR_UNTRACKED;
    public static GitDiffFindFlags GIT_DIFF_FIND_ALL;
    public static GitDiffFindFlags GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE;
    public static GitDiffFindFlags GIT_DIFF_FIND_IGNORE_WHITESPACE;
    public static GitDiffFindFlags GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE;
    public static GitDiffFindFlags GIT_DIFF_FIND_EXACT_MATCH_ONLY;
    public static GitDiffFindFlags GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY;
    public static GitDiffFindFlags GIT_DIFF_FIND_REMOVE_UNMODIFIED;
}
internal class LibGit2Sharp.Core.GitDiffFindOptions : object {
    public UInt32 Version;
    public GitDiffFindFlags Flags;
    public ushort RenameThreshold;
    public ushort RenameFromRewriteThreshold;
    public ushort CopyThreshold;
    public ushort BreakRewriteThreshold;
    public UIntPtr RenameLimit;
    public IntPtr SimilarityMetric;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitDiffFlags : Enum {
    public int value__;
    public static GitDiffFlags GIT_DIFF_FLAG_BINARY;
    public static GitDiffFlags GIT_DIFF_FLAG_NOT_BINARY;
    public static GitDiffFlags GIT_DIFF_FLAG_VALID_ID;
    public static GitDiffFlags GIT_DIFF_FLAG_EXISTS;
}
internal enum LibGit2Sharp.Core.GitDiffFormat : Enum {
    public int value__;
    public static GitDiffFormat GIT_DIFF_FORMAT_PATCH;
    public static GitDiffFormat GIT_DIFF_FORMAT_PATCH_HEADER;
    public static GitDiffFormat GIT_DIFF_FORMAT_RAW;
    public static GitDiffFormat GIT_DIFF_FORMAT_NAME_ONLY;
    public static GitDiffFormat GIT_DIFF_FORMAT_NAME_STATUS;
}
internal class LibGit2Sharp.Core.GitDiffHunk : object {
    public int OldStart;
    public int OldLines;
    public int NewStart;
    public int NewLines;
    public UIntPtr HeaderLen;
    public Byte[] Header;
}
internal class LibGit2Sharp.Core.GitDiffLine : object {
    public GitDiffLineOrigin lineOrigin;
    public int OldLineNo;
    public int NewLineNo;
    public int NumLines;
    public UIntPtr contentLen;
    public long contentOffset;
    public IntPtr content;
}
internal enum LibGit2Sharp.Core.GitDiffLineOrigin : Enum {
    public byte value__;
    public static GitDiffLineOrigin GIT_DIFF_LINE_CONTEXT;
    public static GitDiffLineOrigin GIT_DIFF_LINE_ADDITION;
    public static GitDiffLineOrigin GIT_DIFF_LINE_DELETION;
    public static GitDiffLineOrigin GIT_DIFF_LINE_ADD_EOFNL;
    public static GitDiffLineOrigin GIT_DIFF_LINE_DEL_EOFNL;
    public static GitDiffLineOrigin GIT_DIFF_LINE_FILE_HDR;
    public static GitDiffLineOrigin GIT_DIFF_LINE_HUNK_HDR;
    public static GitDiffLineOrigin GIT_DIFF_LINE_BINARY;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitDiffOptionFlags : Enum {
    public int value__;
    public static GitDiffOptionFlags GIT_DIFF_NORMAL;
    public static GitDiffOptionFlags GIT_DIFF_REVERSE;
    public static GitDiffOptionFlags GIT_DIFF_INCLUDE_IGNORED;
    public static GitDiffOptionFlags GIT_DIFF_RECURSE_IGNORED_DIRS;
    public static GitDiffOptionFlags GIT_DIFF_INCLUDE_UNTRACKED;
    public static GitDiffOptionFlags GIT_DIFF_RECURSE_UNTRACKED_DIRS;
    public static GitDiffOptionFlags GIT_DIFF_INCLUDE_UNMODIFIED;
    public static GitDiffOptionFlags GIT_DIFF_INCLUDE_TYPECHANGE;
    public static GitDiffOptionFlags GIT_DIFF_INCLUDE_TYPECHANGE_TREES;
    public static GitDiffOptionFlags GIT_DIFF_IGNORE_FILEMODE;
    public static GitDiffOptionFlags GIT_DIFF_IGNORE_SUBMODULES;
    public static GitDiffOptionFlags GIT_DIFF_IGNORE_CASE;
    public static GitDiffOptionFlags GIT_DIFF_INCLUDE_CASECHANGE;
    public static GitDiffOptionFlags GIT_DIFF_DISABLE_PATHSPEC_MATCH;
    public static GitDiffOptionFlags GIT_DIFF_SKIP_BINARY_CHECK;
    public static GitDiffOptionFlags GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS;
    public static GitDiffOptionFlags GIT_DIFF_UPDATE_INDEX;
    public static GitDiffOptionFlags GIT_DIFF_INCLUDE_UNREADABLE;
    public static GitDiffOptionFlags GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED;
    public static GitDiffOptionFlags GIT_DIFF_INDENT_HEURISTIC;
    public static GitDiffOptionFlags GIT_DIFF_FORCE_TEXT;
    public static GitDiffOptionFlags GIT_DIFF_FORCE_BINARY;
    public static GitDiffOptionFlags GIT_DIFF_IGNORE_WHITESPACE;
    public static GitDiffOptionFlags GIT_DIFF_IGNORE_WHITESPACE_CHANGE;
    public static GitDiffOptionFlags GIT_DIFF_IGNORE_WHITESPACE_EOL;
    public static GitDiffOptionFlags GIT_DIFF_SHOW_UNTRACKED_CONTENT;
    public static GitDiffOptionFlags GIT_DIFF_SHOW_UNMODIFIED;
    public static GitDiffOptionFlags GIT_DIFF_PATIENCE;
    public static GitDiffOptionFlags GIT_DIFF_MINIMAL;
    public static GitDiffOptionFlags GIT_DIFF_SHOW_BINARY;
}
internal class LibGit2Sharp.Core.GitDiffOptions : object {
    public UInt32 Version;
    public GitDiffOptionFlags Flags;
    public SubmoduleIgnore IgnoreSubmodules;
    public GitStrArrayManaged PathSpec;
    public diff_notify_cb NotifyCallback;
    public diff_progress_cb ProgressCallback;
    public IntPtr Payload;
    public UInt32 ContextLines;
    public UInt32 InterhunkLines;
    public ushort IdAbbrev;
    public long MaxSize;
    public IntPtr OldPrefixString;
    public IntPtr NewPrefixString;
    public sealed virtual void Dispose();
}
internal enum LibGit2Sharp.Core.GitDirection : Enum {
    public int value__;
    public static GitDirection Fetch;
    public static GitDirection Push;
}
internal class LibGit2Sharp.Core.GitError : ValueType {
    public Char* Message;
    public GitErrorCategory Category;
}
internal enum LibGit2Sharp.Core.GitErrorCategory : Enum {
    public int value__;
    public static GitErrorCategory Unknown;
    public static GitErrorCategory None;
    public static GitErrorCategory NoMemory;
    public static GitErrorCategory Os;
    public static GitErrorCategory Invalid;
    public static GitErrorCategory Reference;
    public static GitErrorCategory Zlib;
    public static GitErrorCategory Repository;
    public static GitErrorCategory Config;
    public static GitErrorCategory Regex;
    public static GitErrorCategory Odb;
    public static GitErrorCategory Index;
    public static GitErrorCategory Object;
    public static GitErrorCategory Net;
    public static GitErrorCategory Tag;
    public static GitErrorCategory Tree;
    public static GitErrorCategory Indexer;
    public static GitErrorCategory Ssl;
    public static GitErrorCategory Submodule;
    public static GitErrorCategory Thread;
    public static GitErrorCategory Stash;
    public static GitErrorCategory Checkout;
    public static GitErrorCategory FetchHead;
    public static GitErrorCategory Merge;
    public static GitErrorCategory Ssh;
    public static GitErrorCategory Filter;
    public static GitErrorCategory Revert;
    public static GitErrorCategory Callback;
    public static GitErrorCategory CherryPick;
    public static GitErrorCategory Describe;
    public static GitErrorCategory Rebase;
    public static GitErrorCategory Filesystem;
    public static GitErrorCategory Patch;
    public static GitErrorCategory Worktree;
    public static GitErrorCategory Sha1;
}
internal enum LibGit2Sharp.Core.GitErrorCode : Enum {
    public int value__;
    public static GitErrorCode Ok;
    public static GitErrorCode Error;
    public static GitErrorCode NotFound;
    public static GitErrorCode Exists;
    public static GitErrorCode Ambiguous;
    public static GitErrorCode Buffer;
    public static GitErrorCode User;
    public static GitErrorCode BareRepo;
    public static GitErrorCode OrphanedHead;
    public static GitErrorCode UnmergedEntries;
    public static GitErrorCode NonFastForward;
    public static GitErrorCode InvalidSpecification;
    public static GitErrorCode Conflict;
    public static GitErrorCode LockedFile;
    public static GitErrorCode Modified;
    public static GitErrorCode Auth;
    public static GitErrorCode Certificate;
    public static GitErrorCode Applied;
    public static GitErrorCode Peel;
    public static GitErrorCode EndOfFile;
    public static GitErrorCode Invalid;
    public static GitErrorCode Uncommitted;
    public static GitErrorCode Directory;
    public static GitErrorCode MergeConflict;
    public static GitErrorCode PassThrough;
    public static GitErrorCode IterOver;
    public static GitErrorCode Retry;
    public static GitErrorCode Mismatch;
}
internal class LibGit2Sharp.Core.GitFetchOptions : object {
    public int Version;
    public GitRemoteCallbacks RemoteCallbacks;
    public FetchPruneStrategy Prune;
    public bool UpdateFetchHead;
    public TagFetchMode download_tags;
    public GitProxyOptions ProxyOptions;
    public GitStrArrayManaged CustomHeaders;
}
internal class LibGit2Sharp.Core.GitFetchOptionsWrapper : object {
    [CompilerGeneratedAttribute]
private GitFetchOptions <Options>k__BackingField;
    private bool disposedValue;
    public GitFetchOptions Options { get; private set; }
    public GitFetchOptionsWrapper(GitFetchOptions fetchOptions);
    [CompilerGeneratedAttribute]
public GitFetchOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(GitFetchOptions value);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class LibGit2Sharp.Core.GitFilter : object {
    public UInt32 version;
    public IntPtr attributes;
    public git_filter_init_fn init;
    public git_filter_shutdown_fn shutdown;
    public git_filter_check_fn check;
    public git_filter_apply_fn apply;
    public git_filter_stream_fn stream;
    public git_filter_cleanup_fn cleanup;
}
internal class LibGit2Sharp.Core.GitIndexTime : object {
    public int seconds;
    public UInt32 nanoseconds;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitMergeAnalysis : Enum {
    public int value__;
    public static GitMergeAnalysis GIT_MERGE_ANALYSIS_NONE;
    public static GitMergeAnalysis GIT_MERGE_ANALYSIS_NORMAL;
    public static GitMergeAnalysis GIT_MERGE_ANALYSIS_UP_TO_DATE;
    public static GitMergeAnalysis GIT_MERGE_ANALYSIS_FASTFORWARD;
    public static GitMergeAnalysis GIT_MERGE_ANALYSIS_UNBORN;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitMergeFileFlag : Enum {
    public int value__;
    public static GitMergeFileFlag GIT_MERGE_FILE_DEFAULT;
    public static GitMergeFileFlag GIT_MERGE_FILE_STYLE_MERGE;
    public static GitMergeFileFlag GIT_MERGE_FILE_STYLE_DIFF3;
    public static GitMergeFileFlag GIT_MERGE_FILE_SIMPLIFY_ALNUM;
    public static GitMergeFileFlag GIT_MERGE_FILE_IGNORE_WHITESPACE;
    public static GitMergeFileFlag GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE;
    public static GitMergeFileFlag GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL;
    public static GitMergeFileFlag GIT_MERGE_FILE_DIFF_PATIENCE;
    public static GitMergeFileFlag GIT_MERGE_FILE_DIFF_MINIMAL;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitMergeFlag : Enum {
    public int value__;
    public static GitMergeFlag GIT_MERGE_NORMAL;
    public static GitMergeFlag GIT_MERGE_FIND_RENAMES;
    public static GitMergeFlag GIT_MERGE_FAIL_ON_CONFLICT;
    public static GitMergeFlag GIT_MERGE_SKIP_REUC;
    public static GitMergeFlag GIT_MERGE_NO_RECURSIVE;
}
internal class LibGit2Sharp.Core.GitMergeOpts : ValueType {
    public UInt32 Version;
    public GitMergeFlag MergeTreeFlags;
    public UInt32 RenameThreshold;
    public UInt32 TargetLimit;
    public IntPtr SimilarityMetric;
    public UInt32 RecursionLimit;
    public string DefaultDriver;
    public MergeFileFavor MergeFileFavorFlags;
    public GitMergeFileFlag FileFlags;
}
internal enum LibGit2Sharp.Core.GitMergePreference : Enum {
    public int value__;
    public static GitMergePreference GIT_MERGE_PREFERENCE_NONE;
    public static GitMergePreference GIT_MERGE_PREFERENCE_NO_FASTFORWARD;
    public static GitMergePreference GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY;
}
internal class LibGit2Sharp.Core.GitObjectLazyGroup : LazyGroup`1<ObjectHandle> {
    private ObjectId id;
    public GitObjectLazyGroup(Repository repo, ObjectId id);
    protected virtual void EvaluateInternal(Action`1<ObjectHandle> evaluator);
    public static ILazy`1<TResult> Singleton(Repository repo, ObjectId id, Func`2<ObjectHandle, TResult> resultSelector, bool throwIfMissing);
}
internal enum LibGit2Sharp.Core.GitObjectType : Enum {
    public int value__;
    public static GitObjectType Any;
    public static GitObjectType Bad;
    public static GitObjectType Ext1;
    public static GitObjectType Commit;
    public static GitObjectType Tree;
    public static GitObjectType Blob;
    public static GitObjectType Tag;
    public static GitObjectType Ext2;
    public static GitObjectType OfsDelta;
    public static GitObjectType RefDelta;
}
[ExtensionAttribute]
internal static class LibGit2Sharp.Core.GitObjectTypeExtensions : object {
    [ExtensionAttribute]
public static TreeEntryTargetType ToTreeEntryTargetType(GitObjectType type);
    [ExtensionAttribute]
public static ObjectType ToObjectType(GitObjectType type);
}
internal class LibGit2Sharp.Core.GitOdbBackend : ValueType {
    public UInt32 Version;
    private IntPtr Odb;
    public read_callback Read;
    public read_prefix_callback ReadPrefix;
    public read_header_callback ReadHeader;
    public write_callback Write;
    public writestream_callback WriteStream;
    public readstream_callback ReadStream;
    public exists_callback Exists;
    public exists_prefix_callback ExistsPrefix;
    public IntPtr Refresh;
    public foreach_callback Foreach;
    private IntPtr Padding;
    public IntPtr Writepack;
    public IntPtr Freshen;
    public free_callback Free;
    public IntPtr GCHandle;
    public static int GCHandleOffset;
    private static GitOdbBackend();
}
internal class LibGit2Sharp.Core.GitOdbBackendStream : object {
    public IntPtr Backend;
    public GitOdbBackendStreamMode Mode;
    public IntPtr HashCtx;
    public long DeclaredSize;
    public long ReceivedBytes;
    public read_callback Read;
    public write_callback Write;
    public finalize_write_callback FinalizeWrite;
    public free_callback Free;
    public IntPtr GCHandle;
    public static int GCHandleOffset;
    private static GitOdbBackendStream();
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitOdbBackendStreamMode : Enum {
    public int value__;
    public static GitOdbBackendStreamMode Read;
    public static GitOdbBackendStreamMode Write;
}
internal class LibGit2Sharp.Core.GitOid : ValueType {
    public static int Size;
    public Byte[] Id;
    public static GitOid Empty { get; }
    public static ObjectId op_Implicit(GitOid oid);
    public static ObjectId op_Implicit(Nullable`1<GitOid> oid);
    public static GitOid get_Empty();
}
internal class LibGit2Sharp.Core.GitProxyOptions : ValueType {
    public UInt32 Version;
    public GitProxyType Type;
    public IntPtr Url;
    public IntPtr CredentialsCb;
    public IntPtr CertificateCheck;
    public IntPtr CbPayload;
}
internal enum LibGit2Sharp.Core.GitProxyType : Enum {
    public int value__;
    public static GitProxyType None;
    public static GitProxyType Auto;
    public static GitProxyType Specified;
}
internal class LibGit2Sharp.Core.GitPushOptions : object {
    public int Version;
    public int PackbuilderDegreeOfParallelism;
    public GitRemoteCallbacks RemoteCallbacks;
    public GitProxyOptions ProxyOptions;
    public GitStrArrayManaged CustomHeaders;
}
internal class LibGit2Sharp.Core.GitRebaseOptions : object {
    public UInt32 version;
    public int quiet;
    public int inmemory;
    public IntPtr rewrite_notes_ref;
    public GitMergeOpts merge_options;
    public GitCheckoutOpts checkout_options;
    private IntPtr padding;
    public commit_signing_callback signing_callback;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitReferenceType : Enum {
    public int value__;
    public static GitReferenceType Invalid;
    public static GitReferenceType Oid;
    public static GitReferenceType Symbolic;
    public static GitReferenceType Packed;
    public static GitReferenceType Peel;
    public static GitReferenceType ListAll;
}
internal class LibGit2Sharp.Core.GitRemoteCallbacks : ValueType {
    internal UInt32 version;
    internal remote_progress_callback progress;
    internal remote_completion_callback completion;
    internal git_cred_acquire_cb acquire_credentials;
    internal git_transport_certificate_check_cb certificate_check;
    internal git_transfer_progress_callback download_progress;
    internal remote_update_tips_callback update_tips;
    internal git_packbuilder_progress pack_progress;
    internal git_push_transfer_progress push_transfer_progress;
    internal push_update_reference_callback push_update_reference;
    internal push_negotiation_callback push_negotiation;
    internal IntPtr transport;
    private IntPtr padding;
    internal IntPtr payload;
    internal url_resolve_callback resolve_url;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitRepositoryInitFlags : Enum {
    public int value__;
    public static GitRepositoryInitFlags GIT_REPOSITORY_INIT_BARE;
    public static GitRepositoryInitFlags GIT_REPOSITORY_INIT_NO_REINIT;
    public static GitRepositoryInitFlags GIT_REPOSITORY_INIT_NO_DOTGIT_DIR;
    public static GitRepositoryInitFlags GIT_REPOSITORY_INIT_MKDIR;
    public static GitRepositoryInitFlags GIT_REPOSITORY_INIT_MKPATH;
    public static GitRepositoryInitFlags GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE;
}
internal class LibGit2Sharp.Core.GitRepositoryInitOptions : object {
    public UInt32 Version;
    public GitRepositoryInitFlags Flags;
    public int Mode;
    public IntPtr WorkDirPath;
    public IntPtr Description;
    public IntPtr TemplatePath;
    public IntPtr InitialHead;
    public IntPtr OriginUrl;
    public static GitRepositoryInitOptions BuildFrom(FilePath workdirPath, bool isBare);
    public sealed virtual void Dispose();
}
internal class LibGit2Sharp.Core.GitRevertOpts : object {
    public UInt32 Version;
    public UInt32 Mainline;
    public GitMergeOpts MergeOpts;
    public GitCheckoutOpts CheckoutOpts;
}
internal class LibGit2Sharp.Core.GitSmartSubtransport : object {
    public action_callback Action;
    public close_callback Close;
    public free_callback Free;
    public IntPtr GCHandle;
    public static int GCHandleOffset;
    private static GitSmartSubtransport();
}
internal class LibGit2Sharp.Core.GitSmartSubtransportRegistration : object {
    public IntPtr SubtransportCallback;
    public UInt32 Rpc;
    public UInt32 Param;
}
internal class LibGit2Sharp.Core.GitSmartSubtransportStream : object {
    public IntPtr SmartTransport;
    public read_callback Read;
    public write_callback Write;
    public free_callback Free;
    public IntPtr GCHandle;
    public static int GCHandleOffset;
    private static GitSmartSubtransportStream();
}
internal class LibGit2Sharp.Core.GitStashApplyOpts : object {
    public UInt32 Version;
    public StashApplyModifiers Flags;
    public GitCheckoutOpts CheckoutOptions;
    public stash_apply_progress_cb ApplyProgressCallback;
    public IntPtr ProgressPayload;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitStatusOptionFlags : Enum {
    public int value__;
    public static GitStatusOptionFlags IncludeUntracked;
    public static GitStatusOptionFlags IncludeIgnored;
    public static GitStatusOptionFlags IncludeUnmodified;
    public static GitStatusOptionFlags ExcludeSubmodules;
    public static GitStatusOptionFlags RecurseUntrackedDirs;
    public static GitStatusOptionFlags DisablePathspecMatch;
    public static GitStatusOptionFlags RecurseIgnoredDirs;
    public static GitStatusOptionFlags RenamesHeadToIndex;
    public static GitStatusOptionFlags RenamesIndexToWorkDir;
    public static GitStatusOptionFlags SortCaseSensitively;
    public static GitStatusOptionFlags SortCaseInsensitively;
    public static GitStatusOptionFlags RenamesFromRewrites;
    public static GitStatusOptionFlags NoRefresh;
    public static GitStatusOptionFlags UpdateIndex;
    public static GitStatusOptionFlags IncludeUnreadable;
    public static GitStatusOptionFlags IncludeUnreadableAsUntracked;
}
internal class LibGit2Sharp.Core.GitStatusOptions : object {
    public UInt32 Version;
    public GitStatusShow Show;
    public GitStatusOptionFlags Flags;
    public GitStrArrayManaged PathSpec;
    public IntPtr Baseline;
    public sealed virtual void Dispose();
}
internal enum LibGit2Sharp.Core.GitStatusShow : Enum {
    public int value__;
    public static GitStatusShow IndexAndWorkDir;
    public static GitStatusShow IndexOnly;
    public static GitStatusShow WorkDirOnly;
}
internal class LibGit2Sharp.Core.GitStrArray : ValueType {
    public IntPtr Strings;
    public UIntPtr Count;
    public void Reset();
}
internal class LibGit2Sharp.Core.GitStrArrayManaged : ValueType {
    public GitStrArray Array;
    public static GitStrArrayManaged BuildFrom(String[] strings);
    public static GitStrArrayManaged BuildFrom(FilePath[] paths);
    private static GitStrArrayManaged BuildFrom(T[] input, Func`2<T, IntPtr> marshaler);
    public sealed virtual void Dispose();
}
internal class LibGit2Sharp.Core.GitStrArrayNative : ValueType {
    public GitStrArray Array;
    public String[] ReadStrings();
    public sealed virtual void Dispose();
}
internal enum LibGit2Sharp.Core.GitSubmoduleIgnore : Enum {
    public int value__;
    public static GitSubmoduleIgnore Unspecified;
    public static GitSubmoduleIgnore None;
    public static GitSubmoduleIgnore Untracked;
    public static GitSubmoduleIgnore Dirty;
    public static GitSubmoduleIgnore All;
}
internal class LibGit2Sharp.Core.GitSubmoduleUpdateOptions : ValueType {
    public UInt32 Version;
    public GitCheckoutOpts CheckoutOptions;
    public GitFetchOptions FetchOptions;
    public CheckoutStrategy CloneCheckoutStrategy;
    public int AllowFetch;
}
internal class LibGit2Sharp.Core.GitTransferProgress : ValueType {
    public UInt32 total_objects;
    public UInt32 indexed_objects;
    public UInt32 received_objects;
    public UInt32 local_objects;
    public UInt32 total_deltas;
    public UInt32 indexed_deltas;
    public UIntPtr received_bytes;
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.GitWorktreePruneOptionFlags : Enum {
    public UInt32 value__;
    public static GitWorktreePruneOptionFlags GIT_WORKTREE_PRUNE_VALID;
    public static GitWorktreePruneOptionFlags GIT_WORKTREE_PRUNE_LOCKED;
    public static GitWorktreePruneOptionFlags GIT_WORKTREE_PRUNE_WORKING_TREE;
}
internal class LibGit2Sharp.Core.GitWriteStream : ValueType {
    public write_fn write;
    public close_fn close;
    public free_fn free;
}
internal class LibGit2Sharp.Core.Handles.AnnotatedCommitHandle : Libgit2Object {
    internal AnnotatedCommitHandle(git_annotated_commit* ptr, bool owned);
    internal AnnotatedCommitHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_annotated_commit* op_Implicit(AnnotatedCommitHandle handle);
}
internal class LibGit2Sharp.Core.Handles.BlameHandle : Libgit2Object {
    internal BlameHandle(git_blame* ptr, bool owned);
    internal BlameHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_blame* op_Implicit(BlameHandle handle);
}
internal class LibGit2Sharp.Core.Handles.ConfigurationHandle : Libgit2Object {
    internal ConfigurationHandle(git_config* ptr, bool owned);
    internal ConfigurationHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_config* op_Implicit(ConfigurationHandle handle);
}
internal class LibGit2Sharp.Core.Handles.ConflictIteratorHandle : Libgit2Object {
    internal ConflictIteratorHandle(git_index_conflict_iterator* ptr, bool owned);
    internal ConflictIteratorHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_index_conflict_iterator* op_Implicit(ConflictIteratorHandle handle);
}
internal class LibGit2Sharp.Core.Handles.DescribeResultHandle : Libgit2Object {
    internal DescribeResultHandle(git_describe_result* ptr, bool owned);
    internal DescribeResultHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_describe_result* op_Implicit(DescribeResultHandle handle);
}
internal class LibGit2Sharp.Core.Handles.DiffHandle : Libgit2Object {
    internal DiffHandle(git_diff* ptr, bool owned);
    internal DiffHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_diff* op_Implicit(DiffHandle handle);
}
[ExtensionAttribute]
internal static class LibGit2Sharp.Core.Handles.DisposableExtensions : object {
    [ExtensionAttribute]
public static void SafeDispose(IDisposable disposable);
}
internal class LibGit2Sharp.Core.Handles.GitBuf : object {
    public IntPtr ptr;
    public UIntPtr asize;
    public UIntPtr size;
    public sealed virtual void Dispose();
}
internal class LibGit2Sharp.Core.Handles.IndexHandle : Libgit2Object {
    internal IndexHandle(git_index* ptr, bool owned);
    internal IndexHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_index* op_Implicit(IndexHandle handle);
}
internal abstract class LibGit2Sharp.Core.Handles.Libgit2Object : object {
    protected Void* ptr;
    private bool owned;
    private bool disposed;
    internal Void* Handle { get; }
    internal bool IsNull { get; }
    internal Libgit2Object(Void* handle, bool owned);
    internal Libgit2Object(IntPtr ptr, bool owned);
    internal Void* get_Handle();
    protected virtual override void Finalize();
    internal bool get_IsNull();
    internal IntPtr AsIntPtr();
    public abstract virtual void Free();
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class LibGit2Sharp.Core.Handles.NoteHandle : Libgit2Object {
    internal NoteHandle(git_note* ptr, bool owned);
    internal NoteHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_note* op_Implicit(NoteHandle handle);
}
internal class LibGit2Sharp.Core.Handles.ObjectDatabaseHandle : Libgit2Object {
    internal ObjectDatabaseHandle(git_odb* ptr, bool owned);
    internal ObjectDatabaseHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_odb* op_Implicit(ObjectDatabaseHandle handle);
}
internal class LibGit2Sharp.Core.Handles.ObjectHandle : Libgit2Object {
    internal ObjectHandle(git_object* ptr, bool owned);
    internal ObjectHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_object* op_Implicit(ObjectHandle handle);
}
internal class LibGit2Sharp.Core.Handles.OdbStreamHandle : Libgit2Object {
    internal OdbStreamHandle(git_odb_stream* ptr, bool owned);
    internal OdbStreamHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_odb_stream* op_Implicit(OdbStreamHandle handle);
}
internal class LibGit2Sharp.Core.Handles.PackBuilderHandle : Libgit2Object {
    internal PackBuilderHandle(git_packbuilder* ptr, bool owned);
    internal PackBuilderHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_packbuilder* op_Implicit(PackBuilderHandle handle);
}
internal class LibGit2Sharp.Core.Handles.PatchHandle : Libgit2Object {
    internal PatchHandle(git_patch* ptr, bool owned);
    internal PatchHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_patch* op_Implicit(PatchHandle handle);
}
internal class LibGit2Sharp.Core.Handles.RebaseHandle : Libgit2Object {
    internal RebaseHandle(git_rebase* ptr, bool owned);
    internal RebaseHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_rebase* op_Implicit(RebaseHandle handle);
}
internal class LibGit2Sharp.Core.Handles.ReferenceHandle : Libgit2Object {
    internal ReferenceHandle(git_reference* ptr, bool owned);
    internal ReferenceHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_reference* op_Implicit(ReferenceHandle handle);
}
internal class LibGit2Sharp.Core.Handles.ReflogHandle : Libgit2Object {
    internal ReflogHandle(git_reflog* ptr, bool owned);
    internal ReflogHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_reflog* op_Implicit(ReflogHandle handle);
}
internal class LibGit2Sharp.Core.Handles.RemoteHandle : Libgit2Object {
    internal RemoteHandle(git_remote* ptr, bool owned);
    internal RemoteHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_remote* op_Implicit(RemoteHandle handle);
}
internal class LibGit2Sharp.Core.Handles.RepositoryHandle : Libgit2Object {
    internal RepositoryHandle(git_repository* ptr, bool owned);
    internal RepositoryHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_repository* op_Implicit(RepositoryHandle handle);
}
internal class LibGit2Sharp.Core.Handles.RevWalkerHandle : Libgit2Object {
    internal RevWalkerHandle(git_revwalk* ptr, bool owned);
    internal RevWalkerHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_revwalk* op_Implicit(RevWalkerHandle handle);
}
internal class LibGit2Sharp.Core.Handles.SignatureHandle : Libgit2Object {
    internal SignatureHandle(git_signature* ptr, bool owned);
    internal SignatureHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_signature* op_Implicit(SignatureHandle handle);
}
internal class LibGit2Sharp.Core.Handles.StatusListHandle : Libgit2Object {
    internal StatusListHandle(git_status_list* ptr, bool owned);
    internal StatusListHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_status_list* op_Implicit(StatusListHandle handle);
}
internal class LibGit2Sharp.Core.Handles.SubmoduleHandle : Libgit2Object {
    internal SubmoduleHandle(git_submodule* ptr, bool owned);
    internal SubmoduleHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_submodule* op_Implicit(SubmoduleHandle handle);
}
internal class LibGit2Sharp.Core.Handles.TreeBuilderHandle : Libgit2Object {
    internal TreeBuilderHandle(git_treebuilder* ptr, bool owned);
    internal TreeBuilderHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_treebuilder* op_Implicit(TreeBuilderHandle handle);
}
internal class LibGit2Sharp.Core.Handles.TreeEntryHandle : Libgit2Object {
    internal TreeEntryHandle(git_tree_entry* ptr, bool owned);
    internal TreeEntryHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_tree_entry* op_Implicit(TreeEntryHandle handle);
}
internal class LibGit2Sharp.Core.Handles.WorktreeHandle : Libgit2Object {
    internal WorktreeHandle(git_worktree* ptr, bool owned);
    internal WorktreeHandle(IntPtr ptr, bool owned);
    public virtual void Free();
    public static git_worktree* op_Implicit(WorktreeHandle handle);
}
internal class LibGit2Sharp.Core.HistoryRewriter : object {
    private IRepository repo;
    private HashSet`1<Commit> targetedCommits;
    private Dictionary`2<GitObject, GitObject> objectMap;
    private Dictionary`2<Reference, Reference> refMap;
    private Queue`1<Action> rollbackActions;
    private string backupRefsNamespace;
    private RewriteHistoryOptions options;
    public HistoryRewriter(IRepository repo, IEnumerable`1<Commit> commitsToRewrite, RewriteHistoryOptions options);
    public void Execute();
    private Reference RewriteReference(Reference reference);
    private Reference RewriteReference(TRef oldRef, Func`2<TRef, TTarget> selectTarget, Func`2<TTarget, TTarget> rewriteTarget, ReferenceUpdater`2<TRef, TTarget> updateTarget);
    private void RewriteCommit(Commit commit, RewriteHistoryOptions options);
    private bool TryPruneEmptyCommit(Commit commit, IList`1<Commit> mappedNewParents, Tree newTree);
    private GitObject RewriteTarget(GitObject oldTarget);
    private int ReferenceDepth(Reference reference);
    [CompilerGeneratedAttribute]
private Commit <RewriteCommit>b__12_0(Commit oldParent);
}
internal interface LibGit2Sharp.Core.IConvertableToGitCheckoutOpts {
    public CheckoutStrategy CheckoutStrategy { get; }
    public CheckoutNotifyFlags CheckoutNotifyFlags { get; }
    public abstract virtual CheckoutCallbacks GenerateCallbacks();
    public abstract virtual CheckoutStrategy get_CheckoutStrategy();
    public abstract virtual CheckoutNotifyFlags get_CheckoutNotifyFlags();
}
internal interface LibGit2Sharp.Core.ILazy`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
internal class LibGit2Sharp.Core.LambdaEqualityHelper`1 : object {
    private Func`2[] equalityContributorAccessors;
    public LambdaEqualityHelper`1(Func`2[] equalityContributorAccessors);
    public bool Equals(T instance, T other);
    public int GetHashCode(T instance);
}
internal class LibGit2Sharp.Core.LaxFilePathMarshaler : LaxUtf8Marshaler {
    private static LaxFilePathMarshaler staticInstance;
    private static LaxFilePathMarshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public static FilePath FromNative(IntPtr pNativeData);
    public static FilePath FromNative(Char* buffer);
    public static FilePath FromBuffer(Byte[] buffer);
}
internal class LibGit2Sharp.Core.LaxFilePathNoCleanupMarshaler : LaxFilePathMarshaler {
    private static LaxFilePathNoCleanupMarshaler staticInstance;
    private static LaxFilePathNoCleanupMarshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public virtual void CleanUpNativeData(IntPtr pNativeData);
}
internal class LibGit2Sharp.Core.LaxUtf8Marshaler : EncodingMarshaler {
    private static LaxUtf8Marshaler staticInstance;
    public static Encoding Encoding;
    private static LaxUtf8Marshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public virtual IntPtr MarshalManagedToNative(object managedObj);
    public static string FromNative(Char* pNativeData);
    public static string FromNative(IntPtr pNativeData);
    public static string FromNative(IntPtr pNativeData, int length);
    public static string FromBuffer(Byte[] buffer);
    public static string FromBuffer(Byte[] buffer, int length);
}
internal class LibGit2Sharp.Core.LaxUtf8NoCleanupMarshaler : LaxUtf8Marshaler {
    private static LaxUtf8NoCleanupMarshaler staticInstance;
    private static LaxUtf8NoCleanupMarshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public virtual void CleanUpNativeData(IntPtr pNativeData);
}
internal abstract class LibGit2Sharp.Core.LazyGroup`1 : object {
    private IList`1<IEvaluator`1<T, T>> evaluators;
    private object lock;
    private bool evaluated;
    protected Repository repo;
    protected LazyGroup`1(Repository repo);
    public ILazy`1<TResult> AddLazy(Func`2<T, TResult> func);
    public void Evaluate();
    protected abstract virtual void EvaluateInternal(Action`1<T> evaluator);
    protected static ILazy`1<TResult> Singleton(Func`1<TResult> resultSelector);
    [CompilerGeneratedAttribute]
private void <Evaluate>b__6_0(T input);
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.LookUpOptions : Enum {
    public int value__;
    public static LookUpOptions None;
    public static LookUpOptions ThrowWhenNoGitObjectHasBeenFound;
    public static LookUpOptions DereferenceResultToCommit;
    public static LookUpOptions ThrowWhenCanNotBeDereferencedToACommit;
}
internal static class LibGit2Sharp.Core.NativeDllName : object {
    public static string Name;
}
internal static class LibGit2Sharp.Core.NativeMethods : object {
    public static UInt32 GIT_PATH_MAX;
    private static string libgit2;
    private static NativeShutdownObject shutdownObject;
    public static int RTLD_NOW;
    private static NativeMethods();
    private static string GetGlobalSettingsNativeLibraryPath();
    private static bool TryUseNativeLibrary();
    private static IntPtr LoadUnixLibrary(string path, int flags);
    private static IntPtr LoadWindowsLibrary(string path);
    private static void InitializeNativeLibrary();
    internal static GitError* git_error_last();
    internal static int git_error_set_str(GitErrorCategory error_class, string errorString);
    internal static void git_error_set_oom();
    internal static UInt32 git_blame_get_hunk_count(git_blame* blame);
    internal static git_blame_hunk* git_blame_get_hunk_byindex(git_blame* blame, UInt32 index);
    internal static int git_blame_file(git_blame*& blame, git_repository* repo, string path, git_blame_options options);
    internal static void git_blame_free(git_blame* blame);
    internal static int git_blob_create_from_disk(GitOid& id, git_repository* repo, FilePath path);
    internal static int git_blob_create_from_workdir(GitOid& id, git_repository* repo, FilePath relative_path);
    internal static int git_blob_create_from_stream(IntPtr& stream, git_repository* repositoryPtr, string hintpath);
    internal static int git_blob_create_from_stream_commit(GitOid& oid, IntPtr stream);
    internal static int git_blob_filtered_content(GitBuf buf, git_object* blob, string as_path, bool check_for_binary_data);
    internal static IntPtr git_blob_rawcontent(git_object* blob);
    internal static long git_blob_rawsize(git_object* blob);
    internal static int git_branch_create_from_annotated(git_reference*& ref_out, git_repository* repo, string branch_name, git_annotated_commit* target, bool force);
    internal static int git_branch_delete(git_reference* reference);
    internal static void git_branch_iterator_free(IntPtr iterator);
    internal static int git_branch_iterator_new(IntPtr& iter_out, IntPtr repo, GitBranchType branch_type);
    internal static int git_branch_move(git_reference*& ref_out, git_reference* reference, string new_branch_name, bool force);
    internal static int git_branch_next(IntPtr& ref_out, GitBranchType& type_out, IntPtr iter);
    internal static int git_branch_remote_name(GitBuf buf, git_repository* repo, string canonical_branch_name);
    internal static int git_rebase_init(git_rebase*& rebase, git_repository* repo, git_annotated_commit* branch, git_annotated_commit* upstream, git_annotated_commit* onto, GitRebaseOptions options);
    internal static int git_rebase_open(git_rebase*& rebase, git_repository* repo, GitRebaseOptions options);
    internal static UIntPtr git_rebase_operation_entrycount(git_rebase* rebase);
    internal static UIntPtr git_rebase_operation_current(git_rebase* rebase);
    internal static git_rebase_operation* git_rebase_operation_byindex(git_rebase* rebase, UIntPtr index);
    internal static int git_rebase_next(git_rebase_operation*& operation, git_rebase* rebase);
    internal static int git_rebase_commit(GitOid& id, git_rebase* rebase, git_signature* author, git_signature* committer, IntPtr message_encoding, IntPtr message);
    internal static int git_rebase_abort(git_rebase* rebase);
    internal static int git_rebase_finish(git_rebase* repo, git_signature* signature);
    internal static void git_rebase_free(git_rebase* rebase);
    internal static int git_remote_rename(GitStrArray& problems, git_repository* repo, string old_name, string new_name);
    internal static int git_branch_upstream_name(GitBuf buf, git_repository* repo, string referenceName);
    internal static void git_buf_dispose(GitBuf buf);
    internal static int git_checkout_tree(git_repository* repo, git_object* treeish, GitCheckoutOpts& opts);
    internal static int git_checkout_index(git_repository* repo, git_object* treeish, GitCheckoutOpts& opts);
    internal static int git_clone(git_repository*& repo, string origin_url, FilePath workdir_path, GitCloneOptions& opts);
    internal static git_signature* git_commit_author(git_object* commit);
    internal static git_signature* git_commit_committer(git_object* commit);
    internal static int git_commit_create_from_ids(GitOid& id, git_repository* repo, string updateRef, git_signature* author, git_signature* committer, string encoding, string message, GitOid& tree, UIntPtr parentCount, IntPtr[] parents);
    internal static int git_commit_create_buffer(GitBuf res, git_repository* repo, git_signature* author, git_signature* committer, string encoding, string message, git_object* tree, UIntPtr parent_count, IntPtr* parents);
    internal static int git_commit_create_with_signature(GitOid& id, git_repository* repo, string commit_content, string signature, string signature_field);
    internal static string git_commit_message(git_object* commit);
    internal static string git_commit_summary(git_object* commit);
    internal static string git_commit_message_encoding(git_object* commit);
    internal static git_oid* git_commit_parent_id(git_object* commit, UInt32 n);
    internal static UInt32 git_commit_parentcount(git_object* commit);
    internal static git_oid* git_commit_tree_id(git_object* commit);
    internal static int git_commit_extract_signature(GitBuf signature, GitBuf signed_data, git_repository* repo, GitOid& commit_id, string field);
    internal static int git_config_delete_entry(git_config* cfg, string name);
    internal static int git_config_lock(IntPtr& txn, git_config* config);
    internal static int git_config_delete_multivar(git_config* cfg, string name, string regexp);
    internal static int git_config_set_multivar(git_config* cfg, string name, string regexp, string value);
    internal static int git_config_find_global(GitBuf global_config_path);
    internal static int git_config_find_system(GitBuf system_config_path);
    internal static int git_config_find_xdg(GitBuf xdg_config_path);
    internal static int git_config_find_programdata(GitBuf programdata_config_path);
    internal static void git_config_free(git_config* cfg);
    internal static void git_config_entry_free(GitConfigEntry* entry);
    internal static int git_config_get_entry(GitConfigEntry*& entry, git_config* cfg, string name);
    internal static int git_config_add_file_ondisk(git_config* cfg, FilePath path, UInt32 level, git_repository* repo, bool force);
    internal static int git_config_new(git_config*& cfg);
    internal static int git_config_open_level(git_config*& cfg, git_config* parent, UInt32 level);
    internal static int git_config_parse_bool(Boolean& value, string valueToParse);
    internal static int git_config_parse_int32(Int32& value, string valueToParse);
    internal static int git_config_parse_int64(Int64& value, string valueToParse);
    internal static int git_config_set_bool(git_config* cfg, string name, bool value);
    internal static int git_config_set_int32(git_config* cfg, string name, int value);
    internal static int git_config_set_int64(git_config* cfg, string name, long value);
    internal static int git_config_set_string(git_config* cfg, string name, string value);
    internal static int git_config_foreach(git_config* cfg, config_foreach_callback callback, IntPtr payload);
    internal static int git_config_iterator_glob_new(IntPtr& iter, IntPtr cfg, string regexp);
    internal static int git_config_next(IntPtr& entry, IntPtr iter);
    internal static void git_config_iterator_free(IntPtr iter);
    internal static int git_config_snapshot(git_config*& out, git_config* config);
    internal static int git_cred_default_new(IntPtr& cred);
    internal static int git_cred_userpass_plaintext_new(IntPtr& cred, string username, string password);
    internal static void git_cred_free(IntPtr cred);
    internal static int git_describe_commit(git_describe_result*& describe, git_object* committish, GitDescribeOptions& options);
    internal static int git_describe_format(GitBuf buf, git_describe_result* describe, GitDescribeFormatOptions& options);
    internal static void git_describe_result_free(git_describe_result* describe);
    internal static void git_diff_free(git_diff* diff);
    internal static int git_diff_tree_to_tree(git_diff*& diff, git_repository* repo, git_object* oldTree, git_object* newTree, GitDiffOptions options);
    internal static int git_diff_tree_to_index(git_diff*& diff, git_repository* repo, git_object* oldTree, git_index* index, GitDiffOptions options);
    internal static int git_diff_merge(git_diff* onto, git_diff* from);
    internal static int git_diff_index_to_workdir(git_diff*& diff, git_repository* repo, git_index* index, GitDiffOptions options);
    internal static int git_diff_tree_to_workdir(git_diff*& diff, git_repository* repo, git_object* oldTree, GitDiffOptions options);
    internal static int git_diff_blobs(git_object* oldBlob, string old_as_path, git_object* newBlob, string new_as_path, GitDiffOptions options, git_diff_file_cb fileCallback, git_diff_binary_cb binaryCallback, git_diff_hunk_cb hunkCallback, git_diff_line_cb lineCallback, IntPtr payload);
    internal static int git_diff_foreach(git_diff* diff, git_diff_file_cb fileCallback, git_diff_binary_cb binaryCallback, git_diff_hunk_cb hunkCallback, git_diff_line_cb lineCallback, IntPtr payload);
    internal static int git_diff_find_similar(git_diff* diff, GitDiffFindOptions options);
    internal static UIntPtr git_diff_num_deltas(git_diff* diff);
    internal static git_diff_delta* git_diff_get_delta(git_diff* diff, UIntPtr idx);
    internal static int git_filter_register(string name, IntPtr gitFilter, int priority);
    internal static int git_filter_unregister(string name);
    internal static int git_filter_source_mode(git_filter_source* source);
    internal static int git_libgit2_features();
    internal static int git_libgit2_opts(int option, UInt32 level, GitBuf buf);
    internal static int git_libgit2_opts(int option, UInt32 level, string path);
    internal static int git_libgit2_opts(int option, int enabled);
    internal static int git_libgit2_opts(int option, string path);
    internal static int git_libgit2_opts(int option, GitBuf buf);
    internal static int git_libgit2_opts(int option, IntPtr extensions, UIntPtr len);
    internal static int git_libgit2_opts(int option, GitStrArray& extensions);
    internal static int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, UInt32 level, GitBuf buf);
    internal static int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, UInt32 level, string path);
    internal static int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, int enabled);
    internal static int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, string path);
    internal static int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, GitBuf buf);
    internal static int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, IntPtr extensions, UIntPtr len);
    internal static int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, GitStrArray& extensions);
    internal static int git_graph_ahead_behind(UIntPtr& ahead, UIntPtr& behind, git_repository* repo, GitOid& one, GitOid& two);
    internal static int git_graph_descendant_of(git_repository* repo, GitOid& commit, GitOid& ancestor);
    internal static int git_ignore_add_rule(git_repository* repo, string rules);
    internal static int git_ignore_clear_internal_rules(git_repository* repo);
    internal static int git_ignore_path_is_ignored(Int32& ignored, git_repository* repo, string path);
    internal static int git_index_add_bypath(git_index* index, FilePath path);
    internal static int git_index_add(git_index* index, git_index_entry* entry);
    internal static int git_index_conflict_get(git_index_entry*& ancestor, git_index_entry*& ours, git_index_entry*& theirs, git_index* index, string path);
    internal static int git_index_conflict_iterator_new(git_index_conflict_iterator*& iterator, git_index* index);
    internal static int git_index_conflict_next(git_index_entry*& ancestor, git_index_entry*& ours, git_index_entry*& theirs, git_index_conflict_iterator* iterator);
    internal static void git_index_conflict_iterator_free(git_index_conflict_iterator* iterator);
    internal static UIntPtr git_index_entrycount(git_index* index);
    internal static int git_index_entry_stage(git_index_entry* indexentry);
    internal static void git_index_free(git_index* index);
    internal static git_index_entry* git_index_get_byindex(git_index* index, UIntPtr n);
    internal static git_index_entry* git_index_get_bypath(git_index* index, string path, int stage);
    internal static int git_index_has_conflicts(git_index* index);
    internal static UIntPtr git_index_name_entrycount(git_index* handle);
    internal static git_index_name_entry* git_index_name_get_byindex(git_index* handle, UIntPtr n);
    internal static int git_index_open(git_index*& index, FilePath indexpath);
    internal static int git_index_read(git_index* index, bool force);
    internal static int git_index_remove_bypath(git_index* index, string path);
    internal static UIntPtr git_index_reuc_entrycount(git_index* handle);
    internal static git_index_reuc_entry* git_index_reuc_get_byindex(git_index* handle, UIntPtr n);
    internal static git_index_reuc_entry* git_index_reuc_get_bypath(git_index* handle, string path);
    internal static int git_index_write(git_index* index);
    internal static int git_index_write_tree(GitOid& treeOid, git_index* index);
    internal static int git_index_write_tree_to(GitOid& treeOid, git_index* index, git_repository* repo);
    internal static int git_index_read_tree(git_index* index, git_object* tree);
    internal static int git_index_clear(git_index* index);
    internal static int git_merge_base_many(GitOid& mergeBase, git_repository* repo, int length, GitOid[] input_array);
    internal static int git_merge_base_octopus(GitOid& mergeBase, git_repository* repo, int length, GitOid[] input_array);
    internal static int git_annotated_commit_from_ref(git_annotated_commit*& annotatedCommit, git_repository* repo, git_reference* reference);
    internal static int git_annotated_commit_from_fetchhead(git_annotated_commit*& annotatedCommit, git_repository* repo, string branch_name, string remote_url, GitOid& oid);
    internal static int git_annotated_commit_from_revspec(git_annotated_commit*& annotatedCommit, git_repository* repo, string revspec);
    internal static int git_annotated_commit_lookup(git_annotated_commit*& annotatedCommit, git_repository* repo, GitOid& id);
    internal static git_oid* git_annotated_commit_id(git_annotated_commit* annotatedCommit);
    internal static int git_merge(git_repository* repo, IntPtr[] their_heads, UIntPtr their_heads_len, GitMergeOpts& merge_opts, GitCheckoutOpts& checkout_opts);
    internal static int git_merge_commits(git_index*& index, git_repository* repo, git_object* our_commit, git_object* their_commit, GitMergeOpts& merge_opts);
    internal static int git_merge_analysis(GitMergeAnalysis& status_out, GitMergePreference& preference_out, git_repository* repo, IntPtr[] their_heads, int their_heads_len);
    internal static void git_annotated_commit_free(git_annotated_commit* commit);
    internal static int git_message_prettify(GitBuf buf, string message, bool strip_comments, sbyte comment_char);
    internal static int git_note_create(GitOid& noteOid, git_repository* repo, string notes_ref, git_signature* author, git_signature* committer, GitOid& oid, string note, int force);
    internal static void git_note_free(git_note* note);
    internal static string git_note_message(git_note* note);
    internal static git_oid* git_note_id(git_note* note);
    internal static int git_note_read(git_note*& note, git_repository* repo, string notes_ref, GitOid& oid);
    internal static int git_note_remove(git_repository* repo, string notes_ref, git_signature* author, git_signature* committer, GitOid& oid);
    internal static int git_note_default_ref(GitBuf notes_ref, git_repository* repo);
    internal static int git_note_foreach(git_repository* repo, string notes_ref, git_note_foreach_cb cb, IntPtr payload);
    internal static int git_odb_add_backend(git_odb* odb, IntPtr backend, int priority);
    internal static IntPtr git_odb_backend_malloc(IntPtr backend, UIntPtr len);
    internal static int git_odb_exists(git_odb* odb, GitOid& id);
    internal static int git_odb_foreach(git_odb* odb, git_odb_foreach_cb cb, IntPtr payload);
    internal static int git_odb_open_wstream(git_odb_stream*& stream, git_odb* odb, long size, GitObjectType type);
    internal static void git_odb_free(git_odb* odb);
    internal static int git_odb_read_header(UIntPtr& len_out, GitObjectType& type, git_odb* odb, GitOid& id);
    internal static void git_object_free(git_object* obj);
    internal static int git_odb_stream_write(git_odb_stream* Stream, IntPtr Buffer, UIntPtr len);
    internal static int git_odb_stream_finalize_write(GitOid& id, git_odb_stream* stream);
    internal static void git_odb_stream_free(git_odb_stream* stream);
    internal static int git_odb_write(GitOid& id, git_odb* odb, Byte* data, UIntPtr len, GitObjectType type);
    internal static git_oid* git_object_id(git_object* obj);
    internal static int git_object_lookup(git_object*& obj, git_repository* repo, GitOid& id, GitObjectType type);
    internal static int git_object_peel(git_object*& peeled, git_object* obj, GitObjectType type);
    internal static int git_object_short_id(GitBuf buf, git_object* obj);
    internal static GitObjectType git_object_type(git_object* obj);
    internal static int git_patch_from_diff(git_patch*& patch, git_diff* diff, UIntPtr idx);
    internal static int git_patch_print(git_patch* patch, git_diff_line_cb print_cb, IntPtr payload);
    internal static int git_patch_line_stats(UIntPtr& total_context, UIntPtr& total_additions, UIntPtr& total_deletions, git_patch* patch);
    internal static void git_patch_free(git_patch* patch);
    internal static void git_packbuilder_free(git_packbuilder* packbuilder);
    internal static int git_packbuilder_insert(git_packbuilder* packbuilder, GitOid& id, string name);
    internal static int git_packbuilder_insert_commit(git_packbuilder* packbuilder, GitOid& id);
    internal static int git_packbuilder_insert_recur(git_packbuilder* packbuilder, GitOid& id, string name);
    internal static int git_packbuilder_insert_tree(git_packbuilder* packbuilder, GitOid& id);
    internal static int git_packbuilder_new(git_packbuilder*& packbuilder, git_repository* repo);
    internal static UIntPtr git_packbuilder_object_count(git_packbuilder* packbuilder);
    internal static UInt32 git_packbuilder_set_threads(git_packbuilder* packbuilder, UInt32 numThreads);
    internal static int git_packbuilder_write(git_packbuilder* packbuilder, FilePath path, UInt32 mode, IntPtr progressCallback, IntPtr payload);
    internal static UIntPtr git_packbuilder_written(git_packbuilder* packbuilder);
    internal static int git_reference_create(git_reference*& reference, git_repository* repo, string name, GitOid& oid, bool force, string log_message);
    internal static int git_reference_symbolic_create(git_reference*& reference, git_repository* repo, string name, string target, bool force, string log_message);
    internal static int git_reference_foreach_glob(git_repository* repo, string glob, ref_glob_callback callback, IntPtr payload);
    internal static void git_reference_free(git_reference* reference);
    internal static int git_reference_is_valid_name(string refname);
    internal static int git_reference_list(GitStrArray& array, git_repository* repo);
    internal static int git_reference_lookup(git_reference*& reference, git_repository* repo, string name);
    internal static string git_reference_name(git_reference* reference);
    internal static int git_reference_remove(git_repository* repo, string name);
    internal static git_oid* git_reference_target(git_reference* reference);
    internal static int git_reference_rename(git_reference*& ref_out, git_reference* reference, string newName, bool force, string log_message);
    internal static int git_reference_set_target(git_reference*& ref_out, git_reference* reference, GitOid& id, string log_message);
    internal static int git_reference_symbolic_set_target(git_reference*& ref_out, git_reference* reference, string target, string log_message);
    internal static string git_reference_symbolic_target(git_reference* reference);
    internal static GitReferenceType git_reference_type(git_reference* reference);
    internal static int git_reference_ensure_log(git_repository* repo, string refname);
    internal static void git_reflog_free(git_reflog* reflog);
    internal static int git_reflog_read(git_reflog*& ref_out, git_repository* repo, string name);
    internal static UIntPtr git_reflog_entrycount(git_reflog* reflog);
    internal static git_reflog_entry* git_reflog_entry_byindex(git_reflog* reflog, UIntPtr idx);
    internal static git_oid* git_reflog_entry_id_old(git_reflog_entry* entry);
    internal static git_oid* git_reflog_entry_id_new(git_reflog_entry* entry);
    internal static git_signature* git_reflog_entry_committer(git_reflog_entry* entry);
    internal static string git_reflog_entry_message(git_reflog_entry* entry);
    internal static int git_refspec_transform(GitBuf buf, IntPtr refspec, string name);
    internal static int git_refspec_rtransform(GitBuf buf, IntPtr refspec, string name);
    internal static string git_refspec_string(IntPtr refSpec);
    internal static RefSpecDirection git_refspec_direction(IntPtr refSpec);
    internal static string git_refspec_dst(IntPtr refSpec);
    internal static string git_refspec_src(IntPtr refspec);
    internal static bool git_refspec_force(IntPtr refSpec);
    internal static bool git_refspec_src_matches(IntPtr refspec, string reference);
    internal static bool git_refspec_dst_matches(IntPtr refspec, string reference);
    internal static int git_remote_autotag(git_remote* remote);
    internal static int git_remote_connect(git_remote* remote, GitDirection direction, GitRemoteCallbacks& callbacks, GitProxyOptions& proxy_options, GitStrArray& custom_headers);
    internal static int git_remote_create(git_remote*& remote, git_repository* repo, string name, string url);
    internal static int git_remote_create_anonymous(git_remote*& remote, git_repository* repo, string url);
    internal static int git_remote_create_with_fetchspec(git_remote*& remote, git_repository* repo, string name, string url, string refspec);
    internal static int git_remote_delete(git_repository* repo, string name);
    internal static int git_remote_fetch(git_remote* remote, GitStrArray& refspecs, GitFetchOptions fetch_opts, string log_message);
    internal static void git_remote_free(git_remote* remote);
    internal static int git_remote_get_fetch_refspecs(GitStrArray& array, git_remote* remote);
    internal static git_refspec* git_remote_get_refspec(git_remote* remote, UIntPtr n);
    internal static int git_remote_get_push_refspecs(GitStrArray& array, git_remote* remote);
    internal static int git_remote_push(git_remote* remote, GitStrArray& refSpecs, GitPushOptions opts);
    internal static UIntPtr git_remote_refspec_count(git_remote* remote);
    internal static int git_remote_set_url(git_repository* repo, string remote, string url);
    internal static int git_remote_add_fetch(git_repository* repo, string remote, string url);
    internal static int git_remote_set_pushurl(git_repository* repo, string remote, string url);
    internal static int git_remote_add_push(git_repository* repo, string remote, string url);
    internal static int git_remote_is_valid_name(string remote_name);
    internal static int git_remote_list(GitStrArray& array, git_repository* repo);
    internal static int git_remote_lookup(git_remote*& remote, git_repository* repo, string name);
    internal static int git_remote_ls(git_remote_head**& heads, UIntPtr& size, git_remote* remote);
    internal static string git_remote_name(git_remote* remote);
    internal static string git_remote_url(git_remote* remote);
    internal static string git_remote_pushurl(git_remote* remote);
    internal static void git_remote_set_autotag(git_repository* repo, string name, TagFetchMode option);
    internal static int git_repository_discover(GitBuf buf, FilePath start_path, bool across_fs, FilePath ceiling_dirs);
    internal static int git_repository_fetchhead_foreach(git_repository* repo, git_repository_fetchhead_foreach_cb cb, IntPtr payload);
    internal static void git_repository_free(git_repository* repo);
    internal static int git_repository_head_detached(IntPtr repo);
    internal static int git_repository_head_unborn(IntPtr repo);
    internal static int git_repository_ident(String& name, String& email, git_repository* repo);
    internal static int git_repository_index(git_index*& index, git_repository* repo);
    internal static int git_repository_init_ext(git_repository*& repository, FilePath path, GitRepositoryInitOptions options);
    internal static int git_repository_is_bare(IntPtr handle);
    internal static int git_repository_is_shallow(IntPtr repo);
    internal static int git_repository_state_cleanup(git_repository* repo);
    internal static int git_repository_mergehead_foreach(git_repository* repo, git_repository_mergehead_foreach_cb cb, IntPtr payload);
    internal static int git_repository_message(GitBuf buf, git_repository* repository);
    internal static int git_repository_new(git_repository*& repo);
    internal static int git_repository_odb(git_odb*& odb, git_repository* repo);
    internal static int git_repository_open(git_repository*& repository, FilePath path);
    internal static int git_repository_open_ext(git_repository*& repository, FilePath path, RepositoryOpenFlags flags, FilePath ceilingDirs);
    internal static FilePath git_repository_path(git_repository* repository);
    internal static int git_repository_set_config(git_repository* repository, git_config* config);
    internal static int git_repository_set_ident(git_repository* repo, string name, string email);
    internal static int git_repository_set_index(git_repository* repository, git_index* index);
    internal static int git_repository_set_workdir(git_repository* repository, FilePath workdir, bool update_gitlink);
    internal static int git_repository_set_head_detached(git_repository* repo, GitOid& commitish);
    internal static int git_repository_set_head_detached_from_annotated(git_repository* repo, git_annotated_commit* commit);
    internal static int git_repository_set_head(git_repository* repo, string refname);
    internal static int git_repository_state(git_repository* repository);
    internal static FilePath git_repository_workdir(git_repository* repository);
    internal static FilePath git_repository_workdir(IntPtr repository);
    internal static int git_reset(git_repository* repo, git_object* target, ResetMode reset_type, GitCheckoutOpts& opts);
    internal static int git_revert(git_repository* repo, git_object* commit, GitRevertOpts opts);
    internal static int git_revert_commit(git_index*& index, git_repository* repo, git_object* revert_commit, git_object* our_commit, UInt32 mainline, GitMergeOpts& opts);
    internal static int git_revparse_ext(git_object*& obj, git_reference*& reference, git_repository* repo, string spec);
    internal static void git_revwalk_free(git_revwalk* walker);
    internal static int git_revwalk_hide(git_revwalk* walker, GitOid& commit_id);
    internal static int git_revwalk_new(git_revwalk*& walker, git_repository* repo);
    internal static int git_revwalk_next(GitOid& id, git_revwalk* walker);
    internal static int git_revwalk_push(git_revwalk* walker, GitOid& id);
    internal static int git_revwalk_reset(git_revwalk* walker);
    internal static int git_revwalk_sorting(git_revwalk* walk, CommitSortStrategies sort);
    internal static int git_revwalk_simplify_first_parent(git_revwalk* walk);
    internal static void git_signature_free(git_signature* signature);
    internal static int git_signature_new(git_signature*& signature, string name, string email, long time, int offset);
    internal static int git_signature_now(git_signature*& signature, string name, string email);
    internal static int git_signature_dup(git_signature*& dest, git_signature* sig);
    internal static int git_stash_save(GitOid& id, git_repository* repo, git_signature* stasher, string message, StashModifiers flags);
    internal static int git_stash_foreach(git_repository* repo, git_stash_cb callback, IntPtr payload);
    internal static int git_stash_drop(git_repository* repo, UIntPtr index);
    internal static int git_stash_apply(git_repository* repo, UIntPtr index, GitStashApplyOpts opts);
    internal static int git_stash_pop(git_repository* repo, UIntPtr index, GitStashApplyOpts opts);
    internal static int git_status_file(FileStatus& statusflags, git_repository* repo, FilePath filepath);
    internal static int git_status_list_new(git_status_list*& git_status_list, git_repository* repo, GitStatusOptions options);
    internal static int git_status_list_entrycount(git_status_list* statusList);
    internal static git_status_entry* git_status_byindex(git_status_list* list, UIntPtr idx);
    internal static void git_status_list_free(git_status_list* statusList);
    internal static void git_strarray_free(GitStrArray& array);
    internal static int git_submodule_lookup(git_submodule*& reference, git_repository* repo, string name);
    internal static int git_submodule_resolve_url(GitBuf buf, git_repository* repo, string url);
    internal static int git_submodule_update(git_submodule* sm, bool init, GitSubmoduleUpdateOptions& submoduleUpdateOptions);
    internal static int git_submodule_foreach(git_repository* repo, submodule_callback callback, IntPtr payload);
    internal static int git_submodule_add_to_index(git_submodule* submodule, bool write_index);
    internal static void git_submodule_free(git_submodule* submodule);
    internal static string git_submodule_path(git_submodule* submodule);
    internal static string git_submodule_url(git_submodule* submodule);
    internal static git_oid* git_submodule_index_id(git_submodule* submodule);
    internal static git_oid* git_submodule_head_id(git_submodule* submodule);
    internal static git_oid* git_submodule_wd_id(git_submodule* submodule);
    internal static SubmoduleIgnore git_submodule_ignore(git_submodule* submodule);
    internal static SubmoduleUpdate git_submodule_update_strategy(git_submodule* submodule);
    internal static SubmoduleRecurse git_submodule_fetch_recurse_submodules(git_submodule* submodule);
    internal static int git_submodule_reload(git_submodule* submodule, bool force);
    internal static int git_submodule_status(SubmoduleStatus& status, git_repository* repo, FilePath name, GitSubmoduleIgnore ignore);
    internal static int git_submodule_init(git_submodule* submodule, bool overwrite);
    internal static int git_tag_annotation_create(GitOid& oid, git_repository* repo, string name, git_object* target, git_signature* signature, string message);
    internal static int git_tag_create(GitOid& oid, git_repository* repo, string name, git_object* target, git_signature* signature, string message, bool force);
    internal static int git_tag_create_lightweight(GitOid& oid, git_repository* repo, string name, git_object* target, bool force);
    internal static int git_tag_delete(git_repository* repo, string tagName);
    internal static int git_tag_list(GitStrArray& array, git_repository* repo);
    internal static string git_tag_message(git_object* tag);
    internal static string git_tag_name(git_object* tag);
    internal static git_signature* git_tag_tagger(git_object* tag);
    internal static git_oid* git_tag_target_id(git_object* tag);
    internal static GitObjectType git_tag_target_type(git_object* tag);
    internal static int git_libgit2_init();
    internal static int git_libgit2_shutdown();
    internal static int git_openssl_set_locking();
    internal static int git_trace_set(LogLevel level, git_trace_cb trace_cb);
    internal static int git_transport_register(string prefix, IntPtr transport_cb, IntPtr payload);
    internal static int git_transport_smart(IntPtr& transport, IntPtr remote, IntPtr definition);
    internal static int git_transport_smart_certificate_check(IntPtr transport, IntPtr cert, int valid, string hostname);
    internal static int git_transport_smart_credentials(IntPtr& cred_out, IntPtr transport, string user, int methods);
    internal static int git_transport_unregister(string prefix);
    internal static UInt32 git_tree_entry_filemode(git_tree_entry* entry);
    internal static git_tree_entry* git_tree_entry_byindex(git_object* tree, UIntPtr idx);
    internal static int git_tree_entry_bypath(git_tree_entry*& tree, git_object* root, string treeentry_path);
    internal static void git_tree_entry_free(git_tree_entry* treeEntry);
    internal static git_oid* git_tree_entry_id(git_tree_entry* entry);
    internal static string git_tree_entry_name(git_tree_entry* entry);
    internal static GitObjectType git_tree_entry_type(git_tree_entry* entry);
    internal static UIntPtr git_tree_entrycount(git_object* tree);
    internal static int git_treebuilder_new(git_treebuilder*& builder, git_repository* repo, IntPtr src);
    internal static int git_treebuilder_insert(IntPtr entry_out, git_treebuilder* builder, string treeentry_name, GitOid& id, UInt32 attributes);
    internal static int git_treebuilder_write(GitOid& id, git_treebuilder* bld);
    internal static void git_treebuilder_free(git_treebuilder* bld);
    internal static int git_blob_is_binary(git_object* blob);
    internal static int git_cherrypick(git_repository* repo, git_object* commit, GitCherryPickOptions options);
    internal static int git_cherrypick_commit(git_index*& index, git_repository* repo, git_object* cherrypick_commit, git_object* our_commit, UInt32 mainline, GitMergeOpts& options);
    internal static int git_transaction_commit(IntPtr txn);
    internal static void git_transaction_free(IntPtr txn);
    internal static void git_worktree_free(git_worktree* worktree);
    internal static int git_worktree_lookup(git_worktree*& reference, git_repository* repo, string name);
    internal static int git_worktree_list(GitStrArray& array, git_repository* repo);
    internal static int git_repository_open_from_worktree(git_repository*& repository, git_worktree* worktree);
    internal static int git_worktree_is_locked(GitBuf reason, git_worktree* worktree);
    internal static int git_worktree_validate(git_worktree* worktree);
    internal static int git_worktree_lock(git_worktree* worktree, string reason);
    internal static int git_worktree_unlock(git_worktree* worktree);
    internal static int git_worktree_add(git_worktree*& reference, git_repository* repo, string name, string path, git_worktree_add_options options);
    internal static int git_worktree_prune(git_worktree* worktree, git_worktree_prune_options options);
}
internal class LibGit2Sharp.Core.ObjectSafeWrapper : object {
    private ObjectHandle objectPtr;
    public ObjectHandle ObjectPtr { get; }
    public ObjectSafeWrapper(ObjectId id, RepositoryHandle handle, bool allowNullObjectId, bool throwIfMissing);
    public ObjectHandle get_ObjectPtr();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal enum LibGit2Sharp.Core.OperatingSystemType : Enum {
    public int value__;
    public static OperatingSystemType Windows;
    public static OperatingSystemType Unix;
    public static OperatingSystemType MacOSX;
}
internal class LibGit2Sharp.Core.PackbuilderCallbacks : object {
    private PackBuilderProgressHandler onPackBuilderProgress;
    internal PackbuilderCallbacks(PackBuilderProgressHandler onPackBuilderProgress);
    internal git_packbuilder_progress GenerateCallback();
    private int OnGitPackBuilderProgress(int stage, UInt32 current, UInt32 total, IntPtr payload);
}
internal class LibGit2Sharp.Core.PathCase : object {
    private StringComparer comparer;
    private StringComparison comparison;
    public StringComparer Comparer { get; }
    public PathCase(IRepository repo);
    public StringComparer get_Comparer();
    public bool StartsWith(string path, string value);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class LibGit2Sharp.Core.perfdata_cb : MulticastDelegate {
    public perfdata_cb(object object, IntPtr method);
    public virtual int Invoke(IntPtr perfdata, IntPtr payload);
    public virtual IAsyncResult BeginInvoke(IntPtr perfdata, IntPtr payload, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal static class LibGit2Sharp.Core.Platform : object {
    public static string ProcessorArchitecture { get; }
    public static OperatingSystemType OperatingSystem { get; }
    public static string get_ProcessorArchitecture();
    public static OperatingSystemType get_OperatingSystem();
    public static string GetNativeLibraryExtension();
    public static bool IsRunningOnMono();
    public static bool IsRunningOnNetFramework();
    public static bool IsRunningOnNetCore();
}
[UnmanagedFunctionPointerAttribute("2")]
internal class LibGit2Sharp.Core.progress_cb : MulticastDelegate {
    public progress_cb(object object, IntPtr method);
    public virtual void Invoke(IntPtr strPtr, UIntPtr completed_steps, UIntPtr total_steps, IntPtr payload);
    public virtual IAsyncResult BeginInvoke(IntPtr strPtr, UIntPtr completed_steps, UIntPtr total_steps, IntPtr payload, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class LibGit2Sharp.Core.Proxy : object {
    internal static bool isOSXArm64;
    private static string anyValue;
    private static string non_existing_regex;
    public static long RebaseNoOperation;
    private static IDictionary`2<Type, Func`2<string, object>> configurationParser;
    private static UIntPtr GIT_REBASE_NO_OPERATION { get; }
    private static Proxy();
    public static BlameHandle git_blame_file(RepositoryHandle repo, string path, git_blame_options options);
    public static git_blame_hunk* git_blame_get_hunk_byindex(BlameHandle blame, UInt32 idx);
    public static IntPtr git_blob_create_from_stream(RepositoryHandle repo, string hintpath);
    public static ObjectId git_blob_create_fromstream_commit(IntPtr writestream_ptr);
    public static ObjectId git_blob_create_from_disk(RepositoryHandle repo, FilePath path);
    public static ObjectId git_blob_create_from_workdir(RepositoryHandle repo, FilePath path);
    public static UnmanagedMemoryStream git_blob_filtered_content_stream(RepositoryHandle repo, ObjectId id, string path, bool check_for_binary_data);
    public static UnmanagedMemoryStream git_blob_rawcontent_stream(RepositoryHandle repo, ObjectId id, long size);
    public static long git_blob_rawsize(ObjectHandle obj);
    public static bool git_blob_is_binary(ObjectHandle obj);
    public static ReferenceHandle git_branch_create_from_annotated(RepositoryHandle repo, string branch_name, string targetIdentifier, bool force);
    public static void git_branch_delete(ReferenceHandle reference);
    [IteratorStateMachineAttribute("LibGit2Sharp.Core.Proxy/<git_branch_iterator>d__13")]
public static IEnumerable`1<Branch> git_branch_iterator(Repository repo, GitBranchType branchType);
    public static void git_branch_iterator_free(IntPtr iter);
    public static ReferenceHandle git_branch_move(ReferenceHandle reference, string new_branch_name, bool force);
    public static string git_branch_remote_name(RepositoryHandle repo, string canonical_branch_name, bool shouldThrowIfNotFound);
    public static string git_branch_upstream_name(RepositoryHandle handle, string canonicalReferenceName);
    public static void git_buf_dispose(GitBuf buf);
    public static void git_checkout_tree(RepositoryHandle repo, ObjectId treeId, GitCheckoutOpts& opts);
    public static void git_checkout_index(RepositoryHandle repo, ObjectHandle treeish, GitCheckoutOpts& opts);
    internal static void git_cherrypick(RepositoryHandle repo, ObjectId commit, GitCherryPickOptions options);
    internal static IndexHandle git_cherrypick_commit(RepositoryHandle repo, ObjectHandle cherrypickCommit, ObjectHandle ourCommit, UInt32 mainline, GitMergeOpts opts, Boolean& earlyStop);
    public static RepositoryHandle git_clone(string url, string workdir, GitCloneOptions& opts);
    public static Signature git_commit_author(ObjectHandle obj);
    public static Signature git_commit_committer(ObjectHandle obj);
    public static ObjectId git_commit_create(RepositoryHandle repo, string referenceName, Signature author, Signature committer, string message, Tree tree, GitOid[] parentIds);
    public static string git_commit_create_buffer(RepositoryHandle repo, Signature author, Signature committer, string message, Tree tree, Commit[] parents);
    public static ObjectId git_commit_create_with_signature(RepositoryHandle repo, string commitContent, string signature, string field);
    public static string git_commit_message(ObjectHandle obj);
    public static string git_commit_summary(ObjectHandle obj);
    public static string git_commit_message_encoding(ObjectHandle obj);
    public static ObjectId git_commit_parent_id(ObjectHandle obj, UInt32 i);
    public static int git_commit_parentcount(RepositoryHandle repo, ObjectId id);
    public static int git_commit_parentcount(ObjectSafeWrapper obj);
    public static ObjectId git_commit_tree_id(ObjectHandle obj);
    public static SignatureInfo git_commit_extract_signature(RepositoryHandle repo, ObjectId id, string field);
    public static void git_config_add_file_ondisk(ConfigurationHandle config, FilePath path, ConfigurationLevel level, RepositoryHandle repo);
    public static bool git_config_delete(ConfigurationHandle config, string name);
    public static bool git_config_delete_multivar(ConfigurationHandle config, string name);
    public static FilePath git_config_find_global();
    public static FilePath git_config_find_system();
    public static FilePath git_config_find_xdg();
    public static FilePath git_config_find_programdata();
    public static void git_config_free(git_config* config);
    public static ConfigurationEntry`1<T> git_config_get_entry(ConfigurationHandle config, string key);
    public static ConfigurationHandle git_config_new();
    public static ConfigurationHandle git_config_open_level(ConfigurationHandle parent, ConfigurationLevel level);
    public static bool git_config_parse_bool(string value);
    public static int git_config_parse_int32(string value);
    public static long git_config_parse_int64(string value);
    public static void git_config_set_bool(ConfigurationHandle config, string name, bool value);
    public static void git_config_set_int32(ConfigurationHandle config, string name, int value);
    public static void git_config_set_int64(ConfigurationHandle config, string name, long value);
    public static void git_config_set_string(ConfigurationHandle config, string name, string value);
    public static void git_config_add_string(ConfigurationHandle config, string name, string value);
    public static ICollection`1<TResult> git_config_foreach(ConfigurationHandle config, Func`2<IntPtr, TResult> resultSelector);
    [IteratorStateMachineAttribute("LibGit2Sharp.Core.Proxy/<git_config_iterator_glob>d__59")]
public static IEnumerable`1<ConfigurationEntry`1<string>> git_config_iterator_glob(ConfigurationHandle config, string regexp);
    public static ConfigurationHandle git_config_snapshot(ConfigurationHandle config);
    public static IntPtr git_config_lock(git_config* config);
    public static void git_cred_free(IntPtr cred);
    public static string git_describe_commit(RepositoryHandle repo, ObjectId committishId, DescribeOptions options);
    public static void git_diff_blobs(RepositoryHandle repo, ObjectId oldBlob, ObjectId newBlob, GitDiffOptions options, git_diff_file_cb fileCallback, git_diff_hunk_cb hunkCallback, git_diff_line_cb lineCallback);
    public static void git_diff_foreach(git_diff* diff, git_diff_file_cb fileCallback, git_diff_hunk_cb hunkCallback, git_diff_line_cb lineCallback);
    public static DiffHandle git_diff_tree_to_index(RepositoryHandle repo, IndexHandle index, ObjectId oldTree, GitDiffOptions options);
    public static void git_diff_merge(DiffHandle onto, DiffHandle from);
    public static DiffHandle git_diff_tree_to_tree(RepositoryHandle repo, ObjectId oldTree, ObjectId newTree, GitDiffOptions options);
    public static DiffHandle git_diff_index_to_workdir(RepositoryHandle repo, IndexHandle index, GitDiffOptions options);
    public static DiffHandle git_diff_tree_to_workdir(RepositoryHandle repo, ObjectId oldTree, GitDiffOptions options);
    public static void git_diff_find_similar(DiffHandle diff, GitDiffFindOptions options);
    public static int git_diff_num_deltas(DiffHandle diff);
    public static git_diff_delta* git_diff_get_delta(DiffHandle diff, int idx);
    public static int git_error_set_str(GitErrorCategory error_class, Exception exception);
    public static int git_error_set_str(GitErrorCategory error_class, string errorString);
    public static string ErrorMessageFromException(Exception ex);
    private static void BuildErrorMessageFromException(StringBuilder sb, int level, Exception ex);
    public static void git_filter_register(string name, IntPtr filterPtr, int priority);
    public static void git_filter_unregister(string name);
    public static FilterMode git_filter_source_mode(git_filter_source* filterSource);
    public static Tuple`2<Nullable`1<int>, Nullable`1<int>> git_graph_ahead_behind(RepositoryHandle repo, Commit first, Commit second);
    public static bool git_graph_descendant_of(RepositoryHandle repo, ObjectId commitId, ObjectId ancestorId);
    public static void git_ignore_add_rule(RepositoryHandle repo, string rules);
    public static void git_ignore_clear_internal_rules(RepositoryHandle repo);
    public static bool git_ignore_path_is_ignored(RepositoryHandle repo, string path);
    public static void git_index_add(IndexHandle index, git_index_entry* entry);
    public static void git_index_add_bypath(IndexHandle index, FilePath path);
    public static Conflict git_index_conflict_get(IndexHandle index, string path);
    public static ConflictIteratorHandle git_index_conflict_iterator_new(IndexHandle index);
    public static Conflict git_index_conflict_next(ConflictIteratorHandle iterator);
    public static int git_index_entrycount(IndexHandle index);
    public static StageLevel git_index_entry_stage(git_index_entry* entry);
    public static git_index_entry* git_index_get_byindex(IndexHandle index, UIntPtr n);
    public static git_index_entry* git_index_get_bypath(IndexHandle index, string path, int stage);
    public static bool git_index_has_conflicts(IndexHandle index);
    public static int git_index_name_entrycount(IndexHandle index);
    public static git_index_name_entry* git_index_name_get_byindex(IndexHandle index, UIntPtr n);
    public static IndexHandle git_index_open(FilePath indexpath);
    public static void git_index_read(IndexHandle index);
    public static void git_index_remove_bypath(IndexHandle index, string path);
    public static int git_index_reuc_entrycount(IndexHandle index);
    public static git_index_reuc_entry* git_index_reuc_get_byindex(IndexHandle index, UIntPtr n);
    public static git_index_reuc_entry* git_index_reuc_get_bypath(IndexHandle index, string path);
    public static void git_index_write(IndexHandle index);
    public static ObjectId git_index_write_tree(IndexHandle index);
    public static ObjectId git_index_write_tree_to(IndexHandle index, RepositoryHandle repo);
    public static void git_index_read_fromtree(Index index, ObjectHandle tree);
    public static void git_index_clear(Index index);
    public static IndexHandle git_merge_commits(RepositoryHandle repo, ObjectHandle ourCommit, ObjectHandle theirCommit, GitMergeOpts opts, Boolean& earlyStop);
    public static ObjectId git_merge_base_many(RepositoryHandle repo, GitOid[] commitIds);
    public static ObjectId git_merge_base_octopus(RepositoryHandle repo, GitOid[] commitIds);
    public static AnnotatedCommitHandle git_annotated_commit_from_fetchhead(RepositoryHandle repo, string branchName, string remoteUrl, GitOid oid);
    public static AnnotatedCommitHandle git_annotated_commit_lookup(RepositoryHandle repo, GitOid oid);
    public static AnnotatedCommitHandle git_annotated_commit_from_ref(RepositoryHandle repo, ReferenceHandle reference);
    public static AnnotatedCommitHandle git_annotated_commit_from_revspec(RepositoryHandle repo, string revspec);
    public static ObjectId git_annotated_commit_id(AnnotatedCommitHandle mergeHead);
    public static void git_merge(RepositoryHandle repo, AnnotatedCommitHandle[] heads, GitMergeOpts mergeOptions, GitCheckoutOpts checkoutOptions, Boolean& earlyStop);
    public static void git_merge_analysis(RepositoryHandle repo, AnnotatedCommitHandle[] heads, GitMergeAnalysis& analysis_out, GitMergePreference& preference_out);
    public static string git_message_prettify(string message, Nullable`1<char> commentChar);
    public static ObjectId git_note_create(RepositoryHandle repo, string notes_ref, Signature author, Signature committer, ObjectId targetId, string note, bool force);
    public static string git_note_default_ref(RepositoryHandle repo);
    public static ICollection`1<TResult> git_note_foreach(RepositoryHandle repo, string notes_ref, Func`3<GitOid, GitOid, TResult> resultSelector);
    public static string git_note_message(NoteHandle note);
    public static ObjectId git_note_id(NoteHandle note);
    public static NoteHandle git_note_read(RepositoryHandle repo, string notes_ref, ObjectId id);
    public static void git_note_remove(RepositoryHandle repo, string notes_ref, Signature author, Signature committer, ObjectId targetId);
    public static ObjectId git_object_id(ObjectHandle obj);
    public static ObjectHandle git_object_lookup(RepositoryHandle repo, ObjectId id, GitObjectType type);
    public static ObjectHandle git_object_peel(RepositoryHandle repo, ObjectId id, GitObjectType type, bool throwsIfCanNotPeel);
    public static string git_object_short_id(RepositoryHandle repo, ObjectId id);
    public static GitObjectType git_object_type(ObjectHandle obj);
    public static void git_odb_add_backend(ObjectDatabaseHandle odb, IntPtr backend, int priority);
    public static IntPtr git_odb_backend_malloc(IntPtr backend, UIntPtr len);
    public static bool git_odb_exists(ObjectDatabaseHandle odb, ObjectId id);
    public static GitObjectMetadata git_odb_read_header(ObjectDatabaseHandle odb, ObjectId id);
    public static ICollection`1<ObjectId> git_odb_foreach(ObjectDatabaseHandle odb);
    public static OdbStreamHandle git_odb_open_wstream(ObjectDatabaseHandle odb, long size, GitObjectType type);
    public static void git_odb_stream_write(OdbStreamHandle stream, Byte[] data, int len);
    public static ObjectId git_odb_stream_finalize_write(OdbStreamHandle stream);
    public static ObjectId git_odb_write(ObjectDatabaseHandle odb, Byte[] data, ObjectType type);
    public static PatchHandle git_patch_from_diff(DiffHandle diff, int idx);
    public static void git_patch_print(PatchHandle patch, git_diff_line_cb printCallback);
    public static Tuple`2<int, int> git_patch_line_stats(PatchHandle patch);
    public static PackBuilderHandle git_packbuilder_new(RepositoryHandle repo);
    public static void git_packbuilder_insert(PackBuilderHandle packbuilder, ObjectId targetId, string name);
    internal static void git_packbuilder_insert_commit(PackBuilderHandle packbuilder, ObjectId targetId);
    internal static void git_packbuilder_insert_tree(PackBuilderHandle packbuilder, ObjectId targetId);
    public static void git_packbuilder_insert_recur(PackBuilderHandle packbuilder, ObjectId targetId, string name);
    public static UInt32 git_packbuilder_set_threads(PackBuilderHandle packbuilder, UInt32 numThreads);
    public static void git_packbuilder_write(PackBuilderHandle packbuilder, FilePath path);
    public static UIntPtr git_packbuilder_object_count(PackBuilderHandle packbuilder);
    public static UIntPtr git_packbuilder_written(PackBuilderHandle packbuilder);
    public static RebaseHandle git_rebase_init(RepositoryHandle repo, AnnotatedCommitHandle branch, AnnotatedCommitHandle upstream, AnnotatedCommitHandle onto, GitRebaseOptions options);
    public static RebaseHandle git_rebase_open(RepositoryHandle repo, GitRebaseOptions options);
    public static long git_rebase_operation_entrycount(RebaseHandle rebase);
    public static long git_rebase_operation_current(RebaseHandle rebase);
    private static UIntPtr get_GIT_REBASE_NO_OPERATION();
    public static git_rebase_operation* git_rebase_operation_byindex(RebaseHandle rebase, long index);
    public static git_rebase_operation* git_rebase_next(RebaseHandle rebase);
    public static GitRebaseCommitResult git_rebase_commit(RebaseHandle rebase, Identity author, Identity committer);
    public static void git_rebase_abort(RebaseHandle rebase);
    public static void git_rebase_finish(RebaseHandle rebase, Identity committer);
    public static ReferenceHandle git_reference_create(RepositoryHandle repo, string name, ObjectId targetId, bool allowOverwrite, string logMessage);
    public static ReferenceHandle git_reference_symbolic_create(RepositoryHandle repo, string name, string target, bool allowOverwrite, string logMessage);
    public static ICollection`1<TResult> git_reference_foreach_glob(RepositoryHandle repo, string glob, Func`2<IntPtr, TResult> resultSelector);
    public static bool git_reference_is_valid_name(string refname);
    public static IList`1<string> git_reference_list(RepositoryHandle repo);
    public static ReferenceHandle git_reference_lookup(RepositoryHandle repo, string name, bool shouldThrowIfNotFound);
    public static string git_reference_name(git_reference* reference);
    public static void git_reference_remove(RepositoryHandle repo, string name);
    public static ObjectId git_reference_target(git_reference* reference);
    public static ReferenceHandle git_reference_rename(ReferenceHandle reference, string newName, bool allowOverwrite, string logMessage);
    public static ReferenceHandle git_reference_set_target(ReferenceHandle reference, ObjectId id, string logMessage);
    public static ReferenceHandle git_reference_symbolic_set_target(ReferenceHandle reference, string target, string logMessage);
    public static string git_reference_symbolic_target(git_reference* reference);
    public static GitReferenceType git_reference_type(git_reference* reference);
    public static void git_reference_ensure_log(RepositoryHandle repo, string refname);
    public static ReflogHandle git_reflog_read(RepositoryHandle repo, string canonicalName);
    public static int git_reflog_entrycount(ReflogHandle reflog);
    public static git_reflog_entry* git_reflog_entry_byindex(ReflogHandle reflog, int idx);
    public static ObjectId git_reflog_entry_id_old(git_reflog_entry* entry);
    public static ObjectId git_reflog_entry_id_new(git_reflog_entry* entry);
    public static Signature git_reflog_entry_committer(git_reflog_entry* entry);
    public static string git_reflog_entry_message(git_reflog_entry* entry);
    public static string git_refspec_transform(IntPtr refSpecPtr, string name);
    public static string git_refspec_rtransform(IntPtr refSpecPtr, string name);
    public static string git_refspec_string(IntPtr refspec);
    public static string git_refspec_src(IntPtr refSpec);
    public static string git_refspec_dst(IntPtr refSpec);
    public static RefSpecDirection git_refspec_direction(IntPtr refSpec);
    public static bool git_refspec_force(IntPtr refSpec);
    public static bool git_refspec_src_matches(IntPtr refspec, string reference);
    public static bool git_refspec_dst_matches(IntPtr refspec, string reference);
    public static TagFetchMode git_remote_autotag(RemoteHandle remote);
    public static RemoteHandle git_remote_create(RepositoryHandle repo, string name, string url);
    public static RemoteHandle git_remote_create_with_fetchspec(RepositoryHandle repo, string name, string url, string refspec);
    public static RemoteHandle git_remote_create_anonymous(RepositoryHandle repo, string url);
    public static void git_remote_connect(RemoteHandle remote, GitDirection direction, GitRemoteCallbacks& remoteCallbacks, GitProxyOptions& proxyOptions);
    public static void git_remote_delete(RepositoryHandle repo, string name);
    public static git_refspec* git_remote_get_refspec(RemoteHandle remote, int n);
    public static int git_remote_refspec_count(RemoteHandle remote);
    public static IList`1<string> git_remote_get_fetch_refspecs(RemoteHandle remote);
    public static IList`1<string> git_remote_get_push_refspecs(RemoteHandle remote);
    public static void git_remote_push(RemoteHandle remote, IEnumerable`1<string> refSpecs, GitPushOptions opts);
    public static void git_remote_set_url(RepositoryHandle repo, string remote, string url);
    public static void git_remote_add_fetch(RepositoryHandle repo, string remote, string url);
    public static void git_remote_set_pushurl(RepositoryHandle repo, string remote, string url);
    public static void git_remote_add_push(RepositoryHandle repo, string remote, string url);
    public static void git_remote_fetch(RemoteHandle remote, IEnumerable`1<string> refSpecs, GitFetchOptions fetchOptions, string logMessage);
    public static bool git_remote_is_valid_name(string refname);
    public static IList`1<string> git_remote_list(RepositoryHandle repo);
    public static IEnumerable`1<Reference> git_remote_ls(Repository repository, RemoteHandle remote);
    public static RemoteHandle git_remote_lookup(RepositoryHandle repo, string name, bool throwsIfNotFound);
    public static string git_remote_name(RemoteHandle remote);
    public static void git_remote_rename(RepositoryHandle repo, string name, string new_name, RemoteRenameFailureHandler callback);
    public static void git_remote_set_autotag(RepositoryHandle repo, string remote, TagFetchMode value);
    public static string git_remote_url(RemoteHandle remote);
    public static string git_remote_pushurl(RemoteHandle remote);
    public static FilePath git_repository_discover(FilePath start_path);
    public static bool git_repository_head_detached(RepositoryHandle repo);
    public static ICollection`1<TResult> git_repository_fetchhead_foreach(RepositoryHandle repo, Func`5<string, string, GitOid, bool, TResult> resultSelector);
    public static bool git_repository_head_unborn(RepositoryHandle repo);
    public static IndexHandle git_repository_index(RepositoryHandle repo);
    public static RepositoryHandle git_repository_init_ext(FilePath workdirPath, FilePath gitdirPath, bool isBare);
    public static bool git_repository_is_bare(RepositoryHandle repo);
    public static bool git_repository_is_shallow(RepositoryHandle repo);
    public static void git_repository_state_cleanup(RepositoryHandle repo);
    public static ICollection`1<TResult> git_repository_mergehead_foreach(RepositoryHandle repo, Func`2<GitOid, TResult> resultSelector);
    public static string git_repository_message(RepositoryHandle repo);
    public static ObjectDatabaseHandle git_repository_odb(RepositoryHandle repo);
    public static RepositoryHandle git_repository_open(string path);
    public static RepositoryHandle git_repository_new();
    public static void git_repository_open_ext(string path, RepositoryOpenFlags flags, string ceilingDirs);
    public static FilePath git_repository_path(RepositoryHandle repo);
    public static int git_repository_set_config(RepositoryHandle repo, ConfigurationHandle config);
    public static void git_repository_set_ident(RepositoryHandle repo, string name, string email);
    public static int git_repository_set_index(RepositoryHandle repo, IndexHandle index);
    public static void git_repository_set_workdir(RepositoryHandle repo, FilePath workdir);
    public static CurrentOperation git_repository_state(RepositoryHandle repo);
    public static FilePath git_repository_workdir(RepositoryHandle repo);
    public static FilePath git_repository_workdir(IntPtr repo);
    public static void git_repository_set_head_detached(RepositoryHandle repo, ObjectId commitish);
    public static void git_repository_set_head_detached_from_annotated(RepositoryHandle repo, AnnotatedCommitHandle commit);
    public static void git_repository_set_head(RepositoryHandle repo, string refname);
    public static void git_reset(RepositoryHandle repo, ObjectId committishId, ResetMode resetKind, GitCheckoutOpts& checkoutOptions);
    public static void git_revert(RepositoryHandle repo, ObjectId commit, GitRevertOpts opts);
    internal static IndexHandle git_revert_commit(RepositoryHandle repo, ObjectHandle revertCommit, ObjectHandle ourCommit, UInt32 mainline, GitMergeOpts opts, Boolean& earlyStop);
    public static Tuple`2<ObjectHandle, ReferenceHandle> git_revparse_ext(RepositoryHandle repo, string objectish);
    public static ObjectHandle git_revparse_single(RepositoryHandle repo, string objectish);
    public static void git_revwalk_hide(RevWalkerHandle walker, ObjectId commit_id);
    public static RevWalkerHandle git_revwalk_new(RepositoryHandle repo);
    public static ObjectId git_revwalk_next(RevWalkerHandle walker);
    public static void git_revwalk_push(RevWalkerHandle walker, ObjectId id);
    public static void git_revwalk_reset(RevWalkerHandle walker);
    public static int git_revwalk_sorting(RevWalkerHandle walker, CommitSortStrategies options);
    public static int git_revwalk_simplify_first_parent(RevWalkerHandle walker);
    public static SignatureHandle git_signature_new(string name, string email, DateTimeOffset when);
    public static SignatureHandle git_signature_now(string name, string email);
    public static git_signature* git_signature_dup(git_signature* sig);
    public static ObjectId git_stash_save(RepositoryHandle repo, Signature stasher, string prettifiedMessage, StashModifiers options);
    public static ICollection`1<TResult> git_stash_foreach(RepositoryHandle repo, Func`4<int, IntPtr, GitOid, TResult> resultSelector);
    public static void git_stash_drop(RepositoryHandle repo, int index);
    private static StashApplyStatus get_stash_status(int res);
    public static StashApplyStatus git_stash_apply(RepositoryHandle repo, int index, GitStashApplyOpts opts);
    public static StashApplyStatus git_stash_pop(RepositoryHandle repo, int index, GitStashApplyOpts opts);
    public static FileStatus git_status_file(RepositoryHandle repo, FilePath path);
    public static StatusListHandle git_status_list_new(RepositoryHandle repo, GitStatusOptions options);
    public static int git_status_list_entrycount(StatusListHandle list);
    public static git_status_entry* git_status_byindex(StatusListHandle list, long idx);
    public static SubmoduleHandle git_submodule_lookup(RepositoryHandle repo, string name);
    public static string git_submodule_resolve_url(RepositoryHandle repo, string url);
    public static ICollection`1<TResult> git_submodule_foreach(RepositoryHandle repo, Func`3<IntPtr, IntPtr, TResult> resultSelector);
    public static void git_submodule_add_to_index(SubmoduleHandle submodule, bool write_index);
    public static void git_submodule_update(SubmoduleHandle submodule, bool init, GitSubmoduleUpdateOptions& options);
    public static string git_submodule_path(SubmoduleHandle submodule);
    public static string git_submodule_url(SubmoduleHandle submodule);
    public static ObjectId git_submodule_index_id(SubmoduleHandle submodule);
    public static ObjectId git_submodule_head_id(SubmoduleHandle submodule);
    public static ObjectId git_submodule_wd_id(SubmoduleHandle submodule);
    public static SubmoduleIgnore git_submodule_ignore(SubmoduleHandle submodule);
    public static SubmoduleUpdate git_submodule_update_strategy(SubmoduleHandle submodule);
    public static SubmoduleRecurse git_submodule_fetch_recurse_submodules(SubmoduleHandle submodule);
    public static void git_submodule_reload(SubmoduleHandle submodule);
    public static SubmoduleStatus git_submodule_status(RepositoryHandle repo, string name);
    public static void git_submodule_init(SubmoduleHandle submodule, bool overwrite);
    public static ObjectId git_tag_annotation_create(RepositoryHandle repo, string name, GitObject target, Signature tagger, string message);
    public static ObjectId git_tag_create(RepositoryHandle repo, string name, GitObject target, Signature tagger, string message, bool allowOverwrite);
    public static ObjectId git_tag_create_lightweight(RepositoryHandle repo, string name, GitObject target, bool allowOverwrite);
    public static void git_tag_delete(RepositoryHandle repo, string name);
    public static IList`1<string> git_tag_list(RepositoryHandle repo);
    public static string git_tag_message(ObjectHandle tag);
    public static string git_tag_name(ObjectHandle tag);
    public static Signature git_tag_tagger(ObjectHandle tag);
    public static ObjectId git_tag_target_id(ObjectHandle tag);
    public static GitObjectType git_tag_target_type(ObjectHandle tag);
    public static void git_trace_set(LogLevel level, git_trace_cb callback);
    public static void git_transport_register(string prefix, IntPtr transport_cb, IntPtr param);
    public static void git_transport_unregister(string prefix);
    public static int git_transport_smart_credentials(IntPtr& cred, IntPtr transport, string user, int methods);
    public static Mode git_tree_entry_attributes(git_tree_entry* entry);
    public static TreeEntryHandle git_tree_entry_byindex(ObjectHandle tree, long idx);
    public static TreeEntryHandle git_tree_entry_bypath(RepositoryHandle repo, ObjectId id, string treeentry_path);
    public static ObjectId git_tree_entry_id(git_tree_entry* entry);
    public static string git_tree_entry_name(git_tree_entry* entry);
    public static GitObjectType git_tree_entry_type(git_tree_entry* entry);
    public static int git_tree_entrycount(ObjectHandle tree);
    public static TreeBuilderHandle git_treebuilder_new(RepositoryHandle repo);
    public static void git_treebuilder_insert(TreeBuilderHandle builder, string treeentry_name, TreeEntryDefinition treeEntryDefinition);
    public static ObjectId git_treebuilder_write(TreeBuilderHandle bld);
    public static void git_transaction_commit(IntPtr txn);
    public static void git_transaction_free(IntPtr txn);
    public static BuiltInFeatures git_libgit2_features();
    public static string git_libgit2_opts_get_search_path(ConfigurationLevel level);
    public static void git_libgit2_opts_enable_strict_hash_verification(bool enabled);
    public static void git_libgit2_opts_set_search_path(ConfigurationLevel level, string path);
    public static void git_libgit2_opts_set_enable_caching(bool enabled);
    public static void git_libgit2_opts_set_enable_ofsdelta(bool enabled);
    public static void git_libgit2_opts_set_enable_strictobjectcreation(bool enabled);
    public static void git_libgit2_opts_set_user_agent(string userAgent);
    public static string git_libgit2_opts_get_user_agent();
    public static void git_libgit2_opts_set_extensions(String[] extensions);
    public static String[] git_libgit2_opts_get_extensions();
    public static WorktreeHandle git_worktree_lookup(RepositoryHandle repo, string name);
    public static IList`1<string> git_worktree_list(RepositoryHandle repo);
    public static RepositoryHandle git_repository_open_from_worktree(WorktreeHandle handle);
    public static WorktreeLock git_worktree_is_locked(WorktreeHandle worktree);
    public static bool git_worktree_validate(WorktreeHandle worktree);
    public static bool git_worktree_unlock(WorktreeHandle worktree);
    public static bool git_worktree_lock(WorktreeHandle worktree, string reason);
    public static WorktreeHandle git_worktree_add(RepositoryHandle repo, string name, string path, git_worktree_add_options options);
    public static bool git_worktree_prune(WorktreeHandle worktree, git_worktree_prune_options options);
    private static ICollection`1<TResult> git_foreach(Func`2<T, TResult> resultSelector, Func`2<Func`3<T, IntPtr, int>, int> iterator, GitErrorCode[] ignoredErrorCodes);
    private static ICollection`1<TResult> git_foreach(Func`3<T1, T2, TResult> resultSelector, Func`2<Func`4<T1, T2, IntPtr, int>, int> iterator, GitErrorCode[] ignoredErrorCodes);
    private static ICollection`1<TResult> git_foreach(Func`4<T1, T2, T3, TResult> resultSelector, Func`2<Func`5<T1, T2, T3, IntPtr, int>, int> iterator, GitErrorCode[] ignoredErrorCodes);
    private static ICollection`1<TResult> git_foreach(Func`5<T1, T2, T3, T4, TResult> resultSelector, Func`2<Func`6<T1, T2, T3, T4, IntPtr, int>, int> iterator, GitErrorCode[] ignoredErrorCodes);
    private static bool RepositoryStateChecker(RepositoryHandle repo, Func`2<IntPtr, int> checker);
    private static FilePath ConvertPath(Func`2<GitBuf, int> pathRetriever);
    internal static int ConvertResultToCancelFlag(bool result);
}
[ExtensionAttribute]
internal static class LibGit2Sharp.Core.ProxyExtensions : object {
    [ExtensionAttribute]
public static int ConvertToInt(UIntPtr input);
    [ExtensionAttribute]
public static long ConvertToLong(UIntPtr input);
}
internal class LibGit2Sharp.Core.PushTransferCallbacks : object {
    private PushTransferProgressHandler onPushTransferProgress;
    internal PushTransferCallbacks(PushTransferProgressHandler onPushTransferProgress);
    internal git_push_transfer_progress GenerateCallback();
    private int OnGitTransferProgress(UInt32 current, UInt32 total, UIntPtr bytes, IntPtr payload);
}
internal class LibGit2Sharp.Core.RawContentStream : UnmanagedMemoryStream {
    private ObjectHandle handle;
    private ICollection`1<IDisposable> linkedResources;
    internal RawContentStream(ObjectHandle handle, Func`2<ObjectHandle, IntPtr> bytePtrProvider, Func`2<ObjectHandle, long> sizeProvider, ICollection`1<IDisposable> linkedResources);
    private static T Wrap(ObjectHandle handle, Func`2<ObjectHandle, T> provider, IEnumerable`1<IDisposable> linkedResources);
    private static void Dispose(ObjectHandle handle, IEnumerable`1<IDisposable> linkedResources);
    protected virtual void Dispose(bool disposing);
}
[FlagsAttribute]
internal enum LibGit2Sharp.Core.RepositoryOpenFlags : Enum {
    public int value__;
    public static RepositoryOpenFlags NoSearch;
    public static RepositoryOpenFlags CrossFS;
}
[UnmanagedFunctionPointerAttribute("2")]
internal class LibGit2Sharp.Core.stash_apply_progress_cb : MulticastDelegate {
    public stash_apply_progress_cb(object object, IntPtr method);
    public virtual int Invoke(StashApplyProgress progress, IntPtr payload);
    public virtual IAsyncResult BeginInvoke(StashApplyProgress progress, IntPtr payload, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class LibGit2Sharp.Core.StrictFilePathMarshaler : StrictUtf8Marshaler {
    private static StrictFilePathMarshaler staticInstance;
    private static StrictFilePathMarshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public virtual IntPtr MarshalManagedToNative(object managedObj);
    public static IntPtr FromManaged(FilePath filePath);
}
internal class LibGit2Sharp.Core.StrictUtf8Marshaler : EncodingMarshaler {
    private static StrictUtf8Marshaler staticInstance;
    private static Encoding encoding;
    private static StrictUtf8Marshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public static IntPtr FromManaged(string value);
}
[ExtensionAttribute]
internal static class LibGit2Sharp.Core.StringExtensions : object {
    [ExtensionAttribute]
public static int OctalToInt32(string octal);
}
internal class LibGit2Sharp.Core.SubmoduleLazyGroup : LazyGroup`1<SubmoduleHandle> {
    private string name;
    public SubmoduleLazyGroup(Repository repo, string name);
    protected virtual void EvaluateInternal(Action`1<SubmoduleHandle> evaluator);
}
internal class LibGit2Sharp.Core.TarWriter : object {
    private Stream outStream;
    protected Stream OutStream { get; }
    public TarWriter(Stream writeStream);
    protected Stream get_OutStream();
    public sealed virtual void Dispose();
    public void Write(FilePath filePath, Stream data, DateTimeOffset modificationTime, int mode, string userId, string groupId, char typeflag, string userName, string groupName, string deviceMajorNumber, string deviceMinorNumber, string entrySha, bool isLink);
    protected static void WriteContent(long count, Stream data, Stream dest);
    protected void AlignTo512(long size, bool acceptZero);
    protected void WriteHeader(string fileName, string namePrefix, DateTimeOffset lastModificationTime, long count, int mode, string userId, string groupId, char typeflag, string link, string userName, string groupName, string deviceMajorNumber, string deviceMinorNumber);
    private static LinkExtendedHeader ParseLink(bool isLink, Stream data, string entrySha);
    private void WriteExtendedHeader(FileNameExtendedHeader fileNameExtendedHeader, LinkExtendedHeader linkExtendedHeader, string entrySha, DateTimeOffset modificationTime);
    private static string BuildKeyValueExtHeader(string key, string value);
}
internal static class LibGit2Sharp.Core.UniqueId : object {
    public static string UniqueIdentifier;
}
internal class LibGit2Sharp.Core.WriteStream : Stream {
    private GitWriteStream nextStream;
    private IntPtr nextPtr;
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public WriteStream(GitWriteStream nextStream, IntPtr nextPtr);
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public abstract class LibGit2Sharp.Credentials : object {
    protected internal abstract virtual int GitCredentialHandler(IntPtr& cred);
}
public enum LibGit2Sharp.CurrentOperation : Enum {
    public int value__;
    public static CurrentOperation None;
    public static CurrentOperation Merge;
    public static CurrentOperation Revert;
    public static CurrentOperation RevertSequence;
    public static CurrentOperation CherryPick;
    public static CurrentOperation CherryPickSequence;
    public static CurrentOperation Bisect;
    public static CurrentOperation Rebase;
    public static CurrentOperation RebaseInteractive;
    public static CurrentOperation RebaseMerge;
    public static CurrentOperation ApplyMailbox;
    public static CurrentOperation ApplyMailboxOrRebase;
}
public class LibGit2Sharp.DefaultCredentials : Credentials {
    protected internal virtual int GitCredentialHandler(IntPtr& cred);
}
public class LibGit2Sharp.DescribeOptions : object {
    [CompilerGeneratedAttribute]
private DescribeStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCommitIdAsFallback>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumCommitIdAbbreviatedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysRenderLongFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyFollowFirstParent>k__BackingField;
    public DescribeStrategy Strategy { get; public set; }
    public bool UseCommitIdAsFallback { get; public set; }
    public int MinimumCommitIdAbbreviatedSize { get; public set; }
    public bool AlwaysRenderLongFormat { get; public set; }
    public bool OnlyFollowFirstParent { get; public set; }
    [CompilerGeneratedAttribute]
public DescribeStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(DescribeStrategy value);
    [CompilerGeneratedAttribute]
public bool get_UseCommitIdAsFallback();
    [CompilerGeneratedAttribute]
public void set_UseCommitIdAsFallback(bool value);
    [CompilerGeneratedAttribute]
public int get_MinimumCommitIdAbbreviatedSize();
    [CompilerGeneratedAttribute]
public void set_MinimumCommitIdAbbreviatedSize(int value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysRenderLongFormat();
    [CompilerGeneratedAttribute]
public void set_AlwaysRenderLongFormat(bool value);
    [CompilerGeneratedAttribute]
public bool get_OnlyFollowFirstParent();
    [CompilerGeneratedAttribute]
public void set_OnlyFollowFirstParent(bool value);
}
public enum LibGit2Sharp.DescribeStrategy : Enum {
    public int value__;
    public static DescribeStrategy Default;
    public static DescribeStrategy Tags;
    public static DescribeStrategy All;
}
internal class LibGit2Sharp.DetachedHead : Branch {
    public Branch TrackedBranch { get; }
    internal DetachedHead(Repository repo, Reference reference);
    protected virtual string Shorten();
    public virtual Branch get_TrackedBranch();
}
public class LibGit2Sharp.Diff : object {
    private Repository repo;
    private static IDictionary`2<DiffTargets, Func`2<Repository, TreeComparisonHandleRetriever>> HandleRetrieverDispatcher;
    private static IDictionary`2<Type, Func`2<DiffHandle, object>> ChangesBuilders;
    internal Diff(Repository repo);
    private static Diff();
    private static GitDiffOptions BuildOptions(DiffModifiers diffOptions, FilePath[] filePaths, MatchedPathsAggregator matchedPathsAggregator, CompareOptions compareOptions);
    private static IDictionary`2<DiffTargets, Func`2<Repository, TreeComparisonHandleRetriever>> BuildHandleRetrieverDispatcher();
    private static T BuildDiffResult(DiffHandle diff);
    public virtual ContentChanges Compare(Blob oldBlob, Blob newBlob);
    public virtual ContentChanges Compare(Blob oldBlob, Blob newBlob, CompareOptions compareOptions);
    public virtual T Compare(Tree oldTree, Tree newTree);
    public virtual T Compare(Tree oldTree, Tree newTree, IEnumerable`1<string> paths);
    public virtual T Compare(Tree oldTree, Tree newTree, IEnumerable`1<string> paths, ExplicitPathsOptions explicitPathsOptions);
    public virtual T Compare(Tree oldTree, Tree newTree, IEnumerable`1<string> paths, CompareOptions compareOptions);
    public virtual T Compare(Tree oldTree, Tree newTree, CompareOptions compareOptions);
    public virtual T Compare(Tree oldTree, Tree newTree, IEnumerable`1<string> paths, ExplicitPathsOptions explicitPathsOptions, CompareOptions compareOptions);
    public virtual T Compare(Tree oldTree, DiffTargets diffTargets);
    public virtual T Compare(Tree oldTree, DiffTargets diffTargets, IEnumerable`1<string> paths);
    public virtual T Compare(Tree oldTree, DiffTargets diffTargets, IEnumerable`1<string> paths, ExplicitPathsOptions explicitPathsOptions);
    public virtual T Compare(Tree oldTree, DiffTargets diffTargets, IEnumerable`1<string> paths, ExplicitPathsOptions explicitPathsOptions, CompareOptions compareOptions);
    public virtual T Compare();
    public virtual T Compare(IEnumerable`1<string> paths);
    public virtual T Compare(IEnumerable`1<string> paths, bool includeUntracked);
    public virtual T Compare(IEnumerable`1<string> paths, bool includeUntracked, ExplicitPathsOptions explicitPathsOptions);
    public virtual T Compare(IEnumerable`1<string> paths, bool includeUntracked, ExplicitPathsOptions explicitPathsOptions, CompareOptions compareOptions);
    internal virtual T Compare(DiffModifiers diffOptions, IEnumerable`1<string> paths, ExplicitPathsOptions explicitPathsOptions, CompareOptions compareOptions);
    private static TreeComparisonHandleRetriever TreeToTree(Repository repo);
    private static TreeComparisonHandleRetriever WorkdirToIndex(Repository repo);
    private static TreeComparisonHandleRetriever WorkdirToTree(Repository repo);
    private static TreeComparisonHandleRetriever WorkdirAndIndexToTree(Repository repo);
    private static TreeComparisonHandleRetriever IndexToTree(Repository repo);
    private DiffHandle BuildDiffList(ObjectId oldTreeId, ObjectId newTreeId, TreeComparisonHandleRetriever comparisonHandleRetriever, DiffModifiers diffOptions, IEnumerable`1<string> paths, ExplicitPathsOptions explicitPathsOptions, CompareOptions compareOptions);
    private static void DetectRenames(DiffHandle diffList, CompareOptions compareOptions);
    private static void DispatchUnmatchedPaths(ExplicitPathsOptions explicitPathsOptions, IEnumerable`1<FilePath> filePaths, IEnumerable`1<FilePath> matchedPaths);
    private static string BuildUnmatchedPathsMessage(List`1<FilePath> unmatchedPaths);
}
public enum LibGit2Sharp.DiffAlgorithm : Enum {
    public int value__;
    public static DiffAlgorithm Myers;
    public static DiffAlgorithm Minimal;
    public static DiffAlgorithm Patience;
}
[FlagsAttribute]
internal enum LibGit2Sharp.DiffModifiers : Enum {
    public int value__;
    public static DiffModifiers None;
    public static DiffModifiers IncludeUntracked;
    public static DiffModifiers IncludeUnmodified;
    public static DiffModifiers DisablePathspecMatch;
    public static DiffModifiers IncludeIgnored;
}
[FlagsAttribute]
public enum LibGit2Sharp.DiffTargets : Enum {
    public int value__;
    public static DiffTargets Index;
    public static DiffTargets WorkingDirectory;
}
public class LibGit2Sharp.DirectReference : Reference {
    private Lazy`1<GitObject> targetBuilder;
    public GitObject Target { get; }
    internal DirectReference(string canonicalName, IRepository repo, ObjectId targetId);
    public virtual GitObject get_Target();
    public virtual DirectReference ResolveToDirectReference();
}
public class LibGit2Sharp.EmptyCommitException : LibGit2SharpException {
    public EmptyCommitException(string message);
    public EmptyCommitException(string format, Object[] args);
    public EmptyCommitException(string message, Exception innerException);
    protected EmptyCommitException(SerializationInfo info, StreamingContext context);
}
public class LibGit2Sharp.EntryExistsException : LibGit2SharpException {
    public EntryExistsException(string message);
    public EntryExistsException(string format, Object[] args);
    public EntryExistsException(string message, Exception innerException);
    protected EntryExistsException(SerializationInfo info, StreamingContext context);
    internal EntryExistsException(string message, GitErrorCode code, GitErrorCategory category);
}
public class LibGit2Sharp.ExplicitPathsOptions : object {
    [CompilerGeneratedAttribute]
private bool <ShouldFailOnUnmatchedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private UnmatchedPathHandler <OnUnmatchedPath>k__BackingField;
    public bool ShouldFailOnUnmatchedPath { get; public set; }
    public UnmatchedPathHandler OnUnmatchedPath { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ShouldFailOnUnmatchedPath();
    [CompilerGeneratedAttribute]
public void set_ShouldFailOnUnmatchedPath(bool value);
    [CompilerGeneratedAttribute]
public UnmatchedPathHandler get_OnUnmatchedPath();
    [CompilerGeneratedAttribute]
public void set_OnUnmatchedPath(UnmatchedPathHandler value);
}
public enum LibGit2Sharp.FastForwardStrategy : Enum {
    public int value__;
    public static FastForwardStrategy Default;
    public static FastForwardStrategy NoFastForward;
    public static FastForwardStrategy FastForwardOnly;
}
internal class LibGit2Sharp.FetchHead : ReferenceWrapper`1<GitObject> {
    [CompilerGeneratedAttribute]
private string <RemoteCanonicalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForMerge>k__BackingField;
    public string RemoteCanonicalName { get; private set; }
    public GitObject Target { get; }
    public string Url { get; private set; }
    public bool ForMerge { get; private set; }
    internal FetchHead(Repository repo, string remoteCanonicalName, string url, ObjectId targetId, bool forMerge, int index);
    protected virtual string Shorten();
    [CompilerGeneratedAttribute]
public virtual string get_RemoteCanonicalName();
    [CompilerGeneratedAttribute]
private void set_RemoteCanonicalName(string value);
    public virtual GitObject get_Target();
    [CompilerGeneratedAttribute]
public virtual string get_Url();
    [CompilerGeneratedAttribute]
private void set_Url(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_ForMerge();
    [CompilerGeneratedAttribute]
private void set_ForMerge(bool value);
}
public class LibGit2Sharp.FetchOptions : FetchOptionsBase {
    [CompilerGeneratedAttribute]
private Nullable`1<TagFetchMode> <TagFetchMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Prune>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CustomHeaders>k__BackingField;
    public Nullable`1<TagFetchMode> TagFetchMode { get; public set; }
    public Nullable`1<bool> Prune { get; public set; }
    public String[] CustomHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TagFetchMode> get_TagFetchMode();
    [CompilerGeneratedAttribute]
public void set_TagFetchMode(Nullable`1<TagFetchMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Prune();
    [CompilerGeneratedAttribute]
public void set_Prune(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public String[] get_CustomHeaders();
    [CompilerGeneratedAttribute]
public void set_CustomHeaders(String[] value);
}
public abstract class LibGit2Sharp.FetchOptionsBase : object {
    [CompilerGeneratedAttribute]
private ProgressHandler <OnProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private UpdateTipsHandler <OnUpdateTips>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferProgressHandler <OnTransferProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialsHandler <CredentialsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateCheckHandler <CertificateCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryOperationStarting <RepositoryOperationStarting>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryOperationCompleted <RepositoryOperationCompleted>k__BackingField;
    public ProgressHandler OnProgress { get; public set; }
    public UpdateTipsHandler OnUpdateTips { get; public set; }
    public TransferProgressHandler OnTransferProgress { get; public set; }
    public CredentialsHandler CredentialsProvider { get; public set; }
    public CertificateCheckHandler CertificateCheck { get; public set; }
    public RepositoryOperationStarting RepositoryOperationStarting { get; public set; }
    public RepositoryOperationCompleted RepositoryOperationCompleted { get; public set; }
    [CompilerGeneratedAttribute]
public ProgressHandler get_OnProgress();
    [CompilerGeneratedAttribute]
public void set_OnProgress(ProgressHandler value);
    [CompilerGeneratedAttribute]
public UpdateTipsHandler get_OnUpdateTips();
    [CompilerGeneratedAttribute]
public void set_OnUpdateTips(UpdateTipsHandler value);
    [CompilerGeneratedAttribute]
public TransferProgressHandler get_OnTransferProgress();
    [CompilerGeneratedAttribute]
public void set_OnTransferProgress(TransferProgressHandler value);
    [CompilerGeneratedAttribute]
public CredentialsHandler get_CredentialsProvider();
    [CompilerGeneratedAttribute]
public void set_CredentialsProvider(CredentialsHandler value);
    [CompilerGeneratedAttribute]
public CertificateCheckHandler get_CertificateCheck();
    [CompilerGeneratedAttribute]
public void set_CertificateCheck(CertificateCheckHandler value);
    [CompilerGeneratedAttribute]
public RepositoryOperationStarting get_RepositoryOperationStarting();
    [CompilerGeneratedAttribute]
public void set_RepositoryOperationStarting(RepositoryOperationStarting value);
    [CompilerGeneratedAttribute]
public RepositoryOperationCompleted get_RepositoryOperationCompleted();
    [CompilerGeneratedAttribute]
public void set_RepositoryOperationCompleted(RepositoryOperationCompleted value);
}
[FlagsAttribute]
public enum LibGit2Sharp.FileStatus : Enum {
    public int value__;
    public static FileStatus Nonexistent;
    public static FileStatus Unaltered;
    public static FileStatus NewInIndex;
    public static FileStatus ModifiedInIndex;
    public static FileStatus DeletedFromIndex;
    public static FileStatus RenamedInIndex;
    public static FileStatus TypeChangeInIndex;
    public static FileStatus NewInWorkdir;
    public static FileStatus ModifiedInWorkdir;
    public static FileStatus DeletedFromWorkdir;
    public static FileStatus TypeChangeInWorkdir;
    public static FileStatus RenamedInWorkdir;
    public static FileStatus Unreadable;
    public static FileStatus Ignored;
    public static FileStatus Conflicted;
}
public abstract class LibGit2Sharp.Filter : object {
    private static LambdaEqualityHelper`1<Filter> equalityHelper;
    private static int BufferSize;
    private string name;
    private IEnumerable`1<FilterAttributeEntry> attributes;
    private GitFilter gitFilter;
    private ConcurrentDictionary`2<IntPtr, StreamState> activeStreams;
    public string Name { get; }
    public IEnumerable`1<FilterAttributeEntry> Attributes { get; }
    internal GitFilter GitFilter { get; }
    protected Filter(string name, IEnumerable`1<FilterAttributeEntry> attributes);
    private static Filter();
    protected virtual override void Finalize();
    public string get_Name();
    public IEnumerable`1<FilterAttributeEntry> get_Attributes();
    internal GitFilter get_GitFilter();
    protected virtual void Complete(string path, string root, Stream output);
    protected virtual void Initialize();
    protected virtual void Create(string path, string root, FilterMode mode);
    protected virtual void Clean(string path, string root, Stream input, Stream output);
    protected virtual void Smudge(string path, string root, Stream input, Stream output);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Filter other);
    public virtual int GetHashCode();
    public static bool op_Equality(Filter left, Filter right);
    public static bool op_Inequality(Filter left, Filter right);
    private int InitializeCallback(IntPtr filterPointer);
    private int StreamCreateCallback(IntPtr& git_writestream_out, GitFilter self, IntPtr payload, IntPtr filterSourcePtr, IntPtr git_writestream_next);
    private int StreamCloseCallback(IntPtr stream);
    private void StreamFreeCallback(IntPtr stream);
    private int StreamWriteCallback(IntPtr stream, IntPtr buffer, UIntPtr len);
}
public class LibGit2Sharp.FilterAttributeEntry : object {
    private static string AttributeFilterDefinition;
    private string filterDefinition;
    public string FilterDefinition { get; }
    public FilterAttributeEntry(string filterName);
    public virtual string get_FilterDefinition();
}
public class LibGit2Sharp.FilteringOptions : object {
    [CompilerGeneratedAttribute]
private string <HintPath>k__BackingField;
    public string HintPath { get; private set; }
    public FilteringOptions(string hintPath);
    [CompilerGeneratedAttribute]
public string get_HintPath();
    [CompilerGeneratedAttribute]
private void set_HintPath(string value);
}
public enum LibGit2Sharp.FilterMode : Enum {
    public int value__;
    public static FilterMode Smudge;
    public static FilterMode Clean;
}
public class LibGit2Sharp.FilterRegistration : object {
    public static int FilterPriorityMax;
    public static int FilterPriorityMin;
    public Filter Filter;
    public int Priority;
    private IntPtr FilterPointer;
    private bool freed;
    public bool IsValid { get; }
    public string Name { get; }
    internal FilterRegistration(Filter filter, int priority);
    protected virtual override void Finalize();
    public bool get_IsValid();
    public string get_Name();
    internal void Free();
}
public class LibGit2Sharp.FilterSource : object {
    [CompilerGeneratedAttribute]
private FilterMode <SourceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <ObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public FilterMode SourceMode { get; private set; }
    public string Path { get; private set; }
    public ObjectId ObjectId { get; private set; }
    public string Root { get; private set; }
    internal FilterSource(FilePath path, FilterMode mode, git_filter_source* source);
    internal static FilterSource FromNativePtr(IntPtr ptr);
    internal static FilterSource FromNativePtr(git_filter_source* ptr);
    [CompilerGeneratedAttribute]
public virtual FilterMode get_SourceMode();
    [CompilerGeneratedAttribute]
private void set_SourceMode(FilterMode value);
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_ObjectId();
    [CompilerGeneratedAttribute]
private void set_ObjectId(ObjectId value);
    [CompilerGeneratedAttribute]
public virtual string get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(string value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.GitLink : GitObject {
    private string DebuggerDisplay { get; }
    internal GitLink(Repository repo, ObjectId id);
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class LibGit2Sharp.GitObject : object {
    internal static IDictionary`2<Type, ObjectType> TypeToKindMap;
    internal static IDictionary`2<Type, GitObjectType> TypeToGitKindMap;
    private static LambdaEqualityHelper`1<GitObject> equalityHelper;
    private ILazy`1<bool> lazyIsMissing;
    internal Repository repo;
    [CompilerGeneratedAttribute]
private ObjectId <Id>k__BackingField;
    public ObjectId Id { get; private set; }
    public bool IsMissing { get; }
    public string Sha { get; }
    private string DebuggerDisplay { get; }
    private IRepository LibGit2Sharp.IBelongToARepository.Repository { get; }
    protected GitObject(Repository repo, ObjectId id);
    private static GitObject();
    [CompilerGeneratedAttribute]
public virtual ObjectId get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(ObjectId value);
    public virtual bool get_IsMissing();
    public virtual string get_Sha();
    internal static GitObject BuildFrom(Repository repo, ObjectId id, GitObjectType type, string path);
    internal T Peel(bool throwOnError);
    public virtual T Peel();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GitObject other);
    public virtual int GetHashCode();
    public static bool op_Equality(GitObject left, GitObject right);
    public static bool op_Inequality(GitObject left, GitObject right);
    public virtual string ToString();
    private string get_DebuggerDisplay();
    private sealed virtual override IRepository LibGit2Sharp.IBelongToARepository.get_Repository();
}
public class LibGit2Sharp.GitObjectMetadata : object {
    private GitObjectType type;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    public long Size { get; private set; }
    public ObjectType Type { get; }
    internal GitObjectMetadata(long size, GitObjectType type);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(long value);
    public ObjectType get_Type();
}
public enum LibGit2Sharp.GitSmartSubtransportAction : Enum {
    public int value__;
    public static GitSmartSubtransportAction UploadPackList;
    public static GitSmartSubtransportAction UploadPack;
    public static GitSmartSubtransportAction ReceivePackList;
    public static GitSmartSubtransportAction ReceivePack;
}
public static class LibGit2Sharp.GlobalSettings : object {
    private static Lazy`1<Version> version;
    private static Dictionary`2<Filter, FilterRegistration> registeredFilters;
    private static bool nativeLibraryPathAllowed;
    private static LogConfiguration logConfiguration;
    private static string nativeLibraryPath;
    private static bool nativeLibraryPathLocked;
    private static string nativeLibraryDefaultPath;
    public static Version Version { get; }
    public static LogConfiguration LogConfiguration { get; public set; }
    public static string NativeLibraryPath { get; public set; }
    private static GlobalSettings();
    private static string GetExecutingAssemblyDirectory();
    public static Version get_Version();
    public static SmartSubtransportRegistration`1<T> RegisterSmartSubtransport(string scheme);
    public static void UnregisterSmartSubtransport(SmartSubtransportRegistration`1<T> registration);
    public static void set_LogConfiguration(LogConfiguration value);
    public static LogConfiguration get_LogConfiguration();
    public static string get_NativeLibraryPath();
    public static void set_NativeLibraryPath(string value);
    internal static string GetAndLockNativeLibraryPath();
    public static IEnumerable`1<FilterRegistration> GetRegisteredFilters();
    public static FilterRegistration RegisterFilter(Filter filter);
    public static FilterRegistration RegisterFilter(Filter filter, int priority);
    public static void DeregisterFilter(FilterRegistration registration);
    internal static void DeregisterFilter(Filter filter);
    public static IEnumerable`1<string> GetConfigSearchPaths(ConfigurationLevel level);
    public static void SetConfigSearchPaths(ConfigurationLevel level, String[] paths);
    public static void SetStrictHashVerification(bool enabled);
    public static void SetEnableCaching(bool enabled);
    public static void SetEnableOfsDelta(bool enabled);
    public static void SetEnableStrictObjectCreation(bool enabled);
    public static void SetUserAgent(string userAgent);
    public static void SetExtensions(String[] extensions);
    public static String[] GetExtensions();
    public static string GetUserAgent();
}
public class LibGit2Sharp.Handlers.CertificateCheckHandler : MulticastDelegate {
    public CertificateCheckHandler(object object, IntPtr method);
    public virtual bool Invoke(Certificate certificate, bool valid, string host);
    public virtual IAsyncResult BeginInvoke(Certificate certificate, bool valid, string host, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.CheckoutNotifyHandler : MulticastDelegate {
    public CheckoutNotifyHandler(object object, IntPtr method);
    public virtual bool Invoke(string path, CheckoutNotifyFlags notifyFlags);
    public virtual IAsyncResult BeginInvoke(string path, CheckoutNotifyFlags notifyFlags, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.CheckoutProgressHandler : MulticastDelegate {
    public CheckoutProgressHandler(object object, IntPtr method);
    public virtual void Invoke(string path, int completedSteps, int totalSteps);
    public virtual IAsyncResult BeginInvoke(string path, int completedSteps, int totalSteps, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.CredentialsHandler : MulticastDelegate {
    public CredentialsHandler(object object, IntPtr method);
    public virtual Credentials Invoke(string url, string usernameFromUrl, SupportedCredentialTypes types);
    public virtual IAsyncResult BeginInvoke(string url, string usernameFromUrl, SupportedCredentialTypes types, AsyncCallback callback, object object);
    public virtual Credentials EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.LogHandler : MulticastDelegate {
    public LogHandler(object object, IntPtr method);
    public virtual void Invoke(LogLevel level, string message);
    public virtual IAsyncResult BeginInvoke(LogLevel level, string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.PackBuilderProgressHandler : MulticastDelegate {
    public PackBuilderProgressHandler(object object, IntPtr method);
    public virtual bool Invoke(PackBuilderStage stage, int current, int total);
    public virtual IAsyncResult BeginInvoke(PackBuilderStage stage, int current, int total, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public enum LibGit2Sharp.Handlers.PackBuilderStage : Enum {
    public int value__;
    public static PackBuilderStage Counting;
    public static PackBuilderStage Deltafying;
}
public class LibGit2Sharp.Handlers.PrePushHandler : MulticastDelegate {
    public PrePushHandler(object object, IntPtr method);
    public virtual bool Invoke(IEnumerable`1<PushUpdate> updates);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<PushUpdate> updates, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.ProgressHandler : MulticastDelegate {
    public ProgressHandler(object object, IntPtr method);
    public virtual bool Invoke(string serverProgressOutput);
    public virtual IAsyncResult BeginInvoke(string serverProgressOutput, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.PushStatusErrorHandler : MulticastDelegate {
    public PushStatusErrorHandler(object object, IntPtr method);
    public virtual void Invoke(PushStatusError pushStatusErrors);
    public virtual IAsyncResult BeginInvoke(PushStatusError pushStatusErrors, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.PushTransferProgressHandler : MulticastDelegate {
    public PushTransferProgressHandler(object object, IntPtr method);
    public virtual bool Invoke(int current, int total, long bytes);
    public virtual IAsyncResult BeginInvoke(int current, int total, long bytes, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.RebaseStepCompletedHandler : MulticastDelegate {
    public RebaseStepCompletedHandler(object object, IntPtr method);
    public virtual void Invoke(AfterRebaseStepInfo afterRebaseStepInfo);
    public virtual IAsyncResult BeginInvoke(AfterRebaseStepInfo afterRebaseStepInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.RebaseStepStartingHandler : MulticastDelegate {
    public RebaseStepStartingHandler(object object, IntPtr method);
    public virtual void Invoke(BeforeRebaseStepInfo beforeRebaseStep);
    public virtual IAsyncResult BeginInvoke(BeforeRebaseStepInfo beforeRebaseStep, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.RemoteRenameFailureHandler : MulticastDelegate {
    public RemoteRenameFailureHandler(object object, IntPtr method);
    public virtual void Invoke(string problematicRefspec);
    public virtual IAsyncResult BeginInvoke(string problematicRefspec, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.RepositoryOperationCompleted : MulticastDelegate {
    public RepositoryOperationCompleted(object object, IntPtr method);
    public virtual void Invoke(RepositoryOperationContext context);
    public virtual IAsyncResult BeginInvoke(RepositoryOperationContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.RepositoryOperationStarting : MulticastDelegate {
    public RepositoryOperationStarting(object object, IntPtr method);
    public virtual bool Invoke(RepositoryOperationContext context);
    public virtual IAsyncResult BeginInvoke(RepositoryOperationContext context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.StashApplyProgressHandler : MulticastDelegate {
    public StashApplyProgressHandler(object object, IntPtr method);
    public virtual bool Invoke(StashApplyProgress progress);
    public virtual IAsyncResult BeginInvoke(StashApplyProgress progress, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.TransferProgressHandler : MulticastDelegate {
    public TransferProgressHandler(object object, IntPtr method);
    public virtual bool Invoke(TransferProgress progress);
    public virtual IAsyncResult BeginInvoke(TransferProgress progress, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.UnmatchedPathHandler : MulticastDelegate {
    public UnmatchedPathHandler(object object, IntPtr method);
    public virtual void Invoke(string unmatchedPath);
    public virtual IAsyncResult BeginInvoke(string unmatchedPath, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.Handlers.UpdateTipsHandler : MulticastDelegate {
    public UpdateTipsHandler(object object, IntPtr method);
    public virtual bool Invoke(string referenceName, ObjectId oldId, ObjectId newId);
    public virtual IAsyncResult BeginInvoke(string referenceName, ObjectId oldId, ObjectId newId, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class LibGit2Sharp.HistoryDivergence : object {
    private Lazy`1<Commit> commonAncestor;
    [CompilerGeneratedAttribute]
private Commit <One>k__BackingField;
    [CompilerGeneratedAttribute]
private Commit <Another>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <AheadBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BehindBy>k__BackingField;
    public Commit One { get; private set; }
    public Commit Another { get; private set; }
    public Nullable`1<int> AheadBy { get; private set; }
    public Nullable`1<int> BehindBy { get; private set; }
    public Commit CommonAncestor { get; }
    internal HistoryDivergence(Repository repo, Commit one, Commit another);
    [CompilerGeneratedAttribute]
public virtual Commit get_One();
    [CompilerGeneratedAttribute]
private void set_One(Commit value);
    [CompilerGeneratedAttribute]
public virtual Commit get_Another();
    [CompilerGeneratedAttribute]
private void set_Another(Commit value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<int> get_AheadBy();
    [CompilerGeneratedAttribute]
private void set_AheadBy(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<int> get_BehindBy();
    [CompilerGeneratedAttribute]
private void set_BehindBy(Nullable`1<int> value);
    public virtual Commit get_CommonAncestor();
}
public interface LibGit2Sharp.IBelongToARepository {
    public IRepository Repository { get; }
    public abstract virtual IRepository get_Repository();
}
public interface LibGit2Sharp.ICommitLog {
    public CommitSortStrategies SortedBy { get; }
    public abstract virtual CommitSortStrategies get_SortedBy();
}
public class LibGit2Sharp.Identity : object {
    private string _name;
    private string _email;
    public string Email { get; }
    public string Name { get; }
    public Identity(string name, string email);
    public string get_Email();
    public string get_Name();
    internal SignatureHandle BuildNowSignatureHandle();
}
[ExtensionAttribute]
internal static class LibGit2Sharp.IdentityHelpers : object {
    [ExtensionAttribute]
public static SignatureHandle SafeBuildNowSignatureHandle(Identity identity);
}
public interface LibGit2Sharp.IDiffResult {
}
public class LibGit2Sharp.Ignore : object {
    private Repository repo;
    internal Ignore(Repository repo);
    public virtual void AddTemporaryRules(IEnumerable`1<string> rules);
    public virtual void ResetAllTemporaryRules();
    public virtual bool IsPathIgnored(string relativePath);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Index : object {
    private IndexHandle handle;
    private Repository repo;
    private ConflictCollection conflicts;
    internal IndexHandle Handle { get; }
    public int Count { get; }
    public bool IsFullyMerged { get; }
    public IndexEntry Item { get; }
    private IndexEntry Item { get; }
    public ConflictCollection Conflicts { get; }
    private string DebuggerDisplay { get; }
    internal Index(IndexHandle handle, Repository repo);
    internal Index(Repository repo);
    internal Index(Repository repo, string indexPath);
    internal IndexHandle get_Handle();
    public virtual int get_Count();
    public virtual bool get_IsFullyMerged();
    public virtual IndexEntry get_Item(string path);
    private IndexEntry get_Item(int index);
    private List`1<IndexEntry> AllIndexEntries();
    public virtual IEnumerator`1<IndexEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void Replace(Tree source);
    public virtual void Clear();
    private void RemoveFromIndex(string relativePath);
    public virtual void Remove(string indexEntryPath);
    public virtual void Add(string pathInTheWorkdir);
    public virtual void Add(Blob blob, string indexEntryPath, Mode indexEntryMode);
    internal void Replace(TreeChanges changes);
    public virtual ConflictCollection get_Conflicts();
    private void AddEntryToTheIndex(string path, ObjectId id, Mode mode);
    private string get_DebuggerDisplay();
    public virtual void Replace(Commit commit);
    public virtual void Replace(Commit commit, IEnumerable`1<string> paths);
    public virtual void Replace(Commit commit, IEnumerable`1<string> paths, ExplicitPathsOptions explicitPathsOptions);
    public virtual void Write();
    public virtual Tree WriteToTree();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.IndexEntry : object {
    private static LambdaEqualityHelper`1<IndexEntry> equalityHelper;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Mode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private StageLevel <StageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssumeUnchanged>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <Id>k__BackingField;
    public string Path { get; private set; }
    public Mode Mode { get; private set; }
    public StageLevel StageLevel { get; private set; }
    public bool AssumeUnchanged { get; private set; }
    public ObjectId Id { get; private set; }
    private string DebuggerDisplay { get; }
    private static IndexEntry();
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public virtual Mode get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(Mode value);
    [CompilerGeneratedAttribute]
public virtual StageLevel get_StageLevel();
    [CompilerGeneratedAttribute]
private void set_StageLevel(StageLevel value);
    [CompilerGeneratedAttribute]
public virtual bool get_AssumeUnchanged();
    [CompilerGeneratedAttribute]
private void set_AssumeUnchanged(bool value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(ObjectId value);
    internal static IndexEntry BuildFromPtr(git_index_entry* entry);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IndexEntry other);
    public virtual int GetHashCode();
    public static bool op_Equality(IndexEntry left, IndexEntry right);
    public static bool op_Inequality(IndexEntry left, IndexEntry right);
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.IndexNameEntry : object {
    private static LambdaEqualityHelper`1<IndexNameEntry> equalityHelper;
    [CompilerGeneratedAttribute]
private string <Ancestor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Ours>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Theirs>k__BackingField;
    public string Ancestor { get; private set; }
    public string Ours { get; private set; }
    public string Theirs { get; private set; }
    private string DebuggerDisplay { get; }
    private static IndexNameEntry();
    internal static IndexNameEntry BuildFromPtr(git_index_name_entry* entry);
    [CompilerGeneratedAttribute]
public virtual string get_Ancestor();
    [CompilerGeneratedAttribute]
private void set_Ancestor(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Ours();
    [CompilerGeneratedAttribute]
private void set_Ours(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Theirs();
    [CompilerGeneratedAttribute]
private void set_Theirs(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IndexNameEntry other);
    public virtual int GetHashCode();
    public static bool op_Equality(IndexNameEntry left, IndexNameEntry right);
    public static bool op_Inequality(IndexNameEntry left, IndexNameEntry right);
    private string get_DebuggerDisplay();
}
[DefaultMemberAttribute("Item")]
public class LibGit2Sharp.IndexNameEntryCollection : object {
    private Index index;
    private IndexNameEntry Item { get; }
    internal IndexNameEntryCollection(Index index);
    private IndexNameEntry get_Item(int idx);
    private List`1<IndexNameEntry> AllIndexNames();
    public virtual IEnumerator`1<IndexNameEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.IndexReucEntry : object {
    private static LambdaEqualityHelper`1<IndexReucEntry> equalityHelper;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <AncestorId>k__BackingField;
    [CompilerGeneratedAttribute]
private Mode <AncestorMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <OurId>k__BackingField;
    [CompilerGeneratedAttribute]
private Mode <OurMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <TheirId>k__BackingField;
    [CompilerGeneratedAttribute]
private Mode <TheirMode>k__BackingField;
    public string Path { get; private set; }
    public ObjectId AncestorId { get; private set; }
    public Mode AncestorMode { get; private set; }
    public ObjectId OurId { get; private set; }
    public Mode OurMode { get; private set; }
    public ObjectId TheirId { get; private set; }
    public Mode TheirMode { get; private set; }
    private string DebuggerDisplay { get; }
    private static IndexReucEntry();
    internal static IndexReucEntry BuildFromPtr(git_index_reuc_entry* entry);
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_AncestorId();
    [CompilerGeneratedAttribute]
private void set_AncestorId(ObjectId value);
    [CompilerGeneratedAttribute]
public virtual Mode get_AncestorMode();
    [CompilerGeneratedAttribute]
private void set_AncestorMode(Mode value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_OurId();
    [CompilerGeneratedAttribute]
private void set_OurId(ObjectId value);
    [CompilerGeneratedAttribute]
public virtual Mode get_OurMode();
    [CompilerGeneratedAttribute]
private void set_OurMode(Mode value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_TheirId();
    [CompilerGeneratedAttribute]
private void set_TheirId(ObjectId value);
    [CompilerGeneratedAttribute]
public virtual Mode get_TheirMode();
    [CompilerGeneratedAttribute]
private void set_TheirMode(Mode value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IndexReucEntry other);
    public virtual int GetHashCode();
    public static bool op_Equality(IndexReucEntry left, IndexReucEntry right);
    public static bool op_Inequality(IndexReucEntry left, IndexReucEntry right);
    private string get_DebuggerDisplay();
}
[DefaultMemberAttribute("Item")]
public class LibGit2Sharp.IndexReucEntryCollection : object {
    private Index index;
    public IndexReucEntry Item { get; }
    private IndexReucEntry Item { get; }
    internal IndexReucEntryCollection(Index index);
    public virtual IndexReucEntry get_Item(string path);
    private IndexReucEntry get_Item(int idx);
    private List`1<IndexReucEntry> AllIndexReucs();
    public virtual IEnumerator`1<IndexReucEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class LibGit2Sharp.InvalidSpecificationException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public InvalidSpecificationException(string message);
    public InvalidSpecificationException(string format, Object[] args);
    public InvalidSpecificationException(string message, Exception innerException);
    protected InvalidSpecificationException(SerializationInfo info, StreamingContext context);
    internal InvalidSpecificationException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
public interface LibGit2Sharp.IQueryableCommitLog {
    public abstract virtual ICommitLog QueryBy(CommitFilter filter);
    public abstract virtual IEnumerable`1<LogEntry> QueryBy(string path);
    public abstract virtual IEnumerable`1<LogEntry> QueryBy(string path, CommitFilter filter);
}
public interface LibGit2Sharp.IRepository {
    public Branch Head { get; }
    public Configuration Config { get; }
    public Index Index { get; }
    public ReferenceCollection Refs { get; }
    public IQueryableCommitLog Commits { get; }
    public BranchCollection Branches { get; }
    public TagCollection Tags { get; }
    public RepositoryInformation Info { get; }
    public Diff Diff { get; }
    public ObjectDatabase ObjectDatabase { get; }
    public NoteCollection Notes { get; }
    public SubmoduleCollection Submodules { get; }
    public WorktreeCollection Worktrees { get; }
    public Rebase Rebase { get; }
    public Ignore Ignore { get; }
    public Network Network { get; }
    public StashCollection Stashes { get; }
    public abstract virtual Branch get_Head();
    public abstract virtual Configuration get_Config();
    public abstract virtual Index get_Index();
    public abstract virtual ReferenceCollection get_Refs();
    public abstract virtual IQueryableCommitLog get_Commits();
    public abstract virtual BranchCollection get_Branches();
    public abstract virtual TagCollection get_Tags();
    public abstract virtual RepositoryInformation get_Info();
    public abstract virtual Diff get_Diff();
    public abstract virtual ObjectDatabase get_ObjectDatabase();
    public abstract virtual NoteCollection get_Notes();
    public abstract virtual SubmoduleCollection get_Submodules();
    public abstract virtual WorktreeCollection get_Worktrees();
    public abstract virtual void Checkout(Tree tree, IEnumerable`1<string> paths, CheckoutOptions opts);
    public abstract virtual void CheckoutPaths(string committishOrBranchSpec, IEnumerable`1<string> paths, CheckoutOptions checkoutOptions);
    public abstract virtual GitObject Lookup(ObjectId id);
    public abstract virtual GitObject Lookup(string objectish);
    public abstract virtual GitObject Lookup(ObjectId id, ObjectType type);
    public abstract virtual GitObject Lookup(string objectish, ObjectType type);
    public abstract virtual Commit Commit(string message, Signature author, Signature committer, CommitOptions options);
    public abstract virtual void Reset(ResetMode resetMode, Commit commit);
    public abstract virtual void Reset(ResetMode resetMode, Commit commit, CheckoutOptions options);
    public abstract virtual void RemoveUntrackedFiles();
    public abstract virtual RevertResult Revert(Commit commit, Signature reverter, RevertOptions options);
    public abstract virtual MergeResult Merge(Commit commit, Signature merger, MergeOptions options);
    public abstract virtual MergeResult Merge(Branch branch, Signature merger, MergeOptions options);
    public abstract virtual MergeResult Merge(string committish, Signature merger, MergeOptions options);
    public abstract virtual Rebase get_Rebase();
    public abstract virtual MergeResult MergeFetchedRefs(Signature merger, MergeOptions options);
    public abstract virtual CherryPickResult CherryPick(Commit commit, Signature committer, CherryPickOptions options);
    public abstract virtual Ignore get_Ignore();
    public abstract virtual Network get_Network();
    public abstract virtual StashCollection get_Stashes();
    public abstract virtual BlameHunkCollection Blame(string path, BlameOptions options);
    public abstract virtual FileStatus RetrieveStatus(string filePath);
    public abstract virtual RepositoryStatus RetrieveStatus(StatusOptions options);
    public abstract virtual string Describe(Commit commit, DescribeOptions options);
    public abstract virtual void RevParse(string revision, Reference& reference, GitObject& obj);
}
public class LibGit2Sharp.LibGit2SharpException : Exception {
    public LibGit2SharpException(string message);
    public LibGit2SharpException(string message, Exception innerException);
    public LibGit2SharpException(string format, Object[] args);
    protected LibGit2SharpException(SerializationInfo info, StreamingContext context);
}
public class LibGit2Sharp.Line : ValueType {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public int LineNumber { get; }
    public string Content { get; }
    internal Line(int lineNumber, string content);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public string get_Content();
}
public class LibGit2Sharp.LockedFileException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public LockedFileException(string message);
    public LockedFileException(string format, Object[] args);
    public LockedFileException(string message, Exception innerException);
    protected LockedFileException(SerializationInfo info, StreamingContext context);
    internal LockedFileException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
internal class LibGit2Sharp.Log : object {
    private static bool IsEnabled(LogConfiguration configuration, LogLevel level);
    internal static bool IsEnabled(LogLevel level);
    internal static void Write(LogLevel level, string message, Object[] args);
}
public class LibGit2Sharp.LogConfiguration : object {
    public static LogConfiguration None;
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private LogHandler <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private git_trace_cb <GitTraceCallback>k__BackingField;
    internal LogLevel Level { get; private set; }
    internal LogHandler Handler { get; private set; }
    internal git_trace_cb GitTraceCallback { get; private set; }
    public LogConfiguration(LogLevel level, LogHandler handler);
    private static LogConfiguration();
    [CompilerGeneratedAttribute]
internal LogLevel get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
internal LogHandler get_Handler();
    [CompilerGeneratedAttribute]
private void set_Handler(LogHandler value);
    [CompilerGeneratedAttribute]
internal git_trace_cb get_GitTraceCallback();
    [CompilerGeneratedAttribute]
private void set_GitTraceCallback(git_trace_cb value);
    private void GitTraceHandler(LogLevel level, IntPtr msg);
}
public class LibGit2Sharp.LogEntry : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Commit <Commit>k__BackingField;
    public string Path { get; internal set; }
    public Commit Commit { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
public Commit get_Commit();
    [CompilerGeneratedAttribute]
internal void set_Commit(Commit value);
}
public enum LibGit2Sharp.LogLevel : Enum {
    public int value__;
    public static LogLevel None;
    public static LogLevel Fatal;
    public static LogLevel Error;
    public static LogLevel Warning;
    public static LogLevel Info;
    public static LogLevel Debug;
    public static LogLevel Trace;
}
internal class LibGit2Sharp.MatchedPathsAggregator : object {
    private List`1<FilePath> matchedPaths;
    internal int OnGitDiffNotify(IntPtr diffListSoFar, IntPtr deltaToAdd, IntPtr matchedPathspec, IntPtr payload);
    public sealed virtual IEnumerator`1<FilePath> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class LibGit2Sharp.MergeAndCheckoutOptionsBase : MergeOptionsBase {
    [CompilerGeneratedAttribute]
private CheckoutNotifyFlags <CheckoutNotifyFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CommitOnSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutFileConflictStrategy <FileConflictStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutProgressHandler <OnCheckoutProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutNotifyHandler <OnCheckoutNotify>k__BackingField;
    public CheckoutNotifyFlags CheckoutNotifyFlags { get; public set; }
    public bool CommitOnSuccess { get; public set; }
    public CheckoutFileConflictStrategy FileConflictStrategy { get; public set; }
    public CheckoutProgressHandler OnCheckoutProgress { get; public set; }
    public CheckoutNotifyHandler OnCheckoutNotify { get; public set; }
    private CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.CheckoutStrategy { get; }
    [CompilerGeneratedAttribute]
public sealed virtual CheckoutNotifyFlags get_CheckoutNotifyFlags();
    [CompilerGeneratedAttribute]
public void set_CheckoutNotifyFlags(CheckoutNotifyFlags value);
    [CompilerGeneratedAttribute]
public bool get_CommitOnSuccess();
    [CompilerGeneratedAttribute]
public void set_CommitOnSuccess(bool value);
    [CompilerGeneratedAttribute]
public CheckoutFileConflictStrategy get_FileConflictStrategy();
    [CompilerGeneratedAttribute]
public void set_FileConflictStrategy(CheckoutFileConflictStrategy value);
    [CompilerGeneratedAttribute]
public CheckoutProgressHandler get_OnCheckoutProgress();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutProgress(CheckoutProgressHandler value);
    [CompilerGeneratedAttribute]
public CheckoutNotifyHandler get_OnCheckoutNotify();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutNotify(CheckoutNotifyHandler value);
    private sealed virtual override CheckoutCallbacks LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.GenerateCallbacks();
    private sealed virtual override CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.get_CheckoutStrategy();
}
public enum LibGit2Sharp.MergeBaseFindingStrategy : Enum {
    public int value__;
    public static MergeBaseFindingStrategy Standard;
    public static MergeBaseFindingStrategy Octopus;
}
public class LibGit2Sharp.MergeFetchHeadNotFoundException : NotFoundException {
    public MergeFetchHeadNotFoundException(string message);
    public MergeFetchHeadNotFoundException(string format, Object[] args);
    public MergeFetchHeadNotFoundException(string message, Exception innerException);
    protected MergeFetchHeadNotFoundException(SerializationInfo info, StreamingContext context);
}
public enum LibGit2Sharp.MergeFileFavor : Enum {
    public int value__;
    public static MergeFileFavor Normal;
    public static MergeFileFavor Ours;
    public static MergeFileFavor Theirs;
    public static MergeFileFavor Union;
}
internal class LibGit2Sharp.MergeHead : ReferenceWrapper`1<Commit> {
    public Commit Tip { get; }
    internal MergeHead(Repository repo, ObjectId targetId, int index);
    public virtual Commit get_Tip();
    protected virtual string Shorten();
}
public class LibGit2Sharp.MergeOptions : MergeAndCheckoutOptionsBase {
    [CompilerGeneratedAttribute]
private FastForwardStrategy <FastForwardStrategy>k__BackingField;
    public FastForwardStrategy FastForwardStrategy { get; public set; }
    [CompilerGeneratedAttribute]
public FastForwardStrategy get_FastForwardStrategy();
    [CompilerGeneratedAttribute]
public void set_FastForwardStrategy(FastForwardStrategy value);
}
public abstract class LibGit2Sharp.MergeOptionsBase : object {
    [CompilerGeneratedAttribute]
private bool <FindRenames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailOnConflict>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipReuc>k__BackingField;
    public int RenameThreshold;
    public int TargetLimit;
    [CompilerGeneratedAttribute]
private MergeFileFavor <MergeFileFavor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreWhitespaceChange>k__BackingField;
    public bool FindRenames { get; public set; }
    public bool FailOnConflict { get; public set; }
    public bool SkipReuc { get; public set; }
    public MergeFileFavor MergeFileFavor { get; public set; }
    public bool IgnoreWhitespaceChange { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_FindRenames();
    [CompilerGeneratedAttribute]
public void set_FindRenames(bool value);
    [CompilerGeneratedAttribute]
public bool get_FailOnConflict();
    [CompilerGeneratedAttribute]
public void set_FailOnConflict(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipReuc();
    [CompilerGeneratedAttribute]
public void set_SkipReuc(bool value);
    [CompilerGeneratedAttribute]
public MergeFileFavor get_MergeFileFavor();
    [CompilerGeneratedAttribute]
public void set_MergeFileFavor(MergeFileFavor value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreWhitespaceChange();
    [CompilerGeneratedAttribute]
public void set_IgnoreWhitespaceChange(bool value);
}
public class LibGit2Sharp.MergeResult : object {
    [CompilerGeneratedAttribute]
private MergeStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Commit <Commit>k__BackingField;
    public MergeStatus Status { get; private set; }
    public Commit Commit { get; private set; }
    internal MergeResult(MergeStatus status, Commit commit);
    [CompilerGeneratedAttribute]
public virtual MergeStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(MergeStatus value);
    [CompilerGeneratedAttribute]
public virtual Commit get_Commit();
    [CompilerGeneratedAttribute]
private void set_Commit(Commit value);
}
public enum LibGit2Sharp.MergeStatus : Enum {
    public int value__;
    public static MergeStatus UpToDate;
    public static MergeStatus FastForward;
    public static MergeStatus NonFastForward;
    public static MergeStatus Conflicts;
}
public class LibGit2Sharp.MergeTreeOptions : MergeOptionsBase {
}
public class LibGit2Sharp.MergeTreeResult : object {
    [CompilerGeneratedAttribute]
private MergeTreeStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Tree <Tree>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Conflict> <Conflicts>k__BackingField;
    public MergeTreeStatus Status { get; private set; }
    public Tree Tree { get; private set; }
    public IEnumerable`1<Conflict> Conflicts { get; private set; }
    internal MergeTreeResult(IEnumerable`1<Conflict> conflicts);
    internal MergeTreeResult(Tree tree);
    [CompilerGeneratedAttribute]
public virtual MergeTreeStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(MergeTreeStatus value);
    [CompilerGeneratedAttribute]
public virtual Tree get_Tree();
    [CompilerGeneratedAttribute]
private void set_Tree(Tree value);
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<Conflict> get_Conflicts();
    [CompilerGeneratedAttribute]
private void set_Conflicts(IEnumerable`1<Conflict> value);
}
public enum LibGit2Sharp.MergeTreeStatus : Enum {
    public int value__;
    public static MergeTreeStatus Succeeded;
    public static MergeTreeStatus Conflicts;
}
public enum LibGit2Sharp.Mode : Enum {
    public int value__;
    public static Mode Nonexistent;
    public static Mode Directory;
    public static Mode NonExecutableFile;
    public static Mode NonExecutableGroupWritableFile;
    public static Mode ExecutableFile;
    public static Mode SymbolicLink;
    public static Mode GitLink;
}
public class LibGit2Sharp.NameConflictException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public NameConflictException(string message);
    public NameConflictException(string format, Object[] args);
    public NameConflictException(string message, Exception innerException);
    protected NameConflictException(SerializationInfo info, StreamingContext context);
    internal NameConflictException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
public abstract class LibGit2Sharp.NativeException : LibGit2SharpException {
    internal GitErrorCode ErrorCode { get; }
    internal NativeException(string message);
    internal NativeException(string message, Exception innerException);
    internal NativeException(string format, Object[] args);
    internal NativeException(SerializationInfo info, StreamingContext context);
    internal NativeException(string message, GitErrorCategory category);
    internal abstract virtual GitErrorCode get_ErrorCode();
}
public class LibGit2Sharp.Network : object {
    private Repository repository;
    private Lazy`1<RemoteCollection> remotes;
    public RemoteCollection Remotes { get; }
    internal IEnumerable`1<FetchHead> FetchHeads { get; }
    internal Network(Repository repository);
    public virtual RemoteCollection get_Remotes();
    public virtual IEnumerable`1<Reference> ListReferences(Remote remote);
    public virtual IEnumerable`1<Reference> ListReferences(Remote remote, CredentialsHandler credentialsProvider);
    public virtual IEnumerable`1<Reference> ListReferences(string url);
    public virtual IEnumerable`1<Reference> ListReferences(string url, CredentialsHandler credentialsProvider);
    private IEnumerable`1<Reference> ListReferencesInternal(string url, CredentialsHandler credentialsProvider);
    private static RemoteHandle BuildRemoteHandle(RepositoryHandle repoHandle, string url);
    public virtual void Fetch(string url, IEnumerable`1<string> refspecs);
    public virtual void Fetch(string url, IEnumerable`1<string> refspecs, FetchOptions options);
    public virtual void Fetch(string url, IEnumerable`1<string> refspecs, string logMessage);
    public virtual void Fetch(string url, IEnumerable`1<string> refspecs, FetchOptions options, string logMessage);
    public virtual void Push(Branch branch);
    public virtual void Push(Branch branch, PushOptions pushOptions);
    public virtual void Push(IEnumerable`1<Branch> branches);
    public virtual void Push(IEnumerable`1<Branch> branches, PushOptions pushOptions);
    public virtual void Push(Remote remote, string objectish, string destinationSpec);
    public virtual void Push(Remote remote, string objectish, string destinationSpec, PushOptions pushOptions);
    public virtual void Push(Remote remote, string pushRefSpec);
    public virtual void Push(Remote remote, string pushRefSpec, PushOptions pushOptions);
    public virtual void Push(Remote remote, IEnumerable`1<string> pushRefSpecs);
    public virtual void Push(Remote remote, IEnumerable`1<string> pushRefSpecs, PushOptions pushOptions);
    internal virtual IEnumerable`1<FetchHead> get_FetchHeads();
}
public class LibGit2Sharp.NonFastForwardException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public NonFastForwardException(string message);
    public NonFastForwardException(string format, Object[] args);
    public NonFastForwardException(string message, Exception innerException);
    protected NonFastForwardException(SerializationInfo info, StreamingContext context);
    internal NonFastForwardException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Note : object {
    private static LambdaEqualityHelper`1<Note> equalityHelper;
    [CompilerGeneratedAttribute]
private ObjectId <BlobId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <TargetObjectId>k__BackingField;
    public ObjectId BlobId { get; private set; }
    public string Message { get; private set; }
    public string Namespace { get; private set; }
    public ObjectId TargetObjectId { get; private set; }
    private string DebuggerDisplay { get; }
    private Note(ObjectId blobId, string message, ObjectId targetObjectId, string namespace);
    private static Note();
    [CompilerGeneratedAttribute]
public virtual ObjectId get_BlobId();
    [CompilerGeneratedAttribute]
private void set_BlobId(ObjectId value);
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Namespace();
    [CompilerGeneratedAttribute]
private void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_TargetObjectId();
    [CompilerGeneratedAttribute]
private void set_TargetObjectId(ObjectId value);
    internal static Note BuildFromPtr(NoteHandle note, string namespace, ObjectId targetObjectId);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Note other);
    public virtual int GetHashCode();
    public static bool op_Equality(Note left, Note right);
    public static bool op_Inequality(Note left, Note right);
    private string get_DebuggerDisplay();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.NoteCollection : object {
    internal Repository repo;
    private Lazy`1<string> defaultNamespace;
    public string DefaultNamespace { get; }
    public IEnumerable`1<string> Namespaces { get; }
    internal IEnumerable`1<string> NamespaceRefs { get; }
    public IEnumerable`1<Note> Item { get; }
    public IEnumerable`1<Note> Item { get; }
    public Note Item { get; }
    private string DebuggerDisplay { get; }
    internal NoteCollection(Repository repo);
    public virtual IEnumerator`1<Note> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string get_DefaultNamespace();
    public virtual IEnumerable`1<string> get_Namespaces();
    internal IEnumerable`1<string> get_NamespaceRefs();
    public virtual IEnumerable`1<Note> get_Item(ObjectId id);
    public virtual IEnumerable`1<Note> get_Item(string namespace);
    public virtual Note get_Item(string namespace, ObjectId id);
    private string RetrieveDefaultNamespace();
    internal static string NormalizeToCanonicalName(string name);
    internal static string UnCanonicalizeName(string name);
    public virtual Note Add(ObjectId targetId, string message, Signature author, Signature committer, string namespace);
    public virtual void Remove(ObjectId targetId, Signature author, Signature committer, string namespace);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private bool <get_NamespaceRefs>b__11_1(string refCanonical);
}
public class LibGit2Sharp.NotFoundException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public NotFoundException(string message);
    public NotFoundException(string format, Object[] args);
    public NotFoundException(string message, Exception innerException);
    protected NotFoundException(SerializationInfo info, StreamingContext context);
    internal NotFoundException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
internal class LibGit2Sharp.NullHistoryDivergence : HistoryDivergence {
    public Commit CommonAncestor { get; }
    public virtual Commit get_CommonAncestor();
}
public class LibGit2Sharp.ObjectDatabase : object {
    private Repository repo;
    private ObjectDatabaseHandle handle;
    internal ObjectDatabase(Repository repo);
    public virtual IEnumerator`1<GitObject> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Contains(ObjectId objectId);
    public virtual GitObjectMetadata RetrieveObjectMetadata(ObjectId objectId);
    public virtual Blob CreateBlob(string path);
    public virtual void AddBackend(OdbBackend backend, int priority);
    public virtual ObjectId Write(Byte[] data);
    public virtual ObjectId Write(Stream stream, long numberOfBytesToConsume);
    public virtual Blob CreateBlob(Stream stream);
    public virtual Blob CreateBlob(Stream stream, string hintpath);
    public virtual Blob CreateBlob(Stream stream, string hintpath, long numberOfBytesToConsume);
    private Blob CreateBlob(Stream stream, string hintpath, Nullable`1<long> numberOfBytesToConsume);
    public virtual Blob CreateBlob(Stream stream, long numberOfBytesToConsume);
    public virtual Tree CreateTree(TreeDefinition treeDefinition);
    public virtual Tree CreateTree(Index index);
    public virtual Commit CreateCommit(Signature author, Signature committer, string message, Tree tree, IEnumerable`1<Commit> parents, bool prettifyMessage);
    public virtual Commit CreateCommit(Signature author, Signature committer, string message, Tree tree, IEnumerable`1<Commit> parents, bool prettifyMessage, Nullable`1<char> commentChar);
    public virtual ObjectId CreateCommitWithSignature(string commitContent, string signature, string field);
    public virtual ObjectId CreateCommitWithSignature(string commitContent, string signature);
    public virtual TagAnnotation CreateTagAnnotation(string name, GitObject target, Signature tagger, string message);
    public virtual void Archive(Tree tree, string archivePath);
    public virtual void Archive(Commit commit, string archivePath);
    public virtual void Archive(Commit commit, ArchiverBase archiver);
    public virtual void Archive(Tree tree, ArchiverBase archiver);
    public virtual HistoryDivergence CalculateHistoryDivergence(Commit one, Commit another);
    public virtual MergeTreeResult CherryPickCommit(Commit cherryPickCommit, Commit cherryPickOnto, int mainline, MergeTreeOptions options);
    public virtual string ShortenObjectId(GitObject gitObject);
    public virtual string ShortenObjectId(GitObject gitObject, int minLength);
    public virtual bool CanMergeWithoutConflict(Commit one, Commit another);
    public virtual Commit FindMergeBase(Commit first, Commit second);
    public virtual Commit FindMergeBase(IEnumerable`1<Commit> commits, MergeBaseFindingStrategy strategy);
    public virtual MergeTreeResult MergeCommits(Commit ours, Commit theirs, MergeTreeOptions options);
    public virtual PackBuilderResults Pack(PackBuilderOptions options);
    public virtual PackBuilderResults Pack(PackBuilderOptions options, Action`1<PackBuilder> packDelegate);
    public virtual TransientIndex MergeCommitsIntoIndex(Commit ours, Commit theirs, MergeTreeOptions options);
    public virtual TransientIndex CherryPickCommitIntoIndex(Commit cherryPickCommit, Commit cherryPickOnto, int mainline, MergeTreeOptions options);
    private IndexHandle MergeCommits(Commit ours, Commit theirs, MergeTreeOptions options, Boolean& earlyStop);
    private IndexHandle CherryPickCommit(Commit cherryPickCommit, Commit cherryPickOnto, int mainline, MergeTreeOptions options, Boolean& earlyStop);
    private PackBuilderResults InternalPack(PackBuilderOptions options, Action`1<PackBuilder> packDelegate);
    public virtual MergeTreeResult RevertCommit(Commit revertCommit, Commit revertOnto, int mainline, MergeTreeOptions options);
    [CompilerGeneratedAttribute]
private GitObject <GetEnumerator>b__4_0(ObjectId gitOid);
    [CompilerGeneratedAttribute]
private void <Pack>b__37_0(PackBuilder builder);
}
public class LibGit2Sharp.ObjectId : object {
    private GitOid oid;
    private static int rawSize;
    private string sha;
    internal static int HexSize;
    private static string hexDigits;
    private static Byte[] reverseHexDigits;
    private static Func`2<int, byte> byteConverter;
    private static LambdaEqualityHelper`1<ObjectId> equalityHelper;
    public static ObjectId Zero;
    internal GitOid Oid { get; }
    public Byte[] RawId { get; }
    public string Sha { get; }
    internal ObjectId(GitOid oid);
    public ObjectId(Byte[] rawId);
    internal ObjectId(Byte* rawId);
    public ObjectId(string sha);
    private static ObjectId();
    internal static ObjectId BuildFromPtr(IntPtr ptr);
    internal static ObjectId BuildFromPtr(git_oid* id);
    internal GitOid get_Oid();
    public Byte[] get_RawId();
    public string get_Sha();
    public static bool TryParse(string sha, ObjectId& result);
    private static Nullable`1<GitOid> BuildOidFrom(string sha, bool shouldThrowIfInvalid);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ObjectId other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(int prefixLength);
    private static int NormalizeLength(int prefixLength);
    public static bool op_Equality(ObjectId left, ObjectId right);
    public static bool op_Inequality(ObjectId left, ObjectId right);
    public static ObjectId op_Explicit(string sha);
    private static Byte[] BuildReverseHexDigits();
    internal static string ToString(Byte[] id, int lengthInNibbles);
    private static GitOid ToOid(string sha);
    private static bool LooksValid(string objectId, bool throwIfInvalid);
    public bool StartsWith(string shortSha);
}
public enum LibGit2Sharp.ObjectType : Enum {
    public int value__;
    public static ObjectType Commit;
    public static ObjectType Tree;
    public static ObjectType Blob;
    public static ObjectType Tag;
}
[ExtensionAttribute]
internal static class LibGit2Sharp.ObjectTypeExtensions : object {
    [ExtensionAttribute]
public static GitObjectType ToGitObjectType(ObjectType type);
}
public abstract class LibGit2Sharp.OdbBackend : object {
    private IntPtr nativeBackendPointer;
    protected OdbBackendOperations SupportedOperations { get; }
    internal IntPtr GitOdbBackendPointer { get; }
    internal void Free();
    protected abstract virtual OdbBackendOperations get_SupportedOperations();
    protected UnmanagedMemoryStream AllocateAndBuildFrom(Byte[] bytes);
    protected UnmanagedMemoryStream Allocate(long size);
    public abstract virtual int Read(ObjectId id, UnmanagedMemoryStream& data, ObjectType& objectType);
    public abstract virtual int ReadPrefix(string shortSha, ObjectId& oid, UnmanagedMemoryStream& data, ObjectType& objectType);
    public abstract virtual int ReadHeader(ObjectId id, Int32& length, ObjectType& objectType);
    public abstract virtual int Write(ObjectId id, Stream dataStream, long length, ObjectType objectType);
    public abstract virtual int ReadStream(ObjectId id, OdbBackendStream& stream);
    public abstract virtual int WriteStream(long length, ObjectType objectType, OdbBackendStream& stream);
    public abstract virtual bool Exists(ObjectId id);
    public abstract virtual int ExistsPrefix(string shortSha, ObjectId& found);
    public abstract virtual int ForEach(ForEachCallback callback);
    internal IntPtr get_GitOdbBackendPointer();
    internal static long ConverToLong(UIntPtr len);
}
public abstract class LibGit2Sharp.OdbBackendStream : object {
    private OdbBackend backend;
    private IntPtr nativeBackendStreamPointer;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public OdbBackend Backend { get; }
    internal IntPtr GitOdbBackendStreamPointer { get; }
    protected OdbBackendStream(OdbBackend backend);
    protected virtual void Dispose();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public abstract virtual int Read(Stream dataStream, long length);
    public abstract virtual int Write(Stream dataStream, long length);
    public abstract virtual int FinalizeWrite(ObjectId id);
    public virtual OdbBackend get_Backend();
    internal IntPtr get_GitOdbBackendStreamPointer();
}
public class LibGit2Sharp.PackBuilder : object {
    private PackBuilderHandle packBuilderHandle;
    internal long ObjectsCount { get; }
    internal long WrittenObjectsCount { get; }
    internal PackBuilderHandle Handle { get; }
    internal PackBuilder(Repository repository);
    public void Add(T gitObject);
    public void AddRecursively(T gitObject);
    public void Add(ObjectId id);
    public void AddRecursively(ObjectId id);
    private sealed virtual override void System.IDisposable.Dispose();
    internal void Write(string path);
    internal int SetMaximumNumberOfThreads(int nThread);
    internal long get_ObjectsCount();
    internal long get_WrittenObjectsCount();
    internal PackBuilderHandle get_Handle();
}
public class LibGit2Sharp.PackBuilderOptions : object {
    private string path;
    private int nThreads;
    public string PackDirectoryPath { get; public set; }
    public int MaximumNumberOfThreads { get; public set; }
    public PackBuilderOptions(string packDirectory);
    public void set_PackDirectoryPath(string value);
    public string get_PackDirectoryPath();
    public void set_MaximumNumberOfThreads(int value);
    public int get_MaximumNumberOfThreads();
}
public class LibGit2Sharp.PackBuilderResults : ValueType {
    [CompilerGeneratedAttribute]
private long <WrittenObjectsCount>k__BackingField;
    public long WrittenObjectsCount { get; internal set; }
    [CompilerGeneratedAttribute]
public long get_WrittenObjectsCount();
    [CompilerGeneratedAttribute]
internal void set_WrittenObjectsCount(long value);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Patch : object {
    private StringBuilder fullPatchBuilder;
    private IDictionary`2<FilePath, PatchEntryChanges> changes;
    private int linesAdded;
    private int linesDeleted;
    public PatchEntryChanges Item { get; }
    private PatchEntryChanges Item { get; }
    public int LinesAdded { get; }
    public int LinesDeleted { get; }
    public string Content { get; }
    private string DebuggerDisplay { get; }
    internal Patch(DiffHandle diff);
    private void AddFileChange(git_diff_delta* delta);
    private int PrintCallBack(git_diff_delta* delta, GitDiffHunk hunk, GitDiffLine line, IntPtr payload);
    public virtual IEnumerator`1<PatchEntryChanges> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual PatchEntryChanges get_Item(string path);
    private PatchEntryChanges get_Item(FilePath path);
    public virtual int get_LinesAdded();
    public virtual int get_LinesDeleted();
    public virtual string get_Content();
    public static string op_Implicit(Patch patch);
    private string get_DebuggerDisplay();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class LibGit2Sharp.PatchEntryChanges : ContentChanges {
    private TreeEntryChanges treeEntryChanges;
    public string Path { get; }
    public Mode Mode { get; }
    public ObjectId Oid { get; }
    public ChangeKind Status { get; }
    public string OldPath { get; }
    public Mode OldMode { get; }
    public ObjectId OldOid { get; }
    internal PatchEntryChanges(bool isBinaryComparison, TreeEntryChanges treeEntryChanges);
    public virtual string get_Path();
    public virtual Mode get_Mode();
    public virtual ObjectId get_Oid();
    public virtual ChangeKind get_Status();
    public virtual string get_OldPath();
    public virtual Mode get_OldMode();
    public virtual ObjectId get_OldOid();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.PatchStats : object {
    private IDictionary`2<FilePath, ContentChangeStats> changes;
    private int totalLinesAdded;
    private int totalLinesDeleted;
    public ContentChangeStats Item { get; }
    private ContentChangeStats Item { get; }
    public int TotalLinesAdded { get; }
    public int TotalLinesDeleted { get; }
    private string DebuggerDisplay { get; }
    internal PatchStats(DiffHandle diff);
    public virtual IEnumerator`1<ContentChangeStats> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual ContentChangeStats get_Item(string path);
    private ContentChangeStats get_Item(FilePath path);
    public virtual int get_TotalLinesAdded();
    public virtual int get_TotalLinesDeleted();
    private string get_DebuggerDisplay();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class LibGit2Sharp.PeelException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public PeelException(string message);
    public PeelException(string format, Object[] args);
    public PeelException(string message, Exception innerException);
    protected PeelException(SerializationInfo info, StreamingContext context);
    internal PeelException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
public class LibGit2Sharp.PullOptions : object {
    [CompilerGeneratedAttribute]
private FetchOptions <FetchOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private MergeOptions <MergeOptions>k__BackingField;
    public FetchOptions FetchOptions { get; public set; }
    public MergeOptions MergeOptions { get; public set; }
    [CompilerGeneratedAttribute]
public FetchOptions get_FetchOptions();
    [CompilerGeneratedAttribute]
public void set_FetchOptions(FetchOptions value);
    [CompilerGeneratedAttribute]
public MergeOptions get_MergeOptions();
    [CompilerGeneratedAttribute]
public void set_MergeOptions(MergeOptions value);
}
public class LibGit2Sharp.PushOptions : object {
    [CompilerGeneratedAttribute]
private CredentialsHandler <CredentialsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateCheckHandler <CertificateCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PackbuilderDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private PushStatusErrorHandler <OnPushStatusError>k__BackingField;
    [CompilerGeneratedAttribute]
private PushTransferProgressHandler <OnPushTransferProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private PackBuilderProgressHandler <OnPackBuilderProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private PrePushHandler <OnNegotiationCompletedBeforePush>k__BackingField;
    public CredentialsHandler CredentialsProvider { get; public set; }
    public CertificateCheckHandler CertificateCheck { get; public set; }
    public int PackbuilderDegreeOfParallelism { get; public set; }
    public PushStatusErrorHandler OnPushStatusError { get; public set; }
    public PushTransferProgressHandler OnPushTransferProgress { get; public set; }
    public PackBuilderProgressHandler OnPackBuilderProgress { get; public set; }
    public PrePushHandler OnNegotiationCompletedBeforePush { get; public set; }
    [CompilerGeneratedAttribute]
public CredentialsHandler get_CredentialsProvider();
    [CompilerGeneratedAttribute]
public void set_CredentialsProvider(CredentialsHandler value);
    [CompilerGeneratedAttribute]
public CertificateCheckHandler get_CertificateCheck();
    [CompilerGeneratedAttribute]
public void set_CertificateCheck(CertificateCheckHandler value);
    [CompilerGeneratedAttribute]
public int get_PackbuilderDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public void set_PackbuilderDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public PushStatusErrorHandler get_OnPushStatusError();
    [CompilerGeneratedAttribute]
public void set_OnPushStatusError(PushStatusErrorHandler value);
    [CompilerGeneratedAttribute]
public PushTransferProgressHandler get_OnPushTransferProgress();
    [CompilerGeneratedAttribute]
public void set_OnPushTransferProgress(PushTransferProgressHandler value);
    [CompilerGeneratedAttribute]
public PackBuilderProgressHandler get_OnPackBuilderProgress();
    [CompilerGeneratedAttribute]
public void set_OnPackBuilderProgress(PackBuilderProgressHandler value);
    [CompilerGeneratedAttribute]
public PrePushHandler get_OnNegotiationCompletedBeforePush();
    [CompilerGeneratedAttribute]
public void set_OnNegotiationCompletedBeforePush(PrePushHandler value);
}
public class LibGit2Sharp.PushResult : object {
    private List`1<PushStatusError> failedPushUpdates;
    public IEnumerable`1<PushStatusError> FailedPushUpdates { get; }
    public bool HasErrors { get; }
    internal PushResult(List`1<PushStatusError> failedPushUpdates);
    public virtual IEnumerable`1<PushStatusError> get_FailedPushUpdates();
    public virtual bool get_HasErrors();
}
public class LibGit2Sharp.PushStatusError : object {
    [CompilerGeneratedAttribute]
private string <Reference>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Reference { get; private set; }
    public string Message { get; private set; }
    internal PushStatusError(string reference, string message);
    [CompilerGeneratedAttribute]
public virtual string get_Reference();
    [CompilerGeneratedAttribute]
private void set_Reference(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
}
public class LibGit2Sharp.PushUpdate : object {
    public string SourceRefName;
    public string DestinationRefName;
    public ObjectId SourceObjectId;
    public ObjectId DestinationObjectId;
    internal PushUpdate(string srcRefName, ObjectId srcOid, string dstRefName, ObjectId dstOid);
    internal PushUpdate(git_push_update* update);
}
public class LibGit2Sharp.Rebase : object {
    internal Repository repository;
    internal Rebase(Repository repo);
    private AnnotatedCommitHandle AnnotatedCommitHandleFromRefHandle(ReferenceHandle refHandle);
    public virtual RebaseResult Start(Branch branch, Branch upstream, Branch onto, Identity committer, RebaseOptions options);
    public virtual RebaseResult Continue(Identity committer, RebaseOptions options);
    public virtual void Abort();
    public virtual void Abort(RebaseOptions options);
    public virtual RebaseStepInfo GetCurrentStepInfo();
    public virtual RebaseStepInfo GetStepInfo(long stepIndex);
    public virtual long GetCurrentStepIndex();
    public virtual long GetTotalStepCount();
    private void EnsureNonBareRepo();
    [CompilerGeneratedAttribute]
private ReferenceHandle <Start>b__4_0(Branch b);
}
internal class LibGit2Sharp.RebaseOperationImpl : object {
    public static RebaseResult Run(RebaseHandle rebaseOperationHandle, Repository repository, Identity committer, RebaseOptions options);
    private static RebaseResult CompleteRebase(RebaseHandle rebaseOperationHandle, Identity committer);
    private static RebaseResult RunRebaseStep(RebaseHandle rebaseOperationHandle, Repository repository, Identity committer, RebaseOptions options, long stepToApplyIndex, long totalStepCount);
    private static RebaseStepResult ApplyPickStep(RebaseHandle rebaseOperationHandle, Repository repository, Identity committer, RebaseOptions options, RebaseStepInfo stepToApplyInfo);
    private static void VerifyRebaseOp(git_rebase_operation* rebaseOpReport, RebaseStepInfo stepInfo);
    private static RebaseProgress NextRebaseStep(Repository repository, RebaseHandle rebaseOperationHandle);
}
public class LibGit2Sharp.RebaseOptions : object {
    [CompilerGeneratedAttribute]
private RebaseStepStartingHandler <RebaseStepStarting>k__BackingField;
    [CompilerGeneratedAttribute]
private RebaseStepCompletedHandler <RebaseStepCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutNotifyFlags <CheckoutNotifyFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutProgressHandler <OnCheckoutProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutNotifyHandler <OnCheckoutNotify>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutFileConflictStrategy <FileConflictStrategy>k__BackingField;
    public RebaseStepStartingHandler RebaseStepStarting { get; public set; }
    public RebaseStepCompletedHandler RebaseStepCompleted { get; public set; }
    public CheckoutNotifyFlags CheckoutNotifyFlags { get; public set; }
    public CheckoutProgressHandler OnCheckoutProgress { get; public set; }
    public CheckoutNotifyHandler OnCheckoutNotify { get; public set; }
    public CheckoutFileConflictStrategy FileConflictStrategy { get; public set; }
    private CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.CheckoutStrategy { get; }
    [CompilerGeneratedAttribute]
public RebaseStepStartingHandler get_RebaseStepStarting();
    [CompilerGeneratedAttribute]
public void set_RebaseStepStarting(RebaseStepStartingHandler value);
    [CompilerGeneratedAttribute]
public RebaseStepCompletedHandler get_RebaseStepCompleted();
    [CompilerGeneratedAttribute]
public void set_RebaseStepCompleted(RebaseStepCompletedHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual CheckoutNotifyFlags get_CheckoutNotifyFlags();
    [CompilerGeneratedAttribute]
public void set_CheckoutNotifyFlags(CheckoutNotifyFlags value);
    [CompilerGeneratedAttribute]
public CheckoutProgressHandler get_OnCheckoutProgress();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutProgress(CheckoutProgressHandler value);
    [CompilerGeneratedAttribute]
public CheckoutNotifyHandler get_OnCheckoutNotify();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutNotify(CheckoutNotifyHandler value);
    [CompilerGeneratedAttribute]
public CheckoutFileConflictStrategy get_FileConflictStrategy();
    [CompilerGeneratedAttribute]
public void set_FileConflictStrategy(CheckoutFileConflictStrategy value);
    private sealed virtual override CheckoutCallbacks LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.GenerateCallbacks();
    private sealed virtual override CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.get_CheckoutStrategy();
}
public class LibGit2Sharp.RebaseResult : object {
    [CompilerGeneratedAttribute]
private RebaseStepInfo <CurrentStepInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private RebaseStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompletedStepCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalStepCount>k__BackingField;
    public RebaseStepInfo CurrentStepInfo { get; private set; }
    public RebaseStatus Status { get; protected set; }
    public long CompletedStepCount { get; protected set; }
    public long TotalStepCount { get; protected set; }
    internal RebaseResult(RebaseStatus status, long stepNumber, long totalSteps, RebaseStepInfo currentStepInfo);
    [CompilerGeneratedAttribute]
public virtual RebaseStepInfo get_CurrentStepInfo();
    [CompilerGeneratedAttribute]
private void set_CurrentStepInfo(RebaseStepInfo value);
    [CompilerGeneratedAttribute]
public virtual RebaseStatus get_Status();
    [CompilerGeneratedAttribute]
protected virtual void set_Status(RebaseStatus value);
    [CompilerGeneratedAttribute]
public virtual long get_CompletedStepCount();
    [CompilerGeneratedAttribute]
protected virtual void set_CompletedStepCount(long value);
    [CompilerGeneratedAttribute]
public virtual long get_TotalStepCount();
    [CompilerGeneratedAttribute]
protected virtual void set_TotalStepCount(long value);
}
public enum LibGit2Sharp.RebaseStatus : Enum {
    public int value__;
    public static RebaseStatus Complete;
    public static RebaseStatus Conflicts;
    public static RebaseStatus Stop;
}
public class LibGit2Sharp.RebaseStepInfo : object {
    [CompilerGeneratedAttribute]
private RebaseStepOperation <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Commit <Commit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exec>k__BackingField;
    public RebaseStepOperation Type { get; private set; }
    public Commit Commit { get; private set; }
    internal string Exec { get; private set; }
    internal RebaseStepInfo(RebaseStepOperation type, Commit commit, string exec);
    [CompilerGeneratedAttribute]
public virtual RebaseStepOperation get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(RebaseStepOperation value);
    [CompilerGeneratedAttribute]
public virtual Commit get_Commit();
    [CompilerGeneratedAttribute]
private void set_Commit(Commit value);
    [CompilerGeneratedAttribute]
internal virtual string get_Exec();
    [CompilerGeneratedAttribute]
private void set_Exec(string value);
}
public enum LibGit2Sharp.RebaseStepOperation : Enum {
    public int value__;
    public static RebaseStepOperation Pick;
    public static RebaseStepOperation Reword;
    public static RebaseStepOperation Edit;
    public static RebaseStepOperation Squash;
    public static RebaseStepOperation Fixup;
}
public class LibGit2Sharp.RecurseSubmodulesException : LibGit2SharpException {
    [CompilerGeneratedAttribute]
private string <InitialRepositoryPath>k__BackingField;
    public string InitialRepositoryPath { get; private set; }
    public RecurseSubmodulesException(string message, Exception innerException, string initialRepositoryPath);
    protected RecurseSubmodulesException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public virtual string get_InitialRepositoryPath();
    [CompilerGeneratedAttribute]
private void set_InitialRepositoryPath(string value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class LibGit2Sharp.Reference : object {
    private static LambdaEqualityHelper`1<Reference> equalityHelper;
    private IRepository repo;
    private string canonicalName;
    private string targetIdentifier;
    public bool IsLocalBranch { get; }
    public bool IsRemoteTrackingBranch { get; }
    public bool IsTag { get; }
    public bool IsNote { get; }
    public string CanonicalName { get; }
    public string TargetIdentifier { get; }
    internal static string LocalBranchPrefix { get; }
    internal static string RemoteTrackingBranchPrefix { get; }
    internal static string TagPrefix { get; }
    internal static string NotePrefix { get; }
    private string DebuggerDisplay { get; }
    private IRepository LibGit2Sharp.IBelongToARepository.Repository { get; }
    internal Reference(IRepository repo, string canonicalName, string targetIdentifier);
    private static Reference();
    internal static T BuildFromPtr(ReferenceHandle handle, Repository repo);
    internal static T BuildFromPtr(git_reference* handle, Repository repo);
    public static bool IsValidName(string canonicalName);
    public virtual bool get_IsLocalBranch();
    public virtual bool get_IsRemoteTrackingBranch();
    public virtual bool get_IsTag();
    public virtual bool get_IsNote();
    public virtual string get_CanonicalName();
    public abstract virtual DirectReference ResolveToDirectReference();
    public virtual string get_TargetIdentifier();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Reference other);
    public virtual int GetHashCode();
    public static bool op_Equality(Reference left, Reference right);
    public static bool op_Inequality(Reference left, Reference right);
    public virtual string ToString();
    internal static string get_LocalBranchPrefix();
    internal static string get_RemoteTrackingBranchPrefix();
    internal static string get_TagPrefix();
    internal static string get_NotePrefix();
    private string get_DebuggerDisplay();
    private sealed virtual override IRepository LibGit2Sharp.IBelongToARepository.get_Repository();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.ReferenceCollection : object {
    internal Repository repo;
    public Reference Item { get; }
    public Reference Head { get; }
    private string DebuggerDisplay { get; }
    internal ReferenceCollection(Repository repo);
    public virtual Reference get_Item(string name);
    public virtual IEnumerator`1<Reference> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Reference Add(string name, string canonicalRefNameOrObjectish, string logMessage);
    private static RefState TryResolveReference(Reference& reference, ReferenceCollection refsColl, string canonicalName);
    public virtual Reference Add(string name, string canonicalRefNameOrObjectish, string logMessage, bool allowOverwrite);
    public virtual Reference Add(string name, string canonicalRefNameOrObjectish);
    public virtual Reference Add(string name, string canonicalRefNameOrObjectish, bool allowOverwrite);
    public virtual DirectReference Add(string name, ObjectId targetId, string logMessage);
    public virtual DirectReference Add(string name, ObjectId targetId, string logMessage, bool allowOverwrite);
    public virtual DirectReference Add(string name, ObjectId targetId);
    public virtual DirectReference Add(string name, ObjectId targetId, bool allowOverwrite);
    public virtual SymbolicReference Add(string name, Reference targetRef, string logMessage);
    public virtual SymbolicReference Add(string name, Reference targetRef, string logMessage, bool allowOverwrite);
    public virtual SymbolicReference Add(string name, Reference targetRef);
    public virtual SymbolicReference Add(string name, Reference targetRef, bool allowOverwrite);
    public virtual void Remove(string name);
    public virtual void Remove(Reference reference);
    public virtual Reference Rename(Reference reference, string newName, string logMessage);
    public virtual Reference Rename(Reference reference, string newName, string logMessage, bool allowOverwrite);
    public virtual Reference Rename(string currentName, string newName);
    public virtual Reference Rename(string currentName, string newName, bool allowOverwrite);
    public virtual Reference Rename(string currentName, string newName, string logMessage);
    public virtual Reference Rename(string currentName, string newName, string logMessage, bool allowOverwrite);
    public virtual Reference Rename(Reference reference, string newName);
    public virtual Reference Rename(Reference reference, string newName, bool allowOverwrite);
    internal T Resolve(string name);
    public virtual Reference UpdateTarget(Reference directRef, ObjectId targetId, string logMessage);
    private Reference UpdateDirectReferenceTarget(Reference directRef, ObjectId targetId, string logMessage);
    public virtual Reference UpdateTarget(Reference directRef, string objectish, string logMessage);
    public virtual Reference UpdateTarget(Reference directRef, string objectish);
    public virtual Reference UpdateTarget(string name, string canonicalRefNameOrObjectish, string logMessage);
    public virtual Reference UpdateTarget(string name, string canonicalRefNameOrObjectish);
    public virtual Reference UpdateTarget(Reference directRef, ObjectId targetId);
    public virtual Reference UpdateTarget(Reference symbolicRef, Reference targetRef, string logMessage);
    private Reference UpdateSymbolicRefenceTarget(Reference symbolicRef, Reference targetRef, string logMessage);
    public virtual Reference UpdateTarget(Reference symbolicRef, Reference targetRef);
    internal Reference MoveHeadTarget(T target);
    internal Reference UpdateHeadTarget(ObjectId target, string logMessage);
    internal Reference UpdateHeadTarget(Reference target, string logMessage);
    internal Reference UpdateHeadTarget(string target, string logMessage);
    internal ReferenceHandle RetrieveReferencePtr(string referenceName, bool shouldThrowIfNotFound);
    public virtual IEnumerable`1<Reference> FromGlob(string pattern);
    public virtual Reference get_Head();
    public virtual IEnumerable`1<Reference> ReachableFrom(IEnumerable`1<Reference> refSubset, IEnumerable`1<Commit> targets);
    public virtual IEnumerable`1<Reference> ReachableFrom(IEnumerable`1<Commit> targets);
    private string get_DebuggerDisplay();
    public virtual ReflogCollection Log(string canonicalName);
    public virtual ReflogCollection Log(Reference reference);
    public virtual void RewriteHistory(RewriteHistoryOptions options, Commit[] commitsToRewrite);
    public virtual void RewriteHistory(RewriteHistoryOptions options, IEnumerable`1<Commit> commitsToRewrite);
    internal void EnsureHasLog(string canonicalName);
    [CompilerGeneratedAttribute]
private Reference <GetEnumerator>b__5_0(string n);
    [CompilerGeneratedAttribute]
private Reference <FromGlob>b__47_0(string n);
}
[ExtensionAttribute]
internal static class LibGit2Sharp.ReferenceExtensions : object {
    [ExtensionAttribute]
internal static bool LooksLikeLocalBranch(string canonicalName);
    [ExtensionAttribute]
internal static bool LooksLikeRemoteTrackingBranch(string canonicalName);
    [ExtensionAttribute]
internal static bool LooksLikeTag(string canonicalName);
    [ExtensionAttribute]
internal static bool LooksLikeNote(string canonicalName);
    [ExtensionAttribute]
private static bool IsPrefixedBy(string input, string prefix);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class LibGit2Sharp.ReferenceWrapper`1 : object {
    protected Repository repo;
    private Reference reference;
    private Lazy`1<TObject> objectBuilder;
    private static LambdaEqualityHelper`1<ReferenceWrapper`1<TObject>> equalityHelper;
    private string canonicalName;
    public string CanonicalName { get; }
    public string FriendlyName { get; }
    public Reference Reference { get; }
    protected TObject TargetObject { get; }
    private string DebuggerDisplay { get; }
    private IRepository LibGit2Sharp.IBelongToARepository.Repository { get; }
    protected internal ReferenceWrapper`1(Repository repo, Reference reference, Func`2<Reference, string> canonicalNameSelector);
    private static ReferenceWrapper`1();
    public virtual string get_CanonicalName();
    public virtual string get_FriendlyName();
    public virtual Reference get_Reference();
    public virtual string ToString();
    protected TObject get_TargetObject();
    protected abstract virtual string Shorten();
    private TObject RetrieveTargetObject(Reference reference);
    public sealed virtual bool Equals(ReferenceWrapper`1<TObject> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ReferenceWrapper`1<TObject> left, ReferenceWrapper`1<TObject> right);
    public static bool op_Inequality(ReferenceWrapper`1<TObject> left, ReferenceWrapper`1<TObject> right);
    private string get_DebuggerDisplay();
    private sealed virtual override IRepository LibGit2Sharp.IBelongToARepository.get_Repository();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.ReflogCollection : object {
    internal Repository repo;
    private string canonicalName;
    private string DebuggerDisplay { get; }
    internal ReflogCollection(Repository repo, string canonicalName);
    public virtual IEnumerator`1<ReflogEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private string get_DebuggerDisplay();
}
public class LibGit2Sharp.ReflogEntry : object {
    private ObjectId _from;
    private ObjectId _to;
    private Signature _committer;
    private string message;
    public ObjectId From { get; }
    public ObjectId To { get; }
    public Signature Committer { get; }
    public string Message { get; }
    internal ReflogEntry(git_reflog_entry* entryHandle);
    public virtual ObjectId get_From();
    public virtual ObjectId get_To();
    public virtual Signature get_Committer();
    public virtual string get_Message();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.RefSpec : object {
    private Remote remote;
    private IntPtr handle;
    public string Specification { get; }
    public RefSpecDirection Direction { get; }
    public string Source { get; }
    public string Destination { get; }
    public bool ForceUpdate { get; }
    private string DebuggerDisplay { get; }
    internal RefSpec(Remote remote, git_refspec* handle);
    public virtual string get_Specification();
    public virtual RefSpecDirection get_Direction();
    public virtual string get_Source();
    public virtual string get_Destination();
    public virtual bool get_ForceUpdate();
    public virtual bool SourceMatches(string reference);
    public virtual bool DestinationMatches(string reference);
    public virtual string Transform(string reference);
    public virtual string ReverseTransform(string reference);
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.RefSpecCollection : object {
    private Remote remote;
    private RemoteHandle handle;
    private Lazy`1<IList`1<RefSpec>> refspecs;
    private string DebuggerDisplay { get; }
    internal RefSpecCollection(Remote remote, RemoteHandle handle);
    private static IList`1<RefSpec> RetrieveRefSpecs(Remote remote, RemoteHandle remoteHandle);
    public virtual IEnumerator`1<RefSpec> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private string get_DebuggerDisplay();
}
public enum LibGit2Sharp.RefSpecDirection : Enum {
    public int value__;
    public static RefSpecDirection Fetch;
    public static RefSpecDirection Push;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Remote : object {
    internal Repository repository;
    private RefSpecCollection refSpecs;
    private RemoteHandle handle;
    private bool disposedValue;
    public string Name { get; }
    public string Url { get; }
    public string PushUrl { get; }
    public TagFetchMode TagFetchMode { get; }
    public IEnumerable`1<RefSpec> RefSpecs { get; }
    public IEnumerable`1<RefSpec> FetchRefSpecs { get; }
    public IEnumerable`1<RefSpec> PushRefSpecs { get; }
    public bool AutomaticallyPruneOnFetch { get; }
    private string DebuggerDisplay { get; }
    private IRepository LibGit2Sharp.IBelongToARepository.Repository { get; }
    internal Remote(RemoteHandle handle, Repository repository);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public virtual string get_Name();
    public virtual string get_Url();
    public virtual string get_PushUrl();
    public virtual TagFetchMode get_TagFetchMode();
    public virtual IEnumerable`1<RefSpec> get_RefSpecs();
    public virtual IEnumerable`1<RefSpec> get_FetchRefSpecs();
    public virtual IEnumerable`1<RefSpec> get_PushRefSpecs();
    internal string FetchSpecTransformToSource(string reference);
    public static bool IsValidName(string name);
    public virtual bool get_AutomaticallyPruneOnFetch();
    private string get_DebuggerDisplay();
    private sealed virtual override IRepository LibGit2Sharp.IBelongToARepository.get_Repository();
}
internal class LibGit2Sharp.RemoteCallbacks : object {
    private ProgressHandler Progress;
    private UpdateTipsHandler UpdateTips;
    private PushStatusErrorHandler PushStatusError;
    private TransferProgressHandler DownloadTransferProgress;
    private PushTransferProgressHandler PushTransferProgress;
    private PackBuilderProgressHandler PackBuilderProgress;
    private PrePushHandler PrePushCallback;
    private CredentialsHandler CredentialsProvider;
    private CertificateCheckHandler CertificateCheck;
    internal RemoteCallbacks(CredentialsHandler credentialsProvider);
    internal RemoteCallbacks(PushOptions pushOptions);
    internal RemoteCallbacks(FetchOptionsBase fetchOptions);
    internal GitRemoteCallbacks GenerateCallbacks();
    private int GitProgressHandler(IntPtr str, int len, IntPtr data);
    private int GitUpdateTipsHandler(IntPtr str, GitOid& oldId, GitOid& newId, IntPtr data);
    private int GitPushUpdateReference(IntPtr str, IntPtr status, IntPtr data);
    private int GitDownloadTransferProgressHandler(GitTransferProgress& progress, IntPtr payload);
    private int GitPushTransferProgressHandler(UInt32 current, UInt32 total, UIntPtr bytes, IntPtr payload);
    private int GitPackbuilderProgressHandler(int stage, UInt32 current, UInt32 total, IntPtr payload);
    private int GitCredentialHandler(IntPtr& ptr, IntPtr cUrl, IntPtr usernameFromUrl, GitCredentialType credTypes, IntPtr payload);
    private int GitCertificateCheck(git_certificate* certPtr, int valid, IntPtr cHostname, IntPtr payload);
    private int GitPushNegotiationHandler(IntPtr updates, UIntPtr len, IntPtr payload);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.RemoteCollection : object {
    private Repository repository;
    public Remote Item { get; }
    private string DebuggerDisplay { get; }
    internal RemoteCollection(Repository repository);
    public virtual Remote get_Item(string name);
    internal Remote RemoteForName(string name, bool shouldThrowIfNotFound);
    public virtual void Update(string remote, Action`1[] actions);
    public virtual IEnumerator`1<Remote> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Remote Add(string name, string url);
    public virtual Remote Add(string name, string url, string fetchRefSpec);
    public virtual void Remove(string name);
    public virtual Remote Rename(string name, string newName);
    public virtual Remote Rename(string name, string newName, RemoteRenameFailureHandler callback);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private Remote <GetEnumerator>b__7_0(string n);
}
public enum LibGit2Sharp.RemoteCompletionType : Enum {
    public int value__;
    public static RemoteCompletionType Download;
    public static RemoteCompletionType Indexing;
    public static RemoteCompletionType Error;
}
public class LibGit2Sharp.RemoteUpdater : object {
    private UpdatingCollection`1<string> fetchRefSpecs;
    private UpdatingCollection`1<string> pushRefSpecs;
    private Repository repo;
    private string remoteName;
    unknown TagFetchMode TagFetchMode {public set; }
    unknown string Url {public set; }
    unknown string PushUrl {public set; }
    public ICollection`1<string> FetchRefSpecs { get; public set; }
    public ICollection`1<string> PushRefSpecs { get; public set; }
    internal RemoteUpdater(Repository repo, Remote remote);
    internal RemoteUpdater(Repository repo, string remote);
    private IEnumerable`1<string> GetFetchRefSpecs();
    private void SetFetchRefSpecs(IEnumerable`1<string> value);
    private IEnumerable`1<string> GetPushRefSpecs();
    private void SetPushRefSpecs(IEnumerable`1<string> value);
    public virtual void set_TagFetchMode(TagFetchMode value);
    public virtual void set_Url(string value);
    public virtual void set_PushUrl(string value);
    public virtual ICollection`1<string> get_FetchRefSpecs();
    public virtual void set_FetchRefSpecs(ICollection`1<string> value);
    public virtual ICollection`1<string> get_PushRefSpecs();
    public virtual void set_PushRefSpecs(ICollection`1<string> value);
}
public class LibGit2Sharp.RemoveFromIndexException : LibGit2SharpException {
    public RemoveFromIndexException(string message);
    public RemoveFromIndexException(string format, Object[] args);
    public RemoveFromIndexException(string message, Exception innerException);
    protected RemoveFromIndexException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.RenameDetails : object {
    private string oldFilePath;
    private string newFilePath;
    private int similarity;
    private static LambdaEqualityHelper`1<RenameDetails> equalityHelper;
    public string OldFilePath { get; }
    public string NewFilePath { get; }
    public int Similarity { get; }
    private string DebuggerDisplay { get; }
    internal RenameDetails(string oldFilePath, string newFilePath, int similarity);
    private static RenameDetails();
    public virtual string get_OldFilePath();
    public virtual string get_NewFilePath();
    public virtual int get_Similarity();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RenameDetails other);
    public virtual int GetHashCode();
    public static bool op_Equality(RenameDetails left, RenameDetails right);
    public static bool op_Inequality(RenameDetails left, RenameDetails right);
    private string get_DebuggerDisplay();
}
public enum LibGit2Sharp.RenameDetectionMode : Enum {
    public int value__;
    public static RenameDetectionMode Default;
    public static RenameDetectionMode None;
    public static RenameDetectionMode Exact;
    public static RenameDetectionMode Renames;
    public static RenameDetectionMode Copies;
    public static RenameDetectionMode CopiesHarder;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Repository : object {
    private bool isBare;
    private BranchCollection branches;
    private CommitLog commits;
    private Lazy`1<Configuration> config;
    private RepositoryHandle handle;
    private Lazy`1<Index> index;
    private ReferenceCollection refs;
    private TagCollection tags;
    private StashCollection stashes;
    private Lazy`1<RepositoryInformation> info;
    private Diff diff;
    private NoteCollection notes;
    private Lazy`1<ObjectDatabase> odb;
    private Lazy`1<Network> network;
    private Lazy`1<Rebase> rebaseOperation;
    private Stack`1<IDisposable> toCleanup;
    private Ignore ignore;
    private SubmoduleCollection submodules;
    private WorktreeCollection worktrees;
    private Lazy`1<PathCase> pathCase;
    internal RepositoryHandle Handle { get; }
    public Branch Head { get; }
    public Configuration Config { get; }
    public Index Index { get; }
    public Ignore Ignore { get; }
    public Network Network { get; }
    public Rebase Rebase { get; }
    public ObjectDatabase ObjectDatabase { get; }
    public ReferenceCollection Refs { get; }
    public IQueryableCommitLog Commits { get; }
    public BranchCollection Branches { get; }
    public TagCollection Tags { get; }
    public StashCollection Stashes { get; }
    public RepositoryInformation Info { get; }
    public Diff Diff { get; }
    public NoteCollection Notes { get; }
    public SubmoduleCollection Submodules { get; }
    public WorktreeCollection Worktrees { get; }
    internal IEnumerable`1<MergeHead> MergeHeads { get; }
    internal StringComparer PathComparer { get; }
    private string DebuggerDisplay { get; }
    public Repository(string path);
    public Repository(string path, RepositoryOptions options);
    internal Repository(WorktreeHandle worktreeHandle);
    private Repository(string path, RepositoryOptions options, RepositoryRequiredParameter requiredParameter);
    public static bool IsValid(string path);
    private void EagerlyLoadComponentsWithSpecifiedPaths(RepositoryOptions options);
    internal RepositoryHandle get_Handle();
    public sealed virtual Branch get_Head();
    public sealed virtual Configuration get_Config();
    public sealed virtual Index get_Index();
    public sealed virtual Ignore get_Ignore();
    public sealed virtual Network get_Network();
    public sealed virtual Rebase get_Rebase();
    public sealed virtual ObjectDatabase get_ObjectDatabase();
    public sealed virtual ReferenceCollection get_Refs();
    public sealed virtual IQueryableCommitLog get_Commits();
    public sealed virtual BranchCollection get_Branches();
    public sealed virtual TagCollection get_Tags();
    public sealed virtual StashCollection get_Stashes();
    public sealed virtual RepositoryInformation get_Info();
    public sealed virtual Diff get_Diff();
    public sealed virtual NoteCollection get_Notes();
    public sealed virtual SubmoduleCollection get_Submodules();
    public sealed virtual WorktreeCollection get_Worktrees();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public static string Init(string path);
    public static string Init(string path, bool isBare);
    public static string Init(string workingDirectoryPath, string gitDirectoryPath);
    public sealed virtual GitObject Lookup(ObjectId id);
    public sealed virtual GitObject Lookup(string objectish);
    public sealed virtual GitObject Lookup(ObjectId id, ObjectType type);
    public sealed virtual GitObject Lookup(string objectish, ObjectType type);
    internal GitObject LookupInternal(ObjectId id, GitObjectType type, string knownPath);
    private static string PathFromRevparseSpec(string spec);
    internal GitObject Lookup(string objectish, GitObjectType type, LookUpOptions lookUpOptions);
    internal Commit LookupCommit(string committish);
    public static IEnumerable`1<Reference> ListRemoteReferences(string url);
    public static IEnumerable`1<Reference> ListRemoteReferences(string url, CredentialsHandler credentialsProvider);
    public static string Discover(string startingPath);
    public static string Clone(string sourceUrl, string workdirPath);
    public static string Clone(string sourceUrl, string workdirPath, CloneOptions options);
    private static void RecursivelyCloneSubmodules(CloneOptions options, string repoPath, int recursionDepth);
    private static bool OnRepositoryOperationStarting(RepositoryOperationStarting repositoryChangedCallback, RepositoryOperationContext context);
    private static void OnRepositoryOperationCompleted(RepositoryOperationCompleted repositoryChangedCallback, RepositoryOperationContext context);
    public sealed virtual BlameHunkCollection Blame(string path, BlameOptions options);
    public sealed virtual void Checkout(Tree tree, IEnumerable`1<string> paths, CheckoutOptions options);
    private void CheckoutTree(Tree tree, IList`1<string> paths, IConvertableToGitCheckoutOpts opts);
    public sealed virtual void Reset(ResetMode resetMode, Commit commit);
    public sealed virtual void Reset(ResetMode resetMode, Commit commit, CheckoutOptions opts);
    public sealed virtual void CheckoutPaths(string committishOrBranchSpec, IEnumerable`1<string> paths, CheckoutOptions checkoutOptions);
    public sealed virtual Commit Commit(string message, Signature author, Signature committer, CommitOptions options);
    private static string BuildCommitLogMessage(Commit commit, bool amendPreviousCommit, bool isHeadOrphaned, bool isMergeCommit);
    private void UpdateHeadAndTerminalReference(Commit commit, string reflogMessage);
    private IEnumerable`1<Commit> RetrieveParentsOfTheCommitBeingCreated(bool amendPreviousCommit);
    public sealed virtual void RemoveUntrackedFiles();
    private void CleanupDisposableDependencies();
    internal T RegisterForCleanup(T disposable);
    public sealed virtual MergeResult Merge(Commit commit, Signature merger, MergeOptions options);
    public sealed virtual MergeResult Merge(Branch branch, Signature merger, MergeOptions options);
    public sealed virtual MergeResult Merge(string committish, Signature merger, MergeOptions options);
    public sealed virtual MergeResult MergeFetchedRefs(Signature merger, MergeOptions options);
    public sealed virtual RevertResult Revert(Commit commit, Signature reverter, RevertOptions options);
    public sealed virtual CherryPickResult CherryPick(Commit commit, Signature committer, CherryPickOptions options);
    private FastForwardStrategy FastForwardStrategyFromMergePreference(GitMergePreference preference);
    private MergeResult Merge(AnnotatedCommitHandle[] annotatedCommits, Signature merger, MergeOptions options);
    private MergeResult NormalMerge(AnnotatedCommitHandle[] annotatedCommits, Signature merger, MergeOptions options);
    private MergeResult FastForwardMerge(AnnotatedCommitHandle annotatedCommit, MergeOptions options);
    internal IEnumerable`1<MergeHead> get_MergeHeads();
    internal StringComparer get_PathComparer();
    internal FilePath[] ToFilePaths(IEnumerable`1<string> paths);
    public sealed virtual FileStatus RetrieveStatus(string filePath);
    public sealed virtual RepositoryStatus RetrieveStatus(StatusOptions options);
    internal void ReloadFromDisk();
    internal void AddToIndex(string relativePath);
    internal string RemoveFromIndex(string relativePath);
    internal void UpdatePhysicalIndex();
    public sealed virtual string Describe(Commit commit, DescribeOptions options);
    public sealed virtual void RevParse(string revision, Reference& reference, GitObject& obj);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private Index <.ctor>b__24_0();
    [CompilerGeneratedAttribute]
private RepositoryInformation <.ctor>b__24_2();
    [CompilerGeneratedAttribute]
private ObjectDatabase <.ctor>b__24_4();
    [CompilerGeneratedAttribute]
private Network <.ctor>b__24_5();
    [CompilerGeneratedAttribute]
private Rebase <.ctor>b__24_6();
    [CompilerGeneratedAttribute]
private PathCase <.ctor>b__24_7();
    [CompilerGeneratedAttribute]
private AnnotatedCommitHandle <MergeFetchedRefs>b__101_1(FetchHead fetchHead);
}
[ExtensionAttribute]
public static class LibGit2Sharp.RepositoryExtensions : object {
    [ExtensionAttribute]
public static T Lookup(IRepository repository, string objectish);
    [ExtensionAttribute]
public static T Lookup(IRepository repository, ObjectId id);
    private static void EnsureNoGitLink();
    [ExtensionAttribute]
public static Tag ApplyTag(IRepository repository, string tagName);
    [ExtensionAttribute]
public static Tag ApplyTag(IRepository repository, string tagName, string objectish);
    [ExtensionAttribute]
public static Tag ApplyTag(IRepository repository, string tagName, Signature tagger, string message);
    private static Commit RetrieveHeadCommit(IRepository repository);
    [ExtensionAttribute]
public static Tag ApplyTag(IRepository repository, string tagName, string objectish, Signature tagger, string message);
    [ExtensionAttribute]
public static Branch CreateBranch(IRepository repository, string branchName);
    [ExtensionAttribute]
public static Branch CreateBranch(IRepository repository, string branchName, Commit target);
    [ExtensionAttribute]
public static Branch CreateBranch(IRepository repository, string branchName, string committish);
    [ExtensionAttribute]
public static void Reset(IRepository repository, ResetMode resetMode);
    [ExtensionAttribute]
public static void Reset(IRepository repository, ResetMode resetMode, string committish);
    private static Commit LookUpCommit(IRepository repository, string committish);
    [ExtensionAttribute]
public static Commit Commit(IRepository repository, string message, Signature author, Signature committer);
    [ExtensionAttribute]
internal static string BuildRelativePathFrom(IRepository repo, string path);
    internal static bool PathStartsWith(IRepository repository, string path, string value);
    private static ObjectId DereferenceToCommit(Repository repo, string identifier);
    private static bool AllowOrphanReference(IRepository repo, string identifier);
    [ExtensionAttribute]
private static ObjectId SingleCommittish(Repository repo, object identifier);
    [IteratorStateMachineAttribute("LibGit2Sharp.RepositoryExtensions/<Committishes>d__20")]
[ExtensionAttribute]
internal static IEnumerable`1<ObjectId> Committishes(Repository repo, object identifier, bool throwIfNotFound);
    [ExtensionAttribute]
internal static ObjectId Committish(Repository repo, object identifier);
    [ExtensionAttribute]
public static MergeResult Merge(IRepository repository, Branch branch, Signature merger);
    [ExtensionAttribute]
public static MergeResult Merge(IRepository repository, string committish, Signature merger);
    [ExtensionAttribute]
public static void CheckoutPaths(IRepository repository, string committishOrBranchSpec, IEnumerable`1<string> paths);
    [ExtensionAttribute]
public static void Reset(IRepository repository, ResetMode resetMode, Commit commit);
    [ExtensionAttribute]
public static BlameHunkCollection Blame(IRepository repository, string path);
    [ExtensionAttribute]
public static CherryPickResult CherryPick(IRepository repository, Commit commit, Signature committer);
    [ExtensionAttribute]
public static MergeResult Merge(IRepository repository, Commit commit, Signature merger);
    [ExtensionAttribute]
public static RevertResult Revert(IRepository repository, Commit commit, Signature reverter);
    [ExtensionAttribute]
public static RepositoryStatus RetrieveStatus(IRepository repository);
    [ExtensionAttribute]
public static string Describe(IRepository repository, Commit commit);
}
public class LibGit2Sharp.RepositoryInformation : object {
    private Repository repo;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBare>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsShallow>k__BackingField;
    public string Path { get; private set; }
    public string WorkingDirectory { get; private set; }
    public bool IsBare { get; private set; }
    public bool IsShallow { get; private set; }
    public bool IsHeadDetached { get; }
    public bool IsHeadUnborn { get; }
    public CurrentOperation CurrentOperation { get; }
    public string Message { get; }
    internal RepositoryInformation(Repository repo, bool isBare);
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public virtual string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
private void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsBare();
    [CompilerGeneratedAttribute]
private void set_IsBare(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsShallow();
    [CompilerGeneratedAttribute]
private void set_IsShallow(bool value);
    public virtual bool get_IsHeadDetached();
    public virtual bool get_IsHeadUnborn();
    public virtual CurrentOperation get_CurrentOperation();
    public virtual string get_Message();
}
public class LibGit2Sharp.RepositoryNotFoundException : LibGit2SharpException {
    public RepositoryNotFoundException(string message);
    public RepositoryNotFoundException(string format, Object[] args);
    public RepositoryNotFoundException(string message, Exception innerException);
    protected RepositoryNotFoundException(SerializationInfo info, StreamingContext context);
}
public class LibGit2Sharp.RepositoryOperationContext : object {
    [CompilerGeneratedAttribute]
private string <ParentRepositoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecursionDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubmoduleName>k__BackingField;
    public string ParentRepositoryPath { get; private set; }
    public int RecursionDepth { get; private set; }
    public string RemoteUrl { get; private set; }
    public string RepositoryPath { get; private set; }
    public string SubmoduleName { get; private set; }
    internal RepositoryOperationContext(string repositoryPath, string remoteUrl);
    internal RepositoryOperationContext(string repositoryPath, string remoteUrl, string parentRepositoryPath, string submoduleName, int recursionDepth);
    [CompilerGeneratedAttribute]
public virtual string get_ParentRepositoryPath();
    [CompilerGeneratedAttribute]
private void set_ParentRepositoryPath(string value);
    [CompilerGeneratedAttribute]
public virtual int get_RecursionDepth();
    [CompilerGeneratedAttribute]
private void set_RecursionDepth(int value);
    [CompilerGeneratedAttribute]
public virtual string get_RemoteUrl();
    [CompilerGeneratedAttribute]
private void set_RemoteUrl(string value);
    [CompilerGeneratedAttribute]
public virtual string get_RepositoryPath();
    [CompilerGeneratedAttribute]
private void set_RepositoryPath(string value);
    [CompilerGeneratedAttribute]
public virtual string get_SubmoduleName();
    [CompilerGeneratedAttribute]
private void set_SubmoduleName(string value);
}
public class LibGit2Sharp.RepositoryOptions : object {
    [CompilerGeneratedAttribute]
private string <WorkingDirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Identity <Identity>k__BackingField;
    public string WorkingDirectoryPath { get; public set; }
    public string IndexPath { get; public set; }
    public Identity Identity { get; public set; }
    [CompilerGeneratedAttribute]
public string get_WorkingDirectoryPath();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectoryPath(string value);
    [CompilerGeneratedAttribute]
public string get_IndexPath();
    [CompilerGeneratedAttribute]
public void set_IndexPath(string value);
    [CompilerGeneratedAttribute]
public Identity get_Identity();
    [CompilerGeneratedAttribute]
public void set_Identity(Identity value);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.RepositoryStatus : object {
    private ICollection`1<StatusEntry> statusEntries;
    private List`1<StatusEntry> added;
    private List`1<StatusEntry> staged;
    private List`1<StatusEntry> removed;
    private List`1<StatusEntry> missing;
    private List`1<StatusEntry> modified;
    private List`1<StatusEntry> untracked;
    private List`1<StatusEntry> ignored;
    private List`1<StatusEntry> renamedInIndex;
    private List`1<StatusEntry> renamedInWorkDir;
    private List`1<StatusEntry> unaltered;
    private bool isDirty;
    private IDictionary`2<FileStatus, Action`2<RepositoryStatus, StatusEntry>> dispatcher;
    public StatusEntry Item { get; }
    public IEnumerable`1<StatusEntry> Added { get; }
    public IEnumerable`1<StatusEntry> Staged { get; }
    public IEnumerable`1<StatusEntry> Removed { get; }
    public IEnumerable`1<StatusEntry> Missing { get; }
    public IEnumerable`1<StatusEntry> Modified { get; }
    public IEnumerable`1<StatusEntry> Untracked { get; }
    public IEnumerable`1<StatusEntry> Ignored { get; }
    public IEnumerable`1<StatusEntry> RenamedInIndex { get; }
    public IEnumerable`1<StatusEntry> RenamedInWorkDir { get; }
    public IEnumerable`1<StatusEntry> Unaltered { get; }
    public bool IsDirty { get; }
    private string DebuggerDisplay { get; }
    internal RepositoryStatus(Repository repo, StatusOptions options);
    private static IDictionary`2<FileStatus, Action`2<RepositoryStatus, StatusEntry>> Build();
    private static GitStatusOptions CreateStatusOptions(StatusOptions options);
    private void AddStatusEntryForDelta(FileStatus gitStatus, git_diff_delta* deltaHeadToIndex, git_diff_delta* deltaIndexToWorkDir);
    public virtual StatusEntry get_Item(string path);
    public virtual IEnumerator`1<StatusEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerable`1<StatusEntry> get_Added();
    public virtual IEnumerable`1<StatusEntry> get_Staged();
    public virtual IEnumerable`1<StatusEntry> get_Removed();
    public virtual IEnumerable`1<StatusEntry> get_Missing();
    public virtual IEnumerable`1<StatusEntry> get_Modified();
    public virtual IEnumerable`1<StatusEntry> get_Untracked();
    public virtual IEnumerable`1<StatusEntry> get_Ignored();
    public virtual IEnumerable`1<StatusEntry> get_RenamedInIndex();
    public virtual IEnumerable`1<StatusEntry> get_RenamedInWorkDir();
    public virtual IEnumerable`1<StatusEntry> get_Unaltered();
    public virtual bool get_IsDirty();
    private string get_DebuggerDisplay();
}
public enum LibGit2Sharp.ResetMode : Enum {
    public int value__;
    public static ResetMode Soft;
    public static ResetMode Mixed;
    public static ResetMode Hard;
}
public class LibGit2Sharp.RevertOptions : MergeAndCheckoutOptionsBase {
    [CompilerGeneratedAttribute]
private int <Mainline>k__BackingField;
    public int Mainline { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Mainline();
    [CompilerGeneratedAttribute]
public void set_Mainline(int value);
}
public class LibGit2Sharp.RevertResult : object {
    [CompilerGeneratedAttribute]
private Commit <Commit>k__BackingField;
    [CompilerGeneratedAttribute]
private RevertStatus <Status>k__BackingField;
    public Commit Commit { get; private set; }
    public RevertStatus Status { get; private set; }
    internal RevertResult(RevertStatus status, Commit commit);
    [CompilerGeneratedAttribute]
public virtual Commit get_Commit();
    [CompilerGeneratedAttribute]
private void set_Commit(Commit value);
    [CompilerGeneratedAttribute]
public virtual RevertStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(RevertStatus value);
}
public enum LibGit2Sharp.RevertStatus : Enum {
    public int value__;
    public static RevertStatus Reverted;
    public static RevertStatus Conflicts;
    public static RevertStatus NothingToRevert;
}
public class LibGit2Sharp.RewriteHistoryOptions : object {
    [CompilerGeneratedAttribute]
private string <BackupRefsNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Commit, CommitRewriteInfo> <CommitHeaderRewriter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Commit, IEnumerable`1<Commit>> <CommitParentsRewriter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Commit, TreeDefinition> <CommitTreeRewriter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<string, bool, string, string> <TagNameRewriter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PruneEmptyCommits>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <OnSucceeding>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Exception> <OnError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrettifyMessages>k__BackingField;
    public string BackupRefsNamespace { get; public set; }
    public Func`2<Commit, CommitRewriteInfo> CommitHeaderRewriter { get; public set; }
    public Func`2<Commit, IEnumerable`1<Commit>> CommitParentsRewriter { get; public set; }
    public Func`2<Commit, TreeDefinition> CommitTreeRewriter { get; public set; }
    public Func`4<string, bool, string, string> TagNameRewriter { get; public set; }
    public bool PruneEmptyCommits { get; public set; }
    public Action OnSucceeding { get; public set; }
    public Action`1<Exception> OnError { get; public set; }
    public bool PrettifyMessages { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackupRefsNamespace();
    [CompilerGeneratedAttribute]
public void set_BackupRefsNamespace(string value);
    [CompilerGeneratedAttribute]
public Func`2<Commit, CommitRewriteInfo> get_CommitHeaderRewriter();
    [CompilerGeneratedAttribute]
public void set_CommitHeaderRewriter(Func`2<Commit, CommitRewriteInfo> value);
    [CompilerGeneratedAttribute]
public Func`2<Commit, IEnumerable`1<Commit>> get_CommitParentsRewriter();
    [CompilerGeneratedAttribute]
public void set_CommitParentsRewriter(Func`2<Commit, IEnumerable`1<Commit>> value);
    [CompilerGeneratedAttribute]
public Func`2<Commit, TreeDefinition> get_CommitTreeRewriter();
    [CompilerGeneratedAttribute]
public void set_CommitTreeRewriter(Func`2<Commit, TreeDefinition> value);
    [CompilerGeneratedAttribute]
public Func`4<string, bool, string, string> get_TagNameRewriter();
    [CompilerGeneratedAttribute]
public void set_TagNameRewriter(Func`4<string, bool, string, string> value);
    [CompilerGeneratedAttribute]
public bool get_PruneEmptyCommits();
    [CompilerGeneratedAttribute]
public void set_PruneEmptyCommits(bool value);
    [CompilerGeneratedAttribute]
public Action get_OnSucceeding();
    [CompilerGeneratedAttribute]
public void set_OnSucceeding(Action value);
    [CompilerGeneratedAttribute]
public Action`1<Exception> get_OnError();
    [CompilerGeneratedAttribute]
public void set_OnError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public bool get_PrettifyMessages();
    [CompilerGeneratedAttribute]
public void set_PrettifyMessages(bool value);
}
public abstract class LibGit2Sharp.RpcSmartSubtransport : SmartSubtransport {
}
public class LibGit2Sharp.SecureUsernamePasswordCredentials : Credentials {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private SecureString <Password>k__BackingField;
    public string Username { get; public set; }
    public SecureString Password { get; public set; }
    protected internal virtual int GitCredentialHandler(IntPtr& cred);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public SecureString get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(SecureString value);
}
public class LibGit2Sharp.Signature : object {
    private DateTimeOffset when;
    private string name;
    private string email;
    private static LambdaEqualityHelper`1<Signature> equalityHelper;
    public string Name { get; }
    public string Email { get; }
    public DateTimeOffset When { get; }
    internal Signature(git_signature* sig);
    public Signature(string name, string email, DateTimeOffset when);
    public Signature(Identity identity, DateTimeOffset when);
    private static Signature();
    internal SignatureHandle BuildHandle();
    public string get_Name();
    public string get_Email();
    public DateTimeOffset get_When();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Signature other);
    public virtual int GetHashCode();
    public static bool op_Equality(Signature left, Signature right);
    public static bool op_Inequality(Signature left, Signature right);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class LibGit2Sharp.SignatureHelpers : object {
    [ExtensionAttribute]
public static SignatureHandle SafeBuildHandle(Signature signature);
}
public class LibGit2Sharp.SignatureInfo : ValueType {
    public string Signature;
    public string SignedData;
}
public class LibGit2Sharp.SimilarityOptions : object {
    [CompilerGeneratedAttribute]
private RenameDetectionMode <RenameDetectionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private WhitespaceMode <WhitespaceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RenameThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RenameFromRewriteThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CopyThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BreakRewriteThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RenameLimit>k__BackingField;
    public static SimilarityOptions None { get; }
    public static SimilarityOptions Renames { get; }
    public static SimilarityOptions Exact { get; }
    public static SimilarityOptions Copies { get; }
    public static SimilarityOptions CopiesHarder { get; }
    public static SimilarityOptions Default { get; }
    public RenameDetectionMode RenameDetectionMode { get; public set; }
    public WhitespaceMode WhitespaceMode { get; public set; }
    public int RenameThreshold { get; public set; }
    public int RenameFromRewriteThreshold { get; public set; }
    public int CopyThreshold { get; public set; }
    public int BreakRewriteThreshold { get; public set; }
    public int RenameLimit { get; public set; }
    public static SimilarityOptions get_None();
    public static SimilarityOptions get_Renames();
    public static SimilarityOptions get_Exact();
    public static SimilarityOptions get_Copies();
    public static SimilarityOptions get_CopiesHarder();
    public static SimilarityOptions get_Default();
    [CompilerGeneratedAttribute]
public RenameDetectionMode get_RenameDetectionMode();
    [CompilerGeneratedAttribute]
public void set_RenameDetectionMode(RenameDetectionMode value);
    [CompilerGeneratedAttribute]
public WhitespaceMode get_WhitespaceMode();
    [CompilerGeneratedAttribute]
public void set_WhitespaceMode(WhitespaceMode value);
    [CompilerGeneratedAttribute]
public int get_RenameThreshold();
    [CompilerGeneratedAttribute]
public void set_RenameThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_RenameFromRewriteThreshold();
    [CompilerGeneratedAttribute]
public void set_RenameFromRewriteThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_CopyThreshold();
    [CompilerGeneratedAttribute]
public void set_CopyThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_BreakRewriteThreshold();
    [CompilerGeneratedAttribute]
public void set_BreakRewriteThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_RenameLimit();
    [CompilerGeneratedAttribute]
public void set_RenameLimit(int value);
}
public abstract class LibGit2Sharp.SmartSubtransport : object {
    [CompilerGeneratedAttribute]
private IntPtr <Transport>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastActionUrl>k__BackingField;
    private IntPtr nativeSubtransportPointer;
    internal IntPtr Transport { get; internal set; }
    private string LastActionUrl { get; private set; }
    internal IntPtr GitSmartSubtransportPointer { get; }
    [CompilerGeneratedAttribute]
internal IntPtr get_Transport();
    [CompilerGeneratedAttribute]
internal void set_Transport(IntPtr value);
    public int CertificateCheck(Certificate cert, bool valid, string hostname);
    public int AcquireCredentials(Credentials& cred, string user, Type[] methods);
    [CompilerGeneratedAttribute]
private string get_LastActionUrl();
    [CompilerGeneratedAttribute]
private void set_LastActionUrl(string value);
    protected abstract virtual SmartSubtransportStream Action(string url, GitSmartSubtransportAction action);
    protected virtual void Close();
    protected virtual void Dispose();
    internal IntPtr get_GitSmartSubtransportPointer();
}
public class LibGit2Sharp.SmartSubtransportRegistration`1 : SmartSubtransportRegistrationData {
    internal SmartSubtransportRegistration`1(string scheme);
    private IntPtr CreateRegistrationPointer();
    private IntPtr CreateFunctionPointer();
    internal void Free();
}
public abstract class LibGit2Sharp.SmartSubtransportRegistrationData : object {
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <RegistrationPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <FunctionPointer>k__BackingField;
    public string Scheme { get; internal set; }
    internal IntPtr RegistrationPointer { get; internal set; }
    internal IntPtr FunctionPointer { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
internal void set_Scheme(string value);
    [CompilerGeneratedAttribute]
internal IntPtr get_RegistrationPointer();
    [CompilerGeneratedAttribute]
internal void set_RegistrationPointer(IntPtr value);
    [CompilerGeneratedAttribute]
internal IntPtr get_FunctionPointer();
    [CompilerGeneratedAttribute]
internal void set_FunctionPointer(IntPtr value);
}
public abstract class LibGit2Sharp.SmartSubtransportStream : object {
    [CompilerGeneratedAttribute]
private Exception <StoredError>k__BackingField;
    private SmartSubtransport subtransport;
    private IntPtr nativeStreamPointer;
    public SmartSubtransport SmartTransport { get; }
    private Exception StoredError { get; private set; }
    internal IntPtr GitSmartTransportStreamPointer { get; }
    protected SmartSubtransportStream(SmartSubtransport subtransport);
    protected virtual void Free();
    public abstract virtual int Read(Stream dataStream, long length, Int64& bytesRead);
    public abstract virtual int Write(Stream dataStream, long length);
    public virtual SmartSubtransport get_SmartTransport();
    [CompilerGeneratedAttribute]
private Exception get_StoredError();
    [CompilerGeneratedAttribute]
private void set_StoredError(Exception value);
    internal void SetError(Exception ex);
    internal IntPtr get_GitSmartTransportStreamPointer();
}
public enum LibGit2Sharp.StageLevel : Enum {
    public int value__;
    public static StageLevel Staged;
    public static StageLevel Ancestor;
    public static StageLevel Ours;
    public static StageLevel Theirs;
}
public class LibGit2Sharp.StageOptions : object {
    [CompilerGeneratedAttribute]
private bool <IncludeIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private ExplicitPathsOptions <ExplicitPathsOptions>k__BackingField;
    public bool IncludeIgnored { get; public set; }
    public ExplicitPathsOptions ExplicitPathsOptions { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IncludeIgnored();
    [CompilerGeneratedAttribute]
public void set_IncludeIgnored(bool value);
    [CompilerGeneratedAttribute]
public ExplicitPathsOptions get_ExplicitPathsOptions();
    [CompilerGeneratedAttribute]
public void set_ExplicitPathsOptions(ExplicitPathsOptions value);
}
public class LibGit2Sharp.Stash : ReferenceWrapper`1<Commit> {
    public Commit WorkTree { get; }
    public Commit Base { get; }
    public Commit Index { get; }
    public Commit Untracked { get; }
    public string Message { get; }
    internal Stash(Repository repo, ObjectId targetId, int index);
    public virtual Commit get_WorkTree();
    public virtual Commit get_Base();
    public virtual Commit get_Index();
    public virtual Commit get_Untracked();
    private Commit GetParentAtOrDefault(int parentIndex);
    public virtual string get_Message();
    protected virtual string Shorten();
}
[FlagsAttribute]
public enum LibGit2Sharp.StashApplyModifiers : Enum {
    public int value__;
    public static StashApplyModifiers Default;
    public static StashApplyModifiers ReinstateIndex;
}
public class LibGit2Sharp.StashApplyOptions : object {
    [CompilerGeneratedAttribute]
private StashApplyModifiers <ApplyModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutOptions <CheckoutOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private StashApplyProgressHandler <ProgressHandler>k__BackingField;
    public StashApplyModifiers ApplyModifiers { get; public set; }
    public CheckoutOptions CheckoutOptions { get; public set; }
    public StashApplyProgressHandler ProgressHandler { get; public set; }
    [CompilerGeneratedAttribute]
public StashApplyModifiers get_ApplyModifiers();
    [CompilerGeneratedAttribute]
public void set_ApplyModifiers(StashApplyModifiers value);
    [CompilerGeneratedAttribute]
public CheckoutOptions get_CheckoutOptions();
    [CompilerGeneratedAttribute]
public void set_CheckoutOptions(CheckoutOptions value);
    [CompilerGeneratedAttribute]
public StashApplyProgressHandler get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(StashApplyProgressHandler value);
}
public enum LibGit2Sharp.StashApplyProgress : Enum {
    public int value__;
    public static StashApplyProgress None;
    public static StashApplyProgress LoadingStash;
    public static StashApplyProgress AnalyzeIndex;
    public static StashApplyProgress AnalyzeModified;
    public static StashApplyProgress AnalyzeUntracked;
    public static StashApplyProgress CheckoutUntracked;
    public static StashApplyProgress CheckoutModified;
    public static StashApplyProgress Done;
}
public enum LibGit2Sharp.StashApplyStatus : Enum {
    public int value__;
    public static StashApplyStatus Applied;
    public static StashApplyStatus Conflicts;
    public static StashApplyStatus NotFound;
    public static StashApplyStatus UncommittedChanges;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.StashCollection : object {
    internal Repository repo;
    public Stash Item { get; }
    private string DebuggerDisplay { get; }
    internal StashCollection(Repository repo);
    public virtual IEnumerator`1<Stash> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Stash get_Item(int index);
    public virtual Stash Add(Signature stasher);
    public virtual Stash Add(Signature stasher, StashModifiers options);
    public virtual Stash Add(Signature stasher, string message);
    public virtual Stash Add(Signature stasher, string message, StashModifiers options);
    public virtual StashApplyStatus Apply(int index, StashApplyOptions options);
    public virtual StashApplyStatus Apply(int index);
    public virtual StashApplyStatus Pop(int index, StashApplyOptions options);
    public virtual StashApplyStatus Pop(int index);
    public virtual void Remove(int index);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private Stash <GetEnumerator>b__3_0(int index, IntPtr message, GitOid commitId);
}
[FlagsAttribute]
public enum LibGit2Sharp.StashModifiers : Enum {
    public int value__;
    public static StashModifiers Default;
    public static StashModifiers KeepIndex;
    public static StashModifiers IncludeUntracked;
    public static StashModifiers IncludeIgnored;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.StatusEntry : object {
    private string filePath;
    private FileStatus state;
    private RenameDetails headToIndexRenameDetails;
    private RenameDetails indexToWorkDirRenameDetails;
    private static LambdaEqualityHelper`1<StatusEntry> equalityHelper;
    public FileStatus State { get; }
    public string FilePath { get; }
    public RenameDetails HeadToIndexRenameDetails { get; }
    public RenameDetails IndexToWorkDirRenameDetails { get; }
    private string DebuggerDisplay { get; }
    internal StatusEntry(string filePath, FileStatus state, RenameDetails headToIndexRenameDetails, RenameDetails indexToWorkDirRenameDetails);
    private static StatusEntry();
    public virtual FileStatus get_State();
    public virtual string get_FilePath();
    public virtual RenameDetails get_HeadToIndexRenameDetails();
    public virtual RenameDetails get_IndexToWorkDirRenameDetails();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StatusEntry other);
    public virtual int GetHashCode();
    public static bool op_Equality(StatusEntry left, StatusEntry right);
    public static bool op_Inequality(StatusEntry left, StatusEntry right);
    private string get_DebuggerDisplay();
}
public class LibGit2Sharp.StatusOptions : object {
    [CompilerGeneratedAttribute]
private StatusShowOption <Show>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetectRenamesInIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetectRenamesInWorkDir>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeSubmodules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecurseIgnoredDirs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecurseUntrackedDirs>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PathSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisablePathSpecMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeUnaltered>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeUntracked>k__BackingField;
    public StatusShowOption Show { get; public set; }
    public bool DetectRenamesInIndex { get; public set; }
    public bool DetectRenamesInWorkDir { get; public set; }
    public bool ExcludeSubmodules { get; public set; }
    public bool RecurseIgnoredDirs { get; public set; }
    public bool RecurseUntrackedDirs { get; public set; }
    public String[] PathSpec { get; public set; }
    public bool DisablePathSpecMatch { get; public set; }
    public bool IncludeUnaltered { get; public set; }
    public bool IncludeIgnored { get; public set; }
    public bool IncludeUntracked { get; public set; }
    [CompilerGeneratedAttribute]
public StatusShowOption get_Show();
    [CompilerGeneratedAttribute]
public void set_Show(StatusShowOption value);
    [CompilerGeneratedAttribute]
public bool get_DetectRenamesInIndex();
    [CompilerGeneratedAttribute]
public void set_DetectRenamesInIndex(bool value);
    [CompilerGeneratedAttribute]
public bool get_DetectRenamesInWorkDir();
    [CompilerGeneratedAttribute]
public void set_DetectRenamesInWorkDir(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeSubmodules();
    [CompilerGeneratedAttribute]
public void set_ExcludeSubmodules(bool value);
    [CompilerGeneratedAttribute]
public bool get_RecurseIgnoredDirs();
    [CompilerGeneratedAttribute]
public void set_RecurseIgnoredDirs(bool value);
    [CompilerGeneratedAttribute]
public bool get_RecurseUntrackedDirs();
    [CompilerGeneratedAttribute]
public void set_RecurseUntrackedDirs(bool value);
    [CompilerGeneratedAttribute]
public String[] get_PathSpec();
    [CompilerGeneratedAttribute]
public void set_PathSpec(String[] value);
    [CompilerGeneratedAttribute]
public bool get_DisablePathSpecMatch();
    [CompilerGeneratedAttribute]
public void set_DisablePathSpecMatch(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeUnaltered();
    [CompilerGeneratedAttribute]
public void set_IncludeUnaltered(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeIgnored();
    [CompilerGeneratedAttribute]
public void set_IncludeIgnored(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeUntracked();
    [CompilerGeneratedAttribute]
public void set_IncludeUntracked(bool value);
}
public enum LibGit2Sharp.StatusShowOption : Enum {
    public int value__;
    public static StatusShowOption IndexAndWorkDir;
    public static StatusShowOption IndexOnly;
    public static StatusShowOption WorkDirOnly;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Submodule : object {
    private static LambdaEqualityHelper`1<Submodule> equalityHelper;
    private Repository repo;
    private string name;
    private string path;
    private string url;
    private ILazy`1<ObjectId> headCommitId;
    private ILazy`1<ObjectId> indexCommitId;
    private ILazy`1<ObjectId> workdirCommitId;
    private ILazy`1<SubmoduleRecurse> fetchRecurseSubmodulesRule;
    private ILazy`1<SubmoduleIgnore> ignoreRule;
    private ILazy`1<SubmoduleUpdate> updateRule;
    public string Name { get; }
    public string Path { get; }
    public string Url { get; }
    public ObjectId HeadCommitId { get; }
    public ObjectId IndexCommitId { get; }
    public ObjectId WorkDirCommitId { get; }
    public SubmoduleRecurse FetchRecurseSubmodulesRule { get; }
    public SubmoduleIgnore IgnoreRule { get; }
    public SubmoduleUpdate UpdateRule { get; }
    private string DebuggerDisplay { get; }
    private IRepository LibGit2Sharp.IBelongToARepository.Repository { get; }
    internal Submodule(Repository repo, string name, string path, string url);
    private static Submodule();
    public virtual string get_Name();
    public virtual string get_Path();
    public virtual string get_Url();
    public virtual ObjectId get_HeadCommitId();
    public virtual ObjectId get_IndexCommitId();
    public virtual ObjectId get_WorkDirCommitId();
    public virtual SubmoduleRecurse get_FetchRecurseSubmodulesRule();
    public virtual SubmoduleIgnore get_IgnoreRule();
    public virtual SubmoduleUpdate get_UpdateRule();
    public virtual SubmoduleStatus RetrieveStatus();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Submodule other);
    public virtual int GetHashCode();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    private sealed virtual override IRepository LibGit2Sharp.IBelongToARepository.get_Repository();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.SubmoduleCollection : object {
    internal Repository repo;
    public Submodule Item { get; }
    private string DebuggerDisplay { get; }
    internal SubmoduleCollection(Repository repo);
    public virtual Submodule get_Item(string name);
    public virtual void Init(string name, bool overwrite);
    public virtual void Update(string name, SubmoduleUpdateOptions options);
    public virtual IEnumerator`1<Submodule> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal bool TryStage(string relativePath, bool writeIndex);
    internal T Lookup(string name, Func`2<SubmoduleHandle, T> selector, bool throwIfNotFound);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private Submodule <GetEnumerator>b__7_1(string n);
}
[ExtensionAttribute]
public static class LibGit2Sharp.SubmoduleExtensions : object {
    private static SubmoduleStatus UnmodifiedMask;
    private static SubmoduleStatus WorkDirDirtyMask;
    [ExtensionAttribute]
public static bool IsUnmodified(SubmoduleStatus this);
    [ExtensionAttribute]
public static bool IsWorkingDirectoryDirty(SubmoduleStatus this);
}
public enum LibGit2Sharp.SubmoduleIgnore : Enum {
    public int value__;
    public static SubmoduleIgnore Reset;
    public static SubmoduleIgnore None;
    public static SubmoduleIgnore Untracked;
    public static SubmoduleIgnore Dirty;
    public static SubmoduleIgnore All;
}
public enum LibGit2Sharp.SubmoduleRecurse : Enum {
    public int value__;
    public static SubmoduleRecurse Reset;
    public static SubmoduleRecurse No;
    public static SubmoduleRecurse Yes;
    public static SubmoduleRecurse OnDemand;
}
[FlagsAttribute]
public enum LibGit2Sharp.SubmoduleStatus : Enum {
    public int value__;
    public static SubmoduleStatus Unmodified;
    public static SubmoduleStatus InHead;
    public static SubmoduleStatus InIndex;
    public static SubmoduleStatus InConfig;
    public static SubmoduleStatus InWorkDir;
    public static SubmoduleStatus IndexAdded;
    public static SubmoduleStatus IndexDeleted;
    public static SubmoduleStatus IndexModified;
    public static SubmoduleStatus WorkDirUninitialized;
    public static SubmoduleStatus WorkDirAdded;
    public static SubmoduleStatus WorkDirDeleted;
    public static SubmoduleStatus WorkDirModified;
    public static SubmoduleStatus WorkDirFilesIndexDirty;
    public static SubmoduleStatus WorkDirFilesModified;
    public static SubmoduleStatus WorkDirFilesUntracked;
}
public enum LibGit2Sharp.SubmoduleUpdate : Enum {
    public int value__;
    public static SubmoduleUpdate Reset;
    public static SubmoduleUpdate Unspecified;
    public static SubmoduleUpdate Checkout;
    public static SubmoduleUpdate Rebase;
    public static SubmoduleUpdate Merge;
    public static SubmoduleUpdate None;
}
public class LibGit2Sharp.SubmoduleUpdateOptions : FetchOptionsBase {
    [CompilerGeneratedAttribute]
private bool <Init>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutNotifyHandler <OnCheckoutNotify>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutProgressHandler <OnCheckoutProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckoutNotifyFlags <CheckoutNotifyFlags>k__BackingField;
    public bool Init { get; public set; }
    public CheckoutNotifyHandler OnCheckoutNotify { get; public set; }
    public CheckoutProgressHandler OnCheckoutProgress { get; public set; }
    public CheckoutNotifyFlags CheckoutNotifyFlags { get; public set; }
    private CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.CheckoutStrategy { get; }
    private CheckoutNotifyFlags LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.CheckoutNotifyFlags { get; }
    [CompilerGeneratedAttribute]
public bool get_Init();
    [CompilerGeneratedAttribute]
public void set_Init(bool value);
    [CompilerGeneratedAttribute]
public CheckoutNotifyHandler get_OnCheckoutNotify();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutNotify(CheckoutNotifyHandler value);
    [CompilerGeneratedAttribute]
public CheckoutProgressHandler get_OnCheckoutProgress();
    [CompilerGeneratedAttribute]
public void set_OnCheckoutProgress(CheckoutProgressHandler value);
    [CompilerGeneratedAttribute]
public CheckoutNotifyFlags get_CheckoutNotifyFlags();
    [CompilerGeneratedAttribute]
public void set_CheckoutNotifyFlags(CheckoutNotifyFlags value);
    private sealed virtual override CheckoutCallbacks LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.GenerateCallbacks();
    private sealed virtual override CheckoutStrategy LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.get_CheckoutStrategy();
    private sealed virtual override CheckoutNotifyFlags LibGit2Sharp.Core.IConvertableToGitCheckoutOpts.get_CheckoutNotifyFlags();
}
[FlagsAttribute]
public enum LibGit2Sharp.SupportedCredentialTypes : Enum {
    public int value__;
    public static SupportedCredentialTypes UsernamePassword;
    public static SupportedCredentialTypes Default;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.SymbolicReference : Reference {
    private Reference target;
    public Reference Target { get; }
    private string DebuggerDisplay { get; }
    internal SymbolicReference(IRepository repo, string canonicalName, string targetIdentifier, Reference target);
    public virtual Reference get_Target();
    public virtual DirectReference ResolveToDirectReference();
    private string get_DebuggerDisplay();
}
public class LibGit2Sharp.Tag : ReferenceWrapper`1<GitObject> {
    public TagAnnotation Annotation { get; }
    public GitObject Target { get; }
    public GitObject PeeledTarget { get; }
    public bool IsAnnotated { get; }
    internal Tag(Repository repo, Reference reference, string canonicalName);
    public virtual TagAnnotation get_Annotation();
    public virtual GitObject get_Target();
    public virtual GitObject get_PeeledTarget();
    public virtual bool get_IsAnnotated();
    protected virtual string Shorten();
}
public class LibGit2Sharp.TagAnnotation : GitObject {
    private GitObjectLazyGroup group;
    private ILazy`1<GitObject> lazyTarget;
    private ILazy`1<string> lazyName;
    private ILazy`1<string> lazyMessage;
    private ILazy`1<Signature> lazyTagger;
    public string Name { get; }
    public string Message { get; }
    public GitObject Target { get; }
    public Signature Tagger { get; }
    internal TagAnnotation(Repository repo, ObjectId id);
    public virtual string get_Name();
    public virtual string get_Message();
    public virtual GitObject get_Target();
    public virtual Signature get_Tagger();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.TagCollection : object {
    internal Repository repo;
    public Tag Item { get; }
    private string DebuggerDisplay { get; }
    internal TagCollection(Repository repo);
    public virtual Tag get_Item(string name);
    public virtual IEnumerator`1<Tag> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Tag Add(string name, string objectish, Signature tagger, string message);
    public virtual Tag Add(string name, string objectish, Signature tagger, string message, bool allowOverwrite);
    public virtual Tag Add(string name, string objectish);
    public virtual Tag Add(string name, string objectish, bool allowOverwrite);
    public virtual Tag Add(string name, GitObject target, Signature tagger, string message);
    public virtual Tag Add(string name, GitObject target, Signature tagger, string message, bool allowOverwrite);
    public virtual Tag Add(string name, GitObject target);
    public virtual Tag Add(string name, GitObject target, bool allowOverwrite);
    public virtual void Remove(string name);
    public virtual void Remove(Tag tag);
    private static string NormalizeToCanonicalName(string name);
    private static string UnCanonicalizeName(string name);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private Tag <GetEnumerator>b__5_0(string n);
}
public enum LibGit2Sharp.TagFetchMode : Enum {
    public int value__;
    public static TagFetchMode FromConfigurationOrDefault;
    public static TagFetchMode Auto;
    public static TagFetchMode None;
    public static TagFetchMode All;
}
internal class LibGit2Sharp.TarArchiver : ArchiverBase {
    private TarWriter writer;
    public TarArchiver(FileStream output);
    public virtual void BeforeArchiving(Tree tree, ObjectId oid, DateTimeOffset modificationTime);
    protected virtual void AddTreeEntry(string path, TreeEntry entry, DateTimeOffset modificationTime);
    private void WriteStream(string path, TreeEntry entry, DateTimeOffset modificationTime, Func`1<Stream> streamer);
    public sealed virtual void Dispose();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.TransferProgress : object {
    private GitTransferProgress gitTransferProgress;
    public int TotalObjects { get; }
    public int IndexedObjects { get; }
    public int ReceivedObjects { get; }
    public long ReceivedBytes { get; }
    private string DebuggerDisplay { get; }
    internal TransferProgress(GitTransferProgress gitTransferProgress);
    public virtual int get_TotalObjects();
    public virtual int get_IndexedObjects();
    public virtual int get_ReceivedObjects();
    public virtual long get_ReceivedBytes();
    private string get_DebuggerDisplay();
}
internal class LibGit2Sharp.TransientBlobTreeEntryDefinition : TransientTreeEntryDefinition {
    [CompilerGeneratedAttribute]
private Func`2<ObjectDatabase, Blob> <Builder>k__BackingField;
    public TreeEntryTargetType TargetType { get; }
    public Func`2<ObjectDatabase, Blob> Builder { get; public set; }
    public virtual TreeEntryTargetType get_TargetType();
    [CompilerGeneratedAttribute]
public Func`2<ObjectDatabase, Blob> get_Builder();
    [CompilerGeneratedAttribute]
public void set_Builder(Func`2<ObjectDatabase, Blob> value);
}
public class LibGit2Sharp.TransientIndex : Index {
    internal TransientIndex(IndexHandle handle, Repository repo);
    public sealed virtual void Dispose();
}
internal abstract class LibGit2Sharp.TransientTreeEntryDefinition : TreeEntryDefinition {
    public ObjectId TargetId { get; }
    internal GitObject Target { get; }
    public virtual ObjectId get_TargetId();
    internal virtual GitObject get_Target();
}
internal class LibGit2Sharp.TransientTreeTreeEntryDefinition : TransientTreeEntryDefinition {
    public Mode Mode { get; }
    public TreeEntryTargetType TargetType { get; }
    public virtual Mode get_Mode();
    public virtual TreeEntryTargetType get_TargetType();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Tree : GitObject {
    private string path;
    private ILazy`1<int> lazyCount;
    public int Count { get; }
    public TreeEntry Item { get; }
    internal string Path { get; }
    private string DebuggerDisplay { get; }
    internal Tree(Repository repo, ObjectId id, string path);
    public virtual int get_Count();
    public virtual TreeEntry get_Item(string relativePath);
    private TreeEntry RetrieveFromPath(string relativePath);
    internal string get_Path();
    private TreeEntry byIndex(ObjectSafeWrapper obj, UInt32 i, ObjectId parentTreeId, Repository repo, string parentPath);
    internal static string CombinePath(string a, string b);
    [IteratorStateMachineAttribute("LibGit2Sharp.Tree/<GetEnumerator>d__13")]
public virtual IEnumerator`1<TreeEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.TreeChanges : object {
    private DiffHandle diff;
    private Lazy`1<int> count;
    public IEnumerable`1<TreeEntryChanges> Added { get; }
    public IEnumerable`1<TreeEntryChanges> Deleted { get; }
    public IEnumerable`1<TreeEntryChanges> Modified { get; }
    public IEnumerable`1<TreeEntryChanges> TypeChanged { get; }
    public IEnumerable`1<TreeEntryChanges> Renamed { get; }
    public IEnumerable`1<TreeEntryChanges> Copied { get; }
    public IEnumerable`1<TreeEntryChanges> Unmodified { get; }
    public IEnumerable`1<TreeEntryChanges> Conflicted { get; }
    public int Count { get; }
    private string DebuggerDisplay { get; }
    internal TreeChanges(DiffHandle diff);
    [IteratorStateMachineAttribute("LibGit2Sharp.TreeChanges/<GetChangesOfKind>d__4")]
private IEnumerable`1<TreeEntryChanges> GetChangesOfKind(ChangeKind changeKind);
    private bool TryGetEntryWithChangeTypeAt(int index, ChangeKind changeKind, TreeEntryChanges& entry);
    [IteratorStateMachineAttribute("LibGit2Sharp.TreeChanges/<GetEnumerator>d__6")]
public virtual IEnumerator`1<TreeEntryChanges> GetEnumerator();
    private TreeEntryChanges GetEntryAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerable`1<TreeEntryChanges> get_Added();
    public virtual IEnumerable`1<TreeEntryChanges> get_Deleted();
    public virtual IEnumerable`1<TreeEntryChanges> get_Modified();
    public virtual IEnumerable`1<TreeEntryChanges> get_TypeChanged();
    public virtual IEnumerable`1<TreeEntryChanges> get_Renamed();
    public virtual IEnumerable`1<TreeEntryChanges> get_Copied();
    public virtual IEnumerable`1<TreeEntryChanges> get_Unmodified();
    public virtual IEnumerable`1<TreeEntryChanges> get_Conflicted();
    public virtual int get_Count();
    private string get_DebuggerDisplay();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[DefaultMemberAttribute("Item")]
public class LibGit2Sharp.TreeDefinition : object {
    private Dictionary`2<string, TreeEntryDefinition> entries;
    private Dictionary`2<string, TreeDefinition> unwrappedTrees;
    public TreeEntryDefinition Item { get; }
    public static TreeDefinition From(Tree tree);
    public static TreeDefinition From(Commit commit);
    private void AddEntry(string targetTreeEntryName, TreeEntryDefinition treeEntryDefinition);
    public virtual TreeDefinition Remove(IEnumerable`1<string> treeEntryPaths);
    public virtual TreeDefinition Remove(string treeEntryPath);
    public virtual TreeDefinition Add(string targetTreeEntryPath, TreeEntryDefinition treeEntryDefinition);
    public virtual TreeDefinition Add(string targetTreeEntryPath, TreeEntry treeEntry);
    public virtual TreeDefinition Add(string targetTreeEntryPath, Blob blob, Mode mode);
    public virtual TreeDefinition Add(string targetTreeEntryPath, string filePath, Mode mode);
    public virtual TreeDefinition Add(string targetTreeEntryPath, ObjectId id, Mode mode);
    public virtual TreeDefinition Add(string targetTreeEntryPath, Tree tree);
    public virtual TreeDefinition Add(Submodule submodule);
    public virtual TreeDefinition AddGitLink(string targetTreeEntryPath, ObjectId objectId);
    private TreeDefinition RetrieveOrBuildTreeDefinition(string treeName, bool shouldOverWrite);
    internal Tree Build(Repository repository);
    private void WrapAllTreeDefinitions(Repository repository);
    private void WrapTree(string entryName, TreeEntryDefinition treeEntryDefinition);
    public virtual TreeEntryDefinition get_Item(string treeEntryPath);
    private static Tuple`2<string, string> ExtractPosixLeadingSegment(string targetPath);
    [CompilerGeneratedAttribute]
private void <Build>b__16_0(Tuple`2<string, TreeEntryDefinition> t);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.TreeEntry : object {
    private ObjectId parentTreeId;
    private Repository repo;
    private Lazy`1<GitObject> target;
    private ObjectId targetOid;
    private Lazy`1<string> path;
    private static LambdaEqualityHelper`1<TreeEntry> equalityHelper;
    [CompilerGeneratedAttribute]
private Mode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeEntryTargetType <TargetType>k__BackingField;
    public Mode Mode { get; private set; }
    public string Name { get; private set; }
    public string Path { get; }
    public GitObject Target { get; }
    internal ObjectId TargetId { get; }
    public TreeEntryTargetType TargetType { get; private set; }
    private string DebuggerDisplay { get; }
    internal TreeEntry(TreeEntryHandle entry, ObjectId parentTreeId, Repository repo, string parentPath);
    private static TreeEntry();
    [CompilerGeneratedAttribute]
public virtual Mode get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(Mode value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public virtual string get_Path();
    public virtual GitObject get_Target();
    internal ObjectId get_TargetId();
    [CompilerGeneratedAttribute]
public virtual TreeEntryTargetType get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(TreeEntryTargetType value);
    private GitObject RetrieveTreeEntryTarget();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TreeEntry other);
    public virtual int GetHashCode();
    public static bool op_Equality(TreeEntry left, TreeEntry right);
    public static bool op_Inequality(TreeEntry left, TreeEntry right);
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.TreeEntryChanges : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Mode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <Oid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeKind <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Mode <OldMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <OldOid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OldExists>k__BackingField;
    public string Path { get; private set; }
    public Mode Mode { get; private set; }
    public ObjectId Oid { get; private set; }
    public bool Exists { get; private set; }
    public ChangeKind Status { get; private set; }
    public string OldPath { get; private set; }
    public Mode OldMode { get; private set; }
    public ObjectId OldOid { get; private set; }
    public bool OldExists { get; private set; }
    private string DebuggerDisplay { get; }
    internal TreeEntryChanges(git_diff_delta* delta);
    internal static ChangeKind GetStatusFromChangeKind(ChangeKind changeKind);
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public virtual Mode get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(Mode value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_Oid();
    [CompilerGeneratedAttribute]
private void set_Oid(ObjectId value);
    [CompilerGeneratedAttribute]
public virtual bool get_Exists();
    [CompilerGeneratedAttribute]
private void set_Exists(bool value);
    [CompilerGeneratedAttribute]
public virtual ChangeKind get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(ChangeKind value);
    [CompilerGeneratedAttribute]
public virtual string get_OldPath();
    [CompilerGeneratedAttribute]
private void set_OldPath(string value);
    [CompilerGeneratedAttribute]
public virtual Mode get_OldMode();
    [CompilerGeneratedAttribute]
private void set_OldMode(Mode value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_OldOid();
    [CompilerGeneratedAttribute]
private void set_OldOid(ObjectId value);
    [CompilerGeneratedAttribute]
public virtual bool get_OldExists();
    [CompilerGeneratedAttribute]
private void set_OldExists(bool value);
    private string get_DebuggerDisplay();
}
public class LibGit2Sharp.TreeEntryDefinition : object {
    private Lazy`1<GitObject> target;
    private static LambdaEqualityHelper`1<TreeEntryDefinition> equalityHelper;
    internal static Enum[] BlobModes;
    [CompilerGeneratedAttribute]
private Mode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeEntryTargetType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectId <TargetId>k__BackingField;
    public Mode Mode { get; private set; }
    public TreeEntryTargetType TargetType { get; private set; }
    public ObjectId TargetId { get; private set; }
    internal GitObject Target { get; }
    private static TreeEntryDefinition();
    [CompilerGeneratedAttribute]
public virtual Mode get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(Mode value);
    [CompilerGeneratedAttribute]
public virtual TreeEntryTargetType get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(TreeEntryTargetType value);
    [CompilerGeneratedAttribute]
public virtual ObjectId get_TargetId();
    [CompilerGeneratedAttribute]
private void set_TargetId(ObjectId value);
    internal virtual GitObject get_Target();
    internal static TreeEntryDefinition From(TreeEntry treeEntry);
    internal static TreeEntryDefinition From(Blob blob, Mode mode);
    internal static TreeEntryDefinition From(ObjectId id, Mode mode);
    internal static TreeEntryDefinition TransientBlobFrom(string filePath, Mode mode);
    internal static TreeEntryDefinition From(ObjectId objectId);
    internal static TreeEntryDefinition From(Tree tree);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TreeEntryDefinition other);
    public virtual int GetHashCode();
    public static bool op_Equality(TreeEntryDefinition left, TreeEntryDefinition right);
    public static bool op_Inequality(TreeEntryDefinition left, TreeEntryDefinition right);
}
public enum LibGit2Sharp.TreeEntryTargetType : Enum {
    public int value__;
    public static TreeEntryTargetType Blob;
    public static TreeEntryTargetType Tree;
    public static TreeEntryTargetType GitLink;
}
[ExtensionAttribute]
internal static class LibGit2Sharp.TreeEntryTargetTypeExtensions : object {
    [ExtensionAttribute]
public static GitObjectType ToGitObjectType(TreeEntryTargetType type);
}
public class LibGit2Sharp.UnbornBranchException : LibGit2SharpException {
    public UnbornBranchException(string message);
    public UnbornBranchException(string format, Object[] args);
    public UnbornBranchException(string message, Exception innerException);
    protected UnbornBranchException(SerializationInfo info, StreamingContext context);
}
public class LibGit2Sharp.UnmatchedPathException : LibGit2SharpException {
    public UnmatchedPathException(string message);
    public UnmatchedPathException(string format, Object[] args);
    public UnmatchedPathException(string message, Exception innerException);
    protected UnmatchedPathException(SerializationInfo info, StreamingContext context);
}
public class LibGit2Sharp.UnmergedIndexEntriesException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public UnmergedIndexEntriesException(string message);
    public UnmergedIndexEntriesException(string format, Object[] args);
    public UnmergedIndexEntriesException(string message, Exception innerException);
    protected UnmergedIndexEntriesException(SerializationInfo info, StreamingContext context);
    internal UnmergedIndexEntriesException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
public class LibGit2Sharp.UserCancelledException : NativeException {
    internal GitErrorCode ErrorCode { get; }
    public UserCancelledException(string message);
    public UserCancelledException(string format, Object[] args);
    public UserCancelledException(string message, Exception innerException);
    protected UserCancelledException(SerializationInfo info, StreamingContext context);
    internal UserCancelledException(string message, GitErrorCategory category);
    internal virtual GitErrorCode get_ErrorCode();
}
public class LibGit2Sharp.UsernamePasswordCredentials : Credentials {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Username { get; public set; }
    public string Password { get; public set; }
    protected internal virtual int GitCredentialHandler(IntPtr& cred);
    internal static UsernamePasswordCredentials FromNative(GitCredentialUserpass* gitCred);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
}
public class LibGit2Sharp.Version : object {
    public string InformationalVersion { get; }
    public BuiltInFeatures Features { get; }
    public string LibGit2CommitSha { get; }
    public string LibGit2SharpCommitSha { get; }
    internal static Version Build();
    public virtual string get_InformationalVersion();
    public virtual BuiltInFeatures get_Features();
    public virtual string get_LibGit2CommitSha();
    public virtual string get_LibGit2SharpCommitSha();
    private string RetrieveAbbrevShaFrom(string sha);
    public virtual string ToString();
    private string RetrieveVersion();
}
internal class LibGit2Sharp.VoidReference : Reference {
    internal VoidReference(IRepository repo, string canonicalName);
    public virtual DirectReference ResolveToDirectReference();
}
public enum LibGit2Sharp.WhitespaceMode : Enum {
    public int value__;
    public static WhitespaceMode IgnoreLeadingWhitespace;
    public static WhitespaceMode IgnoreAllWhitespace;
    public static WhitespaceMode DontIgnoreWhitespace;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.Worktree : object {
    private static LambdaEqualityHelper`1<Worktree> equalityHelper;
    private Repository parent;
    private string name;
    private WorktreeLock worktreeLock;
    public string Name { get; }
    public Repository WorktreeRepository { get; }
    public bool IsLocked { get; }
    public string LockReason { get; }
    private string DebuggerDisplay { get; }
    private IRepository LibGit2Sharp.IBelongToARepository.Repository { get; }
    internal Worktree(Repository repo, string name, WorktreeLock worktreeLock);
    private static Worktree();
    internal WorktreeHandle GetWorktreeHandle();
    public virtual string get_Name();
    public virtual Repository get_WorktreeRepository();
    public virtual bool get_IsLocked();
    public virtual string get_LockReason();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Worktree other);
    public virtual void Unlock();
    public virtual void Lock(string reason);
    public virtual int GetHashCode();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    private sealed virtual override IRepository LibGit2Sharp.IBelongToARepository.get_Repository();
}
[DefaultMemberAttribute("Item")]
public class LibGit2Sharp.WorktreeCollection : object {
    internal Repository repo;
    public Worktree Item { get; }
    private string DebuggerDisplay { get; }
    internal WorktreeCollection(Repository repo);
    public virtual Worktree get_Item(string name);
    public virtual Worktree Add(string committishOrBranchSpec, string name, string path, bool isLocked);
    public virtual Worktree Add(string name, string path, bool isLocked);
    public virtual bool Prune(Worktree worktree);
    public virtual bool Prune(Worktree worktree, bool ifLocked);
    internal T Lookup(string name, Func`2<WorktreeHandle, T> selector, bool throwIfNotFound);
    public virtual IEnumerator`1<Worktree> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private Worktree <GetEnumerator>b__10_0(string n);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class LibGit2Sharp.WorktreeLock : object {
    [CompilerGeneratedAttribute]
private bool <IsLocked>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public bool IsLocked { get; }
    public string Reason { get; }
    private string DebuggerDisplay { get; }
    public WorktreeLock(bool isLocked, string reason);
    [CompilerGeneratedAttribute]
public virtual bool get_IsLocked();
    [CompilerGeneratedAttribute]
public virtual string get_Reason();
    private string get_DebuggerDisplay();
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.4.220.64166")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
