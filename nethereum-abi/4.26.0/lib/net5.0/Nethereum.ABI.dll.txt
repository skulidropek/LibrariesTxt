[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Nethereum.ABI.ABIDeserialisation.ABIDeserialiserFactory : object {
    public static ContractABI DeserialiseContractABI(string jsonOrStringSignatureABI);
    private static bool IsJson(string value);
}
public class Nethereum.ABI.ABIDeserialisation.ABIJsonDeserialiser : object {
    public ConstructorABI BuildConstructor(IDictionary`2<string, object> constructor);
    public EventABI BuildEvent(IDictionary`2<string, object> eventobject);
    public Parameter[] BuildEventParameters(List`1<object> inputs);
    public ErrorABI BuildError(IDictionary`2<string, object> errorObject);
    private void InitialiseTupleComponents(IDictionary`2<string, object> input, Parameter parameter);
    public FunctionABI BuildFunction(IDictionary`2<string, object> function);
    public Parameter[] BuildFunctionParameters(List`1<object> inputs);
    public ContractABI DeserialiseContract(string abi);
    public ContractABI DeserialiseContract(JArray abi);
    private ContractABI DeserialiseContractBody(List`1<IDictionary`2<string, object>> contract);
    public bool TryGetSerpentValue(IDictionary`2<string, object> function);
    public string TryGetInternalType(IDictionary`2<string, object> parameter);
    public string TryGetName(IDictionary`2<string, object> parameter);
    public string TryGetSignatureValue(IDictionary`2<string, object> parameter);
}
public class Nethereum.ABI.ABIDeserialisation.ABIStringSignatureDeserialiser : object {
    private static string paramsRegPattern;
    public List`1<Parameter> ExtractParameters(string parameters, bool canIndex);
    private string GetType(string type);
    public ErrorABI ExtractErrorABI(string signature, string name, string parameters);
    public EventABI ExtractEventABI(string signature, string name, string parameters);
    public ConstructorABI ExtractConstructorABI(string signature, string name, string parameters);
    public FunctionABI ExtractFunctionABI(string signature, string name, string parameters);
    public ContractABI ExtractContractABIWithLineBreakSplitSignatures(string signatures);
    public ContractABI ExtractContractABI(String[] signatures);
}
public class Nethereum.ABI.ABIDeserialisation.ExpandoObjectConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool IsPrimitiveToken(JsonToken token);
    private object ReadList(JsonReader reader);
    private object ReadObject(JsonReader reader);
    private object ReadValue(JsonReader reader);
}
public class Nethereum.ABI.ABIDeserialisation.JObjectToExpandoConverter : object {
    public List`1<IDictionary`2<string, object>> JObjectArray(JArray array);
    public List`1<object> JArray(JArray array);
    public IDictionary`2<string, object> JObject(JObject obj);
    public object JToken(JToken token);
}
public class Nethereum.ABI.ABIEncode : object {
    public Byte[] GetSha3ABIEncodedPacked(ABIValue[] abiValues);
    public Byte[] GetSha3ABIEncodedPacked(Object[] values);
    public Byte[] GetSha3ABIEncoded(ABIValue[] abiValues);
    public Byte[] GetSha3ABIEncoded(Object[] values);
    public Byte[] GetSha3ABIParamsEncodedPacked(T input);
    public Byte[] GetSha3ABIParamsEncoded(T input);
    public Byte[] GetABIEncodedPacked(ABIValue[] abiValues);
    public Byte[] GetABIEncoded(ABIValue[] abiValues);
    public Byte[] GetABIEncoded(Object[] values);
    public Byte[] GetABIParamsEncodedPacked(T input);
    public Byte[] GetABIParamsEncoded(T input);
    private List`1<ABIValue> ConvertValuesToDefaultABIValues(Object[] values);
    public Byte[] GetABIEncodedPacked(Object[] values);
    public T DecodeEncodedComplexType(Byte[] encoded);
    public BigInteger DecodeEncodedBigInteger(Byte[] encoded);
    public string DecodeEncodedAddress(Byte[] encoded);
    public bool DecodeEncodedBoolean(Byte[] encoded);
    public string DecodeEncodedString(Byte[] encoded);
}
public class Nethereum.ABI.ABIRepository.ABIInfo : object {
    [CompilerGeneratedAttribute]
private string <ABI>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContractName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContractType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ChainId>k__BackingField;
    [CompilerGeneratedAttribute]
private ContractABI <ContractABI>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationMetadata <Metadata>k__BackingField;
    [JsonPropertyAttribute("abi")]
public string ABI { get; public set; }
    [JsonPropertyAttribute("contractName")]
public string ContractName { get; public set; }
    [JsonPropertyAttribute("contractType")]
public string ContractType { get; public set; }
    [JsonPropertyAttribute("address")]
public string Address { get; public set; }
    [JsonPropertyAttribute("chainId")]
public Nullable`1<long> ChainId { get; public set; }
    [JsonIgnoreAttribute]
public ContractABI ContractABI { get; public set; }
    [JsonPropertyAttribute("metadata")]
public CompilationMetadata Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ABI();
    [CompilerGeneratedAttribute]
public void set_ABI(string value);
    [CompilerGeneratedAttribute]
public string get_ContractName();
    [CompilerGeneratedAttribute]
public void set_ContractName(string value);
    [CompilerGeneratedAttribute]
public string get_ContractType();
    [CompilerGeneratedAttribute]
public void set_ContractType(string value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ChainId();
    [CompilerGeneratedAttribute]
public void set_ChainId(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public ContractABI get_ContractABI();
    [CompilerGeneratedAttribute]
public void set_ContractABI(ContractABI value);
    [CompilerGeneratedAttribute]
public CompilationMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(CompilationMetadata value);
    public void InitialiseContractABI(bool force);
    public static ABIInfo FromCompilationMetadata(CompilationMetadata compilationMetadata, string address, string contractName, string contractType, Nullable`1<long> chainId);
    public static ABIInfo FromABI(string abi, string address, string contractName, string contractType, Nullable`1<long> chainId);
    public static ABIInfo FromABI(string abi);
}
public class Nethereum.ABI.ABIRepository.ABIInfoInMemoryStorage : object {
    private List`1<ABIInfo> _abiInfos;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, List`1<FunctionABI>> <_signatureToFunctionABIDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, List`1<ErrorABI>> <_signatureToErrorABIDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, List`1<EventABI>> <_signatureToEventABIDictionary>k__BackingField;
    private IDictionary`2<string, List`1<FunctionABI>> _signatureToFunctionABIDictionary { get; private set; }
    private IDictionary`2<string, List`1<ErrorABI>> _signatureToErrorABIDictionary { get; private set; }
    private IDictionary`2<string, List`1<EventABI>> _signatureToEventABIDictionary { get; private set; }
    [CompilerGeneratedAttribute]
private IDictionary`2<string, List`1<FunctionABI>> get__signatureToFunctionABIDictionary();
    [CompilerGeneratedAttribute]
private void set__signatureToFunctionABIDictionary(IDictionary`2<string, List`1<FunctionABI>> value);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, List`1<ErrorABI>> get__signatureToErrorABIDictionary();
    [CompilerGeneratedAttribute]
private void set__signatureToErrorABIDictionary(IDictionary`2<string, List`1<ErrorABI>> value);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, List`1<EventABI>> get__signatureToEventABIDictionary();
    [CompilerGeneratedAttribute]
private void set__signatureToEventABIDictionary(IDictionary`2<string, List`1<EventABI>> value);
    public sealed virtual ABIInfo GetABIInfo(BigInteger chainId, string contractAddress);
    public sealed virtual FunctionABI FindFunctionABI(BigInteger chainId, string contractAddress, string signature);
    public sealed virtual FunctionABI FindFunctionABIFromInputData(BigInteger chainId, string contractAddress, string inputData);
    public sealed virtual ErrorABI FindErrorABI(BigInteger chainId, string contractAddress, string signature);
    public sealed virtual EventABI FindEventABI(BigInteger chainId, string contractAddress, string signature);
    public sealed virtual List`1<FunctionABI> FindFunctionABI(string signature);
    public sealed virtual List`1<ErrorABI> FindErrorABI(string signature);
    public sealed virtual List`1<EventABI> FindEventABI(string signature);
    public void AddABIInfo(string abi);
    public void AddABIInfo(string abi, string address, string contractName, string contractType, Nullable`1<long> chainId);
    public void AddABIInfo(CompilationMetadata compilationMetadata, string address, string contractName, string contractType, Nullable`1<long> chainId);
    public sealed virtual void AddABIInfo(ABIInfo abiInfo);
    public sealed virtual List`1<FunctionABI> FindFunctionABIFromInputData(string inputData);
    public void AddEventABI(EventABI eventABI);
    public void AddErrorABI(ErrorABI errorABI);
    public void AddFunctionABI(FunctionABI functionABI);
}
public interface Nethereum.ABI.ABIRepository.IABIInfoStorage {
    public abstract virtual void AddABIInfo(ABIInfo abiInfo);
    public abstract virtual ErrorABI FindErrorABI(BigInteger chainId, string contractAddress, string signature);
    public abstract virtual List`1<ErrorABI> FindErrorABI(string signature);
    public abstract virtual EventABI FindEventABI(BigInteger chainId, string contractAddress, string signature);
    public abstract virtual List`1<EventABI> FindEventABI(string signature);
    public abstract virtual FunctionABI FindFunctionABI(BigInteger chainId, string contractAddress, string signature);
    public abstract virtual List`1<FunctionABI> FindFunctionABI(string signature);
    public abstract virtual FunctionABI FindFunctionABIFromInputData(BigInteger chainId, string contractAddress, string inputData);
    public abstract virtual List`1<FunctionABI> FindFunctionABIFromInputData(string inputData);
    public abstract virtual ABIInfo GetABIInfo(BigInteger chainId, string contractAddress);
}
public abstract class Nethereum.ABI.ABIType : object {
    [CompilerGeneratedAttribute]
private ITypeDecoder <Decoder>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeEncoder <Encoder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    protected ITypeDecoder Decoder { get; protected set; }
    protected ITypeEncoder Encoder { get; protected set; }
    public string Name { get; }
    public string CanonicalName { get; }
    public int FixedSize { get; }
    public int StaticSize { get; }
    public ABIType(string name);
    [CompilerGeneratedAttribute]
protected ITypeDecoder get_Decoder();
    [CompilerGeneratedAttribute]
protected void set_Decoder(ITypeDecoder value);
    [CompilerGeneratedAttribute]
protected ITypeEncoder get_Encoder();
    [CompilerGeneratedAttribute]
protected void set_Encoder(ITypeEncoder value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public virtual string get_CanonicalName();
    public virtual int get_FixedSize();
    public virtual int get_StaticSize();
    public static ABIType CreateABIType(string typeName);
    public object Decode(Byte[] encoded, Type type);
    public object Decode(string encoded, Type type);
    public T Decode(string encoded);
    public T Decode(Byte[] encoded);
    public Byte[] Encode(object value);
    public Byte[] EncodePacked(object value);
    public Type GetDefaultDecodingType();
    public bool IsDynamic();
    public virtual string ToString();
    public object DecodePacked(Byte[] encodedElement, Type elementType);
    public T DecodePacked(string encoded);
    public T DecodePacked(Byte[] encoded);
}
public class Nethereum.ABI.ABIValue : object {
    [CompilerGeneratedAttribute]
private ABIType <ABIType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public ABIType ABIType { get; public set; }
    public object Value { get; public set; }
    public ABIValue(ABIType abiType, object value);
    public ABIValue(string abiType, object value);
    [CompilerGeneratedAttribute]
public ABIType get_ABIType();
    [CompilerGeneratedAttribute]
public void set_ABIType(ABIType value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class Nethereum.ABI.AddressType : ABIType {
    public int StaticSize { get; }
    public virtual int get_StaticSize();
}
public abstract class Nethereum.ABI.ArrayType : ABIType {
    [CompilerGeneratedAttribute]
private ABIType <ElementType>k__BackingField;
    public ABIType ElementType { get; public set; }
    protected ArrayType(string name);
    [CompilerGeneratedAttribute]
public ABIType get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(ABIType value);
    public abstract virtual object DecodePackedUsingElementPacked(Byte[] encoded, Type type);
    public abstract virtual Byte[] EncodePackedUsingElementPacked(object value);
    public static ArrayType CreateABIType(string typeName);
    private void InitialiseElementType(string name);
}
public class Nethereum.ABI.BoolType : ABIType {
    public int StaticSize { get; }
    public virtual int get_StaticSize();
}
public class Nethereum.ABI.ByteArrayConvertors.AbiStructEncoderByteConvertor`1 : object {
    private ABIEncode _abiEncode;
    public sealed virtual Byte[] ConvertToByteArray(T data);
}
public class Nethereum.ABI.ByteArrayConvertors.AbiStructEncoderPackedByteConvertor`1 : object {
    private ABIEncode _abiEncode;
    public sealed virtual Byte[] ConvertToByteArray(T data);
}
public class Nethereum.ABI.ByteArrayConvertors.AbiStructSha3KeccackHashByteArrayConvertor`1 : object {
    private ABIEncode _abiEncode;
    public sealed virtual Byte[] ConvertToByteArray(T data);
}
public static class Nethereum.ABI.ByteCodeConstants : object {
    public static string LIBRARY_PLACEHOLDER_PREFIX;
    public static string LIBRARY_PLACEHOLDER_SUFFIX;
    private static ByteCodeConstants();
}
public class Nethereum.ABI.Bytes32Type : ABIType {
    public int StaticSize { get; }
    public Bytes32Type(string name);
    public virtual int get_StaticSize();
}
public class Nethereum.ABI.BytesElementaryType : ABIType {
    [CompilerGeneratedAttribute]
private int <StaticSize>k__BackingField;
    public int StaticSize { get; }
    public BytesElementaryType(string name, int size);
    [CompilerGeneratedAttribute]
public virtual int get_StaticSize();
}
public class Nethereum.ABI.BytesType : ABIType {
    public int FixedSize { get; }
    public virtual int get_FixedSize();
}
public class Nethereum.ABI.CompilationMetadata.CompilationMetadata : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Compiler <Compiler>k__BackingField;
    [CompilerGeneratedAttribute]
private Output <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SourceCode> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private Settings <Settings>k__BackingField;
    [JsonPropertyAttribute("version")]
public string Version { get; public set; }
    [JsonPropertyAttribute("language")]
public string Language { get; public set; }
    [JsonPropertyAttribute("compiler")]
public Compiler Compiler { get; public set; }
    [JsonPropertyAttribute("output")]
public Output Output { get; public set; }
    [JsonPropertyAttribute("sources")]
public Dictionary`2<string, SourceCode> Sources { get; public set; }
    [JsonPropertyAttribute("settings")]
public Settings Settings { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public Compiler get_Compiler();
    [CompilerGeneratedAttribute]
public void set_Compiler(Compiler value);
    [CompilerGeneratedAttribute]
public Output get_Output();
    [CompilerGeneratedAttribute]
public void set_Output(Output value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SourceCode> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(Dictionary`2<string, SourceCode> value);
    [CompilerGeneratedAttribute]
public Settings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(Settings value);
}
public static class Nethereum.ABI.CompilationMetadata.CompilationMetadataDeserialiser : object {
    public static CompilationMetadata DeserialiseCompilationMetadata(string json);
}
public class Nethereum.ABI.CompilationMetadata.Compiler : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keccak256>k__BackingField;
    [JsonPropertyAttribute("version")]
public string Version { get; public set; }
    [JsonPropertyAttribute("keccak256")]
public string Keccak256 { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Keccak256();
    [CompilerGeneratedAttribute]
public void set_Keccak256(string value);
}
public class Nethereum.ABI.CompilationMetadata.DevDoc : object {
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, DevDocError> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, DevDocEvent> <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, DevDocMethod> <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, DevDocStateVariable> <StateVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [JsonPropertyAttribute("author")]
public string Author { get; public set; }
    [JsonPropertyAttribute("details")]
public string Details { get; public set; }
    [JsonPropertyAttribute("errors")]
public IDictionary`2<string, DevDocError> Errors { get; public set; }
    [JsonPropertyAttribute("events")]
public IDictionary`2<string, DevDocEvent> Events { get; public set; }
    [JsonPropertyAttribute("kind")]
public string Kind { get; public set; }
    [JsonPropertyAttribute("methods")]
public IDictionary`2<string, DevDocMethod> Methods { get; public set; }
    [JsonPropertyAttribute("stateVariables")]
public IDictionary`2<string, DevDocStateVariable> StateVariables { get; public set; }
    [JsonPropertyAttribute("title")]
public string Title { get; public set; }
    [JsonPropertyAttribute("version")]
public int Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public string get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, DevDocError> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(IDictionary`2<string, DevDocError> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, DevDocEvent> get_Events();
    [CompilerGeneratedAttribute]
public void set_Events(IDictionary`2<string, DevDocEvent> value);
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, DevDocMethod> get_Methods();
    [CompilerGeneratedAttribute]
public void set_Methods(IDictionary`2<string, DevDocMethod> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, DevDocStateVariable> get_StateVariables();
    [CompilerGeneratedAttribute]
public void set_StateVariables(IDictionary`2<string, DevDocStateVariable> value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
}
public class Nethereum.ABI.CompilationMetadata.DevDocError : DevDocStatementBase {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Params>k__BackingField;
    [JsonPropertyAttribute("params")]
public IDictionary`2<string, string> Params { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Params();
    [CompilerGeneratedAttribute]
public void set_Params(IDictionary`2<string, string> value);
}
public class Nethereum.ABI.CompilationMetadata.DevDocEvent : DevDocStatementBase {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Params>k__BackingField;
    [JsonPropertyAttribute("params")]
public IDictionary`2<string, string> Params { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Params();
    [CompilerGeneratedAttribute]
public void set_Params(IDictionary`2<string, string> value);
}
public class Nethereum.ABI.CompilationMetadata.DevDocMethod : DevDocStatementBase {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Params>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Returns>k__BackingField;
    [JsonPropertyAttribute("params")]
public IDictionary`2<string, string> Params { get; public set; }
    [JsonPropertyAttribute("returns")]
public IDictionary`2<string, string> Returns { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Params();
    [CompilerGeneratedAttribute]
public void set_Params(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Returns();
    [CompilerGeneratedAttribute]
public void set_Returns(IDictionary`2<string, string> value);
}
public class Nethereum.ABI.CompilationMetadata.DevDocStatementBase : object {
    [CompilerGeneratedAttribute]
private string <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Notice>k__BackingField;
    [JsonPropertyAttribute("details")]
public string Details { get; public set; }
    [JsonPropertyAttribute("notice")]
public string Notice { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(string value);
    [CompilerGeneratedAttribute]
public string get_Notice();
    [CompilerGeneratedAttribute]
public void set_Notice(string value);
}
public class Nethereum.ABI.CompilationMetadata.DevDocStateVariable : object {
    [CompilerGeneratedAttribute]
private string <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Notice>k__BackingField;
    [JsonPropertyAttribute("details")]
public string Details { get; public set; }
    [JsonPropertyAttribute("notice")]
public string Notice { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(string value);
    [CompilerGeneratedAttribute]
public string get_Notice();
    [CompilerGeneratedAttribute]
public void set_Notice(string value);
}
public class Nethereum.ABI.CompilationMetadata.Metadata : object {
    [CompilerGeneratedAttribute]
private bool <AppendCBOR>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BytecodeHash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLiteralContent>k__BackingField;
    [JsonPropertyAttribute("appendCBOR")]
public bool AppendCBOR { get; public set; }
    [JsonPropertyAttribute("bytecodeHash")]
public string BytecodeHash { get; public set; }
    [JsonPropertyAttribute("useLiteralContent")]
public bool UseLiteralContent { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AppendCBOR();
    [CompilerGeneratedAttribute]
public void set_AppendCBOR(bool value);
    [CompilerGeneratedAttribute]
public string get_BytecodeHash();
    [CompilerGeneratedAttribute]
public void set_BytecodeHash(string value);
    [CompilerGeneratedAttribute]
public bool get_UseLiteralContent();
    [CompilerGeneratedAttribute]
public void set_UseLiteralContent(bool value);
}
public class Nethereum.ABI.CompilationMetadata.OptimizationDetails : object {
    [CompilerGeneratedAttribute]
private bool <PeepHole>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inliner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <JumpDestRemover>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OrderLiterals>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deduplicate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConstantOptimizer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Yul>k__BackingField;
    [CompilerGeneratedAttribute]
private YulDetails <YulDetails>k__BackingField;
    [JsonPropertyAttribute("peephole")]
public bool PeepHole { get; public set; }
    [JsonPropertyAttribute("inliner")]
public bool Inliner { get; public set; }
    [JsonPropertyAttribute("jumpdestRemover")]
public bool JumpDestRemover { get; public set; }
    [JsonPropertyAttribute("orderLiterals")]
public bool OrderLiterals { get; public set; }
    [JsonPropertyAttribute("deduplicate")]
public bool Deduplicate { get; public set; }
    [JsonPropertyAttribute("cse")]
public bool Cse { get; public set; }
    [JsonPropertyAttribute("constantOptimizer")]
public bool ConstantOptimizer { get; public set; }
    [JsonPropertyAttribute("yul")]
public bool Yul { get; public set; }
    [JsonPropertyAttribute("yulDetails")]
public YulDetails YulDetails { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PeepHole();
    [CompilerGeneratedAttribute]
public void set_PeepHole(bool value);
    [CompilerGeneratedAttribute]
public bool get_Inliner();
    [CompilerGeneratedAttribute]
public void set_Inliner(bool value);
    [CompilerGeneratedAttribute]
public bool get_JumpDestRemover();
    [CompilerGeneratedAttribute]
public void set_JumpDestRemover(bool value);
    [CompilerGeneratedAttribute]
public bool get_OrderLiterals();
    [CompilerGeneratedAttribute]
public void set_OrderLiterals(bool value);
    [CompilerGeneratedAttribute]
public bool get_Deduplicate();
    [CompilerGeneratedAttribute]
public void set_Deduplicate(bool value);
    [CompilerGeneratedAttribute]
public bool get_Cse();
    [CompilerGeneratedAttribute]
public void set_Cse(bool value);
    [CompilerGeneratedAttribute]
public bool get_ConstantOptimizer();
    [CompilerGeneratedAttribute]
public void set_ConstantOptimizer(bool value);
    [CompilerGeneratedAttribute]
public bool get_Yul();
    [CompilerGeneratedAttribute]
public void set_Yul(bool value);
    [CompilerGeneratedAttribute]
public YulDetails get_YulDetails();
    [CompilerGeneratedAttribute]
public void set_YulDetails(YulDetails value);
}
public class Nethereum.ABI.CompilationMetadata.Optimizer : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Runs>k__BackingField;
    [CompilerGeneratedAttribute]
private OptimizationDetails <Details>k__BackingField;
    [JsonPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    [JsonPropertyAttribute("runs")]
public int Runs { get; public set; }
    [JsonPropertyAttribute("details")]
public OptimizationDetails Details { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public int get_Runs();
    [CompilerGeneratedAttribute]
public void set_Runs(int value);
    [CompilerGeneratedAttribute]
public OptimizationDetails get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(OptimizationDetails value);
}
public class Nethereum.ABI.CompilationMetadata.Output : object {
    [CompilerGeneratedAttribute]
private JArray <Abi>k__BackingField;
    [CompilerGeneratedAttribute]
private DevDoc <DevDoc>k__BackingField;
    [CompilerGeneratedAttribute]
private UserDoc <UserDoc>k__BackingField;
    [JsonPropertyAttribute("abi")]
public JArray Abi { get; public set; }
    [JsonPropertyAttribute("devdoc")]
public DevDoc DevDoc { get; public set; }
    [JsonPropertyAttribute("userdoc")]
public UserDoc UserDoc { get; public set; }
    [CompilerGeneratedAttribute]
public JArray get_Abi();
    [CompilerGeneratedAttribute]
public void set_Abi(JArray value);
    [CompilerGeneratedAttribute]
public DevDoc get_DevDoc();
    [CompilerGeneratedAttribute]
public void set_DevDoc(DevDoc value);
    [CompilerGeneratedAttribute]
public UserDoc get_UserDoc();
    [CompilerGeneratedAttribute]
public void set_UserDoc(UserDoc value);
}
public class Nethereum.ABI.CompilationMetadata.Settings : object {
    [CompilerGeneratedAttribute]
private string <EvmVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Remappings>k__BackingField;
    [CompilerGeneratedAttribute]
private Optimizer <Optimizer>k__BackingField;
    [CompilerGeneratedAttribute]
private Metadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <CompilationTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Libraries>k__BackingField;
    [JsonPropertyAttribute("evmVersion")]
public string EvmVersion { get; public set; }
    [JsonPropertyAttribute("remappings")]
public List`1<string> Remappings { get; public set; }
    [JsonPropertyAttribute("optimizer")]
public Optimizer Optimizer { get; public set; }
    [JsonPropertyAttribute("metadata")]
public Metadata Metadata { get; public set; }
    [JsonPropertyAttribute("compilationTarget")]
public IDictionary`2<string, string> CompilationTarget { get; public set; }
    [JsonPropertyAttribute("libraries")]
public IDictionary`2<string, string> Libraries { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EvmVersion();
    [CompilerGeneratedAttribute]
public void set_EvmVersion(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Remappings();
    [CompilerGeneratedAttribute]
public void set_Remappings(List`1<string> value);
    [CompilerGeneratedAttribute]
public Optimizer get_Optimizer();
    [CompilerGeneratedAttribute]
public void set_Optimizer(Optimizer value);
    [CompilerGeneratedAttribute]
public Metadata get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(Metadata value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_CompilationTarget();
    [CompilerGeneratedAttribute]
public void set_CompilationTarget(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IDictionary`2<string, string> value);
}
public class Nethereum.ABI.CompilationMetadata.SourceCode : object {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keccak256>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Urls>k__BackingField;
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [JsonPropertyAttribute("content")]
public string Content { get; public set; }
    [JsonPropertyAttribute("keccak256")]
public string Keccak256 { get; public set; }
    [JsonPropertyAttribute("urls")]
public List`1<string> Urls { get; public set; }
    [JsonPropertyAttribute("license")]
public string License { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
    [CompilerGeneratedAttribute]
public string get_Keccak256();
    [CompilerGeneratedAttribute]
public void set_Keccak256(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Urls();
    [CompilerGeneratedAttribute]
public void set_Urls(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public void set_License(string value);
}
public class Nethereum.ABI.CompilationMetadata.UserDoc : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, UserDocStatement> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, UserDocStatement> <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, UserDocStatement> <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [JsonPropertyAttribute("errors")]
public IDictionary`2<string, UserDocStatement> Errors { get; public set; }
    [JsonPropertyAttribute("events")]
public IDictionary`2<string, UserDocStatement> Events { get; public set; }
    [JsonPropertyAttribute("kind")]
public string Kind { get; public set; }
    [JsonPropertyAttribute("methods")]
public IDictionary`2<string, UserDocStatement> Methods { get; public set; }
    [JsonPropertyAttribute("version")]
public int Version { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, UserDocStatement> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(IDictionary`2<string, UserDocStatement> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, UserDocStatement> get_Events();
    [CompilerGeneratedAttribute]
public void set_Events(IDictionary`2<string, UserDocStatement> value);
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, UserDocStatement> get_Methods();
    [CompilerGeneratedAttribute]
public void set_Methods(IDictionary`2<string, UserDocStatement> value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
}
public class Nethereum.ABI.CompilationMetadata.UserDocStatement : object {
    [CompilerGeneratedAttribute]
private string <Notice>k__BackingField;
    [JsonPropertyAttribute("notice")]
public string Notice { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Notice();
    [CompilerGeneratedAttribute]
public void set_Notice(string value);
}
public class Nethereum.ABI.CompilationMetadata.YulDetails : object {
    [CompilerGeneratedAttribute]
private string <OptimizerSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StackAllocation>k__BackingField;
    [JsonPropertyAttribute("optimizerSteps")]
public string OptimizerSteps { get; public set; }
    [JsonPropertyAttribute("stackAllocation")]
public bool StackAllocation { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OptimizerSteps();
    [CompilerGeneratedAttribute]
public void set_OptimizerSteps(string value);
    [CompilerGeneratedAttribute]
public bool get_StackAllocation();
    [CompilerGeneratedAttribute]
public void set_StackAllocation(bool value);
}
public class Nethereum.ABI.Decoders.AddressTypeDecoder : TypeDecoder {
    private IntTypeDecoder _intTypeDecoder;
    public virtual object Decode(Byte[] encoded, Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
}
public class Nethereum.ABI.Decoders.ArrayTypeDecoder : TypeDecoder {
    private AttributesToABIExtractor _attributesToABIExtractor;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private ABIType <ElementType>k__BackingField;
    public int Size { get; protected set; }
    protected ABIType ElementType { get; protected set; }
    public ArrayTypeDecoder(ABIType elementType, int size);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
protected void set_Size(int value);
    [CompilerGeneratedAttribute]
protected ABIType get_ElementType();
    [CompilerGeneratedAttribute]
protected void set_ElementType(ABIType value);
    public virtual object Decode(Byte[] encoded, Type type);
    protected object Decode(Byte[] encoded, Type type, int size);
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
    protected virtual object DecodeDynamicElementType(Byte[] encoded, Type type, int size);
    private void DecodeAndAddElement(Type elementType, IList decodedList, Byte[] encodedElement);
    protected void InitTupleElementComponents(Type elementType, TupleType tupleTypeElement);
    protected virtual object DecodeStaticElementType(Byte[] encoded, Type type, int size);
    public static Type GetIListElementType(Type listType);
    public object DecodePackedUsingElementPacked(Byte[] encoded, Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
}
public class Nethereum.ABI.Decoders.BoolTypeDecoder : TypeDecoder {
    private IntTypeDecoder _intTypeDecoder;
    public bool Decode(Byte[] encoded);
    public virtual object Decode(Byte[] encoded, Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
}
public class Nethereum.ABI.Decoders.Bytes32TypeDecoder : TypeDecoder {
    private BoolTypeDecoder _boolTypeDecoder;
    private IntTypeDecoder _intTypeDecoder;
    public virtual object Decode(Byte[] encoded, Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
    private string DecodeString(Byte[] encoded);
}
public class Nethereum.ABI.Decoders.BytesElementaryTypeDecoder : TypeDecoder {
    private int _size;
    public BytesElementaryTypeDecoder(int size);
    public virtual object Decode(Byte[] encoded, Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
}
public class Nethereum.ABI.Decoders.BytesTypeDecoder : TypeDecoder {
    private StringTypeDecoder _stringTypeDecoder;
    public virtual object Decode(Byte[] encoded, Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
}
[ExtensionAttribute]
public static class Nethereum.ABI.Decoders.ByteUtilExtensions : object {
    [ExtensionAttribute]
public static BigInteger ConvertToInt256(Byte[] bytes);
    [ExtensionAttribute]
public static BigInteger ConvertToUInt256(Byte[] bytes);
}
public class Nethereum.ABI.Decoders.DynamicArrayTypeDecoder : ArrayTypeDecoder {
    public DynamicArrayTypeDecoder(ABIType elementType);
    public virtual object Decode(Byte[] encoded, Type type);
}
public interface Nethereum.ABI.Decoders.ICustomRawDecoder`1 {
    public abstract virtual T Decode(Byte[] output);
}
public class Nethereum.ABI.Decoders.IntTypeDecoder : TypeDecoder {
    private bool _signed;
    public IntTypeDecoder(bool signed);
    public virtual object Decode(Byte[] encoded, Type type);
    public BigInteger DecodeBigInteger(string hexString);
    public BigInteger DecodeBigInteger(Byte[] encoded);
    public byte DecodeByte(Byte[] encoded);
    public sbyte DecodeSbyte(Byte[] encoded);
    public short DecodeShort(Byte[] encoded);
    public ushort DecodeUShort(Byte[] encoded);
    public int DecodeInt(Byte[] encoded);
    public long DecodeLong(Byte[] encoded);
    public UInt32 DecodeUInt(Byte[] encoded);
    public ulong DecodeULong(Byte[] encoded);
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
}
public interface Nethereum.ABI.Decoders.ITypeDecoder {
    public abstract virtual object Decode(Byte[] encoded, Type type);
    public abstract virtual T Decode(Byte[] encoded);
    public abstract virtual object Decode(string hexString, Type type);
    public abstract virtual T Decode(string hexString);
    public abstract virtual object DecodePacked(Byte[] encodedElement, Type elementType);
    public abstract virtual T DecodePacked(Byte[] encodedElement);
    public abstract virtual T DecodePacked(string hexString);
    public abstract virtual Type GetDefaultDecodingType();
    public abstract virtual bool IsSupportedType(Type type);
}
public class Nethereum.ABI.Decoders.StringBytes32Decoder : object {
    public sealed virtual string Decode(Byte[] output);
}
public class Nethereum.ABI.Decoders.StringTypeDecoder : TypeDecoder {
    public virtual object Decode(Byte[] encoded, Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
    public string Decode(Byte[] encoded);
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
}
public abstract class Nethereum.ABI.Decoders.TypeDecoder : object {
    public abstract virtual bool IsSupportedType(Type type);
    public abstract virtual object Decode(Byte[] encoded, Type type);
    public abstract virtual object DecodePacked(Byte[] encoded, Type type);
    public sealed virtual T DecodePacked(Byte[] encoded);
    public object DecodePacked(string encoded, Type type);
    public sealed virtual T Decode(Byte[] encoded);
    public sealed virtual object Decode(string encoded, Type type);
    public sealed virtual T Decode(string encoded);
    public abstract virtual Type GetDefaultDecodingType();
    public sealed virtual T DecodePacked(string hexString);
}
public class Nethereum.ABI.DynamicArrayType : ArrayType {
    public string CanonicalName { get; }
    public int FixedSize { get; }
    public DynamicArrayType(string name);
    public virtual string get_CanonicalName();
    public virtual int get_FixedSize();
    public virtual object DecodePackedUsingElementPacked(Byte[] encoded, Type type);
    public virtual Byte[] EncodePackedUsingElementPacked(object value);
}
[StructAttribute("EIP712Domain")]
public class Nethereum.ABI.EIP712.Domain : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BigInteger> <ChainId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifyingContract>k__BackingField;
    [ParameterAttribute("string", "name", "1")]
public string Name { get; public set; }
    [ParameterAttribute("string", "version", "2")]
public string Version { get; public set; }
    [ParameterAttribute("uint256", "chainId", "3")]
public Nullable`1<BigInteger> ChainId { get; public set; }
    [ParameterAttribute("address", "verifyingContract", "4")]
public string VerifyingContract { get; public set; }
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Version();
    [CompilerGeneratedAttribute]
public virtual void set_Version(string value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<BigInteger> get_ChainId();
    [CompilerGeneratedAttribute]
public virtual void set_ChainId(Nullable`1<BigInteger> value);
    [CompilerGeneratedAttribute]
public virtual string get_VerifyingContract();
    [CompilerGeneratedAttribute]
public virtual void set_VerifyingContract(string value);
}
[StructAttribute("EIP712Domain")]
public class Nethereum.ABI.EIP712.DomainWithChainIdAndVerifyingContract : object {
    [CompilerGeneratedAttribute]
private Nullable`1<BigInteger> <ChainId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifyingContract>k__BackingField;
    [ParameterAttribute("uint256", "chainId", "1")]
public Nullable`1<BigInteger> ChainId { get; public set; }
    [ParameterAttribute("address", "verifyingContract", "2")]
public string VerifyingContract { get; public set; }
    [CompilerGeneratedAttribute]
public virtual Nullable`1<BigInteger> get_ChainId();
    [CompilerGeneratedAttribute]
public virtual void set_ChainId(Nullable`1<BigInteger> value);
    [CompilerGeneratedAttribute]
public virtual string get_VerifyingContract();
    [CompilerGeneratedAttribute]
public virtual void set_VerifyingContract(string value);
}
[StructAttribute("EIP712Domain")]
public class Nethereum.ABI.EIP712.DomainWithNameVersionAndChainId : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BigInteger> <ChainId>k__BackingField;
    [ParameterAttribute("string", "name", "1")]
public string Name { get; public set; }
    [ParameterAttribute("string", "version", "2")]
public string Version { get; public set; }
    [ParameterAttribute("uint256", "chainId", "3")]
public Nullable`1<BigInteger> ChainId { get; public set; }
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Version();
    [CompilerGeneratedAttribute]
public virtual void set_Version(string value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<BigInteger> get_ChainId();
    [CompilerGeneratedAttribute]
public virtual void set_ChainId(Nullable`1<BigInteger> value);
}
[StructAttribute("EIP712Domain")]
public class Nethereum.ABI.EIP712.DomainWithSalt : Domain {
    [CompilerGeneratedAttribute]
private Byte[] <Salt>k__BackingField;
    [ParameterAttribute("bytes32", "salt", "5")]
public Byte[] Salt { get; public set; }
    [CompilerGeneratedAttribute]
public virtual Byte[] get_Salt();
    [CompilerGeneratedAttribute]
public virtual void set_Salt(Byte[] value);
}
[StructAttribute("EIP712Domain")]
public class Nethereum.ABI.EIP712.DomainWithVerifyingContract : object {
    [CompilerGeneratedAttribute]
private string <VerifyingContract>k__BackingField;
    [ParameterAttribute("address", "verifyingContract", "1")]
public string VerifyingContract { get; public set; }
    [CompilerGeneratedAttribute]
public virtual string get_VerifyingContract();
    [CompilerGeneratedAttribute]
public virtual void set_VerifyingContract(string value);
}
public static class Nethereum.ABI.EIP712.EIP2612.EIP2612TypeFactory : object {
    public static TypedData`1<Domain> GetTypedDefinition();
}
[StructAttribute("Permit")]
public class Nethereum.ABI.EIP712.EIP2612.Permit : object {
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Spender>k__BackingField;
    [CompilerGeneratedAttribute]
private BigInteger <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private BigInteger <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private BigInteger <Deadline>k__BackingField;
    [ParameterAttribute("address", "owner", "1")]
public string Owner { get; public set; }
    [ParameterAttribute("address", "spender", "2")]
public string Spender { get; public set; }
    [ParameterAttribute("uint256", "value", "3")]
public BigInteger Value { get; public set; }
    [ParameterAttribute("uint256", "nonce", "4")]
public BigInteger Nonce { get; public set; }
    [ParameterAttribute("uint256", "deadline", "5")]
public BigInteger Deadline { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(string value);
    [CompilerGeneratedAttribute]
public string get_Spender();
    [CompilerGeneratedAttribute]
public void set_Spender(string value);
    [CompilerGeneratedAttribute]
public BigInteger get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BigInteger value);
    [CompilerGeneratedAttribute]
public BigInteger get_Nonce();
    [CompilerGeneratedAttribute]
public void set_Nonce(BigInteger value);
    [CompilerGeneratedAttribute]
public BigInteger get_Deadline();
    [CompilerGeneratedAttribute]
public void set_Deadline(BigInteger value);
}
public class Nethereum.ABI.EIP712.Eip712TypedDataEncoder : object {
    private ABIEncode _abiEncode;
    [CompilerGeneratedAttribute]
private static Eip712TypedDataEncoder <Current>k__BackingField;
    private ParametersEncoder _parametersEncoder;
    public static Eip712TypedDataEncoder Current { get; }
    private static Eip712TypedDataEncoder();
    [CompilerGeneratedAttribute]
public static Eip712TypedDataEncoder get_Current();
    public Byte[] EncodeTypedData(T message, TypedData`1<TDomain> typedData);
    public Byte[] EncodeTypedData(T data, TDomain domain, string primaryTypeName);
    public Byte[] EncodeTypedData(string json);
    public Byte[] EncodeTypedData(string json, string messageKeySelector);
    public Byte[] EncodeAndHashTypedData(T message, TypedData`1<TDomain> typedData);
    public Byte[] EncodeAndHashTypedData(TypedData`1<TDomain> typedData);
    public Byte[] EncodeTypedData(TypedData`1<TDomain> typedData);
    public Byte[] EncodeTypedDataRaw(TypedDataRaw typedData);
    public Byte[] HashDomainSeparator(TypedData`1<TDomain> typedData);
    public Byte[] HashStruct(T message, string primaryType, Type[] types);
    public string GetEncodedType(string primaryType, Type[] types);
    public string GetEncodedTypeDomainSeparator(TypedData`1<TDomain> typedData);
    private Byte[] HashStruct(IDictionary`2<string, MemberDescription[]> types, string primaryType, IEnumerable`1<MemberValue> message);
    private static string EncodeType(IDictionary`2<string, MemberDescription[]> types, string typeName);
    private static IList`1<KeyValuePair`2<string, string>> EncodeTypes(IDictionary`2<string, MemberDescription[]> types, string currentTypeName);
    private static string ConvertToElementType(string type);
    internal static bool IsReferenceType(string typeName);
    private void EncodeData(BinaryWriter writer, IDictionary`2<string, MemberDescription[]> types, IEnumerable`1<MemberValue> memberValues);
    public TypedData`1<TDomain> GenerateTypedData(T data, TDomain domain, string primaryTypeName);
}
public interface Nethereum.ABI.EIP712.IDomain {
}
public class Nethereum.ABI.EIP712.Member : object {
    [CompilerGeneratedAttribute]
private MemberDescription <MemberDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberValue <MemberValue>k__BackingField;
    public MemberDescription MemberDescription { get; public set; }
    public MemberValue MemberValue { get; public set; }
    public Member(MemberDescription memberDescription, MemberValue memberValue);
    [CompilerGeneratedAttribute]
public MemberDescription get_MemberDescription();
    [CompilerGeneratedAttribute]
public void set_MemberDescription(MemberDescription value);
    [CompilerGeneratedAttribute]
public MemberValue get_MemberValue();
    [CompilerGeneratedAttribute]
public void set_MemberValue(MemberValue value);
}
public class Nethereum.ABI.EIP712.MemberDescription : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [JsonPropertyAttribute]
public string Name { get; public set; }
    [JsonPropertyAttribute]
public string Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
}
public class Nethereum.ABI.EIP712.MemberDescriptionFactory : object {
    public static Dictionary`2<string, MemberDescription[]> GetTypesMemberDescription(Type[] types);
    public static void AddMemberDescriptionFromTypeToDictionary(Dictionary`2<string, MemberDescription[]> dictionary, Type type);
    private static Parameter[] ExtractParametersFromAttributes(Type contractMessageType);
}
public class Nethereum.ABI.EIP712.MemberValue : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string TypeName { get; public set; }
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class Nethereum.ABI.EIP712.MemberValueFactory : object {
    private static ParametersEncoder _parametersEncoder;
    private static MemberValueFactory();
    public static MemberValue[] CreateFromMessage(T message);
    public static MemberValue[] CreateFromTuple(TupleType tupleType, object value);
    public static MemberValue CreateFromTuple(Parameter structParameter, object value);
}
[JsonObjectAttribute]
public class Nethereum.ABI.EIP712.TypedData`1 : TypedDataRaw {
    [CompilerGeneratedAttribute]
private TDomain <Domain>k__BackingField;
    public TDomain Domain { get; public set; }
    [CompilerGeneratedAttribute]
public TDomain get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(TDomain value);
    public void InitDomainRawValues();
    public void SetMessage(T message);
    public void EnsureDomainRawValuesAreInitialised();
}
[JsonObjectAttribute]
public class Nethereum.ABI.EIP712.TypedDataRaw : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, MemberDescription[]> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrimaryType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberValue[] <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberValue[] <DomainRawValues>k__BackingField;
    [JsonPropertyAttribute]
public IDictionary`2<string, MemberDescription[]> Types { get; public set; }
    [JsonPropertyAttribute]
public string PrimaryType { get; public set; }
    public MemberValue[] Message { get; public set; }
    public MemberValue[] DomainRawValues { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, MemberDescription[]> get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(IDictionary`2<string, MemberDescription[]> value);
    [CompilerGeneratedAttribute]
public string get_PrimaryType();
    [CompilerGeneratedAttribute]
public void set_PrimaryType(string value);
    [CompilerGeneratedAttribute]
public MemberValue[] get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(MemberValue[] value);
    [CompilerGeneratedAttribute]
public MemberValue[] get_DomainRawValues();
    [CompilerGeneratedAttribute]
public void set_DomainRawValues(MemberValue[] value);
}
[ExtensionAttribute]
public static class Nethereum.ABI.EIP712.TypedDataRawJsonConversion : object {
    [ExtensionAttribute]
public static string ToJson(TypedDataRaw typedDataRaw);
    [ExtensionAttribute]
public static string ToJson(TypedData`1<TDomain> typedData);
    [ExtensionAttribute]
public static string ToJson(TypedData`1<TDomain> typedData, TMessage message);
    public static TypedDataRaw DeserialiseJsonToRawTypedData(string json, string messageKeySelector);
    public static TypedDataRaw DeserialiseJsonToRawTypedData(string json);
    public static string SerialiseTypedDataToJson(TypedData`1<TDomain> typedData, TMessage message);
    public static string SerialiseRawTypedDataToJson(TypedDataRaw typedDataRaw);
    private static MemberValue GetMemberValue(string memberType, object memberValue, Dictionary`2<string, MemberDescription[]> typeMemberDescriptions);
    private static Dictionary`2<string, MemberDescription[]> GetMemberDescriptions(IDictionary`2<string, object> types);
    private static List`1<MemberValue> GetMemberValues(IDictionary`2<string, object> deserialisedObject, string typeName, Dictionary`2<string, MemberDescription[]> typeMemberDescriptions);
    private static List`1<JProperty> GetJProperties(string mainTypeName, MemberValue[] values, TypedDataRaw typedDataRaw);
}
public class Nethereum.ABI.EncoderDecoderHelpers : object {
    public static int GetNumberOfBytes(Byte[] encoded);
}
public class Nethereum.ABI.Encoders.AddressTypeEncoder : object {
    private IntTypeEncoder _intTypeEncoder;
    public sealed virtual Byte[] Encode(object value);
    public sealed virtual Byte[] EncodePacked(object value);
}
public abstract class Nethereum.ABI.Encoders.ArrayTypeEncoder : object {
    public sealed virtual Byte[] Encode(object value);
    public sealed virtual Byte[] EncodePacked(object value);
    public abstract virtual Byte[] EncodeList(IList l);
    public abstract virtual Byte[] EncodeListPacked(IList l);
    public abstract virtual Byte[] EncodeListPackedUsingElementPacked(IList l);
}
public class Nethereum.ABI.Encoders.BoolTypeEncoder : object {
    private IntTypeEncoder _intTypeEncoder;
    public sealed virtual Byte[] Encode(object value);
    public sealed virtual Byte[] EncodePacked(object value);
}
public class Nethereum.ABI.Encoders.Bytes32TypeEncoder : object {
    private IntTypeEncoder _intTypeEncoder;
    public sealed virtual Byte[] Encode(object value);
    public sealed virtual Byte[] EncodePacked(object value);
}
public class Nethereum.ABI.Encoders.BytesElementaryTypeEncoder : object {
    private int _size;
    public BytesElementaryTypeEncoder(int size);
    public sealed virtual Byte[] Encode(object value);
    public sealed virtual Byte[] EncodePacked(object value);
    public Byte[] Encode(object value, bool checkEndian);
}
public class Nethereum.ABI.Encoders.BytesTypeEncoder : object {
    private IntTypeEncoder _intTypeEncoder;
    public sealed virtual Byte[] Encode(object value);
    public sealed virtual Byte[] EncodePacked(object value);
    public Byte[] Encode(object value, bool checkEndian);
}
public class Nethereum.ABI.Encoders.DynamicArrayTypeEncoder : ArrayTypeEncoder {
    private ABIType _elementType;
    private IntTypeEncoder _intTypeEncoder;
    public DynamicArrayTypeEncoder(ABIType elementType);
    public virtual Byte[] EncodeList(IList l);
    public virtual Byte[] EncodeListPacked(IList l);
    public virtual Byte[] EncodeListPackedUsingElementPacked(IList l);
}
public class Nethereum.ABI.Encoders.IntTypeEncoder : object {
    private IntTypeDecoder intTypeDecoder;
    private bool _signed;
    private UInt32 _size;
    public IntTypeEncoder(bool signed, UInt32 size);
    public sealed virtual Byte[] Encode(object value);
    public Byte[] Encode(object value, UInt32 numberOfBytesArray);
    public sealed virtual Byte[] EncodePacked(object value);
    public Byte[] EncodeInt(int value);
    public static Byte[] EncodeSignedUnsigned256(BigInteger value, UInt32 numberOfBytesArray);
    public Byte[] EncodeInt(BigInteger value, UInt32 numberOfBytesArray, bool validate, bool overflowToDefault);
    public Byte[] EncodeInt(BigInteger value);
    public void ValidateValue(BigInteger value);
}
public interface Nethereum.ABI.Encoders.ITypeEncoder {
    public abstract virtual Byte[] Encode(object value);
    public abstract virtual Byte[] EncodePacked(object value);
}
public class Nethereum.ABI.Encoders.StaticArrayTypeEncoder : ArrayTypeEncoder {
    private int arraySize;
    private ABIType elementType;
    private IntTypeEncoder intTypeEncoder;
    public StaticArrayTypeEncoder(ABIType elementType, int arraySize);
    public virtual Byte[] EncodeList(IList l);
    public virtual Byte[] EncodeListPacked(IList l);
    public virtual Byte[] EncodeListPackedUsingElementPacked(IList l);
}
public class Nethereum.ABI.Encoders.StringTypeEncoder : object {
    private BytesTypeEncoder byteTypeEncoder;
    public sealed virtual Byte[] Encode(object value);
    public sealed virtual Byte[] EncodePacked(object value);
}
public class Nethereum.ABI.FunctionEncoding.AbiEncodingException : Exception {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private ABIType <ABIType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public int Order { get; }
    public ABIType ABIType { get; }
    public object Value { get; }
    public AbiEncodingException(int order, ABIType abiType, object value, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public ABIType get_ABIType();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public class Nethereum.ABI.FunctionEncoding.AttributeEncoding.ParameterAttributeValue : object {
    [CompilerGeneratedAttribute]
private ParameterAttribute <ParameterAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <PropertyInfo>k__BackingField;
    public ParameterAttribute ParameterAttribute { get; public set; }
    public object Value { get; public set; }
    public PropertyInfo PropertyInfo { get; public set; }
    [CompilerGeneratedAttribute]
public ParameterAttribute get_ParameterAttribute();
    [CompilerGeneratedAttribute]
public void set_ParameterAttribute(ParameterAttribute value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public PropertyInfo get_PropertyInfo();
    [CompilerGeneratedAttribute]
public void set_PropertyInfo(PropertyInfo value);
}
public class Nethereum.ABI.FunctionEncoding.AttributeEncoding.ParameterOutputProperty : ParameterOutput {
    [CompilerGeneratedAttribute]
private PropertyInfo <PropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ParameterOutputProperty> <ChildrenProperties>k__BackingField;
    public PropertyInfo PropertyInfo { get; public set; }
    public List`1<ParameterOutputProperty> ChildrenProperties { get; public set; }
    [CompilerGeneratedAttribute]
public PropertyInfo get_PropertyInfo();
    [CompilerGeneratedAttribute]
public void set_PropertyInfo(PropertyInfo value);
    [CompilerGeneratedAttribute]
public List`1<ParameterOutputProperty> get_ChildrenProperties();
    [CompilerGeneratedAttribute]
public void set_ChildrenProperties(List`1<ParameterOutputProperty> value);
}
public class Nethereum.ABI.FunctionEncoding.Attributes.AttributesToABIExtractor : object {
    public ContractABI ExtractContractABI(Type[] contractMessagesTypes);
    public ErrorABI ExtractErrorABI(Type contractMessageType);
    public FunctionABI ExtractFunctionABI(Type contractMessageType);
    public EventABI ExtractEventABI(Type contractMessageType);
    public Parameter[] ExtractParametersFromAttributes(Type contractMessageType);
    public void InitTupleComponentsFromTypeAttributes(Type type, ABIType abiType);
}
[AttributeUsageAttribute("4")]
public class Nethereum.ABI.FunctionEncoding.Attributes.ErrorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public ErrorAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public static ErrorAttribute GetAttribute();
    public static ErrorAttribute GetAttribute(Type type);
    public static ErrorAttribute GetAttribute(object instance);
    public static bool IsErrorType();
    public static bool IsErrorType(Type type);
    public static bool IsErrorType(object type);
}
public class Nethereum.ABI.FunctionEncoding.Attributes.ErrorDTO : object {
}
[AttributeUsageAttribute("4")]
public class Nethereum.ABI.FunctionEncoding.Attributes.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnonymous>k__BackingField;
    public string Name { get; public set; }
    public bool IsAnonymous { get; public set; }
    public EventAttribute(string name);
    public EventAttribute(string name, bool isAnonymous);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAnonymous();
    [CompilerGeneratedAttribute]
public void set_IsAnonymous(bool value);
    public static EventAttribute GetAttribute();
    public static EventAttribute GetAttribute(Type type);
    public static EventAttribute GetAttribute(object instance);
    public static bool IsEventType();
    public static bool IsEventType(Type type);
    public static bool IsEventType(object type);
}
public class Nethereum.ABI.FunctionEncoding.Attributes.EventDTO : object {
}
[AttributeUsageAttribute("4")]
public class Nethereum.ABI.FunctionEncoding.Attributes.FunctionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DTOReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReturnType>k__BackingField;
    public string Name { get; private set; }
    public Type DTOReturnType { get; private set; }
    public string ReturnType { get; private set; }
    public FunctionAttribute(string name, string returnType);
    public FunctionAttribute(string name);
    public FunctionAttribute(string name, Type dtoReturnType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_DTOReturnType();
    [CompilerGeneratedAttribute]
private void set_DTOReturnType(Type value);
    [CompilerGeneratedAttribute]
public string get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(string value);
    public static FunctionAttribute GetAttribute();
    public static FunctionAttribute GetAttribute(Type type);
    public static FunctionAttribute GetAttribute(object instance);
    public static bool IsFunctionType();
    public static bool IsFunctionType(Type type);
    public static bool IsFunctionType(object type);
}
[AttributeUsageAttribute("4")]
public class Nethereum.ABI.FunctionEncoding.Attributes.FunctionOutputAttribute : Attribute {
    public static FunctionOutputAttribute GetAttribute();
    public static bool IsFunctionType();
}
public class Nethereum.ABI.FunctionEncoding.Attributes.FunctionOutputDTO : object {
}
public interface Nethereum.ABI.FunctionEncoding.Attributes.IErrorDTO {
}
public interface Nethereum.ABI.FunctionEncoding.Attributes.IEventDTO {
}
public interface Nethereum.ABI.FunctionEncoding.Attributes.IFunctionOutputDTO {
}
[AttributeUsageAttribute("128")]
public class Nethereum.ABI.FunctionEncoding.Attributes.ParameterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Parameter <Parameter>k__BackingField;
    public Parameter Parameter { get; }
    public int Order { get; }
    public string Name { get; }
    public string Type { get; }
    public string StructTypeName { get; }
    public ParameterAttribute(string type, string name, int order);
    public ParameterAttribute(string type, string name, int order, bool indexed);
    public ParameterAttribute(string type, string name, int order, string structTypeName);
    public ParameterAttribute(string type, int order);
    [CompilerGeneratedAttribute]
public Parameter get_Parameter();
    public int get_Order();
    public string get_Name();
    public string get_Type();
    public string get_StructTypeName();
}
public class Nethereum.ABI.FunctionEncoding.Attributes.ParameterAttributeIndexedTopics : object {
    [CompilerGeneratedAttribute]
private ParameterAttribute <ParameterAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<object> <Topics>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <PropertyInfo>k__BackingField;
    public ParameterAttribute ParameterAttribute { get; public set; }
    public List`1<object> Topics { get; public set; }
    public PropertyInfo PropertyInfo { get; public set; }
    [CompilerGeneratedAttribute]
public ParameterAttribute get_ParameterAttribute();
    [CompilerGeneratedAttribute]
public void set_ParameterAttribute(ParameterAttribute value);
    [CompilerGeneratedAttribute]
public List`1<object> get_Topics();
    [CompilerGeneratedAttribute]
public void set_Topics(List`1<object> value);
    [CompilerGeneratedAttribute]
public PropertyInfo get_PropertyInfo();
    [CompilerGeneratedAttribute]
public void set_PropertyInfo(PropertyInfo value);
    public Object[] GetTopicValues();
}
public static class Nethereum.ABI.FunctionEncoding.Attributes.ParameterIndexedTopicExtractor : object {
    public static List`1<ParameterAttributeIndexedTopics> GetParameterIndexedTopics(Type type, object instanceValue);
}
public static class Nethereum.ABI.FunctionEncoding.Attributes.PropertiesExtractor : object {
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static IEnumerable`1<PropertyInfo> GetPropertiesWithParameterAttribute(Type type);
    public static ParameterAttributeIndexedTopics[] GetIndexedTopics();
}
[AttributeUsageAttribute("4")]
public class Nethereum.ABI.FunctionEncoding.Attributes.StructAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public StructAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public static StructAttribute GetAttribute();
    public static StructAttribute GetAttribute(Type type);
    public static StructAttribute GetAttribute(object instance);
    public static bool IsStructType();
    public static bool IsStructType(Type type);
    public static bool IsStructType(object type);
}
public class Nethereum.ABI.FunctionEncoding.ByteCodeLibrary : object {
    [CompilerGeneratedAttribute]
private string <PlaceholderKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ByteCode>k__BackingField;
    public string PlaceholderKey { get; public set; }
    public string Address { get; public set; }
    public string LibraryName { get; public set; }
    public string Path { get; public set; }
    public string ByteCode { get; public set; }
    public static ByteCodeLibrary CreateFromPath(string path, string libraryName, string libraryAddress);
    [CompilerGeneratedAttribute]
public string get_PlaceholderKey();
    [CompilerGeneratedAttribute]
public void set_PlaceholderKey(string value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public void set_LibraryName(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_ByteCode();
    [CompilerGeneratedAttribute]
public void set_ByteCode(string value);
    public void CalculatePlaceHolderKey();
}
public class Nethereum.ABI.FunctionEncoding.ByteCodeLibraryLinker : object {
    public static string CONTAINS_PLACEHOLDERS_MESSAGE;
    private static ByteCodeLibraryLinker();
    public static void EnsureDoesNotContainPlaceholders(string byteCode);
    public static bool ContainsPlaceholders(string byteCode);
    private static string CreatePlaceholder(string key);
    public static string LinkByteCode(string byteCode, ByteCodeLibrary[] byteCodeLibraries);
}
public class Nethereum.ABI.FunctionEncoding.ByteCodeSwarmExtractor : object {
    public static string bzzr0_Hex;
    public static string Prefix_bzzr0_Hex;
    public static string Suffix_bzzr0_Hex;
    public static string Prefix_Address_Hex;
    public static string Suffix_Address_Hex;
    public string GetSwarmAddress(string byteCode);
    private string GetSwarmPaddedString(string byteCode);
    public string GetByteCodeIncludingSwarmAddressPart(string byteCode);
    public string GetByteCodeExludingSwarmAddressPart(string byteCode);
    public bool HasSwarmAddress(string byteCode);
}
public class Nethereum.ABI.FunctionEncoding.ConstructorCallDecoder : ParameterDecoder {
    public T DecodeConstructorParameters(T deploymentObject, string data);
    public T DecodeConstructorParameters(string data);
    public T DecodeConstructorParameters(string deploymentByteCode, string data);
    public T DecodeConstructorParameters(T deploymentObject, string deploymentByteCode, string data);
}
public class Nethereum.ABI.FunctionEncoding.ConstructorCallEncoder : ParametersEncoder {
    public string EncodeRequest(T constructorInput, string contractByteCode);
    public string EncodeRequest(string contractByteCode, Parameter[] parameters, Object[] values);
    public string EncodeRequest(string contractByteCode, string encodedParameters);
}
public class Nethereum.ABI.FunctionEncoding.DecodedValue : object {
    [CompilerGeneratedAttribute]
private string <AbiName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AbiType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string AbiName { get; public set; }
    public string AbiType { get; public set; }
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AbiName();
    [CompilerGeneratedAttribute]
public void set_AbiName(string value);
    [CompilerGeneratedAttribute]
public string get_AbiType();
    [CompilerGeneratedAttribute]
public void set_AbiType(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
[FunctionAttribute("Error")]
public class Nethereum.ABI.FunctionEncoding.ErrorFunction : object {
    public static string ERROR_FUNCTION_ID;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [ParameterAttribute("string", "", "1")]
public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public static bool IsErrorData(string dataHex);
}
public class Nethereum.ABI.FunctionEncoding.EventTopicDecoder : ParameterDecoder {
    private bool _isAnonymousEvent;
    public EventTopicDecoder(bool isAnonymousEvent);
    public T DecodeTopics(Object[] topics, string data);
    public List`1<ParameterOutput> DecodeDefaultTopics(EventABI eventABI, Object[] topics, string data);
    public List`1<ParameterOutput> DecodeDefaultTopics(Parameter[] inputParameters, Object[] topics, string data);
    public T DecodeTopics(T eventDTO, Object[] topics, string data);
}
public class Nethereum.ABI.FunctionEncoding.FunctionCallDecoder : ParameterDecoder {
    public bool IsDataForFunction(FunctionABI functionABI, string data);
    public bool IsDataForError(ErrorABI errorABI, string data);
    public List`1<ParameterOutput> DecodeInput(FunctionABI functionABI, string data);
    public List`1<ParameterOutput> DecodeError(ErrorABI errorABI, string data);
    public object DecodeError(Type errorType, string data);
    public List`1<ParameterOutput> DecodeFunctionInput(string sha3Signature, string data, Parameter[] parameters);
    public T DecodeFunctionInput(string sha3Signature, string data);
    public T DecodeFunctionInput(T functionInput, string sha3Signature, string data);
    public TError DecodeFunctionCustomError(TError error, string signature, string encodedErrorData);
    public ErrorFunction DecodeFunctionError(string output);
    public string DecodeFunctionErrorMessage(string output);
    public void ThrowIfErrorOnOutput(string output, Exception innerException);
    public T DecodeFunctionOutput(string output);
    public T DecodeFunctionOutput(T functionOutputResult, string output);
    public T DecodeOutput(string output, Parameter[] outputParameter);
    public T DecodeSimpleTypeOutput(Parameter outputParameter, string output);
}
public class Nethereum.ABI.FunctionEncoding.FunctionCallEncoder : ParametersEncoder {
    public string EncodeRequest(object functionInput, Type functionInputType, string sha3Signature);
    public string EncodeRequest(T functionInput, string sha3Signature);
    public string EncodeRequest(string sha3Signature, Parameter[] parameters, Object[] values);
    public string EncodeRequest(string sha3Signature, string encodedParameters);
    public string EncodeRequest(string sha3Signature);
}
[ExtensionAttribute]
public static class Nethereum.ABI.FunctionEncoding.JsonParameterObjectConvertor : object {
    [ExtensionAttribute]
public static Object[] ConvertToFunctionInputParameterValues(JToken jObject, FunctionABI function);
    [ExtensionAttribute]
public static Object[] ConvertToFunctionInputParameterValues(JToken jObject, Parameter[] parameters);
    private static void AddJTokenValueInputParameters(List`1<object> inputParameters, ABIType abiType, JToken jToken);
}
public class Nethereum.ABI.FunctionEncoding.ParameterDecoder : object {
    private AttributesToABIExtractor attributesToABIExtractor;
    public object DecodeAttributes(Byte[] output, Type objectType);
    public object DecodeAttributes(string output, Type objectType);
    public object DecodeAttributes(Byte[] output, object result, PropertyInfo[] properties);
    public object DecodeAttributes(string output, object result, PropertyInfo[] properties);
    public T DecodeAttributes(string output, T result, PropertyInfo[] properties);
    public void AssingValuesFromPropertyList(object instance, ParameterOutputProperty result);
    public List`1<ParameterOutputProperty> GetParameterOutputsFromAttributes(PropertyInfo[] properties);
    private void InitTupleElementFromArray(PropertyInfo property, ParameterAttribute parameterAttribute, ArrayType arrayType, int depth);
    private Type GetListElementType(Type startType, int depthOfLists);
    public List`1<ParameterOutputProperty> GetParameterOutputsFromAttributes(Type type);
    public List`1<ParameterOutput> DecodeDefaultData(Byte[] data, Parameter[] inputParameters);
    public List`1<ParameterOutput> DecodeDefaultData(string data, Parameter[] inputParameters);
    public List`1<ParameterOutput> DecodeOutput(Byte[] outputBytes, ParameterOutput[] outputParameters);
    public List`1<ParameterOutput> DecodeOutput(string output, ParameterOutput[] outputParameters);
    protected void InitTupleElementComponents(Type type, TupleType tupleType);
}
[ExtensionAttribute]
public static class Nethereum.ABI.FunctionEncoding.ParameterExtensions : object {
    [ExtensionAttribute]
public static string GetParameterNameUsingDefaultIfNotSet(Parameter parameter);
}
public class Nethereum.ABI.FunctionEncoding.ParameterOutput : object {
    [CompilerGeneratedAttribute]
private Parameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataIndexStart>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    public Parameter Parameter { get; public set; }
    public int DataIndexStart { get; public set; }
    public object Result { get; public set; }
    [CompilerGeneratedAttribute]
public Parameter get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(Parameter value);
    [CompilerGeneratedAttribute]
public int get_DataIndexStart();
    [CompilerGeneratedAttribute]
public void set_DataIndexStart(int value);
    [CompilerGeneratedAttribute]
public object get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(object value);
}
[ExtensionAttribute]
public static class Nethereum.ABI.FunctionEncoding.ParameterOutputExtensions : object {
    [ExtensionAttribute]
public static string ConvertToString(IEnumerable`1<ParameterOutput> parameterOutputs, int level);
    private static string ConvertArrayToString(IEnumerable item, int level);
    private static void AppendLevel(StringBuilder builder, string name, object value, int level);
    private static void AppendObjectTitle(StringBuilder builder, string name, int level);
    [ExtensionAttribute]
public static Dictionary`2<string, object> ConvertToObjectDictionary(IEnumerable`1<ParameterOutput> parameterOutputs);
    private static List`1<object> ConvertArrayToObjectDictionary(IEnumerable item);
    [ExtensionAttribute]
public static Dictionary`2<string, object> ConvertToDynamicDictionary(IEnumerable`1<ParameterOutput> parameterOutputs);
    private static List`1<object> ConvertArrayToDynamicDictionary(IEnumerable item);
    [ExtensionAttribute]
public static JObject ConvertToJObject(IEnumerable`1<ParameterOutput> parameterOutputs);
    private static JArray ConvertToJArray(IEnumerable item);
}
public class Nethereum.ABI.FunctionEncoding.ParametersEncoder : object {
    private IntTypeEncoder intTypeEncoder;
    private AttributesToABIExtractor attributesToABIExtractor;
    public Byte[] EncodeAbiTypes(ABIType[] abiTypes, Object[] values);
    public Byte[] EncodeParameters(Parameter[] parameters, Object[] values);
    public Byte[] EncodeParametersFromTypeAttributes(Type type, object instanceValue);
    public Object[] GetValuesInOrder(List`1<ParameterAttributeValue> parameterObjects);
    public Parameter[] GetParametersInOrder(List`1<ParameterAttributeValue> parameterObjects);
    public List`1<ParameterAttributeValue> GetParameterAttributeValues(Type type, object instanceValue);
    public Object[] GetTupleComponentValuesFromTypeAttributes(Type type, object instanceValue);
}
[ExtensionAttribute]
public static class Nethereum.ABI.FunctionEncoding.PropertyInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsHidingMember(PropertyInfo self);
}
public class Nethereum.ABI.FunctionEncoding.SerpentSignatureEncoder : SignatureEncoder {
    public virtual string GenerateSignature(string name, Parameter[] parameters);
}
public class Nethereum.ABI.FunctionEncoding.SignatureEncoder : object {
    private Sha3Keccack sha3Keccack;
    public static string ConvertToStringKey(string signature);
    public static bool IsDataForSignature(string sha3Signature, string data);
    public static bool AreSignaturesTheSame(string sha3Signature, string otherSignature);
    public static bool ValiSignatureLengthFunction(string sha3Signature);
    public static string GetSignatureFromData(string data);
    public static bool ValiInputDataSignature(string data);
    public string GenerateSha3Signature(string name, Parameter[] parameters);
    public string GenerateSha3Signature(string name, Parameter[] parameters, int numberOfFirstBytes);
    public virtual string GenerateSignature(string name, Parameter[] parameters);
    public virtual string GenerateParametersSignature(Parameter[] parameters);
    public virtual string GenerateParameteSignature(Parameter parameter);
}
public class Nethereum.ABI.FunctionEncoding.SmartContractRevertException : Exception {
    private static string ERROR_PREFIX;
    [CompilerGeneratedAttribute]
private string <RevertMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncodedData>k__BackingField;
    public string RevertMessage { get; public set; }
    public string EncodedData { get; public set; }
    public SmartContractRevertException(string message, string encodedData, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_RevertMessage();
    [CompilerGeneratedAttribute]
public void set_RevertMessage(string value);
    [CompilerGeneratedAttribute]
public string get_EncodedData();
    [CompilerGeneratedAttribute]
public void set_EncodedData(string value);
}
public class Nethereum.ABI.IntType : ABIType {
    public static BigInteger MAX_INT256_VALUE;
    public static BigInteger MIN_INT256_VALUE;
    public static BigInteger MAX_UINT256_VALUE;
    public static BigInteger MIN_UINT_VALUE;
    [CompilerGeneratedAttribute]
private int <StaticSize>k__BackingField;
    public int StaticSize { get; }
    public string CanonicalName { get; }
    public IntType(string name);
    private static IntType();
    [CompilerGeneratedAttribute]
public virtual int get_StaticSize();
    public virtual string get_CanonicalName();
    private static bool IsSigned(string name);
    public static BigInteger GetMaxSignedValue(UInt32 size);
    public static BigInteger GetMinSignedValue(UInt32 size);
    public static BigInteger GetMaxUnSignedValue(UInt32 size);
    private static void CheckIsValidAndThrow(UInt32 size);
    public static bool IsValidSize(UInt32 size);
    private static UInt32 GetSize(string name);
}
public class Nethereum.ABI.Model.ConstructorABI : object {
    [CompilerGeneratedAttribute]
private Parameter[] <InputParameters>k__BackingField;
    public Parameter[] InputParameters { get; public set; }
    [CompilerGeneratedAttribute]
public Parameter[] get_InputParameters();
    [CompilerGeneratedAttribute]
public void set_InputParameters(Parameter[] value);
}
public class Nethereum.ABI.Model.ContractABI : object {
    [CompilerGeneratedAttribute]
private FunctionABI[] <Functions>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorABI <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private EventABI[] <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorABI[] <Errors>k__BackingField;
    public FunctionABI[] Functions { get; public set; }
    public ConstructorABI Constructor { get; public set; }
    public EventABI[] Events { get; public set; }
    public ErrorABI[] Errors { get; public set; }
    [CompilerGeneratedAttribute]
public FunctionABI[] get_Functions();
    [CompilerGeneratedAttribute]
public void set_Functions(FunctionABI[] value);
    [CompilerGeneratedAttribute]
public ConstructorABI get_Constructor();
    [CompilerGeneratedAttribute]
public void set_Constructor(ConstructorABI value);
    [CompilerGeneratedAttribute]
public EventABI[] get_Events();
    [CompilerGeneratedAttribute]
public void set_Events(EventABI[] value);
    [CompilerGeneratedAttribute]
public ErrorABI[] get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(ErrorABI[] value);
}
public class Nethereum.ABI.Model.ErrorABI : object {
    private SignatureEncoder signatureEncoder;
    private string sha3Signature;
    private string signature;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Parameter[] <InputParameters>k__BackingField;
    public string Name { get; }
    public Parameter[] InputParameters { get; public set; }
    public string Sha3Signature { get; }
    public string Signature { get; }
    public ErrorABI(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Parameter[] get_InputParameters();
    [CompilerGeneratedAttribute]
public void set_InputParameters(Parameter[] value);
    public string get_Sha3Signature();
    public string get_Signature();
}
public class Nethereum.ABI.Model.EventABI : object {
    private SignatureEncoder signatureEncoder;
    private string sha3Signature;
    private string signature;
    private Nullable`1<int> numberOfIndexes;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnonymous>k__BackingField;
    [CompilerGeneratedAttribute]
private Parameter[] <InputParameters>k__BackingField;
    public string Name { get; }
    public bool IsAnonymous { get; public set; }
    public Parameter[] InputParameters { get; public set; }
    public string Sha3Signature { get; }
    public string Signature { get; }
    public int NumberOfIndexes { get; }
    public EventABI(string name);
    public EventABI(string name, bool isAnonymous);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IsAnonymous();
    [CompilerGeneratedAttribute]
public void set_IsAnonymous(bool value);
    [CompilerGeneratedAttribute]
public Parameter[] get_InputParameters();
    [CompilerGeneratedAttribute]
public void set_InputParameters(Parameter[] value);
    public string get_Sha3Signature();
    public string get_Signature();
    public int get_NumberOfIndexes();
}
public class Nethereum.ABI.Model.FunctionABI : object {
    private SignatureEncoder signatureEncoder;
    private string sha3Signature;
    private string signature;
    [CompilerGeneratedAttribute]
private bool <Serpent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Constant>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Parameter[] <InputParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Parameter[] <OutputParameters>k__BackingField;
    public bool Serpent { get; private set; }
    public bool Constant { get; private set; }
    public string Name { get; }
    public Parameter[] InputParameters { get; public set; }
    public Parameter[] OutputParameters { get; public set; }
    public string Sha3Signature { get; }
    public string Signature { get; }
    public FunctionABI(string name, bool constant, bool serpent);
    [CompilerGeneratedAttribute]
public bool get_Serpent();
    [CompilerGeneratedAttribute]
private void set_Serpent(bool value);
    [CompilerGeneratedAttribute]
public bool get_Constant();
    [CompilerGeneratedAttribute]
private void set_Constant(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Parameter[] get_InputParameters();
    [CompilerGeneratedAttribute]
public void set_InputParameters(Parameter[] value);
    [CompilerGeneratedAttribute]
public Parameter[] get_OutputParameters();
    [CompilerGeneratedAttribute]
public void set_OutputParameters(Parameter[] value);
    public string get_Sha3Signature();
    public string get_Signature();
}
public interface Nethereum.ABI.Model.IGetErrorAbi {
    public abstract virtual ErrorABI GetErrorAbi();
    public abstract virtual void SetValue(string parameterName, object value);
    public abstract virtual object GetValue(string parameterName);
}
public interface Nethereum.ABI.Model.IGetEventAbi {
    public abstract virtual EventABI GetEventAbi();
    public abstract virtual void SetValue(string parameterName, object value);
    public abstract virtual object GetValue(string parameterName);
}
public interface Nethereum.ABI.Model.IGetFunctionAbi {
    public abstract virtual FunctionABI GetFunctionAbi();
    public abstract virtual void SetValue(string parameterName, object value);
    public abstract virtual object GetValue(string parameterName);
}
public interface Nethereum.ABI.Model.IGetParametersAbi {
    public abstract virtual List`1<Parameter> GetParameters();
    public abstract virtual void SetValue(string parameterName, object value);
    public abstract virtual object GetValue(string parameterName);
}
[ExtensionAttribute]
public static class Nethereum.ABI.Model.ModelExtensions : object {
    [ExtensionAttribute]
public static FunctionABI FindFunctionABI(ContractABI contractABI, string signature);
    [ExtensionAttribute]
public static bool HasTheSameSignatureValues(FunctionABI first, FunctionABI other);
    [ExtensionAttribute]
public static bool HasTheSameSignatureValues(EventABI first, EventABI other);
    [ExtensionAttribute]
public static bool HasTheSameSignatureValues(ErrorABI first, ErrorABI other);
    [ExtensionAttribute]
public static bool AreTheSameSignatureValues(IEnumerable`1<Parameter> first, IEnumerable`1<Parameter> other);
    [ExtensionAttribute]
public static bool HasTheSameSignatureValues(Parameter parameter, Parameter other);
    [ExtensionAttribute]
public static FunctionABI FindFunctionABIFromInputData(ContractABI contractABI, string inputData);
    [ExtensionAttribute]
public static List`1<ParameterOutput> DecodeInputDataToDefault(FunctionABI functionABI, string inputData);
    [ExtensionAttribute]
public static List`1<ParameterOutput> DecodeOutputDataToDefault(FunctionABI functionABI, string outputData);
    [ExtensionAttribute]
public static JObject DecodeOutputToJObject(FunctionABI functionABI, string data);
    [ExtensionAttribute]
public static List`1<ParameterOutput> DecodeErrorDataToDefault(ErrorABI errorABI, string data);
    [ExtensionAttribute]
public static JObject DecodeErrorDataToDefaultToJObject(ErrorABI errorABI, string data);
    [ExtensionAttribute]
public static object DecodeErrorData(Type type, string data);
    [ExtensionAttribute]
public static JObject DecodeInputToJObject(FunctionABI functionABI, string inputData);
    [ExtensionAttribute]
public static EventABI FindEventABI(ContractABI contractABI, string signature);
    [ExtensionAttribute]
public static ErrorABI FindErrorABI(ContractABI contractABI, string signature);
    [ExtensionAttribute]
public static bool IsDataForFunction(FunctionABI functionABI, string data);
    [ExtensionAttribute]
public static bool IsSignatureForFunction(FunctionABI functionABI, string sha3Signature);
    [ExtensionAttribute]
public static bool IsSignatureForEvent(EventABI eventABI, string sha3Signature);
    [ExtensionAttribute]
public static bool IsSignatureForError(ErrorABI errorABI, string sha3Signature);
}
public class Nethereum.ABI.Model.Parameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ABIType <ABIType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DecodedType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Indexed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerpentSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StructTypeName>k__BackingField;
    public string Name { get; private set; }
    public string Type { get; private set; }
    public ABIType ABIType { get; private set; }
    public int Order { get; private set; }
    public string InternalType { get; private set; }
    public Type DecodedType { get; public set; }
    public bool Indexed { get; public set; }
    public string SerpentSignature { get; private set; }
    public string StructTypeName { get; public set; }
    public Parameter(string type, string name, int order, string internalType, string serpentSignature);
    public Parameter(string type, int order, string internalType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public ABIType get_ABIType();
    [CompilerGeneratedAttribute]
private void set_ABIType(ABIType value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
private void set_Order(int value);
    [CompilerGeneratedAttribute]
public string get_InternalType();
    [CompilerGeneratedAttribute]
private void set_InternalType(string value);
    [CompilerGeneratedAttribute]
public Type get_DecodedType();
    [CompilerGeneratedAttribute]
public void set_DecodedType(Type value);
    [CompilerGeneratedAttribute]
public bool get_Indexed();
    [CompilerGeneratedAttribute]
public void set_Indexed(bool value);
    [CompilerGeneratedAttribute]
public string get_SerpentSignature();
    [CompilerGeneratedAttribute]
private void set_SerpentSignature(string value);
    [CompilerGeneratedAttribute]
public string get_StructTypeName();
    [CompilerGeneratedAttribute]
public void set_StructTypeName(string value);
}
public class Nethereum.ABI.StaticArrayType : ArrayType {
    internal int Size;
    public string CanonicalName { get; }
    public int FixedSize { get; }
    public StaticArrayType(string name);
    public virtual string get_CanonicalName();
    public virtual int get_FixedSize();
    public virtual object DecodePackedUsingElementPacked(Byte[] encoded, Type type);
    public virtual Byte[] EncodePackedUsingElementPacked(object value);
    private void IntialiseSize(string name);
}
public class Nethereum.ABI.StringType : ABIType {
    public int FixedSize { get; }
    public virtual int get_FixedSize();
}
public class Nethereum.ABI.TupleType : ABIType {
    [CompilerGeneratedAttribute]
private Parameter[] <Components>k__BackingField;
    public Parameter[] Components { get; protected set; }
    public int FixedSize { get; }
    [CompilerGeneratedAttribute]
public Parameter[] get_Components();
    [CompilerGeneratedAttribute]
protected void set_Components(Parameter[] value);
    public void SetComponents(Parameter[] components);
    public T DecodeComplexType(string encoded);
    public T DecodeComplexType(Byte[] encoded);
    public virtual int get_FixedSize();
}
public class Nethereum.ABI.TupleTypeDecoder : TypeDecoder {
    private ParameterDecoder parameterDecoder;
    [CompilerGeneratedAttribute]
private Parameter[] <Components>k__BackingField;
    public Parameter[] Components { get; public set; }
    [CompilerGeneratedAttribute]
public Parameter[] get_Components();
    [CompilerGeneratedAttribute]
public void set_Components(Parameter[] value);
    public virtual object Decode(Byte[] encoded, Type type);
    public T DecodeComplexType(Byte[] encoded);
    public ParameterOutput[] InitDefaultDecodingComponents();
    public virtual Type GetDefaultDecodingType();
    public virtual bool IsSupportedType(Type type);
    public virtual object DecodePacked(Byte[] encoded, Type type);
}
public class Nethereum.ABI.TupleTypeEncoder : object {
    private ParametersEncoder parametersEncoder;
    [CompilerGeneratedAttribute]
private Parameter[] <Components>k__BackingField;
    public Parameter[] Components { get; public set; }
    [CompilerGeneratedAttribute]
public Parameter[] get_Components();
    [CompilerGeneratedAttribute]
public void set_Components(Parameter[] value);
    public sealed virtual Byte[] Encode(object value);
    public sealed virtual Byte[] EncodePacked(object value);
}
[ExtensionAttribute]
public static class Nethereum.ABI.Util.NumberExtensions : object {
    [ExtensionAttribute]
public static bool IsNumber(object value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
