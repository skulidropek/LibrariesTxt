[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public bool IsInvalid { get; }
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle : SafeBuffer {
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafePipeHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public bool IsInvalid { get; }
    public SafePipeHandle(IntPtr preexistingHandle, bool ownsHandle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public bool IsInvalid { get; }
    public SafeProcessHandle(IntPtr existingHandle, bool ownsHandle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
public class System.AccessViolationException : SystemException {
    protected AccessViolationException(SerializationInfo info, StreamingContext context);
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`10 : MulticastDelegate {
    public Action`10(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`11 : MulticastDelegate {
    public Action`11(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`12 : MulticastDelegate {
    public Action`12(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`13 : MulticastDelegate {
    public Action`13(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`14 : MulticastDelegate {
    public Action`14(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`15 : MulticastDelegate {
    public Action`15(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`16 : MulticastDelegate {
    public Action`16(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`5 : MulticastDelegate {
    public Action`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`6 : MulticastDelegate {
    public Action`6(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`7 : MulticastDelegate {
    public Action`7(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`8 : MulticastDelegate {
    public Action`8(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`9 : MulticastDelegate {
    public Action`9(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Activator : object {
    public static object CreateInstance(Type type);
    public static object CreateInstance(Type type, bool nonPublic);
    public static object CreateInstance(Type type, Object[] args);
    public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static T CreateInstance();
}
public class System.AggregateException : Exception {
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    public AggregateException(string message);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception innerException);
    public AggregateException(string message, Exception[] innerExceptions);
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public virtual string get_Message();
    public AggregateException Flatten();
    public virtual Exception GetBaseException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void Handle(Func`2<Exception, bool> predicate);
    public virtual string ToString();
}
public static class System.AppContext : object {
    public static string BaseDirectory { get; }
    public static string TargetFrameworkName { get; }
    public static string get_BaseDirectory();
    public static string get_TargetFrameworkName();
    public static object GetData(string name);
    public static void SetSwitch(string switchName, bool isEnabled);
    public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
}
public class System.AppDomain : MarshalByRefObject {
    public string BaseDirectory { get; }
    public static AppDomain CurrentDomain { get; }
    public string DynamicDirectory { get; }
    public string FriendlyName { get; }
    public int Id { get; }
    public bool IsFullyTrusted { get; }
    public bool IsHomogenous { get; }
    public static bool MonitoringIsEnabled { get; public set; }
    public long MonitoringSurvivedMemorySize { get; }
    public static long MonitoringSurvivedProcessMemorySize { get; }
    public long MonitoringTotalAllocatedMemorySize { get; }
    public TimeSpan MonitoringTotalProcessorTime { get; }
    public string RelativeSearchPath { get; }
    public bool ShadowCopyFiles { get; }
    public string get_BaseDirectory();
    public static AppDomain get_CurrentDomain();
    public string get_DynamicDirectory();
    public string get_FriendlyName();
    public int get_Id();
    public bool get_IsFullyTrusted();
    public bool get_IsHomogenous();
    public static bool get_MonitoringIsEnabled();
    public static void set_MonitoringIsEnabled(bool value);
    public long get_MonitoringSurvivedMemorySize();
    public static long get_MonitoringSurvivedProcessMemorySize();
    public long get_MonitoringTotalAllocatedMemorySize();
    public TimeSpan get_MonitoringTotalProcessorTime();
    public string get_RelativeSearchPath();
    public bool get_ShadowCopyFiles();
    public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public void add_AssemblyResolve(ResolveEventHandler value);
    public void remove_AssemblyResolve(ResolveEventHandler value);
    public void add_DomainUnload(EventHandler value);
    public void remove_DomainUnload(EventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void add_ProcessExit(EventHandler value);
    public void remove_ProcessExit(EventHandler value);
    public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    public void add_ResourceResolve(ResolveEventHandler value);
    public void remove_ResourceResolve(ResolveEventHandler value);
    public void add_TypeResolve(ResolveEventHandler value);
    public void remove_TypeResolve(ResolveEventHandler value);
    public void add_UnhandledException(UnhandledExceptionEventHandler value);
    public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void AppendPrivatePath(string path);
    public string ApplyPolicy(string assemblyName);
    [ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearPrivatePath();
    [ObsoleteAttribute("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearShadowCopyPath();
    public static AppDomain CreateDomain(string friendlyName);
    public int ExecuteAssembly(string assemblyFile);
    public int ExecuteAssembly(string assemblyFile, String[] args);
    public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    public int ExecuteAssemblyByName(string assemblyName);
    public int ExecuteAssemblyByName(string assemblyName, String[] args);
    public Assembly[] GetAssemblies();
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", "False")]
public static int GetCurrentThreadId();
    public object GetData(string name);
    public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    public bool IsDefaultAppDomain();
    public bool IsFinalizingForUnload();
    public Assembly Load(Byte[] rawAssembly);
    public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public Assembly Load(AssemblyName assemblyRef);
    public Assembly Load(string assemblyString);
    public Assembly[] ReflectionOnlyGetAssemblies();
    [ObsoleteAttribute("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void SetCachePath(string path);
    public void SetData(string name, object data);
    [ObsoleteAttribute("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void SetDynamicBase(string path);
    public void SetPrincipalPolicy(PrincipalPolicy policy);
    [ObsoleteAttribute("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyPath(string path);
    public void SetThreadPrincipal(IPrincipal principal);
    public virtual string ToString();
    public static void Unload(AppDomain domain);
}
public class System.AppDomainUnloadedException : SystemException {
    protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
    public AppDomainUnloadedException(string message);
    public AppDomainUnloadedException(string message, Exception innerException);
}
public class System.ApplicationException : Exception {
    protected ApplicationException(SerializationInfo info, StreamingContext context);
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
}
public class System.ApplicationId : object {
    public string Culture { get; }
    public string Name { get; }
    public string ProcessorArchitecture { get; }
    public Byte[] PublicKeyToken { get; }
    public Version Version { get; }
    public ApplicationId(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
    public string get_Culture();
    public string get_Name();
    public string get_ProcessorArchitecture();
    public Byte[] get_PublicKeyToken();
    public Version get_Version();
    public ApplicationId Copy();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.ArgumentException : SystemException {
    public string Message { get; }
    public string ParamName { get; }
    protected ArgumentException(SerializationInfo info, StreamingContext context);
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName);
    public ArgumentException(string message, string paramName, Exception innerException);
    public virtual string get_Message();
    public virtual string get_ParamName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ArgumentNullException : ArgumentException {
    protected ArgumentNullException(SerializationInfo info, StreamingContext context);
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
}
public class System.ArgumentOutOfRangeException : ArgumentException {
    public object ActualValue { get; }
    public string Message { get; }
    protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public ArgumentOutOfRangeException(string paramName, string message);
    public virtual object get_ActualValue();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ArithmeticException : SystemException {
    protected ArithmeticException(SerializationInfo info, StreamingContext context);
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
}
public abstract class System.Array : object {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public int Length { get; }
    public long LongLength { get; }
    public int Rank { get; }
    public object SyncRoot { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public int get_Length();
    public long get_LongLength();
    public int get_Rank();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    public static int BinarySearch(Array array, int index, int length, object value);
    public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static void Clear(Array array, int index, int length);
    public sealed virtual object Clone();
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Array array, long index);
    public static Array CreateInstance(Type elementType, int length);
    public static Array CreateInstance(Type elementType, int length1, int length2);
    public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    public static Array CreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static T[] Empty();
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static T Find(T[] array, Predicate`1<T> match);
    public static void ForEach(T[] array, Action`1<T> action);
    public sealed virtual IEnumerator GetEnumerator();
    public int GetLength(int dimension);
    public long GetLongLength(int dimension);
    public int GetLowerBound(int dimension);
    public int GetUpperBound(int dimension);
    public object GetValue(int index);
    public object GetValue(int index1, int index2);
    public object GetValue(int index1, int index2, int index3);
    public object GetValue(Int32[] indices);
    public object GetValue(long index);
    public object GetValue(long index1, long index2);
    public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    public void Initialize();
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    public static void Resize(T[]& array, int newSize);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    public void SetValue(object value, int index);
    public void SetValue(object value, int index1, int index2);
    public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, Int32[] indices);
    public void SetValue(object value, long index);
    public void SetValue(object value, long index1, long index2);
    public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    public static void Sort(Array array);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort(T[] array);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static void Sort(T[] array, int index, int length);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(TKey[] keys, TValue[] items);
    public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.ArraySegment`1 : ValueType {
    private T[] _array;
    private object _dummy;
    private int _dummyPrimitive;
    public T[] Array { get; }
    public int Count { get; }
    public static ArraySegment`1<T> Empty { get; }
    public T Item { get; public set; }
    public int Offset { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    public T[] get_Array();
    public sealed virtual int get_Count();
    public static ArraySegment`1<T> get_Empty();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Offset();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    public void CopyTo(ArraySegment`1<T> destination);
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public bool Equals(ArraySegment`1<T> obj);
    public virtual bool Equals(object obj);
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T[] ToArray();
}
public class System.ArrayTypeMismatchException : SystemException {
    protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
}
public class System.AssemblyLoadEventArgs : EventArgs {
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    public virtual bool Match(object obj);
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets All;
    public static AttributeTargets Assembly;
    public static AttributeTargets Class;
    public static AttributeTargets Constructor;
    public static AttributeTargets Delegate;
    public static AttributeTargets Enum;
    public static AttributeTargets Event;
    public static AttributeTargets Field;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets Interface;
    public static AttributeTargets Method;
    public static AttributeTargets Module;
    public static AttributeTargets Parameter;
    public static AttributeTargets Property;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets Struct;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeTargets ValidOn { get; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
    public AttributeTargets get_ValidOn();
}
public class System.BadImageFormatException : SystemException {
    public string FileName { get; }
    public string FusionLog { get; }
    public string Message { get; }
    protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    public string get_FileName();
    public string get_FusionLog();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions InsertLineBreaks;
    public static Base64FormattingOptions None;
}
public static class System.BitConverter : object {
    public static bool IsLittleEndian;
    public static long DoubleToInt64Bits(double value);
    public static Byte[] GetBytes(bool value);
    public static Byte[] GetBytes(char value);
    public static Byte[] GetBytes(double value);
    public static Byte[] GetBytes(short value);
    public static Byte[] GetBytes(int value);
    public static Byte[] GetBytes(long value);
    public static Byte[] GetBytes(float value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    public static float Int32BitsToSingle(int value);
    public static double Int64BitsToDouble(long value);
    public static int SingleToInt32Bits(float value);
    public static bool ToBoolean(Byte[] value, int startIndex);
    public static bool ToBoolean(ReadOnlySpan`1<byte> value);
    public static char ToChar(Byte[] value, int startIndex);
    public static char ToChar(ReadOnlySpan`1<byte> value);
    public static double ToDouble(Byte[] value, int startIndex);
    public static double ToDouble(ReadOnlySpan`1<byte> value);
    public static short ToInt16(Byte[] value, int startIndex);
    public static short ToInt16(ReadOnlySpan`1<byte> value);
    public static int ToInt32(Byte[] value, int startIndex);
    public static int ToInt32(ReadOnlySpan`1<byte> value);
    public static long ToInt64(Byte[] value, int startIndex);
    public static long ToInt64(ReadOnlySpan`1<byte> value);
    public static float ToSingle(Byte[] value, int startIndex);
    public static float ToSingle(ReadOnlySpan`1<byte> value);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static string ToString(Byte[] value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    public static bool TryWriteBytes(Span`1<byte> destination, bool value);
    public static bool TryWriteBytes(Span`1<byte> destination, char value);
    public static bool TryWriteBytes(Span`1<byte> destination, double value);
    public static bool TryWriteBytes(Span`1<byte> destination, short value);
    public static bool TryWriteBytes(Span`1<byte> destination, int value);
    public static bool TryWriteBytes(Span`1<byte> destination, long value);
    public static bool TryWriteBytes(Span`1<byte> destination, float value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ulong value);
}
[IsReadOnlyAttribute]
public class System.Boolean : ValueType {
    private bool _dummyPrimitive;
    public static string FalseString;
    public static string TrueString;
    public sealed virtual int CompareTo(bool value);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual bool Equals(bool obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static bool Parse(ReadOnlySpan`1<char> value);
    public static bool Parse(string value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public static bool TryParse(ReadOnlySpan`1<char> value, Boolean& result);
    public static bool TryParse(string value, Boolean& result);
}
public static class System.Buffer : object {
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    public static int ByteLength(Array array);
    public static byte GetByte(Array array, int index);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    public static void SetByte(Array array, int index, byte value);
}
public class System.Buffers.ArrayBufferWriter`1 : object {
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public int WrittenCount { get; }
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public int get_Capacity();
    public int get_FreeCapacity();
    public int get_WrittenCount();
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    public sealed virtual void Advance(int count);
    public void Clear();
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
}
public abstract class System.Buffers.ArrayPool`1 : object {
    public static ArrayPool`1<T> Shared { get; }
    public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
public static class System.Buffers.Binary.BinaryPrimitives : object {
    public static short ReadInt16BigEndian(ReadOnlySpan`1<byte> source);
    public static short ReadInt16LittleEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32BigEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32LittleEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64BigEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> source);
    public static byte ReverseEndianness(byte value);
    public static short ReverseEndianness(short value);
    public static int ReverseEndianness(int value);
    public static long ReverseEndianness(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ReverseEndianness(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ReverseEndianness(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ReverseEndianness(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ReverseEndianness(ulong value);
    public static bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> source, Int64& value);
    public static bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static bool TryWriteInt16BigEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32BigEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64BigEndian(Span`1<byte> destination, long value);
    public static bool TryWriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
    public static void WriteInt16BigEndian(Span`1<byte> destination, short value);
    public static void WriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static void WriteInt32BigEndian(Span`1<byte> destination, int value);
    public static void WriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static void WriteInt64BigEndian(Span`1<byte> destination, long value);
    public static void WriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
}
[ExtensionAttribute]
public static class System.Buffers.BuffersExtensions : object {
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySequence`1& source, Span`1<T> destination);
    [ExtensionAttribute]
public static Nullable`1<SequencePosition> PositionOf(ReadOnlySequence`1& source, T value);
    [ExtensionAttribute]
public static T[] ToArray(ReadOnlySequence`1& sequence);
    [ExtensionAttribute]
public static void Write(IBufferWriter`1<T> writer, ReadOnlySpan`1<T> value);
}
public interface System.Buffers.IBufferWriter`1 {
    public abstract virtual void Advance(int count);
    public abstract virtual Memory`1<T> GetMemory(int sizeHint);
    public abstract virtual Span`1<T> GetSpan(int sizeHint);
}
public interface System.Buffers.IMemoryOwner`1 {
    public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
public interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
public class System.Buffers.MemoryHandle : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
public abstract class System.Buffers.MemoryManager`1 : object {
    public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    private sealed virtual override void System.IDisposable.Dispose();
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    public abstract virtual void Unpin();
}
public abstract class System.Buffers.MemoryPool`1 : object {
    public int MaxBufferSize { get; }
    public static MemoryPool`1<T> Shared { get; }
    public abstract virtual int get_MaxBufferSize();
    public static MemoryPool`1<T> get_Shared();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual IMemoryOwner`1<T> Rent(int minBufferSize);
}
public enum System.Buffers.OperationStatus : Enum {
    public int value__;
    public static OperationStatus DestinationTooSmall;
    public static OperationStatus Done;
    public static OperationStatus InvalidData;
    public static OperationStatus NeedMoreData;
}
[IsReadOnlyAttribute]
public class System.Buffers.ReadOnlySequence`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static ReadOnlySequence`1<T> Empty;
    public SequencePosition End { get; }
    public ReadOnlyMemory`1<T> First { get; }
    public ReadOnlySpan`1<T> FirstSpan { get; }
    public bool IsEmpty { get; }
    public bool IsSingleSegment { get; }
    public long Length { get; }
    public SequencePosition Start { get; }
    public ReadOnlySequence`1(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment, int endIndex);
    public ReadOnlySequence`1(ReadOnlyMemory`1<T> memory);
    public ReadOnlySequence`1(T[] array);
    public ReadOnlySequence`1(T[] array, int start, int length);
    public SequencePosition get_End();
    public ReadOnlyMemory`1<T> get_First();
    public ReadOnlySpan`1<T> get_FirstSpan();
    public bool get_IsEmpty();
    public bool get_IsSingleSegment();
    public long get_Length();
    public SequencePosition get_Start();
    public Enumerator<T> GetEnumerator();
    public SequencePosition GetPosition(long offset);
    public SequencePosition GetPosition(long offset, SequencePosition origin);
    public ReadOnlySequence`1<T> Slice(int start, int length);
    public ReadOnlySequence`1<T> Slice(int start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(long start);
    public ReadOnlySequence`1<T> Slice(long start, long length);
    public ReadOnlySequence`1<T> Slice(long start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, int length);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, long length);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, SequencePosition end);
    public virtual string ToString();
    public bool TryGet(SequencePosition& position, ReadOnlyMemory`1& memory, bool advance);
}
public abstract class System.Buffers.ReadOnlySequenceSegment`1 : object {
    public ReadOnlyMemory`1<T> Memory { get; protected set; }
    public ReadOnlySequenceSegment`1<T> Next { get; protected set; }
    public long RunningIndex { get; protected set; }
    public ReadOnlyMemory`1<T> get_Memory();
    protected void set_Memory(ReadOnlyMemory`1<T> value);
    public ReadOnlySequenceSegment`1<T> get_Next();
    protected void set_Next(ReadOnlySequenceSegment`1<T> value);
    public long get_RunningIndex();
    protected void set_RunningIndex(long value);
}
public class System.Buffers.ReadOnlySpanAction`2 : MulticastDelegate {
    public ReadOnlySpanAction`2(object object, IntPtr method);
    public virtual void Invoke(ReadOnlySpan`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class System.Buffers.SequenceReader`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public long Consumed { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; }
    public int CurrentSpanIndex { get; }
    public bool End { get; }
    public long Length { get; }
    public SequencePosition Position { get; }
    public long Remaining { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public SequenceReader`1(ReadOnlySequence`1<T> sequence);
    [IsReadOnlyAttribute]
public long get_Consumed();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [IsReadOnlyAttribute]
public int get_CurrentSpanIndex();
    [IsReadOnlyAttribute]
public bool get_End();
    [IsReadOnlyAttribute]
public long get_Length();
    [IsReadOnlyAttribute]
public SequencePosition get_Position();
    [IsReadOnlyAttribute]
public long get_Remaining();
    [IsReadOnlyAttribute]
public ReadOnlySequence`1<T> get_Sequence();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_UnreadSpan();
    public void Advance(long count);
    public long AdvancePast(T value);
    public long AdvancePastAny(ReadOnlySpan`1<T> values);
    public long AdvancePastAny(T value0, T value1);
    public long AdvancePastAny(T value0, T value1, T value2);
    public long AdvancePastAny(T value0, T value1, T value2, T value3);
    public bool IsNext(ReadOnlySpan`1<T> next, bool advancePast);
    public bool IsNext(T next, bool advancePast);
    public void Rewind(long count);
    public bool TryAdvanceTo(T delimiter, bool advancePastDelimiter);
    public bool TryAdvanceToAny(ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<T> destination);
    [IsReadOnlyAttribute]
public bool TryPeek(T& value);
    public bool TryRead(T& value);
    public bool TryReadTo(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySequence`1& sequence, T delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySequence`1& sequence, T delimiter, T delimiterEscape, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySpan`1& span, T delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySpan`1& span, T delimiter, T delimiterEscape, bool advancePastDelimiter);
    public bool TryReadToAny(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    public bool TryReadToAny(ReadOnlySpan`1& span, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
}
[ExtensionAttribute]
public static class System.Buffers.SequenceReaderExtensions : object {
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int64& value);
}
public class System.Buffers.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class System.Buffers.StandardFormat : ValueType {
    private int _dummyPrimitive;
    public static byte MaxPrecision;
    public static byte NoPrecision;
    public bool HasPrecision { get; }
    public bool IsDefault { get; }
    public byte Precision { get; }
    public char Symbol { get; }
    public StandardFormat(char symbol, byte precision);
    public bool get_HasPrecision();
    public bool get_IsDefault();
    public byte get_Precision();
    public char get_Symbol();
    public sealed virtual bool Equals(StandardFormat other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StandardFormat left, StandardFormat right);
    public static StandardFormat op_Implicit(char symbol);
    public static bool op_Inequality(StandardFormat left, StandardFormat right);
    public static StandardFormat Parse(ReadOnlySpan`1<char> format);
    public static StandardFormat Parse(string format);
    public virtual string ToString();
    public static bool TryParse(ReadOnlySpan`1<char> format, StandardFormat& result);
}
public static class System.Buffers.Text.Base64 : object {
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static OperationStatus DecodeFromUtf8InPlace(Span`1<byte> buffer, Int32& bytesWritten);
    public static OperationStatus EncodeToUtf8(ReadOnlySpan`1<byte> bytes, Span`1<byte> utf8, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static OperationStatus EncodeToUtf8InPlace(Span`1<byte> buffer, int dataLength, Int32& bytesWritten);
    public static int GetMaxDecodedFromUtf8Length(int length);
    public static int GetMaxEncodedToUtf8Length(int length);
}
public static class System.Buffers.Text.Utf8Formatter : object {
    public static bool TryFormat(bool value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(byte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTime value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTimeOffset value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(decimal value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(double value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(Guid value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(short value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(int value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(long value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(sbyte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(float value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(TimeSpan value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ushort value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(UInt32 value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
}
public static class System.Buffers.Text.Utf8Parser : object {
    public static bool TryParse(ReadOnlySpan`1<byte> source, Boolean& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTime& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Decimal& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Single& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed, char standardFormat);
}
[IsReadOnlyAttribute]
public class System.Byte : ValueType {
    private byte _dummyPrimitive;
    public static byte MaxValue;
    public static byte MinValue;
    public sealed virtual int CompareTo(byte value);
    public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(byte obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Byte& result);
    public static bool TryParse(string s, Byte& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
}
public class System.CannotUnloadAppDomainException : SystemException {
    protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.Char : ValueType {
    private char _dummyPrimitive;
    public static char MaxValue;
    public static char MinValue;
    public sealed virtual int CompareTo(char value);
    public sealed virtual int CompareTo(object value);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
    public sealed virtual bool Equals(char obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public sealed virtual TypeCode GetTypeCode();
    public static UnicodeCategory GetUnicodeCategory(char c);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(char c);
    public static bool IsDigit(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLetter(char c);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(char c);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(char c);
    public static bool IsLower(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(char c);
    public static bool IsPunctuation(string s, int index);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(char c);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(char c);
    public static bool IsWhiteSpace(string s, int index);
    public static char Parse(string s);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public static char ToLower(char c);
    public static char ToLower(char c, CultureInfo culture);
    public static char ToLowerInvariant(char c);
    public virtual string ToString();
    public static string ToString(char c);
    public sealed virtual string ToString(IFormatProvider provider);
    public static char ToUpper(char c);
    public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpperInvariant(char c);
    public static bool TryParse(string s, Char& result);
}
public class System.CharEnumerator : object {
    public char Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual char get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[AttributeUsageAttribute("32767")]
public class System.CodeDom.Compiler.GeneratedCodeAttribute : Attribute {
    public string Tool { get; }
    public string Version { get; }
    public GeneratedCodeAttribute(string tool, string version);
    public string get_Tool();
    public string get_Version();
}
public class System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    public string NewLine { get; public set; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Close();
    public virtual void Flush();
    protected virtual void OutputTabs();
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(float value);
    public virtual void Write(string s);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(string s);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    public void WriteLineNoTabs(string s);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ArrayList : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public object SyncRoot { get; }
    public ArrayList(ICollection c);
    public ArrayList(int capacity);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public virtual object get_SyncRoot();
    public static ArrayList Adapter(IList list);
    public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    public virtual int BinarySearch(object value);
    public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    public static ArrayList FixedSize(ArrayList list);
    public static IList FixedSize(IList list);
    public virtual IEnumerator GetEnumerator();
    public virtual IEnumerator GetEnumerator(int index, int count);
    public virtual ArrayList GetRange(int index, int count);
    public virtual int IndexOf(object value);
    public virtual int IndexOf(object value, int startIndex);
    public virtual int IndexOf(object value, int startIndex, int count);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    public virtual int LastIndexOf(object value);
    public virtual int LastIndexOf(object value, int startIndex);
    public virtual int LastIndexOf(object value, int startIndex, int count);
    public static ArrayList ReadOnly(ArrayList list);
    public static IList ReadOnly(IList list);
    public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual void Sort();
    public virtual void Sort(IComparer comparer);
    public virtual void Sort(int index, int count, IComparer comparer);
    public static ArrayList Synchronized(ArrayList list);
    public static IList Synchronized(IList list);
    public virtual Object[] ToArray();
    public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
[DefaultMemberAttribute("Item")]
public class System.Collections.BitArray : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public bool Item { get; public set; }
    public int Length { get; public set; }
    public object SyncRoot { get; }
    public BitArray(Boolean[] values);
    public BitArray(Byte[] bytes);
    public BitArray(BitArray bits);
    public BitArray(int length);
    public BitArray(int length, bool defaultValue);
    public BitArray(Int32[] values);
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public int get_Length();
    public void set_Length(int value);
    public sealed virtual object get_SyncRoot();
    public BitArray And(BitArray value);
    public sealed virtual object Clone();
    public sealed virtual void CopyTo(Array array, int index);
    public bool Get(int index);
    public sealed virtual IEnumerator GetEnumerator();
    public BitArray LeftShift(int count);
    public BitArray Not();
    public BitArray Or(BitArray value);
    public BitArray RightShift(int count);
    public void Set(int index, bool value);
    public void SetAll(bool value);
    public BitArray Xor(BitArray value);
}
public class System.Collections.CaseInsensitiveComparer : object {
    public static CaseInsensitiveComparer Default { get; }
    public static CaseInsensitiveComparer DefaultInvariant { get; }
    public CaseInsensitiveComparer(CultureInfo culture);
    public static CaseInsensitiveComparer get_Default();
    public static CaseInsensitiveComparer get_DefaultInvariant();
    public sealed virtual int Compare(object a, object b);
}
[ObsoleteAttribute("Please use StringComparer instead.")]
public class System.Collections.CaseInsensitiveHashCodeProvider : object {
    public static CaseInsensitiveHashCodeProvider Default { get; }
    public static CaseInsensitiveHashCodeProvider DefaultInvariant { get; }
    public CaseInsensitiveHashCodeProvider(CultureInfo culture);
    public static CaseInsensitiveHashCodeProvider get_Default();
    public static CaseInsensitiveHashCodeProvider get_DefaultInvariant();
    public sealed virtual int GetHashCode(object obj);
}
public abstract class System.Collections.CollectionBase : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    protected ArrayList InnerList { get; }
    protected IList List { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    protected CollectionBase(int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    protected ArrayList get_InnerList();
    protected IList get_List();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Clear();
    public sealed virtual IEnumerator GetEnumerator();
    protected virtual void OnClear();
    protected virtual void OnClearComplete();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnInsertComplete(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnRemoveComplete(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    protected virtual void OnSetComplete(int index, object oldValue, object newValue);
    protected virtual void OnValidate(object value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public class System.Collections.Comparer : object {
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Collections.Concurrent.BlockingCollection`1 : object {
    public int BoundedCapacity { get; }
    public int Count { get; }
    public bool IsAddingCompleted { get; }
    public bool IsCompleted { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public BlockingCollection`1(IProducerConsumerCollection`1<T> collection);
    public BlockingCollection`1(IProducerConsumerCollection`1<T> collection, int boundedCapacity);
    public BlockingCollection`1(int boundedCapacity);
    public int get_BoundedCapacity();
    public sealed virtual int get_Count();
    public bool get_IsAddingCompleted();
    public bool get_IsCompleted();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Add(T item);
    public void Add(T item, CancellationToken cancellationToken);
    public static int AddToAny(BlockingCollection`1[] collections, T item);
    public static int AddToAny(BlockingCollection`1[] collections, T item, CancellationToken cancellationToken);
    public void CompleteAdding();
    public void CopyTo(T[] array, int index);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public IEnumerable`1<T> GetConsumingEnumerable();
    public IEnumerable`1<T> GetConsumingEnumerable(CancellationToken cancellationToken);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T Take();
    public T Take(CancellationToken cancellationToken);
    public static int TakeFromAny(BlockingCollection`1[] collections, T& item);
    public static int TakeFromAny(BlockingCollection`1[] collections, T& item, CancellationToken cancellationToken);
    public T[] ToArray();
    public bool TryAdd(T item);
    public bool TryAdd(T item, int millisecondsTimeout);
    public bool TryAdd(T item, int millisecondsTimeout, CancellationToken cancellationToken);
    public bool TryAdd(T item, TimeSpan timeout);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken cancellationToken);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, TimeSpan timeout);
    public bool TryTake(T& item);
    public bool TryTake(T& item, int millisecondsTimeout);
    public bool TryTake(T& item, int millisecondsTimeout, CancellationToken cancellationToken);
    public bool TryTake(T& item, TimeSpan timeout);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, CancellationToken cancellationToken);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, TimeSpan timeout);
}
public class System.Collections.Concurrent.ConcurrentBag`1 : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentBag`1(IEnumerable`1<T> collection);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Add(T item);
    public void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T[] ToArray();
    public bool TryPeek(T& result);
    public sealed virtual bool TryTake(T& result);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Concurrent.ConcurrentDictionary`2 : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public ICollection`1<TValue> Values { get; }
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity);
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity, IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual ICollection`1<TValue> get_Values();
    public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public TValue AddOrUpdate(TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public TValue AddOrUpdate(TKey key, Func`3<TKey, TArg, TValue> addValueFactory, Func`4<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key, TValue value);
    public TValue GetOrAdd(TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public KeyValuePair`2[] ToArray();
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryRemove(TKey key, TValue& value);
    public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);
}
public class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public void Enqueue(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T[] ToArray();
    public bool TryDequeue(T& result);
    public bool TryPeek(T& result);
}
public class System.Collections.Concurrent.ConcurrentStack`1 : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentStack`1(IEnumerable`1<T> collection);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public void Push(T item);
    public void PushRange(T[] items);
    public void PushRange(T[] items, int startIndex, int count);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T[] ToArray();
    public bool TryPeek(T& result);
    public bool TryPop(T& result);
    public int TryPopRange(T[] items);
    public int TryPopRange(T[] items, int startIndex, int count);
}
[FlagsAttribute]
public enum System.Collections.Concurrent.EnumerablePartitionerOptions : Enum {
    public int value__;
    public static EnumerablePartitionerOptions NoBuffering;
    public static EnumerablePartitionerOptions None;
}
public interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual T[] ToArray();
    public abstract virtual bool TryAdd(T item);
    public abstract virtual bool TryTake(T& item);
}
public abstract class System.Collections.Concurrent.OrderablePartitioner`1 : Partitioner`1<TSource> {
    public bool KeysNormalized { get; }
    public bool KeysOrderedAcrossPartitions { get; }
    public bool KeysOrderedInEachPartition { get; }
    protected OrderablePartitioner`1(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);
    public bool get_KeysNormalized();
    public bool get_KeysOrderedAcrossPartitions();
    public bool get_KeysOrderedInEachPartition();
    public virtual IEnumerable`1<TSource> GetDynamicPartitions();
    public virtual IEnumerable`1<KeyValuePair`2<long, TSource>> GetOrderableDynamicPartitions();
    public abstract virtual IList`1<IEnumerator`1<KeyValuePair`2<long, TSource>>> GetOrderablePartitions(int partitionCount);
    public virtual IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount);
}
public static class System.Collections.Concurrent.Partitioner : object {
    public static OrderablePartitioner`1<Tuple`2<int, int>> Create(int fromInclusive, int toExclusive);
    public static OrderablePartitioner`1<Tuple`2<int, int>> Create(int fromInclusive, int toExclusive, int rangeSize);
    public static OrderablePartitioner`1<Tuple`2<long, long>> Create(long fromInclusive, long toExclusive);
    public static OrderablePartitioner`1<Tuple`2<long, long>> Create(long fromInclusive, long toExclusive, long rangeSize);
    public static OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source);
    public static OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source, EnumerablePartitionerOptions partitionerOptions);
    public static OrderablePartitioner`1<TSource> Create(IList`1<TSource> list, bool loadBalance);
    public static OrderablePartitioner`1<TSource> Create(TSource[] array, bool loadBalance);
}
public abstract class System.Collections.Concurrent.Partitioner`1 : object {
    public bool SupportsDynamicPartitions { get; }
    public virtual bool get_SupportsDynamicPartitions();
    public virtual IEnumerable`1<TSource> GetDynamicPartitions();
    public abstract virtual IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount);
}
public abstract class System.Collections.DictionaryBase : object {
    public int Count { get; }
    protected IDictionary Dictionary { get; }
    protected Hashtable InnerHashtable { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public sealed virtual int get_Count();
    protected IDictionary get_Dictionary();
    protected Hashtable get_InnerHashtable();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    protected virtual void OnClear();
    protected virtual void OnClearComplete();
    protected virtual object OnGet(object key, object currentValue);
    protected virtual void OnInsert(object key, object value);
    protected virtual void OnInsertComplete(object key, object value);
    protected virtual void OnRemove(object key, object value);
    protected virtual void OnRemoveComplete(object key, object value);
    protected virtual void OnSet(object key, object oldValue, object newValue);
    protected virtual void OnSetComplete(object key, object oldValue, object newValue);
    protected virtual void OnValidate(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Collections.DictionaryEntry : ValueType {
    private object _dummy;
    public object Key { get; public set; }
    public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Object& key, Object& value);
}
[ExtensionAttribute]
public static class System.Collections.Generic.CollectionExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static bool Remove(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue& value);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
}
public abstract class System.Collections.Generic.Comparer`1 : object {
    public static Comparer`1<T> Default { get; }
    public static Comparer`1<T> get_Default();
    public abstract virtual int Compare(T x, T y);
    public static Comparer`1<T> Create(Comparison`1<T> comparison);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Generic.Dictionary`2 : object {
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    protected Dictionary`2(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public int EnsureCapacity(int capacity);
    public Enumerator<TKey, TValue> GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void TrimExcess();
    public void TrimExcess(int capacity);
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
}
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    public static EqualityComparer`1<T> Default { get; }
    public static EqualityComparer`1<T> get_Default();
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
}
public class System.Collections.Generic.HashSet`1 : object {
    public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public HashSet`1(IEnumerable`1<T> collection);
    public HashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public HashSet`1(IEqualityComparer`1<T> comparer);
    public HashSet`1(int capacity);
    public HashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    protected HashSet`1(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<T> get_Comparer();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public static IEqualityComparer`1<HashSet`1<T>> CreateSetComparer();
    public int EnsureCapacity(int capacity);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public Enumerator<T> GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public virtual void OnDeserialization(object sender);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool Remove(T item);
    public int RemoveWhere(Predicate`1<T> match);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void TrimExcess();
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
}
public interface System.Collections.Generic.IAsyncEnumerable`1 {
    public abstract virtual IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken);
}
public interface System.Collections.Generic.IAsyncEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
    public abstract virtual ValueTask`1<bool> MoveNextAsync();
}
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface System.Collections.Generic.IEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
public interface System.Collections.Generic.ISet`1 {
    public abstract virtual bool Add(T item);
    public abstract virtual void ExceptWith(IEnumerable`1<T> other);
    public abstract virtual void IntersectWith(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
    public abstract virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public abstract virtual void UnionWith(IEnumerable`1<T> other);
}
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
}
public static class System.Collections.Generic.KeyValuePair : object {
    public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
}
[IsReadOnlyAttribute]
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    private TKey key;
    private TValue value;
    private int _dummyPrimitive;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    [EditorBrowsableAttribute("1")]
public void Deconstruct(TKey& key, TValue& value);
    public virtual string ToString();
}
public class System.Collections.Generic.LinkedList`1 : object {
    public int Count { get; }
    public LinkedListNode`1<T> First { get; }
    public LinkedListNode`1<T> Last { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public LinkedList`1(IEnumerable`1<T> collection);
    protected LinkedList`1(SerializationInfo info, StreamingContext context);
    public sealed virtual int get_Count();
    public LinkedListNode`1<T> get_First();
    public LinkedListNode`1<T> get_Last();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void AddAfter(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public LinkedListNode`1<T> AddAfter(LinkedListNode`1<T> node, T value);
    public void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public LinkedListNode`1<T> AddBefore(LinkedListNode`1<T> node, T value);
    public void AddFirst(LinkedListNode`1<T> node);
    public LinkedListNode`1<T> AddFirst(T value);
    public void AddLast(LinkedListNode`1<T> node);
    public LinkedListNode`1<T> AddLast(T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public LinkedListNode`1<T> Find(T value);
    public LinkedListNode`1<T> FindLast(T value);
    public Enumerator<T> GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    public void Remove(LinkedListNode`1<T> node);
    public sealed virtual bool Remove(T value);
    public void RemoveFirst();
    public void RemoveLast();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Collections.Generic.LinkedListNode`1 : object {
    public LinkedList`1<T> List { get; }
    public LinkedListNode`1<T> Next { get; }
    public LinkedListNode`1<T> Previous { get; }
    public T Value { get; public set; }
    public LinkedListNode`1(T value);
    public LinkedList`1<T> get_List();
    public LinkedListNode`1<T> get_Next();
    public LinkedListNode`1<T> get_Previous();
    public T get_Value();
    public void set_Value(T value);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Generic.List`1 : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public List`1(IEnumerable`1<T> collection);
    public List`1(int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    public Enumerator<T> GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
}
public class System.Collections.Generic.Queue`1 : object {
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Queue`1(IEnumerable`1<T> collection);
    public Queue`1(int capacity);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    public T Dequeue();
    public void Enqueue(T item);
    public Enumerator<T> GetEnumerator();
    public T Peek();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T[] ToArray();
    public void TrimExcess();
    public bool TryDequeue(T& result);
    public bool TryPeek(T& result);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Generic.SortedDictionary`2 : object {
    public IComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public SortedDictionary`2(IComparer`1<TKey> comparer);
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public IComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<TKey, TValue> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Generic.SortedList`2 : object {
    public int Capacity { get; public set; }
    public IComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public IList`1<TKey> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public IList`1<TValue> Values { get; }
    public SortedList`2(IComparer`1<TKey> comparer);
    public SortedList`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedList`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public SortedList`2(int capacity);
    public SortedList`2(int capacity, IComparer`1<TKey> comparer);
    public int get_Capacity();
    public void set_Capacity(int value);
    public IComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public IList`1<TKey> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public IList`1<TValue> get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public int IndexOfKey(TKey key);
    public int IndexOfValue(TValue value);
    public sealed virtual bool Remove(TKey key);
    public void RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void TrimExcess();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
}
public class System.Collections.Generic.SortedSet`1 : object {
    public IComparer`1<T> Comparer { get; }
    public int Count { get; }
    public T Max { get; }
    public T Min { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public SortedSet`1(IComparer`1<T> comparer);
    public SortedSet`1(IEnumerable`1<T> collection);
    public SortedSet`1(IEnumerable`1<T> collection, IComparer`1<T> comparer);
    protected SortedSet`1(SerializationInfo info, StreamingContext context);
    public IComparer`1<T> get_Comparer();
    public sealed virtual int get_Count();
    public T get_Max();
    public T get_Min();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int index);
    public void CopyTo(T[] array, int index, int count);
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer(IEqualityComparer`1<T> memberEqualityComparer);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public Enumerator<T> GetEnumerator();
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual SortedSet`1<T> GetViewBetween(T lowerValue, T upperValue);
    public virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    protected virtual void OnDeserialization(object sender);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool Remove(T item);
    public int RemoveWhere(Predicate`1<T> match);
    public IEnumerable`1<T> Reverse();
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
}
public class System.Collections.Generic.Stack`1 : object {
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Stack`1(IEnumerable`1<T> collection);
    public Stack`1(int capacity);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    public Enumerator<T> GetEnumerator();
    public T Peek();
    public T Pop();
    public void Push(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T[] ToArray();
    public void TrimExcess();
    public bool TryPeek(T& result);
    public bool TryPop(T& result);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Hashtable : object {
    [ObsoleteAttribute("Please use KeyComparer properties.")]
protected IComparer comparer { get; protected set; }
    public int Count { get; }
    protected IEqualityComparer EqualityComparer { get; }
    [ObsoleteAttribute("Please use EqualityComparer property.")]
protected IHashCodeProvider hcp { get; protected set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity);
    public Hashtable(int capacity, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity, float loadFactor);
    public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    protected Hashtable(SerializationInfo info, StreamingContext context);
    protected IComparer get_comparer();
    protected void set_comparer(IComparer value);
    public virtual int get_Count();
    protected IEqualityComparer get_EqualityComparer();
    protected IHashCodeProvider get_hcp();
    protected void set_hcp(IHashCodeProvider value);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual ICollection get_Keys();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Values();
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual bool KeyEquals(object item, object key);
    public virtual void OnDeserialization(object sender);
    public virtual void Remove(object key);
    public static Hashtable Synchronized(Hashtable table);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface System.Collections.ICollection {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public abstract virtual void CopyTo(Array array, int index);
}
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object key);
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
public interface System.Collections.IDictionaryEnumerator {
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    public abstract virtual DictionaryEntry get_Entry();
    public abstract virtual object get_Key();
    public abstract virtual object get_Value();
}
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual object get_Current();
    public abstract virtual bool MoveNext();
    public abstract virtual void Reset();
}
public interface System.Collections.IEqualityComparer {
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object value);
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.Collection`1 : object {
    public int Count { get; }
    public T Item { get; public set; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    protected virtual void ClearItems();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Collections.ObjectModel.KeyedCollection`2 : Collection`1<TItem> {
    public IEqualityComparer`1<TKey> Comparer { get; }
    protected IDictionary`2<TKey, TItem> Dictionary { get; }
    public TItem Item { get; }
    protected KeyedCollection`2(IEqualityComparer`1<TKey> comparer);
    protected KeyedCollection`2(IEqualityComparer`1<TKey> comparer, int dictionaryCreationThreshold);
    public IEqualityComparer`1<TKey> get_Comparer();
    protected IDictionary`2<TKey, TItem> get_Dictionary();
    public TItem get_Item(TKey key);
    protected void ChangeItemKey(TItem item, TKey newKey);
    protected virtual void ClearItems();
    public bool Contains(TKey key);
    protected abstract virtual TKey GetKeyForItem(TItem item);
    protected virtual void InsertItem(int index, TItem item);
    public bool Remove(TKey key);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, TItem item);
    public bool TryGetValue(TKey key, TItem& item);
}
public class System.Collections.ObjectModel.ObservableCollection`1 : Collection`1<T> {
    public ObservableCollection`1(IEnumerable`1<T> collection);
    public ObservableCollection`1(List`1<T> list);
    public virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected IDisposable BlockReentrancy();
    protected void CheckReentrancy();
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    public void Move(int oldIndex, int newIndex);
    protected virtual void MoveItem(int oldIndex, int newIndex);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    public int Count { get; }
    protected IDictionary`2<TKey, TValue> Dictionary { get; }
    public TValue Item { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual int get_Count();
    protected IDictionary`2<TKey, TValue> get_Dictionary();
    public sealed virtual TValue get_Item(TKey key);
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
}
public class System.Collections.ObjectModel.ReadOnlyObservableCollection`1 : ReadOnlyCollection`1<T> {
    public ReadOnlyObservableCollection`1(ObservableCollection`1<T> list);
    protected virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs args);
}
public class System.Collections.Queue : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Queue(ICollection col);
    public Queue(int capacity);
    public Queue(int capacity, float growFactor);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object obj);
    public virtual void CopyTo(Array array, int index);
    public virtual object Dequeue();
    public virtual void Enqueue(object obj);
    public virtual IEnumerator GetEnumerator();
    public virtual object Peek();
    public static Queue Synchronized(Queue queue);
    public virtual Object[] ToArray();
    public virtual void TrimToSize();
}
public abstract class System.Collections.ReadOnlyCollectionBase : object {
    public int Count { get; }
    protected ArrayList InnerList { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public virtual int get_Count();
    protected ArrayList get_InnerList();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.SortedList : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public SortedList(IComparer comparer);
    public SortedList(IComparer comparer, int capacity);
    public SortedList(IDictionary d);
    public SortedList(IDictionary d, IComparer comparer);
    public SortedList(int initialCapacity);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual ICollection get_Keys();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Values();
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual object GetByIndex(int index);
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual object GetKey(int index);
    public virtual IList GetKeyList();
    public virtual IList GetValueList();
    public virtual int IndexOfKey(object key);
    public virtual int IndexOfValue(object value);
    public virtual void Remove(object key);
    public virtual void RemoveAt(int index);
    public virtual void SetByIndex(int index, object value);
    public static SortedList Synchronized(SortedList list);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void TrimToSize();
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.BitVector32 : ValueType {
    private int _dummyPrimitive;
    public int Data { get; }
    public int Item { get; public set; }
    public bool Item { get; public set; }
    public BitVector32(BitVector32 value);
    public BitVector32(int data);
    public int get_Data();
    public int get_Item(Section section);
    public void set_Item(Section section, int value);
    public bool get_Item(int bit);
    public void set_Item(int bit, bool value);
    public static int CreateMask();
    public static int CreateMask(int previous);
    public static Section CreateSection(short maxValue);
    public static Section CreateSection(short maxValue, Section previous);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static string ToString(BitVector32 value);
}
public class System.Collections.Specialized.CollectionsUtil : object {
    public static Hashtable CreateCaseInsensitiveHashtable();
    public static Hashtable CreateCaseInsensitiveHashtable(IDictionary d);
    public static Hashtable CreateCaseInsensitiveHashtable(int capacity);
    public static SortedList CreateCaseInsensitiveSortedList();
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.HybridDictionary : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public HybridDictionary(bool caseInsensitive);
    public HybridDictionary(int initialSize);
    public HybridDictionary(int initialSize, bool caseInsensitive);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface System.Collections.Specialized.INotifyCollectionChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Specialized.IOrderedDictionary {
    public object Item { get; public set; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Insert(int index, object key, object value);
    public abstract virtual void RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.ListDictionary : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public ListDictionary(IComparer comparer);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.Collections.Specialized.NameObjectCollectionBase : object {
    public int Count { get; }
    protected bool IsReadOnly { get; protected set; }
    public KeysCollection Keys { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    protected NameObjectCollectionBase(IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use NameObjectCollectionBase(IEqualityComparer) instead.")]
protected NameObjectCollectionBase(IHashCodeProvider hashProvider, IComparer comparer);
    protected NameObjectCollectionBase(int capacity);
    protected NameObjectCollectionBase(int capacity, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use NameObjectCollectionBase(Int32, IEqualityComparer) instead.")]
protected NameObjectCollectionBase(int capacity, IHashCodeProvider hashProvider, IComparer comparer);
    protected NameObjectCollectionBase(SerializationInfo info, StreamingContext context);
    public virtual int get_Count();
    protected bool get_IsReadOnly();
    protected void set_IsReadOnly(bool value);
    public virtual KeysCollection get_Keys();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    protected void BaseAdd(string name, object value);
    protected void BaseClear();
    protected object BaseGet(int index);
    protected object BaseGet(string name);
    protected String[] BaseGetAllKeys();
    protected Object[] BaseGetAllValues();
    protected Object[] BaseGetAllValues(Type type);
    protected string BaseGetKey(int index);
    protected bool BaseHasKeys();
    protected void BaseRemove(string name);
    protected void BaseRemoveAt(int index);
    protected void BaseSet(int index, object value);
    protected void BaseSet(string name, object value);
    public virtual IEnumerator GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.NameValueCollection : NameObjectCollectionBase {
    public String[] AllKeys { get; }
    public string Item { get; }
    public string Item { get; public set; }
    public NameValueCollection(IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use NameValueCollection(IEqualityComparer) instead.")]
public NameValueCollection(IHashCodeProvider hashProvider, IComparer comparer);
    public NameValueCollection(NameValueCollection col);
    public NameValueCollection(int capacity);
    public NameValueCollection(int capacity, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use NameValueCollection(Int32, IEqualityComparer) instead.")]
public NameValueCollection(int capacity, IHashCodeProvider hashProvider, IComparer comparer);
    public NameValueCollection(int capacity, NameValueCollection col);
    protected NameValueCollection(SerializationInfo info, StreamingContext context);
    public virtual String[] get_AllKeys();
    public string get_Item(int index);
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public void Add(NameValueCollection c);
    public virtual void Add(string name, string value);
    public virtual void Clear();
    public void CopyTo(Array dest, int index);
    public virtual string Get(int index);
    public virtual string Get(string name);
    public virtual string GetKey(int index);
    public virtual String[] GetValues(int index);
    public virtual String[] GetValues(string name);
    public bool HasKeys();
    protected void InvalidateCachedArrays();
    public virtual void Remove(string name);
    public virtual void Set(string name, string value);
}
public enum System.Collections.Specialized.NotifyCollectionChangedAction : Enum {
    public int value__;
    public static NotifyCollectionChangedAction Add;
    public static NotifyCollectionChangedAction Move;
    public static NotifyCollectionChangedAction Remove;
    public static NotifyCollectionChangedAction Replace;
    public static NotifyCollectionChangedAction Reset;
}
public class System.Collections.Specialized.NotifyCollectionChangedEventArgs : EventArgs {
    public NotifyCollectionChangedAction Action { get; }
    public IList NewItems { get; }
    public int NewStartingIndex { get; }
    public IList OldItems { get; }
    public int OldStartingIndex { get; }
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index);
    public NotifyCollectionChangedAction get_Action();
    public IList get_NewItems();
    public int get_NewStartingIndex();
    public IList get_OldItems();
    public int get_OldStartingIndex();
}
public class System.Collections.Specialized.NotifyCollectionChangedEventHandler : MulticastDelegate {
    public NotifyCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.OrderedDictionary : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public ICollection Values { get; }
    public OrderedDictionary(IEqualityComparer comparer);
    public OrderedDictionary(int capacity);
    public OrderedDictionary(int capacity, IEqualityComparer comparer);
    protected OrderedDictionary(SerializationInfo info, StreamingContext context);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public OrderedDictionary AsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void Insert(int index, object key, object value);
    protected virtual void OnDeserialization(object sender);
    public sealed virtual void Remove(object key);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.StringCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public string Item { get; public set; }
    public object SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public string get_Item(int index);
    public void set_Item(int index, string value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(string value);
    public void AddRange(String[] value);
    public sealed virtual void Clear();
    public bool Contains(string value);
    public void CopyTo(String[] array, int index);
    public StringEnumerator GetEnumerator();
    public int IndexOf(string value);
    public void Insert(int index, string value);
    public void Remove(string value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.StringDictionary : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public string Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual ICollection get_Keys();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Values();
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual bool ContainsKey(string key);
    public virtual bool ContainsValue(string value);
    public virtual void CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
    public virtual void Remove(string key);
}
public class System.Collections.Specialized.StringEnumerator : object {
    public string Current { get; }
    public string get_Current();
    public bool MoveNext();
    public void Reset();
}
public class System.Collections.Stack : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Stack(ICollection col);
    public Stack(int initialCapacity);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object obj);
    public virtual void CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
    public virtual object Peek();
    public virtual object Pop();
    public virtual void Push(object obj);
    public static Stack Synchronized(Stack stack);
    public virtual Object[] ToArray();
}
public static class System.Collections.StructuralComparisons : object {
    public static IComparer StructuralComparer { get; }
    public static IEqualityComparer StructuralEqualityComparer { get; }
    public static IComparer get_StructuralComparer();
    public static IEqualityComparer get_StructuralEqualityComparer();
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.AddingNewEventArgs : EventArgs {
    public object NewObject { get; public set; }
    public AddingNewEventArgs(object newObject);
    public object get_NewObject();
    public void set_NewObject(object value);
}
public class System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
    public AddingNewEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AddingNewEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.AmbientValueAttribute : Attribute {
    public object Value { get; }
    public AmbientValueAttribute(bool value);
    public AmbientValueAttribute(byte value);
    public AmbientValueAttribute(char value);
    public AmbientValueAttribute(double value);
    public AmbientValueAttribute(short value);
    public AmbientValueAttribute(int value);
    public AmbientValueAttribute(long value);
    public AmbientValueAttribute(object value);
    public AmbientValueAttribute(float value);
    public AmbientValueAttribute(string value);
    public AmbientValueAttribute(Type type, string value);
    public object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.ComponentModel.ArrayConverter : CollectionConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.ComponentModel.AsyncCompletedEventArgs : EventArgs {
    public bool Cancelled { get; }
    public Exception Error { get; }
    public object UserState { get; }
    public AsyncCompletedEventArgs(Exception error, bool cancelled, object userState);
    public bool get_Cancelled();
    public Exception get_Error();
    public object get_UserState();
    protected void RaiseExceptionIfNecessary();
}
public class System.ComponentModel.AsyncCompletedEventHandler : MulticastDelegate {
    public AsyncCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.AsyncOperation : object {
    public SynchronizationContext SynchronizationContext { get; }
    public object UserSuppliedState { get; }
    public SynchronizationContext get_SynchronizationContext();
    public object get_UserSuppliedState();
    public void OperationCompleted();
    public void Post(SendOrPostCallback d, object arg);
    public void PostOperationCompleted(SendOrPostCallback d, object arg);
}
public static class System.ComponentModel.AsyncOperationManager : object {
    [EditorBrowsableAttribute("2")]
public static SynchronizationContext SynchronizationContext { get; public set; }
    public static SynchronizationContext get_SynchronizationContext();
    public static void set_SynchronizationContext(SynchronizationContext value);
    public static AsyncOperation CreateOperation(object userSuppliedState);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.AttributeCollection : object {
    public static AttributeCollection Empty;
    protected Attribute[] Attributes { get; }
    public int Count { get; }
    public Attribute Item { get; }
    public Attribute Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public AttributeCollection(Attribute[] attributes);
    protected virtual Attribute[] get_Attributes();
    public int get_Count();
    public virtual Attribute get_Item(int index);
    public virtual Attribute get_Item(Type attributeType);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public bool Contains(Attribute attribute);
    public bool Contains(Attribute[] attributes);
    public sealed virtual void CopyTo(Array array, int index);
    public static AttributeCollection FromExisting(AttributeCollection existing, Attribute[] newAttributes);
    protected Attribute GetDefaultAttribute(Type attributeType);
    public IEnumerator GetEnumerator();
    public bool Matches(Attribute attribute);
    public bool Matches(Attribute[] attributes);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.AttributeProviderAttribute : Attribute {
    public string PropertyName { get; }
    public string TypeName { get; }
    public AttributeProviderAttribute(string typeName);
    public AttributeProviderAttribute(string typeName, string propertyName);
    public AttributeProviderAttribute(Type type);
    public string get_PropertyName();
    public string get_TypeName();
}
[DefaultEventAttribute("DoWork")]
public class System.ComponentModel.BackgroundWorker : Component {
    [BrowsableAttribute("False")]
public bool CancellationPending { get; }
    [BrowsableAttribute("False")]
public bool IsBusy { get; }
    [DefaultValueAttribute("False")]
public bool WorkerReportsProgress { get; public set; }
    [DefaultValueAttribute("False")]
public bool WorkerSupportsCancellation { get; public set; }
    public bool get_CancellationPending();
    public bool get_IsBusy();
    public bool get_WorkerReportsProgress();
    public void set_WorkerReportsProgress(bool value);
    public bool get_WorkerSupportsCancellation();
    public void set_WorkerSupportsCancellation(bool value);
    public void add_DoWork(DoWorkEventHandler value);
    public void remove_DoWork(DoWorkEventHandler value);
    public void add_ProgressChanged(ProgressChangedEventHandler value);
    public void remove_ProgressChanged(ProgressChangedEventHandler value);
    public void add_RunWorkerCompleted(RunWorkerCompletedEventHandler value);
    public void remove_RunWorkerCompleted(RunWorkerCompletedEventHandler value);
    public void CancelAsync();
    protected virtual void Dispose(bool disposing);
    protected virtual void OnDoWork(DoWorkEventArgs e);
    protected virtual void OnProgressChanged(ProgressChangedEventArgs e);
    protected virtual void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e);
    public void ReportProgress(int percentProgress);
    public void ReportProgress(int percentProgress, object userState);
    public void RunWorkerAsync();
    public void RunWorkerAsync(object argument);
}
public abstract class System.ComponentModel.BaseNumberConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.BindableAttribute : Attribute {
    public static BindableAttribute Default;
    public static BindableAttribute No;
    public static BindableAttribute Yes;
    public bool Bindable { get; }
    public BindingDirection Direction { get; }
    public BindableAttribute(bool bindable);
    public BindableAttribute(bool bindable, BindingDirection direction);
    public BindableAttribute(BindableSupport flags);
    public BindableAttribute(BindableSupport flags, BindingDirection direction);
    public bool get_Bindable();
    public BindingDirection get_Direction();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public enum System.ComponentModel.BindableSupport : Enum {
    public int value__;
    public static BindableSupport Default;
    public static BindableSupport No;
    public static BindableSupport Yes;
}
public enum System.ComponentModel.BindingDirection : Enum {
    public int value__;
    public static BindingDirection OneWay;
    public static BindingDirection TwoWay;
}
public class System.ComponentModel.BindingList`1 : Collection`1<T> {
    public bool AllowEdit { get; public set; }
    public bool AllowNew { get; public set; }
    public bool AllowRemove { get; public set; }
    protected bool IsSortedCore { get; }
    public bool RaiseListChangedEvents { get; public set; }
    protected ListSortDirection SortDirectionCore { get; }
    protected PropertyDescriptor SortPropertyCore { get; }
    protected bool SupportsChangeNotificationCore { get; }
    protected bool SupportsSearchingCore { get; }
    protected bool SupportsSortingCore { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    public BindingList`1(IList`1<T> list);
    public bool get_AllowEdit();
    public void set_AllowEdit(bool value);
    public bool get_AllowNew();
    public void set_AllowNew(bool value);
    public bool get_AllowRemove();
    public void set_AllowRemove(bool value);
    protected virtual bool get_IsSortedCore();
    public bool get_RaiseListChangedEvents();
    public void set_RaiseListChangedEvents(bool value);
    protected virtual ListSortDirection get_SortDirectionCore();
    protected virtual PropertyDescriptor get_SortPropertyCore();
    protected virtual bool get_SupportsChangeNotificationCore();
    protected virtual bool get_SupportsSearchingCore();
    protected virtual bool get_SupportsSortingCore();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public T AddNew();
    protected virtual object AddNewCore();
    protected virtual void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction);
    public virtual void CancelNew(int itemIndex);
    protected virtual void ClearItems();
    public virtual void EndNew(int itemIndex);
    protected virtual int FindCore(PropertyDescriptor prop, object key);
    protected virtual void InsertItem(int index, T item);
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    protected virtual void RemoveItem(int index);
    protected virtual void RemoveSortCore();
    public void ResetBindings();
    public void ResetItem(int position);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor prop);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor prop, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor prop, object key);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor prop);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
}
public class System.ComponentModel.BooleanConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.BrowsableAttribute : Attribute {
    public static BrowsableAttribute Default;
    public static BrowsableAttribute No;
    public static BrowsableAttribute Yes;
    public bool Browsable { get; }
    public BrowsableAttribute(bool browsable);
    public bool get_Browsable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ByteConverter : BaseNumberConverter {
}
public class System.ComponentModel.CancelEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public CancelEventArgs(bool cancel);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class System.ComponentModel.CancelEventHandler : MulticastDelegate {
    public CancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.CategoryAttribute : Attribute {
    public static CategoryAttribute Action { get; }
    public static CategoryAttribute Appearance { get; }
    public static CategoryAttribute Asynchronous { get; }
    public static CategoryAttribute Behavior { get; }
    public string Category { get; }
    public static CategoryAttribute Data { get; }
    public static CategoryAttribute Default { get; }
    public static CategoryAttribute Design { get; }
    public static CategoryAttribute DragDrop { get; }
    public static CategoryAttribute Focus { get; }
    public static CategoryAttribute Format { get; }
    public static CategoryAttribute Key { get; }
    public static CategoryAttribute Layout { get; }
    public static CategoryAttribute Mouse { get; }
    public static CategoryAttribute WindowStyle { get; }
    public CategoryAttribute(string category);
    public static CategoryAttribute get_Action();
    public static CategoryAttribute get_Appearance();
    public static CategoryAttribute get_Asynchronous();
    public static CategoryAttribute get_Behavior();
    public string get_Category();
    public static CategoryAttribute get_Data();
    public static CategoryAttribute get_Default();
    public static CategoryAttribute get_Design();
    public static CategoryAttribute get_DragDrop();
    public static CategoryAttribute get_Focus();
    public static CategoryAttribute get_Format();
    public static CategoryAttribute get_Key();
    public static CategoryAttribute get_Layout();
    public static CategoryAttribute get_Mouse();
    public static CategoryAttribute get_WindowStyle();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual string GetLocalizedString(string value);
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.CharConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.ComponentModel.CollectionChangeAction : Enum {
    public int value__;
    public static CollectionChangeAction Add;
    public static CollectionChangeAction Refresh;
    public static CollectionChangeAction Remove;
}
public class System.ComponentModel.CollectionChangeEventArgs : EventArgs {
    public CollectionChangeAction Action { get; }
    public object Element { get; }
    public CollectionChangeEventArgs(CollectionChangeAction action, object element);
    public virtual CollectionChangeAction get_Action();
    public virtual object get_Element();
}
public class System.ComponentModel.CollectionChangeEventHandler : MulticastDelegate {
    public CollectionChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CollectionChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CollectionChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.CollectionConverter : TypeConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ComplexBindingPropertiesAttribute : Attribute {
    public static ComplexBindingPropertiesAttribute Default;
    public string DataMember { get; }
    public string DataSource { get; }
    public ComplexBindingPropertiesAttribute(string dataSource);
    public ComplexBindingPropertiesAttribute(string dataSource, string dataMember);
    public string get_DataMember();
    public string get_DataSource();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DesignerCategoryAttribute("Component")]
public class System.ComponentModel.Component : MarshalByRefObject {
    protected bool CanRaiseEvents { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IContainer Container { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
protected bool DesignMode { get; }
    protected EventHandlerList Events { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ISite Site { get; public set; }
    protected virtual bool get_CanRaiseEvents();
    public IContainer get_Container();
    protected bool get_DesignMode();
    protected EventHandlerList get_Events();
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public sealed virtual void add_Disposed(EventHandler value);
    public sealed virtual void remove_Disposed(EventHandler value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected virtual object GetService(Type service);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.ComponentCollection : ReadOnlyCollectionBase {
    public IComponent Item { get; }
    public IComponent Item { get; }
    public ComponentCollection(IComponent[] components);
    public virtual IComponent get_Item(int index);
    public virtual IComponent get_Item(string name);
    public void CopyTo(IComponent[] array, int index);
}
public class System.ComponentModel.ComponentConverter : ReferenceConverter {
    public ComponentConverter(Type type);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public abstract class System.ComponentModel.ComponentEditor : object {
    public abstract virtual bool EditComponent(ITypeDescriptorContext context, object component);
    public bool EditComponent(object component);
}
public class System.ComponentModel.ComponentResourceManager : ResourceManager {
    public ComponentResourceManager(Type t);
    public void ApplyResources(object value, string objectName);
    public virtual void ApplyResources(object value, string objectName, CultureInfo culture);
}
public class System.ComponentModel.Container : object {
    public ComponentCollection Components { get; }
    public virtual ComponentCollection get_Components();
    public virtual void Add(IComponent component);
    public virtual void Add(IComponent component, string name);
    protected virtual ISite CreateSite(IComponent component, string name);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected virtual object GetService(Type service);
    public virtual void Remove(IComponent component);
    protected void RemoveWithoutUnsiting(IComponent component);
    protected virtual void ValidateName(IComponent component, string name);
}
public abstract class System.ComponentModel.ContainerFilterService : object {
    public virtual ComponentCollection FilterComponents(ComponentCollection components);
}
public class System.ComponentModel.CultureInfoConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    protected virtual string GetCultureName(CultureInfo culture);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public abstract class System.ComponentModel.CustomTypeDescriptor : object {
    protected CustomTypeDescriptor(ICustomTypeDescriptor parent);
    public virtual AttributeCollection GetAttributes();
    public virtual string GetClassName();
    public virtual string GetComponentName();
    public virtual TypeConverter GetConverter();
    public virtual EventDescriptor GetDefaultEvent();
    public virtual PropertyDescriptor GetDefaultProperty();
    public virtual object GetEditor(Type editorBaseType);
    public virtual EventDescriptorCollection GetEvents();
    public virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public virtual PropertyDescriptorCollection GetProperties();
    public virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public virtual object GetPropertyOwner(PropertyDescriptor pd);
}
public class System.ComponentModel.DataErrorsChangedEventArgs : EventArgs {
    public string PropertyName { get; }
    public DataErrorsChangedEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DataObjectAttribute : Attribute {
    public static DataObjectAttribute DataObject;
    public static DataObjectAttribute Default;
    public static DataObjectAttribute NonDataObject;
    public bool IsDataObject { get; }
    public DataObjectAttribute(bool isDataObject);
    public bool get_IsDataObject();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.DataObjectFieldAttribute : Attribute {
    public bool IsIdentity { get; }
    public bool IsNullable { get; }
    public int Length { get; }
    public bool PrimaryKey { get; }
    public DataObjectFieldAttribute(bool primaryKey);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity, bool isNullable);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity, bool isNullable, int length);
    public bool get_IsIdentity();
    public bool get_IsNullable();
    public int get_Length();
    public bool get_PrimaryKey();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("64")]
public class System.ComponentModel.DataObjectMethodAttribute : Attribute {
    public bool IsDefault { get; }
    public DataObjectMethodType MethodType { get; }
    public DataObjectMethodAttribute(DataObjectMethodType methodType);
    public DataObjectMethodAttribute(DataObjectMethodType methodType, bool isDefault);
    public bool get_IsDefault();
    public DataObjectMethodType get_MethodType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Match(object obj);
}
public enum System.ComponentModel.DataObjectMethodType : Enum {
    public int value__;
    public static DataObjectMethodType Delete;
    public static DataObjectMethodType Fill;
    public static DataObjectMethodType Insert;
    public static DataObjectMethodType Select;
    public static DataObjectMethodType Update;
}
public class System.ComponentModel.DateTimeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.DateTimeOffsetConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.DecimalConverter : BaseNumberConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultBindingPropertyAttribute : Attribute {
    public static DefaultBindingPropertyAttribute Default;
    public string Name { get; }
    public DefaultBindingPropertyAttribute(string name);
    public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultEventAttribute : Attribute {
    public static DefaultEventAttribute Default;
    public string Name { get; }
    public DefaultEventAttribute(string name);
    public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultPropertyAttribute : Attribute {
    public static DefaultPropertyAttribute Default;
    public string Name { get; }
    public DefaultPropertyAttribute(string name);
    public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    public object Value { get; }
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(object value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(Type type, string value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DescriptionAttribute : Attribute {
    public static DescriptionAttribute Default;
    public string Description { get; }
    protected string DescriptionValue { get; protected set; }
    public DescriptionAttribute(string description);
    public virtual string get_Description();
    protected string get_DescriptionValue();
    protected void set_DescriptionValue(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.Design.ActiveDesignerEventArgs : EventArgs {
    public IDesignerHost NewDesigner { get; }
    public IDesignerHost OldDesigner { get; }
    public ActiveDesignerEventArgs(IDesignerHost oldDesigner, IDesignerHost newDesigner);
    public IDesignerHost get_NewDesigner();
    public IDesignerHost get_OldDesigner();
}
public class System.ComponentModel.Design.ActiveDesignerEventHandler : MulticastDelegate {
    public ActiveDesignerEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ActiveDesignerEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ActiveDesignerEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.CheckoutException : ExternalException {
    public static CheckoutException Canceled;
    protected CheckoutException(SerializationInfo info, StreamingContext context);
    public CheckoutException(string message);
    public CheckoutException(string message, Exception innerException);
    public CheckoutException(string message, int errorCode);
}
public class System.ComponentModel.Design.CommandID : object {
    public Guid Guid { get; }
    public int ID { get; }
    public CommandID(Guid menuGroup, int commandID);
    public virtual Guid get_Guid();
    public virtual int get_ID();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.ComponentModel.Design.ComponentChangedEventArgs : EventArgs {
    public object Component { get; }
    public MemberDescriptor Member { get; }
    public object NewValue { get; }
    public object OldValue { get; }
    public ComponentChangedEventArgs(object component, MemberDescriptor member, object oldValue, object newValue);
    public object get_Component();
    public MemberDescriptor get_Member();
    public object get_NewValue();
    public object get_OldValue();
}
public class System.ComponentModel.Design.ComponentChangedEventHandler : MulticastDelegate {
    public ComponentChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.ComponentChangingEventArgs : EventArgs {
    public object Component { get; }
    public MemberDescriptor Member { get; }
    public ComponentChangingEventArgs(object component, MemberDescriptor member);
    public object get_Component();
    public MemberDescriptor get_Member();
}
public class System.ComponentModel.Design.ComponentChangingEventHandler : MulticastDelegate {
    public ComponentChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.ComponentEventArgs : EventArgs {
    public IComponent Component { get; }
    public ComponentEventArgs(IComponent component);
    public virtual IComponent get_Component();
}
public class System.ComponentModel.Design.ComponentEventHandler : MulticastDelegate {
    public ComponentEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.ComponentRenameEventArgs : EventArgs {
    public object Component { get; }
    public string NewName { get; }
    public string OldName { get; }
    public ComponentRenameEventArgs(object component, string oldName, string newName);
    public object get_Component();
    public virtual string get_NewName();
    public virtual string get_OldName();
}
public class System.ComponentModel.Design.ComponentRenameEventHandler : MulticastDelegate {
    public ComponentRenameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentRenameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentRenameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.Design.DesignerCollection : object {
    public int Count { get; }
    public IDesignerHost Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public DesignerCollection(IList designers);
    public DesignerCollection(IDesignerHost[] designers);
    public int get_Count();
    public virtual IDesignerHost get_Item(int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.ComponentModel.Design.DesignerEventArgs : EventArgs {
    public IDesignerHost Designer { get; }
    public DesignerEventArgs(IDesignerHost host);
    public IDesignerHost get_Designer();
}
public class System.ComponentModel.Design.DesignerEventHandler : MulticastDelegate {
    public DesignerEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DesignerEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DesignerEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.ComponentModel.Design.DesignerOptionService : object {
    public DesignerOptionCollection Options { get; }
    public DesignerOptionCollection get_Options();
    protected DesignerOptionCollection CreateOptionCollection(DesignerOptionCollection parent, string name, object value);
    protected virtual void PopulateOptionCollection(DesignerOptionCollection options);
    protected virtual bool ShowDialog(DesignerOptionCollection options, object optionObject);
    private sealed virtual override object System.ComponentModel.Design.IDesignerOptionService.GetOptionValue(string pageName, string valueName);
    private sealed virtual override void System.ComponentModel.Design.IDesignerOptionService.SetOptionValue(string pageName, string valueName, object value);
}
public abstract class System.ComponentModel.Design.DesignerTransaction : object {
    public bool Canceled { get; }
    public bool Committed { get; }
    public string Description { get; }
    protected DesignerTransaction(string description);
    public bool get_Canceled();
    public bool get_Committed();
    public string get_Description();
    public void Cancel();
    public void Commit();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected abstract virtual void OnCancel();
    protected abstract virtual void OnCommit();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class System.ComponentModel.Design.DesignerTransactionCloseEventArgs : EventArgs {
    public bool LastTransaction { get; }
    public bool TransactionCommitted { get; }
    [ObsoleteAttribute("This constructor is obsolete. Use DesignerTransactionCloseEventArgs(bool, bool) instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public DesignerTransactionCloseEventArgs(bool commit);
    public DesignerTransactionCloseEventArgs(bool commit, bool lastTransaction);
    public bool get_LastTransaction();
    public bool get_TransactionCommitted();
}
public class System.ComponentModel.Design.DesignerTransactionCloseEventHandler : MulticastDelegate {
    public DesignerTransactionCloseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DesignerTransactionCloseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DesignerTransactionCloseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.DesignerVerb : MenuCommand {
    public string Description { get; public set; }
    public string Text { get; }
    public DesignerVerb(string text, EventHandler handler);
    public DesignerVerb(string text, EventHandler handler, CommandID startCommandID);
    public string get_Description();
    public void set_Description(string value);
    public string get_Text();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.Design.DesignerVerbCollection : CollectionBase {
    public DesignerVerb Item { get; public set; }
    public DesignerVerbCollection(DesignerVerb[] value);
    public DesignerVerb get_Item(int index);
    public void set_Item(int index, DesignerVerb value);
    public int Add(DesignerVerb value);
    public void AddRange(DesignerVerbCollection value);
    public void AddRange(DesignerVerb[] value);
    public bool Contains(DesignerVerb value);
    public void CopyTo(DesignerVerb[] array, int index);
    public int IndexOf(DesignerVerb value);
    public void Insert(int index, DesignerVerb value);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    protected virtual void OnValidate(object value);
    public void Remove(DesignerVerb value);
}
public class System.ComponentModel.Design.DesigntimeLicenseContext : LicenseContext {
    public LicenseUsageMode UsageMode { get; }
    public virtual LicenseUsageMode get_UsageMode();
    public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly);
    public virtual void SetSavedLicenseKey(Type type, string key);
}
public class System.ComponentModel.Design.DesigntimeLicenseContextSerializer : object {
    public static void Serialize(Stream o, string cryptoKey, DesigntimeLicenseContext context);
}
public enum System.ComponentModel.Design.HelpContextType : Enum {
    public int value__;
    public static HelpContextType Ambient;
    public static HelpContextType Selection;
    public static HelpContextType ToolWindowSelection;
    public static HelpContextType Window;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.Design.HelpKeywordAttribute : Attribute {
    public static HelpKeywordAttribute Default;
    public string HelpKeyword { get; }
    public HelpKeywordAttribute(string keyword);
    public HelpKeywordAttribute(Type t);
    public string get_HelpKeyword();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public enum System.ComponentModel.Design.HelpKeywordType : Enum {
    public int value__;
    public static HelpKeywordType F1Keyword;
    public static HelpKeywordType FilterKeyword;
    public static HelpKeywordType GeneralKeyword;
}
public interface System.ComponentModel.Design.IComponentChangeService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentAdded(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentAdded(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentAdding(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentAdding(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentChanged(ComponentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentChanged(ComponentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentChanging(ComponentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentChanging(ComponentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRemoved(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRemoved(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRemoving(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRemoving(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRename(ComponentRenameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRename(ComponentRenameEventHandler value);
    public abstract virtual void OnComponentChanged(object component, MemberDescriptor member, object oldValue, object newValue);
    public abstract virtual void OnComponentChanging(object component, MemberDescriptor member);
}
public interface System.ComponentModel.Design.IComponentDiscoveryService {
    public abstract virtual ICollection GetComponentTypes(IDesignerHost designerHost, Type baseType);
}
public interface System.ComponentModel.Design.IComponentInitializer {
    public abstract virtual void InitializeExistingComponent(IDictionary defaultValues);
    public abstract virtual void InitializeNewComponent(IDictionary defaultValues);
}
public interface System.ComponentModel.Design.IDesigner {
    public IComponent Component { get; }
    public DesignerVerbCollection Verbs { get; }
    public abstract virtual IComponent get_Component();
    public abstract virtual DesignerVerbCollection get_Verbs();
    public abstract virtual void DoDefaultAction();
    public abstract virtual void Initialize(IComponent component);
}
public interface System.ComponentModel.Design.IDesignerEventService {
    public IDesignerHost ActiveDesigner { get; }
    public DesignerCollection Designers { get; }
    public abstract virtual IDesignerHost get_ActiveDesigner();
    public abstract virtual DesignerCollection get_Designers();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ActiveDesignerChanged(ActiveDesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ActiveDesignerChanged(ActiveDesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DesignerCreated(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DesignerCreated(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DesignerDisposed(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DesignerDisposed(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanged(EventHandler value);
}
public interface System.ComponentModel.Design.IDesignerFilter {
    public abstract virtual void PostFilterAttributes(IDictionary attributes);
    public abstract virtual void PostFilterEvents(IDictionary events);
    public abstract virtual void PostFilterProperties(IDictionary properties);
    public abstract virtual void PreFilterAttributes(IDictionary attributes);
    public abstract virtual void PreFilterEvents(IDictionary events);
    public abstract virtual void PreFilterProperties(IDictionary properties);
}
public interface System.ComponentModel.Design.IDesignerHost {
    public IContainer Container { get; }
    public bool InTransaction { get; }
    public bool Loading { get; }
    public IComponent RootComponent { get; }
    public string RootComponentClassName { get; }
    public string TransactionDescription { get; }
    public abstract virtual IContainer get_Container();
    public abstract virtual bool get_InTransaction();
    public abstract virtual bool get_Loading();
    public abstract virtual IComponent get_RootComponent();
    public abstract virtual string get_RootComponentClassName();
    public abstract virtual string get_TransactionDescription();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LoadComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LoadComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionClosed(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionClosed(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionClosing(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionClosing(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionOpening(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionOpening(EventHandler value);
    public abstract virtual void Activate();
    public abstract virtual IComponent CreateComponent(Type componentClass);
    public abstract virtual IComponent CreateComponent(Type componentClass, string name);
    public abstract virtual DesignerTransaction CreateTransaction();
    public abstract virtual DesignerTransaction CreateTransaction(string description);
    public abstract virtual void DestroyComponent(IComponent component);
    public abstract virtual IDesigner GetDesigner(IComponent component);
    public abstract virtual Type GetType(string typeName);
}
public interface System.ComponentModel.Design.IDesignerHostTransactionState {
    public bool IsClosingTransaction { get; }
    public abstract virtual bool get_IsClosingTransaction();
}
public interface System.ComponentModel.Design.IDesignerOptionService {
    public abstract virtual object GetOptionValue(string pageName, string valueName);
    public abstract virtual void SetOptionValue(string pageName, string valueName, object value);
}
public interface System.ComponentModel.Design.IDictionaryService {
    public abstract virtual object GetKey(object value);
    public abstract virtual object GetValue(object key);
    public abstract virtual void SetValue(object key, object value);
}
public interface System.ComponentModel.Design.IEventBindingService {
    public abstract virtual string CreateUniqueMethodName(IComponent component, EventDescriptor e);
    public abstract virtual ICollection GetCompatibleMethods(EventDescriptor e);
    public abstract virtual EventDescriptor GetEvent(PropertyDescriptor property);
    public abstract virtual PropertyDescriptorCollection GetEventProperties(EventDescriptorCollection events);
    public abstract virtual PropertyDescriptor GetEventProperty(EventDescriptor e);
    public abstract virtual bool ShowCode();
    public abstract virtual bool ShowCode(IComponent component, EventDescriptor e);
    public abstract virtual bool ShowCode(int lineNumber);
}
public interface System.ComponentModel.Design.IExtenderListService {
    public abstract virtual IExtenderProvider[] GetExtenderProviders();
}
public interface System.ComponentModel.Design.IExtenderProviderService {
    public abstract virtual void AddExtenderProvider(IExtenderProvider provider);
    public abstract virtual void RemoveExtenderProvider(IExtenderProvider provider);
}
public interface System.ComponentModel.Design.IHelpService {
    public abstract virtual void AddContextAttribute(string name, string value, HelpKeywordType keywordType);
    public abstract virtual void ClearContextAttributes();
    public abstract virtual IHelpService CreateLocalContext(HelpContextType contextType);
    public abstract virtual void RemoveContextAttribute(string name, string value);
    public abstract virtual void RemoveLocalContext(IHelpService localContext);
    public abstract virtual void ShowHelpFromKeyword(string helpKeyword);
    public abstract virtual void ShowHelpFromUrl(string helpUrl);
}
public interface System.ComponentModel.Design.IInheritanceService {
    public abstract virtual void AddInheritedComponents(IComponent component, IContainer container);
    public abstract virtual InheritanceAttribute GetInheritanceAttribute(IComponent component);
}
public interface System.ComponentModel.Design.IMenuCommandService {
    public DesignerVerbCollection Verbs { get; }
    public abstract virtual DesignerVerbCollection get_Verbs();
    public abstract virtual void AddCommand(MenuCommand command);
    public abstract virtual void AddVerb(DesignerVerb verb);
    public abstract virtual MenuCommand FindCommand(CommandID commandID);
    public abstract virtual bool GlobalInvoke(CommandID commandID);
    public abstract virtual void RemoveCommand(MenuCommand command);
    public abstract virtual void RemoveVerb(DesignerVerb verb);
    public abstract virtual void ShowContextMenu(CommandID menuID, int x, int y);
}
public interface System.ComponentModel.Design.IReferenceService {
    public abstract virtual IComponent GetComponent(object reference);
    public abstract virtual string GetName(object reference);
    public abstract virtual object GetReference(string name);
    public abstract virtual Object[] GetReferences();
    public abstract virtual Object[] GetReferences(Type baseType);
}
public interface System.ComponentModel.Design.IResourceService {
    public abstract virtual IResourceReader GetResourceReader(CultureInfo info);
    public abstract virtual IResourceWriter GetResourceWriter(CultureInfo info);
}
public interface System.ComponentModel.Design.IRootDesigner {
    public ViewTechnology[] SupportedTechnologies { get; }
    public abstract virtual ViewTechnology[] get_SupportedTechnologies();
    public abstract virtual object GetView(ViewTechnology technology);
}
public interface System.ComponentModel.Design.ISelectionService {
    public object PrimarySelection { get; }
    public int SelectionCount { get; }
    public abstract virtual object get_PrimarySelection();
    public abstract virtual int get_SelectionCount();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanging(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanging(EventHandler value);
    public abstract virtual bool GetComponentSelected(object component);
    public abstract virtual ICollection GetSelectedComponents();
    public abstract virtual void SetSelectedComponents(ICollection components);
    public abstract virtual void SetSelectedComponents(ICollection components, SelectionTypes selectionType);
}
public interface System.ComponentModel.Design.IServiceContainer {
    public abstract virtual void AddService(Type serviceType, ServiceCreatorCallback callback);
    public abstract virtual void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote);
    public abstract virtual void AddService(Type serviceType, object serviceInstance);
    public abstract virtual void AddService(Type serviceType, object serviceInstance, bool promote);
    public abstract virtual void RemoveService(Type serviceType);
    public abstract virtual void RemoveService(Type serviceType, bool promote);
}
public interface System.ComponentModel.Design.ITreeDesigner {
    public ICollection Children { get; }
    public IDesigner Parent { get; }
    public abstract virtual ICollection get_Children();
    public abstract virtual IDesigner get_Parent();
}
public interface System.ComponentModel.Design.ITypeDescriptorFilterService {
    public abstract virtual bool FilterAttributes(IComponent component, IDictionary attributes);
    public abstract virtual bool FilterEvents(IComponent component, IDictionary events);
    public abstract virtual bool FilterProperties(IComponent component, IDictionary properties);
}
public interface System.ComponentModel.Design.ITypeDiscoveryService {
    public abstract virtual ICollection GetTypes(Type baseType, bool excludeGlobalTypes);
}
public interface System.ComponentModel.Design.ITypeResolutionService {
    public abstract virtual Assembly GetAssembly(AssemblyName name);
    public abstract virtual Assembly GetAssembly(AssemblyName name, bool throwOnError);
    public abstract virtual string GetPathOfAssembly(AssemblyName name);
    public abstract virtual Type GetType(string name);
    public abstract virtual Type GetType(string name, bool throwOnError);
    public abstract virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public abstract virtual void ReferenceAssembly(AssemblyName name);
}
public class System.ComponentModel.Design.MenuCommand : object {
    public bool Checked { get; public set; }
    public CommandID CommandID { get; }
    public bool Enabled { get; public set; }
    public int OleStatus { get; }
    public IDictionary Properties { get; }
    public bool Supported { get; public set; }
    public bool Visible { get; public set; }
    public MenuCommand(EventHandler handler, CommandID command);
    public virtual bool get_Checked();
    public virtual void set_Checked(bool value);
    public virtual CommandID get_CommandID();
    public virtual bool get_Enabled();
    public virtual void set_Enabled(bool value);
    public virtual int get_OleStatus();
    public virtual IDictionary get_Properties();
    public virtual bool get_Supported();
    public virtual void set_Supported(bool value);
    public virtual bool get_Visible();
    public virtual void set_Visible(bool value);
    public void add_CommandChanged(EventHandler value);
    public void remove_CommandChanged(EventHandler value);
    public virtual void Invoke();
    public virtual void Invoke(object arg);
    protected virtual void OnCommandChanged(EventArgs e);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.ComponentModel.Design.SelectionTypes : Enum {
    public int value__;
    public static SelectionTypes Add;
    public static SelectionTypes Auto;
    [ObsoleteAttribute("This value has been deprecated. Use SelectionTypes.Primary instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Click;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. https://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes MouseDown;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. https://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes MouseUp;
    [ObsoleteAttribute("This value has been deprecated. Use SelectionTypes.Auto instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Normal;
    public static SelectionTypes Primary;
    public static SelectionTypes Remove;
    public static SelectionTypes Replace;
    public static SelectionTypes Toggle;
    [ObsoleteAttribute("This value has been deprecated. Use Enum class methods to determine valid values, or use a type converter. https://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Valid;
}
public abstract class System.ComponentModel.Design.Serialization.ComponentSerializationService : object {
    public abstract virtual SerializationStore CreateStore();
    public abstract virtual ICollection Deserialize(SerializationStore store);
    public abstract virtual ICollection Deserialize(SerializationStore store, IContainer container);
    public void DeserializeTo(SerializationStore store, IContainer container);
    public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes);
    public abstract virtual void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes, bool applyDefaults);
    public abstract virtual SerializationStore LoadStore(Stream stream);
    public abstract virtual void Serialize(SerializationStore store, object value);
    public abstract virtual void SerializeAbsolute(SerializationStore store, object value);
    public abstract virtual void SerializeMember(SerializationStore store, object owningObject, MemberDescriptor member);
    public abstract virtual void SerializeMemberAbsolute(SerializationStore store, object owningObject, MemberDescriptor member);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.Design.Serialization.ContextStack : object {
    public object Current { get; }
    public object Item { get; }
    public object Item { get; }
    public object get_Current();
    public object get_Item(int level);
    public object get_Item(Type type);
    public void Append(object context);
    public object Pop();
    public void Push(object context);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.Design.Serialization.DefaultSerializationProviderAttribute : Attribute {
    public string ProviderTypeName { get; }
    public DefaultSerializationProviderAttribute(string providerTypeName);
    public DefaultSerializationProviderAttribute(Type providerType);
    public string get_ProviderTypeName();
}
public abstract class System.ComponentModel.Design.Serialization.DesignerLoader : object {
    public bool Loading { get; }
    public virtual bool get_Loading();
    public abstract virtual void BeginLoad(IDesignerLoaderHost host);
    public abstract virtual void Dispose();
    public virtual void Flush();
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.Design.Serialization.DesignerSerializerAttribute : Attribute {
    public string SerializerBaseTypeName { get; }
    public string SerializerTypeName { get; }
    public object TypeId { get; }
    public DesignerSerializerAttribute(string serializerTypeName, string baseSerializerTypeName);
    public DesignerSerializerAttribute(string serializerTypeName, Type baseSerializerType);
    public DesignerSerializerAttribute(Type serializerType, Type baseSerializerType);
    public string get_SerializerBaseTypeName();
    public string get_SerializerTypeName();
    public virtual object get_TypeId();
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderHost {
    public abstract virtual void EndLoad(string baseClassName, bool successful, ICollection errorCollection);
    public abstract virtual void Reload();
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderHost2 {
    public bool CanReloadWithErrors { get; public set; }
    public bool IgnoreErrorsDuringReload { get; public set; }
    public abstract virtual bool get_CanReloadWithErrors();
    public abstract virtual void set_CanReloadWithErrors(bool value);
    public abstract virtual bool get_IgnoreErrorsDuringReload();
    public abstract virtual void set_IgnoreErrorsDuringReload(bool value);
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderService {
    public abstract virtual void AddLoadDependency();
    public abstract virtual void DependentLoadComplete(bool successful, ICollection errorCollection);
    public abstract virtual bool Reload();
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationManager {
    public ContextStack Context { get; }
    public PropertyDescriptorCollection Properties { get; }
    public abstract virtual ContextStack get_Context();
    public abstract virtual PropertyDescriptorCollection get_Properties();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResolveName(ResolveNameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResolveName(ResolveNameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SerializationComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SerializationComplete(EventHandler value);
    public abstract virtual void AddSerializationProvider(IDesignerSerializationProvider provider);
    public abstract virtual object CreateInstance(Type type, ICollection arguments, string name, bool addToContainer);
    public abstract virtual object GetInstance(string name);
    public abstract virtual string GetName(object value);
    public abstract virtual object GetSerializer(Type objectType, Type serializerType);
    public abstract virtual Type GetType(string typeName);
    public abstract virtual void RemoveSerializationProvider(IDesignerSerializationProvider provider);
    public abstract virtual void ReportError(object errorInformation);
    public abstract virtual void SetName(object instance, string name);
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationProvider {
    public abstract virtual object GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType);
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationService {
    public abstract virtual ICollection Deserialize(object serializationData);
    public abstract virtual object Serialize(ICollection objects);
}
public interface System.ComponentModel.Design.Serialization.INameCreationService {
    public abstract virtual string CreateName(IContainer container, Type dataType);
    public abstract virtual bool IsValidName(string name);
    public abstract virtual void ValidateName(string name);
}
public class System.ComponentModel.Design.Serialization.InstanceDescriptor : object {
    public ICollection Arguments { get; }
    public bool IsComplete { get; }
    public MemberInfo MemberInfo { get; }
    public InstanceDescriptor(MemberInfo member, ICollection arguments);
    public InstanceDescriptor(MemberInfo member, ICollection arguments, bool isComplete);
    public ICollection get_Arguments();
    public bool get_IsComplete();
    public MemberInfo get_MemberInfo();
    public object Invoke();
}
[IsReadOnlyAttribute]
public class System.ComponentModel.Design.Serialization.MemberRelationship : ValueType {
    private object _dummy;
    public static MemberRelationship Empty;
    public bool IsEmpty { get; }
    public MemberDescriptor Member { get; }
    public object Owner { get; }
    public MemberRelationship(object owner, MemberDescriptor member);
    public bool get_IsEmpty();
    public MemberDescriptor get_Member();
    public object get_Owner();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberRelationship left, MemberRelationship right);
    public static bool op_Inequality(MemberRelationship left, MemberRelationship right);
}
[DefaultMemberAttribute("Item")]
public abstract class System.ComponentModel.Design.Serialization.MemberRelationshipService : object {
    public MemberRelationship Item { get; public set; }
    public MemberRelationship Item { get; public set; }
    public MemberRelationship get_Item(MemberRelationship source);
    public void set_Item(MemberRelationship source, MemberRelationship value);
    public MemberRelationship get_Item(object sourceOwner, MemberDescriptor sourceMember);
    public void set_Item(object sourceOwner, MemberDescriptor sourceMember, MemberRelationship value);
    protected virtual MemberRelationship GetRelationship(MemberRelationship source);
    protected virtual void SetRelationship(MemberRelationship source, MemberRelationship relationship);
    public abstract virtual bool SupportsRelationship(MemberRelationship source, MemberRelationship relationship);
}
public class System.ComponentModel.Design.Serialization.ResolveNameEventArgs : EventArgs {
    public string Name { get; }
    public object Value { get; public set; }
    public ResolveNameEventArgs(string name);
    public string get_Name();
    public object get_Value();
    public void set_Value(object value);
}
public class System.ComponentModel.Design.Serialization.ResolveNameEventHandler : MulticastDelegate {
    public ResolveNameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ResolveNameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveNameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1028")]
[ObsoleteAttribute("This attribute has been deprecated. Use DesignerSerializerAttribute instead.  For example, to specify a root designer for CodeDom, use DesignerSerializerAttribute(...,typeof(TypeCodeDomSerializer)).  https://go.microsoft.com/fwlink/?linkid=14202")]
public class System.ComponentModel.Design.Serialization.RootDesignerSerializerAttribute : Attribute {
    public bool Reloadable { get; }
    public string SerializerBaseTypeName { get; }
    public string SerializerTypeName { get; }
    public object TypeId { get; }
    public RootDesignerSerializerAttribute(string serializerTypeName, string baseSerializerTypeName, bool reloadable);
    public RootDesignerSerializerAttribute(string serializerTypeName, Type baseSerializerType, bool reloadable);
    public RootDesignerSerializerAttribute(Type serializerType, Type baseSerializerType, bool reloadable);
    public bool get_Reloadable();
    public string get_SerializerBaseTypeName();
    public string get_SerializerTypeName();
    public virtual object get_TypeId();
}
public abstract class System.ComponentModel.Design.Serialization.SerializationStore : object {
    public ICollection Errors { get; }
    public abstract virtual ICollection get_Errors();
    public abstract virtual void Close();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Save(Stream stream);
    private sealed virtual override void System.IDisposable.Dispose();
}
public class System.ComponentModel.Design.ServiceContainer : object {
    protected Type[] DefaultServices { get; }
    public ServiceContainer(IServiceProvider parentProvider);
    protected virtual Type[] get_DefaultServices();
    public sealed virtual void AddService(Type serviceType, ServiceCreatorCallback callback);
    public virtual void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote);
    public sealed virtual void AddService(Type serviceType, object serviceInstance);
    public virtual void AddService(Type serviceType, object serviceInstance, bool promote);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual object GetService(Type serviceType);
    public sealed virtual void RemoveService(Type serviceType);
    public virtual void RemoveService(Type serviceType, bool promote);
}
public class System.ComponentModel.Design.ServiceCreatorCallback : MulticastDelegate {
    public ServiceCreatorCallback(object object, IntPtr method);
    public virtual object Invoke(IServiceContainer container, Type serviceType);
    public virtual IAsyncResult BeginInvoke(IServiceContainer container, Type serviceType, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.StandardCommands : object {
    public static CommandID AlignBottom;
    public static CommandID AlignHorizontalCenters;
    public static CommandID AlignLeft;
    public static CommandID AlignRight;
    public static CommandID AlignToGrid;
    public static CommandID AlignTop;
    public static CommandID AlignVerticalCenters;
    public static CommandID ArrangeBottom;
    public static CommandID ArrangeIcons;
    public static CommandID ArrangeRight;
    public static CommandID BringForward;
    public static CommandID BringToFront;
    public static CommandID CenterHorizontally;
    public static CommandID CenterVertically;
    public static CommandID Copy;
    public static CommandID Cut;
    public static CommandID Delete;
    public static CommandID DocumentOutline;
    public static CommandID F1Help;
    public static CommandID Group;
    public static CommandID HorizSpaceConcatenate;
    public static CommandID HorizSpaceDecrease;
    public static CommandID HorizSpaceIncrease;
    public static CommandID HorizSpaceMakeEqual;
    public static CommandID LineupIcons;
    public static CommandID LockControls;
    public static CommandID MultiLevelRedo;
    public static CommandID MultiLevelUndo;
    public static CommandID Paste;
    public static CommandID Properties;
    public static CommandID PropertiesWindow;
    public static CommandID Redo;
    public static CommandID Replace;
    public static CommandID SelectAll;
    public static CommandID SendBackward;
    public static CommandID SendToBack;
    public static CommandID ShowGrid;
    public static CommandID ShowLargeIcons;
    public static CommandID SizeToControl;
    public static CommandID SizeToControlHeight;
    public static CommandID SizeToControlWidth;
    public static CommandID SizeToFit;
    public static CommandID SizeToGrid;
    public static CommandID SnapToGrid;
    public static CommandID TabOrder;
    public static CommandID Undo;
    public static CommandID Ungroup;
    public static CommandID VerbFirst;
    public static CommandID VerbLast;
    public static CommandID VertSpaceConcatenate;
    public static CommandID VertSpaceDecrease;
    public static CommandID VertSpaceIncrease;
    public static CommandID VertSpaceMakeEqual;
    public static CommandID ViewCode;
    public static CommandID ViewGrid;
}
public class System.ComponentModel.Design.StandardToolWindows : object {
    public static Guid ObjectBrowser;
    public static Guid OutputWindow;
    public static Guid ProjectExplorer;
    public static Guid PropertyBrowser;
    public static Guid RelatedLinks;
    public static Guid ServerExplorer;
    public static Guid TaskList;
    public static Guid Toolbox;
}
public abstract class System.ComponentModel.Design.TypeDescriptionProviderService : object {
    public abstract virtual TypeDescriptionProvider GetProvider(object instance);
    public abstract virtual TypeDescriptionProvider GetProvider(Type type);
}
public enum System.ComponentModel.Design.ViewTechnology : Enum {
    public int value__;
    public static ViewTechnology Default;
    [ObsoleteAttribute("This value has been deprecated. Use ViewTechnology.Default instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public static ViewTechnology Passthrough;
    [ObsoleteAttribute("This value has been deprecated. Use ViewTechnology.Default instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public static ViewTechnology WindowsForms;
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.DesignerAttribute : Attribute {
    public string DesignerBaseTypeName { get; }
    public string DesignerTypeName { get; }
    public object TypeId { get; }
    public DesignerAttribute(string designerTypeName);
    public DesignerAttribute(string designerTypeName, string designerBaseTypeName);
    public DesignerAttribute(string designerTypeName, Type designerBaseType);
    public DesignerAttribute(Type designerType);
    public DesignerAttribute(Type designerType, Type designerBaseType);
    public string get_DesignerBaseTypeName();
    public string get_DesignerTypeName();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DesignerCategoryAttribute : Attribute {
    public static DesignerCategoryAttribute Component;
    public static DesignerCategoryAttribute Default;
    public static DesignerCategoryAttribute Form;
    public static DesignerCategoryAttribute Generic;
    public string Category { get; }
    public object TypeId { get; }
    public DesignerCategoryAttribute(string category);
    public string get_Category();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public enum System.ComponentModel.DesignerSerializationVisibility : Enum {
    public int value__;
    public static DesignerSerializationVisibility Content;
    public static DesignerSerializationVisibility Hidden;
    public static DesignerSerializationVisibility Visible;
}
[AttributeUsageAttribute("960")]
public class System.ComponentModel.DesignerSerializationVisibilityAttribute : Attribute {
    public static DesignerSerializationVisibilityAttribute Content;
    public static DesignerSerializationVisibilityAttribute Default;
    public static DesignerSerializationVisibilityAttribute Hidden;
    public static DesignerSerializationVisibilityAttribute Visible;
    public DesignerSerializationVisibility Visibility { get; }
    public DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility visibility);
    public DesignerSerializationVisibility get_Visibility();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DesignOnlyAttribute : Attribute {
    public static DesignOnlyAttribute Default;
    public static DesignOnlyAttribute No;
    public static DesignOnlyAttribute Yes;
    public bool IsDesignOnly { get; }
    public DesignOnlyAttribute(bool isDesignOnly);
    public bool get_IsDesignOnly();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.DesignTimeVisibleAttribute : Attribute {
    public static DesignTimeVisibleAttribute Default;
    public static DesignTimeVisibleAttribute No;
    public static DesignTimeVisibleAttribute Yes;
    public bool Visible { get; }
    public DesignTimeVisibleAttribute(bool visible);
    public bool get_Visible();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("708")]
public class System.ComponentModel.DisplayNameAttribute : Attribute {
    public static DisplayNameAttribute Default;
    public string DisplayName { get; }
    protected string DisplayNameValue { get; protected set; }
    public DisplayNameAttribute(string displayName);
    public virtual string get_DisplayName();
    protected string get_DisplayNameValue();
    protected void set_DisplayNameValue(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.DoubleConverter : BaseNumberConverter {
}
public class System.ComponentModel.DoWorkEventArgs : CancelEventArgs {
    public object Argument { get; }
    public object Result { get; public set; }
    public DoWorkEventArgs(object argument);
    public object get_Argument();
    public object get_Result();
    public void set_Result(object value);
}
public class System.ComponentModel.DoWorkEventHandler : MulticastDelegate {
    public DoWorkEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DoWorkEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DoWorkEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.EditorAttribute : Attribute {
    public string EditorBaseTypeName { get; }
    public string EditorTypeName { get; }
    public object TypeId { get; }
    public EditorAttribute(string typeName, string baseTypeName);
    public EditorAttribute(string typeName, Type baseType);
    public EditorAttribute(Type type, Type baseType);
    public string get_EditorBaseTypeName();
    public string get_EditorTypeName();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Advanced;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
}
public class System.ComponentModel.EnumConverter : TypeConverter {
    protected IComparer Comparer { get; }
    protected Type EnumType { get; }
    protected StandardValuesCollection Values { get; protected set; }
    public EnumConverter(Type type);
    protected virtual IComparer get_Comparer();
    protected Type get_EnumType();
    protected StandardValuesCollection get_Values();
    protected void set_Values(StandardValuesCollection value);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
public abstract class System.ComponentModel.EventDescriptor : MemberDescriptor {
    public Type ComponentType { get; }
    public Type EventType { get; }
    public bool IsMulticast { get; }
    protected EventDescriptor(MemberDescriptor descr);
    protected EventDescriptor(MemberDescriptor descr, Attribute[] attrs);
    protected EventDescriptor(string name, Attribute[] attrs);
    public abstract virtual Type get_ComponentType();
    public abstract virtual Type get_EventType();
    public abstract virtual bool get_IsMulticast();
    public abstract virtual void AddEventHandler(object component, Delegate value);
    public abstract virtual void RemoveEventHandler(object component, Delegate value);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.EventDescriptorCollection : object {
    public static EventDescriptorCollection Empty;
    public int Count { get; }
    public EventDescriptor Item { get; }
    public EventDescriptor Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public EventDescriptorCollection(EventDescriptor[] events);
    public EventDescriptorCollection(EventDescriptor[] events, bool readOnly);
    public int get_Count();
    public virtual EventDescriptor get_Item(int index);
    public virtual EventDescriptor get_Item(string name);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(EventDescriptor value);
    public void Clear();
    public bool Contains(EventDescriptor value);
    public virtual EventDescriptor Find(string name, bool ignoreCase);
    public IEnumerator GetEnumerator();
    public int IndexOf(EventDescriptor value);
    public void Insert(int index, EventDescriptor value);
    protected void InternalSort(IComparer sorter);
    protected void InternalSort(String[] names);
    public void Remove(EventDescriptor value);
    public void RemoveAt(int index);
    public virtual EventDescriptorCollection Sort();
    public virtual EventDescriptorCollection Sort(IComparer comparer);
    public virtual EventDescriptorCollection Sort(String[] names);
    public virtual EventDescriptorCollection Sort(String[] names, IComparer comparer);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.EventHandlerList : object {
    public Delegate Item { get; public set; }
    public Delegate get_Item(object key);
    public void set_Item(object key, Delegate value);
    public void AddHandler(object key, Delegate value);
    public void AddHandlers(EventHandlerList listToAddFrom);
    public sealed virtual void Dispose();
    public void RemoveHandler(object key, Delegate value);
}
public class System.ComponentModel.ExpandableObjectConverter : TypeConverter {
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ExtenderProvidedPropertyAttribute : Attribute {
    public PropertyDescriptor ExtenderProperty { get; }
    public IExtenderProvider Provider { get; }
    public Type ReceiverType { get; }
    public PropertyDescriptor get_ExtenderProperty();
    public IExtenderProvider get_Provider();
    public Type get_ReceiverType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.GuidConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.HandledEventArgs : EventArgs {
    public bool Handled { get; public set; }
    public HandledEventArgs(bool defaultHandledValue);
    public bool get_Handled();
    public void set_Handled(bool value);
}
public class System.ComponentModel.HandledEventHandler : MulticastDelegate {
    public HandledEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HandledEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, HandledEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.ComponentModel.IBindingList {
    public bool AllowEdit { get; }
    public bool AllowNew { get; }
    public bool AllowRemove { get; }
    public bool IsSorted { get; }
    public ListSortDirection SortDirection { get; }
    public PropertyDescriptor SortProperty { get; }
    public bool SupportsChangeNotification { get; }
    public bool SupportsSearching { get; }
    public bool SupportsSorting { get; }
    public abstract virtual bool get_AllowEdit();
    public abstract virtual bool get_AllowNew();
    public abstract virtual bool get_AllowRemove();
    public abstract virtual bool get_IsSorted();
    public abstract virtual ListSortDirection get_SortDirection();
    public abstract virtual PropertyDescriptor get_SortProperty();
    public abstract virtual bool get_SupportsChangeNotification();
    public abstract virtual bool get_SupportsSearching();
    public abstract virtual bool get_SupportsSorting();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ListChanged(ListChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ListChanged(ListChangedEventHandler value);
    public abstract virtual void AddIndex(PropertyDescriptor property);
    public abstract virtual object AddNew();
    public abstract virtual void ApplySort(PropertyDescriptor property, ListSortDirection direction);
    public abstract virtual int Find(PropertyDescriptor property, object key);
    public abstract virtual void RemoveIndex(PropertyDescriptor property);
    public abstract virtual void RemoveSort();
}
public interface System.ComponentModel.IBindingListView {
    public string Filter { get; public set; }
    public ListSortDescriptionCollection SortDescriptions { get; }
    public bool SupportsAdvancedSorting { get; }
    public bool SupportsFiltering { get; }
    public abstract virtual string get_Filter();
    public abstract virtual void set_Filter(string value);
    public abstract virtual ListSortDescriptionCollection get_SortDescriptions();
    public abstract virtual bool get_SupportsAdvancedSorting();
    public abstract virtual bool get_SupportsFiltering();
    public abstract virtual void ApplySort(ListSortDescriptionCollection sorts);
    public abstract virtual void RemoveFilter();
}
public interface System.ComponentModel.ICancelAddNew {
    public abstract virtual void CancelNew(int itemIndex);
    public abstract virtual void EndNew(int itemIndex);
}
public interface System.ComponentModel.IChangeTracking {
    public bool IsChanged { get; }
    public abstract virtual bool get_IsChanged();
    public abstract virtual void AcceptChanges();
}
[ObsoleteAttribute("This interface has been deprecated. Add a TypeDescriptionProvider to handle type TypeDescriptor.ComObjectType instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public interface System.ComponentModel.IComNativeDescriptorHandler {
    public abstract virtual AttributeCollection GetAttributes(object component);
    public abstract virtual string GetClassName(object component);
    public abstract virtual TypeConverter GetConverter(object component);
    public abstract virtual EventDescriptor GetDefaultEvent(object component);
    public abstract virtual PropertyDescriptor GetDefaultProperty(object component);
    public abstract virtual object GetEditor(object component, Type baseEditorType);
    public abstract virtual EventDescriptorCollection GetEvents(object component);
    public abstract virtual EventDescriptorCollection GetEvents(object component, Attribute[] attributes);
    public abstract virtual string GetName(object component);
    public abstract virtual PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);
    public abstract virtual object GetPropertyValue(object component, int dispid, Boolean& success);
    public abstract virtual object GetPropertyValue(object component, string propertyName, Boolean& success);
}
public interface System.ComponentModel.IComponent {
    public ISite Site { get; public set; }
    public abstract virtual ISite get_Site();
    public abstract virtual void set_Site(ISite value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Disposed(EventHandler value);
}
public interface System.ComponentModel.IContainer {
    public ComponentCollection Components { get; }
    public abstract virtual ComponentCollection get_Components();
    public abstract virtual void Add(IComponent component);
    public abstract virtual void Add(IComponent component, string name);
    public abstract virtual void Remove(IComponent component);
}
public interface System.ComponentModel.ICustomTypeDescriptor {
    public abstract virtual AttributeCollection GetAttributes();
    public abstract virtual string GetClassName();
    public abstract virtual string GetComponentName();
    public abstract virtual TypeConverter GetConverter();
    public abstract virtual EventDescriptor GetDefaultEvent();
    public abstract virtual PropertyDescriptor GetDefaultProperty();
    public abstract virtual object GetEditor(Type editorBaseType);
    public abstract virtual EventDescriptorCollection GetEvents();
    public abstract virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public abstract virtual PropertyDescriptorCollection GetProperties();
    public abstract virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public abstract virtual object GetPropertyOwner(PropertyDescriptor pd);
}
[DefaultMemberAttribute("Item")]
public interface System.ComponentModel.IDataErrorInfo {
    public string Error { get; }
    public string Item { get; }
    public abstract virtual string get_Error();
    public abstract virtual string get_Item(string columnName);
}
public interface System.ComponentModel.IEditableObject {
    public abstract virtual void BeginEdit();
    public abstract virtual void CancelEdit();
    public abstract virtual void EndEdit();
}
public interface System.ComponentModel.IExtenderProvider {
    public abstract virtual bool CanExtend(object extendee);
}
public interface System.ComponentModel.IIntellisenseBuilder {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool Show(string language, string value, String& newValue);
}
[MergablePropertyAttribute("False")]
public interface System.ComponentModel.IListSource {
    public bool ContainsListCollection { get; }
    public abstract virtual bool get_ContainsListCollection();
    public abstract virtual IList GetList();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ImmutableObjectAttribute : Attribute {
    public static ImmutableObjectAttribute Default;
    public static ImmutableObjectAttribute No;
    public static ImmutableObjectAttribute Yes;
    public bool Immutable { get; }
    public ImmutableObjectAttribute(bool immutable);
    public bool get_Immutable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public interface System.ComponentModel.INestedContainer {
    public IComponent Owner { get; }
    public abstract virtual IComponent get_Owner();
}
public interface System.ComponentModel.INestedSite {
    public string FullName { get; }
    public abstract virtual string get_FullName();
}
[AttributeUsageAttribute("896")]
public class System.ComponentModel.InheritanceAttribute : Attribute {
    public static InheritanceAttribute Default;
    public static InheritanceAttribute Inherited;
    public static InheritanceAttribute InheritedReadOnly;
    public static InheritanceAttribute NotInherited;
    public InheritanceLevel InheritanceLevel { get; }
    public InheritanceAttribute(InheritanceLevel inheritanceLevel);
    public InheritanceLevel get_InheritanceLevel();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
    public virtual string ToString();
}
public enum System.ComponentModel.InheritanceLevel : Enum {
    public int value__;
    public static InheritanceLevel Inherited;
    public static InheritanceLevel InheritedReadOnly;
    public static InheritanceLevel NotInherited;
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.InitializationEventAttribute : Attribute {
    public string EventName { get; }
    public InitializationEventAttribute(string eventName);
    public string get_EventName();
}
public interface System.ComponentModel.INotifyDataErrorInfo {
    public bool HasErrors { get; }
    public abstract virtual bool get_HasErrors();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    public abstract virtual IEnumerable GetErrors(string propertyName);
}
public interface System.ComponentModel.INotifyPropertyChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public interface System.ComponentModel.INotifyPropertyChanging {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.InstallerTypeAttribute : Attribute {
    public Type InstallerType { get; }
    public InstallerTypeAttribute(string typeName);
    public InstallerTypeAttribute(Type installerType);
    public virtual Type get_InstallerType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.ComponentModel.InstanceCreationEditor : object {
    public string Text { get; }
    public virtual string get_Text();
    public abstract virtual object CreateInstance(ITypeDescriptorContext context, Type instanceType);
}
public class System.ComponentModel.Int16Converter : BaseNumberConverter {
}
public class System.ComponentModel.Int32Converter : BaseNumberConverter {
}
public class System.ComponentModel.Int64Converter : BaseNumberConverter {
}
public class System.ComponentModel.InvalidAsynchronousStateException : ArgumentException {
    protected InvalidAsynchronousStateException(SerializationInfo info, StreamingContext context);
    public InvalidAsynchronousStateException(string message);
    public InvalidAsynchronousStateException(string message, Exception innerException);
}
public class System.ComponentModel.InvalidEnumArgumentException : ArgumentException {
    protected InvalidEnumArgumentException(SerializationInfo info, StreamingContext context);
    public InvalidEnumArgumentException(string message);
    public InvalidEnumArgumentException(string message, Exception innerException);
    public InvalidEnumArgumentException(string argumentName, int invalidValue, Type enumClass);
}
public interface System.ComponentModel.IRaiseItemChangedEvents {
    public bool RaisesItemChangedEvents { get; }
    public abstract virtual bool get_RaisesItemChangedEvents();
}
public interface System.ComponentModel.IRevertibleChangeTracking {
    public abstract virtual void RejectChanges();
}
public interface System.ComponentModel.ISite {
    public IComponent Component { get; }
    public IContainer Container { get; }
    public bool DesignMode { get; }
    public string Name { get; public set; }
    public abstract virtual IComponent get_Component();
    public abstract virtual IContainer get_Container();
    public abstract virtual bool get_DesignMode();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public interface System.ComponentModel.ISupportInitialize {
    public abstract virtual void BeginInit();
    public abstract virtual void EndInit();
}
public interface System.ComponentModel.ISupportInitializeNotification {
    public bool IsInitialized { get; }
    public abstract virtual bool get_IsInitialized();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Initialized(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Initialized(EventHandler value);
}
public interface System.ComponentModel.ISynchronizeInvoke {
    public bool InvokeRequired { get; }
    public abstract virtual bool get_InvokeRequired();
    public abstract virtual IAsyncResult BeginInvoke(Delegate method, Object[] args);
    public abstract virtual object EndInvoke(IAsyncResult result);
    public abstract virtual object Invoke(Delegate method, Object[] args);
}
public interface System.ComponentModel.ITypeDescriptorContext {
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public abstract virtual IContainer get_Container();
    public abstract virtual object get_Instance();
    public abstract virtual PropertyDescriptor get_PropertyDescriptor();
    public abstract virtual void OnComponentChanged();
    public abstract virtual bool OnComponentChanging();
}
public interface System.ComponentModel.ITypedList {
    public abstract virtual PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors);
    public abstract virtual string GetListName(PropertyDescriptor[] listAccessors);
}
public abstract class System.ComponentModel.License : object {
    public string LicenseKey { get; }
    public abstract virtual string get_LicenseKey();
    public abstract virtual void Dispose();
}
public class System.ComponentModel.LicenseContext : object {
    public LicenseUsageMode UsageMode { get; }
    public virtual LicenseUsageMode get_UsageMode();
    public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly);
    public virtual object GetService(Type type);
    public virtual void SetSavedLicenseKey(Type type, string key);
}
public class System.ComponentModel.LicenseException : SystemException {
    public Type LicensedType { get; }
    protected LicenseException(SerializationInfo info, StreamingContext context);
    public LicenseException(Type type);
    public LicenseException(Type type, object instance);
    public LicenseException(Type type, object instance, string message);
    public LicenseException(Type type, object instance, string message, Exception innerException);
    public Type get_LicensedType();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ComponentModel.LicenseManager : object {
    public static LicenseContext CurrentContext { get; public set; }
    public static LicenseUsageMode UsageMode { get; }
    public static LicenseContext get_CurrentContext();
    public static void set_CurrentContext(LicenseContext value);
    public static LicenseUsageMode get_UsageMode();
    public static object CreateWithContext(Type type, LicenseContext creationContext);
    public static object CreateWithContext(Type type, LicenseContext creationContext, Object[] args);
    public static bool IsLicensed(Type type);
    public static bool IsValid(Type type);
    public static bool IsValid(Type type, object instance, License& license);
    public static void LockContext(object contextUser);
    public static void UnlockContext(object contextUser);
    public static void Validate(Type type);
    public static License Validate(Type type, object instance);
}
public abstract class System.ComponentModel.LicenseProvider : object {
    public abstract virtual License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.LicenseProviderAttribute : Attribute {
    public static LicenseProviderAttribute Default;
    public Type LicenseProvider { get; }
    public object TypeId { get; }
    public LicenseProviderAttribute(string typeName);
    public LicenseProviderAttribute(Type type);
    public Type get_LicenseProvider();
    public virtual object get_TypeId();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.LicenseUsageMode : Enum {
    public int value__;
    public static LicenseUsageMode Designtime;
    public static LicenseUsageMode Runtime;
}
public class System.ComponentModel.LicFileLicenseProvider : LicenseProvider {
    protected virtual string GetKey(Type type);
    public virtual License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions);
    protected virtual bool IsKeyValid(string key, Type type);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ListBindableAttribute : Attribute {
    public static ListBindableAttribute Default;
    public static ListBindableAttribute No;
    public static ListBindableAttribute Yes;
    public bool ListBindable { get; }
    public ListBindableAttribute(bool listBindable);
    public ListBindableAttribute(BindableSupport flags);
    public bool get_ListBindable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ListChangedEventArgs : EventArgs {
    public ListChangedType ListChangedType { get; }
    public int NewIndex { get; }
    public int OldIndex { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public ListChangedEventArgs(ListChangedType listChangedType, PropertyDescriptor propDesc);
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex);
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, PropertyDescriptor propDesc);
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, int oldIndex);
    public ListChangedType get_ListChangedType();
    public int get_NewIndex();
    public int get_OldIndex();
    public PropertyDescriptor get_PropertyDescriptor();
}
public class System.ComponentModel.ListChangedEventHandler : MulticastDelegate {
    public ListChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ListChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ListChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ComponentModel.ListChangedType : Enum {
    public int value__;
    public static ListChangedType ItemAdded;
    public static ListChangedType ItemChanged;
    public static ListChangedType ItemDeleted;
    public static ListChangedType ItemMoved;
    public static ListChangedType PropertyDescriptorAdded;
    public static ListChangedType PropertyDescriptorChanged;
    public static ListChangedType PropertyDescriptorDeleted;
    public static ListChangedType Reset;
}
public class System.ComponentModel.ListSortDescription : object {
    public PropertyDescriptor PropertyDescriptor { get; public set; }
    public ListSortDirection SortDirection { get; public set; }
    public ListSortDescription(PropertyDescriptor property, ListSortDirection direction);
    public PropertyDescriptor get_PropertyDescriptor();
    public void set_PropertyDescriptor(PropertyDescriptor value);
    public ListSortDirection get_SortDirection();
    public void set_SortDirection(ListSortDirection value);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.ListSortDescriptionCollection : object {
    public int Count { get; }
    public ListSortDescription Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ListSortDescriptionCollection(ListSortDescription[] sorts);
    public sealed virtual int get_Count();
    public ListSortDescription get_Item(int index);
    public void set_Item(int index, ListSortDescription value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int IndexOf(object value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
public enum System.ComponentModel.ListSortDirection : Enum {
    public int value__;
    public static ListSortDirection Ascending;
    public static ListSortDirection Descending;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.LocalizableAttribute : Attribute {
    public static LocalizableAttribute Default;
    public static LocalizableAttribute No;
    public static LocalizableAttribute Yes;
    public bool IsLocalizable { get; }
    public LocalizableAttribute(bool isLocalizable);
    public bool get_IsLocalizable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.LookupBindingPropertiesAttribute : Attribute {
    public static LookupBindingPropertiesAttribute Default;
    public string DataSource { get; }
    public string DisplayMember { get; }
    public string LookupMember { get; }
    public string ValueMember { get; }
    public LookupBindingPropertiesAttribute(string dataSource, string displayMember, string valueMember, string lookupMember);
    public string get_DataSource();
    public string get_DisplayMember();
    public string get_LookupMember();
    public string get_ValueMember();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DesignerCategoryAttribute("Component")]
public class System.ComponentModel.MarshalByValueComponent : object {
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IContainer Container { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool DesignMode { get; }
    protected EventHandlerList Events { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ISite Site { get; public set; }
    public virtual IContainer get_Container();
    public virtual bool get_DesignMode();
    protected EventHandlerList get_Events();
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public sealed virtual void add_Disposed(EventHandler value);
    public sealed virtual void remove_Disposed(EventHandler value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public virtual object GetService(Type service);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.MaskedTextProvider : object {
    public bool AllowPromptAsInput { get; }
    public bool AsciiOnly { get; }
    public int AssignedEditPositionCount { get; }
    public int AvailableEditPositionCount { get; }
    public CultureInfo Culture { get; }
    public static char DefaultPasswordChar { get; }
    public int EditPositionCount { get; }
    public IEnumerator EditPositions { get; }
    public bool IncludeLiterals { get; public set; }
    public bool IncludePrompt { get; public set; }
    public static int InvalidIndex { get; }
    public bool IsPassword { get; public set; }
    public char Item { get; }
    public int LastAssignedPosition { get; }
    public int Length { get; }
    public string Mask { get; }
    public bool MaskCompleted { get; }
    public bool MaskFull { get; }
    public char PasswordChar { get; public set; }
    public char PromptChar { get; public set; }
    public bool ResetOnPrompt { get; public set; }
    public bool ResetOnSpace { get; public set; }
    public bool SkipLiterals { get; public set; }
    public MaskedTextProvider(string mask);
    public MaskedTextProvider(string mask, bool restrictToAscii);
    public MaskedTextProvider(string mask, char passwordChar, bool allowPromptAsInput);
    public MaskedTextProvider(string mask, CultureInfo culture);
    public MaskedTextProvider(string mask, CultureInfo culture, bool restrictToAscii);
    public MaskedTextProvider(string mask, CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);
    public MaskedTextProvider(string mask, CultureInfo culture, char passwordChar, bool allowPromptAsInput);
    public bool get_AllowPromptAsInput();
    public bool get_AsciiOnly();
    public int get_AssignedEditPositionCount();
    public int get_AvailableEditPositionCount();
    public CultureInfo get_Culture();
    public static char get_DefaultPasswordChar();
    public int get_EditPositionCount();
    public IEnumerator get_EditPositions();
    public bool get_IncludeLiterals();
    public void set_IncludeLiterals(bool value);
    public bool get_IncludePrompt();
    public void set_IncludePrompt(bool value);
    public static int get_InvalidIndex();
    public bool get_IsPassword();
    public void set_IsPassword(bool value);
    public char get_Item(int index);
    public int get_LastAssignedPosition();
    public int get_Length();
    public string get_Mask();
    public bool get_MaskCompleted();
    public bool get_MaskFull();
    public char get_PasswordChar();
    public void set_PasswordChar(char value);
    public char get_PromptChar();
    public void set_PromptChar(char value);
    public bool get_ResetOnPrompt();
    public void set_ResetOnPrompt(bool value);
    public bool get_ResetOnSpace();
    public void set_ResetOnSpace(bool value);
    public bool get_SkipLiterals();
    public void set_SkipLiterals(bool value);
    public bool Add(char input);
    public bool Add(char input, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Add(string input);
    public bool Add(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
    public void Clear();
    public void Clear(MaskedTextResultHint& resultHint);
    public sealed virtual object Clone();
    public int FindAssignedEditPositionFrom(int position, bool direction);
    public int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction);
    public int FindEditPositionFrom(int position, bool direction);
    public int FindEditPositionInRange(int startPosition, int endPosition, bool direction);
    public int FindNonEditPositionFrom(int position, bool direction);
    public int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction);
    public int FindUnassignedEditPositionFrom(int position, bool direction);
    public int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction);
    public static bool GetOperationResultFromHint(MaskedTextResultHint hint);
    public bool InsertAt(char input, int position);
    public bool InsertAt(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool InsertAt(string input, int position);
    public bool InsertAt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool IsAvailablePosition(int position);
    public bool IsEditPosition(int position);
    public static bool IsValidInputChar(char c);
    public static bool IsValidMaskChar(char c);
    public static bool IsValidPasswordChar(char c);
    public bool Remove();
    public bool Remove(Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool RemoveAt(int position);
    public bool RemoveAt(int startPosition, int endPosition);
    public bool RemoveAt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(char input, int position);
    public bool Replace(char input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(string input, int position);
    public bool Replace(string input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Set(string input);
    public bool Set(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
    public string ToDisplayString();
    public virtual string ToString();
    public string ToString(bool ignorePasswordChar);
    public string ToString(bool includePrompt, bool includeLiterals);
    public string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);
    public string ToString(bool includePrompt, bool includeLiterals, int startPosition, int length);
    public string ToString(bool ignorePasswordChar, int startPosition, int length);
    public string ToString(int startPosition, int length);
    public bool VerifyChar(char input, int position, MaskedTextResultHint& hint);
    public bool VerifyEscapeChar(char input, int position);
    public bool VerifyString(string input);
    public bool VerifyString(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
}
public enum System.ComponentModel.MaskedTextResultHint : Enum {
    public int value__;
    public static MaskedTextResultHint AlphanumericCharacterExpected;
    public static MaskedTextResultHint AsciiCharacterExpected;
    public static MaskedTextResultHint CharacterEscaped;
    public static MaskedTextResultHint DigitExpected;
    public static MaskedTextResultHint InvalidInput;
    public static MaskedTextResultHint LetterExpected;
    public static MaskedTextResultHint NoEffect;
    public static MaskedTextResultHint NonEditPosition;
    public static MaskedTextResultHint PositionOutOfRange;
    public static MaskedTextResultHint PromptCharNotAllowed;
    public static MaskedTextResultHint SideEffect;
    public static MaskedTextResultHint SignedDigitExpected;
    public static MaskedTextResultHint Success;
    public static MaskedTextResultHint UnavailableEditPosition;
    public static MaskedTextResultHint Unknown;
}
public abstract class System.ComponentModel.MemberDescriptor : object {
    protected Attribute[] AttributeArray { get; protected set; }
    public AttributeCollection Attributes { get; }
    public string Category { get; }
    public string Description { get; }
    public bool DesignTimeOnly { get; }
    public string DisplayName { get; }
    public bool IsBrowsable { get; }
    public string Name { get; }
    protected int NameHashCode { get; }
    protected MemberDescriptor(MemberDescriptor descr);
    protected MemberDescriptor(MemberDescriptor oldMemberDescriptor, Attribute[] newAttributes);
    protected MemberDescriptor(string name);
    protected MemberDescriptor(string name, Attribute[] attributes);
    protected virtual Attribute[] get_AttributeArray();
    protected virtual void set_AttributeArray(Attribute[] value);
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Category();
    public virtual string get_Description();
    public virtual bool get_DesignTimeOnly();
    public virtual string get_DisplayName();
    public virtual bool get_IsBrowsable();
    public virtual string get_Name();
    protected virtual int get_NameHashCode();
    protected virtual AttributeCollection CreateAttributeCollection();
    public virtual bool Equals(object obj);
    protected virtual void FillAttributes(IList attributeList);
    protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType);
    protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly);
    public virtual int GetHashCode();
    protected virtual object GetInvocationTarget(Type type, object instance);
    [ObsoleteAttribute("This method has been deprecated. Use GetInvocationTarget instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
protected static object GetInvokee(Type componentClass, object component);
    protected static ISite GetSite(object component);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.MergablePropertyAttribute : Attribute {
    public static MergablePropertyAttribute Default;
    public static MergablePropertyAttribute No;
    public static MergablePropertyAttribute Yes;
    public bool AllowMerge { get; }
    public MergablePropertyAttribute(bool allowMerge);
    public bool get_AllowMerge();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.MultilineStringConverter : TypeConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.ComponentModel.NestedContainer : Container {
    public IComponent Owner { get; }
    protected string OwnerName { get; }
    public NestedContainer(IComponent owner);
    public sealed virtual IComponent get_Owner();
    protected virtual string get_OwnerName();
    protected virtual ISite CreateSite(IComponent component, string name);
    protected virtual void Dispose(bool disposing);
    protected virtual object GetService(Type service);
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.NotifyParentPropertyAttribute : Attribute {
    public static NotifyParentPropertyAttribute Default;
    public static NotifyParentPropertyAttribute No;
    public static NotifyParentPropertyAttribute Yes;
    public bool NotifyParent { get; }
    public NotifyParentPropertyAttribute(bool notifyParent);
    public bool get_NotifyParent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.NullableConverter : TypeConverter {
    public Type NullableType { get; }
    public Type UnderlyingType { get; }
    public TypeConverter UnderlyingTypeConverter { get; }
    public NullableConverter(Type type);
    public Type get_NullableType();
    public Type get_UnderlyingType();
    public TypeConverter get_UnderlyingTypeConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ParenthesizePropertyNameAttribute : Attribute {
    public static ParenthesizePropertyNameAttribute Default;
    public bool NeedParenthesis { get; }
    public ParenthesizePropertyNameAttribute(bool needParenthesis);
    public bool get_NeedParenthesis();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.PasswordPropertyTextAttribute : Attribute {
    public static PasswordPropertyTextAttribute Default;
    public static PasswordPropertyTextAttribute No;
    public static PasswordPropertyTextAttribute Yes;
    public bool Password { get; }
    public PasswordPropertyTextAttribute(bool password);
    public bool get_Password();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ProgressChangedEventArgs : EventArgs {
    public int ProgressPercentage { get; }
    public object UserState { get; }
    public ProgressChangedEventArgs(int progressPercentage, object userState);
    public int get_ProgressPercentage();
    public object get_UserState();
}
public class System.ComponentModel.ProgressChangedEventHandler : MulticastDelegate {
    public ProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.PropertyChangedEventArgs : EventArgs {
    public string PropertyName { get; }
    public PropertyChangedEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
public class System.ComponentModel.PropertyChangedEventHandler : MulticastDelegate {
    public PropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.PropertyChangingEventArgs : EventArgs {
    public string PropertyName { get; }
    public PropertyChangingEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
public class System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
    public PropertyChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.ComponentModel.PropertyDescriptor : MemberDescriptor {
    public Type ComponentType { get; }
    public TypeConverter Converter { get; }
    public bool IsLocalizable { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public DesignerSerializationVisibility SerializationVisibility { get; }
    public bool SupportsChangeEvents { get; }
    protected PropertyDescriptor(MemberDescriptor descr);
    protected PropertyDescriptor(MemberDescriptor descr, Attribute[] attrs);
    protected PropertyDescriptor(string name, Attribute[] attrs);
    public abstract virtual Type get_ComponentType();
    public virtual TypeConverter get_Converter();
    public virtual bool get_IsLocalizable();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual Type get_PropertyType();
    public DesignerSerializationVisibility get_SerializationVisibility();
    public virtual bool get_SupportsChangeEvents();
    public virtual void AddValueChanged(object component, EventHandler handler);
    public abstract virtual bool CanResetValue(object component);
    protected object CreateInstance(Type type);
    public virtual bool Equals(object obj);
    protected virtual void FillAttributes(IList attributeList);
    public PropertyDescriptorCollection GetChildProperties();
    public PropertyDescriptorCollection GetChildProperties(Attribute[] filter);
    public PropertyDescriptorCollection GetChildProperties(object instance);
    public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter);
    public virtual object GetEditor(Type editorBaseType);
    public virtual int GetHashCode();
    protected virtual object GetInvocationTarget(Type type, object instance);
    protected Type GetTypeFromName(string typeName);
    public abstract virtual object GetValue(object component);
    protected internal EventHandler GetValueChangedHandler(object component);
    protected virtual void OnValueChanged(object component, EventArgs e);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public abstract virtual void ResetValue(object component);
    public abstract virtual void SetValue(object component, object value);
    public abstract virtual bool ShouldSerializeValue(object component);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.PropertyDescriptorCollection : object {
    public static PropertyDescriptorCollection Empty;
    public int Count { get; }
    public PropertyDescriptor Item { get; }
    public PropertyDescriptor Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PropertyDescriptorCollection(PropertyDescriptor[] properties);
    public PropertyDescriptorCollection(PropertyDescriptor[] properties, bool readOnly);
    public int get_Count();
    public virtual PropertyDescriptor get_Item(int index);
    public virtual PropertyDescriptor get_Item(string name);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(PropertyDescriptor value);
    public void Clear();
    public bool Contains(PropertyDescriptor value);
    public sealed virtual void CopyTo(Array array, int index);
    public virtual PropertyDescriptor Find(string name, bool ignoreCase);
    public virtual IEnumerator GetEnumerator();
    public int IndexOf(PropertyDescriptor value);
    public void Insert(int index, PropertyDescriptor value);
    protected void InternalSort(IComparer sorter);
    protected void InternalSort(String[] names);
    public void Remove(PropertyDescriptor value);
    public void RemoveAt(int index);
    public virtual PropertyDescriptorCollection Sort();
    public virtual PropertyDescriptorCollection Sort(IComparer comparer);
    public virtual PropertyDescriptorCollection Sort(String[] names);
    public virtual PropertyDescriptorCollection Sort(String[] names, IComparer comparer);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.PropertyTabAttribute : Attribute {
    public Type[] TabClasses { get; }
    protected String[] TabClassNames { get; }
    public PropertyTabScope[] TabScopes { get; }
    public PropertyTabAttribute(string tabClassName);
    public PropertyTabAttribute(string tabClassName, PropertyTabScope tabScope);
    public PropertyTabAttribute(Type tabClass);
    public PropertyTabAttribute(Type tabClass, PropertyTabScope tabScope);
    public Type[] get_TabClasses();
    protected String[] get_TabClassNames();
    public PropertyTabScope[] get_TabScopes();
    public bool Equals(PropertyTabAttribute other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    protected void InitializeArrays(String[] tabClassNames, PropertyTabScope[] tabScopes);
    protected void InitializeArrays(Type[] tabClasses, PropertyTabScope[] tabScopes);
}
public enum System.ComponentModel.PropertyTabScope : Enum {
    public int value__;
    public static PropertyTabScope Component;
    public static PropertyTabScope Document;
    public static PropertyTabScope Global;
    public static PropertyTabScope Static;
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ProvidePropertyAttribute : Attribute {
    public string PropertyName { get; }
    public string ReceiverTypeName { get; }
    public object TypeId { get; }
    public ProvidePropertyAttribute(string propertyName, string receiverTypeName);
    public ProvidePropertyAttribute(string propertyName, Type receiverType);
    public string get_PropertyName();
    public string get_ReceiverTypeName();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ReadOnlyAttribute : Attribute {
    public static ReadOnlyAttribute Default;
    public static ReadOnlyAttribute No;
    public static ReadOnlyAttribute Yes;
    public bool IsReadOnly { get; }
    public ReadOnlyAttribute(bool isReadOnly);
    public bool get_IsReadOnly();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("128")]
[ObsoleteAttribute("Use System.ComponentModel.SettingsBindableAttribute instead to work with the new settings model.")]
public class System.ComponentModel.RecommendedAsConfigurableAttribute : Attribute {
    public static RecommendedAsConfigurableAttribute Default;
    public static RecommendedAsConfigurableAttribute No;
    public static RecommendedAsConfigurableAttribute Yes;
    public bool RecommendedAsConfigurable { get; }
    public RecommendedAsConfigurableAttribute(bool recommendedAsConfigurable);
    public bool get_RecommendedAsConfigurable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ReferenceConverter : TypeConverter {
    public ReferenceConverter(Type type);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    protected virtual bool IsValueAllowed(ITypeDescriptorContext context, object value);
}
public class System.ComponentModel.RefreshEventArgs : EventArgs {
    public object ComponentChanged { get; }
    public Type TypeChanged { get; }
    public RefreshEventArgs(object componentChanged);
    public RefreshEventArgs(Type typeChanged);
    public object get_ComponentChanged();
    public Type get_TypeChanged();
}
public class System.ComponentModel.RefreshEventHandler : MulticastDelegate {
    public RefreshEventHandler(object object, IntPtr method);
    public virtual void Invoke(RefreshEventArgs e);
    public virtual IAsyncResult BeginInvoke(RefreshEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ComponentModel.RefreshProperties : Enum {
    public int value__;
    public static RefreshProperties All;
    public static RefreshProperties None;
    public static RefreshProperties Repaint;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.RefreshPropertiesAttribute : Attribute {
    public static RefreshPropertiesAttribute All;
    public static RefreshPropertiesAttribute Default;
    public static RefreshPropertiesAttribute Repaint;
    public RefreshProperties RefreshProperties { get; }
    public RefreshPropertiesAttribute(RefreshProperties refresh);
    public RefreshProperties get_RefreshProperties();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.RunInstallerAttribute : Attribute {
    public static RunInstallerAttribute Default;
    public static RunInstallerAttribute No;
    public static RunInstallerAttribute Yes;
    public bool RunInstaller { get; }
    public RunInstallerAttribute(bool runInstaller);
    public bool get_RunInstaller();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.RunWorkerCompletedEventArgs : AsyncCompletedEventArgs {
    public object Result { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object UserState { get; }
    public RunWorkerCompletedEventArgs(object result, Exception error, bool cancelled);
    public object get_Result();
    public object get_UserState();
}
public class System.ComponentModel.RunWorkerCompletedEventHandler : MulticastDelegate {
    public RunWorkerCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RunWorkerCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RunWorkerCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.SByteConverter : BaseNumberConverter {
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.SettingsBindableAttribute : Attribute {
    public static SettingsBindableAttribute No;
    public static SettingsBindableAttribute Yes;
    public bool Bindable { get; }
    public SettingsBindableAttribute(bool bindable);
    public bool get_Bindable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.ComponentModel.SingleConverter : BaseNumberConverter {
}
public class System.ComponentModel.StringConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public static class System.ComponentModel.SyntaxCheck : object {
    public static bool CheckMachineName(string value);
    public static bool CheckPath(string value);
    public static bool CheckRootedPath(string value);
}
public class System.ComponentModel.TimeSpanConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ToolboxItemAttribute : Attribute {
    public static ToolboxItemAttribute Default;
    public static ToolboxItemAttribute None;
    public Type ToolboxItemType { get; }
    public string ToolboxItemTypeName { get; }
    public ToolboxItemAttribute(bool defaultType);
    public ToolboxItemAttribute(string toolboxItemTypeName);
    public ToolboxItemAttribute(Type toolboxItemType);
    public Type get_ToolboxItemType();
    public string get_ToolboxItemTypeName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ToolboxItemFilterAttribute : Attribute {
    public string FilterString { get; }
    public ToolboxItemFilterType FilterType { get; }
    public object TypeId { get; }
    public ToolboxItemFilterAttribute(string filterString);
    public ToolboxItemFilterAttribute(string filterString, ToolboxItemFilterType filterType);
    public string get_FilterString();
    public ToolboxItemFilterType get_FilterType();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Match(object obj);
    public virtual string ToString();
}
public enum System.ComponentModel.ToolboxItemFilterType : Enum {
    public int value__;
    public static ToolboxItemFilterType Allow;
    public static ToolboxItemFilterType Custom;
    public static ToolboxItemFilterType Prevent;
    public static ToolboxItemFilterType Require;
}
public class System.ComponentModel.TypeConverter : object {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public bool CanConvertFrom(Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public bool CanConvertTo(Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public object ConvertFrom(object value);
    public object ConvertFromInvariantString(ITypeDescriptorContext context, string text);
    public object ConvertFromInvariantString(string text);
    public object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text);
    public object ConvertFromString(ITypeDescriptorContext context, string text);
    public object ConvertFromString(string text);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public object ConvertTo(object value, Type destinationType);
    public string ConvertToInvariantString(ITypeDescriptorContext context, object value);
    public string ConvertToInvariantString(object value);
    public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, object value);
    public string ConvertToString(ITypeDescriptorContext context, object value);
    public string ConvertToString(object value);
    public object CreateInstance(IDictionary propertyValues);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    protected Exception GetConvertFromException(object value);
    protected Exception GetConvertToException(object value, Type destinationType);
    public bool GetCreateInstanceSupported();
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public PropertyDescriptorCollection GetProperties(object value);
    public bool GetPropertiesSupported();
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
    public ICollection GetStandardValues();
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public bool GetStandardValuesExclusive();
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public bool GetStandardValuesSupported();
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
    public bool IsValid(object value);
    protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, String[] names);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.TypeConverterAttribute : Attribute {
    public static TypeConverterAttribute Default;
    public string ConverterTypeName { get; }
    public TypeConverterAttribute(string typeName);
    public TypeConverterAttribute(Type type);
    public string get_ConverterTypeName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.ComponentModel.TypeDescriptionProvider : object {
    protected TypeDescriptionProvider(TypeDescriptionProvider parent);
    public virtual object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    public virtual IDictionary GetCache(object instance);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    protected internal virtual IExtenderProvider[] GetExtenderProviders(object instance);
    public virtual string GetFullComponentName(object component);
    public Type GetReflectionType(object instance);
    public Type GetReflectionType(Type objectType);
    public virtual Type GetReflectionType(Type objectType, object instance);
    public virtual Type GetRuntimeType(Type reflectionType);
    public ICustomTypeDescriptor GetTypeDescriptor(object instance);
    public ICustomTypeDescriptor GetTypeDescriptor(Type objectType);
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    public virtual bool IsSupportedType(Type type);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.TypeDescriptionProviderAttribute : Attribute {
    public string TypeName { get; }
    public TypeDescriptionProviderAttribute(string typeName);
    public TypeDescriptionProviderAttribute(Type type);
    public string get_TypeName();
}
public class System.ComponentModel.TypeDescriptor : object {
    [ObsoleteAttribute("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public static IComNativeDescriptorHandler ComNativeDescriptorHandler { get; public set; }
    [EditorBrowsableAttribute("2")]
public static Type ComObjectType { get; }
    [EditorBrowsableAttribute("2")]
public static Type InterfaceType { get; }
    public static IComNativeDescriptorHandler get_ComNativeDescriptorHandler();
    public static void set_ComNativeDescriptorHandler(IComNativeDescriptorHandler value);
    public static Type get_ComObjectType();
    public static Type get_InterfaceType();
    public static void add_Refreshed(RefreshEventHandler value);
    public static void remove_Refreshed(RefreshEventHandler value);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider AddAttributes(object instance, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider AddAttributes(Type type, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static void AddEditorTable(Type editorBaseType, Hashtable table);
    [EditorBrowsableAttribute("2")]
public static void AddProvider(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void AddProvider(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void AddProviderTransparent(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void AddProviderTransparent(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void CreateAssociation(object primary, object secondary);
    public static IDesigner CreateDesigner(IComponent component, Type designerBaseType);
    public static EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, Attribute[] attributes);
    public static EventDescriptor CreateEvent(Type componentType, string name, Type type, Attribute[] attributes);
    public static object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    public static PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, Attribute[] attributes);
    public static PropertyDescriptor CreateProperty(Type componentType, string name, Type type, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static object GetAssociation(Type type, object primary);
    public static AttributeCollection GetAttributes(object component);
    [EditorBrowsableAttribute("2")]
public static AttributeCollection GetAttributes(object component, bool noCustomTypeDesc);
    public static AttributeCollection GetAttributes(Type componentType);
    public static string GetClassName(object component);
    [EditorBrowsableAttribute("2")]
public static string GetClassName(object component, bool noCustomTypeDesc);
    public static string GetClassName(Type componentType);
    public static string GetComponentName(object component);
    [EditorBrowsableAttribute("2")]
public static string GetComponentName(object component, bool noCustomTypeDesc);
    public static TypeConverter GetConverter(object component);
    [EditorBrowsableAttribute("2")]
public static TypeConverter GetConverter(object component, bool noCustomTypeDesc);
    public static TypeConverter GetConverter(Type type);
    public static EventDescriptor GetDefaultEvent(object component);
    [EditorBrowsableAttribute("2")]
public static EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc);
    public static EventDescriptor GetDefaultEvent(Type componentType);
    public static PropertyDescriptor GetDefaultProperty(object component);
    [EditorBrowsableAttribute("2")]
public static PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc);
    public static PropertyDescriptor GetDefaultProperty(Type componentType);
    public static object GetEditor(object component, Type editorBaseType);
    [EditorBrowsableAttribute("2")]
public static object GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc);
    public static object GetEditor(Type type, Type editorBaseType);
    public static EventDescriptorCollection GetEvents(object component);
    public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noCustomTypeDesc);
    [EditorBrowsableAttribute("2")]
public static EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc);
    public static EventDescriptorCollection GetEvents(Type componentType);
    public static EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes);
    public static string GetFullComponentName(object component);
    public static PropertyDescriptorCollection GetProperties(object component);
    public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);
    public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noCustomTypeDesc);
    [EditorBrowsableAttribute("2")]
public static PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc);
    public static PropertyDescriptorCollection GetProperties(Type componentType);
    public static PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider GetProvider(object instance);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider GetProvider(Type type);
    [EditorBrowsableAttribute("2")]
public static Type GetReflectionType(object instance);
    [EditorBrowsableAttribute("2")]
public static Type GetReflectionType(Type type);
    public static void Refresh(object component);
    public static void Refresh(Assembly assembly);
    public static void Refresh(Module module);
    public static void Refresh(Type type);
    [EditorBrowsableAttribute("2")]
public static void RemoveAssociation(object primary, object secondary);
    [EditorBrowsableAttribute("2")]
public static void RemoveAssociations(object primary);
    [EditorBrowsableAttribute("2")]
public static void RemoveProvider(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void RemoveProvider(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void RemoveProviderTransparent(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void RemoveProviderTransparent(TypeDescriptionProvider provider, Type type);
    public static void SortDescriptorArray(IList infos);
}
public abstract class System.ComponentModel.TypeListConverter : TypeConverter {
    protected TypeListConverter(Type[] types);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public class System.ComponentModel.UInt16Converter : BaseNumberConverter {
}
public class System.ComponentModel.UInt32Converter : BaseNumberConverter {
}
public class System.ComponentModel.UInt64Converter : BaseNumberConverter {
}
public class System.ComponentModel.WarningException : SystemException {
    public string HelpTopic { get; }
    public string HelpUrl { get; }
    protected WarningException(SerializationInfo info, StreamingContext context);
    public WarningException(string message);
    public WarningException(string message, Exception innerException);
    public WarningException(string message, string helpUrl);
    public WarningException(string message, string helpUrl, string helpTopic);
    public string get_HelpTopic();
    public string get_HelpUrl();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ComponentModel.Win32Exception : ExternalException {
    public int NativeErrorCode { get; }
    public Win32Exception(int error);
    public Win32Exception(int error, string message);
    protected Win32Exception(SerializationInfo info, StreamingContext context);
    public Win32Exception(string message);
    public Win32Exception(string message, Exception innerException);
    public int get_NativeErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameDomain;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
}
public static class System.Console : object {
    public static ConsoleColor BackgroundColor { get; public set; }
    public static int BufferHeight { get; public set; }
    public static int BufferWidth { get; public set; }
    public static bool CapsLock { get; }
    public static int CursorLeft { get; public set; }
    public static int CursorSize { get; public set; }
    public static int CursorTop { get; public set; }
    public static bool CursorVisible { get; public set; }
    public static TextWriter Error { get; }
    public static ConsoleColor ForegroundColor { get; public set; }
    public static TextReader In { get; }
    public static Encoding InputEncoding { get; public set; }
    public static bool IsErrorRedirected { get; }
    public static bool IsInputRedirected { get; }
    public static bool IsOutputRedirected { get; }
    public static bool KeyAvailable { get; }
    public static int LargestWindowHeight { get; }
    public static int LargestWindowWidth { get; }
    public static bool NumberLock { get; }
    public static TextWriter Out { get; }
    public static Encoding OutputEncoding { get; public set; }
    public static string Title { get; public set; }
    public static bool TreatControlCAsInput { get; public set; }
    public static int WindowHeight { get; public set; }
    public static int WindowLeft { get; public set; }
    public static int WindowTop { get; public set; }
    public static int WindowWidth { get; public set; }
    public static ConsoleColor get_BackgroundColor();
    public static void set_BackgroundColor(ConsoleColor value);
    public static int get_BufferHeight();
    public static void set_BufferHeight(int value);
    public static int get_BufferWidth();
    public static void set_BufferWidth(int value);
    public static bool get_CapsLock();
    public static int get_CursorLeft();
    public static void set_CursorLeft(int value);
    public static int get_CursorSize();
    public static void set_CursorSize(int value);
    public static int get_CursorTop();
    public static void set_CursorTop(int value);
    public static bool get_CursorVisible();
    public static void set_CursorVisible(bool value);
    public static TextWriter get_Error();
    public static ConsoleColor get_ForegroundColor();
    public static void set_ForegroundColor(ConsoleColor value);
    public static TextReader get_In();
    public static Encoding get_InputEncoding();
    public static void set_InputEncoding(Encoding value);
    public static bool get_IsErrorRedirected();
    public static bool get_IsInputRedirected();
    public static bool get_IsOutputRedirected();
    public static bool get_KeyAvailable();
    public static int get_LargestWindowHeight();
    public static int get_LargestWindowWidth();
    public static bool get_NumberLock();
    public static TextWriter get_Out();
    public static Encoding get_OutputEncoding();
    public static void set_OutputEncoding(Encoding value);
    public static string get_Title();
    public static void set_Title(string value);
    public static bool get_TreatControlCAsInput();
    public static void set_TreatControlCAsInput(bool value);
    public static int get_WindowHeight();
    public static void set_WindowHeight(int value);
    public static int get_WindowLeft();
    public static void set_WindowLeft(int value);
    public static int get_WindowTop();
    public static void set_WindowTop(int value);
    public static int get_WindowWidth();
    public static void set_WindowWidth(int value);
    public static void add_CancelKeyPress(ConsoleCancelEventHandler value);
    public static void remove_CancelKeyPress(ConsoleCancelEventHandler value);
    public static void Beep();
    public static void Beep(int frequency, int duration);
    public static void Clear();
    public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
    public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
    public static Stream OpenStandardError();
    public static Stream OpenStandardError(int bufferSize);
    public static Stream OpenStandardInput();
    public static Stream OpenStandardInput(int bufferSize);
    public static Stream OpenStandardOutput();
    public static Stream OpenStandardOutput(int bufferSize);
    public static int Read();
    public static ConsoleKeyInfo ReadKey();
    public static ConsoleKeyInfo ReadKey(bool intercept);
    public static string ReadLine();
    public static void ResetColor();
    public static void SetBufferSize(int width, int height);
    public static void SetCursorPosition(int left, int top);
    public static void SetError(TextWriter newError);
    public static void SetIn(TextReader newIn);
    public static void SetOut(TextWriter newOut);
    public static void SetWindowPosition(int left, int top);
    public static void SetWindowSize(int width, int height);
    public static void Write(bool value);
    public static void Write(char value);
    public static void Write(Char[] buffer);
    public static void Write(Char[] buffer, int index, int count);
    public static void Write(decimal value);
    public static void Write(double value);
    public static void Write(int value);
    public static void Write(long value);
    public static void Write(object value);
    public static void Write(float value);
    public static void Write(string value);
    public static void Write(string format, object arg0);
    public static void Write(string format, object arg0, object arg1);
    public static void Write(string format, object arg0, object arg1, object arg2);
    public static void Write(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public static void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public static void Write(ulong value);
    public static void WriteLine();
    public static void WriteLine(bool value);
    public static void WriteLine(char value);
    public static void WriteLine(Char[] buffer);
    public static void WriteLine(Char[] buffer, int index, int count);
    public static void WriteLine(decimal value);
    public static void WriteLine(double value);
    public static void WriteLine(int value);
    public static void WriteLine(long value);
    public static void WriteLine(object value);
    public static void WriteLine(float value);
    public static void WriteLine(string value);
    public static void WriteLine(string format, object arg0);
    public static void WriteLine(string format, object arg0, object arg1);
    public static void WriteLine(string format, object arg0, object arg1, object arg2);
    public static void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public static void WriteLine(UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteLine(ulong value);
}
public class System.ConsoleCancelEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public ConsoleSpecialKey SpecialKey { get; }
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public ConsoleSpecialKey get_SpecialKey();
}
public class System.ConsoleCancelEventHandler : MulticastDelegate {
    public ConsoleCancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ConsoleCancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ConsoleCancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ConsoleColor : Enum {
    public int value__;
    public static ConsoleColor Black;
    public static ConsoleColor Blue;
    public static ConsoleColor Cyan;
    public static ConsoleColor DarkBlue;
    public static ConsoleColor DarkCyan;
    public static ConsoleColor DarkGray;
    public static ConsoleColor DarkGreen;
    public static ConsoleColor DarkMagenta;
    public static ConsoleColor DarkRed;
    public static ConsoleColor DarkYellow;
    public static ConsoleColor Gray;
    public static ConsoleColor Green;
    public static ConsoleColor Magenta;
    public static ConsoleColor Red;
    public static ConsoleColor White;
    public static ConsoleColor Yellow;
}
public enum System.ConsoleKey : Enum {
    public int value__;
    public static ConsoleKey A;
    public static ConsoleKey Add;
    public static ConsoleKey Applications;
    public static ConsoleKey Attention;
    public static ConsoleKey B;
    public static ConsoleKey Backspace;
    public static ConsoleKey BrowserBack;
    public static ConsoleKey BrowserFavorites;
    public static ConsoleKey BrowserForward;
    public static ConsoleKey BrowserHome;
    public static ConsoleKey BrowserRefresh;
    public static ConsoleKey BrowserSearch;
    public static ConsoleKey BrowserStop;
    public static ConsoleKey C;
    public static ConsoleKey Clear;
    public static ConsoleKey CrSel;
    public static ConsoleKey D;
    public static ConsoleKey D0;
    public static ConsoleKey D1;
    public static ConsoleKey D2;
    public static ConsoleKey D3;
    public static ConsoleKey D4;
    public static ConsoleKey D5;
    public static ConsoleKey D6;
    public static ConsoleKey D7;
    public static ConsoleKey D8;
    public static ConsoleKey D9;
    public static ConsoleKey Decimal;
    public static ConsoleKey Delete;
    public static ConsoleKey Divide;
    public static ConsoleKey DownArrow;
    public static ConsoleKey E;
    public static ConsoleKey End;
    public static ConsoleKey Enter;
    public static ConsoleKey EraseEndOfFile;
    public static ConsoleKey Escape;
    public static ConsoleKey Execute;
    public static ConsoleKey ExSel;
    public static ConsoleKey F;
    public static ConsoleKey F1;
    public static ConsoleKey F10;
    public static ConsoleKey F11;
    public static ConsoleKey F12;
    public static ConsoleKey F13;
    public static ConsoleKey F14;
    public static ConsoleKey F15;
    public static ConsoleKey F16;
    public static ConsoleKey F17;
    public static ConsoleKey F18;
    public static ConsoleKey F19;
    public static ConsoleKey F2;
    public static ConsoleKey F20;
    public static ConsoleKey F21;
    public static ConsoleKey F22;
    public static ConsoleKey F23;
    public static ConsoleKey F24;
    public static ConsoleKey F3;
    public static ConsoleKey F4;
    public static ConsoleKey F5;
    public static ConsoleKey F6;
    public static ConsoleKey F7;
    public static ConsoleKey F8;
    public static ConsoleKey F9;
    public static ConsoleKey G;
    public static ConsoleKey H;
    public static ConsoleKey Help;
    public static ConsoleKey Home;
    public static ConsoleKey I;
    public static ConsoleKey Insert;
    public static ConsoleKey J;
    public static ConsoleKey K;
    public static ConsoleKey L;
    public static ConsoleKey LaunchApp1;
    public static ConsoleKey LaunchApp2;
    public static ConsoleKey LaunchMail;
    public static ConsoleKey LaunchMediaSelect;
    public static ConsoleKey LeftArrow;
    public static ConsoleKey LeftWindows;
    public static ConsoleKey M;
    public static ConsoleKey MediaNext;
    public static ConsoleKey MediaPlay;
    public static ConsoleKey MediaPrevious;
    public static ConsoleKey MediaStop;
    public static ConsoleKey Multiply;
    public static ConsoleKey N;
    public static ConsoleKey NoName;
    public static ConsoleKey NumPad0;
    public static ConsoleKey NumPad1;
    public static ConsoleKey NumPad2;
    public static ConsoleKey NumPad3;
    public static ConsoleKey NumPad4;
    public static ConsoleKey NumPad5;
    public static ConsoleKey NumPad6;
    public static ConsoleKey NumPad7;
    public static ConsoleKey NumPad8;
    public static ConsoleKey NumPad9;
    public static ConsoleKey O;
    public static ConsoleKey Oem1;
    public static ConsoleKey Oem102;
    public static ConsoleKey Oem2;
    public static ConsoleKey Oem3;
    public static ConsoleKey Oem4;
    public static ConsoleKey Oem5;
    public static ConsoleKey Oem6;
    public static ConsoleKey Oem7;
    public static ConsoleKey Oem8;
    public static ConsoleKey OemClear;
    public static ConsoleKey OemComma;
    public static ConsoleKey OemMinus;
    public static ConsoleKey OemPeriod;
    public static ConsoleKey OemPlus;
    public static ConsoleKey P;
    public static ConsoleKey Pa1;
    public static ConsoleKey Packet;
    public static ConsoleKey PageDown;
    public static ConsoleKey PageUp;
    public static ConsoleKey Pause;
    public static ConsoleKey Play;
    public static ConsoleKey Print;
    public static ConsoleKey PrintScreen;
    public static ConsoleKey Process;
    public static ConsoleKey Q;
    public static ConsoleKey R;
    public static ConsoleKey RightArrow;
    public static ConsoleKey RightWindows;
    public static ConsoleKey S;
    public static ConsoleKey Select;
    public static ConsoleKey Separator;
    public static ConsoleKey Sleep;
    public static ConsoleKey Spacebar;
    public static ConsoleKey Subtract;
    public static ConsoleKey T;
    public static ConsoleKey Tab;
    public static ConsoleKey U;
    public static ConsoleKey UpArrow;
    public static ConsoleKey V;
    public static ConsoleKey VolumeDown;
    public static ConsoleKey VolumeMute;
    public static ConsoleKey VolumeUp;
    public static ConsoleKey W;
    public static ConsoleKey X;
    public static ConsoleKey Y;
    public static ConsoleKey Z;
    public static ConsoleKey Zoom;
}
[IsReadOnlyAttribute]
public class System.ConsoleKeyInfo : ValueType {
    private int _dummyPrimitive;
    public ConsoleKey Key { get; }
    public char KeyChar { get; }
    public ConsoleModifiers Modifiers { get; }
    public ConsoleKeyInfo(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);
    public ConsoleKey get_Key();
    public char get_KeyChar();
    public ConsoleModifiers get_Modifiers();
    public bool Equals(ConsoleKeyInfo obj);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static bool op_Equality(ConsoleKeyInfo a, ConsoleKeyInfo b);
    public static bool op_Inequality(ConsoleKeyInfo a, ConsoleKeyInfo b);
}
[FlagsAttribute]
public enum System.ConsoleModifiers : Enum {
    public int value__;
    public static ConsoleModifiers Alt;
    public static ConsoleModifiers Control;
    public static ConsoleModifiers Shift;
}
public enum System.ConsoleSpecialKey : Enum {
    public int value__;
    public static ConsoleSpecialKey ControlBreak;
    public static ConsoleSpecialKey ControlC;
}
public abstract class System.ContextBoundObject : MarshalByRefObject {
}
public class System.ContextMarshalException : SystemException {
    protected ContextMarshalException(SerializationInfo info, StreamingContext context);
    public ContextMarshalException(string message);
    public ContextMarshalException(string message, Exception inner);
}
[AttributeUsageAttribute("256")]
public class System.ContextStaticAttribute : Attribute {
}
public static class System.Convert : object {
    public static object DBNull;
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    public static Byte[] FromBase64String(string s);
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray);
    public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray, int offset, int length);
    public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    public static string ToBase64String(ReadOnlySpan`1<byte> bytes, Base64FormattingOptions options);
    public static bool ToBoolean(bool value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(DateTime value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(short value);
    public static bool ToBoolean(int value);
    public static bool ToBoolean(long value);
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    public static byte ToByte(DateTime value);
    public static byte ToByte(decimal value);
    public static byte ToByte(double value);
    public static byte ToByte(short value);
    public static byte ToByte(int value);
    public static byte ToByte(long value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(float value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static char ToChar(bool value);
    public static char ToChar(byte value);
    public static char ToChar(char value);
    public static char ToChar(DateTime value);
    public static char ToChar(decimal value);
    public static char ToChar(double value);
    public static char ToChar(short value);
    public static char ToChar(int value);
    public static char ToChar(long value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(float value);
    public static char ToChar(string value);
    public static char ToChar(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(decimal value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(short value);
    public static DateTime ToDateTime(int value);
    public static DateTime ToDateTime(long value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(DateTime value);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(short value);
    public static decimal ToDecimal(int value);
    public static decimal ToDecimal(long value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static double ToDouble(bool value);
    public static double ToDouble(byte value);
    public static double ToDouble(char value);
    public static double ToDouble(DateTime value);
    public static double ToDouble(decimal value);
    public static double ToDouble(double value);
    public static double ToDouble(short value);
    public static double ToDouble(int value);
    public static double ToDouble(long value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(float value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static short ToInt16(bool value);
    public static short ToInt16(byte value);
    public static short ToInt16(char value);
    public static short ToInt16(DateTime value);
    public static short ToInt16(decimal value);
    public static short ToInt16(double value);
    public static short ToInt16(short value);
    public static short ToInt16(int value);
    public static short ToInt16(long value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(float value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static int ToInt32(bool value);
    public static int ToInt32(byte value);
    public static int ToInt32(char value);
    public static int ToInt32(DateTime value);
    public static int ToInt32(decimal value);
    public static int ToInt32(double value);
    public static int ToInt32(short value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(float value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static long ToInt64(bool value);
    public static long ToInt64(byte value);
    public static long ToInt64(char value);
    public static long ToInt64(DateTime value);
    public static long ToInt64(decimal value);
    public static long ToInt64(double value);
    public static long ToInt64(short value);
    public static long ToInt64(int value);
    public static long ToInt64(long value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(float value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    public static float ToSingle(bool value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(DateTime value);
    public static float ToSingle(decimal value);
    public static float ToSingle(double value);
    public static float ToSingle(short value);
    public static float ToSingle(int value);
    public static float ToSingle(long value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(float value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static string ToString(bool value);
    public static string ToString(bool value, IFormatProvider provider);
    public static string ToString(byte value);
    public static string ToString(byte value, IFormatProvider provider);
    public static string ToString(byte value, int toBase);
    public static string ToString(char value);
    public static string ToString(char value, IFormatProvider provider);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(decimal value);
    public static string ToString(decimal value, IFormatProvider provider);
    public static string ToString(double value);
    public static string ToString(double value, IFormatProvider provider);
    public static string ToString(short value);
    public static string ToString(short value, IFormatProvider provider);
    public static string ToString(short value, int toBase);
    public static string ToString(int value);
    public static string ToString(int value, IFormatProvider provider);
    public static string ToString(int value, int toBase);
    public static string ToString(long value);
    public static string ToString(long value, IFormatProvider provider);
    public static string ToString(long value, int toBase);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    public static string ToString(float value);
    public static string ToString(float value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    public static bool TryFromBase64Chars(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    public static bool TryFromBase64String(string s, Span`1<byte> bytes, Int32& bytesWritten);
    public static bool TryToBase64Chars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten, Base64FormattingOptions options);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
public enum System.Data.AcceptRejectRule : Enum {
    public int value__;
    public static AcceptRejectRule Cascade;
    public static AcceptRejectRule None;
}
[FlagsAttribute]
public enum System.Data.CommandBehavior : Enum {
    public int value__;
    public static CommandBehavior CloseConnection;
    public static CommandBehavior Default;
    public static CommandBehavior KeyInfo;
    public static CommandBehavior SchemaOnly;
    public static CommandBehavior SequentialAccess;
    public static CommandBehavior SingleResult;
    public static CommandBehavior SingleRow;
}
public enum System.Data.CommandType : Enum {
    public int value__;
    public static CommandType StoredProcedure;
    public static CommandType TableDirect;
    public static CommandType Text;
}
public enum System.Data.Common.CatalogLocation : Enum {
    public int value__;
    public static CatalogLocation End;
    public static CatalogLocation Start;
}
public class System.Data.Common.DataAdapter : Component {
    [DefaultValueAttribute("True")]
public bool AcceptChangesDuringFill { get; public set; }
    [DefaultValueAttribute("True")]
public bool AcceptChangesDuringUpdate { get; public set; }
    [DefaultValueAttribute("False")]
public bool ContinueUpdateOnError { get; public set; }
    [RefreshPropertiesAttribute("1")]
public LoadOption FillLoadOption { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MissingMappingAction MissingMappingAction { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MissingSchemaAction MissingSchemaAction { get; public set; }
    [DefaultValueAttribute("False")]
public bool ReturnProviderSpecificTypes { get; public set; }
    private ITableMappingCollection System.Data.IDataAdapter.TableMappings { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public DataTableMappingCollection TableMappings { get; }
    protected DataAdapter(DataAdapter from);
    public bool get_AcceptChangesDuringFill();
    public void set_AcceptChangesDuringFill(bool value);
    public bool get_AcceptChangesDuringUpdate();
    public void set_AcceptChangesDuringUpdate(bool value);
    public bool get_ContinueUpdateOnError();
    public void set_ContinueUpdateOnError(bool value);
    public LoadOption get_FillLoadOption();
    public void set_FillLoadOption(LoadOption value);
    public sealed virtual MissingMappingAction get_MissingMappingAction();
    public sealed virtual void set_MissingMappingAction(MissingMappingAction value);
    public sealed virtual MissingSchemaAction get_MissingSchemaAction();
    public sealed virtual void set_MissingSchemaAction(MissingSchemaAction value);
    public virtual bool get_ReturnProviderSpecificTypes();
    public virtual void set_ReturnProviderSpecificTypes(bool value);
    private sealed virtual override ITableMappingCollection System.Data.IDataAdapter.get_TableMappings();
    public DataTableMappingCollection get_TableMappings();
    public void add_FillError(FillErrorEventHandler value);
    public void remove_FillError(FillErrorEventHandler value);
    [ObsoleteAttribute("CloneInternals() has been deprecated.  Use the DataAdapter(DataAdapter from) constructor.  https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual DataAdapter CloneInternals();
    protected virtual DataTableMappingCollection CreateTableMappings();
    protected virtual void Dispose(bool disposing);
    public virtual int Fill(DataSet dataSet);
    protected virtual int Fill(DataSet dataSet, string srcTable, IDataReader dataReader, int startRecord, int maxRecords);
    protected virtual int Fill(DataTable dataTable, IDataReader dataReader);
    protected virtual int Fill(DataTable[] dataTables, IDataReader dataReader, int startRecord, int maxRecords);
    public virtual DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType);
    protected virtual DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType, string srcTable, IDataReader dataReader);
    protected virtual DataTable FillSchema(DataTable dataTable, SchemaType schemaType, IDataReader dataReader);
    [EditorBrowsableAttribute("2")]
public virtual IDataParameter[] GetFillParameters();
    protected bool HasTableMappings();
    protected virtual void OnFillError(FillErrorEventArgs value);
    [EditorBrowsableAttribute("1")]
public void ResetFillLoadOption();
    [EditorBrowsableAttribute("1")]
public virtual bool ShouldSerializeAcceptChangesDuringFill();
    [EditorBrowsableAttribute("1")]
public virtual bool ShouldSerializeFillLoadOption();
    protected virtual bool ShouldSerializeTableMappings();
    public virtual int Update(DataSet dataSet);
}
public class System.Data.Common.DataColumnMapping : MarshalByRefObject {
    [DefaultValueAttribute("")]
public string DataSetColumn { get; public set; }
    [DefaultValueAttribute("")]
public string SourceColumn { get; public set; }
    public DataColumnMapping(string sourceColumn, string dataSetColumn);
    public sealed virtual string get_DataSetColumn();
    public sealed virtual void set_DataSetColumn(string value);
    public sealed virtual string get_SourceColumn();
    public sealed virtual void set_SourceColumn(string value);
    [EditorBrowsableAttribute("2")]
public DataColumn GetDataColumnBySchemaAction(DataTable dataTable, Type dataType, MissingSchemaAction schemaAction);
    [EditorBrowsableAttribute("2")]
public static DataColumn GetDataColumnBySchemaAction(string sourceColumn, string dataSetColumn, DataTable dataTable, Type dataType, MissingSchemaAction schemaAction);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Data.Common.DataColumnMappingCollection : MarshalByRefObject {
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int Count { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataColumnMapping Item { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataColumnMapping Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private object System.Data.IColumnMappingCollection.Item { get; private set; }
    public sealed virtual int get_Count();
    public DataColumnMapping get_Item(int index);
    public void set_Item(int index, DataColumnMapping value);
    public DataColumnMapping get_Item(string sourceColumn);
    public void set_Item(string sourceColumn, DataColumnMapping value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override object System.Data.IColumnMappingCollection.get_Item(string index);
    private sealed virtual override void System.Data.IColumnMappingCollection.set_Item(string index, object value);
    public sealed virtual int Add(object value);
    public DataColumnMapping Add(string sourceColumn, string dataSetColumn);
    public void AddRange(Array values);
    public void AddRange(DataColumnMapping[] values);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual bool Contains(string value);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(DataColumnMapping[] array, int index);
    public DataColumnMapping GetByDataSetColumn(string value);
    [EditorBrowsableAttribute("2")]
public static DataColumnMapping GetColumnMappingBySchemaAction(DataColumnMappingCollection columnMappings, string sourceColumn, MissingMappingAction mappingAction);
    [EditorBrowsableAttribute("2")]
public static DataColumn GetDataColumn(DataColumnMappingCollection columnMappings, string sourceColumn, Type dataType, DataTable dataTable, MissingMappingAction mappingAction, MissingSchemaAction schemaAction);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int IndexOf(object value);
    public sealed virtual int IndexOf(string sourceColumn);
    public int IndexOfDataSetColumn(string dataSetColumn);
    public void Insert(int index, DataColumnMapping value);
    public sealed virtual void Insert(int index, object value);
    public void Remove(DataColumnMapping value);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void RemoveAt(string sourceColumn);
    private sealed virtual override IColumnMapping System.Data.IColumnMappingCollection.Add(string sourceColumnName, string dataSetColumnName);
    private sealed virtual override IColumnMapping System.Data.IColumnMappingCollection.GetByDataSetColumn(string dataSetColumnName);
}
public class System.Data.Common.DataTableMapping : MarshalByRefObject {
    [DesignerSerializationVisibilityAttribute("2")]
public DataColumnMappingCollection ColumnMappings { get; }
    [DefaultValueAttribute("")]
public string DataSetTable { get; public set; }
    [DefaultValueAttribute("")]
public string SourceTable { get; public set; }
    private IColumnMappingCollection System.Data.ITableMapping.ColumnMappings { get; }
    public DataTableMapping(string sourceTable, string dataSetTable);
    public DataTableMapping(string sourceTable, string dataSetTable, DataColumnMapping[] columnMappings);
    public DataColumnMappingCollection get_ColumnMappings();
    public sealed virtual string get_DataSetTable();
    public sealed virtual void set_DataSetTable(string value);
    public sealed virtual string get_SourceTable();
    public sealed virtual void set_SourceTable(string value);
    private sealed virtual override IColumnMappingCollection System.Data.ITableMapping.get_ColumnMappings();
    [EditorBrowsableAttribute("2")]
public DataColumnMapping GetColumnMappingBySchemaAction(string sourceColumn, MissingMappingAction mappingAction);
    [EditorBrowsableAttribute("2")]
public DataColumn GetDataColumn(string sourceColumn, Type dataType, DataTable dataTable, MissingMappingAction mappingAction, MissingSchemaAction schemaAction);
    [EditorBrowsableAttribute("2")]
public DataTable GetDataTableBySchemaAction(DataSet dataSet, MissingSchemaAction schemaAction);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[ListBindableAttribute("False")]
public class System.Data.Common.DataTableMappingCollection : MarshalByRefObject {
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int Count { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataTableMapping Item { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataTableMapping Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private object System.Data.ITableMappingCollection.Item { get; private set; }
    public sealed virtual int get_Count();
    public DataTableMapping get_Item(int index);
    public void set_Item(int index, DataTableMapping value);
    public DataTableMapping get_Item(string sourceTable);
    public void set_Item(string sourceTable, DataTableMapping value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override object System.Data.ITableMappingCollection.get_Item(string index);
    private sealed virtual override void System.Data.ITableMappingCollection.set_Item(string index, object value);
    public sealed virtual int Add(object value);
    public DataTableMapping Add(string sourceTable, string dataSetTable);
    public void AddRange(Array values);
    public void AddRange(DataTableMapping[] values);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual bool Contains(string value);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(DataTableMapping[] array, int index);
    public DataTableMapping GetByDataSetTable(string dataSetTable);
    public sealed virtual IEnumerator GetEnumerator();
    [EditorBrowsableAttribute("2")]
public static DataTableMapping GetTableMappingBySchemaAction(DataTableMappingCollection tableMappings, string sourceTable, string dataSetTable, MissingMappingAction mappingAction);
    public sealed virtual int IndexOf(object value);
    public sealed virtual int IndexOf(string sourceTable);
    public int IndexOfDataSetTable(string dataSetTable);
    public void Insert(int index, DataTableMapping value);
    public sealed virtual void Insert(int index, object value);
    public void Remove(DataTableMapping value);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void RemoveAt(string sourceTable);
    private sealed virtual override ITableMapping System.Data.ITableMappingCollection.Add(string sourceTableName, string dataSetTableName);
    private sealed virtual override ITableMapping System.Data.ITableMappingCollection.GetByDataSetTable(string dataSetTableName);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Data.Common.DbColumn : object {
    public Nullable`1<bool> AllowDBNull { get; protected set; }
    public string BaseCatalogName { get; protected set; }
    public string BaseColumnName { get; protected set; }
    public string BaseSchemaName { get; protected set; }
    public string BaseServerName { get; protected set; }
    public string BaseTableName { get; protected set; }
    public string ColumnName { get; protected set; }
    public Nullable`1<int> ColumnOrdinal { get; protected set; }
    public Nullable`1<int> ColumnSize { get; protected set; }
    public Type DataType { get; protected set; }
    public string DataTypeName { get; protected set; }
    public Nullable`1<bool> IsAliased { get; protected set; }
    public Nullable`1<bool> IsAutoIncrement { get; protected set; }
    public Nullable`1<bool> IsExpression { get; protected set; }
    public Nullable`1<bool> IsHidden { get; protected set; }
    public Nullable`1<bool> IsIdentity { get; protected set; }
    public Nullable`1<bool> IsKey { get; protected set; }
    public Nullable`1<bool> IsLong { get; protected set; }
    public Nullable`1<bool> IsReadOnly { get; protected set; }
    public Nullable`1<bool> IsUnique { get; protected set; }
    public object Item { get; }
    public Nullable`1<int> NumericPrecision { get; protected set; }
    public Nullable`1<int> NumericScale { get; protected set; }
    public string UdtAssemblyQualifiedName { get; protected set; }
    public Nullable`1<bool> get_AllowDBNull();
    protected void set_AllowDBNull(Nullable`1<bool> value);
    public string get_BaseCatalogName();
    protected void set_BaseCatalogName(string value);
    public string get_BaseColumnName();
    protected void set_BaseColumnName(string value);
    public string get_BaseSchemaName();
    protected void set_BaseSchemaName(string value);
    public string get_BaseServerName();
    protected void set_BaseServerName(string value);
    public string get_BaseTableName();
    protected void set_BaseTableName(string value);
    public string get_ColumnName();
    protected void set_ColumnName(string value);
    public Nullable`1<int> get_ColumnOrdinal();
    protected void set_ColumnOrdinal(Nullable`1<int> value);
    public Nullable`1<int> get_ColumnSize();
    protected void set_ColumnSize(Nullable`1<int> value);
    public Type get_DataType();
    protected void set_DataType(Type value);
    public string get_DataTypeName();
    protected void set_DataTypeName(string value);
    public Nullable`1<bool> get_IsAliased();
    protected void set_IsAliased(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsAutoIncrement();
    protected void set_IsAutoIncrement(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsExpression();
    protected void set_IsExpression(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsHidden();
    protected void set_IsHidden(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsIdentity();
    protected void set_IsIdentity(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsKey();
    protected void set_IsKey(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsLong();
    protected void set_IsLong(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsReadOnly();
    protected void set_IsReadOnly(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsUnique();
    protected void set_IsUnique(Nullable`1<bool> value);
    public virtual object get_Item(string property);
    public Nullable`1<int> get_NumericPrecision();
    protected void set_NumericPrecision(Nullable`1<int> value);
    public Nullable`1<int> get_NumericScale();
    protected void set_NumericScale(Nullable`1<int> value);
    public string get_UdtAssemblyQualifiedName();
    protected void set_UdtAssemblyQualifiedName(string value);
}
public abstract class System.Data.Common.DbCommand : Component {
    [DefaultValueAttribute("")]
[RefreshPropertiesAttribute("1")]
public string CommandText { get; public set; }
    public int CommandTimeout { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[RefreshPropertiesAttribute("1")]
public CommandType CommandType { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("0")]
public DbConnection Connection { get; public set; }
    protected DbConnection DbConnection { get; protected set; }
    protected DbParameterCollection DbParameterCollection { get; }
    protected DbTransaction DbTransaction { get; protected set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("True")]
[DesignOnlyAttribute("True")]
[EditorBrowsableAttribute("1")]
public bool DesignTimeVisible { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DbParameterCollection Parameters { get; }
    private IDbConnection System.Data.IDbCommand.Connection { get; private set; }
    private IDataParameterCollection System.Data.IDbCommand.Parameters { get; }
    private IDbTransaction System.Data.IDbCommand.Transaction { get; private set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("0")]
public DbTransaction Transaction { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public UpdateRowSource UpdatedRowSource { get; public set; }
    public abstract virtual string get_CommandText();
    public abstract virtual void set_CommandText(string value);
    public abstract virtual int get_CommandTimeout();
    public abstract virtual void set_CommandTimeout(int value);
    public abstract virtual CommandType get_CommandType();
    public abstract virtual void set_CommandType(CommandType value);
    public DbConnection get_Connection();
    public void set_Connection(DbConnection value);
    protected abstract virtual DbConnection get_DbConnection();
    protected abstract virtual void set_DbConnection(DbConnection value);
    protected abstract virtual DbParameterCollection get_DbParameterCollection();
    protected abstract virtual DbTransaction get_DbTransaction();
    protected abstract virtual void set_DbTransaction(DbTransaction value);
    public abstract virtual bool get_DesignTimeVisible();
    public abstract virtual void set_DesignTimeVisible(bool value);
    public DbParameterCollection get_Parameters();
    private sealed virtual override IDbConnection System.Data.IDbCommand.get_Connection();
    private sealed virtual override void System.Data.IDbCommand.set_Connection(IDbConnection value);
    private sealed virtual override IDataParameterCollection System.Data.IDbCommand.get_Parameters();
    private sealed virtual override IDbTransaction System.Data.IDbCommand.get_Transaction();
    private sealed virtual override void System.Data.IDbCommand.set_Transaction(IDbTransaction value);
    public DbTransaction get_Transaction();
    public void set_Transaction(DbTransaction value);
    public abstract virtual UpdateRowSource get_UpdatedRowSource();
    public abstract virtual void set_UpdatedRowSource(UpdateRowSource value);
    public abstract virtual void Cancel();
    protected abstract virtual DbParameter CreateDbParameter();
    public DbParameter CreateParameter();
    protected abstract virtual DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
    protected virtual Task`1<DbDataReader> ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
    public abstract virtual int ExecuteNonQuery();
    public Task`1<int> ExecuteNonQueryAsync();
    public virtual Task`1<int> ExecuteNonQueryAsync(CancellationToken cancellationToken);
    public DbDataReader ExecuteReader();
    public DbDataReader ExecuteReader(CommandBehavior behavior);
    public Task`1<DbDataReader> ExecuteReaderAsync();
    public Task`1<DbDataReader> ExecuteReaderAsync(CommandBehavior behavior);
    public Task`1<DbDataReader> ExecuteReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
    public Task`1<DbDataReader> ExecuteReaderAsync(CancellationToken cancellationToken);
    public abstract virtual object ExecuteScalar();
    public Task`1<object> ExecuteScalarAsync();
    public virtual Task`1<object> ExecuteScalarAsync(CancellationToken cancellationToken);
    public abstract virtual void Prepare();
    public virtual Task PrepareAsync(CancellationToken cancellationToken);
    private sealed virtual override IDbDataParameter System.Data.IDbCommand.CreateParameter();
    private sealed virtual override IDataReader System.Data.IDbCommand.ExecuteReader();
    private sealed virtual override IDataReader System.Data.IDbCommand.ExecuteReader(CommandBehavior behavior);
    public virtual ValueTask DisposeAsync();
}
public abstract class System.Data.Common.DbCommandBuilder : Component {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public CatalogLocation CatalogLocation { get; public set; }
    [DefaultValueAttribute(".")]
public string CatalogSeparator { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ConflictOption ConflictOption { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DbDataAdapter DataAdapter { get; public set; }
    [DefaultValueAttribute("")]
public string QuotePrefix { get; public set; }
    [DefaultValueAttribute("")]
public string QuoteSuffix { get; public set; }
    [DefaultValueAttribute(".")]
public string SchemaSeparator { get; public set; }
    [DefaultValueAttribute("False")]
public bool SetAllValues { get; public set; }
    public virtual CatalogLocation get_CatalogLocation();
    public virtual void set_CatalogLocation(CatalogLocation value);
    public virtual string get_CatalogSeparator();
    public virtual void set_CatalogSeparator(string value);
    public virtual ConflictOption get_ConflictOption();
    public virtual void set_ConflictOption(ConflictOption value);
    public DbDataAdapter get_DataAdapter();
    public void set_DataAdapter(DbDataAdapter value);
    public virtual string get_QuotePrefix();
    public virtual void set_QuotePrefix(string value);
    public virtual string get_QuoteSuffix();
    public virtual void set_QuoteSuffix(string value);
    public virtual string get_SchemaSeparator();
    public virtual void set_SchemaSeparator(string value);
    public bool get_SetAllValues();
    public void set_SetAllValues(bool value);
    protected abstract virtual void ApplyParameterInfo(DbParameter parameter, DataRow row, StatementType statementType, bool whereClause);
    protected virtual void Dispose(bool disposing);
    public DbCommand GetDeleteCommand();
    public DbCommand GetDeleteCommand(bool useColumnsForParameterNames);
    public DbCommand GetInsertCommand();
    public DbCommand GetInsertCommand(bool useColumnsForParameterNames);
    protected abstract virtual string GetParameterName(int parameterOrdinal);
    protected abstract virtual string GetParameterName(string parameterName);
    protected abstract virtual string GetParameterPlaceholder(int parameterOrdinal);
    protected virtual DataTable GetSchemaTable(DbCommand sourceCommand);
    public DbCommand GetUpdateCommand();
    public DbCommand GetUpdateCommand(bool useColumnsForParameterNames);
    protected virtual DbCommand InitializeCommand(DbCommand command);
    public virtual string QuoteIdentifier(string unquotedIdentifier);
    public virtual void RefreshSchema();
    protected void RowUpdatingHandler(RowUpdatingEventArgs rowUpdatingEvent);
    protected abstract virtual void SetRowUpdatingHandler(DbDataAdapter adapter);
    public virtual string UnquoteIdentifier(string quotedIdentifier);
}
public abstract class System.Data.Common.DbConnection : Component {
    [DefaultValueAttribute("")]
[RecommendedAsConfigurableAttribute("True")]
[RefreshPropertiesAttribute("1")]
[SettingsBindableAttribute("True")]
public string ConnectionString { get; public set; }
    public int ConnectionTimeout { get; }
    public string Database { get; }
    public string DataSource { get; }
    protected DbProviderFactory DbProviderFactory { get; }
    [BrowsableAttribute("False")]
public string ServerVersion { get; }
    [BrowsableAttribute("False")]
public ConnectionState State { get; }
    public abstract virtual string get_ConnectionString();
    public abstract virtual void set_ConnectionString(string value);
    public virtual int get_ConnectionTimeout();
    public abstract virtual string get_Database();
    public abstract virtual string get_DataSource();
    protected virtual DbProviderFactory get_DbProviderFactory();
    public abstract virtual string get_ServerVersion();
    public abstract virtual ConnectionState get_State();
    public virtual void add_StateChange(StateChangeEventHandler value);
    public virtual void remove_StateChange(StateChangeEventHandler value);
    protected abstract virtual DbTransaction BeginDbTransaction(IsolationLevel isolationLevel);
    public DbTransaction BeginTransaction();
    public DbTransaction BeginTransaction(IsolationLevel isolationLevel);
    public abstract virtual void ChangeDatabase(string databaseName);
    public virtual Task ChangeDatabaseAsync(string databaseName, CancellationToken cancellationToken);
    public abstract virtual void Close();
    public virtual Task CloseAsync();
    public DbCommand CreateCommand();
    protected abstract virtual DbCommand CreateDbCommand();
    public virtual void EnlistTransaction(Transaction transaction);
    public virtual DataTable GetSchema();
    public virtual DataTable GetSchema(string collectionName);
    public virtual DataTable GetSchema(string collectionName, String[] restrictionValues);
    protected virtual void OnStateChange(StateChangeEventArgs stateChange);
    public abstract virtual void Open();
    public Task OpenAsync();
    public virtual Task OpenAsync(CancellationToken cancellationToken);
    private sealed virtual override IDbTransaction System.Data.IDbConnection.BeginTransaction();
    private sealed virtual override IDbTransaction System.Data.IDbConnection.BeginTransaction(IsolationLevel isolationLevel);
    protected virtual ValueTask`1<DbTransaction> BeginDbTransactionAsync(IsolationLevel isolationLevel, CancellationToken cancellationToken);
    public ValueTask`1<DbTransaction> BeginTransactionAsync(CancellationToken cancellationToken);
    public ValueTask`1<DbTransaction> BeginTransactionAsync(IsolationLevel isolationLevel, CancellationToken cancellationToken);
    private sealed virtual override IDbCommand System.Data.IDbConnection.CreateCommand();
    public virtual ValueTask DisposeAsync();
}
[DefaultMemberAttribute("Item")]
public class System.Data.Common.DbConnectionStringBuilder : object {
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[DesignOnlyAttribute("True")]
[EditorBrowsableAttribute("1")]
public bool BrowsableConnectionString { get; public set; }
    [RefreshPropertiesAttribute("1")]
public string ConnectionString { get; public set; }
    [BrowsableAttribute("False")]
public int Count { get; }
    [BrowsableAttribute("False")]
public bool IsFixedSize { get; }
    [BrowsableAttribute("False")]
public bool IsReadOnly { get; }
    [BrowsableAttribute("False")]
public object Item { get; public set; }
    [BrowsableAttribute("False")]
public ICollection Keys { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    [BrowsableAttribute("False")]
public ICollection Values { get; }
    public DbConnectionStringBuilder(bool useOdbcRules);
    public bool get_BrowsableConnectionString();
    public void set_BrowsableConnectionString(bool value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public virtual object get_Item(string keyword);
    public virtual void set_Item(string keyword, object value);
    public virtual ICollection get_Keys();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object keyword);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object keyword, object value);
    public virtual ICollection get_Values();
    public void Add(string keyword, object value);
    public static void AppendKeyValuePair(StringBuilder builder, string keyword, string value);
    public static void AppendKeyValuePair(StringBuilder builder, string keyword, string value, bool useOdbcRules);
    public virtual void Clear();
    protected internal void ClearPropertyDescriptors();
    public virtual bool ContainsKey(string keyword);
    public virtual bool EquivalentTo(DbConnectionStringBuilder connectionStringBuilder);
    protected virtual void GetProperties(Hashtable propertyDescriptors);
    public virtual bool Remove(string keyword);
    public virtual bool ShouldSerialize(string keyword);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object keyword, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object keyword);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object keyword);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    public virtual string ToString();
    public virtual bool TryGetValue(string keyword, Object& value);
}
public abstract class System.Data.Common.DbDataAdapter : DataAdapter {
    public static string DefaultSourceTableName;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DbCommand DeleteCommand { get; public set; }
    protected internal CommandBehavior FillCommandBehavior { get; protected internal set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DbCommand InsertCommand { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DbCommand SelectCommand { get; public set; }
    private IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; private set; }
    private IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; private set; }
    private IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; private set; }
    private IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; private set; }
    [DefaultValueAttribute("1")]
public int UpdateBatchSize { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DbCommand UpdateCommand { get; public set; }
    protected DbDataAdapter(DbDataAdapter adapter);
    public DbCommand get_DeleteCommand();
    public void set_DeleteCommand(DbCommand value);
    protected internal CommandBehavior get_FillCommandBehavior();
    protected internal void set_FillCommandBehavior(CommandBehavior value);
    public DbCommand get_InsertCommand();
    public void set_InsertCommand(DbCommand value);
    public DbCommand get_SelectCommand();
    public void set_SelectCommand(DbCommand value);
    private sealed virtual override IDbCommand System.Data.IDbDataAdapter.get_DeleteCommand();
    private sealed virtual override void System.Data.IDbDataAdapter.set_DeleteCommand(IDbCommand value);
    private sealed virtual override IDbCommand System.Data.IDbDataAdapter.get_InsertCommand();
    private sealed virtual override void System.Data.IDbDataAdapter.set_InsertCommand(IDbCommand value);
    private sealed virtual override IDbCommand System.Data.IDbDataAdapter.get_SelectCommand();
    private sealed virtual override void System.Data.IDbDataAdapter.set_SelectCommand(IDbCommand value);
    private sealed virtual override IDbCommand System.Data.IDbDataAdapter.get_UpdateCommand();
    private sealed virtual override void System.Data.IDbDataAdapter.set_UpdateCommand(IDbCommand value);
    public virtual int get_UpdateBatchSize();
    public virtual void set_UpdateBatchSize(int value);
    public DbCommand get_UpdateCommand();
    public void set_UpdateCommand(DbCommand value);
    protected virtual int AddToBatch(IDbCommand command);
    protected virtual void ClearBatch();
    protected virtual RowUpdatedEventArgs CreateRowUpdatedEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
    protected virtual RowUpdatingEventArgs CreateRowUpdatingEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
    protected virtual void Dispose(bool disposing);
    protected virtual int ExecuteBatch();
    public virtual int Fill(DataSet dataSet);
    public int Fill(DataSet dataSet, int startRecord, int maxRecords, string srcTable);
    protected virtual int Fill(DataSet dataSet, int startRecord, int maxRecords, string srcTable, IDbCommand command, CommandBehavior behavior);
    public int Fill(DataSet dataSet, string srcTable);
    public int Fill(DataTable dataTable);
    protected virtual int Fill(DataTable dataTable, IDbCommand command, CommandBehavior behavior);
    protected virtual int Fill(DataTable[] dataTables, int startRecord, int maxRecords, IDbCommand command, CommandBehavior behavior);
    public int Fill(int startRecord, int maxRecords, DataTable[] dataTables);
    public virtual DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType);
    protected virtual DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType, IDbCommand command, string srcTable, CommandBehavior behavior);
    public DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType, string srcTable);
    public DataTable FillSchema(DataTable dataTable, SchemaType schemaType);
    protected virtual DataTable FillSchema(DataTable dataTable, SchemaType schemaType, IDbCommand command, CommandBehavior behavior);
    protected virtual IDataParameter GetBatchedParameter(int commandIdentifier, int parameterIndex);
    protected virtual bool GetBatchedRecordsAffected(int commandIdentifier, Int32& recordsAffected, Exception& error);
    [EditorBrowsableAttribute("2")]
public virtual IDataParameter[] GetFillParameters();
    protected virtual void InitializeBatching();
    protected virtual void OnRowUpdated(RowUpdatedEventArgs value);
    protected virtual void OnRowUpdating(RowUpdatingEventArgs value);
    private sealed virtual override object System.ICloneable.Clone();
    protected virtual void TerminateBatching();
    public int Update(DataRow[] dataRows);
    protected virtual int Update(DataRow[] dataRows, DataTableMapping tableMapping);
    public virtual int Update(DataSet dataSet);
    public int Update(DataSet dataSet, string srcTable);
    public int Update(DataTable dataTable);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Data.Common.DbDataReader : MarshalByRefObject {
    public int Depth { get; }
    public int FieldCount { get; }
    public bool HasRows { get; }
    public bool IsClosed { get; }
    public object Item { get; }
    public object Item { get; }
    public int RecordsAffected { get; }
    public int VisibleFieldCount { get; }
    public abstract virtual int get_Depth();
    public abstract virtual int get_FieldCount();
    public abstract virtual bool get_HasRows();
    public abstract virtual bool get_IsClosed();
    public abstract virtual object get_Item(int ordinal);
    public abstract virtual object get_Item(string name);
    public abstract virtual int get_RecordsAffected();
    public virtual int get_VisibleFieldCount();
    public virtual void Close();
    public virtual Task CloseAsync();
    [EditorBrowsableAttribute("1")]
public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public abstract virtual bool GetBoolean(int ordinal);
    public abstract virtual byte GetByte(int ordinal);
    public abstract virtual long GetBytes(int ordinal, long dataOffset, Byte[] buffer, int bufferOffset, int length);
    public abstract virtual char GetChar(int ordinal);
    public abstract virtual long GetChars(int ordinal, long dataOffset, Char[] buffer, int bufferOffset, int length);
    [EditorBrowsableAttribute("1")]
public DbDataReader GetData(int ordinal);
    public abstract virtual string GetDataTypeName(int ordinal);
    public abstract virtual DateTime GetDateTime(int ordinal);
    protected virtual DbDataReader GetDbDataReader(int ordinal);
    public abstract virtual decimal GetDecimal(int ordinal);
    public abstract virtual double GetDouble(int ordinal);
    [EditorBrowsableAttribute("1")]
public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual Type GetFieldType(int ordinal);
    public Task`1<T> GetFieldValueAsync(int ordinal);
    public virtual Task`1<T> GetFieldValueAsync(int ordinal, CancellationToken cancellationToken);
    public virtual T GetFieldValue(int ordinal);
    public abstract virtual float GetFloat(int ordinal);
    public abstract virtual Guid GetGuid(int ordinal);
    public abstract virtual short GetInt16(int ordinal);
    public abstract virtual int GetInt32(int ordinal);
    public abstract virtual long GetInt64(int ordinal);
    public abstract virtual string GetName(int ordinal);
    public abstract virtual int GetOrdinal(string name);
    [EditorBrowsableAttribute("1")]
public virtual Type GetProviderSpecificFieldType(int ordinal);
    [EditorBrowsableAttribute("1")]
public virtual object GetProviderSpecificValue(int ordinal);
    [EditorBrowsableAttribute("1")]
public virtual int GetProviderSpecificValues(Object[] values);
    public virtual DataTable GetSchemaTable();
    public virtual Stream GetStream(int ordinal);
    public abstract virtual string GetString(int ordinal);
    public virtual TextReader GetTextReader(int ordinal);
    public abstract virtual object GetValue(int ordinal);
    public abstract virtual int GetValues(Object[] values);
    public abstract virtual bool IsDBNull(int ordinal);
    public Task`1<bool> IsDBNullAsync(int ordinal);
    public virtual Task`1<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
    public abstract virtual bool NextResult();
    public Task`1<bool> NextResultAsync();
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public abstract virtual bool Read();
    public Task`1<bool> ReadAsync();
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    private sealed virtual override IDataReader System.Data.IDataRecord.GetData(int ordinal);
}
[ExtensionAttribute]
public static class System.Data.Common.DbDataReaderExtensions : object {
    [ExtensionAttribute]
public static bool CanGetColumnSchema(DbDataReader reader);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<DbColumn> GetColumnSchema(DbDataReader reader);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Data.Common.DbDataRecord : object {
    public int FieldCount { get; }
    public object Item { get; }
    public object Item { get; }
    public abstract virtual int get_FieldCount();
    public abstract virtual object get_Item(int i);
    public abstract virtual object get_Item(string name);
    public abstract virtual bool GetBoolean(int i);
    public abstract virtual byte GetByte(int i);
    public abstract virtual long GetBytes(int i, long dataIndex, Byte[] buffer, int bufferIndex, int length);
    public abstract virtual char GetChar(int i);
    public abstract virtual long GetChars(int i, long dataIndex, Char[] buffer, int bufferIndex, int length);
    public sealed virtual IDataReader GetData(int i);
    public abstract virtual string GetDataTypeName(int i);
    public abstract virtual DateTime GetDateTime(int i);
    protected virtual DbDataReader GetDbDataReader(int i);
    public abstract virtual decimal GetDecimal(int i);
    public abstract virtual double GetDouble(int i);
    public abstract virtual Type GetFieldType(int i);
    public abstract virtual float GetFloat(int i);
    public abstract virtual Guid GetGuid(int i);
    public abstract virtual short GetInt16(int i);
    public abstract virtual int GetInt32(int i);
    public abstract virtual long GetInt64(int i);
    public abstract virtual string GetName(int i);
    public abstract virtual int GetOrdinal(string name);
    public abstract virtual string GetString(int i);
    public abstract virtual object GetValue(int i);
    public abstract virtual int GetValues(Object[] values);
    public abstract virtual bool IsDBNull(int i);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
}
public abstract class System.Data.Common.DbDataSourceEnumerator : object {
    public abstract virtual DataTable GetDataSources();
}
public class System.Data.Common.DbEnumerator : object {
    public object Current { get; }
    public DbEnumerator(DbDataReader reader);
    public DbEnumerator(DbDataReader reader, bool closeReader);
    public DbEnumerator(IDataReader reader);
    public DbEnumerator(IDataReader reader, bool closeReader);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    [EditorBrowsableAttribute("1")]
public sealed virtual void Reset();
}
public abstract class System.Data.Common.DbException : ExternalException {
    protected DbException(SerializationInfo info, StreamingContext context);
    protected DbException(string message);
    protected DbException(string message, Exception innerException);
    protected DbException(string message, int errorCode);
}
public static class System.Data.Common.DbMetaDataCollectionNames : object {
    public static string DataSourceInformation;
    public static string DataTypes;
    public static string MetaDataCollections;
    public static string ReservedWords;
    public static string Restrictions;
}
public static class System.Data.Common.DbMetaDataColumnNames : object {
    public static string CollectionName;
    public static string ColumnSize;
    public static string CompositeIdentifierSeparatorPattern;
    public static string CreateFormat;
    public static string CreateParameters;
    public static string DataSourceProductName;
    public static string DataSourceProductVersion;
    public static string DataSourceProductVersionNormalized;
    public static string DataType;
    public static string GroupByBehavior;
    public static string IdentifierCase;
    public static string IdentifierPattern;
    public static string IsAutoIncrementable;
    public static string IsBestMatch;
    public static string IsCaseSensitive;
    public static string IsConcurrencyType;
    public static string IsFixedLength;
    public static string IsFixedPrecisionScale;
    public static string IsLiteralSupported;
    public static string IsLong;
    public static string IsNullable;
    public static string IsSearchable;
    public static string IsSearchableWithLike;
    public static string IsUnsigned;
    public static string LiteralPrefix;
    public static string LiteralSuffix;
    public static string MaximumScale;
    public static string MinimumScale;
    public static string NumberOfIdentifierParts;
    public static string NumberOfRestrictions;
    public static string OrderByColumnsInSelect;
    public static string ParameterMarkerFormat;
    public static string ParameterMarkerPattern;
    public static string ParameterNameMaxLength;
    public static string ParameterNamePattern;
    public static string ProviderDbType;
    public static string QuotedIdentifierCase;
    public static string QuotedIdentifierPattern;
    public static string ReservedWord;
    public static string StatementSeparatorPattern;
    public static string StringLiteralPattern;
    public static string SupportedJoinOperators;
    public static string TypeName;
}
public abstract class System.Data.Common.DbParameter : MarshalByRefObject {
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[RefreshPropertiesAttribute("1")]
public DbType DbType { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[RefreshPropertiesAttribute("1")]
public ParameterDirection Direction { get; public set; }
    [BrowsableAttribute("False")]
[DesignOnlyAttribute("True")]
[EditorBrowsableAttribute("1")]
public bool IsNullable { get; public set; }
    [DefaultValueAttribute("")]
public string ParameterName { get; public set; }
    public byte Precision { get; public set; }
    public byte Scale { get; public set; }
    public int Size { get; public set; }
    [DefaultValueAttribute("")]
public string SourceColumn { get; public set; }
    [DefaultValueAttribute("False")]
[EditorBrowsableAttribute("2")]
[RefreshPropertiesAttribute("1")]
public bool SourceColumnNullMapping { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public DataRowVersion SourceVersion { get; public set; }
    private byte System.Data.IDbDataParameter.Precision { get; private set; }
    private byte System.Data.IDbDataParameter.Scale { get; private set; }
    [DefaultValueAttribute("")]
[RefreshPropertiesAttribute("1")]
public object Value { get; public set; }
    public abstract virtual DbType get_DbType();
    public abstract virtual void set_DbType(DbType value);
    public abstract virtual ParameterDirection get_Direction();
    public abstract virtual void set_Direction(ParameterDirection value);
    public abstract virtual bool get_IsNullable();
    public abstract virtual void set_IsNullable(bool value);
    public abstract virtual string get_ParameterName();
    public abstract virtual void set_ParameterName(string value);
    public virtual byte get_Precision();
    public virtual void set_Precision(byte value);
    public virtual byte get_Scale();
    public virtual void set_Scale(byte value);
    public abstract virtual int get_Size();
    public abstract virtual void set_Size(int value);
    public abstract virtual string get_SourceColumn();
    public abstract virtual void set_SourceColumn(string value);
    public abstract virtual bool get_SourceColumnNullMapping();
    public abstract virtual void set_SourceColumnNullMapping(bool value);
    public virtual DataRowVersion get_SourceVersion();
    public virtual void set_SourceVersion(DataRowVersion value);
    private sealed virtual override byte System.Data.IDbDataParameter.get_Precision();
    private sealed virtual override void System.Data.IDbDataParameter.set_Precision(byte value);
    private sealed virtual override byte System.Data.IDbDataParameter.get_Scale();
    private sealed virtual override void System.Data.IDbDataParameter.set_Scale(byte value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    [EditorBrowsableAttribute("2")]
public abstract virtual void ResetDbType();
}
[DefaultMemberAttribute("Item")]
public abstract class System.Data.Common.DbParameterCollection : MarshalByRefObject {
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int Count { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[EditorBrowsableAttribute("1")]
public bool IsFixedSize { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[EditorBrowsableAttribute("1")]
public bool IsReadOnly { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[EditorBrowsableAttribute("1")]
public bool IsSynchronized { get; }
    public DbParameter Item { get; public set; }
    public DbParameter Item { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[EditorBrowsableAttribute("1")]
public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private object System.Data.IDataParameterCollection.Item { get; private set; }
    public abstract virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public DbParameter get_Item(int index);
    public void set_Item(int index, DbParameter value);
    public DbParameter get_Item(string parameterName);
    public void set_Item(string parameterName, DbParameter value);
    public abstract virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override object System.Data.IDataParameterCollection.get_Item(string parameterName);
    private sealed virtual override void System.Data.IDataParameterCollection.set_Item(string parameterName, object value);
    public abstract virtual int Add(object value);
    public abstract virtual void AddRange(Array values);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object value);
    public abstract virtual bool Contains(string value);
    public abstract virtual void CopyTo(Array array, int index);
    [EditorBrowsableAttribute("1")]
public abstract virtual IEnumerator GetEnumerator();
    protected abstract virtual DbParameter GetParameter(int index);
    protected abstract virtual DbParameter GetParameter(string parameterName);
    public abstract virtual int IndexOf(object value);
    public abstract virtual int IndexOf(string parameterName);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual void RemoveAt(string parameterName);
    protected abstract virtual void SetParameter(int index, DbParameter value);
    protected abstract virtual void SetParameter(string parameterName, DbParameter value);
}
public static class System.Data.Common.DbProviderFactories : object {
    public static DbProviderFactory GetFactory(DbConnection connection);
    public static DbProviderFactory GetFactory(DataRow providerRow);
    public static DbProviderFactory GetFactory(string providerInvariantName);
    public static DataTable GetFactoryClasses();
    public static IEnumerable`1<string> GetProviderInvariantNames();
    public static void RegisterFactory(string providerInvariantName, DbProviderFactory factory);
    public static void RegisterFactory(string providerInvariantName, string factoryTypeAssemblyQualifiedName);
    public static void RegisterFactory(string providerInvariantName, Type providerFactoryClass);
    public static bool TryGetFactory(string providerInvariantName, DbProviderFactory& factory);
    public static bool UnregisterFactory(string providerInvariantName);
}
public abstract class System.Data.Common.DbProviderFactory : object {
    public bool CanCreateDataSourceEnumerator { get; }
    public bool CanCreateDataAdapter { get; }
    public bool CanCreateCommandBuilder { get; }
    public virtual bool get_CanCreateDataSourceEnumerator();
    public virtual bool get_CanCreateDataAdapter();
    public virtual bool get_CanCreateCommandBuilder();
    public virtual DbCommand CreateCommand();
    public virtual DbCommandBuilder CreateCommandBuilder();
    public virtual DbConnection CreateConnection();
    public virtual DbConnectionStringBuilder CreateConnectionStringBuilder();
    public virtual DbDataAdapter CreateDataAdapter();
    public virtual DbDataSourceEnumerator CreateDataSourceEnumerator();
    public virtual DbParameter CreateParameter();
}
[AttributeUsageAttribute("128")]
public class System.Data.Common.DbProviderSpecificTypePropertyAttribute : Attribute {
    public bool IsProviderSpecificTypeProperty { get; }
    public DbProviderSpecificTypePropertyAttribute(bool isProviderSpecificTypeProperty);
    public bool get_IsProviderSpecificTypeProperty();
}
public abstract class System.Data.Common.DbTransaction : MarshalByRefObject {
    public DbConnection Connection { get; }
    protected DbConnection DbConnection { get; }
    public IsolationLevel IsolationLevel { get; }
    private IDbConnection System.Data.IDbTransaction.Connection { get; }
    public DbConnection get_Connection();
    protected abstract virtual DbConnection get_DbConnection();
    public abstract virtual IsolationLevel get_IsolationLevel();
    private sealed virtual override IDbConnection System.Data.IDbTransaction.get_Connection();
    public abstract virtual void Commit();
    public virtual Task CommitAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public virtual ValueTask DisposeAsync();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Rollback();
    public virtual Task RollbackAsync(CancellationToken cancellationToken);
}
public enum System.Data.Common.GroupByBehavior : Enum {
    public int value__;
    public static GroupByBehavior ExactMatch;
    public static GroupByBehavior MustContainAll;
    public static GroupByBehavior NotSupported;
    public static GroupByBehavior Unknown;
    public static GroupByBehavior Unrelated;
}
public interface System.Data.Common.IDbColumnSchemaGenerator {
    public abstract virtual ReadOnlyCollection`1<DbColumn> GetColumnSchema();
}
public enum System.Data.Common.IdentifierCase : Enum {
    public int value__;
    public static IdentifierCase Insensitive;
    public static IdentifierCase Sensitive;
    public static IdentifierCase Unknown;
}
public class System.Data.Common.RowUpdatedEventArgs : EventArgs {
    public IDbCommand Command { get; }
    public Exception Errors { get; public set; }
    public int RecordsAffected { get; }
    public DataRow Row { get; }
    public int RowCount { get; }
    public StatementType StatementType { get; }
    public UpdateStatus Status { get; public set; }
    public DataTableMapping TableMapping { get; }
    public RowUpdatedEventArgs(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
    public IDbCommand get_Command();
    public Exception get_Errors();
    public void set_Errors(Exception value);
    public int get_RecordsAffected();
    public DataRow get_Row();
    public int get_RowCount();
    public StatementType get_StatementType();
    public UpdateStatus get_Status();
    public void set_Status(UpdateStatus value);
    public DataTableMapping get_TableMapping();
    public void CopyToRows(DataRow[] array);
    public void CopyToRows(DataRow[] array, int arrayIndex);
}
public class System.Data.Common.RowUpdatingEventArgs : EventArgs {
    protected IDbCommand BaseCommand { get; protected set; }
    public IDbCommand Command { get; public set; }
    public Exception Errors { get; public set; }
    public DataRow Row { get; }
    public StatementType StatementType { get; }
    public UpdateStatus Status { get; public set; }
    public DataTableMapping TableMapping { get; }
    public RowUpdatingEventArgs(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
    protected virtual IDbCommand get_BaseCommand();
    protected virtual void set_BaseCommand(IDbCommand value);
    public IDbCommand get_Command();
    public void set_Command(IDbCommand value);
    public Exception get_Errors();
    public void set_Errors(Exception value);
    public DataRow get_Row();
    public StatementType get_StatementType();
    public UpdateStatus get_Status();
    public void set_Status(UpdateStatus value);
    public DataTableMapping get_TableMapping();
}
public static class System.Data.Common.SchemaTableColumn : object {
    public static string AllowDBNull;
    public static string BaseColumnName;
    public static string BaseSchemaName;
    public static string BaseTableName;
    public static string ColumnName;
    public static string ColumnOrdinal;
    public static string ColumnSize;
    public static string DataType;
    public static string IsAliased;
    public static string IsExpression;
    public static string IsKey;
    public static string IsLong;
    public static string IsUnique;
    public static string NonVersionedProviderType;
    public static string NumericPrecision;
    public static string NumericScale;
    public static string ProviderType;
}
public static class System.Data.Common.SchemaTableOptionalColumn : object {
    public static string AutoIncrementSeed;
    public static string AutoIncrementStep;
    public static string BaseCatalogName;
    public static string BaseColumnNamespace;
    public static string BaseServerName;
    public static string BaseTableNamespace;
    public static string ColumnMapping;
    public static string DefaultValue;
    public static string Expression;
    public static string IsAutoIncrement;
    public static string IsHidden;
    public static string IsReadOnly;
    public static string IsRowVersion;
    public static string ProviderSpecificDataType;
}
[FlagsAttribute]
public enum System.Data.Common.SupportedJoinOperators : Enum {
    public int value__;
    public static SupportedJoinOperators FullOuter;
    public static SupportedJoinOperators Inner;
    public static SupportedJoinOperators LeftOuter;
    public static SupportedJoinOperators None;
    public static SupportedJoinOperators RightOuter;
}
public enum System.Data.ConflictOption : Enum {
    public int value__;
    public static ConflictOption CompareAllSearchableValues;
    public static ConflictOption CompareRowVersion;
    public static ConflictOption OverwriteChanges;
}
[FlagsAttribute]
public enum System.Data.ConnectionState : Enum {
    public int value__;
    public static ConnectionState Broken;
    public static ConnectionState Closed;
    public static ConnectionState Connecting;
    public static ConnectionState Executing;
    public static ConnectionState Fetching;
    public static ConnectionState Open;
}
[DefaultPropertyAttribute("ConstraintName")]
public abstract class System.Data.Constraint : object {
    [DefaultValueAttribute("")]
public string ConstraintName { get; public set; }
    [BrowsableAttribute("False")]
public PropertyCollection ExtendedProperties { get; }
    public DataTable Table { get; }
    [CLSCompliantAttribute("False")]
protected DataSet _DataSet { get; }
    public virtual string get_ConstraintName();
    public virtual void set_ConstraintName(string value);
    public PropertyCollection get_ExtendedProperties();
    public abstract virtual DataTable get_Table();
    protected virtual DataSet get__DataSet();
    protected void CheckStateForProperty();
    protected internal void SetDataSet(DataSet dataSet);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[DefaultEventAttribute("CollectionChanged")]
public class System.Data.ConstraintCollection : InternalDataCollectionBase {
    public Constraint Item { get; }
    public Constraint Item { get; }
    protected ArrayList List { get; }
    public Constraint get_Item(int index);
    public Constraint get_Item(string name);
    protected virtual ArrayList get_List();
    public void add_CollectionChanged(CollectionChangeEventHandler value);
    public void remove_CollectionChanged(CollectionChangeEventHandler value);
    public void Add(Constraint constraint);
    public Constraint Add(string name, DataColumn column, bool primaryKey);
    public Constraint Add(string name, DataColumn primaryKeyColumn, DataColumn foreignKeyColumn);
    public Constraint Add(string name, DataColumn[] columns, bool primaryKey);
    public Constraint Add(string name, DataColumn[] primaryKeyColumns, DataColumn[] foreignKeyColumns);
    public void AddRange(Constraint[] constraints);
    public bool CanRemove(Constraint constraint);
    public void Clear();
    public bool Contains(string name);
    public void CopyTo(Constraint[] array, int index);
    public int IndexOf(Constraint constraint);
    public int IndexOf(string constraintName);
    public void Remove(Constraint constraint);
    public void Remove(string name);
    public void RemoveAt(int index);
}
public class System.Data.ConstraintException : DataException {
    protected ConstraintException(SerializationInfo info, StreamingContext context);
    public ConstraintException(string s);
    public ConstraintException(string message, Exception innerException);
}
[DefaultPropertyAttribute("ColumnName")]
[DesignTimeVisibleAttribute("False")]
[ToolboxItemAttribute("False")]
public class System.Data.DataColumn : MarshalByValueComponent {
    [DefaultValueAttribute("True")]
public bool AllowDBNull { get; public set; }
    [DefaultValueAttribute("False")]
[RefreshPropertiesAttribute("1")]
public bool AutoIncrement { get; public set; }
    [DefaultValueAttribute("0")]
public long AutoIncrementSeed { get; public set; }
    [DefaultValueAttribute("1")]
public long AutoIncrementStep { get; public set; }
    public string Caption { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MappingType ColumnMapping { get; public set; }
    [DefaultValueAttribute("")]
[RefreshPropertiesAttribute("1")]
public string ColumnName { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[RefreshPropertiesAttribute("1")]
public Type DataType { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[RefreshPropertiesAttribute("1")]
public DataSetDateTime DateTimeMode { get; public set; }
    public object DefaultValue { get; public set; }
    [DefaultValueAttribute("")]
[RefreshPropertiesAttribute("1")]
public string Expression { get; public set; }
    [BrowsableAttribute("False")]
public PropertyCollection ExtendedProperties { get; }
    [DefaultValueAttribute("-1")]
public int MaxLength { get; public set; }
    public string Namespace { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int Ordinal { get; }
    [DefaultValueAttribute("")]
public string Prefix { get; public set; }
    [DefaultValueAttribute("False")]
public bool ReadOnly { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataTable Table { get; }
    [DefaultValueAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Unique { get; public set; }
    public DataColumn(string columnName);
    public DataColumn(string columnName, Type dataType);
    public DataColumn(string columnName, Type dataType, string expr);
    public DataColumn(string columnName, Type dataType, string expr, MappingType type);
    public bool get_AllowDBNull();
    public void set_AllowDBNull(bool value);
    public bool get_AutoIncrement();
    public void set_AutoIncrement(bool value);
    public long get_AutoIncrementSeed();
    public void set_AutoIncrementSeed(long value);
    public long get_AutoIncrementStep();
    public void set_AutoIncrementStep(long value);
    public string get_Caption();
    public void set_Caption(string value);
    public virtual MappingType get_ColumnMapping();
    public virtual void set_ColumnMapping(MappingType value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public Type get_DataType();
    public void set_DataType(Type value);
    public DataSetDateTime get_DateTimeMode();
    public void set_DateTimeMode(DataSetDateTime value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    public string get_Expression();
    public void set_Expression(string value);
    public PropertyCollection get_ExtendedProperties();
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public int get_Ordinal();
    public string get_Prefix();
    public void set_Prefix(string value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public DataTable get_Table();
    public bool get_Unique();
    public void set_Unique(bool value);
    protected internal void CheckNotAllowNull();
    protected void CheckUnique();
    protected virtual void OnPropertyChanging(PropertyChangedEventArgs pcevent);
    protected internal void RaisePropertyChanging(string name);
    public void SetOrdinal(int ordinal);
    public virtual string ToString();
}
public class System.Data.DataColumnChangeEventArgs : EventArgs {
    public DataColumn Column { get; }
    public object ProposedValue { get; public set; }
    public DataRow Row { get; }
    public DataColumnChangeEventArgs(DataRow row, DataColumn column, object value);
    public DataColumn get_Column();
    public object get_ProposedValue();
    public void set_ProposedValue(object value);
    public DataRow get_Row();
}
public class System.Data.DataColumnChangeEventHandler : MulticastDelegate {
    public DataColumnChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataColumnChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataColumnChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
[DefaultEventAttribute("CollectionChanged")]
public class System.Data.DataColumnCollection : InternalDataCollectionBase {
    public DataColumn Item { get; }
    public DataColumn Item { get; }
    protected ArrayList List { get; }
    public DataColumn get_Item(int index);
    public DataColumn get_Item(string name);
    protected virtual ArrayList get_List();
    public void add_CollectionChanged(CollectionChangeEventHandler value);
    public void remove_CollectionChanged(CollectionChangeEventHandler value);
    public DataColumn Add();
    public void Add(DataColumn column);
    public DataColumn Add(string columnName);
    public DataColumn Add(string columnName, Type type);
    public DataColumn Add(string columnName, Type type, string expression);
    public void AddRange(DataColumn[] columns);
    public bool CanRemove(DataColumn column);
    public void Clear();
    public bool Contains(string name);
    public void CopyTo(DataColumn[] array, int index);
    public int IndexOf(DataColumn column);
    public int IndexOf(string columnName);
    public void Remove(DataColumn column);
    public void Remove(string name);
    public void RemoveAt(int index);
}
public class System.Data.DataException : SystemException {
    protected DataException(SerializationInfo info, StreamingContext context);
    public DataException(string s);
    public DataException(string s, Exception innerException);
}
[ExtensionAttribute]
public static class System.Data.DataReaderExtensions : object {
    [ExtensionAttribute]
public static bool GetBoolean(DbDataReader reader, string name);
    [ExtensionAttribute]
public static byte GetByte(DbDataReader reader, string name);
    [ExtensionAttribute]
public static long GetBytes(DbDataReader reader, string name, long dataOffset, Byte[] buffer, int bufferOffset, int length);
    [ExtensionAttribute]
public static char GetChar(DbDataReader reader, string name);
    [ExtensionAttribute]
public static long GetChars(DbDataReader reader, string name, long dataOffset, Char[] buffer, int bufferOffset, int length);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DbDataReader GetData(DbDataReader reader, string name);
    [ExtensionAttribute]
public static string GetDataTypeName(DbDataReader reader, string name);
    [ExtensionAttribute]
public static DateTime GetDateTime(DbDataReader reader, string name);
    [ExtensionAttribute]
public static decimal GetDecimal(DbDataReader reader, string name);
    [ExtensionAttribute]
public static double GetDouble(DbDataReader reader, string name);
    [ExtensionAttribute]
public static Type GetFieldType(DbDataReader reader, string name);
    [ExtensionAttribute]
public static T GetFieldValue(DbDataReader reader, string name);
    [ExtensionAttribute]
public static Task`1<T> GetFieldValueAsync(DbDataReader reader, string name, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static float GetFloat(DbDataReader reader, string name);
    [ExtensionAttribute]
public static Guid GetGuid(DbDataReader reader, string name);
    [ExtensionAttribute]
public static short GetInt16(DbDataReader reader, string name);
    [ExtensionAttribute]
public static int GetInt32(DbDataReader reader, string name);
    [ExtensionAttribute]
public static long GetInt64(DbDataReader reader, string name);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Type GetProviderSpecificFieldType(DbDataReader reader, string name);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static object GetProviderSpecificValue(DbDataReader reader, string name);
    [ExtensionAttribute]
public static Stream GetStream(DbDataReader reader, string name);
    [ExtensionAttribute]
public static string GetString(DbDataReader reader, string name);
    [ExtensionAttribute]
public static TextReader GetTextReader(DbDataReader reader, string name);
    [ExtensionAttribute]
public static object GetValue(DbDataReader reader, string name);
    [ExtensionAttribute]
public static bool IsDBNull(DbDataReader reader, string name);
    [ExtensionAttribute]
public static Task`1<bool> IsDBNullAsync(DbDataReader reader, string name, CancellationToken cancellationToken);
}
[DefaultPropertyAttribute("RelationName")]
public class System.Data.DataRelation : object {
    public DataColumn[] ChildColumns { get; }
    public ForeignKeyConstraint ChildKeyConstraint { get; }
    public DataTable ChildTable { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataSet DataSet { get; }
    [BrowsableAttribute("False")]
public PropertyCollection ExtendedProperties { get; }
    [DefaultValueAttribute("False")]
public bool Nested { get; public set; }
    public DataColumn[] ParentColumns { get; }
    public UniqueConstraint ParentKeyConstraint { get; }
    public DataTable ParentTable { get; }
    [DefaultValueAttribute("")]
public string RelationName { get; public set; }
    public DataRelation(string relationName, DataColumn parentColumn, DataColumn childColumn);
    public DataRelation(string relationName, DataColumn parentColumn, DataColumn childColumn, bool createConstraints);
    public DataRelation(string relationName, DataColumn[] parentColumns, DataColumn[] childColumns);
    public DataRelation(string relationName, DataColumn[] parentColumns, DataColumn[] childColumns, bool createConstraints);
    [BrowsableAttribute("False")]
public DataRelation(string relationName, string parentTableName, string parentTableNamespace, string childTableName, string childTableNamespace, String[] parentColumnNames, String[] childColumnNames, bool nested);
    [BrowsableAttribute("False")]
public DataRelation(string relationName, string parentTableName, string childTableName, String[] parentColumnNames, String[] childColumnNames, bool nested);
    public virtual DataColumn[] get_ChildColumns();
    public virtual ForeignKeyConstraint get_ChildKeyConstraint();
    public virtual DataTable get_ChildTable();
    public virtual DataSet get_DataSet();
    public PropertyCollection get_ExtendedProperties();
    public virtual bool get_Nested();
    public virtual void set_Nested(bool value);
    public virtual DataColumn[] get_ParentColumns();
    public virtual UniqueConstraint get_ParentKeyConstraint();
    public virtual DataTable get_ParentTable();
    public virtual string get_RelationName();
    public virtual void set_RelationName(string value);
    protected void CheckStateForProperty();
    protected internal void OnPropertyChanging(PropertyChangedEventArgs pcevent);
    protected internal void RaisePropertyChanging(string name);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[DefaultEventAttribute("CollectionChanged")]
[DefaultPropertyAttribute("Table")]
public abstract class System.Data.DataRelationCollection : InternalDataCollectionBase {
    public DataRelation Item { get; }
    public DataRelation Item { get; }
    public abstract virtual DataRelation get_Item(int index);
    public abstract virtual DataRelation get_Item(string name);
    public void add_CollectionChanged(CollectionChangeEventHandler value);
    public void remove_CollectionChanged(CollectionChangeEventHandler value);
    public virtual DataRelation Add(DataColumn parentColumn, DataColumn childColumn);
    public virtual DataRelation Add(DataColumn[] parentColumns, DataColumn[] childColumns);
    public void Add(DataRelation relation);
    public virtual DataRelation Add(string name, DataColumn parentColumn, DataColumn childColumn);
    public virtual DataRelation Add(string name, DataColumn parentColumn, DataColumn childColumn, bool createConstraints);
    public virtual DataRelation Add(string name, DataColumn[] parentColumns, DataColumn[] childColumns);
    public virtual DataRelation Add(string name, DataColumn[] parentColumns, DataColumn[] childColumns, bool createConstraints);
    protected virtual void AddCore(DataRelation relation);
    public virtual void AddRange(DataRelation[] relations);
    public virtual bool CanRemove(DataRelation relation);
    public virtual void Clear();
    public virtual bool Contains(string name);
    public void CopyTo(DataRelation[] array, int index);
    protected abstract virtual DataSet GetDataSet();
    public virtual int IndexOf(DataRelation relation);
    public virtual int IndexOf(string relationName);
    protected virtual void OnCollectionChanged(CollectionChangeEventArgs ccevent);
    protected virtual void OnCollectionChanging(CollectionChangeEventArgs ccevent);
    public void Remove(DataRelation relation);
    public void Remove(string name);
    public void RemoveAt(int index);
    protected virtual void RemoveCore(DataRelation relation);
}
[DefaultMemberAttribute("Item")]
public class System.Data.DataRow : object {
    public bool HasErrors { get; }
    public object Item { get; public set; }
    public object Item { get; }
    public object Item { get; public set; }
    public object Item { get; }
    public object Item { get; public set; }
    public object Item { get; }
    public Object[] ItemArray { get; public set; }
    public string RowError { get; public set; }
    public DataRowState RowState { get; }
    public DataTable Table { get; }
    protected internal DataRow(DataRowBuilder builder);
    public bool get_HasErrors();
    public object get_Item(DataColumn column);
    public void set_Item(DataColumn column, object value);
    public object get_Item(DataColumn column, DataRowVersion version);
    public object get_Item(int columnIndex);
    public void set_Item(int columnIndex, object value);
    public object get_Item(int columnIndex, DataRowVersion version);
    public object get_Item(string columnName);
    public void set_Item(string columnName, object value);
    public object get_Item(string columnName, DataRowVersion version);
    public Object[] get_ItemArray();
    public void set_ItemArray(Object[] value);
    public string get_RowError();
    public void set_RowError(string value);
    public DataRowState get_RowState();
    public DataTable get_Table();
    public void AcceptChanges();
    [EditorBrowsableAttribute("2")]
public void BeginEdit();
    [EditorBrowsableAttribute("2")]
public void CancelEdit();
    public void ClearErrors();
    public void Delete();
    [EditorBrowsableAttribute("2")]
public void EndEdit();
    public DataRow[] GetChildRows(DataRelation relation);
    public DataRow[] GetChildRows(DataRelation relation, DataRowVersion version);
    public DataRow[] GetChildRows(string relationName);
    public DataRow[] GetChildRows(string relationName, DataRowVersion version);
    public string GetColumnError(DataColumn column);
    public string GetColumnError(int columnIndex);
    public string GetColumnError(string columnName);
    public DataColumn[] GetColumnsInError();
    public DataRow GetParentRow(DataRelation relation);
    public DataRow GetParentRow(DataRelation relation, DataRowVersion version);
    public DataRow GetParentRow(string relationName);
    public DataRow GetParentRow(string relationName, DataRowVersion version);
    public DataRow[] GetParentRows(DataRelation relation);
    public DataRow[] GetParentRows(DataRelation relation, DataRowVersion version);
    public DataRow[] GetParentRows(string relationName);
    public DataRow[] GetParentRows(string relationName, DataRowVersion version);
    public bool HasVersion(DataRowVersion version);
    public bool IsNull(DataColumn column);
    public bool IsNull(DataColumn column, DataRowVersion version);
    public bool IsNull(int columnIndex);
    public bool IsNull(string columnName);
    public void RejectChanges();
    public void SetAdded();
    public void SetColumnError(DataColumn column, string error);
    public void SetColumnError(int columnIndex, string error);
    public void SetColumnError(string columnName, string error);
    public void SetModified();
    protected void SetNull(DataColumn column);
    public void SetParentRow(DataRow parentRow);
    public void SetParentRow(DataRow parentRow, DataRelation relation);
}
[FlagsAttribute]
public enum System.Data.DataRowAction : Enum {
    public int value__;
    public static DataRowAction Add;
    public static DataRowAction Change;
    public static DataRowAction ChangeCurrentAndOriginal;
    public static DataRowAction ChangeOriginal;
    public static DataRowAction Commit;
    public static DataRowAction Delete;
    public static DataRowAction Nothing;
    public static DataRowAction Rollback;
}
public class System.Data.DataRowBuilder : object {
}
public class System.Data.DataRowChangeEventArgs : EventArgs {
    public DataRowAction Action { get; }
    public DataRow Row { get; }
    public DataRowChangeEventArgs(DataRow row, DataRowAction action);
    public DataRowAction get_Action();
    public DataRow get_Row();
}
public class System.Data.DataRowChangeEventHandler : MulticastDelegate {
    public DataRowChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataRowChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataRowChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.Data.DataRowCollection : InternalDataCollectionBase {
    public int Count { get; }
    public DataRow Item { get; }
    public virtual int get_Count();
    public DataRow get_Item(int index);
    public void Add(DataRow row);
    public DataRow Add(Object[] values);
    public void Clear();
    public bool Contains(object key);
    public bool Contains(Object[] keys);
    public virtual void CopyTo(Array ar, int index);
    public void CopyTo(DataRow[] array, int index);
    public DataRow Find(object key);
    public DataRow Find(Object[] keys);
    public virtual IEnumerator GetEnumerator();
    public int IndexOf(DataRow row);
    public void InsertAt(DataRow row, int pos);
    public void Remove(DataRow row);
    public void RemoveAt(int index);
}
public static class System.Data.DataRowComparer : object {
    public static DataRowComparer`1<DataRow> Default { get; }
    public static DataRowComparer`1<DataRow> get_Default();
}
public class System.Data.DataRowComparer`1 : object {
    public static DataRowComparer`1<TRow> Default { get; }
    public static DataRowComparer`1<TRow> get_Default();
    public sealed virtual bool Equals(TRow leftRow, TRow rightRow);
    public sealed virtual int GetHashCode(TRow row);
}
[ExtensionAttribute]
public static class System.Data.DataRowExtensions : object {
    [ExtensionAttribute]
public static T Field(DataRow row, DataColumn column);
    [ExtensionAttribute]
public static T Field(DataRow row, DataColumn column, DataRowVersion version);
    [ExtensionAttribute]
public static T Field(DataRow row, int columnIndex);
    [ExtensionAttribute]
public static T Field(DataRow row, int columnIndex, DataRowVersion version);
    [ExtensionAttribute]
public static T Field(DataRow row, string columnName);
    [ExtensionAttribute]
public static T Field(DataRow row, string columnName, DataRowVersion version);
    [ExtensionAttribute]
public static void SetField(DataRow row, DataColumn column, T value);
    [ExtensionAttribute]
public static void SetField(DataRow row, int columnIndex, T value);
    [ExtensionAttribute]
public static void SetField(DataRow row, string columnName, T value);
}
[FlagsAttribute]
public enum System.Data.DataRowState : Enum {
    public int value__;
    public static DataRowState Added;
    public static DataRowState Deleted;
    public static DataRowState Detached;
    public static DataRowState Modified;
    public static DataRowState Unchanged;
}
public enum System.Data.DataRowVersion : Enum {
    public int value__;
    public static DataRowVersion Current;
    public static DataRowVersion Default;
    public static DataRowVersion Original;
    public static DataRowVersion Proposed;
}
[DefaultMemberAttribute("Item")]
public class System.Data.DataRowView : object {
    public DataView DataView { get; }
    public bool IsEdit { get; }
    public bool IsNew { get; }
    public object Item { get; public set; }
    public object Item { get; public set; }
    public DataRow Row { get; }
    public DataRowVersion RowVersion { get; }
    private string System.ComponentModel.IDataErrorInfo.Error { get; }
    private string System.ComponentModel.IDataErrorInfo.Item { get; }
    public DataView get_DataView();
    public bool get_IsEdit();
    public bool get_IsNew();
    public object get_Item(int ndx);
    public void set_Item(int ndx, object value);
    public object get_Item(string property);
    public void set_Item(string property, object value);
    public DataRow get_Row();
    public DataRowVersion get_RowVersion();
    private sealed virtual override string System.ComponentModel.IDataErrorInfo.get_Error();
    private sealed virtual override string System.ComponentModel.IDataErrorInfo.get_Item(string colName);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void BeginEdit();
    public sealed virtual void CancelEdit();
    public DataView CreateChildView(DataRelation relation);
    public DataView CreateChildView(DataRelation relation, bool followParent);
    public DataView CreateChildView(string relationName);
    public DataView CreateChildView(string relationName, bool followParent);
    public void Delete();
    public sealed virtual void EndEdit();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
}
[DefaultPropertyAttribute("DataSetName")]
[ToolboxItemAttribute("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[XmlSchemaProviderAttribute("GetDataSetSchema")]
public class System.Data.DataSet : MarshalByValueComponent {
    [DefaultValueAttribute("False")]
public bool CaseSensitive { get; public set; }
    [DefaultValueAttribute("")]
public string DataSetName { get; public set; }
    [BrowsableAttribute("False")]
public DataViewManager DefaultViewManager { get; }
    [DefaultValueAttribute("True")]
public bool EnforceConstraints { get; public set; }
    [BrowsableAttribute("False")]
public PropertyCollection ExtendedProperties { get; }
    [BrowsableAttribute("False")]
public bool HasErrors { get; }
    [BrowsableAttribute("False")]
public bool IsInitialized { get; }
    public CultureInfo Locale { get; public set; }
    [DefaultValueAttribute("")]
public string Namespace { get; public set; }
    [DefaultValueAttribute("")]
public string Prefix { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public DataRelationCollection Relations { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SerializationFormat RemotingFormat { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public SchemaSerializationMode SchemaSerializationMode { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ISite Site { get; public set; }
    private bool System.ComponentModel.IListSource.ContainsListCollection { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public DataTableCollection Tables { get; }
    protected DataSet(SerializationInfo info, StreamingContext context);
    protected DataSet(SerializationInfo info, StreamingContext context, bool ConstructSchema);
    public DataSet(string dataSetName);
    public bool get_CaseSensitive();
    public void set_CaseSensitive(bool value);
    public string get_DataSetName();
    public void set_DataSetName(string value);
    public DataViewManager get_DefaultViewManager();
    public bool get_EnforceConstraints();
    public void set_EnforceConstraints(bool value);
    public PropertyCollection get_ExtendedProperties();
    public bool get_HasErrors();
    public sealed virtual bool get_IsInitialized();
    public CultureInfo get_Locale();
    public void set_Locale(CultureInfo value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public DataRelationCollection get_Relations();
    public SerializationFormat get_RemotingFormat();
    public void set_RemotingFormat(SerializationFormat value);
    public virtual SchemaSerializationMode get_SchemaSerializationMode();
    public virtual void set_SchemaSerializationMode(SchemaSerializationMode value);
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    private sealed virtual override bool System.ComponentModel.IListSource.get_ContainsListCollection();
    public DataTableCollection get_Tables();
    public sealed virtual void add_Initialized(EventHandler value);
    public sealed virtual void remove_Initialized(EventHandler value);
    public void add_MergeFailed(MergeFailedEventHandler value);
    public void remove_MergeFailed(MergeFailedEventHandler value);
    public void AcceptChanges();
    public sealed virtual void BeginInit();
    public void Clear();
    public virtual DataSet Clone();
    public DataSet Copy();
    public DataTableReader CreateDataReader();
    public DataTableReader CreateDataReader(DataTable[] dataTables);
    protected SchemaSerializationMode DetermineSchemaSerializationMode(SerializationInfo info, StreamingContext context);
    protected SchemaSerializationMode DetermineSchemaSerializationMode(XmlReader reader);
    public sealed virtual void EndInit();
    public DataSet GetChanges();
    public DataSet GetChanges(DataRowState rowStates);
    public static XmlSchemaComplexType GetDataSetSchema(XmlSchemaSet schemaSet);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual XmlSchema GetSchemaSerializable();
    protected void GetSerializationData(SerializationInfo info, StreamingContext context);
    public string GetXml();
    public string GetXmlSchema();
    public bool HasChanges();
    public bool HasChanges(DataRowState rowStates);
    public void InferXmlSchema(Stream stream, String[] nsArray);
    public void InferXmlSchema(TextReader reader, String[] nsArray);
    public void InferXmlSchema(string fileName, String[] nsArray);
    public void InferXmlSchema(XmlReader reader, String[] nsArray);
    protected virtual void InitializeDerivedDataSet();
    protected bool IsBinarySerialized(SerializationInfo info, StreamingContext context);
    public void Load(IDataReader reader, LoadOption loadOption, DataTable[] tables);
    public virtual void Load(IDataReader reader, LoadOption loadOption, FillErrorEventHandler errorHandler, DataTable[] tables);
    public void Load(IDataReader reader, LoadOption loadOption, String[] tables);
    public void Merge(DataRow[] rows);
    public void Merge(DataRow[] rows, bool preserveChanges, MissingSchemaAction missingSchemaAction);
    public void Merge(DataSet dataSet);
    public void Merge(DataSet dataSet, bool preserveChanges);
    public void Merge(DataSet dataSet, bool preserveChanges, MissingSchemaAction missingSchemaAction);
    public void Merge(DataTable table);
    public void Merge(DataTable table, bool preserveChanges, MissingSchemaAction missingSchemaAction);
    protected virtual void OnPropertyChanging(PropertyChangedEventArgs pcevent);
    protected virtual void OnRemoveRelation(DataRelation relation);
    protected internal virtual void OnRemoveTable(DataTable table);
    protected internal void RaisePropertyChanging(string name);
    public XmlReadMode ReadXml(Stream stream);
    public XmlReadMode ReadXml(Stream stream, XmlReadMode mode);
    public XmlReadMode ReadXml(TextReader reader);
    public XmlReadMode ReadXml(TextReader reader, XmlReadMode mode);
    public XmlReadMode ReadXml(string fileName);
    public XmlReadMode ReadXml(string fileName, XmlReadMode mode);
    public XmlReadMode ReadXml(XmlReader reader);
    public XmlReadMode ReadXml(XmlReader reader, XmlReadMode mode);
    public void ReadXmlSchema(Stream stream);
    public void ReadXmlSchema(TextReader reader);
    public void ReadXmlSchema(string fileName);
    public void ReadXmlSchema(XmlReader reader);
    protected virtual void ReadXmlSerializable(XmlReader reader);
    public virtual void RejectChanges();
    public virtual void Reset();
    protected virtual bool ShouldSerializeRelations();
    protected virtual bool ShouldSerializeTables();
    private sealed virtual override IList System.ComponentModel.IListSource.GetList();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public void WriteXml(Stream stream);
    public void WriteXml(Stream stream, XmlWriteMode mode);
    public void WriteXml(TextWriter writer);
    public void WriteXml(TextWriter writer, XmlWriteMode mode);
    public void WriteXml(string fileName);
    public void WriteXml(string fileName, XmlWriteMode mode);
    public void WriteXml(XmlWriter writer);
    public void WriteXml(XmlWriter writer, XmlWriteMode mode);
    public void WriteXmlSchema(Stream stream);
    public void WriteXmlSchema(Stream stream, Converter`2<Type, string> multipleTargetConverter);
    public void WriteXmlSchema(TextWriter writer);
    public void WriteXmlSchema(TextWriter writer, Converter`2<Type, string> multipleTargetConverter);
    public void WriteXmlSchema(string fileName);
    public void WriteXmlSchema(string fileName, Converter`2<Type, string> multipleTargetConverter);
    public void WriteXmlSchema(XmlWriter writer);
    public void WriteXmlSchema(XmlWriter writer, Converter`2<Type, string> multipleTargetConverter);
}
public enum System.Data.DataSetDateTime : Enum {
    public int value__;
    public static DataSetDateTime Local;
    public static DataSetDateTime Unspecified;
    public static DataSetDateTime UnspecifiedLocal;
    public static DataSetDateTime Utc;
}
[AttributeUsageAttribute("32767")]
[ObsoleteAttribute("DataSysDescriptionAttribute has been deprecated.  https://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Data.DataSysDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    [ObsoleteAttribute("DataSysDescriptionAttribute has been deprecated.  https://go.microsoft.com/fwlink/?linkid=14202", "False")]
public DataSysDescriptionAttribute(string description);
    public virtual string get_Description();
}
[DefaultEventAttribute("RowChanging")]
[DefaultPropertyAttribute("TableName")]
[DesignTimeVisibleAttribute("False")]
[ToolboxItemAttribute("False")]
[XmlSchemaProviderAttribute("GetDataTableSchema")]
public class System.Data.DataTable : MarshalByValueComponent {
    protected internal bool fInitInProgress;
    public bool CaseSensitive { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataRelationCollection ChildRelations { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public DataColumnCollection Columns { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public ConstraintCollection Constraints { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataSet DataSet { get; }
    [BrowsableAttribute("False")]
public DataView DefaultView { get; }
    [DefaultValueAttribute("")]
public string DisplayExpression { get; public set; }
    [BrowsableAttribute("False")]
public PropertyCollection ExtendedProperties { get; }
    [BrowsableAttribute("False")]
public bool HasErrors { get; }
    [BrowsableAttribute("False")]
public bool IsInitialized { get; }
    public CultureInfo Locale { get; public set; }
    [DefaultValueAttribute("50")]
public int MinimumCapacity { get; public set; }
    public string Namespace { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DataRelationCollection ParentRelations { get; }
    [DefaultValueAttribute("")]
public string Prefix { get; public set; }
    public DataColumn[] PrimaryKey { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SerializationFormat RemotingFormat { get; public set; }
    [BrowsableAttribute("False")]
public DataRowCollection Rows { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ISite Site { get; public set; }
    private bool System.ComponentModel.IListSource.ContainsListCollection { get; }
    [DefaultValueAttribute("")]
[RefreshPropertiesAttribute("1")]
public string TableName { get; public set; }
    protected DataTable(SerializationInfo info, StreamingContext context);
    public DataTable(string tableName);
    public DataTable(string tableName, string tableNamespace);
    public bool get_CaseSensitive();
    public void set_CaseSensitive(bool value);
    public DataRelationCollection get_ChildRelations();
    public DataColumnCollection get_Columns();
    public ConstraintCollection get_Constraints();
    public DataSet get_DataSet();
    public DataView get_DefaultView();
    public string get_DisplayExpression();
    public void set_DisplayExpression(string value);
    public PropertyCollection get_ExtendedProperties();
    public bool get_HasErrors();
    public sealed virtual bool get_IsInitialized();
    public CultureInfo get_Locale();
    public void set_Locale(CultureInfo value);
    public int get_MinimumCapacity();
    public void set_MinimumCapacity(int value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public DataRelationCollection get_ParentRelations();
    public string get_Prefix();
    public void set_Prefix(string value);
    public DataColumn[] get_PrimaryKey();
    public void set_PrimaryKey(DataColumn[] value);
    public SerializationFormat get_RemotingFormat();
    public void set_RemotingFormat(SerializationFormat value);
    public DataRowCollection get_Rows();
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    private sealed virtual override bool System.ComponentModel.IListSource.get_ContainsListCollection();
    public string get_TableName();
    public void set_TableName(string value);
    public void add_ColumnChanged(DataColumnChangeEventHandler value);
    public void remove_ColumnChanged(DataColumnChangeEventHandler value);
    public void add_ColumnChanging(DataColumnChangeEventHandler value);
    public void remove_ColumnChanging(DataColumnChangeEventHandler value);
    public sealed virtual void add_Initialized(EventHandler value);
    public sealed virtual void remove_Initialized(EventHandler value);
    public void add_RowChanged(DataRowChangeEventHandler value);
    public void remove_RowChanged(DataRowChangeEventHandler value);
    public void add_RowChanging(DataRowChangeEventHandler value);
    public void remove_RowChanging(DataRowChangeEventHandler value);
    public void add_RowDeleted(DataRowChangeEventHandler value);
    public void remove_RowDeleted(DataRowChangeEventHandler value);
    public void add_RowDeleting(DataRowChangeEventHandler value);
    public void remove_RowDeleting(DataRowChangeEventHandler value);
    public void add_TableCleared(DataTableClearEventHandler value);
    public void remove_TableCleared(DataTableClearEventHandler value);
    public void add_TableClearing(DataTableClearEventHandler value);
    public void remove_TableClearing(DataTableClearEventHandler value);
    public void add_TableNewRow(DataTableNewRowEventHandler value);
    public void remove_TableNewRow(DataTableNewRowEventHandler value);
    public void AcceptChanges();
    public virtual void BeginInit();
    public void BeginLoadData();
    public void Clear();
    public virtual DataTable Clone();
    public object Compute(string expression, string filter);
    public DataTable Copy();
    public DataTableReader CreateDataReader();
    protected virtual DataTable CreateInstance();
    public virtual void EndInit();
    public void EndLoadData();
    public DataTable GetChanges();
    public DataTable GetChanges(DataRowState rowStates);
    public static XmlSchemaComplexType GetDataTableSchema(XmlSchemaSet schemaSet);
    public DataRow[] GetErrors();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual Type GetRowType();
    protected virtual XmlSchema GetSchema();
    public void ImportRow(DataRow row);
    public void Load(IDataReader reader);
    public void Load(IDataReader reader, LoadOption loadOption);
    public virtual void Load(IDataReader reader, LoadOption loadOption, FillErrorEventHandler errorHandler);
    public DataRow LoadDataRow(Object[] values, bool fAcceptChanges);
    public DataRow LoadDataRow(Object[] values, LoadOption loadOption);
    public void Merge(DataTable table);
    public void Merge(DataTable table, bool preserveChanges);
    public void Merge(DataTable table, bool preserveChanges, MissingSchemaAction missingSchemaAction);
    public DataRow NewRow();
    protected internal DataRow[] NewRowArray(int size);
    protected virtual DataRow NewRowFromBuilder(DataRowBuilder builder);
    protected internal virtual void OnColumnChanged(DataColumnChangeEventArgs e);
    protected internal virtual void OnColumnChanging(DataColumnChangeEventArgs e);
    protected virtual void OnPropertyChanging(PropertyChangedEventArgs pcevent);
    protected virtual void OnRemoveColumn(DataColumn column);
    protected virtual void OnRowChanged(DataRowChangeEventArgs e);
    protected virtual void OnRowChanging(DataRowChangeEventArgs e);
    protected virtual void OnRowDeleted(DataRowChangeEventArgs e);
    protected virtual void OnRowDeleting(DataRowChangeEventArgs e);
    protected virtual void OnTableCleared(DataTableClearEventArgs e);
    protected virtual void OnTableClearing(DataTableClearEventArgs e);
    protected virtual void OnTableNewRow(DataTableNewRowEventArgs e);
    public XmlReadMode ReadXml(Stream stream);
    public XmlReadMode ReadXml(TextReader reader);
    public XmlReadMode ReadXml(string fileName);
    public XmlReadMode ReadXml(XmlReader reader);
    public void ReadXmlSchema(Stream stream);
    public void ReadXmlSchema(TextReader reader);
    public void ReadXmlSchema(string fileName);
    public void ReadXmlSchema(XmlReader reader);
    protected virtual void ReadXmlSerializable(XmlReader reader);
    public void RejectChanges();
    public virtual void Reset();
    public DataRow[] Select();
    public DataRow[] Select(string filterExpression);
    public DataRow[] Select(string filterExpression, string sort);
    public DataRow[] Select(string filterExpression, string sort, DataViewRowState recordStates);
    private sealed virtual override IList System.ComponentModel.IListSource.GetList();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual string ToString();
    public void WriteXml(Stream stream);
    public void WriteXml(Stream stream, bool writeHierarchy);
    public void WriteXml(Stream stream, XmlWriteMode mode);
    public void WriteXml(Stream stream, XmlWriteMode mode, bool writeHierarchy);
    public void WriteXml(TextWriter writer);
    public void WriteXml(TextWriter writer, bool writeHierarchy);
    public void WriteXml(TextWriter writer, XmlWriteMode mode);
    public void WriteXml(TextWriter writer, XmlWriteMode mode, bool writeHierarchy);
    public void WriteXml(string fileName);
    public void WriteXml(string fileName, bool writeHierarchy);
    public void WriteXml(string fileName, XmlWriteMode mode);
    public void WriteXml(string fileName, XmlWriteMode mode, bool writeHierarchy);
    public void WriteXml(XmlWriter writer);
    public void WriteXml(XmlWriter writer, bool writeHierarchy);
    public void WriteXml(XmlWriter writer, XmlWriteMode mode);
    public void WriteXml(XmlWriter writer, XmlWriteMode mode, bool writeHierarchy);
    public void WriteXmlSchema(Stream stream);
    public void WriteXmlSchema(Stream stream, bool writeHierarchy);
    public void WriteXmlSchema(TextWriter writer);
    public void WriteXmlSchema(TextWriter writer, bool writeHierarchy);
    public void WriteXmlSchema(string fileName);
    public void WriteXmlSchema(string fileName, bool writeHierarchy);
    public void WriteXmlSchema(XmlWriter writer);
    public void WriteXmlSchema(XmlWriter writer, bool writeHierarchy);
}
public class System.Data.DataTableClearEventArgs : EventArgs {
    public DataTable Table { get; }
    public string TableName { get; }
    public string TableNamespace { get; }
    public DataTableClearEventArgs(DataTable dataTable);
    public DataTable get_Table();
    public string get_TableName();
    public string get_TableNamespace();
}
public class System.Data.DataTableClearEventHandler : MulticastDelegate {
    public DataTableClearEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataTableClearEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataTableClearEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
[DefaultEventAttribute("CollectionChanged")]
[ListBindableAttribute("False")]
public class System.Data.DataTableCollection : InternalDataCollectionBase {
    public DataTable Item { get; }
    public DataTable Item { get; }
    public DataTable Item { get; }
    protected ArrayList List { get; }
    public DataTable get_Item(int index);
    public DataTable get_Item(string name);
    public DataTable get_Item(string name, string tableNamespace);
    protected virtual ArrayList get_List();
    public void add_CollectionChanged(CollectionChangeEventHandler value);
    public void remove_CollectionChanged(CollectionChangeEventHandler value);
    public void add_CollectionChanging(CollectionChangeEventHandler value);
    public void remove_CollectionChanging(CollectionChangeEventHandler value);
    public DataTable Add();
    public void Add(DataTable table);
    public DataTable Add(string name);
    public DataTable Add(string name, string tableNamespace);
    public void AddRange(DataTable[] tables);
    public bool CanRemove(DataTable table);
    public void Clear();
    public bool Contains(string name);
    public bool Contains(string name, string tableNamespace);
    public void CopyTo(DataTable[] array, int index);
    public int IndexOf(DataTable table);
    public int IndexOf(string tableName);
    public int IndexOf(string tableName, string tableNamespace);
    public void Remove(DataTable table);
    public void Remove(string name);
    public void Remove(string name, string tableNamespace);
    public void RemoveAt(int index);
}
[ExtensionAttribute]
public static class System.Data.DataTableExtensions : object {
    [ExtensionAttribute]
public static DataView AsDataView(DataTable table);
    [ExtensionAttribute]
public static DataView AsDataView(EnumerableRowCollection`1<T> source);
    [ExtensionAttribute]
public static EnumerableRowCollection`1<DataRow> AsEnumerable(DataTable source);
    [ExtensionAttribute]
public static DataTable CopyToDataTable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static void CopyToDataTable(IEnumerable`1<T> source, DataTable table, LoadOption options);
    [ExtensionAttribute]
public static void CopyToDataTable(IEnumerable`1<T> source, DataTable table, LoadOption options, FillErrorEventHandler errorHandler);
}
public class System.Data.DataTableNewRowEventArgs : EventArgs {
    public DataRow Row { get; }
    public DataTableNewRowEventArgs(DataRow dataRow);
    public DataRow get_Row();
}
public class System.Data.DataTableNewRowEventHandler : MulticastDelegate {
    public DataTableNewRowEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataTableNewRowEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataTableNewRowEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.Data.DataTableReader : DbDataReader {
    public int Depth { get; }
    public int FieldCount { get; }
    public bool HasRows { get; }
    public bool IsClosed { get; }
    public object Item { get; }
    public object Item { get; }
    public int RecordsAffected { get; }
    public DataTableReader(DataTable dataTable);
    public DataTableReader(DataTable[] dataTables);
    public virtual int get_Depth();
    public virtual int get_FieldCount();
    public virtual bool get_HasRows();
    public virtual bool get_IsClosed();
    public virtual object get_Item(int ordinal);
    public virtual object get_Item(string name);
    public virtual int get_RecordsAffected();
    public virtual void Close();
    public virtual bool GetBoolean(int ordinal);
    public virtual byte GetByte(int ordinal);
    public virtual long GetBytes(int ordinal, long dataIndex, Byte[] buffer, int bufferIndex, int length);
    public virtual char GetChar(int ordinal);
    public virtual long GetChars(int ordinal, long dataIndex, Char[] buffer, int bufferIndex, int length);
    public virtual string GetDataTypeName(int ordinal);
    public virtual DateTime GetDateTime(int ordinal);
    public virtual decimal GetDecimal(int ordinal);
    public virtual double GetDouble(int ordinal);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int ordinal);
    public virtual float GetFloat(int ordinal);
    public virtual Guid GetGuid(int ordinal);
    public virtual short GetInt16(int ordinal);
    public virtual int GetInt32(int ordinal);
    public virtual long GetInt64(int ordinal);
    public virtual string GetName(int ordinal);
    public virtual int GetOrdinal(string name);
    public virtual Type GetProviderSpecificFieldType(int ordinal);
    public virtual object GetProviderSpecificValue(int ordinal);
    public virtual int GetProviderSpecificValues(Object[] values);
    public virtual DataTable GetSchemaTable();
    public virtual string GetString(int ordinal);
    public virtual object GetValue(int ordinal);
    public virtual int GetValues(Object[] values);
    public virtual bool IsDBNull(int ordinal);
    public virtual bool NextResult();
    public virtual bool Read();
}
[DefaultMemberAttribute("Item")]
[DefaultEventAttribute("PositionChanged")]
[DefaultPropertyAttribute("Table")]
public class System.Data.DataView : MarshalByValueComponent {
    [DefaultValueAttribute("True")]
public bool AllowDelete { get; public set; }
    [DefaultValueAttribute("True")]
public bool AllowEdit { get; public set; }
    [DefaultValueAttribute("True")]
public bool AllowNew { get; public set; }
    [DefaultValueAttribute("False")]
[RefreshPropertiesAttribute("1")]
public bool ApplyDefaultSort { get; public set; }
    [BrowsableAttribute("False")]
public int Count { get; }
    [BrowsableAttribute("False")]
public DataViewManager DataViewManager { get; }
    [BrowsableAttribute("False")]
public bool IsInitialized { get; }
    [BrowsableAttribute("False")]
protected bool IsOpen { get; }
    public DataRowView Item { get; }
    [DefaultValueAttribute("")]
public string RowFilter { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public DataViewRowState RowStateFilter { get; public set; }
    [DefaultValueAttribute("")]
public string Sort { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    private string System.ComponentModel.IBindingListView.Filter { get; private set; }
    private ListSortDescriptionCollection System.ComponentModel.IBindingListView.SortDescriptions { get; }
    private bool System.ComponentModel.IBindingListView.SupportsAdvancedSorting { get; }
    private bool System.ComponentModel.IBindingListView.SupportsFiltering { get; }
    [DefaultValueAttribute("")]
[RefreshPropertiesAttribute("1")]
public DataTable Table { get; public set; }
    public DataView(DataTable table);
    public DataView(DataTable table, string RowFilter, string Sort, DataViewRowState RowState);
    public bool get_AllowDelete();
    public void set_AllowDelete(bool value);
    public bool get_AllowEdit();
    public void set_AllowEdit(bool value);
    public bool get_AllowNew();
    public void set_AllowNew(bool value);
    public bool get_ApplyDefaultSort();
    public void set_ApplyDefaultSort(bool value);
    public sealed virtual int get_Count();
    public DataViewManager get_DataViewManager();
    public sealed virtual bool get_IsInitialized();
    protected bool get_IsOpen();
    public DataRowView get_Item(int recordIndex);
    public virtual string get_RowFilter();
    public virtual void set_RowFilter(string value);
    public DataViewRowState get_RowStateFilter();
    public void set_RowStateFilter(DataViewRowState value);
    public string get_Sort();
    public void set_Sort(string value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int recordIndex);
    private sealed virtual override void System.Collections.IList.set_Item(int recordIndex, object value);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    private sealed virtual override string System.ComponentModel.IBindingListView.get_Filter();
    private sealed virtual override void System.ComponentModel.IBindingListView.set_Filter(string value);
    private sealed virtual override ListSortDescriptionCollection System.ComponentModel.IBindingListView.get_SortDescriptions();
    private sealed virtual override bool System.ComponentModel.IBindingListView.get_SupportsAdvancedSorting();
    private sealed virtual override bool System.ComponentModel.IBindingListView.get_SupportsFiltering();
    public DataTable get_Table();
    public void set_Table(DataTable value);
    public sealed virtual void add_Initialized(EventHandler value);
    public sealed virtual void remove_Initialized(EventHandler value);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public virtual DataRowView AddNew();
    public sealed virtual void BeginInit();
    protected void Close();
    protected virtual void ColumnCollectionChanged(object sender, CollectionChangeEventArgs e);
    public sealed virtual void CopyTo(Array array, int index);
    public void Delete(int index);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    public virtual bool Equals(DataView view);
    public int Find(object key);
    public int Find(Object[] key);
    public DataRowView[] FindRows(object key);
    public DataRowView[] FindRows(Object[] key);
    public sealed virtual IEnumerator GetEnumerator();
    protected virtual void IndexListChanged(object sender, ListChangedEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    protected void Open();
    protected void Reset();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override void System.ComponentModel.IBindingListView.ApplySort(ListSortDescriptionCollection sorts);
    private sealed virtual override void System.ComponentModel.IBindingListView.RemoveFilter();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    public DataTable ToTable();
    public DataTable ToTable(bool distinct, String[] columnNames);
    public DataTable ToTable(string tableName);
    public DataTable ToTable(string tableName, bool distinct, String[] columnNames);
    protected void UpdateIndex();
    protected virtual void UpdateIndex(bool force);
}
public class System.Data.DataViewManager : MarshalByValueComponent {
    [DefaultValueAttribute("")]
public DataSet DataSet { get; public set; }
    public string DataViewSettingCollectionString { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public DataViewSettingCollection DataViewSettings { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    public DataViewManager(DataSet dataSet);
    public DataSet get_DataSet();
    public void set_DataSet(DataSet value);
    public string get_DataViewSettingCollectionString();
    public void set_DataViewSettingCollectionString(string value);
    public DataViewSettingCollection get_DataViewSettings();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public DataView CreateDataView(DataTable table);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    protected virtual void RelationCollectionChanged(object sender, CollectionChangeEventArgs e);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    protected virtual void TableCollectionChanged(object sender, CollectionChangeEventArgs e);
}
[FlagsAttribute]
public enum System.Data.DataViewRowState : Enum {
    public int value__;
    public static DataViewRowState Added;
    public static DataViewRowState CurrentRows;
    public static DataViewRowState Deleted;
    public static DataViewRowState ModifiedCurrent;
    public static DataViewRowState ModifiedOriginal;
    public static DataViewRowState None;
    public static DataViewRowState OriginalRows;
    public static DataViewRowState Unchanged;
}
public class System.Data.DataViewSetting : object {
    public bool ApplyDefaultSort { get; public set; }
    [BrowsableAttribute("False")]
public DataViewManager DataViewManager { get; }
    public string RowFilter { get; public set; }
    public DataViewRowState RowStateFilter { get; public set; }
    public string Sort { get; public set; }
    [BrowsableAttribute("False")]
public DataTable Table { get; }
    public bool get_ApplyDefaultSort();
    public void set_ApplyDefaultSort(bool value);
    public DataViewManager get_DataViewManager();
    public string get_RowFilter();
    public void set_RowFilter(string value);
    public DataViewRowState get_RowStateFilter();
    public void set_RowStateFilter(DataViewRowState value);
    public string get_Sort();
    public void set_Sort(string value);
    public DataTable get_Table();
}
[DefaultMemberAttribute("Item")]
public class System.Data.DataViewSettingCollection : object {
    [BrowsableAttribute("False")]
public int Count { get; }
    [BrowsableAttribute("False")]
public bool IsReadOnly { get; }
    [BrowsableAttribute("False")]
public bool IsSynchronized { get; }
    public DataViewSetting Item { get; public set; }
    public DataViewSetting Item { get; public set; }
    public DataViewSetting Item { get; }
    [BrowsableAttribute("False")]
public object SyncRoot { get; }
    public virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public virtual DataViewSetting get_Item(DataTable table);
    public virtual void set_Item(DataTable table, DataViewSetting value);
    public virtual DataViewSetting get_Item(int index);
    public virtual void set_Item(int index, DataViewSetting value);
    public virtual DataViewSetting get_Item(string tableName);
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array ar, int index);
    public void CopyTo(DataViewSetting[] ar, int index);
    public sealed virtual IEnumerator GetEnumerator();
}
public class System.Data.DBConcurrencyException : SystemException {
    public DataRow Row { get; public set; }
    public int RowCount { get; }
    public DBConcurrencyException(string message);
    public DBConcurrencyException(string message, Exception inner);
    public DBConcurrencyException(string message, Exception inner, DataRow[] dataRows);
    public DataRow get_Row();
    public void set_Row(DataRow value);
    public int get_RowCount();
    public void CopyToRows(DataRow[] array);
    public void CopyToRows(DataRow[] array, int arrayIndex);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.Data.DbType : Enum {
    public int value__;
    public static DbType AnsiString;
    public static DbType AnsiStringFixedLength;
    public static DbType Binary;
    public static DbType Boolean;
    public static DbType Byte;
    public static DbType Currency;
    public static DbType Date;
    public static DbType DateTime;
    public static DbType DateTime2;
    public static DbType DateTimeOffset;
    public static DbType Decimal;
    public static DbType Double;
    public static DbType Guid;
    public static DbType Int16;
    public static DbType Int32;
    public static DbType Int64;
    public static DbType Object;
    public static DbType SByte;
    public static DbType Single;
    public static DbType String;
    public static DbType StringFixedLength;
    public static DbType Time;
    public static DbType UInt16;
    public static DbType UInt32;
    public static DbType UInt64;
    public static DbType VarNumeric;
    public static DbType Xml;
}
public class System.Data.DeletedRowInaccessibleException : DataException {
    protected DeletedRowInaccessibleException(SerializationInfo info, StreamingContext context);
    public DeletedRowInaccessibleException(string s);
    public DeletedRowInaccessibleException(string message, Exception innerException);
}
public class System.Data.DuplicateNameException : DataException {
    protected DuplicateNameException(SerializationInfo info, StreamingContext context);
    public DuplicateNameException(string s);
    public DuplicateNameException(string message, Exception innerException);
}
public abstract class System.Data.EnumerableRowCollection : object {
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Data.EnumerableRowCollection`1 : EnumerableRowCollection {
    public sealed virtual IEnumerator`1<TRow> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class System.Data.EnumerableRowCollectionExtensions : object {
    [ExtensionAttribute]
public static EnumerableRowCollection`1<TResult> Cast(EnumerableRowCollection source);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> OrderByDescending(EnumerableRowCollection`1<TRow> source, Func`2<TRow, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> OrderByDescending(EnumerableRowCollection`1<TRow> source, Func`2<TRow, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> OrderBy(EnumerableRowCollection`1<TRow> source, Func`2<TRow, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> OrderBy(EnumerableRowCollection`1<TRow> source, Func`2<TRow, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static EnumerableRowCollection`1<S> Select(EnumerableRowCollection`1<TRow> source, Func`2<TRow, S> selector);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> ThenByDescending(OrderedEnumerableRowCollection`1<TRow> source, Func`2<TRow, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> ThenByDescending(OrderedEnumerableRowCollection`1<TRow> source, Func`2<TRow, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> ThenBy(OrderedEnumerableRowCollection`1<TRow> source, Func`2<TRow, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> ThenBy(OrderedEnumerableRowCollection`1<TRow> source, Func`2<TRow, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static EnumerableRowCollection`1<TRow> Where(EnumerableRowCollection`1<TRow> source, Func`2<TRow, bool> predicate);
}
public class System.Data.EvaluateException : InvalidExpressionException {
    protected EvaluateException(SerializationInfo info, StreamingContext context);
    public EvaluateException(string s);
    public EvaluateException(string message, Exception innerException);
}
public class System.Data.FillErrorEventArgs : EventArgs {
    public bool Continue { get; public set; }
    public DataTable DataTable { get; }
    public Exception Errors { get; public set; }
    public Object[] Values { get; }
    public FillErrorEventArgs(DataTable dataTable, Object[] values);
    public bool get_Continue();
    public void set_Continue(bool value);
    public DataTable get_DataTable();
    public Exception get_Errors();
    public void set_Errors(Exception value);
    public Object[] get_Values();
}
public class System.Data.FillErrorEventHandler : MulticastDelegate {
    public FillErrorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FillErrorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FillErrorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultPropertyAttribute("ConstraintName")]
public class System.Data.ForeignKeyConstraint : Constraint {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public AcceptRejectRule AcceptRejectRule { get; public set; }
    [ReadOnlyAttribute("True")]
public DataColumn[] Columns { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public Rule DeleteRule { get; public set; }
    [ReadOnlyAttribute("True")]
public DataColumn[] RelatedColumns { get; }
    [ReadOnlyAttribute("True")]
public DataTable RelatedTable { get; }
    [ReadOnlyAttribute("True")]
public DataTable Table { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public Rule UpdateRule { get; public set; }
    public ForeignKeyConstraint(DataColumn parentColumn, DataColumn childColumn);
    public ForeignKeyConstraint(DataColumn[] parentColumns, DataColumn[] childColumns);
    public ForeignKeyConstraint(string constraintName, DataColumn parentColumn, DataColumn childColumn);
    public ForeignKeyConstraint(string constraintName, DataColumn[] parentColumns, DataColumn[] childColumns);
    [BrowsableAttribute("False")]
public ForeignKeyConstraint(string constraintName, string parentTableName, string parentTableNamespace, String[] parentColumnNames, String[] childColumnNames, AcceptRejectRule acceptRejectRule, Rule deleteRule, Rule updateRule);
    [BrowsableAttribute("False")]
public ForeignKeyConstraint(string constraintName, string parentTableName, String[] parentColumnNames, String[] childColumnNames, AcceptRejectRule acceptRejectRule, Rule deleteRule, Rule updateRule);
    public virtual AcceptRejectRule get_AcceptRejectRule();
    public virtual void set_AcceptRejectRule(AcceptRejectRule value);
    public virtual DataColumn[] get_Columns();
    public virtual Rule get_DeleteRule();
    public virtual void set_DeleteRule(Rule value);
    public virtual DataColumn[] get_RelatedColumns();
    public virtual DataTable get_RelatedTable();
    public virtual DataTable get_Table();
    public virtual Rule get_UpdateRule();
    public virtual void set_UpdateRule(Rule value);
    public virtual bool Equals(object key);
    public virtual int GetHashCode();
}
public interface System.Data.IColumnMapping {
    public string DataSetColumn { get; public set; }
    public string SourceColumn { get; public set; }
    public abstract virtual string get_DataSetColumn();
    public abstract virtual void set_DataSetColumn(string value);
    public abstract virtual string get_SourceColumn();
    public abstract virtual void set_SourceColumn(string value);
}
[DefaultMemberAttribute("Item")]
public interface System.Data.IColumnMappingCollection {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string index);
    public abstract virtual void set_Item(string index, object value);
    public abstract virtual IColumnMapping Add(string sourceColumnName, string dataSetColumnName);
    public abstract virtual bool Contains(string sourceColumnName);
    public abstract virtual IColumnMapping GetByDataSetColumn(string dataSetColumnName);
    public abstract virtual int IndexOf(string sourceColumnName);
    public abstract virtual void RemoveAt(string sourceColumnName);
}
public interface System.Data.IDataAdapter {
    public MissingMappingAction MissingMappingAction { get; public set; }
    public MissingSchemaAction MissingSchemaAction { get; public set; }
    public ITableMappingCollection TableMappings { get; }
    public abstract virtual MissingMappingAction get_MissingMappingAction();
    public abstract virtual void set_MissingMappingAction(MissingMappingAction value);
    public abstract virtual MissingSchemaAction get_MissingSchemaAction();
    public abstract virtual void set_MissingSchemaAction(MissingSchemaAction value);
    public abstract virtual ITableMappingCollection get_TableMappings();
    public abstract virtual int Fill(DataSet dataSet);
    public abstract virtual DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType);
    public abstract virtual IDataParameter[] GetFillParameters();
    public abstract virtual int Update(DataSet dataSet);
}
public interface System.Data.IDataParameter {
    public DbType DbType { get; public set; }
    public ParameterDirection Direction { get; public set; }
    public bool IsNullable { get; }
    public string ParameterName { get; public set; }
    public string SourceColumn { get; public set; }
    public DataRowVersion SourceVersion { get; public set; }
    public object Value { get; public set; }
    public abstract virtual DbType get_DbType();
    public abstract virtual void set_DbType(DbType value);
    public abstract virtual ParameterDirection get_Direction();
    public abstract virtual void set_Direction(ParameterDirection value);
    public abstract virtual bool get_IsNullable();
    public abstract virtual string get_ParameterName();
    public abstract virtual void set_ParameterName(string value);
    public abstract virtual string get_SourceColumn();
    public abstract virtual void set_SourceColumn(string value);
    public abstract virtual DataRowVersion get_SourceVersion();
    public abstract virtual void set_SourceVersion(DataRowVersion value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[DefaultMemberAttribute("Item")]
public interface System.Data.IDataParameterCollection {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string parameterName);
    public abstract virtual void set_Item(string parameterName, object value);
    public abstract virtual bool Contains(string parameterName);
    public abstract virtual int IndexOf(string parameterName);
    public abstract virtual void RemoveAt(string parameterName);
}
public interface System.Data.IDataReader {
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public abstract virtual int get_Depth();
    public abstract virtual bool get_IsClosed();
    public abstract virtual int get_RecordsAffected();
    public abstract virtual void Close();
    public abstract virtual DataTable GetSchemaTable();
    public abstract virtual bool NextResult();
    public abstract virtual bool Read();
}
[DefaultMemberAttribute("Item")]
public interface System.Data.IDataRecord {
    public int FieldCount { get; }
    public object Item { get; }
    public object Item { get; }
    public abstract virtual int get_FieldCount();
    public abstract virtual object get_Item(int i);
    public abstract virtual object get_Item(string name);
    public abstract virtual bool GetBoolean(int i);
    public abstract virtual byte GetByte(int i);
    public abstract virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public abstract virtual char GetChar(int i);
    public abstract virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public abstract virtual IDataReader GetData(int i);
    public abstract virtual string GetDataTypeName(int i);
    public abstract virtual DateTime GetDateTime(int i);
    public abstract virtual decimal GetDecimal(int i);
    public abstract virtual double GetDouble(int i);
    public abstract virtual Type GetFieldType(int i);
    public abstract virtual float GetFloat(int i);
    public abstract virtual Guid GetGuid(int i);
    public abstract virtual short GetInt16(int i);
    public abstract virtual int GetInt32(int i);
    public abstract virtual long GetInt64(int i);
    public abstract virtual string GetName(int i);
    public abstract virtual int GetOrdinal(string name);
    public abstract virtual string GetString(int i);
    public abstract virtual object GetValue(int i);
    public abstract virtual int GetValues(Object[] values);
    public abstract virtual bool IsDBNull(int i);
}
public interface System.Data.IDbCommand {
    public string CommandText { get; public set; }
    public int CommandTimeout { get; public set; }
    public CommandType CommandType { get; public set; }
    public IDbConnection Connection { get; public set; }
    public IDataParameterCollection Parameters { get; }
    public IDbTransaction Transaction { get; public set; }
    public UpdateRowSource UpdatedRowSource { get; public set; }
    public abstract virtual string get_CommandText();
    public abstract virtual void set_CommandText(string value);
    public abstract virtual int get_CommandTimeout();
    public abstract virtual void set_CommandTimeout(int value);
    public abstract virtual CommandType get_CommandType();
    public abstract virtual void set_CommandType(CommandType value);
    public abstract virtual IDbConnection get_Connection();
    public abstract virtual void set_Connection(IDbConnection value);
    public abstract virtual IDataParameterCollection get_Parameters();
    public abstract virtual IDbTransaction get_Transaction();
    public abstract virtual void set_Transaction(IDbTransaction value);
    public abstract virtual UpdateRowSource get_UpdatedRowSource();
    public abstract virtual void set_UpdatedRowSource(UpdateRowSource value);
    public abstract virtual void Cancel();
    public abstract virtual IDbDataParameter CreateParameter();
    public abstract virtual int ExecuteNonQuery();
    public abstract virtual IDataReader ExecuteReader();
    public abstract virtual IDataReader ExecuteReader(CommandBehavior behavior);
    public abstract virtual object ExecuteScalar();
    public abstract virtual void Prepare();
}
public interface System.Data.IDbConnection {
    public string ConnectionString { get; public set; }
    public int ConnectionTimeout { get; }
    public string Database { get; }
    public ConnectionState State { get; }
    public abstract virtual string get_ConnectionString();
    public abstract virtual void set_ConnectionString(string value);
    public abstract virtual int get_ConnectionTimeout();
    public abstract virtual string get_Database();
    public abstract virtual ConnectionState get_State();
    public abstract virtual IDbTransaction BeginTransaction();
    public abstract virtual IDbTransaction BeginTransaction(IsolationLevel il);
    public abstract virtual void ChangeDatabase(string databaseName);
    public abstract virtual void Close();
    public abstract virtual IDbCommand CreateCommand();
    public abstract virtual void Open();
}
public interface System.Data.IDbDataAdapter {
    public IDbCommand DeleteCommand { get; public set; }
    public IDbCommand InsertCommand { get; public set; }
    public IDbCommand SelectCommand { get; public set; }
    public IDbCommand UpdateCommand { get; public set; }
    public abstract virtual IDbCommand get_DeleteCommand();
    public abstract virtual void set_DeleteCommand(IDbCommand value);
    public abstract virtual IDbCommand get_InsertCommand();
    public abstract virtual void set_InsertCommand(IDbCommand value);
    public abstract virtual IDbCommand get_SelectCommand();
    public abstract virtual void set_SelectCommand(IDbCommand value);
    public abstract virtual IDbCommand get_UpdateCommand();
    public abstract virtual void set_UpdateCommand(IDbCommand value);
}
public interface System.Data.IDbDataParameter {
    public byte Precision { get; public set; }
    public byte Scale { get; public set; }
    public int Size { get; public set; }
    public abstract virtual byte get_Precision();
    public abstract virtual void set_Precision(byte value);
    public abstract virtual byte get_Scale();
    public abstract virtual void set_Scale(byte value);
    public abstract virtual int get_Size();
    public abstract virtual void set_Size(int value);
}
public interface System.Data.IDbTransaction {
    public IDbConnection Connection { get; }
    public IsolationLevel IsolationLevel { get; }
    public abstract virtual IDbConnection get_Connection();
    public abstract virtual IsolationLevel get_IsolationLevel();
    public abstract virtual void Commit();
    public abstract virtual void Rollback();
}
public class System.Data.InRowChangingEventException : DataException {
    protected InRowChangingEventException(SerializationInfo info, StreamingContext context);
    public InRowChangingEventException(string s);
    public InRowChangingEventException(string message, Exception innerException);
}
public class System.Data.InternalDataCollectionBase : object {
    [BrowsableAttribute("False")]
public int Count { get; }
    [BrowsableAttribute("False")]
public bool IsReadOnly { get; }
    [BrowsableAttribute("False")]
public bool IsSynchronized { get; }
    protected ArrayList List { get; }
    [BrowsableAttribute("False")]
public object SyncRoot { get; }
    public virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    protected virtual ArrayList get_List();
    public sealed virtual object get_SyncRoot();
    public virtual void CopyTo(Array ar, int index);
    public virtual IEnumerator GetEnumerator();
}
public class System.Data.InvalidConstraintException : DataException {
    protected InvalidConstraintException(SerializationInfo info, StreamingContext context);
    public InvalidConstraintException(string s);
    public InvalidConstraintException(string message, Exception innerException);
}
public class System.Data.InvalidExpressionException : DataException {
    protected InvalidExpressionException(SerializationInfo info, StreamingContext context);
    public InvalidExpressionException(string s);
    public InvalidExpressionException(string message, Exception innerException);
}
public enum System.Data.IsolationLevel : Enum {
    public int value__;
    public static IsolationLevel Chaos;
    public static IsolationLevel ReadCommitted;
    public static IsolationLevel ReadUncommitted;
    public static IsolationLevel RepeatableRead;
    public static IsolationLevel Serializable;
    public static IsolationLevel Snapshot;
    public static IsolationLevel Unspecified;
}
public interface System.Data.ITableMapping {
    public IColumnMappingCollection ColumnMappings { get; }
    public string DataSetTable { get; public set; }
    public string SourceTable { get; public set; }
    public abstract virtual IColumnMappingCollection get_ColumnMappings();
    public abstract virtual string get_DataSetTable();
    public abstract virtual void set_DataSetTable(string value);
    public abstract virtual string get_SourceTable();
    public abstract virtual void set_SourceTable(string value);
}
[DefaultMemberAttribute("Item")]
public interface System.Data.ITableMappingCollection {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string index);
    public abstract virtual void set_Item(string index, object value);
    public abstract virtual ITableMapping Add(string sourceTableName, string dataSetTableName);
    public abstract virtual bool Contains(string sourceTableName);
    public abstract virtual ITableMapping GetByDataSetTable(string dataSetTableName);
    public abstract virtual int IndexOf(string sourceTableName);
    public abstract virtual void RemoveAt(string sourceTableName);
}
public enum System.Data.KeyRestrictionBehavior : Enum {
    public int value__;
    public static KeyRestrictionBehavior AllowOnly;
    public static KeyRestrictionBehavior PreventUsage;
}
public enum System.Data.LoadOption : Enum {
    public int value__;
    public static LoadOption OverwriteChanges;
    public static LoadOption PreserveChanges;
    public static LoadOption Upsert;
}
public enum System.Data.MappingType : Enum {
    public int value__;
    public static MappingType Attribute;
    public static MappingType Element;
    public static MappingType Hidden;
    public static MappingType SimpleContent;
}
public class System.Data.MergeFailedEventArgs : EventArgs {
    public string Conflict { get; }
    public DataTable Table { get; }
    public MergeFailedEventArgs(DataTable table, string conflict);
    public string get_Conflict();
    public DataTable get_Table();
}
public class System.Data.MergeFailedEventHandler : MulticastDelegate {
    public MergeFailedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MergeFailedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MergeFailedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Data.MissingMappingAction : Enum {
    public int value__;
    public static MissingMappingAction Error;
    public static MissingMappingAction Ignore;
    public static MissingMappingAction Passthrough;
}
public class System.Data.MissingPrimaryKeyException : DataException {
    protected MissingPrimaryKeyException(SerializationInfo info, StreamingContext context);
    public MissingPrimaryKeyException(string s);
    public MissingPrimaryKeyException(string message, Exception innerException);
}
public enum System.Data.MissingSchemaAction : Enum {
    public int value__;
    public static MissingSchemaAction Add;
    public static MissingSchemaAction AddWithKey;
    public static MissingSchemaAction Error;
    public static MissingSchemaAction Ignore;
}
public class System.Data.NoNullAllowedException : DataException {
    protected NoNullAllowedException(SerializationInfo info, StreamingContext context);
    public NoNullAllowedException(string s);
    public NoNullAllowedException(string message, Exception innerException);
}
public class System.Data.OrderedEnumerableRowCollection`1 : EnumerableRowCollection`1<TRow> {
}
public enum System.Data.ParameterDirection : Enum {
    public int value__;
    public static ParameterDirection Input;
    public static ParameterDirection InputOutput;
    public static ParameterDirection Output;
    public static ParameterDirection ReturnValue;
}
public class System.Data.PropertyCollection : Hashtable {
    protected PropertyCollection(SerializationInfo info, StreamingContext context);
    public virtual object Clone();
}
public class System.Data.ReadOnlyException : DataException {
    protected ReadOnlyException(SerializationInfo info, StreamingContext context);
    public ReadOnlyException(string s);
    public ReadOnlyException(string message, Exception innerException);
}
public class System.Data.RowNotInTableException : DataException {
    protected RowNotInTableException(SerializationInfo info, StreamingContext context);
    public RowNotInTableException(string s);
    public RowNotInTableException(string message, Exception innerException);
}
public enum System.Data.Rule : Enum {
    public int value__;
    public static Rule Cascade;
    public static Rule None;
    public static Rule SetDefault;
    public static Rule SetNull;
}
public enum System.Data.SchemaSerializationMode : Enum {
    public int value__;
    public static SchemaSerializationMode ExcludeSchema;
    public static SchemaSerializationMode IncludeSchema;
}
public enum System.Data.SchemaType : Enum {
    public int value__;
    public static SchemaType Mapped;
    public static SchemaType Source;
}
public enum System.Data.SerializationFormat : Enum {
    public int value__;
    public static SerializationFormat Binary;
    public static SerializationFormat Xml;
}
public enum System.Data.SqlDbType : Enum {
    public int value__;
    public static SqlDbType BigInt;
    public static SqlDbType Binary;
    public static SqlDbType Bit;
    public static SqlDbType Char;
    public static SqlDbType Date;
    public static SqlDbType DateTime;
    public static SqlDbType DateTime2;
    public static SqlDbType DateTimeOffset;
    public static SqlDbType Decimal;
    public static SqlDbType Float;
    public static SqlDbType Image;
    public static SqlDbType Int;
    public static SqlDbType Money;
    public static SqlDbType NChar;
    public static SqlDbType NText;
    public static SqlDbType NVarChar;
    public static SqlDbType Real;
    public static SqlDbType SmallDateTime;
    public static SqlDbType SmallInt;
    public static SqlDbType SmallMoney;
    public static SqlDbType Structured;
    public static SqlDbType Text;
    public static SqlDbType Time;
    public static SqlDbType Timestamp;
    public static SqlDbType TinyInt;
    public static SqlDbType Udt;
    public static SqlDbType UniqueIdentifier;
    public static SqlDbType VarBinary;
    public static SqlDbType VarChar;
    public static SqlDbType Variant;
    public static SqlDbType Xml;
}
public interface System.Data.SqlTypes.INullable {
    public bool IsNull { get; }
    public abstract virtual bool get_IsNull();
}
public class System.Data.SqlTypes.SqlAlreadyFilledException : SqlTypeException {
    public SqlAlreadyFilledException(string message);
    public SqlAlreadyFilledException(string message, Exception e);
}
[DefaultMemberAttribute("Item")]
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlBinary : ValueType {
    private object _dummy;
    public static SqlBinary Null;
    public bool IsNull { get; }
    public byte Item { get; }
    public int Length { get; }
    public Byte[] Value { get; }
    public SqlBinary(Byte[] value);
    public sealed virtual bool get_IsNull();
    public byte get_Item(int index);
    public int get_Length();
    public Byte[] get_Value();
    public static SqlBinary Add(SqlBinary x, SqlBinary y);
    public int CompareTo(SqlBinary value);
    public sealed virtual int CompareTo(object value);
    public static SqlBinary Concat(SqlBinary x, SqlBinary y);
    public static SqlBoolean Equals(SqlBinary x, SqlBinary y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlBinary x, SqlBinary y);
    public static SqlBoolean GreaterThanOrEqual(SqlBinary x, SqlBinary y);
    public static SqlBoolean LessThan(SqlBinary x, SqlBinary y);
    public static SqlBoolean LessThanOrEqual(SqlBinary x, SqlBinary y);
    public static SqlBoolean NotEquals(SqlBinary x, SqlBinary y);
    public static SqlBinary op_Addition(SqlBinary x, SqlBinary y);
    public static SqlBoolean op_Equality(SqlBinary x, SqlBinary y);
    public static Byte[] op_Explicit(SqlBinary x);
    public static SqlBinary op_Explicit(SqlGuid x);
    public static SqlBoolean op_GreaterThan(SqlBinary x, SqlBinary y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlBinary x, SqlBinary y);
    public static SqlBinary op_Implicit(Byte[] x);
    public static SqlBoolean op_Inequality(SqlBinary x, SqlBinary y);
    public static SqlBoolean op_LessThan(SqlBinary x, SqlBinary y);
    public static SqlBoolean op_LessThanOrEqual(SqlBinary x, SqlBinary y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlGuid ToSqlGuid();
    public virtual string ToString();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlBoolean : ValueType {
    private int _dummyPrimitive;
    public static SqlBoolean False;
    public static SqlBoolean Null;
    public static SqlBoolean One;
    public static SqlBoolean True;
    public static SqlBoolean Zero;
    public byte ByteValue { get; }
    public bool IsFalse { get; }
    public bool IsNull { get; }
    public bool IsTrue { get; }
    public bool Value { get; }
    public SqlBoolean(bool value);
    public SqlBoolean(int value);
    public byte get_ByteValue();
    public bool get_IsFalse();
    public sealed virtual bool get_IsNull();
    public bool get_IsTrue();
    public bool get_Value();
    public static SqlBoolean And(SqlBoolean x, SqlBoolean y);
    public int CompareTo(SqlBoolean value);
    public sealed virtual int CompareTo(object value);
    public static SqlBoolean Equals(SqlBoolean x, SqlBoolean y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean GreaterThanOrEquals(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean LessThan(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean LessThanOrEquals(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean NotEquals(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean OnesComplement(SqlBoolean x);
    public static SqlBoolean op_BitwiseAnd(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean op_BitwiseOr(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean op_Equality(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean op_ExclusiveOr(SqlBoolean x, SqlBoolean y);
    public static bool op_Explicit(SqlBoolean x);
    public static SqlBoolean op_Explicit(SqlByte x);
    public static SqlBoolean op_Explicit(SqlDecimal x);
    public static SqlBoolean op_Explicit(SqlDouble x);
    public static SqlBoolean op_Explicit(SqlInt16 x);
    public static SqlBoolean op_Explicit(SqlInt32 x);
    public static SqlBoolean op_Explicit(SqlInt64 x);
    public static SqlBoolean op_Explicit(SqlMoney x);
    public static SqlBoolean op_Explicit(SqlSingle x);
    public static SqlBoolean op_Explicit(SqlString x);
    public static bool op_False(SqlBoolean x);
    public static SqlBoolean op_GreaterThan(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean op_Implicit(bool x);
    public static SqlBoolean op_Inequality(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean op_LessThan(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean op_LessThanOrEqual(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean op_LogicalNot(SqlBoolean x);
    public static SqlBoolean op_OnesComplement(SqlBoolean x);
    public static bool op_True(SqlBoolean x);
    public static SqlBoolean Or(SqlBoolean x, SqlBoolean y);
    public static SqlBoolean Parse(string s);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlByte ToSqlByte();
    public SqlDecimal ToSqlDecimal();
    public SqlDouble ToSqlDouble();
    public SqlInt16 ToSqlInt16();
    public SqlInt32 ToSqlInt32();
    public SqlInt64 ToSqlInt64();
    public SqlMoney ToSqlMoney();
    public SqlSingle ToSqlSingle();
    public SqlString ToSqlString();
    public virtual string ToString();
    public static SqlBoolean Xor(SqlBoolean x, SqlBoolean y);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlByte : ValueType {
    private int _dummyPrimitive;
    public static SqlByte MaxValue;
    public static SqlByte MinValue;
    public static SqlByte Null;
    public static SqlByte Zero;
    public bool IsNull { get; }
    public byte Value { get; }
    public SqlByte(byte value);
    public sealed virtual bool get_IsNull();
    public byte get_Value();
    public static SqlByte Add(SqlByte x, SqlByte y);
    public static SqlByte BitwiseAnd(SqlByte x, SqlByte y);
    public static SqlByte BitwiseOr(SqlByte x, SqlByte y);
    public int CompareTo(SqlByte value);
    public sealed virtual int CompareTo(object value);
    public static SqlByte Divide(SqlByte x, SqlByte y);
    public static SqlBoolean Equals(SqlByte x, SqlByte y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlByte x, SqlByte y);
    public static SqlBoolean GreaterThanOrEqual(SqlByte x, SqlByte y);
    public static SqlBoolean LessThan(SqlByte x, SqlByte y);
    public static SqlBoolean LessThanOrEqual(SqlByte x, SqlByte y);
    public static SqlByte Mod(SqlByte x, SqlByte y);
    public static SqlByte Modulus(SqlByte x, SqlByte y);
    public static SqlByte Multiply(SqlByte x, SqlByte y);
    public static SqlBoolean NotEquals(SqlByte x, SqlByte y);
    public static SqlByte OnesComplement(SqlByte x);
    public static SqlByte op_Addition(SqlByte x, SqlByte y);
    public static SqlByte op_BitwiseAnd(SqlByte x, SqlByte y);
    public static SqlByte op_BitwiseOr(SqlByte x, SqlByte y);
    public static SqlByte op_Division(SqlByte x, SqlByte y);
    public static SqlBoolean op_Equality(SqlByte x, SqlByte y);
    public static SqlByte op_ExclusiveOr(SqlByte x, SqlByte y);
    public static SqlByte op_Explicit(SqlBoolean x);
    public static byte op_Explicit(SqlByte x);
    public static SqlByte op_Explicit(SqlDecimal x);
    public static SqlByte op_Explicit(SqlDouble x);
    public static SqlByte op_Explicit(SqlInt16 x);
    public static SqlByte op_Explicit(SqlInt32 x);
    public static SqlByte op_Explicit(SqlInt64 x);
    public static SqlByte op_Explicit(SqlMoney x);
    public static SqlByte op_Explicit(SqlSingle x);
    public static SqlByte op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlByte x, SqlByte y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlByte x, SqlByte y);
    public static SqlByte op_Implicit(byte x);
    public static SqlBoolean op_Inequality(SqlByte x, SqlByte y);
    public static SqlBoolean op_LessThan(SqlByte x, SqlByte y);
    public static SqlBoolean op_LessThanOrEqual(SqlByte x, SqlByte y);
    public static SqlByte op_Modulus(SqlByte x, SqlByte y);
    public static SqlByte op_Multiply(SqlByte x, SqlByte y);
    public static SqlByte op_OnesComplement(SqlByte x);
    public static SqlByte op_Subtraction(SqlByte x, SqlByte y);
    public static SqlByte Parse(string s);
    public static SqlByte Subtract(SqlByte x, SqlByte y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlBoolean ToSqlBoolean();
    public SqlDecimal ToSqlDecimal();
    public SqlDouble ToSqlDouble();
    public SqlInt16 ToSqlInt16();
    public SqlInt32 ToSqlInt32();
    public SqlInt64 ToSqlInt64();
    public SqlMoney ToSqlMoney();
    public SqlSingle ToSqlSingle();
    public SqlString ToSqlString();
    public virtual string ToString();
    public static SqlByte Xor(SqlByte x, SqlByte y);
}
[DefaultMemberAttribute("Item")]
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlBytes : object {
    public Byte[] Buffer { get; }
    public bool IsNull { get; }
    public byte Item { get; public set; }
    public long Length { get; }
    public long MaxLength { get; }
    public static SqlBytes Null { get; }
    public StorageState Storage { get; }
    public Stream Stream { get; public set; }
    public Byte[] Value { get; }
    public SqlBytes(Byte[] buffer);
    public SqlBytes(SqlBinary value);
    public SqlBytes(Stream s);
    public Byte[] get_Buffer();
    public sealed virtual bool get_IsNull();
    public byte get_Item(long offset);
    public void set_Item(long offset, byte value);
    public long get_Length();
    public long get_MaxLength();
    public static SqlBytes get_Null();
    public StorageState get_Storage();
    public Stream get_Stream();
    public void set_Stream(Stream value);
    public Byte[] get_Value();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBytes op_Explicit(SqlBinary value);
    public static SqlBinary op_Explicit(SqlBytes value);
    public long Read(long offset, Byte[] buffer, int offsetInBuffer, int count);
    public void SetLength(long value);
    public void SetNull();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader r);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlBinary ToSqlBinary();
    public void Write(long offset, Byte[] buffer, int offsetInBuffer, int count);
}
[DefaultMemberAttribute("Item")]
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlChars : object {
    public Char[] Buffer { get; }
    public bool IsNull { get; }
    public char Item { get; public set; }
    public long Length { get; }
    public long MaxLength { get; }
    public static SqlChars Null { get; }
    public StorageState Storage { get; }
    public Char[] Value { get; }
    public SqlChars(Char[] buffer);
    public SqlChars(SqlString value);
    public Char[] get_Buffer();
    public sealed virtual bool get_IsNull();
    public char get_Item(long offset);
    public void set_Item(long offset, char value);
    public long get_Length();
    public long get_MaxLength();
    public static SqlChars get_Null();
    public StorageState get_Storage();
    public Char[] get_Value();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlString op_Explicit(SqlChars value);
    public static SqlChars op_Explicit(SqlString value);
    public long Read(long offset, Char[] buffer, int offsetInBuffer, int count);
    public void SetLength(long value);
    public void SetNull();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader r);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlString ToSqlString();
    public void Write(long offset, Char[] buffer, int offsetInBuffer, int count);
}
[FlagsAttribute]
public enum System.Data.SqlTypes.SqlCompareOptions : Enum {
    public int value__;
    public static SqlCompareOptions BinarySort;
    public static SqlCompareOptions BinarySort2;
    public static SqlCompareOptions IgnoreCase;
    public static SqlCompareOptions IgnoreKanaType;
    public static SqlCompareOptions IgnoreNonSpace;
    public static SqlCompareOptions IgnoreWidth;
    public static SqlCompareOptions None;
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlDateTime : ValueType {
    private int _dummyPrimitive;
    public static SqlDateTime MaxValue;
    public static SqlDateTime MinValue;
    public static SqlDateTime Null;
    public static int SQLTicksPerHour;
    public static int SQLTicksPerMinute;
    public static int SQLTicksPerSecond;
    public int DayTicks { get; }
    public bool IsNull { get; }
    public int TimeTicks { get; }
    public DateTime Value { get; }
    public SqlDateTime(DateTime value);
    public SqlDateTime(int dayTicks, int timeTicks);
    public SqlDateTime(int year, int month, int day);
    public SqlDateTime(int year, int month, int day, int hour, int minute, int second);
    public SqlDateTime(int year, int month, int day, int hour, int minute, int second, double millisecond);
    public SqlDateTime(int year, int month, int day, int hour, int minute, int second, int bilisecond);
    public int get_DayTicks();
    public sealed virtual bool get_IsNull();
    public int get_TimeTicks();
    public DateTime get_Value();
    public static SqlDateTime Add(SqlDateTime x, TimeSpan t);
    public int CompareTo(SqlDateTime value);
    public sealed virtual int CompareTo(object value);
    public static SqlBoolean Equals(SqlDateTime x, SqlDateTime y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlDateTime x, SqlDateTime y);
    public static SqlBoolean GreaterThanOrEqual(SqlDateTime x, SqlDateTime y);
    public static SqlBoolean LessThan(SqlDateTime x, SqlDateTime y);
    public static SqlBoolean LessThanOrEqual(SqlDateTime x, SqlDateTime y);
    public static SqlBoolean NotEquals(SqlDateTime x, SqlDateTime y);
    public static SqlDateTime op_Addition(SqlDateTime x, TimeSpan t);
    public static SqlBoolean op_Equality(SqlDateTime x, SqlDateTime y);
    public static DateTime op_Explicit(SqlDateTime x);
    public static SqlDateTime op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlDateTime x, SqlDateTime y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlDateTime x, SqlDateTime y);
    public static SqlDateTime op_Implicit(DateTime value);
    public static SqlBoolean op_Inequality(SqlDateTime x, SqlDateTime y);
    public static SqlBoolean op_LessThan(SqlDateTime x, SqlDateTime y);
    public static SqlBoolean op_LessThanOrEqual(SqlDateTime x, SqlDateTime y);
    public static SqlDateTime op_Subtraction(SqlDateTime x, TimeSpan t);
    public static SqlDateTime Parse(string s);
    public static SqlDateTime Subtract(SqlDateTime x, TimeSpan t);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlString ToSqlString();
    public virtual string ToString();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlDecimal : ValueType {
    private int _dummyPrimitive;
    public static byte MaxPrecision;
    public static byte MaxScale;
    public static SqlDecimal MaxValue;
    public static SqlDecimal MinValue;
    public static SqlDecimal Null;
    public Byte[] BinData { get; }
    public Int32[] Data { get; }
    public bool IsNull { get; }
    public bool IsPositive { get; }
    public byte Precision { get; }
    public byte Scale { get; }
    public decimal Value { get; }
    public SqlDecimal(byte bPrecision, byte bScale, bool fPositive, int data1, int data2, int data3, int data4);
    public SqlDecimal(byte bPrecision, byte bScale, bool fPositive, Int32[] bits);
    public SqlDecimal(decimal value);
    public SqlDecimal(double dVal);
    public SqlDecimal(int value);
    public SqlDecimal(long value);
    public Byte[] get_BinData();
    public Int32[] get_Data();
    public sealed virtual bool get_IsNull();
    public bool get_IsPositive();
    public byte get_Precision();
    public byte get_Scale();
    public decimal get_Value();
    public static SqlDecimal Abs(SqlDecimal n);
    public static SqlDecimal Add(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal AdjustScale(SqlDecimal n, int digits, bool fRound);
    public static SqlDecimal Ceiling(SqlDecimal n);
    public int CompareTo(SqlDecimal value);
    public sealed virtual int CompareTo(object value);
    public static SqlDecimal ConvertToPrecScale(SqlDecimal n, int precision, int scale);
    public static SqlDecimal Divide(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean Equals(SqlDecimal x, SqlDecimal y);
    public virtual bool Equals(object value);
    public static SqlDecimal Floor(SqlDecimal n);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean GreaterThanOrEqual(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean LessThan(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean LessThanOrEqual(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal Multiply(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean NotEquals(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal op_Addition(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal op_Division(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean op_Equality(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal op_Explicit(SqlBoolean x);
    public static decimal op_Explicit(SqlDecimal x);
    public static SqlDecimal op_Explicit(SqlDouble x);
    public static SqlDecimal op_Explicit(SqlSingle x);
    public static SqlDecimal op_Explicit(SqlString x);
    public static SqlDecimal op_Explicit(double x);
    public static SqlBoolean op_GreaterThan(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal op_Implicit(SqlByte x);
    public static SqlDecimal op_Implicit(SqlInt16 x);
    public static SqlDecimal op_Implicit(SqlInt32 x);
    public static SqlDecimal op_Implicit(SqlInt64 x);
    public static SqlDecimal op_Implicit(SqlMoney x);
    public static SqlDecimal op_Implicit(decimal x);
    public static SqlDecimal op_Implicit(long x);
    public static SqlBoolean op_Inequality(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean op_LessThan(SqlDecimal x, SqlDecimal y);
    public static SqlBoolean op_LessThanOrEqual(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal op_Multiply(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal op_Subtraction(SqlDecimal x, SqlDecimal y);
    public static SqlDecimal op_UnaryNegation(SqlDecimal x);
    public static SqlDecimal Parse(string s);
    public static SqlDecimal Power(SqlDecimal n, double exp);
    public static SqlDecimal Round(SqlDecimal n, int position);
    public static SqlInt32 Sign(SqlDecimal n);
    public static SqlDecimal Subtract(SqlDecimal x, SqlDecimal y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public double ToDouble();
    public SqlBoolean ToSqlBoolean();
    public SqlByte ToSqlByte();
    public SqlDouble ToSqlDouble();
    public SqlInt16 ToSqlInt16();
    public SqlInt32 ToSqlInt32();
    public SqlInt64 ToSqlInt64();
    public SqlMoney ToSqlMoney();
    public SqlSingle ToSqlSingle();
    public SqlString ToSqlString();
    public virtual string ToString();
    public static SqlDecimal Truncate(SqlDecimal n, int position);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlDouble : ValueType {
    private int _dummyPrimitive;
    public static SqlDouble MaxValue;
    public static SqlDouble MinValue;
    public static SqlDouble Null;
    public static SqlDouble Zero;
    public bool IsNull { get; }
    public double Value { get; }
    public SqlDouble(double value);
    public sealed virtual bool get_IsNull();
    public double get_Value();
    public static SqlDouble Add(SqlDouble x, SqlDouble y);
    public int CompareTo(SqlDouble value);
    public sealed virtual int CompareTo(object value);
    public static SqlDouble Divide(SqlDouble x, SqlDouble y);
    public static SqlBoolean Equals(SqlDouble x, SqlDouble y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlDouble x, SqlDouble y);
    public static SqlBoolean GreaterThanOrEqual(SqlDouble x, SqlDouble y);
    public static SqlBoolean LessThan(SqlDouble x, SqlDouble y);
    public static SqlBoolean LessThanOrEqual(SqlDouble x, SqlDouble y);
    public static SqlDouble Multiply(SqlDouble x, SqlDouble y);
    public static SqlBoolean NotEquals(SqlDouble x, SqlDouble y);
    public static SqlDouble op_Addition(SqlDouble x, SqlDouble y);
    public static SqlDouble op_Division(SqlDouble x, SqlDouble y);
    public static SqlBoolean op_Equality(SqlDouble x, SqlDouble y);
    public static SqlDouble op_Explicit(SqlBoolean x);
    public static double op_Explicit(SqlDouble x);
    public static SqlDouble op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlDouble x, SqlDouble y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlDouble x, SqlDouble y);
    public static SqlDouble op_Implicit(SqlByte x);
    public static SqlDouble op_Implicit(SqlDecimal x);
    public static SqlDouble op_Implicit(SqlInt16 x);
    public static SqlDouble op_Implicit(SqlInt32 x);
    public static SqlDouble op_Implicit(SqlInt64 x);
    public static SqlDouble op_Implicit(SqlMoney x);
    public static SqlDouble op_Implicit(SqlSingle x);
    public static SqlDouble op_Implicit(double x);
    public static SqlBoolean op_Inequality(SqlDouble x, SqlDouble y);
    public static SqlBoolean op_LessThan(SqlDouble x, SqlDouble y);
    public static SqlBoolean op_LessThanOrEqual(SqlDouble x, SqlDouble y);
    public static SqlDouble op_Multiply(SqlDouble x, SqlDouble y);
    public static SqlDouble op_Subtraction(SqlDouble x, SqlDouble y);
    public static SqlDouble op_UnaryNegation(SqlDouble x);
    public static SqlDouble Parse(string s);
    public static SqlDouble Subtract(SqlDouble x, SqlDouble y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlBoolean ToSqlBoolean();
    public SqlByte ToSqlByte();
    public SqlDecimal ToSqlDecimal();
    public SqlInt16 ToSqlInt16();
    public SqlInt32 ToSqlInt32();
    public SqlInt64 ToSqlInt64();
    public SqlMoney ToSqlMoney();
    public SqlSingle ToSqlSingle();
    public SqlString ToSqlString();
    public virtual string ToString();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlGuid : ValueType {
    private object _dummy;
    public static SqlGuid Null;
    public bool IsNull { get; }
    public Guid Value { get; }
    public SqlGuid(Byte[] value);
    public SqlGuid(Guid g);
    public SqlGuid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public SqlGuid(string s);
    public sealed virtual bool get_IsNull();
    public Guid get_Value();
    public int CompareTo(SqlGuid value);
    public sealed virtual int CompareTo(object value);
    public static SqlBoolean Equals(SqlGuid x, SqlGuid y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlGuid x, SqlGuid y);
    public static SqlBoolean GreaterThanOrEqual(SqlGuid x, SqlGuid y);
    public static SqlBoolean LessThan(SqlGuid x, SqlGuid y);
    public static SqlBoolean LessThanOrEqual(SqlGuid x, SqlGuid y);
    public static SqlBoolean NotEquals(SqlGuid x, SqlGuid y);
    public static SqlBoolean op_Equality(SqlGuid x, SqlGuid y);
    public static SqlGuid op_Explicit(SqlBinary x);
    public static Guid op_Explicit(SqlGuid x);
    public static SqlGuid op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlGuid x, SqlGuid y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlGuid x, SqlGuid y);
    public static SqlGuid op_Implicit(Guid x);
    public static SqlBoolean op_Inequality(SqlGuid x, SqlGuid y);
    public static SqlBoolean op_LessThan(SqlGuid x, SqlGuid y);
    public static SqlBoolean op_LessThanOrEqual(SqlGuid x, SqlGuid y);
    public static SqlGuid Parse(string s);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public Byte[] ToByteArray();
    public SqlBinary ToSqlBinary();
    public SqlString ToSqlString();
    public virtual string ToString();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlInt16 : ValueType {
    private int _dummyPrimitive;
    public static SqlInt16 MaxValue;
    public static SqlInt16 MinValue;
    public static SqlInt16 Null;
    public static SqlInt16 Zero;
    public bool IsNull { get; }
    public short Value { get; }
    public SqlInt16(short value);
    public sealed virtual bool get_IsNull();
    public short get_Value();
    public static SqlInt16 Add(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 BitwiseAnd(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 BitwiseOr(SqlInt16 x, SqlInt16 y);
    public int CompareTo(SqlInt16 value);
    public sealed virtual int CompareTo(object value);
    public static SqlInt16 Divide(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean Equals(SqlInt16 x, SqlInt16 y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean GreaterThanOrEqual(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean LessThan(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean LessThanOrEqual(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 Mod(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 Modulus(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 Multiply(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean NotEquals(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 OnesComplement(SqlInt16 x);
    public static SqlInt16 op_Addition(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_BitwiseAnd(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_BitwiseOr(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_Division(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean op_Equality(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_ExclusiveOr(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_Explicit(SqlBoolean x);
    public static SqlInt16 op_Explicit(SqlDecimal x);
    public static SqlInt16 op_Explicit(SqlDouble x);
    public static short op_Explicit(SqlInt16 x);
    public static SqlInt16 op_Explicit(SqlInt32 x);
    public static SqlInt16 op_Explicit(SqlInt64 x);
    public static SqlInt16 op_Explicit(SqlMoney x);
    public static SqlInt16 op_Explicit(SqlSingle x);
    public static SqlInt16 op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_Implicit(SqlByte x);
    public static SqlInt16 op_Implicit(short x);
    public static SqlBoolean op_Inequality(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean op_LessThan(SqlInt16 x, SqlInt16 y);
    public static SqlBoolean op_LessThanOrEqual(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_Modulus(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_Multiply(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_OnesComplement(SqlInt16 x);
    public static SqlInt16 op_Subtraction(SqlInt16 x, SqlInt16 y);
    public static SqlInt16 op_UnaryNegation(SqlInt16 x);
    public static SqlInt16 Parse(string s);
    public static SqlInt16 Subtract(SqlInt16 x, SqlInt16 y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlBoolean ToSqlBoolean();
    public SqlByte ToSqlByte();
    public SqlDecimal ToSqlDecimal();
    public SqlDouble ToSqlDouble();
    public SqlInt32 ToSqlInt32();
    public SqlInt64 ToSqlInt64();
    public SqlMoney ToSqlMoney();
    public SqlSingle ToSqlSingle();
    public SqlString ToSqlString();
    public virtual string ToString();
    public static SqlInt16 Xor(SqlInt16 x, SqlInt16 y);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlInt32 : ValueType {
    private int _dummyPrimitive;
    public static SqlInt32 MaxValue;
    public static SqlInt32 MinValue;
    public static SqlInt32 Null;
    public static SqlInt32 Zero;
    public bool IsNull { get; }
    public int Value { get; }
    public SqlInt32(int value);
    public sealed virtual bool get_IsNull();
    public int get_Value();
    public static SqlInt32 Add(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 BitwiseAnd(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 BitwiseOr(SqlInt32 x, SqlInt32 y);
    public int CompareTo(SqlInt32 value);
    public sealed virtual int CompareTo(object value);
    public static SqlInt32 Divide(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean Equals(SqlInt32 x, SqlInt32 y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean GreaterThanOrEqual(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean LessThan(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean LessThanOrEqual(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 Mod(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 Modulus(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 Multiply(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean NotEquals(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 OnesComplement(SqlInt32 x);
    public static SqlInt32 op_Addition(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_BitwiseAnd(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_BitwiseOr(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_Division(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean op_Equality(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_ExclusiveOr(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_Explicit(SqlBoolean x);
    public static SqlInt32 op_Explicit(SqlDecimal x);
    public static SqlInt32 op_Explicit(SqlDouble x);
    public static int op_Explicit(SqlInt32 x);
    public static SqlInt32 op_Explicit(SqlInt64 x);
    public static SqlInt32 op_Explicit(SqlMoney x);
    public static SqlInt32 op_Explicit(SqlSingle x);
    public static SqlInt32 op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_Implicit(SqlByte x);
    public static SqlInt32 op_Implicit(SqlInt16 x);
    public static SqlInt32 op_Implicit(int x);
    public static SqlBoolean op_Inequality(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean op_LessThan(SqlInt32 x, SqlInt32 y);
    public static SqlBoolean op_LessThanOrEqual(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_Modulus(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_Multiply(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_OnesComplement(SqlInt32 x);
    public static SqlInt32 op_Subtraction(SqlInt32 x, SqlInt32 y);
    public static SqlInt32 op_UnaryNegation(SqlInt32 x);
    public static SqlInt32 Parse(string s);
    public static SqlInt32 Subtract(SqlInt32 x, SqlInt32 y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlBoolean ToSqlBoolean();
    public SqlByte ToSqlByte();
    public SqlDecimal ToSqlDecimal();
    public SqlDouble ToSqlDouble();
    public SqlInt16 ToSqlInt16();
    public SqlInt64 ToSqlInt64();
    public SqlMoney ToSqlMoney();
    public SqlSingle ToSqlSingle();
    public SqlString ToSqlString();
    public virtual string ToString();
    public static SqlInt32 Xor(SqlInt32 x, SqlInt32 y);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlInt64 : ValueType {
    private int _dummyPrimitive;
    public static SqlInt64 MaxValue;
    public static SqlInt64 MinValue;
    public static SqlInt64 Null;
    public static SqlInt64 Zero;
    public bool IsNull { get; }
    public long Value { get; }
    public SqlInt64(long value);
    public sealed virtual bool get_IsNull();
    public long get_Value();
    public static SqlInt64 Add(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 BitwiseAnd(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 BitwiseOr(SqlInt64 x, SqlInt64 y);
    public int CompareTo(SqlInt64 value);
    public sealed virtual int CompareTo(object value);
    public static SqlInt64 Divide(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean Equals(SqlInt64 x, SqlInt64 y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean GreaterThanOrEqual(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean LessThan(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean LessThanOrEqual(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 Mod(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 Modulus(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 Multiply(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean NotEquals(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 OnesComplement(SqlInt64 x);
    public static SqlInt64 op_Addition(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_BitwiseAnd(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_BitwiseOr(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_Division(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean op_Equality(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_ExclusiveOr(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_Explicit(SqlBoolean x);
    public static SqlInt64 op_Explicit(SqlDecimal x);
    public static SqlInt64 op_Explicit(SqlDouble x);
    public static long op_Explicit(SqlInt64 x);
    public static SqlInt64 op_Explicit(SqlMoney x);
    public static SqlInt64 op_Explicit(SqlSingle x);
    public static SqlInt64 op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_Implicit(SqlByte x);
    public static SqlInt64 op_Implicit(SqlInt16 x);
    public static SqlInt64 op_Implicit(SqlInt32 x);
    public static SqlInt64 op_Implicit(long x);
    public static SqlBoolean op_Inequality(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean op_LessThan(SqlInt64 x, SqlInt64 y);
    public static SqlBoolean op_LessThanOrEqual(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_Modulus(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_Multiply(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_OnesComplement(SqlInt64 x);
    public static SqlInt64 op_Subtraction(SqlInt64 x, SqlInt64 y);
    public static SqlInt64 op_UnaryNegation(SqlInt64 x);
    public static SqlInt64 Parse(string s);
    public static SqlInt64 Subtract(SqlInt64 x, SqlInt64 y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlBoolean ToSqlBoolean();
    public SqlByte ToSqlByte();
    public SqlDecimal ToSqlDecimal();
    public SqlDouble ToSqlDouble();
    public SqlInt16 ToSqlInt16();
    public SqlInt32 ToSqlInt32();
    public SqlMoney ToSqlMoney();
    public SqlSingle ToSqlSingle();
    public SqlString ToSqlString();
    public virtual string ToString();
    public static SqlInt64 Xor(SqlInt64 x, SqlInt64 y);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlMoney : ValueType {
    private int _dummyPrimitive;
    public static SqlMoney MaxValue;
    public static SqlMoney MinValue;
    public static SqlMoney Null;
    public static SqlMoney Zero;
    public bool IsNull { get; }
    public decimal Value { get; }
    public SqlMoney(decimal value);
    public SqlMoney(double value);
    public SqlMoney(int value);
    public SqlMoney(long value);
    public sealed virtual bool get_IsNull();
    public decimal get_Value();
    public static SqlMoney Add(SqlMoney x, SqlMoney y);
    public int CompareTo(SqlMoney value);
    public sealed virtual int CompareTo(object value);
    public static SqlMoney Divide(SqlMoney x, SqlMoney y);
    public static SqlBoolean Equals(SqlMoney x, SqlMoney y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlMoney x, SqlMoney y);
    public static SqlBoolean GreaterThanOrEqual(SqlMoney x, SqlMoney y);
    public static SqlBoolean LessThan(SqlMoney x, SqlMoney y);
    public static SqlBoolean LessThanOrEqual(SqlMoney x, SqlMoney y);
    public static SqlMoney Multiply(SqlMoney x, SqlMoney y);
    public static SqlBoolean NotEquals(SqlMoney x, SqlMoney y);
    public static SqlMoney op_Addition(SqlMoney x, SqlMoney y);
    public static SqlMoney op_Division(SqlMoney x, SqlMoney y);
    public static SqlBoolean op_Equality(SqlMoney x, SqlMoney y);
    public static SqlMoney op_Explicit(SqlBoolean x);
    public static SqlMoney op_Explicit(SqlDecimal x);
    public static SqlMoney op_Explicit(SqlDouble x);
    public static decimal op_Explicit(SqlMoney x);
    public static SqlMoney op_Explicit(SqlSingle x);
    public static SqlMoney op_Explicit(SqlString x);
    public static SqlMoney op_Explicit(double x);
    public static SqlBoolean op_GreaterThan(SqlMoney x, SqlMoney y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlMoney x, SqlMoney y);
    public static SqlMoney op_Implicit(SqlByte x);
    public static SqlMoney op_Implicit(SqlInt16 x);
    public static SqlMoney op_Implicit(SqlInt32 x);
    public static SqlMoney op_Implicit(SqlInt64 x);
    public static SqlMoney op_Implicit(decimal x);
    public static SqlMoney op_Implicit(long x);
    public static SqlBoolean op_Inequality(SqlMoney x, SqlMoney y);
    public static SqlBoolean op_LessThan(SqlMoney x, SqlMoney y);
    public static SqlBoolean op_LessThanOrEqual(SqlMoney x, SqlMoney y);
    public static SqlMoney op_Multiply(SqlMoney x, SqlMoney y);
    public static SqlMoney op_Subtraction(SqlMoney x, SqlMoney y);
    public static SqlMoney op_UnaryNegation(SqlMoney x);
    public static SqlMoney Parse(string s);
    public static SqlMoney Subtract(SqlMoney x, SqlMoney y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public decimal ToDecimal();
    public double ToDouble();
    public int ToInt32();
    public long ToInt64();
    public SqlBoolean ToSqlBoolean();
    public SqlByte ToSqlByte();
    public SqlDecimal ToSqlDecimal();
    public SqlDouble ToSqlDouble();
    public SqlInt16 ToSqlInt16();
    public SqlInt32 ToSqlInt32();
    public SqlInt64 ToSqlInt64();
    public SqlSingle ToSqlSingle();
    public SqlString ToSqlString();
    public virtual string ToString();
}
public class System.Data.SqlTypes.SqlNotFilledException : SqlTypeException {
    public SqlNotFilledException(string message);
    public SqlNotFilledException(string message, Exception e);
}
public class System.Data.SqlTypes.SqlNullValueException : SqlTypeException {
    public SqlNullValueException(string message);
    public SqlNullValueException(string message, Exception e);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlSingle : ValueType {
    private int _dummyPrimitive;
    public static SqlSingle MaxValue;
    public static SqlSingle MinValue;
    public static SqlSingle Null;
    public static SqlSingle Zero;
    public bool IsNull { get; }
    public float Value { get; }
    public SqlSingle(double value);
    public SqlSingle(float value);
    public sealed virtual bool get_IsNull();
    public float get_Value();
    public static SqlSingle Add(SqlSingle x, SqlSingle y);
    public int CompareTo(SqlSingle value);
    public sealed virtual int CompareTo(object value);
    public static SqlSingle Divide(SqlSingle x, SqlSingle y);
    public static SqlBoolean Equals(SqlSingle x, SqlSingle y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlSingle x, SqlSingle y);
    public static SqlBoolean GreaterThanOrEqual(SqlSingle x, SqlSingle y);
    public static SqlBoolean LessThan(SqlSingle x, SqlSingle y);
    public static SqlBoolean LessThanOrEqual(SqlSingle x, SqlSingle y);
    public static SqlSingle Multiply(SqlSingle x, SqlSingle y);
    public static SqlBoolean NotEquals(SqlSingle x, SqlSingle y);
    public static SqlSingle op_Addition(SqlSingle x, SqlSingle y);
    public static SqlSingle op_Division(SqlSingle x, SqlSingle y);
    public static SqlBoolean op_Equality(SqlSingle x, SqlSingle y);
    public static SqlSingle op_Explicit(SqlBoolean x);
    public static SqlSingle op_Explicit(SqlDouble x);
    public static float op_Explicit(SqlSingle x);
    public static SqlSingle op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlSingle x, SqlSingle y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlSingle x, SqlSingle y);
    public static SqlSingle op_Implicit(SqlByte x);
    public static SqlSingle op_Implicit(SqlDecimal x);
    public static SqlSingle op_Implicit(SqlInt16 x);
    public static SqlSingle op_Implicit(SqlInt32 x);
    public static SqlSingle op_Implicit(SqlInt64 x);
    public static SqlSingle op_Implicit(SqlMoney x);
    public static SqlSingle op_Implicit(float x);
    public static SqlBoolean op_Inequality(SqlSingle x, SqlSingle y);
    public static SqlBoolean op_LessThan(SqlSingle x, SqlSingle y);
    public static SqlBoolean op_LessThanOrEqual(SqlSingle x, SqlSingle y);
    public static SqlSingle op_Multiply(SqlSingle x, SqlSingle y);
    public static SqlSingle op_Subtraction(SqlSingle x, SqlSingle y);
    public static SqlSingle op_UnaryNegation(SqlSingle x);
    public static SqlSingle Parse(string s);
    public static SqlSingle Subtract(SqlSingle x, SqlSingle y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlBoolean ToSqlBoolean();
    public SqlByte ToSqlByte();
    public SqlDecimal ToSqlDecimal();
    public SqlDouble ToSqlDouble();
    public SqlInt16 ToSqlInt16();
    public SqlInt32 ToSqlInt32();
    public SqlInt64 ToSqlInt64();
    public SqlMoney ToSqlMoney();
    public SqlString ToSqlString();
    public virtual string ToString();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlString : ValueType {
    private object _dummy;
    public static int BinarySort;
    public static int BinarySort2;
    public static int IgnoreCase;
    public static int IgnoreKanaType;
    public static int IgnoreNonSpace;
    public static int IgnoreWidth;
    public static SqlString Null;
    public CompareInfo CompareInfo { get; }
    public CultureInfo CultureInfo { get; }
    public bool IsNull { get; }
    public int LCID { get; }
    public SqlCompareOptions SqlCompareOptions { get; }
    public string Value { get; }
    public SqlString(int lcid, SqlCompareOptions compareOptions, Byte[] data);
    public SqlString(int lcid, SqlCompareOptions compareOptions, Byte[] data, bool fUnicode);
    public SqlString(int lcid, SqlCompareOptions compareOptions, Byte[] data, int index, int count);
    public SqlString(int lcid, SqlCompareOptions compareOptions, Byte[] data, int index, int count, bool fUnicode);
    public SqlString(string data);
    public SqlString(string data, int lcid);
    public SqlString(string data, int lcid, SqlCompareOptions compareOptions);
    public CompareInfo get_CompareInfo();
    public CultureInfo get_CultureInfo();
    public sealed virtual bool get_IsNull();
    public int get_LCID();
    public SqlCompareOptions get_SqlCompareOptions();
    public string get_Value();
    public static SqlString Add(SqlString x, SqlString y);
    public SqlString Clone();
    public static CompareOptions CompareOptionsFromSqlCompareOptions(SqlCompareOptions compareOptions);
    public int CompareTo(SqlString value);
    public sealed virtual int CompareTo(object value);
    public static SqlString Concat(SqlString x, SqlString y);
    public static SqlBoolean Equals(SqlString x, SqlString y);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public Byte[] GetNonUnicodeBytes();
    public Byte[] GetUnicodeBytes();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    public static SqlBoolean GreaterThan(SqlString x, SqlString y);
    public static SqlBoolean GreaterThanOrEqual(SqlString x, SqlString y);
    public static SqlBoolean LessThan(SqlString x, SqlString y);
    public static SqlBoolean LessThanOrEqual(SqlString x, SqlString y);
    public static SqlBoolean NotEquals(SqlString x, SqlString y);
    public static SqlString op_Addition(SqlString x, SqlString y);
    public static SqlBoolean op_Equality(SqlString x, SqlString y);
    public static SqlString op_Explicit(SqlBoolean x);
    public static SqlString op_Explicit(SqlByte x);
    public static SqlString op_Explicit(SqlDateTime x);
    public static SqlString op_Explicit(SqlDecimal x);
    public static SqlString op_Explicit(SqlDouble x);
    public static SqlString op_Explicit(SqlGuid x);
    public static SqlString op_Explicit(SqlInt16 x);
    public static SqlString op_Explicit(SqlInt32 x);
    public static SqlString op_Explicit(SqlInt64 x);
    public static SqlString op_Explicit(SqlMoney x);
    public static SqlString op_Explicit(SqlSingle x);
    public static string op_Explicit(SqlString x);
    public static SqlBoolean op_GreaterThan(SqlString x, SqlString y);
    public static SqlBoolean op_GreaterThanOrEqual(SqlString x, SqlString y);
    public static SqlString op_Implicit(string x);
    public static SqlBoolean op_Inequality(SqlString x, SqlString y);
    public static SqlBoolean op_LessThan(SqlString x, SqlString y);
    public static SqlBoolean op_LessThanOrEqual(SqlString x, SqlString y);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public SqlBoolean ToSqlBoolean();
    public SqlByte ToSqlByte();
    public SqlDateTime ToSqlDateTime();
    public SqlDecimal ToSqlDecimal();
    public SqlDouble ToSqlDouble();
    public SqlGuid ToSqlGuid();
    public SqlInt16 ToSqlInt16();
    public SqlInt32 ToSqlInt32();
    public SqlInt64 ToSqlInt64();
    public SqlMoney ToSqlMoney();
    public SqlSingle ToSqlSingle();
    public virtual string ToString();
}
public class System.Data.SqlTypes.SqlTruncateException : SqlTypeException {
    public SqlTruncateException(string message);
    public SqlTruncateException(string message, Exception e);
}
public class System.Data.SqlTypes.SqlTypeException : SystemException {
    protected SqlTypeException(SerializationInfo si, StreamingContext sc);
    public SqlTypeException(string message);
    public SqlTypeException(string message, Exception e);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class System.Data.SqlTypes.SqlXml : object {
    public bool IsNull { get; }
    public static SqlXml Null { get; }
    public string Value { get; }
    public SqlXml(Stream value);
    public SqlXml(XmlReader value);
    public sealed virtual bool get_IsNull();
    public static SqlXml get_Null();
    public string get_Value();
    public XmlReader CreateReader();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader r);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
public enum System.Data.SqlTypes.StorageState : Enum {
    public int value__;
    public static StorageState Buffer;
    public static StorageState Stream;
    public static StorageState UnmanagedBuffer;
}
public class System.Data.StateChangeEventArgs : EventArgs {
    public ConnectionState CurrentState { get; }
    public ConnectionState OriginalState { get; }
    public StateChangeEventArgs(ConnectionState originalState, ConnectionState currentState);
    public ConnectionState get_CurrentState();
    public ConnectionState get_OriginalState();
}
public class System.Data.StateChangeEventHandler : MulticastDelegate {
    public StateChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StateChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StateChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Data.StatementCompletedEventArgs : EventArgs {
    public int RecordCount { get; }
    public StatementCompletedEventArgs(int recordCount);
    public int get_RecordCount();
}
public class System.Data.StatementCompletedEventHandler : MulticastDelegate {
    public StatementCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StatementCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StatementCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Data.StatementType : Enum {
    public int value__;
    public static StatementType Batch;
    public static StatementType Delete;
    public static StatementType Insert;
    public static StatementType Select;
    public static StatementType Update;
}
public class System.Data.StrongTypingException : DataException {
    protected StrongTypingException(SerializationInfo info, StreamingContext context);
    public StrongTypingException(string message);
    public StrongTypingException(string s, Exception innerException);
}
public class System.Data.SyntaxErrorException : InvalidExpressionException {
    protected SyntaxErrorException(SerializationInfo info, StreamingContext context);
    public SyntaxErrorException(string s);
    public SyntaxErrorException(string message, Exception innerException);
}
public abstract class System.Data.TypedTableBase`1 : DataTable {
    protected TypedTableBase`1(SerializationInfo info, StreamingContext context);
    public EnumerableRowCollection`1<TResult> Cast();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class System.Data.TypedTableBaseExtensions : object {
    [ExtensionAttribute]
public static EnumerableRowCollection`1<TRow> AsEnumerable(TypedTableBase`1<TRow> source);
    [ExtensionAttribute]
public static TRow ElementAtOrDefault(TypedTableBase`1<TRow> source, int index);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> OrderByDescending(TypedTableBase`1<TRow> source, Func`2<TRow, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> OrderByDescending(TypedTableBase`1<TRow> source, Func`2<TRow, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> OrderBy(TypedTableBase`1<TRow> source, Func`2<TRow, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedEnumerableRowCollection`1<TRow> OrderBy(TypedTableBase`1<TRow> source, Func`2<TRow, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static EnumerableRowCollection`1<S> Select(TypedTableBase`1<TRow> source, Func`2<TRow, S> selector);
    [ExtensionAttribute]
public static EnumerableRowCollection`1<TRow> Where(TypedTableBase`1<TRow> source, Func`2<TRow, bool> predicate);
}
[DefaultPropertyAttribute("ConstraintName")]
public class System.Data.UniqueConstraint : Constraint {
    [ReadOnlyAttribute("True")]
public DataColumn[] Columns { get; }
    public bool IsPrimaryKey { get; }
    [ReadOnlyAttribute("True")]
public DataTable Table { get; }
    public UniqueConstraint(DataColumn column);
    public UniqueConstraint(DataColumn column, bool isPrimaryKey);
    public UniqueConstraint(DataColumn[] columns);
    public UniqueConstraint(DataColumn[] columns, bool isPrimaryKey);
    public UniqueConstraint(string name, DataColumn column);
    public UniqueConstraint(string name, DataColumn column, bool isPrimaryKey);
    public UniqueConstraint(string name, DataColumn[] columns);
    public UniqueConstraint(string name, DataColumn[] columns, bool isPrimaryKey);
    [BrowsableAttribute("False")]
public UniqueConstraint(string name, String[] columnNames, bool isPrimaryKey);
    public virtual DataColumn[] get_Columns();
    public bool get_IsPrimaryKey();
    public virtual DataTable get_Table();
    public virtual bool Equals(object key2);
    public virtual int GetHashCode();
}
public enum System.Data.UpdateRowSource : Enum {
    public int value__;
    public static UpdateRowSource Both;
    public static UpdateRowSource FirstReturnedRecord;
    public static UpdateRowSource None;
    public static UpdateRowSource OutputParameters;
}
public enum System.Data.UpdateStatus : Enum {
    public int value__;
    public static UpdateStatus Continue;
    public static UpdateStatus ErrorsOccurred;
    public static UpdateStatus SkipAllRemainingRows;
    public static UpdateStatus SkipCurrentRow;
}
public class System.Data.VersionNotFoundException : DataException {
    protected VersionNotFoundException(SerializationInfo info, StreamingContext context);
    public VersionNotFoundException(string s);
    public VersionNotFoundException(string message, Exception innerException);
}
public enum System.Data.XmlReadMode : Enum {
    public int value__;
    public static XmlReadMode Auto;
    public static XmlReadMode DiffGram;
    public static XmlReadMode Fragment;
    public static XmlReadMode IgnoreSchema;
    public static XmlReadMode InferSchema;
    public static XmlReadMode InferTypedSchema;
    public static XmlReadMode ReadSchema;
}
public enum System.Data.XmlWriteMode : Enum {
    public int value__;
    public static XmlWriteMode DiffGram;
    public static XmlWriteMode IgnoreSchema;
    public static XmlWriteMode WriteSchema;
}
public class System.DataMisalignedException : SystemException {
    public DataMisalignedException(string message);
    public DataMisalignedException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.DateTime : ValueType {
    private int _dummyPrimitive;
    public static DateTime MaxValue;
    public static DateTime MinValue;
    public static DateTime UnixEpoch;
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public static DateTime UtcNow { get; }
    public int Year { get; }
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    public DateTime(long ticks);
    public DateTime(long ticks, DateTimeKind kind);
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public static DateTime get_UtcNow();
    public int get_Year();
    public DateTime Add(TimeSpan value);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(DateTime value);
    public sealed virtual int CompareTo(object value);
    public static int DaysInMonth(int year, int month);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public virtual bool Equals(object value);
    public static DateTime FromBinary(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public bool IsDaylightSavingTime();
    public static bool IsLeapYear(int year);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public long ToBinary();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    public string ToLongDateString();
    public string ToLongTimeString();
    public double ToOADate();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Local;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
}
[IsReadOnlyAttribute]
public class System.DateTimeOffset : ValueType {
    private int _dummyPrimitive;
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset MinValue;
    public static DateTimeOffset UnixEpoch;
    public DateTime Date { get; }
    public DateTime DateTime { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTime LocalDateTime { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTimeOffset Now { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public DateTime UtcDateTime { get; }
    public static DateTimeOffset UtcNow { get; }
    public long UtcTicks { get; }
    public int Year { get; }
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTime get_Date();
    public DateTime get_DateTime();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public DateTime get_LocalDateTime();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTimeOffset get_Now();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public DateTime get_UtcDateTime();
    public static DateTimeOffset get_UtcNow();
    public long get_UtcTicks();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public sealed virtual bool Equals(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public virtual bool Equals(object obj);
    public bool EqualsExact(DateTimeOffset other);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public virtual int GetHashCode();
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public long ToFileTime();
    public DateTimeOffset ToLocalTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public long ToUnixTimeMilliseconds();
    public long ToUnixTimeSeconds();
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Friday;
    public static DayOfWeek Monday;
    public static DayOfWeek Saturday;
    public static DayOfWeek Sunday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
}
public class System.DBNull : object {
    public static DBNull Value;
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
}
[IsReadOnlyAttribute]
public class System.Decimal : ValueType {
    private int _dummyPrimitive;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    public Decimal(double value);
    public Decimal(int value);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    public Decimal(Int32[] bits);
    public Decimal(long value);
    public Decimal(float value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public static decimal Add(decimal d1, decimal d2);
    public static decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    public sealed virtual int CompareTo(decimal value);
    public sealed virtual int CompareTo(object value);
    public static decimal Divide(decimal d1, decimal d2);
    public sealed virtual bool Equals(decimal value);
    public static bool Equals(decimal d1, decimal d2);
    public virtual bool Equals(object value);
    public static decimal Floor(decimal d);
    public static decimal FromOACurrency(long cy);
    public static Int32[] GetBits(decimal d);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    public static decimal op_Addition(decimal d1, decimal d2);
    public static decimal op_Decrement(decimal d);
    public static decimal op_Division(decimal d1, decimal d2);
    public static bool op_Equality(decimal d1, decimal d2);
    public static byte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static decimal op_Explicit(double value);
    public static decimal op_Explicit(float value);
    public static bool op_GreaterThan(decimal d1, decimal d2);
    public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public static decimal op_Implicit(byte value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(short value);
    public static decimal op_Implicit(int value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Increment(decimal d);
    public static bool op_Inequality(decimal d1, decimal d2);
    public static bool op_LessThan(decimal d1, decimal d2);
    public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    public static decimal op_Multiply(decimal d1, decimal d2);
    public static decimal op_Subtraction(decimal d1, decimal d2);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Remainder(decimal d1, decimal d2);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Subtract(decimal d1, decimal d2);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public static byte ToByte(decimal value);
    public static double ToDouble(decimal d);
    public static short ToInt16(decimal value);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    public static long ToOACurrency(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static float ToSingle(decimal d);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static decimal Truncate(decimal d);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
}
public abstract class System.Delegate : object {
    public MethodInfo Method { get; }
    public object Target { get; }
    protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    public MethodInfo get_Method();
    public object get_Target();
    public virtual object Clone();
    public static Delegate Combine(Delegate a, Delegate b);
    public static Delegate Combine(Delegate[] delegates);
    protected virtual Delegate CombineImpl(Delegate d);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, object target, string method);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public object DynamicInvoke(Object[] args);
    protected virtual object DynamicInvokeImpl(Object[] args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Delegate[] GetInvocationList();
    protected virtual MethodInfo GetMethodImpl();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(Delegate d1, Delegate d2);
    public static bool op_Inequality(Delegate d1, Delegate d2);
    public static Delegate Remove(Delegate source, Delegate value);
    public static Delegate RemoveAll(Delegate source, Delegate value);
    protected virtual Delegate RemoveImpl(Delegate d);
}
[SwitchLevelAttribute("System.Boolean")]
public class System.Diagnostics.BooleanSwitch : Switch {
    public bool Enabled { get; public set; }
    public BooleanSwitch(string displayName, string description);
    public BooleanSwitch(string displayName, string description, string defaultSwitchValue);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual void OnValueChanged();
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    public bool get_ParameterValue();
}
[AttributeUsageAttribute("749")]
public class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
public class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    public bool get_ReturnValue();
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CODE_ANALYSIS")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    public string Category { get; }
    public string CheckId { get; }
    public string Justification { get; public set; }
    public string MessageId { get; public set; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public SuppressMessageAttribute(string category, string checkId);
    public string get_Category();
    public string get_CheckId();
    public string get_Justification();
    public void set_Justification(string value);
    public string get_MessageId();
    public void set_MessageId(string value);
    public string get_Scope();
    public void set_Scope(string value);
    public string get_Target();
    public void set_Target(string value);
}
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    public string get_ConditionString();
}
public static class System.Diagnostics.Contracts.Contract : object {
    public static void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    public static void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assume(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assume(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EndContractBlock();
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition, string userMessage);
    public static bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    public static bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition, string userMessage);
    public static T OldValue(T value);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition, string userMessage);
    public static void Requires(bool condition);
    public static void Requires(bool condition, string userMessage);
    public static T Result();
    public static T ValueAtReturn(T& value);
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractAbbreviatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractArgumentValidatorAttribute : Attribute {
}
[AttributeUsageAttribute("5124")]
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public class System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
    public Type TypeContainingContracts { get; }
    public ContractClassAttribute(Type typeContainingContracts);
    public Type get_TypeContainingContracts();
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
    public Type TypeContractsAreFor { get; }
    public ContractClassForAttribute(Type typeContractsAreFor);
    public Type get_TypeContractsAreFor();
}
public class System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
    public string Condition { get; }
    public ContractFailureKind FailureKind { get; }
    public bool Handled { get; }
    public string Message { get; }
    public Exception OriginalException { get; }
    public bool Unwind { get; }
    public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
    public string get_Condition();
    public ContractFailureKind get_FailureKind();
    public bool get_Handled();
    public string get_Message();
    public Exception get_OriginalException();
    public bool get_Unwind();
    public void SetHandled();
    public void SetUnwind();
}
public enum System.Diagnostics.Contracts.ContractFailureKind : Enum {
    public int value__;
    public static ContractFailureKind Assert;
    public static ContractFailureKind Assume;
    public static ContractFailureKind Invariant;
    public static ContractFailureKind Postcondition;
    public static ContractFailureKind PostconditionOnException;
    public static ContractFailureKind Precondition;
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractInvariantMethodAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
    public string Category { get; }
    public bool Enabled { get; }
    public string Setting { get; }
    public string Value { get; }
    public ContractOptionAttribute(string category, string setting, bool enabled);
    public ContractOptionAttribute(string category, string setting, string value);
    public string get_Category();
    public bool get_Enabled();
    public string get_Setting();
    public string get_Value();
}
[AttributeUsageAttribute("256")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
    public string Name { get; }
    public ContractPublicPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
public class System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute : Attribute {
}
[AttributeUsageAttribute("237")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
    public bool Value { get; }
    public ContractVerificationAttribute(bool value);
    public bool get_Value();
}
[AttributeUsageAttribute("6884")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.PureAttribute : Attribute {
}
public class System.Diagnostics.CorrelationManager : object {
    public Guid ActivityId { get; public set; }
    public Stack LogicalOperationStack { get; }
    public Guid get_ActivityId();
    public void set_ActivityId(Guid value);
    public Stack get_LogicalOperationStack();
    public void StartLogicalOperation();
    public void StartLogicalOperation(object operationId);
    public void StopLogicalOperation();
}
public class System.Diagnostics.DataReceivedEventArgs : EventArgs {
    public string Data { get; }
    public string get_Data();
}
public class System.Diagnostics.DataReceivedEventHandler : MulticastDelegate {
    public DataReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataReceivedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataReceivedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Diagnostics.Debug : object {
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [DoesNotReturnAttribute]
[ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [DoesNotReturnAttribute]
[ConditionalAttribute("DEBUG")]
public static void Fail(string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [ConditionalAttribute("DEBUG")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    public DebuggingModes DebuggingFlags { get; }
    public bool IsJITOptimizerDisabled { get; }
    public bool IsJITTrackingEnabled { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public DebuggingModes get_DebuggingFlags();
    public bool get_IsJITOptimizerDisabled();
    public bool get_IsJITTrackingEnabled();
}
public static class System.Diagnostics.Debugger : object {
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    public static bool get_IsAttached();
    public static void Break();
    public static bool IsLogging();
    public static bool Launch();
    public static void Log(int level, string category, string message);
    public static void NotifyOfCrossThreadDependency();
}
[AttributeUsageAttribute("384")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    public DebuggerBrowsableState get_State();
}
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState RootHidden;
}
[AttributeUsageAttribute("4509")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    public string Name { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public string Type { get; public set; }
    public string Value { get; }
    public DebuggerDisplayAttribute(string value);
    public string get_Name();
    public void set_Name(string value);
    public Type get_Target();
    public void set_Target(Type value);
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
    public string get_Type();
    public void set_Type(string value);
    public string get_Value();
}
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[AttributeUsageAttribute("236")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
public class System.Diagnostics.DebuggerStepperBoundaryAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerTypeProxyAttribute(string typeName);
    public DebuggerTypeProxyAttribute(Type type);
    public string get_ProxyTypeName();
    public Type get_Target();
    public void set_Target(Type value);
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
    public string Description { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public string VisualizerObjectSourceTypeName { get; }
    public string VisualizerTypeName { get; }
    public DebuggerVisualizerAttribute(string visualizerTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer);
    public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
    public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
    public string get_Description();
    public void set_Description(string value);
    public Type get_Target();
    public void set_Target(Type value);
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
    public string get_VisualizerObjectSourceTypeName();
    public string get_VisualizerTypeName();
}
public class System.Diagnostics.DefaultTraceListener : TraceListener {
    public bool AssertUiEnabled { get; public set; }
    public string LogFileName { get; public set; }
    public bool get_AssertUiEnabled();
    public void set_AssertUiEnabled(bool value);
    public string get_LogFileName();
    public void set_LogFileName(string value);
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
}
public class System.Diagnostics.DelimitedListTraceListener : TextWriterTraceListener {
    public string Delimiter { get; public set; }
    public DelimitedListTraceListener(Stream stream);
    public DelimitedListTraceListener(Stream stream, string name);
    public DelimitedListTraceListener(TextWriter writer);
    public DelimitedListTraceListener(TextWriter writer, string name);
    public DelimitedListTraceListener(string fileName);
    public DelimitedListTraceListener(string fileName, string name);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    protected virtual String[] GetSupportedAttributes();
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
}
public class System.Diagnostics.EventTypeFilter : TraceFilter {
    public SourceLevels EventType { get; public set; }
    public EventTypeFilter(SourceLevels level);
    public SourceLevels get_EventType();
    public void set_EventType(SourceLevels value);
    public virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
}
public class System.Diagnostics.FileVersionInfo : object {
    public string Comments { get; }
    public string CompanyName { get; }
    public int FileBuildPart { get; }
    public string FileDescription { get; }
    public int FileMajorPart { get; }
    public int FileMinorPart { get; }
    public string FileName { get; }
    public int FilePrivatePart { get; }
    public string FileVersion { get; }
    public string InternalName { get; }
    public bool IsDebug { get; }
    public bool IsPatched { get; }
    public bool IsPreRelease { get; }
    public bool IsPrivateBuild { get; }
    public bool IsSpecialBuild { get; }
    public string Language { get; }
    public string LegalCopyright { get; }
    public string LegalTrademarks { get; }
    public string OriginalFilename { get; }
    public string PrivateBuild { get; }
    public int ProductBuildPart { get; }
    public int ProductMajorPart { get; }
    public int ProductMinorPart { get; }
    public string ProductName { get; }
    public int ProductPrivatePart { get; }
    public string ProductVersion { get; }
    public string SpecialBuild { get; }
    public string get_Comments();
    public string get_CompanyName();
    public int get_FileBuildPart();
    public string get_FileDescription();
    public int get_FileMajorPart();
    public int get_FileMinorPart();
    public string get_FileName();
    public int get_FilePrivatePart();
    public string get_FileVersion();
    public string get_InternalName();
    public bool get_IsDebug();
    public bool get_IsPatched();
    public bool get_IsPreRelease();
    public bool get_IsPrivateBuild();
    public bool get_IsSpecialBuild();
    public string get_Language();
    public string get_LegalCopyright();
    public string get_LegalTrademarks();
    public string get_OriginalFilename();
    public string get_PrivateBuild();
    public int get_ProductBuildPart();
    public int get_ProductMajorPart();
    public int get_ProductMinorPart();
    public string get_ProductName();
    public int get_ProductPrivatePart();
    public string get_ProductVersion();
    public string get_SpecialBuild();
    public static FileVersionInfo GetVersionInfo(string fileName);
    public virtual string ToString();
}
[AttributeUsageAttribute("32767")]
public class System.Diagnostics.MonitoringDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public MonitoringDescriptionAttribute(string description);
    public virtual string get_Description();
}
[DefaultEventAttribute("Exited")]
[DefaultPropertyAttribute("StartInfo")]
public class System.Diagnostics.Process : Component {
    [DesignerSerializationVisibilityAttribute("0")]
public int BasePriority { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("False")]
public bool EnableRaisingEvents { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int ExitCode { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DateTime ExitTime { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IntPtr Handle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public int HandleCount { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool HasExited { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public int Id { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public string MachineName { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ProcessModule MainModule { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public IntPtr MainWindowHandle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public string MainWindowTitle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public IntPtr MaxWorkingSet { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public IntPtr MinWorkingSet { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ProcessModuleCollection Modules { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int NonpagedSystemMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long NonpagedSystemMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int PagedMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long PagedMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int PagedSystemMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long PagedSystemMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int PeakPagedMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long PeakPagedMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int PeakVirtualMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long PeakVirtualMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int PeakWorkingSet { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long PeakWorkingSet64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool PriorityBoostEnabled { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public ProcessPriorityClass PriorityClass { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int PrivateMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long PrivateMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public TimeSpan PrivilegedProcessorTime { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public string ProcessName { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public IntPtr ProcessorAffinity { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool Responding { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public SafeProcessHandle SafeHandle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public int SessionId { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public StreamReader StandardError { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public StreamWriter StandardInput { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public StreamReader StandardOutput { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("2")]
public ProcessStartInfo StartInfo { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DateTime StartTime { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ProcessThreadCollection Threads { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public TimeSpan TotalProcessorTime { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public TimeSpan UserProcessorTime { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int VirtualMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long VirtualMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int WorkingSet { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public long WorkingSet64 { get; }
    public int get_BasePriority();
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public int get_ExitCode();
    public DateTime get_ExitTime();
    public IntPtr get_Handle();
    public int get_HandleCount();
    public bool get_HasExited();
    public int get_Id();
    public string get_MachineName();
    public ProcessModule get_MainModule();
    public IntPtr get_MainWindowHandle();
    public string get_MainWindowTitle();
    public IntPtr get_MaxWorkingSet();
    public void set_MaxWorkingSet(IntPtr value);
    public IntPtr get_MinWorkingSet();
    public void set_MinWorkingSet(IntPtr value);
    public ProcessModuleCollection get_Modules();
    public int get_NonpagedSystemMemorySize();
    public long get_NonpagedSystemMemorySize64();
    public int get_PagedMemorySize();
    public long get_PagedMemorySize64();
    public int get_PagedSystemMemorySize();
    public long get_PagedSystemMemorySize64();
    public int get_PeakPagedMemorySize();
    public long get_PeakPagedMemorySize64();
    public int get_PeakVirtualMemorySize();
    public long get_PeakVirtualMemorySize64();
    public int get_PeakWorkingSet();
    public long get_PeakWorkingSet64();
    public bool get_PriorityBoostEnabled();
    public void set_PriorityBoostEnabled(bool value);
    public ProcessPriorityClass get_PriorityClass();
    public void set_PriorityClass(ProcessPriorityClass value);
    public int get_PrivateMemorySize();
    public long get_PrivateMemorySize64();
    public TimeSpan get_PrivilegedProcessorTime();
    public string get_ProcessName();
    public IntPtr get_ProcessorAffinity();
    public void set_ProcessorAffinity(IntPtr value);
    public bool get_Responding();
    public SafeProcessHandle get_SafeHandle();
    public int get_SessionId();
    public StreamReader get_StandardError();
    public StreamWriter get_StandardInput();
    public StreamReader get_StandardOutput();
    public ProcessStartInfo get_StartInfo();
    public void set_StartInfo(ProcessStartInfo value);
    public DateTime get_StartTime();
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public ProcessThreadCollection get_Threads();
    public TimeSpan get_TotalProcessorTime();
    public TimeSpan get_UserProcessorTime();
    public int get_VirtualMemorySize();
    public long get_VirtualMemorySize64();
    public int get_WorkingSet();
    public long get_WorkingSet64();
    public void add_ErrorDataReceived(DataReceivedEventHandler value);
    public void remove_ErrorDataReceived(DataReceivedEventHandler value);
    public void add_Exited(EventHandler value);
    public void remove_Exited(EventHandler value);
    public void add_OutputDataReceived(DataReceivedEventHandler value);
    public void remove_OutputDataReceived(DataReceivedEventHandler value);
    public void BeginErrorReadLine();
    public void BeginOutputReadLine();
    public void CancelErrorRead();
    public void CancelOutputRead();
    public void Close();
    public bool CloseMainWindow();
    protected virtual void Dispose(bool disposing);
    public static void EnterDebugMode();
    public static Process GetCurrentProcess();
    public static Process GetProcessById(int processId);
    public static Process GetProcessById(int processId, string machineName);
    public static Process[] GetProcesses();
    public static Process[] GetProcesses(string machineName);
    public static Process[] GetProcessesByName(string processName);
    public static Process[] GetProcessesByName(string processName, string machineName);
    public void Kill();
    public static void LeaveDebugMode();
    protected void OnExited();
    public void Refresh();
    public bool Start();
    public static Process Start(ProcessStartInfo startInfo);
    public static Process Start(string fileName);
    public static Process Start(string fileName, string arguments);
    [CLSCompliantAttribute("False")]
public static Process Start(string fileName, string userName, SecureString password, string domain);
    [CLSCompliantAttribute("False")]
public static Process Start(string fileName, string arguments, string userName, SecureString password, string domain);
    public virtual string ToString();
    public void WaitForExit();
    public bool WaitForExit(int milliseconds);
    public bool WaitForInputIdle();
    public bool WaitForInputIdle(int milliseconds);
}
public class System.Diagnostics.ProcessModule : Component {
    public IntPtr BaseAddress { get; }
    public IntPtr EntryPointAddress { get; }
    public string FileName { get; }
    [BrowsableAttribute("False")]
public FileVersionInfo FileVersionInfo { get; }
    public int ModuleMemorySize { get; }
    public string ModuleName { get; }
    public IntPtr get_BaseAddress();
    public IntPtr get_EntryPointAddress();
    public string get_FileName();
    public FileVersionInfo get_FileVersionInfo();
    public int get_ModuleMemorySize();
    public string get_ModuleName();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.ProcessModuleCollection : ReadOnlyCollectionBase {
    public ProcessModule Item { get; }
    public ProcessModuleCollection(ProcessModule[] processModules);
    public ProcessModule get_Item(int index);
    public bool Contains(ProcessModule module);
    public void CopyTo(ProcessModule[] array, int index);
    public int IndexOf(ProcessModule module);
}
public enum System.Diagnostics.ProcessPriorityClass : Enum {
    public int value__;
    public static ProcessPriorityClass AboveNormal;
    public static ProcessPriorityClass BelowNormal;
    public static ProcessPriorityClass High;
    public static ProcessPriorityClass Idle;
    public static ProcessPriorityClass Normal;
    public static ProcessPriorityClass RealTime;
}
public class System.Diagnostics.ProcessStartInfo : object {
    public Collection`1<string> ArgumentList { get; }
    [DefaultValueAttribute("")]
[NotifyParentPropertyAttribute("True")]
[SettingsBindableAttribute("True")]
public string Arguments { get; public set; }
    [DefaultValueAttribute("False")]
[NotifyParentPropertyAttribute("True")]
public bool CreateNoWindow { get; public set; }
    [NotifyParentPropertyAttribute("True")]
public string Domain { get; public set; }
    [DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("0")]
[NotifyParentPropertyAttribute("True")]
public IDictionary`2<string, string> Environment { get; }
    [DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("2")]
[NotifyParentPropertyAttribute("True")]
public StringDictionary EnvironmentVariables { get; }
    [DefaultValueAttribute("False")]
[NotifyParentPropertyAttribute("True")]
public bool ErrorDialog { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IntPtr ErrorDialogParentHandle { get; public set; }
    [DefaultValueAttribute("")]
[NotifyParentPropertyAttribute("True")]
[SettingsBindableAttribute("True")]
public string FileName { get; public set; }
    [NotifyParentPropertyAttribute("True")]
public bool LoadUserProfile { get; public set; }
    [CLSCompliantAttribute("False")]
public SecureString Password { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public string PasswordInClearText { get; public set; }
    [DefaultValueAttribute("False")]
[NotifyParentPropertyAttribute("True")]
public bool RedirectStandardError { get; public set; }
    [DefaultValueAttribute("False")]
[NotifyParentPropertyAttribute("True")]
public bool RedirectStandardInput { get; public set; }
    [DefaultValueAttribute("False")]
[NotifyParentPropertyAttribute("True")]
public bool RedirectStandardOutput { get; public set; }
    public Encoding StandardErrorEncoding { get; public set; }
    public Encoding StandardInputEncoding { get; public set; }
    public Encoding StandardOutputEncoding { get; public set; }
    [NotifyParentPropertyAttribute("True")]
public string UserName { get; public set; }
    [DefaultValueAttribute("True")]
[NotifyParentPropertyAttribute("True")]
public bool UseShellExecute { get; public set; }
    [DefaultValueAttribute("")]
[NotifyParentPropertyAttribute("True")]
public string Verb { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public String[] Verbs { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[NotifyParentPropertyAttribute("True")]
public ProcessWindowStyle WindowStyle { get; public set; }
    [DefaultValueAttribute("")]
[NotifyParentPropertyAttribute("True")]
[SettingsBindableAttribute("True")]
public string WorkingDirectory { get; public set; }
    public ProcessStartInfo(string fileName);
    public ProcessStartInfo(string fileName, string arguments);
    public Collection`1<string> get_ArgumentList();
    public string get_Arguments();
    public void set_Arguments(string value);
    public bool get_CreateNoWindow();
    public void set_CreateNoWindow(bool value);
    public string get_Domain();
    public void set_Domain(string value);
    public IDictionary`2<string, string> get_Environment();
    public StringDictionary get_EnvironmentVariables();
    public bool get_ErrorDialog();
    public void set_ErrorDialog(bool value);
    public IntPtr get_ErrorDialogParentHandle();
    public void set_ErrorDialogParentHandle(IntPtr value);
    public string get_FileName();
    public void set_FileName(string value);
    public bool get_LoadUserProfile();
    public void set_LoadUserProfile(bool value);
    public SecureString get_Password();
    public void set_Password(SecureString value);
    public string get_PasswordInClearText();
    public void set_PasswordInClearText(string value);
    public bool get_RedirectStandardError();
    public void set_RedirectStandardError(bool value);
    public bool get_RedirectStandardInput();
    public void set_RedirectStandardInput(bool value);
    public bool get_RedirectStandardOutput();
    public void set_RedirectStandardOutput(bool value);
    public Encoding get_StandardErrorEncoding();
    public void set_StandardErrorEncoding(Encoding value);
    public Encoding get_StandardInputEncoding();
    public void set_StandardInputEncoding(Encoding value);
    public Encoding get_StandardOutputEncoding();
    public void set_StandardOutputEncoding(Encoding value);
    public string get_UserName();
    public void set_UserName(string value);
    public bool get_UseShellExecute();
    public void set_UseShellExecute(bool value);
    public string get_Verb();
    public void set_Verb(string value);
    public String[] get_Verbs();
    public ProcessWindowStyle get_WindowStyle();
    public void set_WindowStyle(ProcessWindowStyle value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
}
public class System.Diagnostics.ProcessThread : Component {
    public int BasePriority { get; }
    public int CurrentPriority { get; }
    public int Id { get; }
    [BrowsableAttribute("False")]
unknown int IdealProcessor {public set; }
    public bool PriorityBoostEnabled { get; public set; }
    public ThreadPriorityLevel PriorityLevel { get; public set; }
    public TimeSpan PrivilegedProcessorTime { get; }
    [BrowsableAttribute("False")]
unknown IntPtr ProcessorAffinity {public set; }
    public IntPtr StartAddress { get; }
    public DateTime StartTime { get; }
    public ThreadState ThreadState { get; }
    public TimeSpan TotalProcessorTime { get; }
    public TimeSpan UserProcessorTime { get; }
    public ThreadWaitReason WaitReason { get; }
    public int get_BasePriority();
    public int get_CurrentPriority();
    public int get_Id();
    public void set_IdealProcessor(int value);
    public bool get_PriorityBoostEnabled();
    public void set_PriorityBoostEnabled(bool value);
    public ThreadPriorityLevel get_PriorityLevel();
    public void set_PriorityLevel(ThreadPriorityLevel value);
    public TimeSpan get_PrivilegedProcessorTime();
    public void set_ProcessorAffinity(IntPtr value);
    public IntPtr get_StartAddress();
    public DateTime get_StartTime();
    public ThreadState get_ThreadState();
    public TimeSpan get_TotalProcessorTime();
    public TimeSpan get_UserProcessorTime();
    public ThreadWaitReason get_WaitReason();
    public void ResetIdealProcessor();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.ProcessThreadCollection : ReadOnlyCollectionBase {
    public ProcessThread Item { get; }
    public ProcessThreadCollection(ProcessThread[] processThreads);
    public ProcessThread get_Item(int index);
    public int Add(ProcessThread thread);
    public bool Contains(ProcessThread thread);
    public void CopyTo(ProcessThread[] array, int index);
    public int IndexOf(ProcessThread thread);
    public void Insert(int index, ProcessThread thread);
    public void Remove(ProcessThread thread);
}
public enum System.Diagnostics.ProcessWindowStyle : Enum {
    public int value__;
    public static ProcessWindowStyle Hidden;
    public static ProcessWindowStyle Maximized;
    public static ProcessWindowStyle Minimized;
    public static ProcessWindowStyle Normal;
}
public class System.Diagnostics.SourceFilter : TraceFilter {
    public string Source { get; public set; }
    public SourceFilter(string source);
    public string get_Source();
    public void set_Source(string value);
    public virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
}
[FlagsAttribute]
public enum System.Diagnostics.SourceLevels : Enum {
    public int value__;
    [EditorBrowsableAttribute("2")]
public static SourceLevels ActivityTracing;
    public static SourceLevels All;
    public static SourceLevels Critical;
    public static SourceLevels Error;
    public static SourceLevels Information;
    public static SourceLevels Off;
    public static SourceLevels Verbose;
    public static SourceLevels Warning;
}
public class System.Diagnostics.SourceSwitch : Switch {
    public SourceLevels Level { get; public set; }
    public SourceSwitch(string name);
    public SourceSwitch(string displayName, string defaultSwitchValue);
    public SourceLevels get_Level();
    public void set_Level(SourceLevels value);
    protected virtual void OnValueChanged();
    public bool ShouldTrace(TraceEventType eventType);
}
public class System.Diagnostics.StackFrame : object {
    public static int OFFSET_UNKNOWN;
    public StackFrame(bool fNeedFileInfo);
    public StackFrame(int skipFrames);
    public StackFrame(int skipFrames, bool fNeedFileInfo);
    public StackFrame(string fileName, int lineNumber);
    public StackFrame(string fileName, int lineNumber, int colNumber);
    public virtual int GetFileColumnNumber();
    public virtual int GetFileLineNumber();
    public virtual string GetFileName();
    public virtual int GetILOffset();
    public virtual MethodBase GetMethod();
    public virtual int GetNativeOffset();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class System.Diagnostics.StackFrameExtensions : object {
    [ExtensionAttribute]
public static IntPtr GetNativeImageBase(StackFrame stackFrame);
    [ExtensionAttribute]
public static IntPtr GetNativeIP(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasILOffset(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasMethod(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasNativeImage(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasSource(StackFrame stackFrame);
}
public class System.Diagnostics.StackTrace : object {
    public static int METHODS_TO_SKIP;
    public int FrameCount { get; }
    public StackTrace(bool fNeedFileInfo);
    public StackTrace(StackFrame frame);
    public StackTrace(Exception e);
    public StackTrace(Exception e, bool fNeedFileInfo);
    public StackTrace(Exception e, int skipFrames);
    public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
    public StackTrace(int skipFrames);
    public StackTrace(int skipFrames, bool fNeedFileInfo);
    public virtual int get_FrameCount();
    public virtual StackFrame GetFrame(int index);
    public virtual StackFrame[] GetFrames();
    public virtual string ToString();
}
public class System.Diagnostics.Stopwatch : object {
    public static long Frequency;
    public static bool IsHighResolution;
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    public bool IsRunning { get; }
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    public bool get_IsRunning();
    public static long GetTimestamp();
    public void Reset();
    public void Restart();
    public void Start();
    public static Stopwatch StartNew();
    public void Stop();
}
public abstract class System.Diagnostics.Switch : object {
    public StringDictionary Attributes { get; }
    public string Description { get; }
    public string DisplayName { get; }
    protected int SwitchSetting { get; protected set; }
    protected string Value { get; protected set; }
    protected Switch(string displayName, string description);
    protected Switch(string displayName, string description, string defaultSwitchValue);
    public StringDictionary get_Attributes();
    public string get_Description();
    public string get_DisplayName();
    protected int get_SwitchSetting();
    protected void set_SwitchSetting(int value);
    protected string get_Value();
    protected void set_Value(string value);
    protected virtual String[] GetSupportedAttributes();
    protected virtual void OnSwitchSettingChanged();
    protected virtual void OnValueChanged();
}
[AttributeUsageAttribute("741")]
public class System.Diagnostics.SwitchAttribute : Attribute {
    public string SwitchDescription { get; public set; }
    public string SwitchName { get; public set; }
    public Type SwitchType { get; public set; }
    public SwitchAttribute(string switchName, Type switchType);
    public string get_SwitchDescription();
    public void set_SwitchDescription(string value);
    public string get_SwitchName();
    public void set_SwitchName(string value);
    public Type get_SwitchType();
    public void set_SwitchType(Type value);
    public static SwitchAttribute[] GetAll(Assembly assembly);
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.SwitchLevelAttribute : Attribute {
    public Type SwitchLevelType { get; public set; }
    public SwitchLevelAttribute(Type switchLevelType);
    public Type get_SwitchLevelType();
    public void set_SwitchLevelType(Type value);
}
public interface System.Diagnostics.SymbolStore.ISymbolBinder {
    [ObsoleteAttribute("The recommended alternative is ISymbolBinder1.GetReader. ISymbolBinder1.GetReader takes the importer interface pointer as an IntPtr instead of an Int32, and thus works on both 32-bit and 64-bit architectures. https://go.microsoft.com/fwlink/?linkid=14202=14202")]
public abstract virtual ISymbolReader GetReader(int importer, string filename, string searchPath);
}
public interface System.Diagnostics.SymbolStore.ISymbolBinder1 {
    public abstract virtual ISymbolReader GetReader(IntPtr importer, string filename, string searchPath);
}
public interface System.Diagnostics.SymbolStore.ISymbolDocument {
    public Guid CheckSumAlgorithmId { get; }
    public Guid DocumentType { get; }
    public bool HasEmbeddedSource { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public int SourceLength { get; }
    public string URL { get; }
    public abstract virtual Guid get_CheckSumAlgorithmId();
    public abstract virtual Guid get_DocumentType();
    public abstract virtual bool get_HasEmbeddedSource();
    public abstract virtual Guid get_Language();
    public abstract virtual Guid get_LanguageVendor();
    public abstract virtual int get_SourceLength();
    public abstract virtual string get_URL();
    public abstract virtual int FindClosestLine(int line);
    public abstract virtual Byte[] GetCheckSum();
    public abstract virtual Byte[] GetSourceRange(int startLine, int startColumn, int endLine, int endColumn);
}
public interface System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
    public abstract virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
    public abstract virtual void SetSource(Byte[] source);
}
public interface System.Diagnostics.SymbolStore.ISymbolMethod {
    public ISymbolScope RootScope { get; }
    public int SequencePointCount { get; }
    public SymbolToken Token { get; }
    public abstract virtual ISymbolScope get_RootScope();
    public abstract virtual int get_SequencePointCount();
    public abstract virtual SymbolToken get_Token();
    public abstract virtual ISymbolNamespace GetNamespace();
    public abstract virtual int GetOffset(ISymbolDocument document, int line, int column);
    public abstract virtual ISymbolVariable[] GetParameters();
    public abstract virtual Int32[] GetRanges(ISymbolDocument document, int line, int column);
    public abstract virtual ISymbolScope GetScope(int offset);
    public abstract virtual void GetSequencePoints(Int32[] offsets, ISymbolDocument[] documents, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual bool GetSourceStartEnd(ISymbolDocument[] docs, Int32[] lines, Int32[] columns);
}
public interface System.Diagnostics.SymbolStore.ISymbolNamespace {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual ISymbolNamespace[] GetNamespaces();
    public abstract virtual ISymbolVariable[] GetVariables();
}
public interface System.Diagnostics.SymbolStore.ISymbolReader {
    public SymbolToken UserEntryPoint { get; }
    public abstract virtual SymbolToken get_UserEntryPoint();
    public abstract virtual ISymbolDocument GetDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual ISymbolDocument[] GetDocuments();
    public abstract virtual ISymbolVariable[] GetGlobalVariables();
    public abstract virtual ISymbolMethod GetMethod(SymbolToken method);
    public abstract virtual ISymbolMethod GetMethod(SymbolToken method, int version);
    public abstract virtual ISymbolMethod GetMethodFromDocumentPosition(ISymbolDocument document, int line, int column);
    public abstract virtual ISymbolNamespace[] GetNamespaces();
    public abstract virtual Byte[] GetSymAttribute(SymbolToken parent, string name);
    public abstract virtual ISymbolVariable[] GetVariables(SymbolToken parent);
}
public interface System.Diagnostics.SymbolStore.ISymbolScope {
    public int EndOffset { get; }
    public ISymbolMethod Method { get; }
    public ISymbolScope Parent { get; }
    public int StartOffset { get; }
    public abstract virtual int get_EndOffset();
    public abstract virtual ISymbolMethod get_Method();
    public abstract virtual ISymbolScope get_Parent();
    public abstract virtual int get_StartOffset();
    public abstract virtual ISymbolScope[] GetChildren();
    public abstract virtual ISymbolVariable[] GetLocals();
    public abstract virtual ISymbolNamespace[] GetNamespaces();
}
public interface System.Diagnostics.SymbolStore.ISymbolVariable {
    public int AddressField1 { get; }
    public int AddressField2 { get; }
    public int AddressField3 { get; }
    public SymAddressKind AddressKind { get; }
    public object Attributes { get; }
    public int EndOffset { get; }
    public string Name { get; }
    public int StartOffset { get; }
    public abstract virtual int get_AddressField1();
    public abstract virtual int get_AddressField2();
    public abstract virtual int get_AddressField3();
    public abstract virtual SymAddressKind get_AddressKind();
    public abstract virtual object get_Attributes();
    public abstract virtual int get_EndOffset();
    public abstract virtual string get_Name();
    public abstract virtual int get_StartOffset();
    public abstract virtual Byte[] GetSignature();
}
public interface System.Diagnostics.SymbolStore.ISymbolWriter {
    public abstract virtual void Close();
    public abstract virtual void CloseMethod();
    public abstract virtual void CloseNamespace();
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual void DefineField(SymbolToken parent, string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void DefineGlobalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public abstract virtual void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual void Initialize(IntPtr emitter, string filename, bool fFullBuild);
    public abstract virtual void OpenMethod(SymbolToken method);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual int OpenScope(int startOffset);
    public abstract virtual void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn);
    public abstract virtual void SetScopeRange(int scopeID, int startOffset, int endOffset);
    public abstract virtual void SetSymAttribute(SymbolToken parent, string name, Byte[] data);
    public abstract virtual void SetUnderlyingWriter(IntPtr underlyingWriter);
    public abstract virtual void SetUserEntryPoint(SymbolToken entryMethod);
    public abstract virtual void UsingNamespace(string fullName);
}
public enum System.Diagnostics.SymbolStore.SymAddressKind : Enum {
    public int value__;
    public static SymAddressKind BitField;
    public static SymAddressKind ILOffset;
    public static SymAddressKind NativeOffset;
    public static SymAddressKind NativeRegister;
    public static SymAddressKind NativeRegisterRegister;
    public static SymAddressKind NativeRegisterRelative;
    public static SymAddressKind NativeRegisterStack;
    public static SymAddressKind NativeRVA;
    public static SymAddressKind NativeSectionOffset;
    public static SymAddressKind NativeStackRegister;
}
[IsReadOnlyAttribute]
public class System.Diagnostics.SymbolStore.SymbolToken : ValueType {
    private object _dummy;
    public SymbolToken(int val);
    public bool Equals(SymbolToken obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int GetToken();
    public static bool op_Equality(SymbolToken a, SymbolToken b);
    public static bool op_Inequality(SymbolToken a, SymbolToken b);
}
public class System.Diagnostics.SymbolStore.SymDocumentType : object {
    public static Guid Text;
}
public class System.Diagnostics.SymbolStore.SymLanguageType : object {
    public static Guid Basic;
    public static Guid C;
    public static Guid Cobol;
    public static Guid CPlusPlus;
    public static Guid CSharp;
    public static Guid ILAssembly;
    public static Guid Java;
    public static Guid JScript;
    public static Guid MCPlusPlus;
    public static Guid Pascal;
    public static Guid SMC;
}
public class System.Diagnostics.SymbolStore.SymLanguageVendor : object {
    public static Guid Microsoft;
}
public class System.Diagnostics.TextWriterTraceListener : TraceListener {
    public TextWriter Writer { get; public set; }
    public TextWriterTraceListener(Stream stream);
    public TextWriterTraceListener(Stream stream, string name);
    public TextWriterTraceListener(TextWriter writer);
    public TextWriterTraceListener(TextWriter writer, string name);
    public TextWriterTraceListener(string fileName);
    public TextWriterTraceListener(string fileName, string name);
    public TextWriter get_Writer();
    public void set_Writer(TextWriter value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
}
public enum System.Diagnostics.ThreadPriorityLevel : Enum {
    public int value__;
    public static ThreadPriorityLevel AboveNormal;
    public static ThreadPriorityLevel BelowNormal;
    public static ThreadPriorityLevel Highest;
    public static ThreadPriorityLevel Idle;
    public static ThreadPriorityLevel Lowest;
    public static ThreadPriorityLevel Normal;
    public static ThreadPriorityLevel TimeCritical;
}
public enum System.Diagnostics.ThreadState : Enum {
    public int value__;
    public static ThreadState Initialized;
    public static ThreadState Ready;
    public static ThreadState Running;
    public static ThreadState Standby;
    public static ThreadState Terminated;
    public static ThreadState Transition;
    public static ThreadState Unknown;
    public static ThreadState Wait;
}
public enum System.Diagnostics.ThreadWaitReason : Enum {
    public int value__;
    public static ThreadWaitReason EventPairHigh;
    public static ThreadWaitReason EventPairLow;
    public static ThreadWaitReason ExecutionDelay;
    public static ThreadWaitReason Executive;
    public static ThreadWaitReason FreePage;
    public static ThreadWaitReason LpcReceive;
    public static ThreadWaitReason LpcReply;
    public static ThreadWaitReason PageIn;
    public static ThreadWaitReason PageOut;
    public static ThreadWaitReason Suspended;
    public static ThreadWaitReason SystemAllocation;
    public static ThreadWaitReason Unknown;
    public static ThreadWaitReason UserRequest;
    public static ThreadWaitReason VirtualMemory;
}
public class System.Diagnostics.Trace : object {
    public static bool AutoFlush { get; public set; }
    public static CorrelationManager CorrelationManager { get; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    public static TraceListenerCollection Listeners { get; }
    public static bool UseGlobalLock { get; public set; }
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static CorrelationManager get_CorrelationManager();
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    public static TraceListenerCollection get_Listeners();
    public static bool get_UseGlobalLock();
    public static void set_UseGlobalLock(bool value);
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition);
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("TRACE")]
public static void Close();
    [ConditionalAttribute("TRACE")]
public static void Fail(string message);
    [ConditionalAttribute("TRACE")]
public static void Fail(string message, string detailMessage);
    [ConditionalAttribute("TRACE")]
public static void Flush();
    [ConditionalAttribute("TRACE")]
public static void Indent();
    public static void Refresh();
    [ConditionalAttribute("TRACE")]
public static void TraceError(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceError(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void TraceInformation(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceInformation(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void TraceWarning(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceWarning(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void Unindent();
    [ConditionalAttribute("TRACE")]
public static void Write(object value);
    [ConditionalAttribute("TRACE")]
public static void Write(object value, string category);
    [ConditionalAttribute("TRACE")]
public static void Write(string message);
    [ConditionalAttribute("TRACE")]
public static void Write(string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(object value);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(string message);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, string message, string category);
}
public class System.Diagnostics.TraceEventCache : object {
    public string Callstack { get; }
    public DateTime DateTime { get; }
    public Stack LogicalOperationStack { get; }
    public int ProcessId { get; }
    public string ThreadId { get; }
    public long Timestamp { get; }
    public string get_Callstack();
    public DateTime get_DateTime();
    public Stack get_LogicalOperationStack();
    public int get_ProcessId();
    public string get_ThreadId();
    public long get_Timestamp();
}
public enum System.Diagnostics.TraceEventType : Enum {
    public int value__;
    public static TraceEventType Critical;
    public static TraceEventType Error;
    public static TraceEventType Information;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Resume;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Start;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Stop;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Suspend;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Transfer;
    public static TraceEventType Verbose;
    public static TraceEventType Warning;
}
public abstract class System.Diagnostics.TraceFilter : object {
    public abstract virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
}
public enum System.Diagnostics.TraceLevel : Enum {
    public int value__;
    public static TraceLevel Error;
    public static TraceLevel Info;
    public static TraceLevel Off;
    public static TraceLevel Verbose;
    public static TraceLevel Warning;
}
public abstract class System.Diagnostics.TraceListener : MarshalByRefObject {
    public StringDictionary Attributes { get; }
    public TraceFilter Filter { get; public set; }
    public int IndentLevel { get; public set; }
    public int IndentSize { get; public set; }
    public bool IsThreadSafe { get; }
    public string Name { get; public set; }
    protected bool NeedIndent { get; protected set; }
    public TraceOptions TraceOutputOptions { get; public set; }
    protected TraceListener(string name);
    public StringDictionary get_Attributes();
    public TraceFilter get_Filter();
    public void set_Filter(TraceFilter value);
    public int get_IndentLevel();
    public void set_IndentLevel(int value);
    public int get_IndentSize();
    public void set_IndentSize(int value);
    public virtual bool get_IsThreadSafe();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    protected bool get_NeedIndent();
    protected void set_NeedIndent(bool value);
    public TraceOptions get_TraceOutputOptions();
    public void set_TraceOutputOptions(TraceOptions value);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    public virtual void Flush();
    protected virtual String[] GetSupportedAttributes();
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    public virtual void Write(object o);
    public virtual void Write(object o, string category);
    public abstract virtual void Write(string message);
    public virtual void Write(string message, string category);
    protected virtual void WriteIndent();
    public virtual void WriteLine(object o);
    public virtual void WriteLine(object o, string category);
    public abstract virtual void WriteLine(string message);
    public virtual void WriteLine(string message, string category);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.TraceListenerCollection : object {
    public int Count { get; }
    public TraceListener Item { get; public set; }
    public TraceListener Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public TraceListener get_Item(int i);
    public void set_Item(int i, TraceListener value);
    public TraceListener get_Item(string name);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(TraceListener listener);
    public void AddRange(TraceListenerCollection value);
    public void AddRange(TraceListener[] value);
    public sealed virtual void Clear();
    public bool Contains(TraceListener listener);
    public void CopyTo(TraceListener[] listeners, int index);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(TraceListener listener);
    public void Insert(int index, TraceListener listener);
    public void Remove(TraceListener listener);
    public void Remove(string name);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[FlagsAttribute]
public enum System.Diagnostics.TraceOptions : Enum {
    public int value__;
    public static TraceOptions Callstack;
    public static TraceOptions DateTime;
    public static TraceOptions LogicalOperationStack;
    public static TraceOptions None;
    public static TraceOptions ProcessId;
    public static TraceOptions ThreadId;
    public static TraceOptions Timestamp;
}
public class System.Diagnostics.TraceSource : object {
    public StringDictionary Attributes { get; }
    public TraceListenerCollection Listeners { get; }
    public string Name { get; }
    public SourceSwitch Switch { get; public set; }
    public TraceSource(string name);
    public TraceSource(string name, SourceLevels defaultLevel);
    public StringDictionary get_Attributes();
    public TraceListenerCollection get_Listeners();
    public string get_Name();
    public SourceSwitch get_Switch();
    public void set_Switch(SourceSwitch value);
    public void Close();
    public void Flush();
    protected virtual String[] GetSupportedAttributes();
    [ConditionalAttribute("TRACE")]
public void TraceData(TraceEventType eventType, int id, object data);
    [ConditionalAttribute("TRACE")]
public void TraceData(TraceEventType eventType, int id, Object[] data);
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id);
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id, string message);
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public void TraceInformation(string message);
    [ConditionalAttribute("TRACE")]
public void TraceInformation(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public void TraceTransfer(int id, string message, Guid relatedActivityId);
}
[SwitchLevelAttribute("System.Diagnostics.TraceLevel")]
public class System.Diagnostics.TraceSwitch : Switch {
    public TraceLevel Level { get; public set; }
    public bool TraceError { get; }
    public bool TraceInfo { get; }
    public bool TraceVerbose { get; }
    public bool TraceWarning { get; }
    public TraceSwitch(string displayName, string description);
    public TraceSwitch(string displayName, string description, string defaultSwitchValue);
    public TraceLevel get_Level();
    public void set_Level(TraceLevel value);
    public bool get_TraceError();
    public bool get_TraceInfo();
    public bool get_TraceVerbose();
    public bool get_TraceWarning();
    protected virtual void OnSwitchSettingChanged();
    protected virtual void OnValueChanged();
}
public abstract class System.Diagnostics.Tracing.DiagnosticCounter : object {
    public string DisplayName { get; public set; }
    public string DisplayUnits { get; public set; }
    public EventSource EventSource { get; }
    public string Name { get; }
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_DisplayUnits();
    public void set_DisplayUnits(string value);
    public EventSource get_EventSource();
    public string get_Name();
    public void AddMetadata(string key, string value);
    public sealed virtual void Dispose();
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions Detachable;
    public static EventActivityOptions Disable;
    public static EventActivityOptions None;
    public static EventActivityOptions Recursive;
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventChannel Channel { get; public set; }
    public int EventId { get; }
    public EventKeywords Keywords { get; public set; }
    public EventLevel Level { get; public set; }
    public string Message { get; public set; }
    public EventOpcode Opcode { get; public set; }
    public EventTags Tags { get; public set; }
    public EventTask Task { get; public set; }
    public byte Version { get; public set; }
    public EventAttribute(int eventId);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
    public EventChannel get_Channel();
    public void set_Channel(EventChannel value);
    public int get_EventId();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public string get_Message();
    public void set_Message(string value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventTask get_Task();
    public void set_Task(EventTask value);
    public byte get_Version();
    public void set_Version(byte value);
}
public enum System.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel Admin;
    public static EventChannel Analytic;
    public static EventChannel Debug;
    public static EventChannel None;
    public static EventChannel Operational;
}
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Disable;
    public static EventCommand Enable;
    public static EventCommand SendManifest;
    public static EventCommand Update;
}
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    public IDictionary`2<string, string> Arguments { get; }
    public EventCommand Command { get; }
    public IDictionary`2<string, string> get_Arguments();
    public EventCommand get_Command();
    public bool DisableEvent(int eventId);
    public bool EnableEvent(int eventId);
}
public class System.Diagnostics.Tracing.EventCounter : DiagnosticCounter {
    public EventCounter(string name, EventSource eventSource);
    public virtual string ToString();
    public void WriteMetric(double value);
    public void WriteMetric(float value);
}
[AttributeUsageAttribute("12")]
public class System.Diagnostics.Tracing.EventDataAttribute : Attribute {
    public string Name { get; public set; }
    public string get_Name();
    public void set_Name(string value);
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    public EventFieldFormat Format { get; public set; }
    public EventFieldTags Tags { get; public set; }
    public EventFieldFormat get_Format();
    public void set_Format(EventFieldFormat value);
    public EventFieldTags get_Tags();
    public void set_Tags(EventFieldTags value);
}
public enum System.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Default;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat HResult;
    public static EventFieldFormat Json;
    public static EventFieldFormat String;
    public static EventFieldFormat Xml;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords All;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
    public static EventKeywords MicrosoftTelemetry;
    public static EventKeywords None;
    public static EventKeywords Sqm;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
}
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Informational;
    public static EventLevel LogAlways;
    public static EventLevel Verbose;
    public static EventLevel Warning;
}
public abstract class System.Diagnostics.Tracing.EventListener : object {
    public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public void DisableEvents(EventSource eventSource);
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    protected static int EventSourceIndex(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions AllowEventSourceOverride;
    public static EventManifestOptions None;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions Strict;
}
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Info;
    public static EventOpcode Receive;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Send;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode Suspend;
}
public class System.Diagnostics.Tracing.EventSource : object {
    public Exception ConstructionException { get; }
    public static Guid CurrentThreadActivityId { get; }
    public Guid Guid { get; }
    public string Name { get; }
    public EventSourceSettings Settings { get; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    public EventSource(string eventSourceName);
    public EventSource(string eventSourceName, EventSourceSettings config);
    public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    public Exception get_ConstructionException();
    public static Guid get_CurrentThreadActivityId();
    public Guid get_Guid();
    public string get_Name();
    public EventSourceSettings get_Settings();
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    public static Guid GetGuid(Type eventSourceType);
    public static string GetName(Type eventSourceType);
    public static IEnumerable`1<EventSource> GetSources();
    public string GetTrait(string key);
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    public static void SetCurrentThreadActivityId(Guid activityId);
    public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    public virtual string ToString();
    public void Write(string eventName);
    public void Write(string eventName, EventSourceOptions options);
    protected void WriteEvent(int eventId);
    protected void WriteEvent(int eventId, Byte[] arg1);
    protected void WriteEvent(int eventId, int arg1);
    protected void WriteEvent(int eventId, int arg1, int arg2);
    protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, int arg1, string arg2);
    protected void WriteEvent(int eventId, long arg1);
    protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    protected void WriteEvent(int eventId, long arg1, string arg2);
    protected void WriteEvent(int eventId, Object[] args);
    protected void WriteEvent(int eventId, string arg1);
    protected void WriteEvent(int eventId, string arg1, int arg2);
    protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, string arg1, long arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    [CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    [CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    public void Write(string eventName, EventSourceOptions& options, T& data);
    public void Write(string eventName, T data);
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    public string Name { get; public set; }
    public string get_Guid();
    public void set_Guid(string value);
    public string get_LocalizationResources();
    public void set_LocalizationResources(string value);
    public string get_Name();
    public void set_Name(string value);
}
public class System.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    public EventSource EventSource { get; }
    public EventSource get_EventSource();
}
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    protected EventSourceException(SerializationInfo info, StreamingContext context);
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
}
public class System.Diagnostics.Tracing.EventSourceOptions : ValueType {
    private int _dummyPrimitive;
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
    public static EventSourceSettings ThrowOnEventWriteErrors;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    public Guid ActivityId { get; }
    public EventChannel Channel { get; }
    public int EventId { get; }
    public string EventName { get; }
    public EventSource EventSource { get; }
    public EventKeywords Keywords { get; }
    public EventLevel Level { get; }
    public string Message { get; }
    public EventOpcode Opcode { get; }
    public long OSThreadId { get; }
    public ReadOnlyCollection`1<object> Payload { get; }
    public ReadOnlyCollection`1<string> PayloadNames { get; }
    public Guid RelatedActivityId { get; }
    public EventTags Tags { get; }
    public EventTask Task { get; }
    public DateTime TimeStamp { get; }
    public byte Version { get; }
    public Guid get_ActivityId();
    public EventChannel get_Channel();
    public int get_EventId();
    public string get_EventName();
    public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    public EventLevel get_Level();
    public string get_Message();
    public EventOpcode get_Opcode();
    public long get_OSThreadId();
    public ReadOnlyCollection`1<object> get_Payload();
    public ReadOnlyCollection`1<string> get_PayloadNames();
    public Guid get_RelatedActivityId();
    public EventTags get_Tags();
    public EventTask get_Task();
    public DateTime get_TimeStamp();
    public byte get_Version();
}
public class System.Diagnostics.Tracing.IncrementingEventCounter : DiagnosticCounter {
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingEventCounter(string name, EventSource eventSource);
    public TimeSpan get_DisplayRateTimeScale();
    public void set_DisplayRateTimeScale(TimeSpan value);
    public void Increment(double increment);
    public virtual string ToString();
}
public class System.Diagnostics.Tracing.IncrementingPollingCounter : DiagnosticCounter {
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingPollingCounter(string name, EventSource eventSource, Func`1<double> totalValueProvider);
    public TimeSpan get_DisplayRateTimeScale();
    public void set_DisplayRateTimeScale(TimeSpan value);
    public virtual string ToString();
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
public class System.Diagnostics.Tracing.PollingCounter : DiagnosticCounter {
    public PollingCounter(string name, EventSource eventSource, Func`1<double> metricProvider);
    public virtual string ToString();
}
public class System.DivideByZeroException : ArithmeticException {
    protected DivideByZeroException(SerializationInfo info, StreamingContext context);
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
}
public class System.DllNotFoundException : TypeLoadException {
    protected DllNotFoundException(SerializationInfo info, StreamingContext context);
    public DllNotFoundException(string message);
    public DllNotFoundException(string message, Exception inner);
}
[IsReadOnlyAttribute]
public class System.Double : ValueType {
    private double _dummyPrimitive;
    public static double Epsilon;
    public static double MaxValue;
    public static double MinValue;
    public static double NaN;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public sealed virtual int CompareTo(double value);
    public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(double obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static bool IsFinite(double d);
    public static bool IsInfinity(double d);
    public static bool IsNaN(double d);
    public static bool IsNegative(double d);
    public static bool IsNegativeInfinity(double d);
    public static bool IsNormal(double d);
    public static bool IsPositiveInfinity(double d);
    public static bool IsSubnormal(double d);
    public static bool op_Equality(double left, double right);
    public static bool op_GreaterThan(double left, double right);
    public static bool op_GreaterThanOrEqual(double left, double right);
    public static bool op_Inequality(double left, double right);
    public static bool op_LessThan(double left, double right);
    public static bool op_LessThanOrEqual(double left, double right);
    public static double Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static double Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Double& result);
    public static bool TryParse(string s, Double& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
}
[IsReadOnlyAttribute]
public class System.Drawing.Color : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static Color Empty;
    public byte A { get; }
    public static Color AliceBlue { get; }
    public static Color AntiqueWhite { get; }
    public static Color Aqua { get; }
    public static Color Aquamarine { get; }
    public static Color Azure { get; }
    public byte B { get; }
    public static Color Beige { get; }
    public static Color Bisque { get; }
    public static Color Black { get; }
    public static Color BlanchedAlmond { get; }
    public static Color Blue { get; }
    public static Color BlueViolet { get; }
    public static Color Brown { get; }
    public static Color BurlyWood { get; }
    public static Color CadetBlue { get; }
    public static Color Chartreuse { get; }
    public static Color Chocolate { get; }
    public static Color Coral { get; }
    public static Color CornflowerBlue { get; }
    public static Color Cornsilk { get; }
    public static Color Crimson { get; }
    public static Color Cyan { get; }
    public static Color DarkBlue { get; }
    public static Color DarkCyan { get; }
    public static Color DarkGoldenrod { get; }
    public static Color DarkGray { get; }
    public static Color DarkGreen { get; }
    public static Color DarkKhaki { get; }
    public static Color DarkMagenta { get; }
    public static Color DarkOliveGreen { get; }
    public static Color DarkOrange { get; }
    public static Color DarkOrchid { get; }
    public static Color DarkRed { get; }
    public static Color DarkSalmon { get; }
    public static Color DarkSeaGreen { get; }
    public static Color DarkSlateBlue { get; }
    public static Color DarkSlateGray { get; }
    public static Color DarkTurquoise { get; }
    public static Color DarkViolet { get; }
    public static Color DeepPink { get; }
    public static Color DeepSkyBlue { get; }
    public static Color DimGray { get; }
    public static Color DodgerBlue { get; }
    public static Color Firebrick { get; }
    public static Color FloralWhite { get; }
    public static Color ForestGreen { get; }
    public static Color Fuchsia { get; }
    public byte G { get; }
    public static Color Gainsboro { get; }
    public static Color GhostWhite { get; }
    public static Color Gold { get; }
    public static Color Goldenrod { get; }
    public static Color Gray { get; }
    public static Color Green { get; }
    public static Color GreenYellow { get; }
    public static Color Honeydew { get; }
    public static Color HotPink { get; }
    public static Color IndianRed { get; }
    public static Color Indigo { get; }
    public bool IsEmpty { get; }
    public bool IsKnownColor { get; }
    public bool IsNamedColor { get; }
    public bool IsSystemColor { get; }
    public static Color Ivory { get; }
    public static Color Khaki { get; }
    public static Color Lavender { get; }
    public static Color LavenderBlush { get; }
    public static Color LawnGreen { get; }
    public static Color LemonChiffon { get; }
    public static Color LightBlue { get; }
    public static Color LightCoral { get; }
    public static Color LightCyan { get; }
    public static Color LightGoldenrodYellow { get; }
    public static Color LightGray { get; }
    public static Color LightGreen { get; }
    public static Color LightPink { get; }
    public static Color LightSalmon { get; }
    public static Color LightSeaGreen { get; }
    public static Color LightSkyBlue { get; }
    public static Color LightSlateGray { get; }
    public static Color LightSteelBlue { get; }
    public static Color LightYellow { get; }
    public static Color Lime { get; }
    public static Color LimeGreen { get; }
    public static Color Linen { get; }
    public static Color Magenta { get; }
    public static Color Maroon { get; }
    public static Color MediumAquamarine { get; }
    public static Color MediumBlue { get; }
    public static Color MediumOrchid { get; }
    public static Color MediumPurple { get; }
    public static Color MediumSeaGreen { get; }
    public static Color MediumSlateBlue { get; }
    public static Color MediumSpringGreen { get; }
    public static Color MediumTurquoise { get; }
    public static Color MediumVioletRed { get; }
    public static Color MidnightBlue { get; }
    public static Color MintCream { get; }
    public static Color MistyRose { get; }
    public static Color Moccasin { get; }
    public string Name { get; }
    public static Color NavajoWhite { get; }
    public static Color Navy { get; }
    public static Color OldLace { get; }
    public static Color Olive { get; }
    public static Color OliveDrab { get; }
    public static Color Orange { get; }
    public static Color OrangeRed { get; }
    public static Color Orchid { get; }
    public static Color PaleGoldenrod { get; }
    public static Color PaleGreen { get; }
    public static Color PaleTurquoise { get; }
    public static Color PaleVioletRed { get; }
    public static Color PapayaWhip { get; }
    public static Color PeachPuff { get; }
    public static Color Peru { get; }
    public static Color Pink { get; }
    public static Color Plum { get; }
    public static Color PowderBlue { get; }
    public static Color Purple { get; }
    public byte R { get; }
    public static Color Red { get; }
    public static Color RosyBrown { get; }
    public static Color RoyalBlue { get; }
    public static Color SaddleBrown { get; }
    public static Color Salmon { get; }
    public static Color SandyBrown { get; }
    public static Color SeaGreen { get; }
    public static Color SeaShell { get; }
    public static Color Sienna { get; }
    public static Color Silver { get; }
    public static Color SkyBlue { get; }
    public static Color SlateBlue { get; }
    public static Color SlateGray { get; }
    public static Color Snow { get; }
    public static Color SpringGreen { get; }
    public static Color SteelBlue { get; }
    public static Color Tan { get; }
    public static Color Teal { get; }
    public static Color Thistle { get; }
    public static Color Tomato { get; }
    public static Color Transparent { get; }
    public static Color Turquoise { get; }
    public static Color Violet { get; }
    public static Color Wheat { get; }
    public static Color White { get; }
    public static Color WhiteSmoke { get; }
    public static Color Yellow { get; }
    public static Color YellowGreen { get; }
    public byte get_A();
    public static Color get_AliceBlue();
    public static Color get_AntiqueWhite();
    public static Color get_Aqua();
    public static Color get_Aquamarine();
    public static Color get_Azure();
    public byte get_B();
    public static Color get_Beige();
    public static Color get_Bisque();
    public static Color get_Black();
    public static Color get_BlanchedAlmond();
    public static Color get_Blue();
    public static Color get_BlueViolet();
    public static Color get_Brown();
    public static Color get_BurlyWood();
    public static Color get_CadetBlue();
    public static Color get_Chartreuse();
    public static Color get_Chocolate();
    public static Color get_Coral();
    public static Color get_CornflowerBlue();
    public static Color get_Cornsilk();
    public static Color get_Crimson();
    public static Color get_Cyan();
    public static Color get_DarkBlue();
    public static Color get_DarkCyan();
    public static Color get_DarkGoldenrod();
    public static Color get_DarkGray();
    public static Color get_DarkGreen();
    public static Color get_DarkKhaki();
    public static Color get_DarkMagenta();
    public static Color get_DarkOliveGreen();
    public static Color get_DarkOrange();
    public static Color get_DarkOrchid();
    public static Color get_DarkRed();
    public static Color get_DarkSalmon();
    public static Color get_DarkSeaGreen();
    public static Color get_DarkSlateBlue();
    public static Color get_DarkSlateGray();
    public static Color get_DarkTurquoise();
    public static Color get_DarkViolet();
    public static Color get_DeepPink();
    public static Color get_DeepSkyBlue();
    public static Color get_DimGray();
    public static Color get_DodgerBlue();
    public static Color get_Firebrick();
    public static Color get_FloralWhite();
    public static Color get_ForestGreen();
    public static Color get_Fuchsia();
    public byte get_G();
    public static Color get_Gainsboro();
    public static Color get_GhostWhite();
    public static Color get_Gold();
    public static Color get_Goldenrod();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_GreenYellow();
    public static Color get_Honeydew();
    public static Color get_HotPink();
    public static Color get_IndianRed();
    public static Color get_Indigo();
    public bool get_IsEmpty();
    public bool get_IsKnownColor();
    public bool get_IsNamedColor();
    public bool get_IsSystemColor();
    public static Color get_Ivory();
    public static Color get_Khaki();
    public static Color get_Lavender();
    public static Color get_LavenderBlush();
    public static Color get_LawnGreen();
    public static Color get_LemonChiffon();
    public static Color get_LightBlue();
    public static Color get_LightCoral();
    public static Color get_LightCyan();
    public static Color get_LightGoldenrodYellow();
    public static Color get_LightGray();
    public static Color get_LightGreen();
    public static Color get_LightPink();
    public static Color get_LightSalmon();
    public static Color get_LightSeaGreen();
    public static Color get_LightSkyBlue();
    public static Color get_LightSlateGray();
    public static Color get_LightSteelBlue();
    public static Color get_LightYellow();
    public static Color get_Lime();
    public static Color get_LimeGreen();
    public static Color get_Linen();
    public static Color get_Magenta();
    public static Color get_Maroon();
    public static Color get_MediumAquamarine();
    public static Color get_MediumBlue();
    public static Color get_MediumOrchid();
    public static Color get_MediumPurple();
    public static Color get_MediumSeaGreen();
    public static Color get_MediumSlateBlue();
    public static Color get_MediumSpringGreen();
    public static Color get_MediumTurquoise();
    public static Color get_MediumVioletRed();
    public static Color get_MidnightBlue();
    public static Color get_MintCream();
    public static Color get_MistyRose();
    public static Color get_Moccasin();
    public string get_Name();
    public static Color get_NavajoWhite();
    public static Color get_Navy();
    public static Color get_OldLace();
    public static Color get_Olive();
    public static Color get_OliveDrab();
    public static Color get_Orange();
    public static Color get_OrangeRed();
    public static Color get_Orchid();
    public static Color get_PaleGoldenrod();
    public static Color get_PaleGreen();
    public static Color get_PaleTurquoise();
    public static Color get_PaleVioletRed();
    public static Color get_PapayaWhip();
    public static Color get_PeachPuff();
    public static Color get_Peru();
    public static Color get_Pink();
    public static Color get_Plum();
    public static Color get_PowderBlue();
    public static Color get_Purple();
    public byte get_R();
    public static Color get_Red();
    public static Color get_RosyBrown();
    public static Color get_RoyalBlue();
    public static Color get_SaddleBrown();
    public static Color get_Salmon();
    public static Color get_SandyBrown();
    public static Color get_SeaGreen();
    public static Color get_SeaShell();
    public static Color get_Sienna();
    public static Color get_Silver();
    public static Color get_SkyBlue();
    public static Color get_SlateBlue();
    public static Color get_SlateGray();
    public static Color get_Snow();
    public static Color get_SpringGreen();
    public static Color get_SteelBlue();
    public static Color get_Tan();
    public static Color get_Teal();
    public static Color get_Thistle();
    public static Color get_Tomato();
    public static Color get_Transparent();
    public static Color get_Turquoise();
    public static Color get_Violet();
    public static Color get_Wheat();
    public static Color get_White();
    public static Color get_WhiteSmoke();
    public static Color get_Yellow();
    public static Color get_YellowGreen();
    public sealed virtual bool Equals(Color other);
    public virtual bool Equals(object obj);
    public static Color FromArgb(int argb);
    public static Color FromArgb(int alpha, Color baseColor);
    public static Color FromArgb(int red, int green, int blue);
    public static Color FromArgb(int alpha, int red, int green, int blue);
    public static Color FromKnownColor(KnownColor color);
    public static Color FromName(string name);
    public float GetBrightness();
    public virtual int GetHashCode();
    public float GetHue();
    public float GetSaturation();
    public static bool op_Equality(Color left, Color right);
    public static bool op_Inequality(Color left, Color right);
    public int ToArgb();
    public KnownColor ToKnownColor();
    public virtual string ToString();
}
public class System.Drawing.ColorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public enum System.Drawing.KnownColor : Enum {
    public int value__;
    public static KnownColor ActiveBorder;
    public static KnownColor ActiveCaption;
    public static KnownColor ActiveCaptionText;
    public static KnownColor AliceBlue;
    public static KnownColor AntiqueWhite;
    public static KnownColor AppWorkspace;
    public static KnownColor Aqua;
    public static KnownColor Aquamarine;
    public static KnownColor Azure;
    public static KnownColor Beige;
    public static KnownColor Bisque;
    public static KnownColor Black;
    public static KnownColor BlanchedAlmond;
    public static KnownColor Blue;
    public static KnownColor BlueViolet;
    public static KnownColor Brown;
    public static KnownColor BurlyWood;
    public static KnownColor ButtonFace;
    public static KnownColor ButtonHighlight;
    public static KnownColor ButtonShadow;
    public static KnownColor CadetBlue;
    public static KnownColor Chartreuse;
    public static KnownColor Chocolate;
    public static KnownColor Control;
    public static KnownColor ControlDark;
    public static KnownColor ControlDarkDark;
    public static KnownColor ControlLight;
    public static KnownColor ControlLightLight;
    public static KnownColor ControlText;
    public static KnownColor Coral;
    public static KnownColor CornflowerBlue;
    public static KnownColor Cornsilk;
    public static KnownColor Crimson;
    public static KnownColor Cyan;
    public static KnownColor DarkBlue;
    public static KnownColor DarkCyan;
    public static KnownColor DarkGoldenrod;
    public static KnownColor DarkGray;
    public static KnownColor DarkGreen;
    public static KnownColor DarkKhaki;
    public static KnownColor DarkMagenta;
    public static KnownColor DarkOliveGreen;
    public static KnownColor DarkOrange;
    public static KnownColor DarkOrchid;
    public static KnownColor DarkRed;
    public static KnownColor DarkSalmon;
    public static KnownColor DarkSeaGreen;
    public static KnownColor DarkSlateBlue;
    public static KnownColor DarkSlateGray;
    public static KnownColor DarkTurquoise;
    public static KnownColor DarkViolet;
    public static KnownColor DeepPink;
    public static KnownColor DeepSkyBlue;
    public static KnownColor Desktop;
    public static KnownColor DimGray;
    public static KnownColor DodgerBlue;
    public static KnownColor Firebrick;
    public static KnownColor FloralWhite;
    public static KnownColor ForestGreen;
    public static KnownColor Fuchsia;
    public static KnownColor Gainsboro;
    public static KnownColor GhostWhite;
    public static KnownColor Gold;
    public static KnownColor Goldenrod;
    public static KnownColor GradientActiveCaption;
    public static KnownColor GradientInactiveCaption;
    public static KnownColor Gray;
    public static KnownColor GrayText;
    public static KnownColor Green;
    public static KnownColor GreenYellow;
    public static KnownColor Highlight;
    public static KnownColor HighlightText;
    public static KnownColor Honeydew;
    public static KnownColor HotPink;
    public static KnownColor HotTrack;
    public static KnownColor InactiveBorder;
    public static KnownColor InactiveCaption;
    public static KnownColor InactiveCaptionText;
    public static KnownColor IndianRed;
    public static KnownColor Indigo;
    public static KnownColor Info;
    public static KnownColor InfoText;
    public static KnownColor Ivory;
    public static KnownColor Khaki;
    public static KnownColor Lavender;
    public static KnownColor LavenderBlush;
    public static KnownColor LawnGreen;
    public static KnownColor LemonChiffon;
    public static KnownColor LightBlue;
    public static KnownColor LightCoral;
    public static KnownColor LightCyan;
    public static KnownColor LightGoldenrodYellow;
    public static KnownColor LightGray;
    public static KnownColor LightGreen;
    public static KnownColor LightPink;
    public static KnownColor LightSalmon;
    public static KnownColor LightSeaGreen;
    public static KnownColor LightSkyBlue;
    public static KnownColor LightSlateGray;
    public static KnownColor LightSteelBlue;
    public static KnownColor LightYellow;
    public static KnownColor Lime;
    public static KnownColor LimeGreen;
    public static KnownColor Linen;
    public static KnownColor Magenta;
    public static KnownColor Maroon;
    public static KnownColor MediumAquamarine;
    public static KnownColor MediumBlue;
    public static KnownColor MediumOrchid;
    public static KnownColor MediumPurple;
    public static KnownColor MediumSeaGreen;
    public static KnownColor MediumSlateBlue;
    public static KnownColor MediumSpringGreen;
    public static KnownColor MediumTurquoise;
    public static KnownColor MediumVioletRed;
    public static KnownColor Menu;
    public static KnownColor MenuBar;
    public static KnownColor MenuHighlight;
    public static KnownColor MenuText;
    public static KnownColor MidnightBlue;
    public static KnownColor MintCream;
    public static KnownColor MistyRose;
    public static KnownColor Moccasin;
    public static KnownColor NavajoWhite;
    public static KnownColor Navy;
    public static KnownColor OldLace;
    public static KnownColor Olive;
    public static KnownColor OliveDrab;
    public static KnownColor Orange;
    public static KnownColor OrangeRed;
    public static KnownColor Orchid;
    public static KnownColor PaleGoldenrod;
    public static KnownColor PaleGreen;
    public static KnownColor PaleTurquoise;
    public static KnownColor PaleVioletRed;
    public static KnownColor PapayaWhip;
    public static KnownColor PeachPuff;
    public static KnownColor Peru;
    public static KnownColor Pink;
    public static KnownColor Plum;
    public static KnownColor PowderBlue;
    public static KnownColor Purple;
    public static KnownColor Red;
    public static KnownColor RosyBrown;
    public static KnownColor RoyalBlue;
    public static KnownColor SaddleBrown;
    public static KnownColor Salmon;
    public static KnownColor SandyBrown;
    public static KnownColor ScrollBar;
    public static KnownColor SeaGreen;
    public static KnownColor SeaShell;
    public static KnownColor Sienna;
    public static KnownColor Silver;
    public static KnownColor SkyBlue;
    public static KnownColor SlateBlue;
    public static KnownColor SlateGray;
    public static KnownColor Snow;
    public static KnownColor SpringGreen;
    public static KnownColor SteelBlue;
    public static KnownColor Tan;
    public static KnownColor Teal;
    public static KnownColor Thistle;
    public static KnownColor Tomato;
    public static KnownColor Transparent;
    public static KnownColor Turquoise;
    public static KnownColor Violet;
    public static KnownColor Wheat;
    public static KnownColor White;
    public static KnownColor WhiteSmoke;
    public static KnownColor Window;
    public static KnownColor WindowFrame;
    public static KnownColor WindowText;
    public static KnownColor Yellow;
    public static KnownColor YellowGreen;
}
public class System.Drawing.Point : ValueType {
    private int _dummyPrimitive;
    public static Point Empty;
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public Point(Size sz);
    public Point(int dw);
    public Point(int x, int y);
    public bool get_IsEmpty();
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public static Point Add(Point pt, Size sz);
    public static Point Ceiling(PointF value);
    public sealed virtual bool Equals(Point other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Offset(Point p);
    public void Offset(int dx, int dy);
    public static Point op_Addition(Point pt, Size sz);
    public static bool op_Equality(Point left, Point right);
    public static Size op_Explicit(Point p);
    public static PointF op_Implicit(Point p);
    public static bool op_Inequality(Point left, Point right);
    public static Point op_Subtraction(Point pt, Size sz);
    public static Point Round(PointF value);
    public static Point Subtract(Point pt, Size sz);
    public virtual string ToString();
    public static Point Truncate(PointF value);
}
public class System.Drawing.PointConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.PointF : ValueType {
    private int _dummyPrimitive;
    public static PointF Empty;
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public float X { get; public set; }
    public float Y { get; public set; }
    public PointF(float x, float y);
    public bool get_IsEmpty();
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public static PointF Add(PointF pt, Size sz);
    public static PointF Add(PointF pt, SizeF sz);
    public sealed virtual bool Equals(PointF other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PointF op_Addition(PointF pt, Size sz);
    public static PointF op_Addition(PointF pt, SizeF sz);
    public static bool op_Equality(PointF left, PointF right);
    public static bool op_Inequality(PointF left, PointF right);
    public static PointF op_Subtraction(PointF pt, Size sz);
    public static PointF op_Subtraction(PointF pt, SizeF sz);
    public static PointF Subtract(PointF pt, Size sz);
    public static PointF Subtract(PointF pt, SizeF sz);
    public virtual string ToString();
}
public class System.Drawing.Rectangle : ValueType {
    private int _dummyPrimitive;
    public static Rectangle Empty;
    [BrowsableAttribute("False")]
public int Bottom { get; }
    public int Height { get; public set; }
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    [BrowsableAttribute("False")]
public int Left { get; }
    [BrowsableAttribute("False")]
public Point Location { get; public set; }
    [BrowsableAttribute("False")]
public int Right { get; }
    [BrowsableAttribute("False")]
public Size Size { get; public set; }
    [BrowsableAttribute("False")]
public int Top { get; }
    public int Width { get; public set; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public Rectangle(Point location, Size size);
    public Rectangle(int x, int y, int width, int height);
    public int get_Bottom();
    public int get_Height();
    public void set_Height(int value);
    public bool get_IsEmpty();
    public int get_Left();
    public Point get_Location();
    public void set_Location(Point value);
    public int get_Right();
    public Size get_Size();
    public void set_Size(Size value);
    public int get_Top();
    public int get_Width();
    public void set_Width(int value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public static Rectangle Ceiling(RectangleF value);
    public bool Contains(Point pt);
    public bool Contains(Rectangle rect);
    public bool Contains(int x, int y);
    public sealed virtual bool Equals(Rectangle other);
    public virtual bool Equals(object obj);
    public static Rectangle FromLTRB(int left, int top, int right, int bottom);
    public virtual int GetHashCode();
    public static Rectangle Inflate(Rectangle rect, int x, int y);
    public void Inflate(Size size);
    public void Inflate(int width, int height);
    public void Intersect(Rectangle rect);
    public static Rectangle Intersect(Rectangle a, Rectangle b);
    public bool IntersectsWith(Rectangle rect);
    public void Offset(Point pos);
    public void Offset(int x, int y);
    public static bool op_Equality(Rectangle left, Rectangle right);
    public static bool op_Inequality(Rectangle left, Rectangle right);
    public static Rectangle Round(RectangleF value);
    public virtual string ToString();
    public static Rectangle Truncate(RectangleF value);
    public static Rectangle Union(Rectangle a, Rectangle b);
}
public class System.Drawing.RectangleConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.RectangleF : ValueType {
    private int _dummyPrimitive;
    public static RectangleF Empty;
    [BrowsableAttribute("False")]
public float Bottom { get; }
    public float Height { get; public set; }
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    [BrowsableAttribute("False")]
public float Left { get; }
    [BrowsableAttribute("False")]
public PointF Location { get; public set; }
    [BrowsableAttribute("False")]
public float Right { get; }
    [BrowsableAttribute("False")]
public SizeF Size { get; public set; }
    [BrowsableAttribute("False")]
public float Top { get; }
    public float Width { get; public set; }
    public float X { get; public set; }
    public float Y { get; public set; }
    public RectangleF(PointF location, SizeF size);
    public RectangleF(float x, float y, float width, float height);
    public float get_Bottom();
    public float get_Height();
    public void set_Height(float value);
    public bool get_IsEmpty();
    public float get_Left();
    public PointF get_Location();
    public void set_Location(PointF value);
    public float get_Right();
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public float get_Top();
    public float get_Width();
    public void set_Width(float value);
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public bool Contains(PointF pt);
    public bool Contains(RectangleF rect);
    public bool Contains(float x, float y);
    public sealed virtual bool Equals(RectangleF other);
    public virtual bool Equals(object obj);
    public static RectangleF FromLTRB(float left, float top, float right, float bottom);
    public virtual int GetHashCode();
    public static RectangleF Inflate(RectangleF rect, float x, float y);
    public void Inflate(SizeF size);
    public void Inflate(float x, float y);
    public void Intersect(RectangleF rect);
    public static RectangleF Intersect(RectangleF a, RectangleF b);
    public bool IntersectsWith(RectangleF rect);
    public void Offset(PointF pos);
    public void Offset(float x, float y);
    public static bool op_Equality(RectangleF left, RectangleF right);
    public static RectangleF op_Implicit(Rectangle r);
    public static bool op_Inequality(RectangleF left, RectangleF right);
    public virtual string ToString();
    public static RectangleF Union(RectangleF a, RectangleF b);
}
public class System.Drawing.Size : ValueType {
    private int _dummyPrimitive;
    public static Size Empty;
    public int Height { get; public set; }
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public int Width { get; public set; }
    public Size(Point pt);
    public Size(int width, int height);
    public int get_Height();
    public void set_Height(int value);
    public bool get_IsEmpty();
    public int get_Width();
    public void set_Width(int value);
    public static Size Add(Size sz1, Size sz2);
    public static Size Ceiling(SizeF value);
    public sealed virtual bool Equals(Size other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Size op_Addition(Size sz1, Size sz2);
    public static Size op_Division(Size left, int right);
    public static SizeF op_Division(Size left, float right);
    public static bool op_Equality(Size sz1, Size sz2);
    public static Point op_Explicit(Size size);
    public static SizeF op_Implicit(Size p);
    public static bool op_Inequality(Size sz1, Size sz2);
    public static Size op_Multiply(Size left, int right);
    public static SizeF op_Multiply(Size left, float right);
    public static Size op_Multiply(int left, Size right);
    public static SizeF op_Multiply(float left, Size right);
    public static Size op_Subtraction(Size sz1, Size sz2);
    public static Size Round(SizeF value);
    public static Size Subtract(Size sz1, Size sz2);
    public virtual string ToString();
    public static Size Truncate(SizeF value);
}
public class System.Drawing.SizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.SizeF : ValueType {
    private int _dummyPrimitive;
    public static SizeF Empty;
    public float Height { get; public set; }
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public float Width { get; public set; }
    public SizeF(PointF pt);
    public SizeF(SizeF size);
    public SizeF(float width, float height);
    public float get_Height();
    public void set_Height(float value);
    public bool get_IsEmpty();
    public float get_Width();
    public void set_Width(float value);
    public static SizeF Add(SizeF sz1, SizeF sz2);
    public sealed virtual bool Equals(SizeF other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static SizeF op_Addition(SizeF sz1, SizeF sz2);
    public static SizeF op_Division(SizeF left, float right);
    public static bool op_Equality(SizeF sz1, SizeF sz2);
    public static PointF op_Explicit(SizeF size);
    public static bool op_Inequality(SizeF sz1, SizeF sz2);
    public static SizeF op_Multiply(SizeF left, float right);
    public static SizeF op_Multiply(float left, SizeF right);
    public static SizeF op_Subtraction(SizeF sz1, SizeF sz2);
    public static SizeF Subtract(SizeF sz1, SizeF sz2);
    public PointF ToPointF();
    public Size ToSize();
    public virtual string ToString();
}
public class System.Drawing.SizeFConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.DuplicateWaitObjectException : ArgumentException {
    protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string message, Exception innerException);
    public DuplicateWaitObjectException(string parameterName, string message);
}
public abstract class System.Dynamic.BinaryOperationBinder : DynamicMetaObjectBinder {
    public ExpressionType Operation { get; }
    public Type ReturnType { get; }
    protected BinaryOperationBinder(ExpressionType operation);
    public ExpressionType get_Operation();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg);
    public abstract virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.BindingRestrictions : object {
    public static BindingRestrictions Empty;
    public static BindingRestrictions Combine(IList`1<DynamicMetaObject> contributingObjects);
    public static BindingRestrictions GetExpressionRestriction(Expression expression);
    public static BindingRestrictions GetInstanceRestriction(Expression expression, object instance);
    public static BindingRestrictions GetTypeRestriction(Expression expression, Type type);
    public BindingRestrictions Merge(BindingRestrictions restrictions);
    public Expression ToExpression();
}
public class System.Dynamic.CallInfo : object {
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<string> ArgumentNames { get; }
    public CallInfo(int argCount, IEnumerable`1<string> argNames);
    public CallInfo(int argCount, String[] argNames);
    public int get_ArgumentCount();
    public ReadOnlyCollection`1<string> get_ArgumentNames();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.Dynamic.ConvertBinder : DynamicMetaObjectBinder {
    public bool Explicit { get; }
    public Type ReturnType { get; }
    public Type Type { get; }
    protected ConvertBinder(Type type, bool explicit);
    public bool get_Explicit();
    public sealed virtual Type get_ReturnType();
    public Type get_Type();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackConvert(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.CreateInstanceBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected CreateInstanceBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.DeleteIndexBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected DeleteIndexBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.DeleteMemberBinder : DynamicMetaObjectBinder {
    public bool IgnoreCase { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    protected DeleteMemberBinder(string name, bool ignoreCase);
    public bool get_IgnoreCase();
    public string get_Name();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
public class System.Dynamic.DynamicMetaObject : object {
    public static DynamicMetaObject[] EmptyMetaObjects;
    public Expression Expression { get; }
    public bool HasValue { get; }
    public Type LimitType { get; }
    public BindingRestrictions Restrictions { get; }
    public Type RuntimeType { get; }
    public object Value { get; }
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions);
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions, object value);
    public Expression get_Expression();
    public bool get_HasValue();
    public Type get_LimitType();
    public BindingRestrictions get_Restrictions();
    public Type get_RuntimeType();
    public object get_Value();
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public static DynamicMetaObject Create(object value, Expression expression);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
public abstract class System.Dynamic.DynamicMetaObjectBinder : CallSiteBinder {
    public Type ReturnType { get; }
    public virtual Type get_ReturnType();
    public abstract virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public sealed virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public DynamicMetaObject Defer(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject Defer(DynamicMetaObject[] args);
    public Expression GetUpdateExpression(Type type);
}
public class System.Dynamic.DynamicObject : object {
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual DynamicMetaObject GetMetaObject(Expression parameter);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryUnaryOperation(UnaryOperationBinder binder, Object& result);
}
public class System.Dynamic.ExpandoObject : object {
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
public abstract class System.Dynamic.GetIndexBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected GetIndexBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.GetMemberBinder : DynamicMetaObjectBinder {
    public bool IgnoreCase { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    protected GetMemberBinder(string name, bool ignoreCase);
    public bool get_IgnoreCase();
    public string get_Name();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackGetMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
public interface System.Dynamic.IDynamicMetaObjectProvider {
    public abstract virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public interface System.Dynamic.IInvokeOnGetBinder {
    public bool InvokeOnGet { get; }
    public abstract virtual bool get_InvokeOnGet();
}
public abstract class System.Dynamic.InvokeBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected InvokeBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.InvokeMemberBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public bool IgnoreCase { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    protected InvokeMemberBinder(string name, bool ignoreCase, CallInfo callInfo);
    public CallInfo get_CallInfo();
    public bool get_IgnoreCase();
    public string get_Name();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetIndexBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected SetIndexBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetMemberBinder : DynamicMetaObjectBinder {
    public bool IgnoreCase { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    protected SetMemberBinder(string name, bool ignoreCase);
    public bool get_IgnoreCase();
    public string get_Name();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.UnaryOperationBinder : DynamicMetaObjectBinder {
    public ExpressionType Operation { get; }
    public Type ReturnType { get; }
    protected UnaryOperationBinder(ExpressionType operation);
    public ExpressionType get_Operation();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
public class System.EntryPointNotFoundException : TypeLoadException {
    protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
}
public abstract class System.Enum : ValueType {
    public sealed virtual int CompareTo(object target);
    public virtual bool Equals(object obj);
    public static string Format(Type enumType, object value, string format);
    public virtual int GetHashCode();
    public static string GetName(Type enumType, object value);
    public static String[] GetNames(Type enumType);
    public sealed virtual TypeCode GetTypeCode();
    public static Type GetUnderlyingType(Type enumType);
    public static Array GetValues(Type enumType);
    public bool HasFlag(Enum flag);
    public static bool IsDefined(Type enumType, object value);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    public static TEnum Parse(string value);
    public static TEnum Parse(string value, bool ignoreCase);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public static object ToObject(Type enumType, byte value);
    public static object ToObject(Type enumType, short value);
    public static object ToObject(Type enumType, int value);
    public static object ToObject(Type enumType, long value);
    public static object ToObject(Type enumType, object value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
    public virtual string ToString();
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    public static bool TryParse(Type enumType, string value, Object& result);
    public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    public static bool TryParse(string value, TEnum& result);
}
public static class System.Environment : object {
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static bool HasShutdownStarted { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool Is64BitProcess { get; }
    public static string MachineName { get; }
    public static string NewLine { get; }
    public static OperatingSystem OSVersion { get; }
    public static int ProcessorCount { get; }
    public static string StackTrace { get; }
    public static string SystemDirectory { get; }
    public static int SystemPageSize { get; }
    public static int TickCount { get; }
    public static string UserDomainName { get; }
    public static bool UserInteractive { get; }
    public static string UserName { get; }
    public static Version Version { get; }
    public static long WorkingSet { get; }
    public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static int get_CurrentManagedThreadId();
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static bool get_HasShutdownStarted();
    public static bool get_Is64BitOperatingSystem();
    public static bool get_Is64BitProcess();
    public static string get_MachineName();
    public static string get_NewLine();
    public static OperatingSystem get_OSVersion();
    public static int get_ProcessorCount();
    public static string get_StackTrace();
    public static string get_SystemDirectory();
    public static int get_SystemPageSize();
    public static int get_TickCount();
    public static string get_UserDomainName();
    public static bool get_UserInteractive();
    public static string get_UserName();
    public static Version get_Version();
    public static long get_WorkingSet();
    [DoesNotReturnAttribute]
public static void Exit(int exitCode);
    public static string ExpandEnvironmentVariables(string name);
    [DoesNotReturnAttribute]
public static void FailFast(string message);
    [DoesNotReturnAttribute]
public static void FailFast(string message, Exception exception);
    public static String[] GetCommandLineArgs();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables();
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    public static string GetFolderPath(SpecialFolder folder);
    public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    public static String[] GetLogicalDrives();
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
}
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Machine;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
}
public class System.EventArgs : object {
    public static EventArgs Empty;
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Exception : object {
    public IDictionary Data { get; }
    public string HelpLink { get; public set; }
    public int HResult { get; protected set; }
    public Exception InnerException { get; }
    public string Message { get; }
    public string Source { get; public set; }
    public string StackTrace { get; }
    public MethodBase TargetSite { get; }
    protected Exception(SerializationInfo info, StreamingContext context);
    public Exception(string message);
    public Exception(string message, Exception innerException);
    public virtual IDictionary get_Data();
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public int get_HResult();
    protected void set_HResult(int value);
    public Exception get_InnerException();
    public virtual string get_Message();
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string get_StackTrace();
    public MethodBase get_TargetSite();
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    public virtual Exception GetBaseException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public Type GetType();
    public virtual string ToString();
}
[ObsoleteAttribute("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
}
public class System.FieldAccessException : MemberAccessException {
    protected FieldAccessException(SerializationInfo info, StreamingContext context);
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
}
public class System.FileStyleUriParser : UriParser {
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
public class System.FormatException : SystemException {
    protected FormatException(SerializationInfo info, StreamingContext context);
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
}
public abstract class System.FormattableString : object {
    public int ArgumentCount { get; }
    public string Format { get; }
    public abstract virtual int get_ArgumentCount();
    public abstract virtual string get_Format();
    public abstract virtual object GetArgument(int index);
    public abstract virtual Object[] GetArguments();
    public static string Invariant(FormattableString formattable);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public virtual string ToString();
    public abstract virtual string ToString(IFormatProvider formatProvider);
}
public class System.FtpStyleUriParser : UriParser {
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`10 : MulticastDelegate {
    public Func`10(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`11 : MulticastDelegate {
    public Func`11(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`12 : MulticastDelegate {
    public Func`12(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`13 : MulticastDelegate {
    public Func`13(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`14 : MulticastDelegate {
    public Func`14(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`15 : MulticastDelegate {
    public Func`15(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`16 : MulticastDelegate {
    public Func`16(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`17 : MulticastDelegate {
    public Func`17(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`6 : MulticastDelegate {
    public Func`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`7 : MulticastDelegate {
    public Func`7(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`8 : MulticastDelegate {
    public Func`8(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`9 : MulticastDelegate {
    public Func`9(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public static class System.GC : object {
    public static int MaxGeneration { get; }
    public static int get_MaxGeneration();
    public static void AddMemoryPressure(long bytesAllocated);
    public static void CancelFullGCNotification();
    public static void Collect();
    public static void Collect(int generation);
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static int CollectionCount(int generation);
    public static void EndNoGCRegion();
    public static long GetAllocatedBytesForCurrentThread();
    public static int GetGeneration(object obj);
    public static int GetGeneration(WeakReference wo);
    public static long GetTotalMemory(bool forceFullCollection);
    public static void KeepAlive(object obj);
    public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    public static void RemoveMemoryPressure(long bytesAllocated);
    public static void ReRegisterForFinalize(object obj);
    public static void SuppressFinalize(object obj);
    public static bool TryStartNoGCRegion(long totalSize);
    public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    public static GCNotificationStatus WaitForFullGCApproach();
    public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCComplete();
    public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    public static void WaitForPendingFinalizers();
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus NotApplicable;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Timeout;
}
public class System.GenericUriParser : UriParser {
    public GenericUriParser(GenericUriParserOptions options);
}
[FlagsAttribute]
public enum System.GenericUriParserOptions : Enum {
    public int value__;
    public static GenericUriParserOptions AllowEmptyAuthority;
    public static GenericUriParserOptions Default;
    public static GenericUriParserOptions DontCompressPath;
    public static GenericUriParserOptions DontConvertPathBackslashes;
    public static GenericUriParserOptions DontUnescapePathDotsAndSlashes;
    public static GenericUriParserOptions GenericAuthority;
    public static GenericUriParserOptions Idn;
    public static GenericUriParserOptions IriParsing;
    public static GenericUriParserOptions NoFragment;
    public static GenericUriParserOptions NoPort;
    public static GenericUriParserOptions NoQuery;
    public static GenericUriParserOptions NoUserInfo;
}
public abstract class System.Globalization.Calendar : object {
    public static int CurrentEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public bool IsReadOnly { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public abstract virtual Int32[] get_Eras();
    public bool get_IsReadOnly();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public virtual object Clone();
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public virtual int GetHour(DateTime time);
    public virtual int GetLeapMonth(int year);
    public virtual int GetLeapMonth(int year, int era);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public static Calendar ReadOnly(Calendar calendar);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType Unknown;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFourDayWeek;
    public static CalendarWeekRule FirstFullWeek;
}
public static class System.Globalization.CharUnicodeInfo : object {
    public static int GetDecimalDigitValue(char ch);
    public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    public static int GetDigitValue(string s, int index);
    public static double GetNumericValue(char ch);
    public static double GetNumericValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(int codePoint);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
}
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
public class System.Globalization.CompareInfo : object {
    public int LCID { get; }
    public string Name { get; }
    public SortVersion Version { get; }
    public int get_LCID();
    public virtual string get_Name();
    public SortVersion get_Version();
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, string string2, int offset2);
    public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    public virtual int Compare(string string1, string string2);
    public virtual int Compare(string string1, string string2, CompareOptions options);
    public virtual bool Equals(object value);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public virtual int GetHashCode();
    public virtual int GetHashCode(string source, CompareOptions options);
    public virtual SortKey GetSortKey(string source);
    public virtual SortKey GetSortKey(string source, CompareOptions options);
    public virtual int IndexOf(string source, char value);
    public virtual int IndexOf(string source, char value, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex);
    public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex, int count);
    public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int IndexOf(string source, string value);
    public virtual int IndexOf(string source, string value, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex);
    public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, int count);
    public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    public virtual bool IsPrefix(string source, string prefix);
    public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
    public static bool IsSortable(char ch);
    public static bool IsSortable(string text);
    public virtual bool IsSuffix(string source, string suffix);
    public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
    public virtual int LastIndexOf(string source, char value);
    public virtual int LastIndexOf(string source, char value, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex);
    public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int LastIndexOf(string source, string value);
    public virtual int LastIndexOf(string source, string value, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex);
    public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions None;
    public static CompareOptions Ordinal;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
}
public class System.Globalization.CultureInfo : object {
    public Calendar Calendar { get; }
    public CompareInfo CompareInfo { get; }
    public CultureTypes CultureTypes { get; }
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public string DisplayName { get; }
    public string EnglishName { get; }
    public string IetfLanguageTag { get; }
    public static CultureInfo InstalledUICulture { get; }
    public static CultureInfo InvariantCulture { get; }
    public bool IsNeutralCulture { get; }
    public bool IsReadOnly { get; }
    public int KeyboardLayoutId { get; }
    public int LCID { get; }
    public string Name { get; }
    public string NativeName { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public Calendar[] OptionalCalendars { get; }
    public CultureInfo Parent { get; }
    public TextInfo TextInfo { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public string TwoLetterISOLanguageName { get; }
    public bool UseUserOverride { get; }
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    public virtual Calendar get_Calendar();
    public virtual CompareInfo get_CompareInfo();
    public CultureTypes get_CultureTypes();
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public static CultureInfo get_DefaultThreadCurrentCulture();
    public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    public static CultureInfo get_DefaultThreadCurrentUICulture();
    public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    public virtual string get_DisplayName();
    public virtual string get_EnglishName();
    public string get_IetfLanguageTag();
    public static CultureInfo get_InstalledUICulture();
    public static CultureInfo get_InvariantCulture();
    public virtual bool get_IsNeutralCulture();
    public bool get_IsReadOnly();
    public virtual int get_KeyboardLayoutId();
    public virtual int get_LCID();
    public virtual string get_Name();
    public virtual string get_NativeName();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual Calendar[] get_OptionalCalendars();
    public virtual CultureInfo get_Parent();
    public virtual TextInfo get_TextInfo();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual string get_TwoLetterISOLanguageName();
    public bool get_UseUserOverride();
    public void ClearCachedData();
    public virtual object Clone();
    public static CultureInfo CreateSpecificCulture(string name);
    public virtual bool Equals(object value);
    public CultureInfo GetConsoleFallbackUICulture();
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    public static CultureInfo[] GetCultures(CultureTypes types);
    public virtual object GetFormat(Type formatType);
    public virtual int GetHashCode();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public virtual string ToString();
}
public class System.Globalization.CultureNotFoundException : ArgumentException {
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    public string Message { get; }
    protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes AllCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes FrameworkCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes NeutralCultures;
    public static CultureTypes ReplacementCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes UserCustomCulture;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes WindowsOnlyCultures;
}
public class System.Globalization.DateTimeFormatInfo : object {
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string DateSeparator { get; public set; }
    public String[] DayNames { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public bool IsReadOnly { get; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    public String[] MonthNames { get; public set; }
    public string NativeCalendarName { get; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public static DateTimeFormatInfo get_CurrentInfo();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public static DateTimeFormatInfo get_InvariantInfo();
    public bool get_IsReadOnly();
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    public string get_NativeCalendarName();
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    public sealed virtual object Clone();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedEraName(int era);
    public string GetAbbreviatedMonthName(int month);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public int GetEra(string eraName);
    public string GetEraName(int era);
    public sealed virtual object GetFormat(Type formatType);
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    public string GetMonthName(int month);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public void SetAllDateTimePatterns(String[] patterns, char format);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles None;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    public TimeSpan Delta { get; }
    public DateTime End { get; }
    public DateTime Start { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public TimeSpan get_Delta();
    public DateTime get_End();
    public DateTime get_Start();
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes NativeNational;
    public static DigitShapes None;
}
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public int GetCelestialStem(int sexagenaryYear);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetTerrestrialBranch(int sexagenaryYear);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Globalization.GlobalizationExtensions : object {
    [ExtensionAttribute]
public static StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options);
}
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
    public static GregorianCalendarTypes USEnglish;
}
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.HijriCalendar : Calendar {
    public static int HijriEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int HijriAdjustment { get; public set; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.IdnMapping : object {
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public virtual bool Equals(object obj);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public virtual int GetHashCode();
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
}
public static class System.Globalization.ISOWeek : object {
    public static int GetWeekOfYear(DateTime date);
    public static int GetWeeksInYear(int year);
    public static int GetYear(DateTime date);
    public static DateTime GetYearEnd(int year);
    public static DateTime GetYearStart(int year);
    public static DateTime ToDateTime(int year, int week, DayOfWeek dayOfWeek);
}
public class System.Globalization.JapaneseCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
public class System.Globalization.NumberFormatInfo : object {
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public DigitShapes DigitSubstitution { get; public set; }
    public static NumberFormatInfo InvariantInfo { get; }
    public bool IsReadOnly { get; }
    public string NaNSymbol { get; public set; }
    public String[] NativeDigits { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    public static NumberFormatInfo get_InvariantInfo();
    public bool get_IsReadOnly();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public sealed virtual object Clone();
    public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles Any;
    public static NumberStyles Currency;
    public static NumberStyles Float;
    public static NumberStyles HexNumber;
    public static NumberStyles Integer;
    public static NumberStyles None;
    public static NumberStyles Number;
}
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.RegionInfo : object {
    public string CurrencyEnglishName { get; }
    public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public static RegionInfo CurrentRegion { get; }
    public string DisplayName { get; }
    public string EnglishName { get; }
    public int GeoId { get; }
    public bool IsMetric { get; }
    public string ISOCurrencySymbol { get; }
    public string Name { get; }
    public string NativeName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public string TwoLetterISORegionName { get; }
    public RegionInfo(int culture);
    public RegionInfo(string name);
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_CurrencySymbol();
    public static RegionInfo get_CurrentRegion();
    public virtual string get_DisplayName();
    public virtual string get_EnglishName();
    public virtual int get_GeoId();
    public virtual bool get_IsMetric();
    public virtual string get_ISOCurrencySymbol();
    public virtual string get_Name();
    public virtual string get_NativeName();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual string get_TwoLetterISORegionName();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortKey : object {
    public Byte[] KeyData { get; }
    public string OriginalString { get; }
    public virtual Byte[] get_KeyData();
    public virtual string get_OriginalString();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortVersion : object {
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    public int get_FullVersion();
    public Guid get_SortId();
    public sealed virtual bool Equals(SortVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
public class System.Globalization.StringInfo : object {
    public int LengthInTextElements { get; }
    public string String { get; public set; }
    public StringInfo(string value);
    public int get_LengthInTextElements();
    public string get_String();
    public void set_String(string value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static string GetNextTextElement(string str);
    public static string GetNextTextElement(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
}
public class System.Globalization.TaiwanCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
public class System.Globalization.TextElementEnumerator : object {
    public object Current { get; }
    public int ElementIndex { get; }
    public sealed virtual object get_Current();
    public int get_ElementIndex();
    public string GetTextElement();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Globalization.TextInfo : object {
    public int ANSICodePage { get; }
    public string CultureName { get; }
    public int EBCDICCodePage { get; }
    public bool IsReadOnly { get; }
    public bool IsRightToLeft { get; }
    public int LCID { get; }
    public string ListSeparator { get; public set; }
    public int MacCodePage { get; }
    public int OEMCodePage { get; }
    public virtual int get_ANSICodePage();
    public string get_CultureName();
    public virtual int get_EBCDICCodePage();
    public bool get_IsReadOnly();
    public bool get_IsRightToLeft();
    public int get_LCID();
    public virtual string get_ListSeparator();
    public virtual void set_ListSeparator(string value);
    public virtual int get_MacCodePage();
    public virtual int get_OEMCodePage();
    public virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static TextInfo ReadOnly(TextInfo textInfo);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual char ToLower(char c);
    public virtual string ToLower(string str);
    public virtual string ToString();
    public string ToTitleCase(string str);
    public virtual char ToUpper(char c);
    public virtual string ToUpper(string str);
}
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    public static int ThaiBuddhistEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles AssumeNegative;
    public static TimeSpanStyles None;
}
public class System.Globalization.UmAlQuraCalendar : Calendar {
    public static int UmAlQuraEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory Control;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory Format;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory OtherNotAssigned;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory UppercaseLetter;
}
public class System.GopherStyleUriParser : UriParser {
}
public class System.Guid : ValueType {
    private int _dummyPrimitive;
    public static Guid Empty;
    public Guid(Byte[] b);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, Byte[] d);
    public Guid(ReadOnlySpan`1<byte> b);
    public Guid(string g);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public sealed virtual int CompareTo(Guid value);
    public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(Guid g);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static Guid NewGuid();
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    public static Guid Parse(ReadOnlySpan`1<char> input);
    public static Guid Parse(string input);
    public static Guid ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format);
    public static Guid ParseExact(string input, string format);
    public Byte[] ToByteArray();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    public static bool TryParse(ReadOnlySpan`1<char> input, Guid& result);
    public static bool TryParse(string input, Guid& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, Guid& result);
    public static bool TryParseExact(string input, string format, Guid& result);
    public bool TryWriteBytes(Span`1<byte> destination);
}
public class System.HashCode : ValueType {
    private int _dummyPrimitive;
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
public virtual int GetHashCode();
    public int ToHashCode();
}
public class System.HttpStyleUriParser : UriParser {
}
public interface System.IAsyncDisposable {
    public abstract virtual ValueTask DisposeAsync();
}
public interface System.IAsyncResult {
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public abstract virtual object get_AsyncState();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual bool get_CompletedSynchronously();
    public abstract virtual bool get_IsCompleted();
}
public interface System.ICloneable {
    public abstract virtual object Clone();
}
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual string ToString(IFormatProvider provider);
    public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
}
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
public class System.Index : ValueType {
    private int _dummyPrimitive;
    public static Index End { get; }
    public bool IsFromEnd { get; }
    public static Index Start { get; }
    public int Value { get; }
    public Index(int value, bool fromEnd);
    public static Index get_End();
    public bool get_IsFromEnd();
    public static Index get_Start();
    public int get_Value();
    public sealed virtual bool Equals(Index other);
    public virtual bool Equals(object value);
    public static Index FromEnd(int value);
    public static Index FromStart(int value);
    public virtual int GetHashCode();
    public int GetOffset(int length);
    public static Index op_Implicit(int value);
    public virtual string ToString();
}
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
}
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
}
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.Int16 : ValueType {
    private short _dummyPrimitive;
    public static short MaxValue;
    public static short MinValue;
    public sealed virtual int CompareTo(short value);
    public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(short obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static short Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int16& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static bool TryParse(string s, Int16& result);
}
[IsReadOnlyAttribute]
public class System.Int32 : ValueType {
    private int _dummyPrimitive;
    public static int MaxValue;
    public static int MinValue;
    public sealed virtual int CompareTo(int value);
    public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(int obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static int Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static int Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int32& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static bool TryParse(string s, Int32& result);
}
[IsReadOnlyAttribute]
public class System.Int64 : ValueType {
    private long _dummyPrimitive;
    public static long MaxValue;
    public static long MinValue;
    public sealed virtual int CompareTo(long value);
    public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(long obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static long Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static long Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int64& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static bool TryParse(string s, Int64& result);
}
[IsReadOnlyAttribute]
public class System.IntPtr : ValueType {
    private int _dummyPrimitive;
    public static IntPtr Zero;
    public static int Size { get; }
    public IntPtr(int value);
    public IntPtr(long value);
    [CLSCompliantAttribute("False")]
public IntPtr(Void* value);
    public static int get_Size();
    public static IntPtr Add(IntPtr pointer, int offset);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static IntPtr op_Addition(IntPtr pointer, int offset);
    public static bool op_Equality(IntPtr value1, IntPtr value2);
    public static IntPtr op_Explicit(int value);
    public static IntPtr op_Explicit(long value);
    public static int op_Explicit(IntPtr value);
    public static long op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static Void* op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static IntPtr op_Explicit(Void* value);
    public static bool op_Inequality(IntPtr value1, IntPtr value2);
    public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    public static IntPtr Subtract(IntPtr pointer, int offset);
    private sealed virtual override bool System.IEquatable<System.IntPtr>.Equals(IntPtr other);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public int ToInt32();
    public long ToInt64();
    [CLSCompliantAttribute("False")]
public Void* ToPointer();
    public virtual string ToString();
    public string ToString(string format);
}
public class System.InvalidCastException : SystemException {
    protected InvalidCastException(SerializationInfo info, StreamingContext context);
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
}
public class System.InvalidOperationException : SystemException {
    protected InvalidOperationException(SerializationInfo info, StreamingContext context);
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
}
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
}
public class System.InvalidTimeZoneException : Exception {
    protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
}
public class System.IO.BinaryReader : object {
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void FillBuffer(int numBytes);
    public virtual int PeekChar();
    public virtual int Read();
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int Read(Span`1<char> buffer);
    protected internal int Read7BitEncodedInt();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    public virtual Byte[] ReadBytes(int count);
    public virtual char ReadChar();
    public virtual Char[] ReadChars(int count);
    public virtual decimal ReadDecimal();
    public virtual double ReadDouble();
    public virtual short ReadInt16();
    public virtual int ReadInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual float ReadSingle();
    public virtual string ReadString();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
}
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(short value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<char> chars);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(float value);
    public virtual void Write(string value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    protected void Write7BitEncodedInt(int value);
}
public class System.IO.BufferedStream : Stream {
    public int BufferSize { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Stream UnderlyingStream { get; }
    public BufferedStream(Stream stream);
    public BufferedStream(Stream stream, int bufferSize);
    public int get_BufferSize();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Stream get_UnderlyingStream();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public class System.IO.Compression.BrotliDecoder : ValueType {
    public OperationStatus Decompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten);
    public sealed virtual void Dispose();
    public static bool TryDecompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
public class System.IO.Compression.BrotliEncoder : ValueType {
    public BrotliEncoder(int quality, int window);
    public OperationStatus Compress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public sealed virtual void Dispose();
    public OperationStatus Flush(Span`1<byte> destination, Int32& bytesWritten);
    public static int GetMaxCompressedLength(int inputSize);
    public static bool TryCompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryCompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten, int quality, int window);
}
public class System.IO.Compression.BrotliStream : Stream {
    public Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BrotliStream(Stream stream, CompressionLevel compressionLevel);
    public BrotliStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    public BrotliStream(Stream stream, CompressionMode mode);
    public BrotliStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
public enum System.IO.Compression.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel Fastest;
    public static CompressionLevel NoCompression;
    public static CompressionLevel Optimal;
}
public enum System.IO.Compression.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Compress;
    public static CompressionMode Decompress;
}
public class System.IO.Compression.DeflateStream : Stream {
    public Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DeflateStream(Stream stream, CompressionLevel compressionLevel);
    public DeflateStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    public DeflateStream(Stream stream, CompressionMode mode);
    public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
public class System.IO.Compression.GZipStream : Stream {
    public Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public GZipStream(Stream stream, CompressionLevel compressionLevel);
    public GZipStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    public GZipStream(Stream stream, CompressionMode mode);
    public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
public class System.IO.Compression.ZipArchive : object {
    public ReadOnlyCollection`1<ZipArchiveEntry> Entries { get; }
    public ZipArchiveMode Mode { get; }
    public ZipArchive(Stream stream);
    public ZipArchive(Stream stream, ZipArchiveMode mode);
    public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen);
    public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen, Encoding entryNameEncoding);
    public ReadOnlyCollection`1<ZipArchiveEntry> get_Entries();
    public ZipArchiveMode get_Mode();
    public ZipArchiveEntry CreateEntry(string entryName);
    public ZipArchiveEntry CreateEntry(string entryName, CompressionLevel compressionLevel);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public ZipArchiveEntry GetEntry(string entryName);
}
public class System.IO.Compression.ZipArchiveEntry : object {
    public ZipArchive Archive { get; }
    public long CompressedLength { get; }
    [CLSCompliantAttribute("False")]
public UInt32 Crc32 { get; }
    public int ExternalAttributes { get; public set; }
    public string FullName { get; }
    public DateTimeOffset LastWriteTime { get; public set; }
    public long Length { get; }
    public string Name { get; }
    public ZipArchive get_Archive();
    public long get_CompressedLength();
    public UInt32 get_Crc32();
    public int get_ExternalAttributes();
    public void set_ExternalAttributes(int value);
    public string get_FullName();
    public DateTimeOffset get_LastWriteTime();
    public void set_LastWriteTime(DateTimeOffset value);
    public long get_Length();
    public string get_Name();
    public void Delete();
    public Stream Open();
    public virtual string ToString();
}
public enum System.IO.Compression.ZipArchiveMode : Enum {
    public int value__;
    public static ZipArchiveMode Create;
    public static ZipArchiveMode Read;
    public static ZipArchiveMode Update;
}
public static class System.IO.Compression.ZipFile : object {
    public static void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName);
    public static void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, CompressionLevel compressionLevel, bool includeBaseDirectory);
    public static void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, CompressionLevel compressionLevel, bool includeBaseDirectory, Encoding entryNameEncoding);
    public static void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName);
    public static void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, bool overwriteFiles);
    public static void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, Encoding entryNameEncoding);
    public static void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, Encoding entryNameEncoding, bool overwriteFiles);
    public static ZipArchive Open(string archiveFileName, ZipArchiveMode mode);
    public static ZipArchive Open(string archiveFileName, ZipArchiveMode mode, Encoding entryNameEncoding);
    public static ZipArchive OpenRead(string archiveFileName);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.IO.Compression.ZipFileExtensions : object {
    [ExtensionAttribute]
public static ZipArchiveEntry CreateEntryFromFile(ZipArchive destination, string sourceFileName, string entryName);
    [ExtensionAttribute]
public static ZipArchiveEntry CreateEntryFromFile(ZipArchive destination, string sourceFileName, string entryName, CompressionLevel compressionLevel);
    [ExtensionAttribute]
public static void ExtractToDirectory(ZipArchive source, string destinationDirectoryName);
    [ExtensionAttribute]
public static void ExtractToDirectory(ZipArchive source, string destinationDirectoryName, bool overwriteFiles);
    [ExtensionAttribute]
public static void ExtractToFile(ZipArchiveEntry source, string destinationFileName);
    [ExtensionAttribute]
public static void ExtractToFile(ZipArchiveEntry source, string destinationFileName, bool overwrite);
}
public static class System.IO.Directory : object {
    public static DirectoryInfo CreateDirectory(string path);
    public static void Delete(string path);
    public static void Delete(string path, bool recursive);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static bool Exists(string path);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static string GetCurrentDirectory();
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static string GetDirectoryRoot(string path);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static String[] GetLogicalDrives();
    public static DirectoryInfo GetParent(string path);
    public static void Move(string sourceDirName, string destDirName);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static void SetCurrentDirectory(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
}
public class System.IO.DirectoryInfo : FileSystemInfo {
    public bool Exists { get; }
    public string Name { get; }
    public DirectoryInfo Parent { get; }
    public DirectoryInfo Root { get; }
    public DirectoryInfo(string path);
    public virtual bool get_Exists();
    public virtual string get_Name();
    public DirectoryInfo get_Parent();
    public DirectoryInfo get_Root();
    public void Create();
    public DirectoryInfo CreateSubdirectory(string path);
    public virtual void Delete();
    public void Delete(bool recursive);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    public DirectoryInfo[] GetDirectories();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles();
    public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public void MoveTo(string destDirName);
    public virtual string ToString();
}
public class System.IO.DirectoryNotFoundException : IOException {
    protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
}
public class System.IO.DriveInfo : object {
    public long AvailableFreeSpace { get; }
    public string DriveFormat { get; }
    public DriveType DriveType { get; }
    public bool IsReady { get; }
    public string Name { get; }
    public DirectoryInfo RootDirectory { get; }
    public long TotalFreeSpace { get; }
    public long TotalSize { get; }
    public string VolumeLabel { get; public set; }
    public DriveInfo(string driveName);
    public long get_AvailableFreeSpace();
    public string get_DriveFormat();
    public DriveType get_DriveType();
    public bool get_IsReady();
    public string get_Name();
    public DirectoryInfo get_RootDirectory();
    public long get_TotalFreeSpace();
    public long get_TotalSize();
    public string get_VolumeLabel();
    public void set_VolumeLabel(string value);
    public static DriveInfo[] GetDrives();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class System.IO.DriveNotFoundException : IOException {
    protected DriveNotFoundException(SerializationInfo info, StreamingContext context);
    public DriveNotFoundException(string message);
    public DriveNotFoundException(string message, Exception innerException);
}
public enum System.IO.DriveType : Enum {
    public int value__;
    public static DriveType CDRom;
    public static DriveType Fixed;
    public static DriveType Network;
    public static DriveType NoRootDirectory;
    public static DriveType Ram;
    public static DriveType Removable;
    public static DriveType Unknown;
}
public class System.IO.EndOfStreamException : IOException {
    protected EndOfStreamException(SerializationInfo info, StreamingContext context);
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class System.IO.Enumeration.FileSystemEntry : ValueType {
    public FileAttributes Attributes { get; }
    public DateTimeOffset CreationTimeUtc { get; }
    public ReadOnlySpan`1<char> Directory { get; }
    public ReadOnlySpan`1<char> FileName { get; }
    public bool IsDirectory { get; }
    public bool IsHidden { get; }
    public DateTimeOffset LastAccessTimeUtc { get; }
    public DateTimeOffset LastWriteTimeUtc { get; }
    public long Length { get; }
    public ReadOnlySpan`1<char> OriginalRootDirectory { get; }
    public ReadOnlySpan`1<char> RootDirectory { get; }
    public FileAttributes get_Attributes();
    public DateTimeOffset get_CreationTimeUtc();
    public ReadOnlySpan`1<char> get_Directory();
    public ReadOnlySpan`1<char> get_FileName();
    public bool get_IsDirectory();
    public bool get_IsHidden();
    public DateTimeOffset get_LastAccessTimeUtc();
    public DateTimeOffset get_LastWriteTimeUtc();
    public long get_Length();
    public ReadOnlySpan`1<char> get_OriginalRootDirectory();
    public ReadOnlySpan`1<char> get_RootDirectory();
    public FileSystemInfo ToFileSystemInfo();
    public string ToFullPath();
    public string ToSpecifiedFullPath();
}
public class System.IO.Enumeration.FileSystemEnumerable`1 : object {
    public FindPredicate<TResult> ShouldIncludePredicate { get; public set; }
    public FindPredicate<TResult> ShouldRecursePredicate { get; public set; }
    public FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options);
    public FindPredicate<TResult> get_ShouldIncludePredicate();
    public void set_ShouldIncludePredicate(FindPredicate<TResult> value);
    public FindPredicate<TResult> get_ShouldRecursePredicate();
    public void set_ShouldRecursePredicate(FindPredicate<TResult> value);
    public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.IO.Enumeration.FileSystemEnumerator`1 : CriticalFinalizerObject {
    public TResult Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public FileSystemEnumerator`1(string directory, EnumerationOptions options);
    public sealed virtual TResult get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    protected virtual bool ContinueOnError(int error);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool MoveNext();
    protected virtual void OnDirectoryFinished(ReadOnlySpan`1<char> directory);
    public sealed virtual void Reset();
    protected virtual bool ShouldIncludeEntry(FileSystemEntry& entry);
    protected virtual bool ShouldRecurseIntoEntry(FileSystemEntry& entry);
    protected abstract virtual TResult TransformEntry(FileSystemEntry& entry);
}
public static class System.IO.Enumeration.FileSystemName : object {
    public static bool MatchesSimpleExpression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    public static bool MatchesWin32Expression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    public static string TranslateWin32Expression(string expression);
}
public class System.IO.EnumerationOptions : object {
    public FileAttributes AttributesToSkip { get; public set; }
    public int BufferSize { get; public set; }
    public bool IgnoreInaccessible { get; public set; }
    public MatchCasing MatchCasing { get; public set; }
    public MatchType MatchType { get; public set; }
    public bool RecurseSubdirectories { get; public set; }
    public bool ReturnSpecialDirectories { get; public set; }
    public FileAttributes get_AttributesToSkip();
    public void set_AttributesToSkip(FileAttributes value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public bool get_IgnoreInaccessible();
    public void set_IgnoreInaccessible(bool value);
    public MatchCasing get_MatchCasing();
    public void set_MatchCasing(MatchCasing value);
    public MatchType get_MatchType();
    public void set_MatchType(MatchType value);
    public bool get_RecurseSubdirectories();
    public void set_RecurseSubdirectories(bool value);
    public bool get_ReturnSpecialDirectories();
    public void set_ReturnSpecialDirectories(bool value);
}
public class System.IO.ErrorEventArgs : EventArgs {
    public ErrorEventArgs(Exception exception);
    public virtual Exception GetException();
}
public class System.IO.ErrorEventHandler : MulticastDelegate {
    public ErrorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ErrorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ErrorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.IO.File : object {
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    public static Task AppendAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    public static StreamWriter CreateText(string path);
    public static void Decrypt(string path);
    public static void Delete(string path);
    public static void Encrypt(string path);
    public static bool Exists(string path);
    public static FileAttributes GetAttributes(string path);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static void Move(string sourceFileName, string destFileName);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    public static FileStream OpenRead(string path);
    public static StreamReader OpenText(string path);
    public static FileStream OpenWrite(string path);
    public static Byte[] ReadAllBytes(string path);
    public static Task`1<Byte[]> ReadAllBytesAsync(string path, CancellationToken cancellationToken);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    public static Task`1<String[]> ReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, CancellationToken cancellationToken);
    public static string ReadAllText(string path);
    public static string ReadAllText(string path, Encoding encoding);
    public static Task`1<string> ReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<string> ReadAllTextAsync(string path, CancellationToken cancellationToken);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static void WriteAllBytes(string path, Byte[] bytes);
    public static Task WriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static void WriteAllLines(string path, String[] contents);
    public static void WriteAllLines(string path, String[] contents, Encoding encoding);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static void WriteAllText(string path, string contents);
    public static void WriteAllText(string path, string contents, Encoding encoding);
    public static Task WriteAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess ReadWrite;
    public static FileAccess Write;
}
[FlagsAttribute]
public enum System.IO.FileAttributes : Enum {
    public int value__;
    public static FileAttributes Archive;
    public static FileAttributes Compressed;
    public static FileAttributes Device;
    public static FileAttributes Directory;
    public static FileAttributes Encrypted;
    public static FileAttributes Hidden;
    public static FileAttributes IntegrityStream;
    public static FileAttributes Normal;
    public static FileAttributes NoScrubData;
    public static FileAttributes NotContentIndexed;
    public static FileAttributes Offline;
    public static FileAttributes ReadOnly;
    public static FileAttributes ReparsePoint;
    public static FileAttributes SparseFile;
    public static FileAttributes System;
    public static FileAttributes Temporary;
}
public class System.IO.FileInfo : FileSystemInfo {
    public DirectoryInfo Directory { get; }
    public string DirectoryName { get; }
    public bool Exists { get; }
    public bool IsReadOnly { get; public set; }
    public long Length { get; }
    public string Name { get; }
    public FileInfo(string fileName);
    public DirectoryInfo get_Directory();
    public string get_DirectoryName();
    public virtual bool get_Exists();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public long get_Length();
    public virtual string get_Name();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    public StreamWriter CreateText();
    public void Decrypt();
    public virtual void Delete();
    public void Encrypt();
    public void MoveTo(string destFileName);
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    public FileStream OpenRead();
    public StreamReader OpenText();
    public FileStream OpenWrite();
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public virtual string ToString();
}
public class System.IO.FileLoadException : IOException {
    public string FileName { get; }
    public string FusionLog { get; }
    public string Message { get; }
    protected FileLoadException(SerializationInfo info, StreamingContext context);
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    public string get_FileName();
    public string get_FusionLog();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode Append;
    public static FileMode Create;
    public static FileMode CreateNew;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
}
public class System.IO.FileNotFoundException : IOException {
    public string FileName { get; }
    public string FusionLog { get; }
    public string Message { get; }
    protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    public string get_FileName();
    public string get_FusionLog();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions Asynchronous;
    public static FileOptions DeleteOnClose;
    public static FileOptions Encrypted;
    public static FileOptions None;
    public static FileOptions RandomAccess;
    public static FileOptions SequentialScan;
    public static FileOptions WriteThrough;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare Delete;
    public static FileShare Inheritable;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare ReadWrite;
    public static FileShare Write;
}
public class System.IO.FileStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public string Name { get; }
    public long Position { get; public set; }
    public SafeFileHandle SafeFileHandle { get; }
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual IntPtr get_Handle();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    public virtual string get_Name();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual override void Finalize();
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Lock(long position, long length);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Unlock(long position, long length);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public class System.IO.FileSystemEventArgs : EventArgs {
    public WatcherChangeTypes ChangeType { get; }
    public string FullPath { get; }
    public string Name { get; }
    public FileSystemEventArgs(WatcherChangeTypes changeType, string directory, string name);
    public WatcherChangeTypes get_ChangeType();
    public string get_FullPath();
    public string get_Name();
}
public class System.IO.FileSystemEventHandler : MulticastDelegate {
    public FileSystemEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FileSystemEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FileSystemEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.IO.FileSystemInfo : MarshalByRefObject {
    protected string FullPath;
    protected string OriginalPath;
    public FileAttributes Attributes { get; public set; }
    public DateTime CreationTime { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public bool Exists { get; }
    public string Extension { get; }
    public string FullName { get; }
    public DateTime LastAccessTime { get; public set; }
    public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    public string Name { get; }
    protected FileSystemInfo(SerializationInfo info, StreamingContext context);
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public abstract virtual bool get_Exists();
    public string get_Extension();
    public virtual string get_FullName();
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    public abstract virtual string get_Name();
    public abstract virtual void Delete();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void Refresh();
    public virtual string ToString();
}
[DefaultEventAttribute("Changed")]
public class System.IO.FileSystemWatcher : Component {
    [DefaultValueAttribute("False")]
public bool EnableRaisingEvents { get; public set; }
    [DefaultValueAttribute("*.*")]
[SettingsBindableAttribute("True")]
public string Filter { get; public set; }
    [DefaultValueAttribute("False")]
public bool IncludeSubdirectories { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("8192")]
public int InternalBufferSize { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public NotifyFilters NotifyFilter { get; public set; }
    [DefaultValueAttribute("")]
[SettingsBindableAttribute("True")]
public string Path { get; public set; }
    [BrowsableAttribute("False")]
public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public FileSystemWatcher(string path);
    public FileSystemWatcher(string path, string filter);
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public string get_Filter();
    public void set_Filter(string value);
    public bool get_IncludeSubdirectories();
    public void set_IncludeSubdirectories(bool value);
    public int get_InternalBufferSize();
    public void set_InternalBufferSize(int value);
    public NotifyFilters get_NotifyFilter();
    public void set_NotifyFilter(NotifyFilters value);
    public string get_Path();
    public void set_Path(string value);
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public void add_Changed(FileSystemEventHandler value);
    public void remove_Changed(FileSystemEventHandler value);
    public void add_Created(FileSystemEventHandler value);
    public void remove_Created(FileSystemEventHandler value);
    public void add_Deleted(FileSystemEventHandler value);
    public void remove_Deleted(FileSystemEventHandler value);
    public void add_Error(ErrorEventHandler value);
    public void remove_Error(ErrorEventHandler value);
    public void add_Renamed(RenamedEventHandler value);
    public void remove_Renamed(RenamedEventHandler value);
    public sealed virtual void BeginInit();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    protected void OnChanged(FileSystemEventArgs e);
    protected void OnCreated(FileSystemEventArgs e);
    protected void OnDeleted(FileSystemEventArgs e);
    protected void OnError(ErrorEventArgs e);
    protected void OnRenamed(RenamedEventArgs e);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout);
}
public enum System.IO.HandleInheritability : Enum {
    public int value__;
    public static HandleInheritability Inheritable;
    public static HandleInheritability None;
}
public class System.IO.InternalBufferOverflowException : SystemException {
    protected InternalBufferOverflowException(SerializationInfo info, StreamingContext context);
    public InternalBufferOverflowException(string message);
    public InternalBufferOverflowException(string message, Exception inner);
}
public class System.IO.InvalidDataException : SystemException {
    public InvalidDataException(string message);
    public InvalidDataException(string message, Exception innerException);
}
public class System.IO.IOException : SystemException {
    protected IOException(SerializationInfo info, StreamingContext context);
    public IOException(string message);
    public IOException(string message, Exception innerException);
    public IOException(string message, int hresult);
}
public interface System.IO.IsolatedStorage.INormalizeForIsolatedStorage {
    public abstract virtual object Normalize();
}
public abstract class System.IO.IsolatedStorage.IsolatedStorage : MarshalByRefObject {
    public object ApplicationIdentity { get; }
    public object AssemblyIdentity { get; }
    public long AvailableFreeSpace { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("IsolatedStorage.CurrentSize has been deprecated because it is not CLS Compliant.  To get the current size use IsolatedStorage.UsedSize")]
public ulong CurrentSize { get; }
    public object DomainIdentity { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("IsolatedStorage.MaximumSize has been deprecated because it is not CLS Compliant.  To get the maximum size use IsolatedStorage.Quota")]
public ulong MaximumSize { get; }
    public long Quota { get; }
    public IsolatedStorageScope Scope { get; }
    protected char SeparatorExternal { get; }
    protected char SeparatorInternal { get; }
    public long UsedSize { get; }
    public object get_ApplicationIdentity();
    public object get_AssemblyIdentity();
    public virtual long get_AvailableFreeSpace();
    public virtual ulong get_CurrentSize();
    public object get_DomainIdentity();
    public virtual ulong get_MaximumSize();
    public virtual long get_Quota();
    public IsolatedStorageScope get_Scope();
    protected virtual char get_SeparatorExternal();
    protected virtual char get_SeparatorInternal();
    public virtual long get_UsedSize();
    public virtual bool IncreaseQuotaTo(long newQuotaSize);
    protected void InitStore(IsolatedStorageScope scope, Type appEvidenceType);
    protected void InitStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);
    public abstract virtual void Remove();
}
public class System.IO.IsolatedStorage.IsolatedStorageException : Exception {
    protected IsolatedStorageException(SerializationInfo info, StreamingContext context);
    public IsolatedStorageException(string message);
    public IsolatedStorageException(string message, Exception inner);
}
public class System.IO.IsolatedStorage.IsolatedStorageFile : IsolatedStorage {
    public long AvailableFreeSpace { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("IsolatedStorageFile.CurrentSize has been deprecated because it is not CLS Compliant.  To get the current size use IsolatedStorageFile.UsedSize")]
public ulong CurrentSize { get; }
    public static bool IsEnabled { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("IsolatedStorageFile.MaximumSize has been deprecated because it is not CLS Compliant.  To get the maximum size use IsolatedStorageFile.Quota")]
public ulong MaximumSize { get; }
    public long Quota { get; }
    public long UsedSize { get; }
    public virtual long get_AvailableFreeSpace();
    public virtual ulong get_CurrentSize();
    public static bool get_IsEnabled();
    public virtual ulong get_MaximumSize();
    public virtual long get_Quota();
    public virtual long get_UsedSize();
    public void Close();
    public void CopyFile(string sourceFileName, string destinationFileName);
    public void CopyFile(string sourceFileName, string destinationFileName, bool overwrite);
    public void CreateDirectory(string dir);
    public IsolatedStorageFileStream CreateFile(string path);
    public void DeleteDirectory(string dir);
    public void DeleteFile(string file);
    public bool DirectoryExists(string path);
    public sealed virtual void Dispose();
    public bool FileExists(string path);
    public DateTimeOffset GetCreationTime(string path);
    public String[] GetDirectoryNames();
    public String[] GetDirectoryNames(string searchPattern);
    public static IEnumerator GetEnumerator(IsolatedStorageScope scope);
    public String[] GetFileNames();
    public String[] GetFileNames(string searchPattern);
    public DateTimeOffset GetLastAccessTime(string path);
    public DateTimeOffset GetLastWriteTime(string path);
    public static IsolatedStorageFile GetMachineStoreForApplication();
    public static IsolatedStorageFile GetMachineStoreForAssembly();
    public static IsolatedStorageFile GetMachineStoreForDomain();
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, object applicationIdentity);
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity);
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type applicationEvidenceType);
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);
    public static IsolatedStorageFile GetUserStoreForApplication();
    public static IsolatedStorageFile GetUserStoreForAssembly();
    public static IsolatedStorageFile GetUserStoreForDomain();
    public static IsolatedStorageFile GetUserStoreForSite();
    public virtual bool IncreaseQuotaTo(long newQuotaSize);
    public void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName);
    public void MoveFile(string sourceFileName, string destinationFileName);
    public IsolatedStorageFileStream OpenFile(string path, FileMode mode);
    public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access);
    public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access, FileShare share);
    public virtual void Remove();
    public static void Remove(IsolatedStorageScope scope);
}
public class System.IO.IsolatedStorage.IsolatedStorageFileStream : FileStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use IsolatedStorageFileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SafeFileHandle SafeFileHandle { get; }
    public IsolatedStorageFileStream(string path, FileMode mode);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, IsolatedStorageFile isf);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual IntPtr get_Handle();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Lock(long position, long length);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Unlock(long position, long length);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
[FlagsAttribute]
public enum System.IO.IsolatedStorage.IsolatedStorageScope : Enum {
    public int value__;
    public static IsolatedStorageScope Application;
    public static IsolatedStorageScope Assembly;
    public static IsolatedStorageScope Domain;
    public static IsolatedStorageScope Machine;
    public static IsolatedStorageScope None;
    public static IsolatedStorageScope Roaming;
    public static IsolatedStorageScope User;
}
public enum System.IO.MatchCasing : Enum {
    public int value__;
    public static MatchCasing CaseInsensitive;
    public static MatchCasing CaseSensitive;
    public static MatchCasing PlatformDefault;
}
public enum System.IO.MatchType : Enum {
    public int value__;
    public static MatchType Simple;
    public static MatchType Win32;
}
public class System.IO.MemoryMappedFiles.MemoryMappedFile : object {
    public SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }
    public SafeMemoryMappedFileHandle get_SafeMemoryMappedFileHandle();
    public static MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, HandleInheritability inheritability, bool leaveOpen);
    public static MemoryMappedFile CreateFromFile(string path);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity, MemoryMappedFileAccess access);
    public static MemoryMappedFile CreateNew(string mapName, long capacity);
    public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access);
    public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability);
    public static MemoryMappedFile CreateOrOpen(string mapName, long capacity);
    public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access);
    public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability);
    public MemoryMappedViewAccessor CreateViewAccessor();
    public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size);
    public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size, MemoryMappedFileAccess access);
    public MemoryMappedViewStream CreateViewStream();
    public MemoryMappedViewStream CreateViewStream(long offset, long size);
    public MemoryMappedViewStream CreateViewStream(long offset, long size, MemoryMappedFileAccess access);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static MemoryMappedFile OpenExisting(string mapName);
    public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights);
    public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights, HandleInheritability inheritability);
}
public enum System.IO.MemoryMappedFiles.MemoryMappedFileAccess : Enum {
    public int value__;
    public static MemoryMappedFileAccess CopyOnWrite;
    public static MemoryMappedFileAccess Read;
    public static MemoryMappedFileAccess ReadExecute;
    public static MemoryMappedFileAccess ReadWrite;
    public static MemoryMappedFileAccess ReadWriteExecute;
    public static MemoryMappedFileAccess Write;
}
[FlagsAttribute]
public enum System.IO.MemoryMappedFiles.MemoryMappedFileOptions : Enum {
    public int value__;
    public static MemoryMappedFileOptions DelayAllocatePages;
    public static MemoryMappedFileOptions None;
}
[FlagsAttribute]
public enum System.IO.MemoryMappedFiles.MemoryMappedFileRights : Enum {
    public int value__;
    public static MemoryMappedFileRights AccessSystemSecurity;
    public static MemoryMappedFileRights ChangePermissions;
    public static MemoryMappedFileRights CopyOnWrite;
    public static MemoryMappedFileRights Delete;
    public static MemoryMappedFileRights Execute;
    public static MemoryMappedFileRights FullControl;
    public static MemoryMappedFileRights Read;
    public static MemoryMappedFileRights ReadExecute;
    public static MemoryMappedFileRights ReadPermissions;
    public static MemoryMappedFileRights ReadWrite;
    public static MemoryMappedFileRights ReadWriteExecute;
    public static MemoryMappedFileRights TakeOwnership;
    public static MemoryMappedFileRights Write;
}
public class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor : UnmanagedMemoryAccessor {
    public long PointerOffset { get; }
    public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle { get; }
    public long get_PointerOffset();
    public SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle();
    protected virtual void Dispose(bool disposing);
    public void Flush();
}
public class System.IO.MemoryMappedFiles.MemoryMappedViewStream : UnmanagedMemoryStream {
    public long PointerOffset { get; }
    public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle { get; }
    public long get_PointerOffset();
    public SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual void SetLength(long value);
}
public class System.IO.MemoryStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public MemoryStream(int capacity);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> destination);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> source);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
[FlagsAttribute]
public enum System.IO.NotifyFilters : Enum {
    public int value__;
    public static NotifyFilters Attributes;
    public static NotifyFilters CreationTime;
    public static NotifyFilters DirectoryName;
    public static NotifyFilters FileName;
    public static NotifyFilters LastAccess;
    public static NotifyFilters LastWrite;
    public static NotifyFilters Security;
    public static NotifyFilters Size;
}
public static class System.IO.Path : object {
    public static char AltDirectorySeparatorChar;
    public static char DirectorySeparatorChar;
    [ObsoleteAttribute("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    public static char PathSeparator;
    public static char VolumeSeparatorChar;
    public static string ChangeExtension(string path, string extension);
    public static string Combine(string path1, string path2);
    public static string Combine(string path1, string path2, string path3);
    public static string Combine(string path1, string path2, string path3, string path4);
    public static string Combine(String[] paths);
    public static ReadOnlySpan`1<char> GetDirectoryName(ReadOnlySpan`1<char> path);
    public static string GetDirectoryName(string path);
    public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> path);
    public static string GetExtension(string path);
    public static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path);
    public static string GetFileName(string path);
    public static ReadOnlySpan`1<char> GetFileNameWithoutExtension(ReadOnlySpan`1<char> path);
    public static string GetFileNameWithoutExtension(string path);
    public static string GetFullPath(string path);
    public static string GetFullPath(string path, string basePath);
    public static Char[] GetInvalidFileNameChars();
    public static Char[] GetInvalidPathChars();
    public static ReadOnlySpan`1<char> GetPathRoot(ReadOnlySpan`1<char> path);
    public static string GetPathRoot(string path);
    public static string GetRandomFileName();
    public static string GetRelativePath(string relativeTo, string path);
    public static string GetTempFileName();
    public static string GetTempPath();
    public static bool HasExtension(ReadOnlySpan`1<char> path);
    public static bool HasExtension(string path);
    public static bool IsPathFullyQualified(ReadOnlySpan`1<char> path);
    public static bool IsPathFullyQualified(string path);
    public static bool IsPathRooted(ReadOnlySpan`1<char> path);
    public static bool IsPathRooted(string path);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, Span`1<char> destination, Int32& charsWritten);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, Span`1<char> destination, Int32& charsWritten);
}
public class System.IO.PathTooLongException : IOException {
    protected PathTooLongException(SerializationInfo info, StreamingContext context);
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
}
public class System.IO.Pipes.AnonymousPipeClientStream : PipeStream {
    unknown PipeTransmissionMode ReadMode {public set; }
    public PipeTransmissionMode TransmissionMode { get; }
    public AnonymousPipeClientStream(PipeDirection direction, SafePipeHandle safePipeHandle);
    public AnonymousPipeClientStream(PipeDirection direction, string pipeHandleAsString);
    public AnonymousPipeClientStream(string pipeHandleAsString);
    public virtual void set_ReadMode(PipeTransmissionMode value);
    public virtual PipeTransmissionMode get_TransmissionMode();
}
public class System.IO.Pipes.AnonymousPipeServerStream : PipeStream {
    public SafePipeHandle ClientSafePipeHandle { get; }
    unknown PipeTransmissionMode ReadMode {public set; }
    public PipeTransmissionMode TransmissionMode { get; }
    public AnonymousPipeServerStream(PipeDirection direction);
    public AnonymousPipeServerStream(PipeDirection direction, SafePipeHandle serverSafePipeHandle, SafePipeHandle clientSafePipeHandle);
    public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability);
    public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize);
    public SafePipeHandle get_ClientSafePipeHandle();
    public virtual void set_ReadMode(PipeTransmissionMode value);
    public virtual PipeTransmissionMode get_TransmissionMode();
    protected virtual void Dispose(bool disposing);
    public void DisposeLocalCopyOfClientHandle();
    public string GetClientHandleAsString();
}
public class System.IO.Pipes.NamedPipeClientStream : PipeStream {
    public int NumberOfServerInstances { get; }
    public NamedPipeClientStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle);
    public NamedPipeClientStream(string pipeName);
    public NamedPipeClientStream(string serverName, string pipeName);
    public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction);
    public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options);
    public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel);
    public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability);
    public int get_NumberOfServerInstances();
    protected internal virtual void CheckPipePropertyOperations();
    public void Connect();
    public void Connect(int timeout);
    public Task ConnectAsync();
    public Task ConnectAsync(int timeout);
    public Task ConnectAsync(int timeout, CancellationToken cancellationToken);
    public Task ConnectAsync(CancellationToken cancellationToken);
}
public class System.IO.Pipes.NamedPipeServerStream : PipeStream {
    public static int MaxAllowedServerInstances;
    public NamedPipeServerStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle);
    public NamedPipeServerStream(string pipeName);
    public NamedPipeServerStream(string pipeName, PipeDirection direction);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize);
    public IAsyncResult BeginWaitForConnection(AsyncCallback callback, object state);
    public void Disconnect();
    public void EndWaitForConnection(IAsyncResult asyncResult);
    public string GetImpersonationUserName();
    public void RunAsClient(PipeStreamImpersonationWorker impersonationWorker);
    public void WaitForConnection();
    public Task WaitForConnectionAsync();
    public Task WaitForConnectionAsync(CancellationToken cancellationToken);
}
public enum System.IO.Pipes.PipeDirection : Enum {
    public int value__;
    public static PipeDirection In;
    public static PipeDirection InOut;
    public static PipeDirection Out;
}
[FlagsAttribute]
public enum System.IO.Pipes.PipeOptions : Enum {
    public int value__;
    public static PipeOptions Asynchronous;
    public static PipeOptions CurrentUserOnly;
    public static PipeOptions None;
    public static PipeOptions WriteThrough;
}
public abstract class System.IO.Pipes.PipeStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int InBufferSize { get; }
    public bool IsAsync { get; }
    public bool IsConnected { get; protected set; }
    protected bool IsHandleExposed { get; }
    public bool IsMessageComplete { get; }
    public long Length { get; }
    public int OutBufferSize { get; }
    public long Position { get; public set; }
    public PipeTransmissionMode ReadMode { get; public set; }
    public SafePipeHandle SafePipeHandle { get; }
    public PipeTransmissionMode TransmissionMode { get; }
    protected PipeStream(PipeDirection direction, int bufferSize);
    protected PipeStream(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual int get_InBufferSize();
    public bool get_IsAsync();
    public bool get_IsConnected();
    protected void set_IsConnected(bool value);
    protected bool get_IsHandleExposed();
    public bool get_IsMessageComplete();
    public virtual long get_Length();
    public virtual int get_OutBufferSize();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual PipeTransmissionMode get_ReadMode();
    public virtual void set_ReadMode(PipeTransmissionMode value);
    public SafePipeHandle get_SafePipeHandle();
    public virtual PipeTransmissionMode get_TransmissionMode();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    protected internal virtual void CheckPipePropertyOperations();
    protected internal void CheckReadOperations();
    protected internal void CheckWriteOperations();
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    protected void InitializeHandle(SafePipeHandle handle, bool isExposed, bool isAsync);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public void WaitForPipeDrain();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public class System.IO.Pipes.PipeStreamImpersonationWorker : MulticastDelegate {
    public PipeStreamImpersonationWorker(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.IO.Pipes.PipeTransmissionMode : Enum {
    public int value__;
    public static PipeTransmissionMode Byte;
    public static PipeTransmissionMode Message;
}
public class System.IO.RenamedEventArgs : FileSystemEventArgs {
    public string OldFullPath { get; }
    public string OldName { get; }
    public RenamedEventArgs(WatcherChangeTypes changeType, string directory, string name, string oldName);
    public string get_OldFullPath();
    public string get_OldName();
}
public class System.IO.RenamedEventHandler : MulticastDelegate {
    public RenamedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RenamedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RenamedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption AllDirectories;
    public static SearchOption TopDirectoryOnly;
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public static Stream Synchronized(Stream stream);
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public class System.IO.StreamReader : TextReader {
    public static StreamReader Null;
    public Stream BaseStream { get; }
    public Encoding CurrentEncoding { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public virtual Stream get_BaseStream();
    public virtual Encoding get_CurrentEncoding();
    public bool get_EndOfStream();
    public virtual void Close();
    public void DiscardBufferedData();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Span`1<char> buffer);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
}
public class System.IO.StreamWriter : TextWriter {
    public static StreamWriter Null;
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    public Encoding Encoding { get; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    public virtual Encoding get_Encoding();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(string value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(string value);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(string value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(string value);
}
public class System.IO.StringReader : TextReader {
    public StringReader(string s);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual int ReadBlock(Span`1<char> buffer);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
}
public class System.IO.StringWriter : TextWriter {
    public Encoding Encoding { get; }
    public StringWriter(IFormatProvider formatProvider);
    public StringWriter(StringBuilder sb);
    public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
    public virtual Encoding get_Encoding();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Task FlushAsync();
    public virtual StringBuilder GetStringBuilder();
    public virtual string ToString();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(string value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(string value);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(string value);
}
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Span`1<char> buffer);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
    public static TextReader Synchronized(TextReader reader);
}
public abstract class System.IO.TextWriter : MarshalByRefObject {
    protected Char[] CoreNewLine;
    public static TextWriter Null;
    public Encoding Encoding { get; }
    public IFormatProvider FormatProvider { get; }
    public string NewLine { get; public set; }
    protected TextWriter(IFormatProvider formatProvider);
    public abstract virtual Encoding get_Encoding();
    public virtual IFormatProvider get_FormatProvider();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual Task FlushAsync();
    public static TextWriter Synchronized(TextWriter writer);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(float value);
    public virtual void Write(string value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual Task WriteAsync(char value);
    public Task WriteAsync(Char[] buffer);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(string value);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public Task WriteLineAsync(Char[] buffer);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(string value);
}
public class System.IO.UnmanagedMemoryAccessor : object {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Capacity { get; }
    protected bool IsOpen { get; }
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public bool get_CanRead();
    public bool get_CanWrite();
    public long get_Capacity();
    protected bool get_IsOpen();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public int ReadArray(long position, T[] array, int offset, int count);
    public bool ReadBoolean(long position);
    public byte ReadByte(long position);
    public char ReadChar(long position);
    public decimal ReadDecimal(long position);
    public double ReadDouble(long position);
    public short ReadInt16(long position);
    public int ReadInt32(long position);
    public long ReadInt64(long position);
    [CLSCompliantAttribute("False")]
public sbyte ReadSByte(long position);
    public float ReadSingle(long position);
    [CLSCompliantAttribute("False")]
public ushort ReadUInt16(long position);
    [CLSCompliantAttribute("False")]
public UInt32 ReadUInt32(long position);
    [CLSCompliantAttribute("False")]
public ulong ReadUInt64(long position);
    public void Read(long position, T& structure);
    public void Write(long position, bool value);
    public void Write(long position, byte value);
    public void Write(long position, char value);
    public void Write(long position, decimal value);
    public void Write(long position, double value);
    public void Write(long position, short value);
    public void Write(long position, int value);
    public void Write(long position, long value);
    [CLSCompliantAttribute("False")]
public void Write(long position, sbyte value);
    public void Write(long position, float value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ushort value);
    [CLSCompliantAttribute("False")]
public void Write(long position, UInt32 value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ulong value);
    public void WriteArray(long position, T[] array, int offset, int count);
    public void Write(long position, T& structure);
}
public class System.IO.UnmanagedMemoryStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Capacity { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public long get_Capacity();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Byte* get_PositionPointer();
    public void set_PositionPointer(Byte* value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> destination);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> source);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public class System.IO.WaitForChangedResult : ValueType {
    private object _dummy;
    public WatcherChangeTypes ChangeType { get; public set; }
    public string Name { get; public set; }
    public string OldName { get; public set; }
    public bool TimedOut { get; public set; }
    public WatcherChangeTypes get_ChangeType();
    public void set_ChangeType(WatcherChangeTypes value);
    public string get_Name();
    public void set_Name(string value);
    public string get_OldName();
    public void set_OldName(string value);
    public bool get_TimedOut();
    public void set_TimedOut(bool value);
}
[FlagsAttribute]
public enum System.IO.WatcherChangeTypes : Enum {
    public int value__;
    public static WatcherChangeTypes All;
    public static WatcherChangeTypes Changed;
    public static WatcherChangeTypes Created;
    public static WatcherChangeTypes Deleted;
    public static WatcherChangeTypes Renamed;
}
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public interface System.IObserver`1 {
    public abstract virtual void OnCompleted();
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnNext(T value);
}
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
public interface System.IServiceProvider {
    public abstract virtual object GetService(Type serviceType);
}
public class System.Lazy`1 : object {
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(T value);
    public bool get_IsValueCreated();
    public T get_Value();
    public virtual string ToString();
}
public class System.Lazy`2 : Lazy`1<T> {
    public TMetadata Metadata { get; }
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, bool isThreadSafe);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode);
    public Lazy`2(TMetadata metadata);
    public Lazy`2(TMetadata metadata, bool isThreadSafe);
    public Lazy`2(TMetadata metadata, LazyThreadSafetyMode mode);
    public TMetadata get_Metadata();
}
public class System.LdapStyleUriParser : UriParser {
}
[ExtensionAttribute]
public static class System.Linq.Enumerable : object {
    [ExtensionAttribute]
public static TSource Aggregate(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Append(IEnumerable`1<TSource> source, TSource element);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static decimal Average(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Average(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static decimal Average(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static float Average(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Cast(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Concat(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(IEnumerable`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAt(IEnumerable`1<TSource> source, int index);
    public static IEnumerable`1<TResult> Empty();
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource LastOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Last(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static decimal Max(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static double Max(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static int Max(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static long Max(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Max(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<int> Max(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<long> Max(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Max(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Max(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static TSource Max(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static decimal Max(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static double Max(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static int Max(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static long Max(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static float Max(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static TResult Max(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static decimal Min(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static double Min(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static int Min(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static long Min(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Min(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<int> Min(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<long> Min(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Min(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Min(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static TSource Min(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static decimal Min(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static double Min(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static int Min(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static long Min(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static float Min(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static TResult Min(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> OfType(IEnumerable source);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element);
    public static IEnumerable`1<int> Range(int start, int count);
    public static IEnumerable`1<TResult> Repeat(TResult element, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Reverse(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipLast(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Skip(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static decimal Sum(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static double Sum(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static int Sum(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static long Sum(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Sum(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static decimal Sum(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static double Sum(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static int Sum(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static long Sum(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static float Sum(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeLast(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Take(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource[] ToArray(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static HashSet`1<TSource> ToHashSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static HashSet`1<TSource> ToHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static List`1<TSource> ToList(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
}
public abstract class System.Linq.EnumerableExecutor : object {
}
public class System.Linq.EnumerableExecutor`1 : EnumerableExecutor {
    public EnumerableExecutor`1(Expression expression);
}
public abstract class System.Linq.EnumerableQuery : object {
}
public class System.Linq.EnumerableQuery`1 : EnumerableQuery {
    private Type System.Linq.IQueryable.ElementType { get; }
    private Expression System.Linq.IQueryable.Expression { get; }
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    public EnumerableQuery`1(IEnumerable`1<T> enumerable);
    public EnumerableQuery`1(Expression expression);
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IQueryable System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override IQueryable`1<S> System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override object System.Linq.IQueryProvider.Execute(Expression expression);
    private sealed virtual override S System.Linq.IQueryProvider.Execute(Expression expression);
    public virtual string ToString();
}
public class System.Linq.Expressions.BinaryExpression : Expression {
    public bool CanReduce { get; }
    public LambdaExpression Conversion { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public Expression Left { get; }
    public MethodInfo Method { get; }
    public Expression Right { get; }
    public virtual bool get_CanReduce();
    public LambdaExpression get_Conversion();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    public Expression get_Left();
    public MethodInfo get_Method();
    public Expression get_Right();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right);
}
public class System.Linq.Expressions.BlockExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public ExpressionType NodeType { get; }
    public Expression Result { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Result();
    public virtual Type get_Type();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public BlockExpression Update(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
}
public class System.Linq.Expressions.CatchBlock : object {
    public Expression Body { get; }
    public Expression Filter { get; }
    public Type Test { get; }
    public ParameterExpression Variable { get; }
    public Expression get_Body();
    public Expression get_Filter();
    public Type get_Test();
    public ParameterExpression get_Variable();
    public virtual string ToString();
    public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body);
}
public class System.Linq.Expressions.ConditionalExpression : Expression {
    public Expression IfFalse { get; }
    public Expression IfTrue { get; }
    public ExpressionType NodeType { get; }
    public Expression Test { get; }
    public Type Type { get; }
    public Expression get_IfFalse();
    public Expression get_IfTrue();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Test();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse);
}
public class System.Linq.Expressions.ConstantExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public object Value { get; }
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public object get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.DebugInfoExpression : Expression {
    public SymbolDocumentInfo Document { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public bool IsClear { get; }
    public ExpressionType NodeType { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public Type Type { get; }
    public SymbolDocumentInfo get_Document();
    public virtual int get_EndColumn();
    public virtual int get_EndLine();
    public virtual bool get_IsClear();
    public sealed virtual ExpressionType get_NodeType();
    public virtual int get_StartColumn();
    public virtual int get_StartLine();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.DefaultExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.DynamicExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public CallSiteBinder Binder { get; }
    public Type DelegateType { get; }
    public ExpressionType NodeType { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public CallSiteBinder get_Binder();
    public sealed virtual Type get_DelegateType();
    public sealed virtual ExpressionType get_NodeType();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override object System.Linq.Expressions.IDynamicExpression.CreateCallSite();
    private sealed virtual override Expression System.Linq.Expressions.IDynamicExpression.Rewrite(Expression[] args);
    public DynamicExpression Update(IEnumerable`1<Expression> arguments);
}
public abstract class System.Linq.Expressions.DynamicExpressionVisitor : ExpressionVisitor {
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
}
public class System.Linq.Expressions.ElementInit : object {
    public MethodInfo AddMethod { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public MethodInfo get_AddMethod();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public virtual string ToString();
    public ElementInit Update(IEnumerable`1<Expression> arguments);
}
public abstract class System.Linq.Expressions.Expression : object {
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    [ObsoleteAttribute("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")]
protected Expression(ExpressionType nodeType, Type type);
    public virtual bool get_CanReduce();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public static BinaryExpression Add(Expression left, Expression right);
    public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddChecked(Expression left, Expression right);
    public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression And(Expression left, Expression right);
    public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAlso(Expression left, Expression right);
    public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes);
    public static IndexExpression ArrayAccess(Expression array, Expression[] indexes);
    public static MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes);
    public static BinaryExpression ArrayIndex(Expression array, Expression index);
    public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes);
    public static UnaryExpression ArrayLength(Expression array);
    public static BinaryExpression Assign(Expression left, Expression right);
    public static MemberAssignment Bind(MemberInfo member, Expression expression);
    public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression);
    public static BlockExpression Block(IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Expression arg0, Expression arg1);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static BlockExpression Block(Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Type type, Expression[] expressions);
    public static GotoExpression Break(LabelTarget target);
    public static GotoExpression Break(LabelTarget target, Expression value);
    public static GotoExpression Break(LabelTarget target, Expression value, Type type);
    public static GotoExpression Break(LabelTarget target, Type type);
    public static MethodCallExpression Call(Expression instance, MethodInfo method);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments);
    public static CatchBlock Catch(ParameterExpression variable, Expression body);
    public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter);
    public static CatchBlock Catch(Type type, Expression body);
    public static CatchBlock Catch(Type type, Expression body, Expression filter);
    public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document);
    public static BinaryExpression Coalesce(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public static ConstantExpression Constant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static GotoExpression Continue(LabelTarget target);
    public static GotoExpression Continue(LabelTarget target, Type type);
    public static UnaryExpression Convert(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ConvertChecked(Expression expression, Type type);
    public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
    public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public static UnaryExpression Decrement(Expression expression);
    public static UnaryExpression Decrement(Expression expression, MethodInfo method);
    public static DefaultExpression Default(Type type);
    public static BinaryExpression Divide(Expression left, Expression right);
    public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments);
    public static DefaultExpression Empty();
    public static BinaryExpression Equal(Expression left, Expression right);
    public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static MemberExpression Field(Expression expression, FieldInfo field);
    public static MemberExpression Field(Expression expression, string fieldName);
    public static MemberExpression Field(Expression expression, Type type, string fieldName);
    public static Type GetActionType(Type[] typeArgs);
    public static Type GetDelegateType(Type[] typeArgs);
    public static Type GetFuncType(Type[] typeArgs);
    public static GotoExpression Goto(LabelTarget target);
    public static GotoExpression Goto(LabelTarget target, Expression value);
    public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
    public static GotoExpression Goto(LabelTarget target, Type type);
    public static BinaryExpression GreaterThan(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
    public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static UnaryExpression Increment(Expression expression);
    public static UnaryExpression Increment(Expression expression, MethodInfo method);
    public static InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments);
    public static InvocationExpression Invoke(Expression expression, Expression[] arguments);
    public static UnaryExpression IsFalse(Expression expression);
    public static UnaryExpression IsFalse(Expression expression, MethodInfo method);
    public static UnaryExpression IsTrue(Expression expression);
    public static UnaryExpression IsTrue(Expression expression, MethodInfo method);
    public static LabelTarget Label();
    public static LabelExpression Label(LabelTarget target);
    public static LabelExpression Label(LabelTarget target, Expression defaultValue);
    public static LabelTarget Label(string name);
    public static LabelTarget Label(Type type);
    public static LabelTarget Label(Type type, string name);
    public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static BinaryExpression LeftShift(Expression left, Expression right);
    public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression LessThan(Expression left, Expression right);
    public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers);
    public static LoopExpression Loop(Expression body);
    public static LoopExpression Loop(Expression body, LabelTarget break);
    public static LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
    public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
    public static TryExpression MakeTry(Type type, Expression body, Expression finally, Expression fault, IEnumerable`1<CatchBlock> handlers);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method);
    public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings);
    public static BinaryExpression Modulo(Expression left, Expression right);
    public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Multiply(Expression left, Expression right);
    public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
    public static UnaryExpression Negate(Expression expression);
    public static UnaryExpression Negate(Expression expression, MethodInfo method);
    public static UnaryExpression NegateChecked(Expression expression);
    public static UnaryExpression NegateChecked(Expression expression, MethodInfo method);
    public static NewExpression New(ConstructorInfo constructor);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members);
    public static NewExpression New(ConstructorInfo constructor, Expression[] arguments);
    public static NewExpression New(Type type);
    public static NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds);
    public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds);
    public static NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers);
    public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers);
    public static UnaryExpression Not(Expression expression);
    public static UnaryExpression Not(Expression expression, MethodInfo method);
    public static BinaryExpression NotEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static UnaryExpression OnesComplement(Expression expression);
    public static UnaryExpression OnesComplement(Expression expression, MethodInfo method);
    public static BinaryExpression Or(Expression left, Expression right);
    public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression OrElse(Expression left, Expression right);
    public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
    public static ParameterExpression Parameter(Type type);
    public static ParameterExpression Parameter(Type type, string name);
    public static UnaryExpression PostDecrementAssign(Expression expression);
    public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostIncrementAssign(Expression expression);
    public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method);
    public static BinaryExpression Power(Expression left, Expression right);
    public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static UnaryExpression PreDecrementAssign(Expression expression);
    public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PreIncrementAssign(Expression expression);
    public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method);
    public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor);
    public static MemberExpression Property(Expression expression, PropertyInfo property);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments);
    public static MemberExpression Property(Expression expression, string propertyName);
    public static IndexExpression Property(Expression instance, string propertyName, Expression[] arguments);
    public static MemberExpression Property(Expression expression, Type type, string propertyName);
    public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName);
    public static UnaryExpression Quote(Expression expression);
    public virtual Expression Reduce();
    public Expression ReduceAndCheck();
    public Expression ReduceExtensions();
    public static BinaryExpression ReferenceEqual(Expression left, Expression right);
    public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
    public static UnaryExpression Rethrow();
    public static UnaryExpression Rethrow(Type type);
    public static GotoExpression Return(LabelTarget target);
    public static GotoExpression Return(LabelTarget target, Expression value);
    public static GotoExpression Return(LabelTarget target, Expression value, Type type);
    public static GotoExpression Return(LabelTarget target, Type type);
    public static BinaryExpression RightShift(Expression left, Expression right);
    public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static RuntimeVariablesExpression RuntimeVariables(IEnumerable`1<ParameterExpression> variables);
    public static RuntimeVariablesExpression RuntimeVariables(ParameterExpression[] variables);
    public static BinaryExpression Subtract(Expression left, Expression right);
    public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractChecked(Expression left, Expression right);
    public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, SwitchCase[] cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public static SwitchCase SwitchCase(Expression body, Expression[] testValues);
    public static SymbolDocumentInfo SymbolDocument(string fileName);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType);
    public static UnaryExpression Throw(Expression value);
    public static UnaryExpression Throw(Expression value, Type type);
    public virtual string ToString();
    public static TryExpression TryCatch(Expression body, CatchBlock[] handlers);
    public static TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers);
    public static TryExpression TryFault(Expression body, Expression fault);
    public static TryExpression TryFinally(Expression body, Expression finally);
    public static bool TryGetActionType(Type[] typeArgs, Type& actionType);
    public static bool TryGetFuncType(Type[] typeArgs, Type& funcType);
    public static UnaryExpression TypeAs(Expression expression, Type type);
    public static TypeBinaryExpression TypeEqual(Expression expression, Type type);
    public static TypeBinaryExpression TypeIs(Expression expression, Type type);
    public static UnaryExpression UnaryPlus(Expression expression);
    public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method);
    public static UnaryExpression Unbox(Expression expression, Type type);
    public static ParameterExpression Variable(Type type);
    public static ParameterExpression Variable(Type type, string name);
    protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.Expression`1 : LambdaExpression {
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TDelegate Compile();
    public TDelegate Compile(bool preferInterpretation);
    public TDelegate Compile(DebugInfoGenerator debugInfoGenerator);
    public Expression`1<TDelegate> Update(Expression body, IEnumerable`1<ParameterExpression> parameters);
}
public enum System.Linq.Expressions.ExpressionType : Enum {
    public int value__;
    public static ExpressionType Add;
    public static ExpressionType AddAssign;
    public static ExpressionType AddAssignChecked;
    public static ExpressionType AddChecked;
    public static ExpressionType And;
    public static ExpressionType AndAlso;
    public static ExpressionType AndAssign;
    public static ExpressionType ArrayIndex;
    public static ExpressionType ArrayLength;
    public static ExpressionType Assign;
    public static ExpressionType Block;
    public static ExpressionType Call;
    public static ExpressionType Coalesce;
    public static ExpressionType Conditional;
    public static ExpressionType Constant;
    public static ExpressionType Convert;
    public static ExpressionType ConvertChecked;
    public static ExpressionType DebugInfo;
    public static ExpressionType Decrement;
    public static ExpressionType Default;
    public static ExpressionType Divide;
    public static ExpressionType DivideAssign;
    public static ExpressionType Dynamic;
    public static ExpressionType Equal;
    public static ExpressionType ExclusiveOr;
    public static ExpressionType ExclusiveOrAssign;
    public static ExpressionType Extension;
    public static ExpressionType Goto;
    public static ExpressionType GreaterThan;
    public static ExpressionType GreaterThanOrEqual;
    public static ExpressionType Increment;
    public static ExpressionType Index;
    public static ExpressionType Invoke;
    public static ExpressionType IsFalse;
    public static ExpressionType IsTrue;
    public static ExpressionType Label;
    public static ExpressionType Lambda;
    public static ExpressionType LeftShift;
    public static ExpressionType LeftShiftAssign;
    public static ExpressionType LessThan;
    public static ExpressionType LessThanOrEqual;
    public static ExpressionType ListInit;
    public static ExpressionType Loop;
    public static ExpressionType MemberAccess;
    public static ExpressionType MemberInit;
    public static ExpressionType Modulo;
    public static ExpressionType ModuloAssign;
    public static ExpressionType Multiply;
    public static ExpressionType MultiplyAssign;
    public static ExpressionType MultiplyAssignChecked;
    public static ExpressionType MultiplyChecked;
    public static ExpressionType Negate;
    public static ExpressionType NegateChecked;
    public static ExpressionType New;
    public static ExpressionType NewArrayBounds;
    public static ExpressionType NewArrayInit;
    public static ExpressionType Not;
    public static ExpressionType NotEqual;
    public static ExpressionType OnesComplement;
    public static ExpressionType Or;
    public static ExpressionType OrAssign;
    public static ExpressionType OrElse;
    public static ExpressionType Parameter;
    public static ExpressionType PostDecrementAssign;
    public static ExpressionType PostIncrementAssign;
    public static ExpressionType Power;
    public static ExpressionType PowerAssign;
    public static ExpressionType PreDecrementAssign;
    public static ExpressionType PreIncrementAssign;
    public static ExpressionType Quote;
    public static ExpressionType RightShift;
    public static ExpressionType RightShiftAssign;
    public static ExpressionType RuntimeVariables;
    public static ExpressionType Subtract;
    public static ExpressionType SubtractAssign;
    public static ExpressionType SubtractAssignChecked;
    public static ExpressionType SubtractChecked;
    public static ExpressionType Switch;
    public static ExpressionType Throw;
    public static ExpressionType Try;
    public static ExpressionType TypeAs;
    public static ExpressionType TypeEqual;
    public static ExpressionType TypeIs;
    public static ExpressionType UnaryPlus;
    public static ExpressionType Unbox;
}
public abstract class System.Linq.Expressions.ExpressionVisitor : object {
    public ReadOnlyCollection`1<Expression> Visit(ReadOnlyCollection`1<Expression> nodes);
    public virtual Expression Visit(Expression node);
    public ReadOnlyCollection`1<T> VisitAndConvert(ReadOnlyCollection`1<T> nodes, string callerName);
    public T VisitAndConvert(T node, string callerName);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    public static ReadOnlyCollection`1<T> Visit(ReadOnlyCollection`1<T> nodes, Func`2<T, T> elementVisitor);
}
public class System.Linq.Expressions.GotoExpression : Expression {
    public GotoExpressionKind Kind { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Type Type { get; }
    public Expression Value { get; }
    public GotoExpressionKind get_Kind();
    public sealed virtual ExpressionType get_NodeType();
    public LabelTarget get_Target();
    public sealed virtual Type get_Type();
    public Expression get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public GotoExpression Update(LabelTarget target, Expression value);
}
public enum System.Linq.Expressions.GotoExpressionKind : Enum {
    public int value__;
    public static GotoExpressionKind Break;
    public static GotoExpressionKind Continue;
    public static GotoExpressionKind Goto;
    public static GotoExpressionKind Return;
}
public interface System.Linq.Expressions.IArgumentProvider {
    public int ArgumentCount { get; }
    public abstract virtual int get_ArgumentCount();
    public abstract virtual Expression GetArgument(int index);
}
public interface System.Linq.Expressions.IDynamicExpression {
    public Type DelegateType { get; }
    public abstract virtual Type get_DelegateType();
    public abstract virtual object CreateCallSite();
    public abstract virtual Expression Rewrite(Expression[] args);
}
public class System.Linq.Expressions.IndexExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public PropertyInfo Indexer { get; }
    public ExpressionType NodeType { get; }
    public Expression Object { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public PropertyInfo get_Indexer();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Object();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public IndexExpression Update(Expression object, IEnumerable`1<Expression> arguments);
}
public class System.Linq.Expressions.InvocationExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public Expression get_Expression();
    public sealed virtual ExpressionType get_NodeType();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public InvocationExpression Update(Expression expression, IEnumerable`1<Expression> arguments);
}
public class System.Linq.Expressions.LabelExpression : Expression {
    public Expression DefaultValue { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Type Type { get; }
    public Expression get_DefaultValue();
    public sealed virtual ExpressionType get_NodeType();
    public LabelTarget get_Target();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LabelExpression Update(LabelTarget target, Expression defaultValue);
}
public class System.Linq.Expressions.LabelTarget : object {
    public string Name { get; }
    public Type Type { get; }
    public string get_Name();
    public Type get_Type();
    public virtual string ToString();
}
public abstract class System.Linq.Expressions.LambdaExpression : Expression {
    public Expression Body { get; }
    public string Name { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Parameters { get; }
    public Type ReturnType { get; }
    public bool TailCall { get; }
    public Type Type { get; }
    public Expression get_Body();
    public string get_Name();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Parameters();
    public Type get_ReturnType();
    public bool get_TailCall();
    public sealed virtual Type get_Type();
    public Delegate Compile();
    public Delegate Compile(bool preferInterpretation);
    public Delegate Compile(DebugInfoGenerator debugInfoGenerator);
}
public class System.Linq.Expressions.ListInitExpression : Expression {
    public bool CanReduce { get; }
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    public NewExpression NewExpression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public virtual bool get_CanReduce();
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public NewExpression get_NewExpression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public ListInitExpression Update(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
}
public class System.Linq.Expressions.LoopExpression : Expression {
    public Expression Body { get; }
    public LabelTarget BreakLabel { get; }
    public LabelTarget ContinueLabel { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression get_Body();
    public LabelTarget get_BreakLabel();
    public LabelTarget get_ContinueLabel();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body);
}
public class System.Linq.Expressions.MemberAssignment : MemberBinding {
    public Expression Expression { get; }
    public Expression get_Expression();
    public MemberAssignment Update(Expression expression);
}
public abstract class System.Linq.Expressions.MemberBinding : object {
    public MemberBindingType BindingType { get; }
    public MemberInfo Member { get; }
    [ObsoleteAttribute("Do not use this constructor. It will be removed in future releases.")]
protected MemberBinding(MemberBindingType type, MemberInfo member);
    public MemberBindingType get_BindingType();
    public MemberInfo get_Member();
    public virtual string ToString();
}
public enum System.Linq.Expressions.MemberBindingType : Enum {
    public int value__;
    public static MemberBindingType Assignment;
    public static MemberBindingType ListBinding;
    public static MemberBindingType MemberBinding;
}
public class System.Linq.Expressions.MemberExpression : Expression {
    public Expression Expression { get; }
    public MemberInfo Member { get; }
    public ExpressionType NodeType { get; }
    public Expression get_Expression();
    public MemberInfo get_Member();
    public sealed virtual ExpressionType get_NodeType();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public MemberExpression Update(Expression expression);
}
public class System.Linq.Expressions.MemberInitExpression : Expression {
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    public bool CanReduce { get; }
    public NewExpression NewExpression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public virtual bool get_CanReduce();
    public NewExpression get_NewExpression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public MemberInitExpression Update(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
}
public class System.Linq.Expressions.MemberListBinding : MemberBinding {
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public MemberListBinding Update(IEnumerable`1<ElementInit> initializers);
}
public class System.Linq.Expressions.MemberMemberBinding : MemberBinding {
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public MemberMemberBinding Update(IEnumerable`1<MemberBinding> bindings);
}
public class System.Linq.Expressions.MethodCallExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public MethodInfo Method { get; }
    public ExpressionType NodeType { get; }
    public Expression Object { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public MethodInfo get_Method();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Object();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public MethodCallExpression Update(Expression object, IEnumerable`1<Expression> arguments);
}
public class System.Linq.Expressions.NewArrayExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewArrayExpression Update(IEnumerable`1<Expression> expressions);
}
public class System.Linq.Expressions.NewExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public ConstructorInfo Constructor { get; }
    public ReadOnlyCollection`1<MemberInfo> Members { get; }
    public ExpressionType NodeType { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public ConstructorInfo get_Constructor();
    public ReadOnlyCollection`1<MemberInfo> get_Members();
    public sealed virtual ExpressionType get_NodeType();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public NewExpression Update(IEnumerable`1<Expression> arguments);
}
public class System.Linq.Expressions.ParameterExpression : Expression {
    public bool IsByRef { get; }
    public string Name { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool get_IsByRef();
    public string get_Name();
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.RuntimeVariablesExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public RuntimeVariablesExpression Update(IEnumerable`1<ParameterExpression> variables);
}
public class System.Linq.Expressions.SwitchCase : object {
    public Expression Body { get; }
    public ReadOnlyCollection`1<Expression> TestValues { get; }
    public Expression get_Body();
    public ReadOnlyCollection`1<Expression> get_TestValues();
    public virtual string ToString();
    public SwitchCase Update(IEnumerable`1<Expression> testValues, Expression body);
}
public class System.Linq.Expressions.SwitchExpression : Expression {
    public ReadOnlyCollection`1<SwitchCase> Cases { get; }
    public MethodInfo Comparison { get; }
    public Expression DefaultBody { get; }
    public ExpressionType NodeType { get; }
    public Expression SwitchValue { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<SwitchCase> get_Cases();
    public MethodInfo get_Comparison();
    public Expression get_DefaultBody();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_SwitchValue();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public SwitchExpression Update(Expression switchValue, IEnumerable`1<SwitchCase> cases, Expression defaultBody);
}
public class System.Linq.Expressions.SymbolDocumentInfo : object {
    public Guid DocumentType { get; }
    public string FileName { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public virtual Guid get_DocumentType();
    public string get_FileName();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
}
public class System.Linq.Expressions.TryExpression : Expression {
    public Expression Body { get; }
    public Expression Fault { get; }
    public Expression Finally { get; }
    public ReadOnlyCollection`1<CatchBlock> Handlers { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression get_Body();
    public Expression get_Fault();
    public Expression get_Finally();
    public ReadOnlyCollection`1<CatchBlock> get_Handlers();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TryExpression Update(Expression body, IEnumerable`1<CatchBlock> handlers, Expression finally, Expression fault);
}
public class System.Linq.Expressions.TypeBinaryExpression : Expression {
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Type TypeOperand { get; }
    public Expression get_Expression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public Type get_TypeOperand();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TypeBinaryExpression Update(Expression expression);
}
public class System.Linq.Expressions.UnaryExpression : Expression {
    public bool CanReduce { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public MethodInfo Method { get; }
    public ExpressionType NodeType { get; }
    public Expression Operand { get; }
    public Type Type { get; }
    public virtual bool get_CanReduce();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    public MethodInfo get_Method();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Operand();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public UnaryExpression Update(Expression operand);
}
public interface System.Linq.IGrouping`2 {
    public TKey Key { get; }
    public abstract virtual TKey get_Key();
}
[DefaultMemberAttribute("Item")]
public interface System.Linq.ILookup`2 {
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<TElement> get_Item(TKey key);
    public abstract virtual bool Contains(TKey key);
}
public interface System.Linq.IOrderedEnumerable`1 {
    public abstract virtual IOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
}
public interface System.Linq.IOrderedQueryable {
}
public interface System.Linq.IOrderedQueryable`1 {
}
public interface System.Linq.IQueryable {
    public Type ElementType { get; }
    public Expression Expression { get; }
    public IQueryProvider Provider { get; }
    public abstract virtual Type get_ElementType();
    public abstract virtual Expression get_Expression();
    public abstract virtual IQueryProvider get_Provider();
}
public interface System.Linq.IQueryable`1 {
}
public interface System.Linq.IQueryProvider {
    public abstract virtual IQueryable CreateQuery(Expression expression);
    public abstract virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public abstract virtual object Execute(Expression expression);
    public abstract virtual TResult Execute(Expression expression);
}
[DefaultMemberAttribute("Item")]
public class System.Linq.Lookup`2 : object {
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public IEnumerable`1<TResult> ApplyResultSelector(Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    public sealed virtual bool Contains(TKey key);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Linq.OrderedParallelQuery`1 : ParallelQuery`1<TSource> {
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
[ExtensionAttribute]
public static class System.Linq.ParallelEnumerable : object {
    [ExtensionAttribute]
public static TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, Func`1<TAccumulate> seedFactory, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static bool All(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsOrdered(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsOrdered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsParallel(IEnumerable source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(Partitioner`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsSequential(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsUnordered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Cast(ParallelQuery source);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(ParallelQuery`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAt(ParallelQuery`1<TSource> source, int index);
    public static ParallelQuery`1<TResult> Empty();
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static void ForAll(ParallelQuery`1<TSource> source, Action`1<TSource> action);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static TSource Max(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static TResult Max(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static TSource Min(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static TResult Min(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> OfType(ParallelQuery source);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    public static ParallelQuery`1<int> Range(int start, int count);
    public static ParallelQuery`1<TResult> Repeat(TResult element, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Reverse(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Skip(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Take(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource[] ToArray(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static List`1<TSource> ToList(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithCancellation(ParallelQuery`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithDegreeOfParallelism(ParallelQuery`1<TSource> source, int degreeOfParallelism);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithExecutionMode(ParallelQuery`1<TSource> source, ParallelExecutionMode executionMode);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithMergeOptions(ParallelQuery`1<TSource> source, ParallelMergeOptions mergeOptions);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, ParallelQuery`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
}
public enum System.Linq.ParallelExecutionMode : Enum {
    public int value__;
    public static ParallelExecutionMode Default;
    public static ParallelExecutionMode ForceParallelism;
}
public enum System.Linq.ParallelMergeOptions : Enum {
    public int value__;
    public static ParallelMergeOptions AutoBuffered;
    public static ParallelMergeOptions Default;
    public static ParallelMergeOptions FullyBuffered;
    public static ParallelMergeOptions NotBuffered;
}
public class System.Linq.ParallelQuery : object {
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Linq.ParallelQuery`1 : ParallelQuery {
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
[ExtensionAttribute]
public static class System.Linq.Queryable : object {
    [ExtensionAttribute]
public static TSource Aggregate(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, TSource, TSource>> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func);
    [ExtensionAttribute]
public static TResult Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func, Expression`1<Func`2<TAccumulate, TResult>> selector);
    [ExtensionAttribute]
public static bool All(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static bool Any(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static bool Any(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Append(IQueryable`1<TSource> source, TSource element);
    [ExtensionAttribute]
public static IQueryable AsQueryable(IEnumerable source);
    [ExtensionAttribute]
public static IQueryable`1<TElement> AsQueryable(IEnumerable`1<TElement> source);
    [ExtensionAttribute]
public static decimal Average(IQueryable`1<decimal> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<double> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<int> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IQueryable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IQueryable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Average(IQueryable`1<float> source);
    [ExtensionAttribute]
public static decimal Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector);
    [ExtensionAttribute]
public static float Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Cast(IQueryable source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Concat(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static bool Contains(IQueryable`1<TSource> source, TSource item);
    [ExtensionAttribute]
public static bool Contains(IQueryable`1<TSource> source, TSource item, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static int Count(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static int Count(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(IQueryable`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAt(IQueryable`1<TSource> source, int index);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource First(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource LastOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Last(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static long LongCount(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Max(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TResult Max(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static TSource Min(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TResult Min(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> OfType(IQueryable source);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Prepend(IQueryable`1<TSource> source, TSource element);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Reverse(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TResult>>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TResult>>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, TResult>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Single(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> SkipLast(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Skip(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static decimal Sum(IQueryable`1<decimal> source);
    [ExtensionAttribute]
public static double Sum(IQueryable`1<double> source);
    [ExtensionAttribute]
public static int Sum(IQueryable`1<int> source);
    [ExtensionAttribute]
public static long Sum(IQueryable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IQueryable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IQueryable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IQueryable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IQueryable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IQueryable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Sum(IQueryable`1<float> source);
    [ExtensionAttribute]
public static decimal Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector);
    [ExtensionAttribute]
public static double Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector);
    [ExtensionAttribute]
public static int Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector);
    [ExtensionAttribute]
public static long Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector);
    [ExtensionAttribute]
public static float Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TSource> TakeLast(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Take(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Zip(IQueryable`1<TFirst> source1, IEnumerable`1<TSecond> source2, Expression`1<Func`3<TFirst, TSecond, TResult>> resultSelector);
}
public enum System.LoaderOptimization : Enum {
    public int value__;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DisallowBindings;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DomainMask;
    public static LoaderOptimization MultiDomain;
    public static LoaderOptimization MultiDomainHost;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
}
[AttributeUsageAttribute("64")]
public class System.LoaderOptimizationAttribute : Attribute {
    public LoaderOptimization Value { get; }
    public LoaderOptimizationAttribute(byte value);
    public LoaderOptimizationAttribute(LoaderOptimization value);
    public LoaderOptimization get_Value();
}
public class System.LocalDataStoreSlot : object {
}
public abstract class System.MarshalByRefObject : object {
    public object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
public static class System.Math : object {
    public static double E;
    public static double PI;
    public static decimal Abs(decimal value);
    public static double Abs(double value);
    public static short Abs(short value);
    public static int Abs(int value);
    public static long Abs(long value);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    public static float Abs(float value);
    public static double Acos(double d);
    public static double Acosh(double d);
    public static double Asin(double d);
    public static double Asinh(double d);
    public static double Atan(double d);
    public static double Atan2(double y, double x);
    public static double Atanh(double d);
    public static long BigMul(int a, int b);
    public static double Cbrt(double d);
    public static decimal Ceiling(decimal d);
    public static double Ceiling(double a);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    public static double Cos(double d);
    public static double Cosh(double value);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
    public static double Exp(double d);
    public static decimal Floor(decimal d);
    public static double Floor(double d);
    public static double IEEERemainder(double x, double y);
    public static double Log(double d);
    public static double Log(double a, double newBase);
    public static double Log10(double d);
    public static byte Max(byte val1, byte val2);
    public static decimal Max(decimal val1, decimal val2);
    public static double Max(double val1, double val2);
    public static short Max(short val1, short val2);
    public static int Max(int val1, int val2);
    public static long Max(long val1, long val2);
    [CLSCompliantAttribute("False")]
public static sbyte Max(sbyte val1, sbyte val2);
    public static float Max(float val1, float val2);
    [CLSCompliantAttribute("False")]
public static ushort Max(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
public static ulong Max(ulong val1, ulong val2);
    public static byte Min(byte val1, byte val2);
    public static decimal Min(decimal val1, decimal val2);
    public static double Min(double val1, double val2);
    public static short Min(short val1, short val2);
    public static int Min(int val1, int val2);
    public static long Min(long val1, long val2);
    [CLSCompliantAttribute("False")]
public static sbyte Min(sbyte val1, sbyte val2);
    public static float Min(float val1, float val2);
    [CLSCompliantAttribute("False")]
public static ushort Min(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
public static ulong Min(ulong val1, ulong val2);
    public static double Pow(double x, double y);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static double Round(double value, MidpointRounding mode);
    public static int Sign(decimal value);
    public static int Sign(double value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(float value);
    public static double Sin(double a);
    public static double Sinh(double value);
    public static double Sqrt(double d);
    public static double Tan(double a);
    public static double Tanh(double value);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
}
public static class System.MathF : object {
    public static float E;
    public static float PI;
    public static float Abs(float x);
    public static float Acos(float x);
    public static float Acosh(float x);
    public static float Asin(float x);
    public static float Asinh(float x);
    public static float Atan(float x);
    public static float Atan2(float y, float x);
    public static float Atanh(float x);
    public static float Cbrt(float x);
    public static float Ceiling(float x);
    public static float Cos(float x);
    public static float Cosh(float x);
    public static float Exp(float x);
    public static float Floor(float x);
    public static float IEEERemainder(float x, float y);
    public static float Log(float x);
    public static float Log(float x, float y);
    public static float Log10(float x);
    public static float Max(float x, float y);
    public static float Min(float x, float y);
    public static float Pow(float x, float y);
    public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static float Round(float x, MidpointRounding mode);
    public static int Sign(float x);
    public static float Sin(float x);
    public static float Sinh(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
    public static float Tanh(float x);
    public static float Truncate(float x);
}
public class System.MemberAccessException : SystemException {
    protected MemberAccessException(SerializationInfo info, StreamingContext context);
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
}
[IsReadOnlyAttribute]
public class System.Memory`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static Memory`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public int Length { get; }
    public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    public Memory`1(T[] array, int start, int length);
    public static Memory`1<T> get_Empty();
    public bool get_IsEmpty();
    public int get_Length();
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public sealed virtual bool Equals(Memory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> op_Implicit(T[] array);
    public MemoryHandle Pin();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public T[] ToArray();
    public virtual string ToString();
    public bool TryCopyTo(Memory`1<T> destination);
}
[ExtensionAttribute]
public static class System.MemoryExtensions : object {
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Index startIndex);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Range range);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Index startIndex);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Range range);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Index startIndex);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Range range);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, Index startIndex);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, Range range);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
}
public class System.MethodAccessException : MemberAccessException {
    protected MethodAccessException(SerializationInfo info, StreamingContext context);
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding AwayFromZero;
    public static MidpointRounding ToEven;
}
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public MissingFieldException(string message);
    public MissingFieldException(string message, Exception inner);
    public MissingFieldException(string className, string fieldName);
    public virtual string get_Message();
}
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    public string Message { get; }
    protected MissingMemberException(SerializationInfo info, StreamingContext context);
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    public MissingMemberException(string className, string memberName);
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public MissingMethodException(string message);
    public MissingMethodException(string message, Exception inner);
    public MissingMethodException(string className, string methodName);
    public virtual string get_Message();
}
public class System.ModuleHandle : ValueType {
    private object _dummy;
    public static ModuleHandle EmptyHandle;
    public int MDStreamVersion { get; }
    public int get_MDStreamVersion();
    public bool Equals(ModuleHandle handle);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
public abstract class System.MulticastDelegate : Delegate {
    protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual Delegate[] GetInvocationList();
    protected virtual MethodInfo GetMethodImpl();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
}
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
}
public class System.Net.AuthenticationManager : object {
    public static ICredentialPolicy CredentialPolicy { get; public set; }
    public static StringDictionary CustomTargetNameDictionary { get; }
    public static IEnumerator RegisteredModules { get; }
    public static ICredentialPolicy get_CredentialPolicy();
    public static void set_CredentialPolicy(ICredentialPolicy value);
    public static StringDictionary get_CustomTargetNameDictionary();
    public static IEnumerator get_RegisteredModules();
    public static Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public static Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public static void Register(IAuthenticationModule authenticationModule);
    public static void Unregister(IAuthenticationModule authenticationModule);
    public static void Unregister(string authenticationScheme);
}
[FlagsAttribute]
public enum System.Net.AuthenticationSchemes : Enum {
    public int value__;
    public static AuthenticationSchemes Anonymous;
    public static AuthenticationSchemes Basic;
    public static AuthenticationSchemes Digest;
    public static AuthenticationSchemes IntegratedWindowsAuthentication;
    public static AuthenticationSchemes Negotiate;
    public static AuthenticationSchemes None;
    public static AuthenticationSchemes Ntlm;
}
public class System.Net.AuthenticationSchemeSelector : MulticastDelegate {
    public AuthenticationSchemeSelector(object object, IntPtr method);
    public virtual AuthenticationSchemes Invoke(HttpListenerRequest httpRequest);
    public virtual IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object);
    public virtual AuthenticationSchemes EndInvoke(IAsyncResult result);
}
public class System.Net.Authorization : object {
    public bool Complete { get; }
    public string ConnectionGroupId { get; }
    public string Message { get; }
    public bool MutuallyAuthenticated { get; public set; }
    public String[] ProtectionRealm { get; public set; }
    public Authorization(string token);
    public Authorization(string token, bool finished);
    public Authorization(string token, bool finished, string connectionGroupId);
    public bool get_Complete();
    public string get_ConnectionGroupId();
    public string get_Message();
    public bool get_MutuallyAuthenticated();
    public void set_MutuallyAuthenticated(bool value);
    public String[] get_ProtectionRealm();
    public void set_ProtectionRealm(String[] value);
}
public class System.Net.BindIPEndPoint : MulticastDelegate {
    public BindIPEndPoint(object object, IntPtr method);
    public virtual IPEndPoint Invoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount);
    public virtual IAsyncResult BeginInvoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount, AsyncCallback callback, object object);
    public virtual IPEndPoint EndInvoke(IAsyncResult result);
}
public enum System.Net.Cache.HttpCacheAgeControl : Enum {
    public int value__;
    public static HttpCacheAgeControl MaxAge;
    public static HttpCacheAgeControl MaxAgeAndMaxStale;
    public static HttpCacheAgeControl MaxAgeAndMinFresh;
    public static HttpCacheAgeControl MaxStale;
    public static HttpCacheAgeControl MinFresh;
    public static HttpCacheAgeControl None;
}
public enum System.Net.Cache.HttpRequestCacheLevel : Enum {
    public int value__;
    public static HttpRequestCacheLevel BypassCache;
    public static HttpRequestCacheLevel CacheIfAvailable;
    public static HttpRequestCacheLevel CacheOnly;
    public static HttpRequestCacheLevel CacheOrNextCacheOnly;
    public static HttpRequestCacheLevel Default;
    public static HttpRequestCacheLevel NoCacheNoStore;
    public static HttpRequestCacheLevel Refresh;
    public static HttpRequestCacheLevel Reload;
    public static HttpRequestCacheLevel Revalidate;
}
public class System.Net.Cache.HttpRequestCachePolicy : RequestCachePolicy {
    public DateTime CacheSyncDate { get; }
    public HttpRequestCacheLevel Level { get; }
    public TimeSpan MaxAge { get; }
    public TimeSpan MaxStale { get; }
    public TimeSpan MinFresh { get; }
    public HttpRequestCachePolicy(DateTime cacheSyncDate);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate);
    public HttpRequestCachePolicy(HttpRequestCacheLevel level);
    public DateTime get_CacheSyncDate();
    public HttpRequestCacheLevel get_Level();
    public TimeSpan get_MaxAge();
    public TimeSpan get_MaxStale();
    public TimeSpan get_MinFresh();
    public virtual string ToString();
}
public enum System.Net.Cache.RequestCacheLevel : Enum {
    public int value__;
    public static RequestCacheLevel BypassCache;
    public static RequestCacheLevel CacheIfAvailable;
    public static RequestCacheLevel CacheOnly;
    public static RequestCacheLevel Default;
    public static RequestCacheLevel NoCacheNoStore;
    public static RequestCacheLevel Reload;
    public static RequestCacheLevel Revalidate;
}
public class System.Net.Cache.RequestCachePolicy : object {
    public RequestCacheLevel Level { get; }
    public RequestCachePolicy(RequestCacheLevel level);
    public RequestCacheLevel get_Level();
    public virtual string ToString();
}
public class System.Net.Cookie : object {
    public string Comment { get; public set; }
    public Uri CommentUri { get; public set; }
    public bool Discard { get; public set; }
    public string Domain { get; public set; }
    public bool Expired { get; public set; }
    public DateTime Expires { get; public set; }
    public bool HttpOnly { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    public string Port { get; public set; }
    public bool Secure { get; public set; }
    public DateTime TimeStamp { get; }
    public string Value { get; public set; }
    public int Version { get; public set; }
    public Cookie(string name, string value);
    public Cookie(string name, string value, string path);
    public Cookie(string name, string value, string path, string domain);
    public string get_Comment();
    public void set_Comment(string value);
    public Uri get_CommentUri();
    public void set_CommentUri(Uri value);
    public bool get_Discard();
    public void set_Discard(bool value);
    public string get_Domain();
    public void set_Domain(string value);
    public bool get_Expired();
    public void set_Expired(bool value);
    public DateTime get_Expires();
    public void set_Expires(DateTime value);
    public bool get_HttpOnly();
    public void set_HttpOnly(bool value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Path();
    public void set_Path(string value);
    public string get_Port();
    public void set_Port(string value);
    public bool get_Secure();
    public void set_Secure(bool value);
    public DateTime get_TimeStamp();
    public string get_Value();
    public void set_Value(string value);
    public int get_Version();
    public void set_Version(int value);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Net.CookieCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Cookie Item { get; }
    public Cookie Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Cookie get_Item(int index);
    public Cookie get_Item(string name);
    public sealed virtual object get_SyncRoot();
    public void Add(Cookie cookie);
    public void Add(CookieCollection cookies);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Cookie[] array, int index);
    public sealed virtual IEnumerator GetEnumerator();
}
public class System.Net.CookieContainer : object {
    public static int DefaultCookieLengthLimit;
    public static int DefaultCookieLimit;
    public static int DefaultPerDomainCookieLimit;
    public int Capacity { get; public set; }
    public int Count { get; }
    public int MaxCookieSize { get; public set; }
    public int PerDomainCapacity { get; public set; }
    public CookieContainer(int capacity);
    public CookieContainer(int capacity, int perDomainCapacity, int maxCookieSize);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public int get_MaxCookieSize();
    public void set_MaxCookieSize(int value);
    public int get_PerDomainCapacity();
    public void set_PerDomainCapacity(int value);
    public void Add(Cookie cookie);
    public void Add(CookieCollection cookies);
    public void Add(Uri uri, Cookie cookie);
    public void Add(Uri uri, CookieCollection cookies);
    public string GetCookieHeader(Uri uri);
    public CookieCollection GetCookies(Uri uri);
    public void SetCookies(Uri uri, string cookieHeader);
}
public class System.Net.CookieException : FormatException {
    protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Net.CredentialCache : object {
    public static ICredentials DefaultCredentials { get; }
    public static NetworkCredential DefaultNetworkCredentials { get; }
    public static ICredentials get_DefaultCredentials();
    public static NetworkCredential get_DefaultNetworkCredentials();
    public void Add(string host, int port, string authenticationType, NetworkCredential credential);
    public void Add(Uri uriPrefix, string authType, NetworkCredential cred);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
    public sealed virtual NetworkCredential GetCredential(Uri uriPrefix, string authType);
    public sealed virtual IEnumerator GetEnumerator();
    public void Remove(string host, int port, string authenticationType);
    public void Remove(Uri uriPrefix, string authType);
}
[FlagsAttribute]
public enum System.Net.DecompressionMethods : Enum {
    public int value__;
    public static DecompressionMethods Deflate;
    public static DecompressionMethods GZip;
    public static DecompressionMethods None;
}
public static class System.Net.Dns : object {
    public static IAsyncResult BeginGetHostAddresses(string hostNameOrAddress, AsyncCallback requestCallback, object state);
    [ObsoleteAttribute("BeginGetHostByName is obsoleted for this type, please use BeginGetHostEntry instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static IAsyncResult BeginGetHostByName(string hostName, AsyncCallback requestCallback, object stateObject);
    public static IAsyncResult BeginGetHostEntry(IPAddress address, AsyncCallback requestCallback, object stateObject);
    public static IAsyncResult BeginGetHostEntry(string hostNameOrAddress, AsyncCallback requestCallback, object stateObject);
    [ObsoleteAttribute("BeginResolve is obsoleted for this type, please use BeginGetHostEntry instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static IAsyncResult BeginResolve(string hostName, AsyncCallback requestCallback, object stateObject);
    public static IPAddress[] EndGetHostAddresses(IAsyncResult asyncResult);
    [ObsoleteAttribute("EndGetHostByName is obsoleted for this type, please use EndGetHostEntry instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry EndGetHostByName(IAsyncResult asyncResult);
    public static IPHostEntry EndGetHostEntry(IAsyncResult asyncResult);
    [ObsoleteAttribute("EndResolve is obsoleted for this type, please use EndGetHostEntry instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry EndResolve(IAsyncResult asyncResult);
    public static IPAddress[] GetHostAddresses(string hostNameOrAddress);
    public static Task`1<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress);
    [ObsoleteAttribute("GetHostByAddress is obsoleted for this type, please use GetHostEntry instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry GetHostByAddress(IPAddress address);
    [ObsoleteAttribute("GetHostByAddress is obsoleted for this type, please use GetHostEntry instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry GetHostByAddress(string address);
    [ObsoleteAttribute("GetHostByName is obsoleted for this type, please use GetHostEntry instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry GetHostByName(string hostName);
    public static IPHostEntry GetHostEntry(IPAddress address);
    public static IPHostEntry GetHostEntry(string hostNameOrAddress);
    public static Task`1<IPHostEntry> GetHostEntryAsync(IPAddress address);
    public static Task`1<IPHostEntry> GetHostEntryAsync(string hostNameOrAddress);
    public static string GetHostName();
    [ObsoleteAttribute("Resolve is obsoleted for this type, please use GetHostEntry instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry Resolve(string hostName);
}
public class System.Net.DnsEndPoint : EndPoint {
    public AddressFamily AddressFamily { get; }
    public string Host { get; }
    public int Port { get; }
    public DnsEndPoint(string host, int port);
    public DnsEndPoint(string host, int port, AddressFamily addressFamily);
    public virtual AddressFamily get_AddressFamily();
    public string get_Host();
    public int get_Port();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Net.DownloadDataCompletedEventArgs : AsyncCompletedEventArgs {
    public Byte[] Result { get; }
    public Byte[] get_Result();
}
public class System.Net.DownloadDataCompletedEventHandler : MulticastDelegate {
    public DownloadDataCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadDataCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadDataCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.DownloadProgressChangedEventArgs : ProgressChangedEventArgs {
    public long BytesReceived { get; }
    public long TotalBytesToReceive { get; }
    public long get_BytesReceived();
    public long get_TotalBytesToReceive();
}
public class System.Net.DownloadProgressChangedEventHandler : MulticastDelegate {
    public DownloadProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.DownloadStringCompletedEventArgs : AsyncCompletedEventArgs {
    public string Result { get; }
    public string get_Result();
}
public class System.Net.DownloadStringCompletedEventHandler : MulticastDelegate {
    public DownloadStringCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadStringCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadStringCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Net.EndPoint : object {
    public AddressFamily AddressFamily { get; }
    public virtual AddressFamily get_AddressFamily();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual SocketAddress Serialize();
}
public class System.Net.FileWebRequest : WebRequest {
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    [ObsoleteAttribute("Serialization is obsoleted for this type. https://go.microsoft.com/fwlink/?linkid=14202")]
protected FileWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual void Abort();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual Stream GetRequestStream();
    public virtual Task`1<Stream> GetRequestStreamAsync();
    public virtual WebResponse GetResponse();
    public virtual Task`1<WebResponse> GetResponseAsync();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Net.FileWebResponse : WebResponse {
    public long ContentLength { get; }
    public string ContentType { get; }
    public WebHeaderCollection Headers { get; }
    public Uri ResponseUri { get; }
    public bool SupportsHeaders { get; }
    [ObsoleteAttribute("Serialization is obsoleted for this type. https://go.microsoft.com/fwlink/?linkid=14202")]
protected FileWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual WebHeaderCollection get_Headers();
    public virtual Uri get_ResponseUri();
    public virtual bool get_SupportsHeaders();
    public virtual void Close();
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual Stream GetResponseStream();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.Net.FtpStatusCode : Enum {
    public int value__;
    public static FtpStatusCode AccountNeeded;
    public static FtpStatusCode ActionAbortedLocalProcessingError;
    public static FtpStatusCode ActionAbortedUnknownPageType;
    public static FtpStatusCode ActionNotTakenFilenameNotAllowed;
    public static FtpStatusCode ActionNotTakenFileUnavailable;
    public static FtpStatusCode ActionNotTakenFileUnavailableOrBusy;
    public static FtpStatusCode ActionNotTakenInsufficientSpace;
    public static FtpStatusCode ArgumentSyntaxError;
    public static FtpStatusCode BadCommandSequence;
    public static FtpStatusCode CantOpenData;
    public static FtpStatusCode ClosingControl;
    public static FtpStatusCode ClosingData;
    public static FtpStatusCode CommandExtraneous;
    public static FtpStatusCode CommandNotImplemented;
    public static FtpStatusCode CommandOK;
    public static FtpStatusCode CommandSyntaxError;
    public static FtpStatusCode ConnectionClosed;
    public static FtpStatusCode DataAlreadyOpen;
    public static FtpStatusCode DirectoryStatus;
    public static FtpStatusCode EnteringPassive;
    public static FtpStatusCode FileActionAborted;
    public static FtpStatusCode FileActionOK;
    public static FtpStatusCode FileCommandPending;
    public static FtpStatusCode FileStatus;
    public static FtpStatusCode LoggedInProceed;
    public static FtpStatusCode NeedLoginAccount;
    public static FtpStatusCode NotLoggedIn;
    public static FtpStatusCode OpeningData;
    public static FtpStatusCode PathnameCreated;
    public static FtpStatusCode RestartMarker;
    public static FtpStatusCode SendPasswordCommand;
    public static FtpStatusCode SendUserCommand;
    public static FtpStatusCode ServerWantsSecureSession;
    public static FtpStatusCode ServiceNotAvailable;
    public static FtpStatusCode ServiceTemporarilyNotAvailable;
    public static FtpStatusCode SystemType;
    public static FtpStatusCode Undefined;
}
public class System.Net.FtpWebRequest : WebRequest {
    public X509CertificateCollection ClientCertificates { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public long ContentOffset { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public bool EnableSsl { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public bool KeepAlive { get; public set; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public int ReadWriteTimeout { get; public set; }
    public string RenameTo { get; public set; }
    public Uri RequestUri { get; }
    public ServicePoint ServicePoint { get; }
    public int Timeout { get; public set; }
    public bool UseBinary { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public bool UsePassive { get; public set; }
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public long get_ContentOffset();
    public void set_ContentOffset(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public string get_RenameTo();
    public void set_RenameTo(string value);
    public virtual Uri get_RequestUri();
    public ServicePoint get_ServicePoint();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public bool get_UseBinary();
    public void set_UseBinary(bool value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public bool get_UsePassive();
    public void set_UsePassive(bool value);
    public virtual void Abort();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
}
public class System.Net.FtpWebResponse : WebResponse {
    public string BannerMessage { get; }
    public long ContentLength { get; }
    public string ContentType { get; }
    public string ExitMessage { get; }
    public WebHeaderCollection Headers { get; }
    public DateTime LastModified { get; }
    public Uri ResponseUri { get; }
    public FtpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public bool SupportsHeaders { get; }
    public string WelcomeMessage { get; }
    public string get_BannerMessage();
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public string get_ExitMessage();
    public virtual WebHeaderCollection get_Headers();
    public DateTime get_LastModified();
    public virtual Uri get_ResponseUri();
    public FtpStatusCode get_StatusCode();
    public string get_StatusDescription();
    public virtual bool get_SupportsHeaders();
    public string get_WelcomeMessage();
    public virtual void Close();
    public virtual Stream GetResponseStream();
}
[ObsoleteAttribute("This class has been deprecated. Please use WebRequest.DefaultWebProxy instead to access and set the global default proxy. Use 'null' instead of GetEmptyWebProxy. https://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Net.GlobalProxySelection : object {
    public static IWebProxy Select { get; public set; }
    public static IWebProxy get_Select();
    public static void set_Select(IWebProxy value);
    public static IWebProxy GetEmptyWebProxy();
}
public class System.Net.Http.ByteArrayContent : HttpContent {
    public ByteArrayContent(Byte[] content);
    public ByteArrayContent(Byte[] content, int offset, int count);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
}
public enum System.Net.Http.ClientCertificateOption : Enum {
    public int value__;
    public static ClientCertificateOption Automatic;
    public static ClientCertificateOption Manual;
}
public abstract class System.Net.Http.DelegatingHandler : HttpMessageHandler {
    public HttpMessageHandler InnerHandler { get; public set; }
    protected DelegatingHandler(HttpMessageHandler innerHandler);
    public HttpMessageHandler get_InnerHandler();
    public void set_InnerHandler(HttpMessageHandler value);
    protected virtual void Dispose(bool disposing);
    protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.FormUrlEncodedContent : ByteArrayContent {
    public FormUrlEncodedContent(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
}
public class System.Net.Http.Headers.AuthenticationHeaderValue : object {
    public string Parameter { get; }
    public string Scheme { get; }
    public AuthenticationHeaderValue(string scheme);
    public AuthenticationHeaderValue(string scheme, string parameter);
    public string get_Parameter();
    public string get_Scheme();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static AuthenticationHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, AuthenticationHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.CacheControlHeaderValue : object {
    public ICollection`1<NameValueHeaderValue> Extensions { get; }
    public Nullable`1<TimeSpan> MaxAge { get; public set; }
    public bool MaxStale { get; public set; }
    public Nullable`1<TimeSpan> MaxStaleLimit { get; public set; }
    public Nullable`1<TimeSpan> MinFresh { get; public set; }
    public bool MustRevalidate { get; public set; }
    public bool NoCache { get; public set; }
    public ICollection`1<string> NoCacheHeaders { get; }
    public bool NoStore { get; public set; }
    public bool NoTransform { get; public set; }
    public bool OnlyIfCached { get; public set; }
    public bool Private { get; public set; }
    public ICollection`1<string> PrivateHeaders { get; }
    public bool ProxyRevalidate { get; public set; }
    public bool Public { get; public set; }
    public Nullable`1<TimeSpan> SharedMaxAge { get; public set; }
    public ICollection`1<NameValueHeaderValue> get_Extensions();
    public Nullable`1<TimeSpan> get_MaxAge();
    public void set_MaxAge(Nullable`1<TimeSpan> value);
    public bool get_MaxStale();
    public void set_MaxStale(bool value);
    public Nullable`1<TimeSpan> get_MaxStaleLimit();
    public void set_MaxStaleLimit(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_MinFresh();
    public void set_MinFresh(Nullable`1<TimeSpan> value);
    public bool get_MustRevalidate();
    public void set_MustRevalidate(bool value);
    public bool get_NoCache();
    public void set_NoCache(bool value);
    public ICollection`1<string> get_NoCacheHeaders();
    public bool get_NoStore();
    public void set_NoStore(bool value);
    public bool get_NoTransform();
    public void set_NoTransform(bool value);
    public bool get_OnlyIfCached();
    public void set_OnlyIfCached(bool value);
    public bool get_Private();
    public void set_Private(bool value);
    public ICollection`1<string> get_PrivateHeaders();
    public bool get_ProxyRevalidate();
    public void set_ProxyRevalidate(bool value);
    public bool get_Public();
    public void set_Public(bool value);
    public Nullable`1<TimeSpan> get_SharedMaxAge();
    public void set_SharedMaxAge(Nullable`1<TimeSpan> value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static CacheControlHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, CacheControlHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.ContentDispositionHeaderValue : object {
    public Nullable`1<DateTimeOffset> CreationDate { get; public set; }
    public string DispositionType { get; public set; }
    public string FileName { get; public set; }
    public string FileNameStar { get; public set; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; public set; }
    public string Name { get; public set; }
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public Nullable`1<DateTimeOffset> ReadDate { get; public set; }
    public Nullable`1<long> Size { get; public set; }
    protected ContentDispositionHeaderValue(ContentDispositionHeaderValue source);
    public ContentDispositionHeaderValue(string dispositionType);
    public Nullable`1<DateTimeOffset> get_CreationDate();
    public void set_CreationDate(Nullable`1<DateTimeOffset> value);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public string get_FileNameStar();
    public void set_FileNameStar(string value);
    public Nullable`1<DateTimeOffset> get_ModificationDate();
    public void set_ModificationDate(Nullable`1<DateTimeOffset> value);
    public string get_Name();
    public void set_Name(string value);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public Nullable`1<DateTimeOffset> get_ReadDate();
    public void set_ReadDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<long> get_Size();
    public void set_Size(Nullable`1<long> value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ContentDispositionHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, ContentDispositionHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.ContentRangeHeaderValue : object {
    public Nullable`1<long> From { get; }
    public bool HasLength { get; }
    public bool HasRange { get; }
    public Nullable`1<long> Length { get; }
    public Nullable`1<long> To { get; }
    public string Unit { get; public set; }
    public ContentRangeHeaderValue(long length);
    public ContentRangeHeaderValue(long from, long to);
    public ContentRangeHeaderValue(long from, long to, long length);
    public Nullable`1<long> get_From();
    public bool get_HasLength();
    public bool get_HasRange();
    public Nullable`1<long> get_Length();
    public Nullable`1<long> get_To();
    public string get_Unit();
    public void set_Unit(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ContentRangeHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, ContentRangeHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.EntityTagHeaderValue : object {
    public static EntityTagHeaderValue Any { get; }
    public bool IsWeak { get; }
    public string Tag { get; }
    public EntityTagHeaderValue(string tag);
    public EntityTagHeaderValue(string tag, bool isWeak);
    public static EntityTagHeaderValue get_Any();
    public bool get_IsWeak();
    public string get_Tag();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static EntityTagHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, EntityTagHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.HttpContentHeaders : HttpHeaders {
    public ICollection`1<string> Allow { get; }
    public ContentDispositionHeaderValue ContentDisposition { get; public set; }
    public ICollection`1<string> ContentEncoding { get; }
    public ICollection`1<string> ContentLanguage { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public Uri ContentLocation { get; public set; }
    public Byte[] ContentMD5 { get; public set; }
    public ContentRangeHeaderValue ContentRange { get; public set; }
    public MediaTypeHeaderValue ContentType { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public Nullable`1<DateTimeOffset> LastModified { get; public set; }
    public ICollection`1<string> get_Allow();
    public ContentDispositionHeaderValue get_ContentDisposition();
    public void set_ContentDisposition(ContentDispositionHeaderValue value);
    public ICollection`1<string> get_ContentEncoding();
    public ICollection`1<string> get_ContentLanguage();
    public Nullable`1<long> get_ContentLength();
    public void set_ContentLength(Nullable`1<long> value);
    public Uri get_ContentLocation();
    public void set_ContentLocation(Uri value);
    public Byte[] get_ContentMD5();
    public void set_ContentMD5(Byte[] value);
    public ContentRangeHeaderValue get_ContentRange();
    public void set_ContentRange(ContentRangeHeaderValue value);
    public MediaTypeHeaderValue get_ContentType();
    public void set_ContentType(MediaTypeHeaderValue value);
    public Nullable`1<DateTimeOffset> get_Expires();
    public void set_Expires(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public void set_LastModified(Nullable`1<DateTimeOffset> value);
}
public abstract class System.Net.Http.Headers.HttpHeaders : object {
    public void Add(string name, IEnumerable`1<string> values);
    public void Add(string name, string value);
    public void Clear();
    public bool Contains(string name);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator();
    public IEnumerable`1<string> GetValues(string name);
    public bool Remove(string name);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public bool TryAddWithoutValidation(string name, IEnumerable`1<string> values);
    public bool TryAddWithoutValidation(string name, string value);
    public bool TryGetValues(string name, IEnumerable`1& values);
}
public class System.Net.Http.Headers.HttpHeaderValueCollection`1 : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public void ParseAdd(string input);
    public sealed virtual bool Remove(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public bool TryParseAdd(string input);
}
public class System.Net.Http.Headers.HttpRequestHeaders : HttpHeaders {
    public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> Accept { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptCharset { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptEncoding { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptLanguage { get; }
    public AuthenticationHeaderValue Authorization { get; public set; }
    public CacheControlHeaderValue CacheControl { get; public set; }
    public HttpHeaderValueCollection`1<string> Connection { get; }
    public Nullable`1<bool> ConnectionClose { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> Expect { get; }
    public Nullable`1<bool> ExpectContinue { get; public set; }
    public string From { get; public set; }
    public string Host { get; public set; }
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfMatch { get; }
    public Nullable`1<DateTimeOffset> IfModifiedSince { get; public set; }
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfNoneMatch { get; }
    public RangeConditionHeaderValue IfRange { get; public set; }
    public Nullable`1<DateTimeOffset> IfUnmodifiedSince { get; public set; }
    public Nullable`1<int> MaxForwards { get; public set; }
    public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    public AuthenticationHeaderValue ProxyAuthorization { get; public set; }
    public RangeHeaderValue Range { get; public set; }
    public Uri Referrer { get; public set; }
    public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> TE { get; }
    public HttpHeaderValueCollection`1<string> Trailer { get; }
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> UserAgent { get; }
    public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> get_Accept();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptCharset();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptEncoding();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptLanguage();
    public AuthenticationHeaderValue get_Authorization();
    public void set_Authorization(AuthenticationHeaderValue value);
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> get_Expect();
    public Nullable`1<bool> get_ExpectContinue();
    public void set_ExpectContinue(Nullable`1<bool> value);
    public string get_From();
    public void set_From(string value);
    public string get_Host();
    public void set_Host(string value);
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfMatch();
    public Nullable`1<DateTimeOffset> get_IfModifiedSince();
    public void set_IfModifiedSince(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfNoneMatch();
    public RangeConditionHeaderValue get_IfRange();
    public void set_IfRange(RangeConditionHeaderValue value);
    public Nullable`1<DateTimeOffset> get_IfUnmodifiedSince();
    public void set_IfUnmodifiedSince(Nullable`1<DateTimeOffset> value);
    public Nullable`1<int> get_MaxForwards();
    public void set_MaxForwards(Nullable`1<int> value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public AuthenticationHeaderValue get_ProxyAuthorization();
    public void set_ProxyAuthorization(AuthenticationHeaderValue value);
    public RangeHeaderValue get_Range();
    public void set_Range(RangeHeaderValue value);
    public Uri get_Referrer();
    public void set_Referrer(Uri value);
    public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> get_TE();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_UserAgent();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
}
public class System.Net.Http.Headers.HttpResponseHeaders : HttpHeaders {
    public HttpHeaderValueCollection`1<string> AcceptRanges { get; }
    public Nullable`1<TimeSpan> Age { get; public set; }
    public CacheControlHeaderValue CacheControl { get; public set; }
    public HttpHeaderValueCollection`1<string> Connection { get; }
    public Nullable`1<bool> ConnectionClose { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public EntityTagHeaderValue ETag { get; public set; }
    public Uri Location { get; public set; }
    public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> ProxyAuthenticate { get; }
    public RetryConditionHeaderValue RetryAfter { get; public set; }
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> Server { get; }
    public HttpHeaderValueCollection`1<string> Trailer { get; }
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    public HttpHeaderValueCollection`1<string> Vary { get; }
    public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> WwwAuthenticate { get; }
    public HttpHeaderValueCollection`1<string> get_AcceptRanges();
    public Nullable`1<TimeSpan> get_Age();
    public void set_Age(Nullable`1<TimeSpan> value);
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public EntityTagHeaderValue get_ETag();
    public void set_ETag(EntityTagHeaderValue value);
    public Uri get_Location();
    public void set_Location(Uri value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_ProxyAuthenticate();
    public RetryConditionHeaderValue get_RetryAfter();
    public void set_RetryAfter(RetryConditionHeaderValue value);
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_Server();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<string> get_Vary();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_WwwAuthenticate();
}
public class System.Net.Http.Headers.MediaTypeHeaderValue : object {
    public string CharSet { get; public set; }
    public string MediaType { get; public set; }
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    protected MediaTypeHeaderValue(MediaTypeHeaderValue source);
    public MediaTypeHeaderValue(string mediaType);
    public string get_CharSet();
    public void set_CharSet(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static MediaTypeHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, MediaTypeHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.MediaTypeWithQualityHeaderValue : MediaTypeHeaderValue {
    public Nullable`1<double> Quality { get; public set; }
    public MediaTypeWithQualityHeaderValue(string mediaType);
    public MediaTypeWithQualityHeaderValue(string mediaType, double quality);
    public Nullable`1<double> get_Quality();
    public void set_Quality(Nullable`1<double> value);
    public static MediaTypeWithQualityHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public static bool TryParse(string input, MediaTypeWithQualityHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.NameValueHeaderValue : object {
    public string Name { get; }
    public string Value { get; public set; }
    protected NameValueHeaderValue(NameValueHeaderValue source);
    public NameValueHeaderValue(string name);
    public NameValueHeaderValue(string name, string value);
    public string get_Name();
    public string get_Value();
    public void set_Value(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static NameValueHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, NameValueHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.NameValueWithParametersHeaderValue : NameValueHeaderValue {
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    protected NameValueWithParametersHeaderValue(NameValueWithParametersHeaderValue source);
    public NameValueWithParametersHeaderValue(string name);
    public NameValueWithParametersHeaderValue(string name, string value);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static NameValueWithParametersHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, NameValueWithParametersHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.ProductHeaderValue : object {
    public string Name { get; }
    public string Version { get; }
    public ProductHeaderValue(string name);
    public ProductHeaderValue(string name, string version);
    public string get_Name();
    public string get_Version();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ProductHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, ProductHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.ProductInfoHeaderValue : object {
    public string Comment { get; }
    public ProductHeaderValue Product { get; }
    public ProductInfoHeaderValue(ProductHeaderValue product);
    public ProductInfoHeaderValue(string comment);
    public ProductInfoHeaderValue(string productName, string productVersion);
    public string get_Comment();
    public ProductHeaderValue get_Product();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ProductInfoHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, ProductInfoHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.RangeConditionHeaderValue : object {
    public Nullable`1<DateTimeOffset> Date { get; }
    public EntityTagHeaderValue EntityTag { get; }
    public RangeConditionHeaderValue(DateTimeOffset date);
    public RangeConditionHeaderValue(EntityTagHeaderValue entityTag);
    public RangeConditionHeaderValue(string entityTag);
    public Nullable`1<DateTimeOffset> get_Date();
    public EntityTagHeaderValue get_EntityTag();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeConditionHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, RangeConditionHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.RangeHeaderValue : object {
    public ICollection`1<RangeItemHeaderValue> Ranges { get; }
    public string Unit { get; public set; }
    public RangeHeaderValue(Nullable`1<long> from, Nullable`1<long> to);
    public ICollection`1<RangeItemHeaderValue> get_Ranges();
    public string get_Unit();
    public void set_Unit(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, RangeHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.RangeItemHeaderValue : object {
    public Nullable`1<long> From { get; }
    public Nullable`1<long> To { get; }
    public RangeItemHeaderValue(Nullable`1<long> from, Nullable`1<long> to);
    public Nullable`1<long> get_From();
    public Nullable`1<long> get_To();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
}
public class System.Net.Http.Headers.RetryConditionHeaderValue : object {
    public Nullable`1<DateTimeOffset> Date { get; }
    public Nullable`1<TimeSpan> Delta { get; }
    public RetryConditionHeaderValue(DateTimeOffset date);
    public RetryConditionHeaderValue(TimeSpan delta);
    public Nullable`1<DateTimeOffset> get_Date();
    public Nullable`1<TimeSpan> get_Delta();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RetryConditionHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, RetryConditionHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.StringWithQualityHeaderValue : object {
    public Nullable`1<double> Quality { get; }
    public string Value { get; }
    public StringWithQualityHeaderValue(string value);
    public StringWithQualityHeaderValue(string value, double quality);
    public Nullable`1<double> get_Quality();
    public string get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static StringWithQualityHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, StringWithQualityHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.TransferCodingHeaderValue : object {
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public string Value { get; }
    protected TransferCodingHeaderValue(TransferCodingHeaderValue source);
    public TransferCodingHeaderValue(string value);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public string get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static TransferCodingHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, TransferCodingHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.TransferCodingWithQualityHeaderValue : TransferCodingHeaderValue {
    public Nullable`1<double> Quality { get; public set; }
    public TransferCodingWithQualityHeaderValue(string value);
    public TransferCodingWithQualityHeaderValue(string value, double quality);
    public Nullable`1<double> get_Quality();
    public void set_Quality(Nullable`1<double> value);
    public static TransferCodingWithQualityHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public static bool TryParse(string input, TransferCodingWithQualityHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.ViaHeaderValue : object {
    public string Comment { get; }
    public string ProtocolName { get; }
    public string ProtocolVersion { get; }
    public string ReceivedBy { get; }
    public ViaHeaderValue(string protocolVersion, string receivedBy);
    public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName);
    public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName, string comment);
    public string get_Comment();
    public string get_ProtocolName();
    public string get_ProtocolVersion();
    public string get_ReceivedBy();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ViaHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, ViaHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.WarningHeaderValue : object {
    public string Agent { get; }
    public int Code { get; }
    public Nullable`1<DateTimeOffset> Date { get; }
    public string Text { get; }
    public WarningHeaderValue(int code, string agent, string text);
    public WarningHeaderValue(int code, string agent, string text, DateTimeOffset date);
    public string get_Agent();
    public int get_Code();
    public Nullable`1<DateTimeOffset> get_Date();
    public string get_Text();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static WarningHeaderValue Parse(string input);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public static bool TryParse(string input, WarningHeaderValue& parsedValue);
}
public class System.Net.Http.HttpClient : HttpMessageInvoker {
    public Uri BaseAddress { get; public set; }
    public HttpRequestHeaders DefaultRequestHeaders { get; }
    public long MaxResponseContentBufferSize { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public HttpClient(HttpMessageHandler handler);
    public HttpClient(HttpMessageHandler handler, bool disposeHandler);
    public Uri get_BaseAddress();
    public void set_BaseAddress(Uri value);
    public HttpRequestHeaders get_DefaultRequestHeaders();
    public long get_MaxResponseContentBufferSize();
    public void set_MaxResponseContentBufferSize(long value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
    public void CancelPendingRequests();
    public Task`1<HttpResponseMessage> DeleteAsync(string requestUri);
    public Task`1<HttpResponseMessage> DeleteAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, CancellationToken cancellationToken);
    public Task`1<Byte[]> GetByteArrayAsync(string requestUri);
    public Task`1<Byte[]> GetByteArrayAsync(Uri requestUri);
    public Task`1<Stream> GetStreamAsync(string requestUri);
    public Task`1<Stream> GetStreamAsync(Uri requestUri);
    public Task`1<string> GetStringAsync(string requestUri);
    public Task`1<string> GetStringAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.HttpClientHandler : HttpMessageHandler {
    public bool AllowAutoRedirect { get; public set; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    public bool CheckCertificateRevocationList { get; public set; }
    public ClientCertificateOption ClientCertificateOptions { get; public set; }
    public X509CertificateCollection ClientCertificates { get; }
    public CookieContainer CookieContainer { get; public set; }
    public ICredentials Credentials { get; public set; }
    public static Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> DangerousAcceptAnyServerCertificateValidator { get; }
    public ICredentials DefaultProxyCredentials { get; public set; }
    public int MaxAutomaticRedirections { get; public set; }
    public int MaxConnectionsPerServer { get; public set; }
    public long MaxRequestContentBufferSize { get; public set; }
    public int MaxResponseHeadersLength { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IDictionary`2<string, object> Properties { get; }
    public IWebProxy Proxy { get; public set; }
    public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateCustomValidationCallback { get; public set; }
    public SslProtocols SslProtocols { get; public set; }
    public bool SupportsAutomaticDecompression { get; }
    public bool SupportsProxy { get; }
    public bool SupportsRedirectConfiguration { get; }
    public bool UseCookies { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public bool UseProxy { get; public set; }
    public bool get_AllowAutoRedirect();
    public void set_AllowAutoRedirect(bool value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public bool get_CheckCertificateRevocationList();
    public void set_CheckCertificateRevocationList(bool value);
    public ClientCertificateOption get_ClientCertificateOptions();
    public void set_ClientCertificateOptions(ClientCertificateOption value);
    public X509CertificateCollection get_ClientCertificates();
    public CookieContainer get_CookieContainer();
    public void set_CookieContainer(CookieContainer value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public static Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_DangerousAcceptAnyServerCertificateValidator();
    public ICredentials get_DefaultProxyCredentials();
    public void set_DefaultProxyCredentials(ICredentials value);
    public int get_MaxAutomaticRedirections();
    public void set_MaxAutomaticRedirections(int value);
    public int get_MaxConnectionsPerServer();
    public void set_MaxConnectionsPerServer(int value);
    public long get_MaxRequestContentBufferSize();
    public void set_MaxRequestContentBufferSize(long value);
    public int get_MaxResponseHeadersLength();
    public void set_MaxResponseHeadersLength(int value);
    public bool get_PreAuthenticate();
    public void set_PreAuthenticate(bool value);
    public IDictionary`2<string, object> get_Properties();
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ServerCertificateCustomValidationCallback();
    public void set_ServerCertificateCustomValidationCallback(Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> value);
    public SslProtocols get_SslProtocols();
    public void set_SslProtocols(SslProtocols value);
    public virtual bool get_SupportsAutomaticDecompression();
    public virtual bool get_SupportsProxy();
    public virtual bool get_SupportsRedirectConfiguration();
    public bool get_UseCookies();
    public void set_UseCookies(bool value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public bool get_UseProxy();
    public void set_UseProxy(bool value);
    protected virtual void Dispose(bool disposing);
    protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public enum System.Net.Http.HttpCompletionOption : Enum {
    public int value__;
    public static HttpCompletionOption ResponseContentRead;
    public static HttpCompletionOption ResponseHeadersRead;
}
public abstract class System.Net.Http.HttpContent : object {
    public HttpContentHeaders Headers { get; }
    public HttpContentHeaders get_Headers();
    public Task CopyToAsync(Stream stream);
    public Task CopyToAsync(Stream stream, TransportContext context);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public Task LoadIntoBufferAsync();
    public Task LoadIntoBufferAsync(long maxBufferSize);
    public Task`1<Byte[]> ReadAsByteArrayAsync();
    public Task`1<Stream> ReadAsStreamAsync();
    public Task`1<string> ReadAsStringAsync();
    protected abstract virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal abstract virtual bool TryComputeLength(Int64& length);
}
public abstract class System.Net.Http.HttpMessageHandler : object {
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected internal abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.HttpMessageInvoker : object {
    public HttpMessageInvoker(HttpMessageHandler handler);
    public HttpMessageInvoker(HttpMessageHandler handler, bool disposeHandler);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.HttpMethod : object {
    public static HttpMethod Delete { get; }
    public static HttpMethod Get { get; }
    public static HttpMethod Head { get; }
    public string Method { get; }
    public static HttpMethod Options { get; }
    public static HttpMethod Patch { get; }
    public static HttpMethod Post { get; }
    public static HttpMethod Put { get; }
    public static HttpMethod Trace { get; }
    public HttpMethod(string method);
    public static HttpMethod get_Delete();
    public static HttpMethod get_Get();
    public static HttpMethod get_Head();
    public string get_Method();
    public static HttpMethod get_Options();
    public static HttpMethod get_Patch();
    public static HttpMethod get_Post();
    public static HttpMethod get_Put();
    public static HttpMethod get_Trace();
    public sealed virtual bool Equals(HttpMethod other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HttpMethod left, HttpMethod right);
    public static bool op_Inequality(HttpMethod left, HttpMethod right);
    public virtual string ToString();
}
public class System.Net.Http.HttpRequestException : Exception {
    public HttpRequestException(string message);
    public HttpRequestException(string message, Exception inner);
}
public class System.Net.Http.HttpRequestMessage : object {
    public HttpContent Content { get; public set; }
    public HttpRequestHeaders Headers { get; }
    public HttpMethod Method { get; public set; }
    public IDictionary`2<string, object> Properties { get; }
    public Uri RequestUri { get; public set; }
    public Version Version { get; public set; }
    public HttpRequestMessage(HttpMethod method, string requestUri);
    public HttpRequestMessage(HttpMethod method, Uri requestUri);
    public HttpContent get_Content();
    public void set_Content(HttpContent value);
    public HttpRequestHeaders get_Headers();
    public HttpMethod get_Method();
    public void set_Method(HttpMethod value);
    public IDictionary`2<string, object> get_Properties();
    public Uri get_RequestUri();
    public void set_RequestUri(Uri value);
    public Version get_Version();
    public void set_Version(Version value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
}
public class System.Net.Http.HttpResponseMessage : object {
    public HttpContent Content { get; public set; }
    public HttpResponseHeaders Headers { get; }
    public bool IsSuccessStatusCode { get; }
    public string ReasonPhrase { get; public set; }
    public HttpRequestMessage RequestMessage { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public HttpResponseHeaders TrailingHeaders { get; }
    public Version Version { get; public set; }
    public HttpResponseMessage(HttpStatusCode statusCode);
    public HttpContent get_Content();
    public void set_Content(HttpContent value);
    public HttpResponseHeaders get_Headers();
    public bool get_IsSuccessStatusCode();
    public string get_ReasonPhrase();
    public void set_ReasonPhrase(string value);
    public HttpRequestMessage get_RequestMessage();
    public void set_RequestMessage(HttpRequestMessage value);
    public HttpStatusCode get_StatusCode();
    public void set_StatusCode(HttpStatusCode value);
    public HttpResponseHeaders get_TrailingHeaders();
    public Version get_Version();
    public void set_Version(Version value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public HttpResponseMessage EnsureSuccessStatusCode();
    public virtual string ToString();
}
public abstract class System.Net.Http.MessageProcessingHandler : DelegatingHandler {
    protected MessageProcessingHandler(HttpMessageHandler innerHandler);
    protected abstract virtual HttpRequestMessage ProcessRequest(HttpRequestMessage request, CancellationToken cancellationToken);
    protected abstract virtual HttpResponseMessage ProcessResponse(HttpResponseMessage response, CancellationToken cancellationToken);
    protected internal sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.MultipartContent : HttpContent {
    public MultipartContent(string subtype);
    public MultipartContent(string subtype, string boundary);
    public virtual void Add(HttpContent content);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<HttpContent> GetEnumerator();
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected internal virtual bool TryComputeLength(Int64& length);
}
public class System.Net.Http.MultipartFormDataContent : MultipartContent {
    public MultipartFormDataContent(string boundary);
    public virtual void Add(HttpContent content);
    public void Add(HttpContent content, string name);
    public void Add(HttpContent content, string name, string fileName);
}
public class System.Net.Http.ReadOnlyMemoryContent : HttpContent {
    public ReadOnlyMemoryContent(ReadOnlyMemory`1<byte> content);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
}
public class System.Net.Http.StreamContent : HttpContent {
    public StreamContent(Stream content);
    public StreamContent(Stream content, int bufferSize);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual void Dispose(bool disposing);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
}
public class System.Net.Http.StringContent : ByteArrayContent {
    public StringContent(string content);
    public StringContent(string content, Encoding encoding);
    public StringContent(string content, Encoding encoding, string mediaType);
}
public class System.Net.HttpContinueDelegate : MulticastDelegate {
    public HttpContinueDelegate(object object, IntPtr method);
    public virtual void Invoke(int StatusCode, WebHeaderCollection httpHeaders);
    public virtual IAsyncResult BeginInvoke(int StatusCode, WebHeaderCollection httpHeaders, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.HttpListener : object {
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; public set; }
    public ServiceNameCollection DefaultServiceNames { get; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; public set; }
    public bool IgnoreWriteExceptions { get; public set; }
    public bool IsListening { get; }
    public static bool IsSupported { get; }
    public HttpListenerPrefixCollection Prefixes { get; }
    public string Realm { get; public set; }
    public HttpListenerTimeoutManager TimeoutManager { get; }
    public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate();
    public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value);
    public ServiceNameCollection get_DefaultServiceNames();
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate();
    public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value);
    public bool get_IgnoreWriteExceptions();
    public void set_IgnoreWriteExceptions(bool value);
    public bool get_IsListening();
    public static bool get_IsSupported();
    public HttpListenerPrefixCollection get_Prefixes();
    public string get_Realm();
    public void set_Realm(string value);
    public HttpListenerTimeoutManager get_TimeoutManager();
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    public void Abort();
    public IAsyncResult BeginGetContext(AsyncCallback callback, object state);
    public void Close();
    public HttpListenerContext EndGetContext(IAsyncResult asyncResult);
    public HttpListenerContext GetContext();
    public Task`1<HttpListenerContext> GetContextAsync();
    public void Start();
    public void Stop();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class System.Net.HttpListenerBasicIdentity : GenericIdentity {
    public string Password { get; }
    public HttpListenerBasicIdentity(string username, string password);
    public virtual string get_Password();
}
public class System.Net.HttpListenerContext : object {
    public HttpListenerRequest Request { get; }
    public HttpListenerResponse Response { get; }
    public IPrincipal User { get; }
    public HttpListenerRequest get_Request();
    public HttpListenerResponse get_Response();
    public IPrincipal get_User();
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval);
    [EditorBrowsableAttribute("1")]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval);
}
public class System.Net.HttpListenerException : Win32Exception {
    public int ErrorCode { get; }
    public HttpListenerException(int errorCode);
    public HttpListenerException(int errorCode, string message);
    protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
public class System.Net.HttpListenerPrefixCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsSynchronized();
    public sealed virtual void Add(string uriPrefix);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(string uriPrefix);
    public void CopyTo(Array array, int offset);
    public sealed virtual void CopyTo(String[] array, int offset);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Remove(string uriPrefix);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Net.HttpListenerRequest : object {
    public String[] AcceptTypes { get; }
    public int ClientCertificateError { get; }
    public Encoding ContentEncoding { get; }
    public long ContentLength64 { get; }
    public string ContentType { get; }
    public CookieCollection Cookies { get; }
    public bool HasEntityBody { get; }
    public NameValueCollection Headers { get; }
    public string HttpMethod { get; }
    public Stream InputStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public bool IsWebSocketRequest { get; }
    public bool KeepAlive { get; }
    public IPEndPoint LocalEndPoint { get; }
    public Version ProtocolVersion { get; }
    public NameValueCollection QueryString { get; }
    public string RawUrl { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public Guid RequestTraceIdentifier { get; }
    public string ServiceName { get; }
    public TransportContext TransportContext { get; }
    public Uri Url { get; }
    public Uri UrlReferrer { get; }
    public string UserAgent { get; }
    public string UserHostAddress { get; }
    public string UserHostName { get; }
    public String[] UserLanguages { get; }
    public String[] get_AcceptTypes();
    public int get_ClientCertificateError();
    public Encoding get_ContentEncoding();
    public long get_ContentLength64();
    public string get_ContentType();
    public CookieCollection get_Cookies();
    public bool get_HasEntityBody();
    public NameValueCollection get_Headers();
    public string get_HttpMethod();
    public Stream get_InputStream();
    public bool get_IsAuthenticated();
    public bool get_IsLocal();
    public bool get_IsSecureConnection();
    public bool get_IsWebSocketRequest();
    public bool get_KeepAlive();
    public IPEndPoint get_LocalEndPoint();
    public Version get_ProtocolVersion();
    public NameValueCollection get_QueryString();
    public string get_RawUrl();
    public IPEndPoint get_RemoteEndPoint();
    public Guid get_RequestTraceIdentifier();
    public string get_ServiceName();
    public TransportContext get_TransportContext();
    public Uri get_Url();
    public Uri get_UrlReferrer();
    public string get_UserAgent();
    public string get_UserHostAddress();
    public string get_UserHostName();
    public String[] get_UserLanguages();
    public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state);
    public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult);
    public X509Certificate2 GetClientCertificate();
    public Task`1<X509Certificate2> GetClientCertificateAsync();
}
public class System.Net.HttpListenerResponse : object {
    public Encoding ContentEncoding { get; public set; }
    public long ContentLength64 { get; public set; }
    public string ContentType { get; public set; }
    public CookieCollection Cookies { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public bool KeepAlive { get; public set; }
    public Stream OutputStream { get; }
    public Version ProtocolVersion { get; public set; }
    public string RedirectLocation { get; public set; }
    public bool SendChunked { get; public set; }
    public int StatusCode { get; public set; }
    public string StatusDescription { get; public set; }
    public Encoding get_ContentEncoding();
    public void set_ContentEncoding(Encoding value);
    public long get_ContentLength64();
    public void set_ContentLength64(long value);
    public string get_ContentType();
    public void set_ContentType(string value);
    public CookieCollection get_Cookies();
    public void set_Cookies(CookieCollection value);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public Stream get_OutputStream();
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public string get_RedirectLocation();
    public void set_RedirectLocation(string value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public void Abort();
    public void AddHeader(string name, string value);
    public void AppendCookie(Cookie cookie);
    public void AppendHeader(string name, string value);
    public void Close();
    public void Close(Byte[] responseEntity, bool willBlock);
    public void CopyFrom(HttpListenerResponse templateResponse);
    public void Redirect(string url);
    public void SetCookie(Cookie cookie);
    private sealed virtual override void System.IDisposable.Dispose();
}
public class System.Net.HttpListenerTimeoutManager : object {
    public TimeSpan DrainEntityBody { get; public set; }
    public TimeSpan EntityBody { get; public set; }
    public TimeSpan HeaderWait { get; public set; }
    public TimeSpan IdleConnection { get; public set; }
    public long MinSendBytesPerSecond { get; public set; }
    public TimeSpan RequestQueue { get; public set; }
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_EntityBody();
    public void set_EntityBody(TimeSpan value);
    public TimeSpan get_HeaderWait();
    public void set_HeaderWait(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    public void set_MinSendBytesPerSecond(long value);
    public TimeSpan get_RequestQueue();
    public void set_RequestQueue(TimeSpan value);
}
public enum System.Net.HttpRequestHeader : Enum {
    public int value__;
    public static HttpRequestHeader Accept;
    public static HttpRequestHeader AcceptCharset;
    public static HttpRequestHeader AcceptEncoding;
    public static HttpRequestHeader AcceptLanguage;
    public static HttpRequestHeader Allow;
    public static HttpRequestHeader Authorization;
    public static HttpRequestHeader CacheControl;
    public static HttpRequestHeader Connection;
    public static HttpRequestHeader ContentEncoding;
    public static HttpRequestHeader ContentLanguage;
    public static HttpRequestHeader ContentLength;
    public static HttpRequestHeader ContentLocation;
    public static HttpRequestHeader ContentMd5;
    public static HttpRequestHeader ContentRange;
    public static HttpRequestHeader ContentType;
    public static HttpRequestHeader Cookie;
    public static HttpRequestHeader Date;
    public static HttpRequestHeader Expect;
    public static HttpRequestHeader Expires;
    public static HttpRequestHeader From;
    public static HttpRequestHeader Host;
    public static HttpRequestHeader IfMatch;
    public static HttpRequestHeader IfModifiedSince;
    public static HttpRequestHeader IfNoneMatch;
    public static HttpRequestHeader IfRange;
    public static HttpRequestHeader IfUnmodifiedSince;
    public static HttpRequestHeader KeepAlive;
    public static HttpRequestHeader LastModified;
    public static HttpRequestHeader MaxForwards;
    public static HttpRequestHeader Pragma;
    public static HttpRequestHeader ProxyAuthorization;
    public static HttpRequestHeader Range;
    public static HttpRequestHeader Referer;
    public static HttpRequestHeader Te;
    public static HttpRequestHeader Trailer;
    public static HttpRequestHeader TransferEncoding;
    public static HttpRequestHeader Translate;
    public static HttpRequestHeader Upgrade;
    public static HttpRequestHeader UserAgent;
    public static HttpRequestHeader Via;
    public static HttpRequestHeader Warning;
}
public enum System.Net.HttpResponseHeader : Enum {
    public int value__;
    public static HttpResponseHeader AcceptRanges;
    public static HttpResponseHeader Age;
    public static HttpResponseHeader Allow;
    public static HttpResponseHeader CacheControl;
    public static HttpResponseHeader Connection;
    public static HttpResponseHeader ContentEncoding;
    public static HttpResponseHeader ContentLanguage;
    public static HttpResponseHeader ContentLength;
    public static HttpResponseHeader ContentLocation;
    public static HttpResponseHeader ContentMd5;
    public static HttpResponseHeader ContentRange;
    public static HttpResponseHeader ContentType;
    public static HttpResponseHeader Date;
    public static HttpResponseHeader ETag;
    public static HttpResponseHeader Expires;
    public static HttpResponseHeader KeepAlive;
    public static HttpResponseHeader LastModified;
    public static HttpResponseHeader Location;
    public static HttpResponseHeader Pragma;
    public static HttpResponseHeader ProxyAuthenticate;
    public static HttpResponseHeader RetryAfter;
    public static HttpResponseHeader Server;
    public static HttpResponseHeader SetCookie;
    public static HttpResponseHeader Trailer;
    public static HttpResponseHeader TransferEncoding;
    public static HttpResponseHeader Upgrade;
    public static HttpResponseHeader Vary;
    public static HttpResponseHeader Via;
    public static HttpResponseHeader Warning;
    public static HttpResponseHeader WwwAuthenticate;
}
public enum System.Net.HttpStatusCode : Enum {
    public int value__;
    public static HttpStatusCode Accepted;
    public static HttpStatusCode AlreadyReported;
    public static HttpStatusCode Ambiguous;
    public static HttpStatusCode BadGateway;
    public static HttpStatusCode BadRequest;
    public static HttpStatusCode Conflict;
    public static HttpStatusCode Continue;
    public static HttpStatusCode Created;
    public static HttpStatusCode EarlyHints;
    public static HttpStatusCode ExpectationFailed;
    public static HttpStatusCode FailedDependency;
    public static HttpStatusCode Forbidden;
    public static HttpStatusCode Found;
    public static HttpStatusCode GatewayTimeout;
    public static HttpStatusCode Gone;
    public static HttpStatusCode HttpVersionNotSupported;
    public static HttpStatusCode IMUsed;
    public static HttpStatusCode InsufficientStorage;
    public static HttpStatusCode InternalServerError;
    public static HttpStatusCode LengthRequired;
    public static HttpStatusCode Locked;
    public static HttpStatusCode LoopDetected;
    public static HttpStatusCode MethodNotAllowed;
    public static HttpStatusCode MisdirectedRequest;
    public static HttpStatusCode Moved;
    public static HttpStatusCode MovedPermanently;
    public static HttpStatusCode MultipleChoices;
    public static HttpStatusCode MultiStatus;
    public static HttpStatusCode NetworkAuthenticationRequired;
    public static HttpStatusCode NoContent;
    public static HttpStatusCode NonAuthoritativeInformation;
    public static HttpStatusCode NotAcceptable;
    public static HttpStatusCode NotExtended;
    public static HttpStatusCode NotFound;
    public static HttpStatusCode NotImplemented;
    public static HttpStatusCode NotModified;
    public static HttpStatusCode OK;
    public static HttpStatusCode PartialContent;
    public static HttpStatusCode PaymentRequired;
    public static HttpStatusCode PermanentRedirect;
    public static HttpStatusCode PreconditionFailed;
    public static HttpStatusCode PreconditionRequired;
    public static HttpStatusCode Processing;
    public static HttpStatusCode ProxyAuthenticationRequired;
    public static HttpStatusCode Redirect;
    public static HttpStatusCode RedirectKeepVerb;
    public static HttpStatusCode RedirectMethod;
    public static HttpStatusCode RequestedRangeNotSatisfiable;
    public static HttpStatusCode RequestEntityTooLarge;
    public static HttpStatusCode RequestHeaderFieldsTooLarge;
    public static HttpStatusCode RequestTimeout;
    public static HttpStatusCode RequestUriTooLong;
    public static HttpStatusCode ResetContent;
    public static HttpStatusCode SeeOther;
    public static HttpStatusCode ServiceUnavailable;
    public static HttpStatusCode SwitchingProtocols;
    public static HttpStatusCode TemporaryRedirect;
    public static HttpStatusCode TooManyRequests;
    public static HttpStatusCode Unauthorized;
    public static HttpStatusCode UnavailableForLegalReasons;
    public static HttpStatusCode UnprocessableEntity;
    public static HttpStatusCode UnsupportedMediaType;
    public static HttpStatusCode Unused;
    public static HttpStatusCode UpgradeRequired;
    public static HttpStatusCode UseProxy;
    public static HttpStatusCode VariantAlsoNegotiates;
}
public static class System.Net.HttpVersion : object {
    public static Version Unknown;
    public static Version Version10;
    public static Version Version11;
    public static Version Version20;
}
public class System.Net.HttpWebRequest : WebRequest {
    public string Accept { get; public set; }
    public Uri Address { get; }
    public bool AllowAutoRedirect { get; public set; }
    public bool AllowReadStreamBuffering { get; public set; }
    public bool AllowWriteStreamBuffering { get; public set; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public string Connection { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public HttpContinueDelegate ContinueDelegate { get; public set; }
    public int ContinueTimeout { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public ICredentials Credentials { get; public set; }
    public DateTime Date { get; public set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public static int DefaultMaximumErrorResponseLength { get; public set; }
    public static int DefaultMaximumResponseHeadersLength { get; public set; }
    public string Expect { get; public set; }
    public bool HaveResponse { get; }
    public WebHeaderCollection Headers { get; public set; }
    public string Host { get; public set; }
    public DateTime IfModifiedSince { get; public set; }
    public bool KeepAlive { get; public set; }
    public int MaximumAutomaticRedirections { get; public set; }
    public int MaximumResponseHeadersLength { get; public set; }
    public string MediaType { get; public set; }
    public string Method { get; public set; }
    public bool Pipelined { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public Version ProtocolVersion { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public int ReadWriteTimeout { get; public set; }
    public string Referer { get; public set; }
    public Uri RequestUri { get; }
    public bool SendChunked { get; public set; }
    public RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    public ServicePoint ServicePoint { get; }
    public bool SupportsCookieContainer { get; }
    public int Timeout { get; public set; }
    public string TransferEncoding { get; public set; }
    public bool UnsafeAuthenticatedConnectionSharing { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public string UserAgent { get; public set; }
    [ObsoleteAttribute("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")]
protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public string get_Accept();
    public void set_Accept(string value);
    public Uri get_Address();
    public virtual bool get_AllowAutoRedirect();
    public virtual void set_AllowAutoRedirect(bool value);
    public virtual bool get_AllowReadStreamBuffering();
    public virtual void set_AllowReadStreamBuffering(bool value);
    public virtual bool get_AllowWriteStreamBuffering();
    public virtual void set_AllowWriteStreamBuffering(bool value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public string get_Connection();
    public void set_Connection(string value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public HttpContinueDelegate get_ContinueDelegate();
    public void set_ContinueDelegate(HttpContinueDelegate value);
    public int get_ContinueTimeout();
    public void set_ContinueTimeout(int value);
    public virtual CookieContainer get_CookieContainer();
    public virtual void set_CookieContainer(CookieContainer value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public DateTime get_Date();
    public void set_Date(DateTime value);
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public static int get_DefaultMaximumErrorResponseLength();
    public static void set_DefaultMaximumErrorResponseLength(int value);
    public static int get_DefaultMaximumResponseHeadersLength();
    public static void set_DefaultMaximumResponseHeadersLength(int value);
    public string get_Expect();
    public void set_Expect(string value);
    public virtual bool get_HaveResponse();
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public string get_Host();
    public void set_Host(string value);
    public DateTime get_IfModifiedSince();
    public void set_IfModifiedSince(DateTime value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public int get_MaximumAutomaticRedirections();
    public void set_MaximumAutomaticRedirections(int value);
    public int get_MaximumResponseHeadersLength();
    public void set_MaximumResponseHeadersLength(int value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public bool get_Pipelined();
    public void set_Pipelined(bool value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public string get_Referer();
    public void set_Referer(string value);
    public virtual Uri get_RequestUri();
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public ServicePoint get_ServicePoint();
    public virtual bool get_SupportsCookieContainer();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public string get_TransferEncoding();
    public void set_TransferEncoding(string value);
    public bool get_UnsafeAuthenticatedConnectionSharing();
    public void set_UnsafeAuthenticatedConnectionSharing(bool value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public virtual void Abort();
    public void AddRange(int range);
    public void AddRange(int from, int to);
    public void AddRange(long range);
    public void AddRange(long from, long to);
    public void AddRange(string rangeSpecifier, int range);
    public void AddRange(string rangeSpecifier, int from, int to);
    public void AddRange(string rangeSpecifier, long range);
    public void AddRange(string rangeSpecifier, long from, long to);
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public Stream EndGetRequestStream(IAsyncResult asyncResult, TransportContext& context);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    [ObsoleteAttribute("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual Stream GetRequestStream();
    public Stream GetRequestStream(TransportContext& context);
    public virtual WebResponse GetResponse();
    [ObsoleteAttribute("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Net.HttpWebResponse : WebResponse {
    public string CharacterSet { get; }
    public string ContentEncoding { get; }
    public long ContentLength { get; }
    public string ContentType { get; }
    public CookieCollection Cookies { get; public set; }
    public WebHeaderCollection Headers { get; }
    public bool IsMutuallyAuthenticated { get; }
    public DateTime LastModified { get; }
    public string Method { get; }
    public Version ProtocolVersion { get; }
    public Uri ResponseUri { get; }
    public string Server { get; }
    public HttpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public bool SupportsHeaders { get; }
    [ObsoleteAttribute("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")]
protected HttpWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public string get_CharacterSet();
    public string get_ContentEncoding();
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual CookieCollection get_Cookies();
    public virtual void set_Cookies(CookieCollection value);
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_IsMutuallyAuthenticated();
    public DateTime get_LastModified();
    public virtual string get_Method();
    public Version get_ProtocolVersion();
    public virtual Uri get_ResponseUri();
    public string get_Server();
    public virtual HttpStatusCode get_StatusCode();
    public virtual string get_StatusDescription();
    public virtual bool get_SupportsHeaders();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    [ObsoleteAttribute("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public string GetResponseHeader(string headerName);
    public virtual Stream GetResponseStream();
    [ObsoleteAttribute("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public interface System.Net.IAuthenticationModule {
    public string AuthenticationType { get; }
    public bool CanPreAuthenticate { get; }
    public abstract virtual string get_AuthenticationType();
    public abstract virtual bool get_CanPreAuthenticate();
    public abstract virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public abstract virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
}
public interface System.Net.ICredentialPolicy {
    public abstract virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule);
}
public interface System.Net.ICredentials {
    public abstract virtual NetworkCredential GetCredential(Uri uri, string authType);
}
public interface System.Net.ICredentialsByHost {
    public abstract virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
}
public class System.Net.IPAddress : object {
    public static IPAddress Any;
    public static IPAddress Broadcast;
    public static IPAddress IPv6Any;
    public static IPAddress IPv6Loopback;
    public static IPAddress IPv6None;
    public static IPAddress Loopback;
    public static IPAddress None;
    [ObsoleteAttribute("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. https://go.microsoft.com/fwlink/?linkid=14202")]
public long Address { get; public set; }
    public AddressFamily AddressFamily { get; }
    public bool IsIPv4MappedToIPv6 { get; }
    public bool IsIPv6LinkLocal { get; }
    public bool IsIPv6Multicast { get; }
    public bool IsIPv6SiteLocal { get; }
    public bool IsIPv6Teredo { get; }
    public long ScopeId { get; public set; }
    public IPAddress(Byte[] address);
    public IPAddress(Byte[] address, long scopeid);
    public IPAddress(long newAddress);
    public IPAddress(ReadOnlySpan`1<byte> address);
    public IPAddress(ReadOnlySpan`1<byte> address, long scopeid);
    public long get_Address();
    public void set_Address(long value);
    public AddressFamily get_AddressFamily();
    public bool get_IsIPv4MappedToIPv6();
    public bool get_IsIPv6LinkLocal();
    public bool get_IsIPv6Multicast();
    public bool get_IsIPv6SiteLocal();
    public bool get_IsIPv6Teredo();
    public long get_ScopeId();
    public void set_ScopeId(long value);
    public virtual bool Equals(object comparand);
    public Byte[] GetAddressBytes();
    public virtual int GetHashCode();
    public static short HostToNetworkOrder(short host);
    public static int HostToNetworkOrder(int host);
    public static long HostToNetworkOrder(long host);
    public static bool IsLoopback(IPAddress address);
    public IPAddress MapToIPv4();
    public IPAddress MapToIPv6();
    public static short NetworkToHostOrder(short network);
    public static int NetworkToHostOrder(int network);
    public static long NetworkToHostOrder(long network);
    public static IPAddress Parse(ReadOnlySpan`1<char> ipString);
    public static IPAddress Parse(string ipString);
    public virtual string ToString();
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public static bool TryParse(ReadOnlySpan`1<char> ipString, IPAddress& address);
    public static bool TryParse(string ipString, IPAddress& address);
    public bool TryWriteBytes(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Net.IPEndPoint : EndPoint {
    public static int MaxPort;
    public static int MinPort;
    public IPAddress Address { get; public set; }
    public AddressFamily AddressFamily { get; }
    public int Port { get; public set; }
    public IPEndPoint(long address, int port);
    public IPEndPoint(IPAddress address, int port);
    public IPAddress get_Address();
    public void set_Address(IPAddress value);
    public virtual AddressFamily get_AddressFamily();
    public int get_Port();
    public void set_Port(int value);
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual SocketAddress Serialize();
    public virtual string ToString();
}
public class System.Net.IPHostEntry : object {
    public IPAddress[] AddressList { get; public set; }
    public String[] Aliases { get; public set; }
    public string HostName { get; public set; }
    public IPAddress[] get_AddressList();
    public void set_AddressList(IPAddress[] value);
    public String[] get_Aliases();
    public void set_Aliases(String[] value);
    public string get_HostName();
    public void set_HostName(string value);
}
public interface System.Net.IWebProxy {
    public ICredentials Credentials { get; public set; }
    public abstract virtual ICredentials get_Credentials();
    public abstract virtual void set_Credentials(ICredentials value);
    public abstract virtual Uri GetProxy(Uri destination);
    public abstract virtual bool IsBypassed(Uri host);
}
public interface System.Net.IWebProxyScript {
    public abstract virtual void Close();
    public abstract virtual bool Load(Uri scriptLocation, string script, Type helperType);
    public abstract virtual string Run(string url, string host);
}
public interface System.Net.IWebRequestCreate {
    public abstract virtual WebRequest Create(Uri uri);
}
public class System.Net.Mail.AlternateView : AttachmentBase {
    public Uri BaseUri { get; public set; }
    public LinkedResourceCollection LinkedResources { get; }
    public AlternateView(Stream contentStream);
    public AlternateView(Stream contentStream, ContentType contentType);
    public AlternateView(Stream contentStream, string mediaType);
    public AlternateView(string fileName);
    public AlternateView(string fileName, ContentType contentType);
    public AlternateView(string fileName, string mediaType);
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public LinkedResourceCollection get_LinkedResources();
    public static AlternateView CreateAlternateViewFromString(string content);
    public static AlternateView CreateAlternateViewFromString(string content, ContentType contentType);
    public static AlternateView CreateAlternateViewFromString(string content, Encoding contentEncoding, string mediaType);
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
    protected virtual void ClearItems();
    public sealed virtual void Dispose();
    protected virtual void InsertItem(int index, AlternateView item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, AlternateView item);
}
public class System.Net.Mail.Attachment : AttachmentBase {
    public ContentDisposition ContentDisposition { get; }
    public string Name { get; public set; }
    public Encoding NameEncoding { get; public set; }
    public Attachment(Stream contentStream, ContentType contentType);
    public Attachment(Stream contentStream, string name);
    public Attachment(Stream contentStream, string name, string mediaType);
    public Attachment(string fileName);
    public Attachment(string fileName, ContentType contentType);
    public Attachment(string fileName, string mediaType);
    public ContentDisposition get_ContentDisposition();
    public string get_Name();
    public void set_Name(string value);
    public Encoding get_NameEncoding();
    public void set_NameEncoding(Encoding value);
    public static Attachment CreateAttachmentFromString(string content, ContentType contentType);
    public static Attachment CreateAttachmentFromString(string content, string name);
    public static Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType);
}
public abstract class System.Net.Mail.AttachmentBase : object {
    public string ContentId { get; public set; }
    public Stream ContentStream { get; }
    public ContentType ContentType { get; public set; }
    public TransferEncoding TransferEncoding { get; public set; }
    protected AttachmentBase(Stream contentStream);
    protected AttachmentBase(Stream contentStream, ContentType contentType);
    protected AttachmentBase(Stream contentStream, string mediaType);
    protected AttachmentBase(string fileName);
    protected AttachmentBase(string fileName, ContentType contentType);
    protected AttachmentBase(string fileName, string mediaType);
    public string get_ContentId();
    public void set_ContentId(string value);
    public Stream get_ContentStream();
    public ContentType get_ContentType();
    public void set_ContentType(ContentType value);
    public TransferEncoding get_TransferEncoding();
    public void set_TransferEncoding(TransferEncoding value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
    protected virtual void ClearItems();
    public sealed virtual void Dispose();
    protected virtual void InsertItem(int index, Attachment item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, Attachment item);
}
[FlagsAttribute]
public enum System.Net.Mail.DeliveryNotificationOptions : Enum {
    public int value__;
    public static DeliveryNotificationOptions Delay;
    public static DeliveryNotificationOptions Never;
    public static DeliveryNotificationOptions None;
    public static DeliveryNotificationOptions OnFailure;
    public static DeliveryNotificationOptions OnSuccess;
}
public class System.Net.Mail.LinkedResource : AttachmentBase {
    public Uri ContentLink { get; public set; }
    public LinkedResource(Stream contentStream);
    public LinkedResource(Stream contentStream, ContentType contentType);
    public LinkedResource(Stream contentStream, string mediaType);
    public LinkedResource(string fileName);
    public LinkedResource(string fileName, ContentType contentType);
    public LinkedResource(string fileName, string mediaType);
    public Uri get_ContentLink();
    public void set_ContentLink(Uri value);
    public static LinkedResource CreateLinkedResourceFromString(string content);
    public static LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType);
    public static LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType);
}
public class System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
    protected virtual void ClearItems();
    public sealed virtual void Dispose();
    protected virtual void InsertItem(int index, LinkedResource item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, LinkedResource item);
}
public class System.Net.Mail.MailAddress : object {
    public string Address { get; }
    public string DisplayName { get; }
    public string Host { get; }
    public string User { get; }
    public MailAddress(string address);
    public MailAddress(string address, string displayName);
    public MailAddress(string address, string displayName, Encoding displayNameEncoding);
    public string get_Address();
    public string get_DisplayName();
    public string get_Host();
    public string get_User();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
    public void Add(string addresses);
    protected virtual void InsertItem(int index, MailAddress item);
    protected virtual void SetItem(int index, MailAddress item);
    public virtual string ToString();
}
public class System.Net.Mail.MailMessage : object {
    public AlternateViewCollection AlternateViews { get; }
    public AttachmentCollection Attachments { get; }
    public MailAddressCollection Bcc { get; }
    public string Body { get; public set; }
    public Encoding BodyEncoding { get; public set; }
    public TransferEncoding BodyTransferEncoding { get; public set; }
    public MailAddressCollection CC { get; }
    public DeliveryNotificationOptions DeliveryNotificationOptions { get; public set; }
    public MailAddress From { get; public set; }
    public NameValueCollection Headers { get; }
    public Encoding HeadersEncoding { get; public set; }
    public bool IsBodyHtml { get; public set; }
    public MailPriority Priority { get; public set; }
    [ObsoleteAttribute("ReplyTo is obsoleted for this type.  Please use ReplyToList instead which can accept multiple addresses. https://go.microsoft.com/fwlink/?linkid=14202")]
public MailAddress ReplyTo { get; public set; }
    public MailAddressCollection ReplyToList { get; }
    public MailAddress Sender { get; public set; }
    public string Subject { get; public set; }
    public Encoding SubjectEncoding { get; public set; }
    public MailAddressCollection To { get; }
    public MailMessage(MailAddress from, MailAddress to);
    public MailMessage(string from, string to);
    public MailMessage(string from, string to, string subject, string body);
    public AlternateViewCollection get_AlternateViews();
    public AttachmentCollection get_Attachments();
    public MailAddressCollection get_Bcc();
    public string get_Body();
    public void set_Body(string value);
    public Encoding get_BodyEncoding();
    public void set_BodyEncoding(Encoding value);
    public TransferEncoding get_BodyTransferEncoding();
    public void set_BodyTransferEncoding(TransferEncoding value);
    public MailAddressCollection get_CC();
    public DeliveryNotificationOptions get_DeliveryNotificationOptions();
    public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value);
    public MailAddress get_From();
    public void set_From(MailAddress value);
    public NameValueCollection get_Headers();
    public Encoding get_HeadersEncoding();
    public void set_HeadersEncoding(Encoding value);
    public bool get_IsBodyHtml();
    public void set_IsBodyHtml(bool value);
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    public MailAddress get_ReplyTo();
    public void set_ReplyTo(MailAddress value);
    public MailAddressCollection get_ReplyToList();
    public MailAddress get_Sender();
    public void set_Sender(MailAddress value);
    public string get_Subject();
    public void set_Subject(string value);
    public Encoding get_SubjectEncoding();
    public void set_SubjectEncoding(Encoding value);
    public MailAddressCollection get_To();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum System.Net.Mail.MailPriority : Enum {
    public int value__;
    public static MailPriority High;
    public static MailPriority Low;
    public static MailPriority Normal;
}
public class System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
    public SendCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.Mail.SmtpClient : object {
    public X509CertificateCollection ClientCertificates { get; }
    public ICredentialsByHost Credentials { get; public set; }
    public SmtpDeliveryFormat DeliveryFormat { get; public set; }
    public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    public bool EnableSsl { get; public set; }
    public string Host { get; public set; }
    public string PickupDirectoryLocation { get; public set; }
    public int Port { get; public set; }
    public ServicePoint ServicePoint { get; }
    public string TargetName { get; public set; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public SmtpClient(string host);
    public SmtpClient(string host, int port);
    public X509CertificateCollection get_ClientCertificates();
    public ICredentialsByHost get_Credentials();
    public void set_Credentials(ICredentialsByHost value);
    public SmtpDeliveryFormat get_DeliveryFormat();
    public void set_DeliveryFormat(SmtpDeliveryFormat value);
    public SmtpDeliveryMethod get_DeliveryMethod();
    public void set_DeliveryMethod(SmtpDeliveryMethod value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public string get_Host();
    public void set_Host(string value);
    public string get_PickupDirectoryLocation();
    public void set_PickupDirectoryLocation(string value);
    public int get_Port();
    public void set_Port(int value);
    public ServicePoint get_ServicePoint();
    public string get_TargetName();
    public void set_TargetName(string value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public void add_SendCompleted(SendCompletedEventHandler value);
    public void remove_SendCompleted(SendCompletedEventHandler value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected void OnSendCompleted(AsyncCompletedEventArgs e);
    public void Send(MailMessage message);
    public void Send(string from, string recipients, string subject, string body);
    public void SendAsync(MailMessage message, object userToken);
    public void SendAsync(string from, string recipients, string subject, string body, object userToken);
    public void SendAsyncCancel();
    public Task SendMailAsync(MailMessage message);
    public Task SendMailAsync(string from, string recipients, string subject, string body);
}
public enum System.Net.Mail.SmtpDeliveryFormat : Enum {
    public int value__;
    public static SmtpDeliveryFormat International;
    public static SmtpDeliveryFormat SevenBit;
}
public enum System.Net.Mail.SmtpDeliveryMethod : Enum {
    public int value__;
    public static SmtpDeliveryMethod Network;
    public static SmtpDeliveryMethod PickupDirectoryFromIis;
    public static SmtpDeliveryMethod SpecifiedPickupDirectory;
}
public class System.Net.Mail.SmtpException : Exception {
    public SmtpStatusCode StatusCode { get; public set; }
    public SmtpException(SmtpStatusCode statusCode);
    public SmtpException(SmtpStatusCode statusCode, string message);
    protected SmtpException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public SmtpException(string message);
    public SmtpException(string message, Exception innerException);
    public SmtpStatusCode get_StatusCode();
    public void set_StatusCode(SmtpStatusCode value);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Net.Mail.SmtpFailedRecipientException : SmtpException {
    public string FailedRecipient { get; }
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient, string serverResponse);
    protected SmtpFailedRecipientException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientException(string message);
    public SmtpFailedRecipientException(string message, Exception innerException);
    public SmtpFailedRecipientException(string message, string failedRecipient, Exception innerException);
    public string get_FailedRecipient();
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
    public SmtpFailedRecipientException[] InnerExceptions { get; }
    protected SmtpFailedRecipientsException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientsException(string message);
    public SmtpFailedRecipientsException(string message, Exception innerException);
    public SmtpFailedRecipientsException(string message, SmtpFailedRecipientException[] innerExceptions);
    public SmtpFailedRecipientException[] get_InnerExceptions();
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.Net.Mail.SmtpStatusCode : Enum {
    public int value__;
    public static SmtpStatusCode BadCommandSequence;
    public static SmtpStatusCode CannotVerifyUserWillAttemptDelivery;
    public static SmtpStatusCode ClientNotPermitted;
    public static SmtpStatusCode CommandNotImplemented;
    public static SmtpStatusCode CommandParameterNotImplemented;
    public static SmtpStatusCode CommandUnrecognized;
    public static SmtpStatusCode ExceededStorageAllocation;
    public static SmtpStatusCode GeneralFailure;
    public static SmtpStatusCode HelpMessage;
    public static SmtpStatusCode InsufficientStorage;
    public static SmtpStatusCode LocalErrorInProcessing;
    public static SmtpStatusCode MailboxBusy;
    public static SmtpStatusCode MailboxNameNotAllowed;
    public static SmtpStatusCode MailboxUnavailable;
    public static SmtpStatusCode MustIssueStartTlsFirst;
    public static SmtpStatusCode Ok;
    public static SmtpStatusCode ServiceClosingTransmissionChannel;
    public static SmtpStatusCode ServiceNotAvailable;
    public static SmtpStatusCode ServiceReady;
    public static SmtpStatusCode StartMailInput;
    public static SmtpStatusCode SyntaxError;
    public static SmtpStatusCode SystemStatus;
    public static SmtpStatusCode TransactionFailed;
    public static SmtpStatusCode UserNotLocalTryAlternatePath;
    public static SmtpStatusCode UserNotLocalWillForward;
}
public class System.Net.Mime.ContentDisposition : object {
    public DateTime CreationDate { get; public set; }
    public string DispositionType { get; public set; }
    public string FileName { get; public set; }
    public bool Inline { get; public set; }
    public DateTime ModificationDate { get; public set; }
    public StringDictionary Parameters { get; }
    public DateTime ReadDate { get; public set; }
    public long Size { get; public set; }
    public ContentDisposition(string disposition);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public bool get_Inline();
    public void set_Inline(bool value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    public StringDictionary get_Parameters();
    public DateTime get_ReadDate();
    public void set_ReadDate(DateTime value);
    public long get_Size();
    public void set_Size(long value);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Net.Mime.ContentType : object {
    public string Boundary { get; public set; }
    public string CharSet { get; public set; }
    public string MediaType { get; public set; }
    public string Name { get; public set; }
    public StringDictionary Parameters { get; }
    public ContentType(string contentType);
    public string get_Boundary();
    public void set_Boundary(string value);
    public string get_CharSet();
    public void set_CharSet(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_Name();
    public void set_Name(string value);
    public StringDictionary get_Parameters();
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class System.Net.Mime.DispositionTypeNames : object {
    public static string Attachment;
    public static string Inline;
}
public static class System.Net.Mime.MediaTypeNames : object {
}
public enum System.Net.Mime.TransferEncoding : Enum {
    public int value__;
    public static TransferEncoding Base64;
    public static TransferEncoding EightBit;
    public static TransferEncoding QuotedPrintable;
    public static TransferEncoding SevenBit;
    public static TransferEncoding Unknown;
}
public class System.Net.NetworkCredential : object {
    public string Domain { get; public set; }
    public string Password { get; public set; }
    [CLSCompliantAttribute("False")]
public SecureString SecurePassword { get; public set; }
    public string UserName { get; public set; }
    [CLSCompliantAttribute("False")]
public NetworkCredential(string userName, SecureString password);
    [CLSCompliantAttribute("False")]
public NetworkCredential(string userName, SecureString password, string domain);
    public NetworkCredential(string userName, string password);
    public NetworkCredential(string userName, string password, string domain);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_Password();
    public void set_Password(string value);
    public SecureString get_SecurePassword();
    public void set_SecurePassword(SecureString value);
    public string get_UserName();
    public void set_UserName(string value);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
    public sealed virtual NetworkCredential GetCredential(Uri uri, string authType);
}
public enum System.Net.NetworkInformation.DuplicateAddressDetectionState : Enum {
    public int value__;
    public static DuplicateAddressDetectionState Deprecated;
    public static DuplicateAddressDetectionState Duplicate;
    public static DuplicateAddressDetectionState Invalid;
    public static DuplicateAddressDetectionState Preferred;
    public static DuplicateAddressDetectionState Tentative;
}
public abstract class System.Net.NetworkInformation.GatewayIPAddressInformation : object {
    public IPAddress Address { get; }
    public abstract virtual IPAddress get_Address();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.GatewayIPAddressInformationCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public GatewayIPAddressInformation Item { get; }
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual GatewayIPAddressInformation get_Item(int index);
    public virtual void Add(GatewayIPAddressInformation address);
    public virtual void Clear();
    public virtual bool Contains(GatewayIPAddressInformation address);
    public virtual void CopyTo(GatewayIPAddressInformation[] array, int offset);
    public virtual IEnumerator`1<GatewayIPAddressInformation> GetEnumerator();
    public virtual bool Remove(GatewayIPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.Net.NetworkInformation.IcmpV4Statistics : object {
    public long AddressMaskRepliesReceived { get; }
    public long AddressMaskRepliesSent { get; }
    public long AddressMaskRequestsReceived { get; }
    public long AddressMaskRequestsSent { get; }
    public long DestinationUnreachableMessagesReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long EchoRepliesReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRequestsSent { get; }
    public long ErrorsReceived { get; }
    public long ErrorsSent { get; }
    public long MessagesReceived { get; }
    public long MessagesSent { get; }
    public long ParameterProblemsReceived { get; }
    public long ParameterProblemsSent { get; }
    public long RedirectsReceived { get; }
    public long RedirectsSent { get; }
    public long SourceQuenchesReceived { get; }
    public long SourceQuenchesSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public long TimestampRepliesReceived { get; }
    public long TimestampRepliesSent { get; }
    public long TimestampRequestsReceived { get; }
    public long TimestampRequestsSent { get; }
    public abstract virtual long get_AddressMaskRepliesReceived();
    public abstract virtual long get_AddressMaskRepliesSent();
    public abstract virtual long get_AddressMaskRequestsReceived();
    public abstract virtual long get_AddressMaskRequestsSent();
    public abstract virtual long get_DestinationUnreachableMessagesReceived();
    public abstract virtual long get_DestinationUnreachableMessagesSent();
    public abstract virtual long get_EchoRepliesReceived();
    public abstract virtual long get_EchoRepliesSent();
    public abstract virtual long get_EchoRequestsReceived();
    public abstract virtual long get_EchoRequestsSent();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_ErrorsSent();
    public abstract virtual long get_MessagesReceived();
    public abstract virtual long get_MessagesSent();
    public abstract virtual long get_ParameterProblemsReceived();
    public abstract virtual long get_ParameterProblemsSent();
    public abstract virtual long get_RedirectsReceived();
    public abstract virtual long get_RedirectsSent();
    public abstract virtual long get_SourceQuenchesReceived();
    public abstract virtual long get_SourceQuenchesSent();
    public abstract virtual long get_TimeExceededMessagesReceived();
    public abstract virtual long get_TimeExceededMessagesSent();
    public abstract virtual long get_TimestampRepliesReceived();
    public abstract virtual long get_TimestampRepliesSent();
    public abstract virtual long get_TimestampRequestsReceived();
    public abstract virtual long get_TimestampRequestsSent();
}
public abstract class System.Net.NetworkInformation.IcmpV6Statistics : object {
    public long DestinationUnreachableMessagesReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long EchoRepliesReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRequestsSent { get; }
    public long ErrorsReceived { get; }
    public long ErrorsSent { get; }
    public long MembershipQueriesReceived { get; }
    public long MembershipQueriesSent { get; }
    public long MembershipReductionsReceived { get; }
    public long MembershipReductionsSent { get; }
    public long MembershipReportsReceived { get; }
    public long MembershipReportsSent { get; }
    public long MessagesReceived { get; }
    public long MessagesSent { get; }
    public long NeighborAdvertisementsReceived { get; }
    public long NeighborAdvertisementsSent { get; }
    public long NeighborSolicitsReceived { get; }
    public long NeighborSolicitsSent { get; }
    public long PacketTooBigMessagesReceived { get; }
    public long PacketTooBigMessagesSent { get; }
    public long ParameterProblemsReceived { get; }
    public long ParameterProblemsSent { get; }
    public long RedirectsReceived { get; }
    public long RedirectsSent { get; }
    public long RouterAdvertisementsReceived { get; }
    public long RouterAdvertisementsSent { get; }
    public long RouterSolicitsReceived { get; }
    public long RouterSolicitsSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public abstract virtual long get_DestinationUnreachableMessagesReceived();
    public abstract virtual long get_DestinationUnreachableMessagesSent();
    public abstract virtual long get_EchoRepliesReceived();
    public abstract virtual long get_EchoRepliesSent();
    public abstract virtual long get_EchoRequestsReceived();
    public abstract virtual long get_EchoRequestsSent();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_ErrorsSent();
    public abstract virtual long get_MembershipQueriesReceived();
    public abstract virtual long get_MembershipQueriesSent();
    public abstract virtual long get_MembershipReductionsReceived();
    public abstract virtual long get_MembershipReductionsSent();
    public abstract virtual long get_MembershipReportsReceived();
    public abstract virtual long get_MembershipReportsSent();
    public abstract virtual long get_MessagesReceived();
    public abstract virtual long get_MessagesSent();
    public abstract virtual long get_NeighborAdvertisementsReceived();
    public abstract virtual long get_NeighborAdvertisementsSent();
    public abstract virtual long get_NeighborSolicitsReceived();
    public abstract virtual long get_NeighborSolicitsSent();
    public abstract virtual long get_PacketTooBigMessagesReceived();
    public abstract virtual long get_PacketTooBigMessagesSent();
    public abstract virtual long get_ParameterProblemsReceived();
    public abstract virtual long get_ParameterProblemsSent();
    public abstract virtual long get_RedirectsReceived();
    public abstract virtual long get_RedirectsSent();
    public abstract virtual long get_RouterAdvertisementsReceived();
    public abstract virtual long get_RouterAdvertisementsSent();
    public abstract virtual long get_RouterSolicitsReceived();
    public abstract virtual long get_RouterSolicitsSent();
    public abstract virtual long get_TimeExceededMessagesReceived();
    public abstract virtual long get_TimeExceededMessagesSent();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.IPAddressCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IPAddress Item { get; }
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual IPAddress get_Item(int index);
    public virtual void Add(IPAddress address);
    public virtual void Clear();
    public virtual bool Contains(IPAddress address);
    public virtual void CopyTo(IPAddress[] array, int offset);
    public virtual IEnumerator`1<IPAddress> GetEnumerator();
    public virtual bool Remove(IPAddress address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.Net.NetworkInformation.IPAddressInformation : object {
    public IPAddress Address { get; }
    public bool IsDnsEligible { get; }
    public bool IsTransient { get; }
    public abstract virtual IPAddress get_Address();
    public abstract virtual bool get_IsDnsEligible();
    public abstract virtual bool get_IsTransient();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.IPAddressInformationCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IPAddressInformation Item { get; }
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual IPAddressInformation get_Item(int index);
    public virtual void Add(IPAddressInformation address);
    public virtual void Clear();
    public virtual bool Contains(IPAddressInformation address);
    public virtual void CopyTo(IPAddressInformation[] array, int offset);
    public virtual IEnumerator`1<IPAddressInformation> GetEnumerator();
    public virtual bool Remove(IPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.Net.NetworkInformation.IPGlobalProperties : object {
    public string DhcpScopeName { get; }
    public string DomainName { get; }
    public string HostName { get; }
    public bool IsWinsProxy { get; }
    public NetBiosNodeType NodeType { get; }
    public abstract virtual string get_DhcpScopeName();
    public abstract virtual string get_DomainName();
    public abstract virtual string get_HostName();
    public abstract virtual bool get_IsWinsProxy();
    public abstract virtual NetBiosNodeType get_NodeType();
    public virtual IAsyncResult BeginGetUnicastAddresses(AsyncCallback callback, object state);
    public virtual UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult);
    public abstract virtual TcpConnectionInformation[] GetActiveTcpConnections();
    public abstract virtual IPEndPoint[] GetActiveTcpListeners();
    public abstract virtual IPEndPoint[] GetActiveUdpListeners();
    public abstract virtual IcmpV4Statistics GetIcmpV4Statistics();
    public abstract virtual IcmpV6Statistics GetIcmpV6Statistics();
    public static IPGlobalProperties GetIPGlobalProperties();
    public abstract virtual IPGlobalStatistics GetIPv4GlobalStatistics();
    public abstract virtual IPGlobalStatistics GetIPv6GlobalStatistics();
    public abstract virtual TcpStatistics GetTcpIPv4Statistics();
    public abstract virtual TcpStatistics GetTcpIPv6Statistics();
    public abstract virtual UdpStatistics GetUdpIPv4Statistics();
    public abstract virtual UdpStatistics GetUdpIPv6Statistics();
    public virtual UnicastIPAddressInformationCollection GetUnicastAddresses();
    public virtual Task`1<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync();
}
public abstract class System.Net.NetworkInformation.IPGlobalStatistics : object {
    public int DefaultTtl { get; }
    public bool ForwardingEnabled { get; }
    public int NumberOfInterfaces { get; }
    public int NumberOfIPAddresses { get; }
    public int NumberOfRoutes { get; }
    public long OutputPacketRequests { get; }
    public long OutputPacketRoutingDiscards { get; }
    public long OutputPacketsDiscarded { get; }
    public long OutputPacketsWithNoRoute { get; }
    public long PacketFragmentFailures { get; }
    public long PacketReassembliesRequired { get; }
    public long PacketReassemblyFailures { get; }
    public long PacketReassemblyTimeout { get; }
    public long PacketsFragmented { get; }
    public long PacketsReassembled { get; }
    public long ReceivedPackets { get; }
    public long ReceivedPacketsDelivered { get; }
    public long ReceivedPacketsDiscarded { get; }
    public long ReceivedPacketsForwarded { get; }
    public long ReceivedPacketsWithAddressErrors { get; }
    public long ReceivedPacketsWithHeadersErrors { get; }
    public long ReceivedPacketsWithUnknownProtocol { get; }
    public abstract virtual int get_DefaultTtl();
    public abstract virtual bool get_ForwardingEnabled();
    public abstract virtual int get_NumberOfInterfaces();
    public abstract virtual int get_NumberOfIPAddresses();
    public abstract virtual int get_NumberOfRoutes();
    public abstract virtual long get_OutputPacketRequests();
    public abstract virtual long get_OutputPacketRoutingDiscards();
    public abstract virtual long get_OutputPacketsDiscarded();
    public abstract virtual long get_OutputPacketsWithNoRoute();
    public abstract virtual long get_PacketFragmentFailures();
    public abstract virtual long get_PacketReassembliesRequired();
    public abstract virtual long get_PacketReassemblyFailures();
    public abstract virtual long get_PacketReassemblyTimeout();
    public abstract virtual long get_PacketsFragmented();
    public abstract virtual long get_PacketsReassembled();
    public abstract virtual long get_ReceivedPackets();
    public abstract virtual long get_ReceivedPacketsDelivered();
    public abstract virtual long get_ReceivedPacketsDiscarded();
    public abstract virtual long get_ReceivedPacketsForwarded();
    public abstract virtual long get_ReceivedPacketsWithAddressErrors();
    public abstract virtual long get_ReceivedPacketsWithHeadersErrors();
    public abstract virtual long get_ReceivedPacketsWithUnknownProtocol();
}
public abstract class System.Net.NetworkInformation.IPInterfaceProperties : object {
    public IPAddressInformationCollection AnycastAddresses { get; }
    public IPAddressCollection DhcpServerAddresses { get; }
    public IPAddressCollection DnsAddresses { get; }
    public string DnsSuffix { get; }
    public GatewayIPAddressInformationCollection GatewayAddresses { get; }
    public bool IsDnsEnabled { get; }
    public bool IsDynamicDnsEnabled { get; }
    public MulticastIPAddressInformationCollection MulticastAddresses { get; }
    public UnicastIPAddressInformationCollection UnicastAddresses { get; }
    public IPAddressCollection WinsServersAddresses { get; }
    public abstract virtual IPAddressInformationCollection get_AnycastAddresses();
    public abstract virtual IPAddressCollection get_DhcpServerAddresses();
    public abstract virtual IPAddressCollection get_DnsAddresses();
    public abstract virtual string get_DnsSuffix();
    public abstract virtual GatewayIPAddressInformationCollection get_GatewayAddresses();
    public abstract virtual bool get_IsDnsEnabled();
    public abstract virtual bool get_IsDynamicDnsEnabled();
    public abstract virtual MulticastIPAddressInformationCollection get_MulticastAddresses();
    public abstract virtual UnicastIPAddressInformationCollection get_UnicastAddresses();
    public abstract virtual IPAddressCollection get_WinsServersAddresses();
    public abstract virtual IPv4InterfaceProperties GetIPv4Properties();
    public abstract virtual IPv6InterfaceProperties GetIPv6Properties();
}
public abstract class System.Net.NetworkInformation.IPInterfaceStatistics : object {
    public long BytesReceived { get; }
    public long BytesSent { get; }
    public long IncomingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    public long NonUnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long OutputQueueLength { get; }
    public long UnicastPacketsReceived { get; }
    public long UnicastPacketsSent { get; }
    public abstract virtual long get_BytesReceived();
    public abstract virtual long get_BytesSent();
    public abstract virtual long get_IncomingPacketsDiscarded();
    public abstract virtual long get_IncomingPacketsWithErrors();
    public abstract virtual long get_IncomingUnknownProtocolPackets();
    public abstract virtual long get_NonUnicastPacketsReceived();
    public abstract virtual long get_NonUnicastPacketsSent();
    public abstract virtual long get_OutgoingPacketsDiscarded();
    public abstract virtual long get_OutgoingPacketsWithErrors();
    public abstract virtual long get_OutputQueueLength();
    public abstract virtual long get_UnicastPacketsReceived();
    public abstract virtual long get_UnicastPacketsSent();
}
public enum System.Net.NetworkInformation.IPStatus : Enum {
    public int value__;
    public static IPStatus BadDestination;
    public static IPStatus BadHeader;
    public static IPStatus BadOption;
    public static IPStatus BadRoute;
    public static IPStatus DestinationHostUnreachable;
    public static IPStatus DestinationNetworkUnreachable;
    public static IPStatus DestinationPortUnreachable;
    public static IPStatus DestinationProhibited;
    public static IPStatus DestinationProtocolUnreachable;
    public static IPStatus DestinationScopeMismatch;
    public static IPStatus DestinationUnreachable;
    public static IPStatus HardwareError;
    public static IPStatus IcmpError;
    public static IPStatus NoResources;
    public static IPStatus PacketTooBig;
    public static IPStatus ParameterProblem;
    public static IPStatus SourceQuench;
    public static IPStatus Success;
    public static IPStatus TimedOut;
    public static IPStatus TimeExceeded;
    public static IPStatus TtlExpired;
    public static IPStatus TtlReassemblyTimeExceeded;
    public static IPStatus Unknown;
    public static IPStatus UnrecognizedNextHeader;
}
public abstract class System.Net.NetworkInformation.IPv4InterfaceProperties : object {
    public int Index { get; }
    public bool IsAutomaticPrivateAddressingActive { get; }
    public bool IsAutomaticPrivateAddressingEnabled { get; }
    public bool IsDhcpEnabled { get; }
    public bool IsForwardingEnabled { get; }
    public int Mtu { get; }
    public bool UsesWins { get; }
    public abstract virtual int get_Index();
    public abstract virtual bool get_IsAutomaticPrivateAddressingActive();
    public abstract virtual bool get_IsAutomaticPrivateAddressingEnabled();
    public abstract virtual bool get_IsDhcpEnabled();
    public abstract virtual bool get_IsForwardingEnabled();
    public abstract virtual int get_Mtu();
    public abstract virtual bool get_UsesWins();
}
public abstract class System.Net.NetworkInformation.IPv4InterfaceStatistics : object {
    public long BytesReceived { get; }
    public long BytesSent { get; }
    public long IncomingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    public long NonUnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long OutputQueueLength { get; }
    public long UnicastPacketsReceived { get; }
    public long UnicastPacketsSent { get; }
    public abstract virtual long get_BytesReceived();
    public abstract virtual long get_BytesSent();
    public abstract virtual long get_IncomingPacketsDiscarded();
    public abstract virtual long get_IncomingPacketsWithErrors();
    public abstract virtual long get_IncomingUnknownProtocolPackets();
    public abstract virtual long get_NonUnicastPacketsReceived();
    public abstract virtual long get_NonUnicastPacketsSent();
    public abstract virtual long get_OutgoingPacketsDiscarded();
    public abstract virtual long get_OutgoingPacketsWithErrors();
    public abstract virtual long get_OutputQueueLength();
    public abstract virtual long get_UnicastPacketsReceived();
    public abstract virtual long get_UnicastPacketsSent();
}
public abstract class System.Net.NetworkInformation.IPv6InterfaceProperties : object {
    public int Index { get; }
    public int Mtu { get; }
    public abstract virtual int get_Index();
    public abstract virtual int get_Mtu();
    public virtual long GetScopeId(ScopeLevel scopeLevel);
}
public abstract class System.Net.NetworkInformation.MulticastIPAddressInformation : IPAddressInformation {
    public long AddressPreferredLifetime { get; }
    public long AddressValidLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public abstract virtual long get_AddressPreferredLifetime();
    public abstract virtual long get_AddressValidLifetime();
    public abstract virtual long get_DhcpLeaseLifetime();
    public abstract virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public abstract virtual PrefixOrigin get_PrefixOrigin();
    public abstract virtual SuffixOrigin get_SuffixOrigin();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.MulticastIPAddressInformationCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public MulticastIPAddressInformation Item { get; }
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual MulticastIPAddressInformation get_Item(int index);
    public virtual void Add(MulticastIPAddressInformation address);
    public virtual void Clear();
    public virtual bool Contains(MulticastIPAddressInformation address);
    public virtual void CopyTo(MulticastIPAddressInformation[] array, int offset);
    public virtual IEnumerator`1<MulticastIPAddressInformation> GetEnumerator();
    public virtual bool Remove(MulticastIPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.Net.NetworkInformation.NetBiosNodeType : Enum {
    public int value__;
    public static NetBiosNodeType Broadcast;
    public static NetBiosNodeType Hybrid;
    public static NetBiosNodeType Mixed;
    public static NetBiosNodeType Peer2Peer;
    public static NetBiosNodeType Unknown;
}
public class System.Net.NetworkInformation.NetworkAddressChangedEventHandler : MulticastDelegate {
    public NetworkAddressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.NetworkAvailabilityChangedEventHandler : MulticastDelegate {
    public NetworkAvailabilityChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NetworkAvailabilityEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NetworkAvailabilityEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.NetworkAvailabilityEventArgs : EventArgs {
    public bool IsAvailable { get; }
    public bool get_IsAvailable();
}
public static class System.Net.NetworkInformation.NetworkChange : object {
    public static void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public static void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public static void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public static void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
}
public class System.Net.NetworkInformation.NetworkInformationException : Win32Exception {
    public int ErrorCode { get; }
    public NetworkInformationException(int errorCode);
    protected NetworkInformationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
public abstract class System.Net.NetworkInformation.NetworkInterface : object {
    public string Description { get; }
    public string Id { get; }
    public static int IPv6LoopbackInterfaceIndex { get; }
    public bool IsReceiveOnly { get; }
    public static int LoopbackInterfaceIndex { get; }
    public string Name { get; }
    public NetworkInterfaceType NetworkInterfaceType { get; }
    public OperationalStatus OperationalStatus { get; }
    public long Speed { get; }
    public bool SupportsMulticast { get; }
    public virtual string get_Description();
    public virtual string get_Id();
    public static int get_IPv6LoopbackInterfaceIndex();
    public virtual bool get_IsReceiveOnly();
    public static int get_LoopbackInterfaceIndex();
    public virtual string get_Name();
    public virtual NetworkInterfaceType get_NetworkInterfaceType();
    public virtual OperationalStatus get_OperationalStatus();
    public virtual long get_Speed();
    public virtual bool get_SupportsMulticast();
    public static NetworkInterface[] GetAllNetworkInterfaces();
    public virtual IPInterfaceProperties GetIPProperties();
    public virtual IPInterfaceStatistics GetIPStatistics();
    public virtual IPv4InterfaceStatistics GetIPv4Statistics();
    public static bool GetIsNetworkAvailable();
    public virtual PhysicalAddress GetPhysicalAddress();
    public virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent);
}
public enum System.Net.NetworkInformation.NetworkInterfaceComponent : Enum {
    public int value__;
    public static NetworkInterfaceComponent IPv4;
    public static NetworkInterfaceComponent IPv6;
}
public enum System.Net.NetworkInformation.NetworkInterfaceType : Enum {
    public int value__;
    public static NetworkInterfaceType AsymmetricDsl;
    public static NetworkInterfaceType Atm;
    public static NetworkInterfaceType BasicIsdn;
    public static NetworkInterfaceType Ethernet;
    public static NetworkInterfaceType Ethernet3Megabit;
    public static NetworkInterfaceType FastEthernetFx;
    public static NetworkInterfaceType FastEthernetT;
    public static NetworkInterfaceType Fddi;
    public static NetworkInterfaceType GenericModem;
    public static NetworkInterfaceType GigabitEthernet;
    public static NetworkInterfaceType HighPerformanceSerialBus;
    public static NetworkInterfaceType IPOverAtm;
    public static NetworkInterfaceType Isdn;
    public static NetworkInterfaceType Loopback;
    public static NetworkInterfaceType MultiRateSymmetricDsl;
    public static NetworkInterfaceType Ppp;
    public static NetworkInterfaceType PrimaryIsdn;
    public static NetworkInterfaceType RateAdaptDsl;
    public static NetworkInterfaceType Slip;
    public static NetworkInterfaceType SymmetricDsl;
    public static NetworkInterfaceType TokenRing;
    public static NetworkInterfaceType Tunnel;
    public static NetworkInterfaceType Unknown;
    public static NetworkInterfaceType VeryHighSpeedDsl;
    public static NetworkInterfaceType Wireless80211;
    public static NetworkInterfaceType Wman;
    public static NetworkInterfaceType Wwanpp;
    public static NetworkInterfaceType Wwanpp2;
}
public enum System.Net.NetworkInformation.OperationalStatus : Enum {
    public int value__;
    public static OperationalStatus Dormant;
    public static OperationalStatus Down;
    public static OperationalStatus LowerLayerDown;
    public static OperationalStatus NotPresent;
    public static OperationalStatus Testing;
    public static OperationalStatus Unknown;
    public static OperationalStatus Up;
}
public class System.Net.NetworkInformation.PhysicalAddress : object {
    public static PhysicalAddress None;
    public PhysicalAddress(Byte[] address);
    public virtual bool Equals(object comparand);
    public Byte[] GetAddressBytes();
    public virtual int GetHashCode();
    public static PhysicalAddress Parse(string address);
    public virtual string ToString();
}
public class System.Net.NetworkInformation.Ping : Component {
    public void add_PingCompleted(PingCompletedEventHandler value);
    public void remove_PingCompleted(PingCompletedEventHandler value);
    protected virtual void Dispose(bool disposing);
    protected void OnPingCompleted(PingCompletedEventArgs e);
    public PingReply Send(IPAddress address);
    public PingReply Send(IPAddress address, int timeout);
    public PingReply Send(IPAddress address, int timeout, Byte[] buffer);
    public PingReply Send(IPAddress address, int timeout, Byte[] buffer, PingOptions options);
    public PingReply Send(string hostNameOrAddress);
    public PingReply Send(string hostNameOrAddress, int timeout);
    public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer);
    public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options);
    public void SendAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options, object userToken);
    public void SendAsync(IPAddress address, int timeout, Byte[] buffer, object userToken);
    public void SendAsync(IPAddress address, int timeout, object userToken);
    public void SendAsync(IPAddress address, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, object userToken);
    public void SendAsync(string hostNameOrAddress, object userToken);
    public void SendAsyncCancel();
    public Task`1<PingReply> SendPingAsync(IPAddress address);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options);
}
public class System.Net.NetworkInformation.PingCompletedEventArgs : AsyncCompletedEventArgs {
    public PingReply Reply { get; }
    public PingReply get_Reply();
}
public class System.Net.NetworkInformation.PingCompletedEventHandler : MulticastDelegate {
    public PingCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PingCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PingCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.PingException : InvalidOperationException {
    protected PingException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public PingException(string message);
    public PingException(string message, Exception innerException);
}
public class System.Net.NetworkInformation.PingOptions : object {
    public bool DontFragment { get; public set; }
    public int Ttl { get; public set; }
    public PingOptions(int ttl, bool dontFragment);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public int get_Ttl();
    public void set_Ttl(int value);
}
public class System.Net.NetworkInformation.PingReply : object {
    public IPAddress Address { get; }
    public Byte[] Buffer { get; }
    public PingOptions Options { get; }
    public long RoundtripTime { get; }
    public IPStatus Status { get; }
    public IPAddress get_Address();
    public Byte[] get_Buffer();
    public PingOptions get_Options();
    public long get_RoundtripTime();
    public IPStatus get_Status();
}
public enum System.Net.NetworkInformation.PrefixOrigin : Enum {
    public int value__;
    public static PrefixOrigin Dhcp;
    public static PrefixOrigin Manual;
    public static PrefixOrigin Other;
    public static PrefixOrigin RouterAdvertisement;
    public static PrefixOrigin WellKnown;
}
public enum System.Net.NetworkInformation.ScopeLevel : Enum {
    public int value__;
    public static ScopeLevel Admin;
    public static ScopeLevel Global;
    public static ScopeLevel Interface;
    public static ScopeLevel Link;
    public static ScopeLevel None;
    public static ScopeLevel Organization;
    public static ScopeLevel Site;
    public static ScopeLevel Subnet;
}
public enum System.Net.NetworkInformation.SuffixOrigin : Enum {
    public int value__;
    public static SuffixOrigin LinkLayerAddress;
    public static SuffixOrigin Manual;
    public static SuffixOrigin OriginDhcp;
    public static SuffixOrigin Other;
    public static SuffixOrigin Random;
    public static SuffixOrigin WellKnown;
}
public abstract class System.Net.NetworkInformation.TcpConnectionInformation : object {
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public TcpState State { get; }
    public abstract virtual IPEndPoint get_LocalEndPoint();
    public abstract virtual IPEndPoint get_RemoteEndPoint();
    public abstract virtual TcpState get_State();
}
public enum System.Net.NetworkInformation.TcpState : Enum {
    public int value__;
    public static TcpState Closed;
    public static TcpState CloseWait;
    public static TcpState Closing;
    public static TcpState DeleteTcb;
    public static TcpState Established;
    public static TcpState FinWait1;
    public static TcpState FinWait2;
    public static TcpState LastAck;
    public static TcpState Listen;
    public static TcpState SynReceived;
    public static TcpState SynSent;
    public static TcpState TimeWait;
    public static TcpState Unknown;
}
public abstract class System.Net.NetworkInformation.TcpStatistics : object {
    public long ConnectionsAccepted { get; }
    public long ConnectionsInitiated { get; }
    public long CumulativeConnections { get; }
    public long CurrentConnections { get; }
    public long ErrorsReceived { get; }
    public long FailedConnectionAttempts { get; }
    public long MaximumConnections { get; }
    public long MaximumTransmissionTimeout { get; }
    public long MinimumTransmissionTimeout { get; }
    public long ResetConnections { get; }
    public long ResetsSent { get; }
    public long SegmentsReceived { get; }
    public long SegmentsResent { get; }
    public long SegmentsSent { get; }
    public abstract virtual long get_ConnectionsAccepted();
    public abstract virtual long get_ConnectionsInitiated();
    public abstract virtual long get_CumulativeConnections();
    public abstract virtual long get_CurrentConnections();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_FailedConnectionAttempts();
    public abstract virtual long get_MaximumConnections();
    public abstract virtual long get_MaximumTransmissionTimeout();
    public abstract virtual long get_MinimumTransmissionTimeout();
    public abstract virtual long get_ResetConnections();
    public abstract virtual long get_ResetsSent();
    public abstract virtual long get_SegmentsReceived();
    public abstract virtual long get_SegmentsResent();
    public abstract virtual long get_SegmentsSent();
}
public abstract class System.Net.NetworkInformation.UdpStatistics : object {
    public long DatagramsReceived { get; }
    public long DatagramsSent { get; }
    public long IncomingDatagramsDiscarded { get; }
    public long IncomingDatagramsWithErrors { get; }
    public int UdpListeners { get; }
    public abstract virtual long get_DatagramsReceived();
    public abstract virtual long get_DatagramsSent();
    public abstract virtual long get_IncomingDatagramsDiscarded();
    public abstract virtual long get_IncomingDatagramsWithErrors();
    public abstract virtual int get_UdpListeners();
}
public abstract class System.Net.NetworkInformation.UnicastIPAddressInformation : IPAddressInformation {
    public long AddressPreferredLifetime { get; }
    public long AddressValidLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public IPAddress IPv4Mask { get; }
    public int PrefixLength { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public abstract virtual long get_AddressPreferredLifetime();
    public abstract virtual long get_AddressValidLifetime();
    public abstract virtual long get_DhcpLeaseLifetime();
    public abstract virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public abstract virtual IPAddress get_IPv4Mask();
    public virtual int get_PrefixLength();
    public abstract virtual PrefixOrigin get_PrefixOrigin();
    public abstract virtual SuffixOrigin get_SuffixOrigin();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.UnicastIPAddressInformationCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public UnicastIPAddressInformation Item { get; }
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual UnicastIPAddressInformation get_Item(int index);
    public virtual void Add(UnicastIPAddressInformation address);
    public virtual void Clear();
    public virtual bool Contains(UnicastIPAddressInformation address);
    public virtual void CopyTo(UnicastIPAddressInformation[] array, int offset);
    public virtual IEnumerator`1<UnicastIPAddressInformation> GetEnumerator();
    public virtual bool Remove(UnicastIPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Net.OpenReadCompletedEventArgs : AsyncCompletedEventArgs {
    public Stream Result { get; }
    public Stream get_Result();
}
public class System.Net.OpenReadCompletedEventHandler : MulticastDelegate {
    public OpenReadCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OpenReadCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OpenReadCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.OpenWriteCompletedEventArgs : AsyncCompletedEventArgs {
    public Stream Result { get; }
    public Stream get_Result();
}
public class System.Net.OpenWriteCompletedEventHandler : MulticastDelegate {
    public OpenWriteCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OpenWriteCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OpenWriteCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.ProtocolViolationException : InvalidOperationException {
    protected ProtocolViolationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public ProtocolViolationException(string message);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public abstract class System.Net.Security.AuthenticatedStream : Stream {
    protected Stream InnerStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsServer { get; }
    public bool IsSigned { get; }
    public bool LeaveInnerStreamOpen { get; }
    protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen);
    protected Stream get_InnerStream();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual bool get_IsServer();
    public abstract virtual bool get_IsSigned();
    public bool get_LeaveInnerStreamOpen();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
}
public enum System.Net.Security.AuthenticationLevel : Enum {
    public int value__;
    public static AuthenticationLevel MutualAuthRequested;
    public static AuthenticationLevel MutualAuthRequired;
    public static AuthenticationLevel None;
}
public enum System.Net.Security.EncryptionPolicy : Enum {
    public int value__;
    public static EncryptionPolicy AllowNoEncryption;
    public static EncryptionPolicy NoEncryption;
    public static EncryptionPolicy RequireEncryption;
}
public class System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
    public LocalCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
public class System.Net.Security.NegotiateStream : AuthenticatedStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public bool IsAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsServer { get; }
    public bool IsSigned { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public IIdentity RemoteIdentity { get; }
    public int WriteTimeout { get; public set; }
    public NegotiateStream(Stream innerStream);
    public NegotiateStream(Stream innerStream, bool leaveInnerStreamOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual TokenImpersonationLevel get_ImpersonationLevel();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsServer();
    public virtual bool get_IsSigned();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual IIdentity get_RemoteIdentity();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void AuthenticateAsClient();
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync();
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual void AuthenticateAsServer();
    public virtual void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual void AuthenticateAsServer(ExtendedProtectionPolicy policy);
    public virtual Task AuthenticateAsServerAsync();
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy);
    public virtual IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public enum System.Net.Security.ProtectionLevel : Enum {
    public int value__;
    public static ProtectionLevel EncryptAndSign;
    public static ProtectionLevel None;
    public static ProtectionLevel Sign;
}
public class System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
    public RemoteCertificateValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Net.Security.ServerCertificateSelectionCallback : MulticastDelegate {
    public ServerCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string hostName);
    public virtual IAsyncResult BeginInvoke(object sender, string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class System.Net.Security.SslApplicationProtocol : ValueType {
    private object _dummy;
    public static SslApplicationProtocol Http11;
    public static SslApplicationProtocol Http2;
    public ReadOnlyMemory`1<byte> Protocol { get; }
    public SslApplicationProtocol(Byte[] protocol);
    public SslApplicationProtocol(string protocol);
    public ReadOnlyMemory`1<byte> get_Protocol();
    public sealed virtual bool Equals(SslApplicationProtocol other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SslApplicationProtocol left, SslApplicationProtocol right);
    public static bool op_Inequality(SslApplicationProtocol left, SslApplicationProtocol right);
    public virtual string ToString();
}
public class System.Net.Security.SslClientAuthenticationOptions : object {
    public bool AllowRenegotiation { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public string TargetHost { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    public LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback();
    public void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public string get_TargetHost();
    public void set_TargetHost(string value);
}
[FlagsAttribute]
public enum System.Net.Security.SslPolicyErrors : Enum {
    public int value__;
    public static SslPolicyErrors None;
    public static SslPolicyErrors RemoteCertificateChainErrors;
    public static SslPolicyErrors RemoteCertificateNameMismatch;
    public static SslPolicyErrors RemoteCertificateNotAvailable;
}
public class System.Net.Security.SslServerAuthenticationOptions : object {
    public bool AllowRenegotiation { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public bool ClientCertificateRequired { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public ServerCertificateSelectionCallback ServerCertificateSelectionCallback { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public bool get_ClientCertificateRequired();
    public void set_ClientCertificateRequired(bool value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public X509Certificate get_ServerCertificate();
    public void set_ServerCertificate(X509Certificate value);
    public ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback();
    public void set_ServerCertificateSelectionCallback(ServerCertificateSelectionCallback value);
}
public class System.Net.Security.SslStream : AuthenticatedStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public bool CheckCertRevocationStatus { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public bool IsAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsServer { get; }
    public bool IsSigned { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    public long Length { get; }
    public X509Certificate LocalCertificate { get; }
    public SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public X509Certificate RemoteCertificate { get; }
    public SslProtocols SslProtocol { get; }
    public TransportContext TransportContext { get; }
    public int WriteTimeout { get; public set; }
    public SslStream(Stream innerStream);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual bool get_CheckCertRevocationStatus();
    public virtual CipherAlgorithmType get_CipherAlgorithm();
    public virtual int get_CipherStrength();
    public virtual HashAlgorithmType get_HashAlgorithm();
    public virtual int get_HashStrength();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsServer();
    public virtual bool get_IsSigned();
    public virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public virtual int get_KeyExchangeStrength();
    public virtual long get_Length();
    public virtual X509Certificate get_LocalCertificate();
    public SslApplicationProtocol get_NegotiatedApplicationProtocol();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual X509Certificate get_RemoteCertificate();
    public virtual SslProtocols get_SslProtocol();
    public TransportContext get_TransportContext();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void AuthenticateAsClient(string targetHost);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsClientAsync(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task AuthenticateAsClientAsync(string targetHost);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsServerAsync(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual Task ShutdownAsync();
    public void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum System.Net.SecurityProtocolType : Enum {
    public int value__;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. https://go.microsoft.com/fwlink/?linkid=14202")]
public static SecurityProtocolType Ssl3;
    public static SecurityProtocolType SystemDefault;
    public static SecurityProtocolType Tls;
    public static SecurityProtocolType Tls11;
    public static SecurityProtocolType Tls12;
}
public class System.Net.ServicePoint : object {
    public Uri Address { get; }
    public BindIPEndPoint BindIPEndPointDelegate { get; public set; }
    public X509Certificate Certificate { get; }
    public X509Certificate ClientCertificate { get; }
    public int ConnectionLeaseTimeout { get; public set; }
    public int ConnectionLimit { get; public set; }
    public string ConnectionName { get; }
    public int CurrentConnections { get; }
    public bool Expect100Continue { get; public set; }
    public DateTime IdleSince { get; }
    public int MaxIdleTime { get; public set; }
    public Version ProtocolVersion { get; }
    public int ReceiveBufferSize { get; public set; }
    public bool SupportsPipelining { get; }
    public bool UseNagleAlgorithm { get; public set; }
    public Uri get_Address();
    public BindIPEndPoint get_BindIPEndPointDelegate();
    public void set_BindIPEndPointDelegate(BindIPEndPoint value);
    public X509Certificate get_Certificate();
    public X509Certificate get_ClientCertificate();
    public int get_ConnectionLeaseTimeout();
    public void set_ConnectionLeaseTimeout(int value);
    public int get_ConnectionLimit();
    public void set_ConnectionLimit(int value);
    public string get_ConnectionName();
    public int get_CurrentConnections();
    public bool get_Expect100Continue();
    public void set_Expect100Continue(bool value);
    public DateTime get_IdleSince();
    public int get_MaxIdleTime();
    public void set_MaxIdleTime(int value);
    public virtual Version get_ProtocolVersion();
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public bool get_SupportsPipelining();
    public bool get_UseNagleAlgorithm();
    public void set_UseNagleAlgorithm(bool value);
    public bool CloseConnectionGroup(string connectionGroupName);
    public void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);
}
public class System.Net.ServicePointManager : object {
    public static int DefaultNonPersistentConnectionLimit;
    public static int DefaultPersistentConnectionLimit;
    public static bool CheckCertificateRevocationList { get; public set; }
    public static int DefaultConnectionLimit { get; public set; }
    public static int DnsRefreshTimeout { get; public set; }
    public static bool EnableDnsRoundRobin { get; public set; }
    public static EncryptionPolicy EncryptionPolicy { get; }
    public static bool Expect100Continue { get; public set; }
    public static int MaxServicePointIdleTime { get; public set; }
    public static int MaxServicePoints { get; public set; }
    public static bool ReusePort { get; public set; }
    public static SecurityProtocolType SecurityProtocol { get; public set; }
    public static RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    public static bool UseNagleAlgorithm { get; public set; }
    public static bool get_CheckCertificateRevocationList();
    public static void set_CheckCertificateRevocationList(bool value);
    public static int get_DefaultConnectionLimit();
    public static void set_DefaultConnectionLimit(int value);
    public static int get_DnsRefreshTimeout();
    public static void set_DnsRefreshTimeout(int value);
    public static bool get_EnableDnsRoundRobin();
    public static void set_EnableDnsRoundRobin(bool value);
    public static EncryptionPolicy get_EncryptionPolicy();
    public static bool get_Expect100Continue();
    public static void set_Expect100Continue(bool value);
    public static int get_MaxServicePointIdleTime();
    public static void set_MaxServicePointIdleTime(int value);
    public static int get_MaxServicePoints();
    public static void set_MaxServicePoints(int value);
    public static bool get_ReusePort();
    public static void set_ReusePort(bool value);
    public static SecurityProtocolType get_SecurityProtocol();
    public static void set_SecurityProtocol(SecurityProtocolType value);
    public static RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public static void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public static bool get_UseNagleAlgorithm();
    public static void set_UseNagleAlgorithm(bool value);
    public static ServicePoint FindServicePoint(string uriString, IWebProxy proxy);
    public static ServicePoint FindServicePoint(Uri address);
    public static ServicePoint FindServicePoint(Uri address, IWebProxy proxy);
    public static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);
}
[DefaultMemberAttribute("Item")]
public class System.Net.SocketAddress : object {
    public AddressFamily Family { get; }
    public byte Item { get; public set; }
    public int Size { get; }
    public SocketAddress(AddressFamily family);
    public SocketAddress(AddressFamily family, int size);
    public AddressFamily get_Family();
    public byte get_Item(int offset);
    public void set_Item(int offset, byte value);
    public int get_Size();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum System.Net.Sockets.AddressFamily : Enum {
    public int value__;
    public static AddressFamily AppleTalk;
    public static AddressFamily Atm;
    public static AddressFamily Banyan;
    public static AddressFamily Ccitt;
    public static AddressFamily Chaos;
    public static AddressFamily Cluster;
    public static AddressFamily DataKit;
    public static AddressFamily DataLink;
    public static AddressFamily DecNet;
    public static AddressFamily Ecma;
    public static AddressFamily FireFox;
    public static AddressFamily HyperChannel;
    public static AddressFamily Ieee12844;
    public static AddressFamily ImpLink;
    public static AddressFamily InterNetwork;
    public static AddressFamily InterNetworkV6;
    public static AddressFamily Ipx;
    public static AddressFamily Irda;
    public static AddressFamily Iso;
    public static AddressFamily Lat;
    public static AddressFamily Max;
    public static AddressFamily NetBios;
    public static AddressFamily NetworkDesigners;
    public static AddressFamily NS;
    public static AddressFamily Osi;
    public static AddressFamily Pup;
    public static AddressFamily Sna;
    public static AddressFamily Unix;
    public static AddressFamily Unknown;
    public static AddressFamily Unspecified;
    public static AddressFamily VoiceView;
}
public enum System.Net.Sockets.IOControlCode : Enum {
    public long value__;
    public static IOControlCode AbsorbRouterAlert;
    public static IOControlCode AddMulticastGroupOnInterface;
    public static IOControlCode AddressListChange;
    public static IOControlCode AddressListQuery;
    public static IOControlCode AddressListSort;
    public static IOControlCode AssociateHandle;
    public static IOControlCode AsyncIO;
    public static IOControlCode BindToInterface;
    public static IOControlCode DataToRead;
    public static IOControlCode DeleteMulticastGroupFromInterface;
    public static IOControlCode EnableCircularQueuing;
    public static IOControlCode Flush;
    public static IOControlCode GetBroadcastAddress;
    public static IOControlCode GetExtensionFunctionPointer;
    public static IOControlCode GetGroupQos;
    public static IOControlCode GetQos;
    public static IOControlCode KeepAliveValues;
    public static IOControlCode LimitBroadcasts;
    public static IOControlCode MulticastInterface;
    public static IOControlCode MulticastScope;
    public static IOControlCode MultipointLoopback;
    public static IOControlCode NamespaceChange;
    public static IOControlCode NonBlockingIO;
    public static IOControlCode OobDataRead;
    public static IOControlCode QueryTargetPnpHandle;
    public static IOControlCode ReceiveAll;
    public static IOControlCode ReceiveAllIgmpMulticast;
    public static IOControlCode ReceiveAllMulticast;
    public static IOControlCode RoutingInterfaceChange;
    public static IOControlCode RoutingInterfaceQuery;
    public static IOControlCode SetGroupQos;
    public static IOControlCode SetQos;
    public static IOControlCode TranslateHandle;
    public static IOControlCode UnicastInterface;
}
public class System.Net.Sockets.IPPacketInformation : ValueType {
    private object _dummy;
    public IPAddress Address { get; }
    public int Interface { get; }
    public IPAddress get_Address();
    public int get_Interface();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public static bool op_Equality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
    public static bool op_Inequality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
}
public enum System.Net.Sockets.IPProtectionLevel : Enum {
    public int value__;
    public static IPProtectionLevel EdgeRestricted;
    public static IPProtectionLevel Restricted;
    public static IPProtectionLevel Unrestricted;
    public static IPProtectionLevel Unspecified;
}
public class System.Net.Sockets.IPv6MulticastOption : object {
    public IPAddress Group { get; public set; }
    public long InterfaceIndex { get; public set; }
    public IPv6MulticastOption(IPAddress group);
    public IPv6MulticastOption(IPAddress group, long ifindex);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public long get_InterfaceIndex();
    public void set_InterfaceIndex(long value);
}
public class System.Net.Sockets.LingerOption : object {
    public bool Enabled { get; public set; }
    public int LingerTime { get; public set; }
    public LingerOption(bool enable, int seconds);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public int get_LingerTime();
    public void set_LingerTime(int value);
}
public class System.Net.Sockets.MulticastOption : object {
    public IPAddress Group { get; public set; }
    public int InterfaceIndex { get; public set; }
    public IPAddress LocalAddress { get; public set; }
    public MulticastOption(IPAddress group);
    public MulticastOption(IPAddress group, int interfaceIndex);
    public MulticastOption(IPAddress group, IPAddress mcint);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public int get_InterfaceIndex();
    public void set_InterfaceIndex(int value);
    public IPAddress get_LocalAddress();
    public void set_LocalAddress(IPAddress value);
}
public class System.Net.Sockets.NetworkStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public bool DataAvailable { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected bool Readable { get; protected set; }
    public int ReadTimeout { get; public set; }
    protected Socket Socket { get; }
    protected bool Writeable { get; protected set; }
    public int WriteTimeout { get; public set; }
    public NetworkStream(Socket socket);
    public NetworkStream(Socket socket, bool ownsSocket);
    public NetworkStream(Socket socket, FileAccess access);
    public NetworkStream(Socket socket, FileAccess access, bool ownsSocket);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual bool get_DataAvailable();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected bool get_Readable();
    protected void set_Readable(bool value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    protected Socket get_Socket();
    protected bool get_Writeable();
    protected void set_Writeable(bool value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public void Close(int timeout);
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual override void Finalize();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public enum System.Net.Sockets.ProtocolFamily : Enum {
    public int value__;
    public static ProtocolFamily AppleTalk;
    public static ProtocolFamily Atm;
    public static ProtocolFamily Banyan;
    public static ProtocolFamily Ccitt;
    public static ProtocolFamily Chaos;
    public static ProtocolFamily Cluster;
    public static ProtocolFamily DataKit;
    public static ProtocolFamily DataLink;
    public static ProtocolFamily DecNet;
    public static ProtocolFamily Ecma;
    public static ProtocolFamily FireFox;
    public static ProtocolFamily HyperChannel;
    public static ProtocolFamily Ieee12844;
    public static ProtocolFamily ImpLink;
    public static ProtocolFamily InterNetwork;
    public static ProtocolFamily InterNetworkV6;
    public static ProtocolFamily Ipx;
    public static ProtocolFamily Irda;
    public static ProtocolFamily Iso;
    public static ProtocolFamily Lat;
    public static ProtocolFamily Max;
    public static ProtocolFamily NetBios;
    public static ProtocolFamily NetworkDesigners;
    public static ProtocolFamily NS;
    public static ProtocolFamily Osi;
    public static ProtocolFamily Pup;
    public static ProtocolFamily Sna;
    public static ProtocolFamily Unix;
    public static ProtocolFamily Unknown;
    public static ProtocolFamily Unspecified;
    public static ProtocolFamily VoiceView;
}
public enum System.Net.Sockets.ProtocolType : Enum {
    public int value__;
    public static ProtocolType Ggp;
    public static ProtocolType Icmp;
    public static ProtocolType IcmpV6;
    public static ProtocolType Idp;
    public static ProtocolType Igmp;
    public static ProtocolType IP;
    public static ProtocolType IPSecAuthenticationHeader;
    public static ProtocolType IPSecEncapsulatingSecurityPayload;
    public static ProtocolType IPv4;
    public static ProtocolType IPv6;
    public static ProtocolType IPv6DestinationOptions;
    public static ProtocolType IPv6FragmentHeader;
    public static ProtocolType IPv6HopByHopOptions;
    public static ProtocolType IPv6NoNextHeader;
    public static ProtocolType IPv6RoutingHeader;
    public static ProtocolType Ipx;
    public static ProtocolType ND;
    public static ProtocolType Pup;
    public static ProtocolType Raw;
    public static ProtocolType Spx;
    public static ProtocolType SpxII;
    public static ProtocolType Tcp;
    public static ProtocolType Udp;
    public static ProtocolType Unknown;
    public static ProtocolType Unspecified;
}
public enum System.Net.Sockets.SelectMode : Enum {
    public int value__;
    public static SelectMode SelectError;
    public static SelectMode SelectRead;
    public static SelectMode SelectWrite;
}
public class System.Net.Sockets.SendPacketsElement : object {
    public Byte[] Buffer { get; }
    public int Count { get; }
    public bool EndOfPacket { get; }
    public string FilePath { get; }
    public int Offset { get; }
    public SendPacketsElement(Byte[] buffer);
    public SendPacketsElement(Byte[] buffer, int offset, int count);
    public SendPacketsElement(Byte[] buffer, int offset, int count, bool endOfPacket);
    public SendPacketsElement(string filepath);
    public SendPacketsElement(string filepath, int offset, int count);
    public SendPacketsElement(string filepath, int offset, int count, bool endOfPacket);
    public Byte[] get_Buffer();
    public int get_Count();
    public bool get_EndOfPacket();
    public string get_FilePath();
    public int get_Offset();
}
public class System.Net.Sockets.Socket : object {
    public AddressFamily AddressFamily { get; }
    public int Available { get; }
    public bool Blocking { get; public set; }
    public bool Connected { get; }
    public bool DontFragment { get; public set; }
    public bool DualMode { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool ExclusiveAddressUse { get; public set; }
    public IntPtr Handle { get; }
    public bool IsBound { get; }
    public LingerOption LingerState { get; public set; }
    public EndPoint LocalEndPoint { get; }
    public bool MulticastLoopback { get; public set; }
    public bool NoDelay { get; public set; }
    public static bool OSSupportsIPv4 { get; }
    public static bool OSSupportsIPv6 { get; }
    public ProtocolType ProtocolType { get; }
    public int ReceiveBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public EndPoint RemoteEndPoint { get; }
    public int SendBufferSize { get; public set; }
    public int SendTimeout { get; public set; }
    public SocketType SocketType { get; }
    [ObsoleteAttribute("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static bool SupportsIPv4 { get; }
    [ObsoleteAttribute("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static bool SupportsIPv6 { get; }
    public short Ttl { get; public set; }
    public bool UseOnlyOverlappedIO { get; public set; }
    public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public Socket(SocketInformation socketInformation);
    public Socket(SocketType socketType, ProtocolType protocolType);
    public AddressFamily get_AddressFamily();
    public int get_Available();
    public bool get_Blocking();
    public void set_Blocking(bool value);
    public bool get_Connected();
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_DualMode();
    public void set_DualMode(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public IntPtr get_Handle();
    public bool get_IsBound();
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public EndPoint get_LocalEndPoint();
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    public static bool get_OSSupportsIPv4();
    public static bool get_OSSupportsIPv6();
    public ProtocolType get_ProtocolType();
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public EndPoint get_RemoteEndPoint();
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public SocketType get_SocketType();
    public static bool get_SupportsIPv4();
    public static bool get_SupportsIPv6();
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_UseOnlyOverlappedIO();
    public void set_UseOnlyOverlappedIO(bool value);
    public Socket Accept();
    public bool AcceptAsync(SocketAsyncEventArgs e);
    public IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state);
    public IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);
    public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state);
    public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, object state);
    public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    public IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public IAsyncResult BeginSendFile(string fileName, AsyncCallback callback, object state);
    public IAsyncResult BeginSendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags, AsyncCallback callback, object state);
    public IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, object state);
    public void Bind(EndPoint localEP);
    public static void CancelConnectAsync(SocketAsyncEventArgs e);
    public void Close();
    public void Close(int timeout);
    public void Connect(EndPoint remoteEP);
    public void Connect(IPAddress address, int port);
    public void Connect(IPAddress[] addresses, int port);
    public void Connect(string host, int port);
    public bool ConnectAsync(SocketAsyncEventArgs e);
    public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e);
    public void Disconnect(bool reuseSocket);
    public bool DisconnectAsync(SocketAsyncEventArgs e);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public SocketInformation DuplicateAndClose(int targetProcessId);
    public Socket EndAccept(Byte[]& buffer, IAsyncResult asyncResult);
    public Socket EndAccept(Byte[]& buffer, Int32& bytesTransferred, IAsyncResult asyncResult);
    public Socket EndAccept(IAsyncResult asyncResult);
    public void EndConnect(IAsyncResult asyncResult);
    public void EndDisconnect(IAsyncResult asyncResult);
    public int EndReceive(IAsyncResult asyncResult);
    public int EndReceive(IAsyncResult asyncResult, SocketError& errorCode);
    public int EndReceiveFrom(IAsyncResult asyncResult, EndPoint& endPoint);
    public int EndReceiveMessageFrom(IAsyncResult asyncResult, SocketFlags& socketFlags, EndPoint& endPoint, IPPacketInformation& ipPacketInformation);
    public int EndSend(IAsyncResult asyncResult);
    public int EndSend(IAsyncResult asyncResult, SocketError& errorCode);
    public void EndSendFile(IAsyncResult asyncResult);
    public int EndSendTo(IAsyncResult asyncResult);
    protected virtual override void Finalize();
    public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName);
    public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);
    public int IOControl(int ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    public void Listen(int backlog);
    public bool Poll(int microSeconds, SelectMode mode);
    public int Receive(Byte[] buffer);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    public int Receive(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, SocketFlags socketFlags);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int Receive(Span`1<byte> buffer);
    public int Receive(Span`1<byte> buffer, SocketFlags socketFlags);
    public int Receive(Span`1<byte> buffer, SocketFlags socketFlags, SocketError& errorCode);
    public bool ReceiveAsync(SocketAsyncEventArgs e);
    public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, SocketFlags socketFlags, EndPoint& remoteEP);
    public bool ReceiveFromAsync(SocketAsyncEventArgs e);
    public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation);
    public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e);
    public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds);
    public int Send(Byte[] buffer);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    public int Send(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, SocketFlags socketFlags);
    public int Send(IList`1<ArraySegment`1<byte>> buffers);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int Send(ReadOnlySpan`1<byte> buffer);
    public int Send(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags);
    public int Send(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags, SocketError& errorCode);
    public bool SendAsync(SocketAsyncEventArgs e);
    public void SendFile(string fileName);
    public void SendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags);
    public bool SendPacketsAsync(SocketAsyncEventArgs e);
    public int SendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);
    public bool SendToAsync(SocketAsyncEventArgs e);
    public void SetIPProtectionLevel(IPProtectionLevel level);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue);
    public void Shutdown(SocketShutdown how);
}
public class System.Net.Sockets.SocketAsyncEventArgs : EventArgs {
    public Socket AcceptSocket { get; public set; }
    public Byte[] Buffer { get; }
    public IList`1<ArraySegment`1<byte>> BufferList { get; public set; }
    public int BytesTransferred { get; }
    public Exception ConnectByNameError { get; }
    public Socket ConnectSocket { get; }
    public int Count { get; }
    public bool DisconnectReuseSocket { get; public set; }
    public SocketAsyncOperation LastOperation { get; }
    public Memory`1<byte> MemoryBuffer { get; }
    public int Offset { get; }
    public IPPacketInformation ReceiveMessageFromPacketInfo { get; }
    public EndPoint RemoteEndPoint { get; public set; }
    public SendPacketsElement[] SendPacketsElements { get; public set; }
    public TransmitFileOptions SendPacketsFlags { get; public set; }
    public int SendPacketsSendSize { get; public set; }
    public SocketError SocketError { get; public set; }
    public SocketFlags SocketFlags { get; public set; }
    public object UserToken { get; public set; }
    public Socket get_AcceptSocket();
    public void set_AcceptSocket(Socket value);
    public Byte[] get_Buffer();
    public IList`1<ArraySegment`1<byte>> get_BufferList();
    public void set_BufferList(IList`1<ArraySegment`1<byte>> value);
    public int get_BytesTransferred();
    public Exception get_ConnectByNameError();
    public Socket get_ConnectSocket();
    public int get_Count();
    public bool get_DisconnectReuseSocket();
    public void set_DisconnectReuseSocket(bool value);
    public SocketAsyncOperation get_LastOperation();
    public Memory`1<byte> get_MemoryBuffer();
    public int get_Offset();
    public IPPacketInformation get_ReceiveMessageFromPacketInfo();
    public EndPoint get_RemoteEndPoint();
    public void set_RemoteEndPoint(EndPoint value);
    public SendPacketsElement[] get_SendPacketsElements();
    public void set_SendPacketsElements(SendPacketsElement[] value);
    public TransmitFileOptions get_SendPacketsFlags();
    public void set_SendPacketsFlags(TransmitFileOptions value);
    public int get_SendPacketsSendSize();
    public void set_SendPacketsSendSize(int value);
    public SocketError get_SocketError();
    public void set_SocketError(SocketError value);
    public SocketFlags get_SocketFlags();
    public void set_SocketFlags(SocketFlags value);
    public object get_UserToken();
    public void set_UserToken(object value);
    public void add_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    public void remove_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void OnCompleted(SocketAsyncEventArgs e);
    public void SetBuffer(Byte[] buffer, int offset, int count);
    public void SetBuffer(int offset, int count);
    public void SetBuffer(Memory`1<byte> buffer);
}
public enum System.Net.Sockets.SocketAsyncOperation : Enum {
    public int value__;
    public static SocketAsyncOperation Accept;
    public static SocketAsyncOperation Connect;
    public static SocketAsyncOperation Disconnect;
    public static SocketAsyncOperation None;
    public static SocketAsyncOperation Receive;
    public static SocketAsyncOperation ReceiveFrom;
    public static SocketAsyncOperation ReceiveMessageFrom;
    public static SocketAsyncOperation Send;
    public static SocketAsyncOperation SendPackets;
    public static SocketAsyncOperation SendTo;
}
public enum System.Net.Sockets.SocketError : Enum {
    public int value__;
    public static SocketError AccessDenied;
    public static SocketError AddressAlreadyInUse;
    public static SocketError AddressFamilyNotSupported;
    public static SocketError AddressNotAvailable;
    public static SocketError AlreadyInProgress;
    public static SocketError ConnectionAborted;
    public static SocketError ConnectionRefused;
    public static SocketError ConnectionReset;
    public static SocketError DestinationAddressRequired;
    public static SocketError Disconnecting;
    public static SocketError Fault;
    public static SocketError HostDown;
    public static SocketError HostNotFound;
    public static SocketError HostUnreachable;
    public static SocketError InProgress;
    public static SocketError Interrupted;
    public static SocketError InvalidArgument;
    public static SocketError IOPending;
    public static SocketError IsConnected;
    public static SocketError MessageSize;
    public static SocketError NetworkDown;
    public static SocketError NetworkReset;
    public static SocketError NetworkUnreachable;
    public static SocketError NoBufferSpaceAvailable;
    public static SocketError NoData;
    public static SocketError NoRecovery;
    public static SocketError NotConnected;
    public static SocketError NotInitialized;
    public static SocketError NotSocket;
    public static SocketError OperationAborted;
    public static SocketError OperationNotSupported;
    public static SocketError ProcessLimit;
    public static SocketError ProtocolFamilyNotSupported;
    public static SocketError ProtocolNotSupported;
    public static SocketError ProtocolOption;
    public static SocketError ProtocolType;
    public static SocketError Shutdown;
    public static SocketError SocketError;
    public static SocketError SocketNotSupported;
    public static SocketError Success;
    public static SocketError SystemNotReady;
    public static SocketError TimedOut;
    public static SocketError TooManyOpenSockets;
    public static SocketError TryAgain;
    public static SocketError TypeNotFound;
    public static SocketError VersionNotSupported;
    public static SocketError WouldBlock;
}
public class System.Net.Sockets.SocketException : Win32Exception {
    public int ErrorCode { get; }
    public string Message { get; }
    public SocketError SocketErrorCode { get; }
    public SocketException(int errorCode);
    protected SocketException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
    public virtual string get_Message();
    public SocketError get_SocketErrorCode();
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketFlags : Enum {
    public int value__;
    public static SocketFlags Broadcast;
    public static SocketFlags ControlDataTruncated;
    public static SocketFlags DontRoute;
    public static SocketFlags Multicast;
    public static SocketFlags None;
    public static SocketFlags OutOfBand;
    public static SocketFlags Partial;
    public static SocketFlags Peek;
    public static SocketFlags Truncated;
}
public class System.Net.Sockets.SocketInformation : ValueType {
    private object _dummy;
    public SocketInformationOptions Options { get; public set; }
    public Byte[] ProtocolInformation { get; public set; }
    public SocketInformationOptions get_Options();
    public void set_Options(SocketInformationOptions value);
    public Byte[] get_ProtocolInformation();
    public void set_ProtocolInformation(Byte[] value);
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketInformationOptions : Enum {
    public int value__;
    public static SocketInformationOptions Connected;
    public static SocketInformationOptions Listening;
    public static SocketInformationOptions NonBlocking;
    public static SocketInformationOptions UseOnlyOverlappedIO;
}
public enum System.Net.Sockets.SocketOptionLevel : Enum {
    public int value__;
    public static SocketOptionLevel IP;
    public static SocketOptionLevel IPv6;
    public static SocketOptionLevel Socket;
    public static SocketOptionLevel Tcp;
    public static SocketOptionLevel Udp;
}
public enum System.Net.Sockets.SocketOptionName : Enum {
    public int value__;
    public static SocketOptionName AcceptConnection;
    public static SocketOptionName AddMembership;
    public static SocketOptionName AddSourceMembership;
    public static SocketOptionName BlockSource;
    public static SocketOptionName Broadcast;
    public static SocketOptionName BsdUrgent;
    public static SocketOptionName ChecksumCoverage;
    public static SocketOptionName Debug;
    public static SocketOptionName DontFragment;
    public static SocketOptionName DontLinger;
    public static SocketOptionName DontRoute;
    public static SocketOptionName DropMembership;
    public static SocketOptionName DropSourceMembership;
    public static SocketOptionName Error;
    public static SocketOptionName ExclusiveAddressUse;
    public static SocketOptionName Expedited;
    public static SocketOptionName HeaderIncluded;
    public static SocketOptionName HopLimit;
    public static SocketOptionName IPOptions;
    public static SocketOptionName IPProtectionLevel;
    public static SocketOptionName IpTimeToLive;
    public static SocketOptionName IPv6Only;
    public static SocketOptionName KeepAlive;
    public static SocketOptionName Linger;
    public static SocketOptionName MaxConnections;
    public static SocketOptionName MulticastInterface;
    public static SocketOptionName MulticastLoopback;
    public static SocketOptionName MulticastTimeToLive;
    public static SocketOptionName NoChecksum;
    public static SocketOptionName NoDelay;
    public static SocketOptionName OutOfBandInline;
    public static SocketOptionName PacketInformation;
    public static SocketOptionName ReceiveBuffer;
    public static SocketOptionName ReceiveLowWater;
    public static SocketOptionName ReceiveTimeout;
    public static SocketOptionName ReuseAddress;
    public static SocketOptionName ReuseUnicastPort;
    public static SocketOptionName SendBuffer;
    public static SocketOptionName SendLowWater;
    public static SocketOptionName SendTimeout;
    public static SocketOptionName Type;
    public static SocketOptionName TypeOfService;
    public static SocketOptionName UnblockSource;
    public static SocketOptionName UpdateAcceptContext;
    public static SocketOptionName UpdateConnectContext;
    public static SocketOptionName UseLoopback;
}
public class System.Net.Sockets.SocketReceiveFromResult : ValueType {
    public int ReceivedBytes;
    public EndPoint RemoteEndPoint;
}
public class System.Net.Sockets.SocketReceiveMessageFromResult : ValueType {
    public IPPacketInformation PacketInformation;
    public int ReceivedBytes;
    public EndPoint RemoteEndPoint;
    public SocketFlags SocketFlags;
}
public enum System.Net.Sockets.SocketShutdown : Enum {
    public int value__;
    public static SocketShutdown Both;
    public static SocketShutdown Receive;
    public static SocketShutdown Send;
}
[ExtensionAttribute]
public static class System.Net.Sockets.SocketTaskExtensions : object {
    [ExtensionAttribute]
public static Task`1<Socket> AcceptAsync(Socket socket);
    [ExtensionAttribute]
public static Task`1<Socket> AcceptAsync(Socket socket, Socket acceptSocket);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, EndPoint remoteEP);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, IPAddress address, int port);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, IPAddress[] addresses, int port);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, string host, int port);
    [ExtensionAttribute]
public static Task`1<int> ReceiveAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> ReceiveAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
public static ValueTask`1<int> ReceiveAsync(Socket socket, Memory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SocketReceiveFromResult> ReceiveFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task`1<int> SendAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> SendAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
public static ValueTask`1<int> SendAsync(Socket socket, ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> SendToAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
}
public enum System.Net.Sockets.SocketType : Enum {
    public int value__;
    public static SocketType Dgram;
    public static SocketType Raw;
    public static SocketType Rdm;
    public static SocketType Seqpacket;
    public static SocketType Stream;
    public static SocketType Unknown;
}
public class System.Net.Sockets.TcpClient : object {
    protected bool Active { get; protected set; }
    public int Available { get; }
    public Socket Client { get; public set; }
    public bool Connected { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public LingerOption LingerState { get; public set; }
    public bool NoDelay { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendBufferSize { get; public set; }
    public int SendTimeout { get; public set; }
    public TcpClient(IPEndPoint localEP);
    public TcpClient(AddressFamily family);
    public TcpClient(string hostname, int port);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public Socket get_Client();
    public void set_Client(Socket value);
    public bool get_Connected();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    public void Close();
    public void Connect(IPAddress address, int port);
    public void Connect(IPAddress[] ipAddresses, int port);
    public void Connect(IPEndPoint remoteEP);
    public void Connect(string hostname, int port);
    public Task ConnectAsync(IPAddress address, int port);
    public Task ConnectAsync(IPAddress[] addresses, int port);
    public Task ConnectAsync(string host, int port);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void EndConnect(IAsyncResult asyncResult);
    protected virtual override void Finalize();
    public NetworkStream GetStream();
}
public class System.Net.Sockets.TcpListener : object {
    protected bool Active { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public EndPoint LocalEndpoint { get; }
    public Socket Server { get; }
    [ObsoleteAttribute("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public TcpListener(int port);
    public TcpListener(IPAddress localaddr, int port);
    public TcpListener(IPEndPoint localEP);
    protected bool get_Active();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public EndPoint get_LocalEndpoint();
    public Socket get_Server();
    public Socket AcceptSocket();
    public Task`1<Socket> AcceptSocketAsync();
    public TcpClient AcceptTcpClient();
    public Task`1<TcpClient> AcceptTcpClientAsync();
    public void AllowNatTraversal(bool allowed);
    public IAsyncResult BeginAcceptSocket(AsyncCallback callback, object state);
    public IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, object state);
    public static TcpListener Create(int port);
    public Socket EndAcceptSocket(IAsyncResult asyncResult);
    public TcpClient EndAcceptTcpClient(IAsyncResult asyncResult);
    public bool Pending();
    public void Start();
    public void Start(int backlog);
    public void Stop();
}
[FlagsAttribute]
public enum System.Net.Sockets.TransmitFileOptions : Enum {
    public int value__;
    public static TransmitFileOptions Disconnect;
    public static TransmitFileOptions ReuseSocket;
    public static TransmitFileOptions UseDefaultWorkerThread;
    public static TransmitFileOptions UseKernelApc;
    public static TransmitFileOptions UseSystemThread;
    public static TransmitFileOptions WriteBehind;
}
public class System.Net.Sockets.UdpClient : object {
    protected bool Active { get; protected set; }
    public int Available { get; }
    public Socket Client { get; public set; }
    public bool DontFragment { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool ExclusiveAddressUse { get; public set; }
    public bool MulticastLoopback { get; public set; }
    public short Ttl { get; public set; }
    public UdpClient(int port);
    public UdpClient(int port, AddressFamily family);
    public UdpClient(IPEndPoint localEP);
    public UdpClient(AddressFamily family);
    public UdpClient(string hostname, int port);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public Socket get_Client();
    public void set_Client(Socket value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public short get_Ttl();
    public void set_Ttl(short value);
    public void AllowNatTraversal(bool allowed);
    public IAsyncResult BeginReceive(AsyncCallback requestCallback, object state);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);
    public void Close();
    public void Connect(IPAddress addr, int port);
    public void Connect(IPEndPoint endPoint);
    public void Connect(string hostname, int port);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void DropMulticastGroup(IPAddress multicastAddr);
    public void DropMulticastGroup(IPAddress multicastAddr, int ifindex);
    public Byte[] EndReceive(IAsyncResult asyncResult, IPEndPoint& remoteEP);
    public int EndSend(IAsyncResult asyncResult);
    public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive);
    public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress);
    public Byte[] Receive(IPEndPoint& remoteEP);
    public Task`1<UdpReceiveResult> ReceiveAsync();
    public int Send(Byte[] dgram, int bytes);
    public int Send(Byte[] dgram, int bytes, IPEndPoint endPoint);
    public int Send(Byte[] dgram, int bytes, string hostname, int port);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, IPEndPoint endPoint);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, string hostname, int port);
}
public class System.Net.Sockets.UdpReceiveResult : ValueType {
    private object _dummy;
    public Byte[] Buffer { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public UdpReceiveResult(Byte[] buffer, IPEndPoint remoteEndPoint);
    public Byte[] get_Buffer();
    public IPEndPoint get_RemoteEndPoint();
    public sealed virtual bool Equals(UdpReceiveResult other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(UdpReceiveResult left, UdpReceiveResult right);
    public static bool op_Inequality(UdpReceiveResult left, UdpReceiveResult right);
}
public class System.Net.Sockets.UnixDomainSocketEndPoint : EndPoint {
    public UnixDomainSocketEndPoint(string path);
}
public abstract class System.Net.TransportContext : object {
    public abstract virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
public class System.Net.UploadDataCompletedEventArgs : AsyncCompletedEventArgs {
    public Byte[] Result { get; }
    public Byte[] get_Result();
}
public class System.Net.UploadDataCompletedEventHandler : MulticastDelegate {
    public UploadDataCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadDataCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadDataCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadFileCompletedEventArgs : AsyncCompletedEventArgs {
    public Byte[] Result { get; }
    public Byte[] get_Result();
}
public class System.Net.UploadFileCompletedEventHandler : MulticastDelegate {
    public UploadFileCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadFileCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadFileCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadProgressChangedEventArgs : ProgressChangedEventArgs {
    public long BytesReceived { get; }
    public long BytesSent { get; }
    public long TotalBytesToReceive { get; }
    public long TotalBytesToSend { get; }
    public long get_BytesReceived();
    public long get_BytesSent();
    public long get_TotalBytesToReceive();
    public long get_TotalBytesToSend();
}
public class System.Net.UploadProgressChangedEventHandler : MulticastDelegate {
    public UploadProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadStringCompletedEventArgs : AsyncCompletedEventArgs {
    public string Result { get; }
    public string get_Result();
}
public class System.Net.UploadStringCompletedEventHandler : MulticastDelegate {
    public UploadStringCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadStringCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadStringCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadValuesCompletedEventArgs : AsyncCompletedEventArgs {
    public Byte[] Result { get; }
    public Byte[] get_Result();
}
public class System.Net.UploadValuesCompletedEventHandler : MulticastDelegate {
    public UploadValuesCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadValuesCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadValuesCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.WebClient : Component {
    public string BaseAddress { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public ICredentials Credentials { get; public set; }
    public Encoding Encoding { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public bool IsBusy { get; }
    public IWebProxy Proxy { get; public set; }
    public NameValueCollection QueryString { get; public set; }
    public WebHeaderCollection ResponseHeaders { get; }
    public bool UseDefaultCredentials { get; public set; }
    public string get_BaseAddress();
    public void set_BaseAddress(string value);
    public RequestCachePolicy get_CachePolicy();
    public void set_CachePolicy(RequestCachePolicy value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    public bool get_IsBusy();
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public NameValueCollection get_QueryString();
    public void set_QueryString(NameValueCollection value);
    public WebHeaderCollection get_ResponseHeaders();
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public void add_DownloadDataCompleted(DownloadDataCompletedEventHandler value);
    public void remove_DownloadDataCompleted(DownloadDataCompletedEventHandler value);
    public void add_DownloadFileCompleted(AsyncCompletedEventHandler value);
    public void remove_DownloadFileCompleted(AsyncCompletedEventHandler value);
    public void add_DownloadProgressChanged(DownloadProgressChangedEventHandler value);
    public void remove_DownloadProgressChanged(DownloadProgressChangedEventHandler value);
    public void add_DownloadStringCompleted(DownloadStringCompletedEventHandler value);
    public void remove_DownloadStringCompleted(DownloadStringCompletedEventHandler value);
    public void add_OpenReadCompleted(OpenReadCompletedEventHandler value);
    public void remove_OpenReadCompleted(OpenReadCompletedEventHandler value);
    public void add_OpenWriteCompleted(OpenWriteCompletedEventHandler value);
    public void remove_OpenWriteCompleted(OpenWriteCompletedEventHandler value);
    public void add_UploadDataCompleted(UploadDataCompletedEventHandler value);
    public void remove_UploadDataCompleted(UploadDataCompletedEventHandler value);
    public void add_UploadFileCompleted(UploadFileCompletedEventHandler value);
    public void remove_UploadFileCompleted(UploadFileCompletedEventHandler value);
    public void add_UploadProgressChanged(UploadProgressChangedEventHandler value);
    public void remove_UploadProgressChanged(UploadProgressChangedEventHandler value);
    public void add_UploadStringCompleted(UploadStringCompletedEventHandler value);
    public void remove_UploadStringCompleted(UploadStringCompletedEventHandler value);
    public void add_UploadValuesCompleted(UploadValuesCompletedEventHandler value);
    public void remove_UploadValuesCompleted(UploadValuesCompletedEventHandler value);
    public void CancelAsync();
    public Byte[] DownloadData(string address);
    public Byte[] DownloadData(Uri address);
    public void DownloadDataAsync(Uri address);
    public void DownloadDataAsync(Uri address, object userToken);
    public Task`1<Byte[]> DownloadDataTaskAsync(string address);
    public Task`1<Byte[]> DownloadDataTaskAsync(Uri address);
    public void DownloadFile(string address, string fileName);
    public void DownloadFile(Uri address, string fileName);
    public void DownloadFileAsync(Uri address, string fileName);
    public void DownloadFileAsync(Uri address, string fileName, object userToken);
    public Task DownloadFileTaskAsync(string address, string fileName);
    public Task DownloadFileTaskAsync(Uri address, string fileName);
    public string DownloadString(string address);
    public string DownloadString(Uri address);
    public void DownloadStringAsync(Uri address);
    public void DownloadStringAsync(Uri address, object userToken);
    public Task`1<string> DownloadStringTaskAsync(string address);
    public Task`1<string> DownloadStringTaskAsync(Uri address);
    protected virtual WebRequest GetWebRequest(Uri address);
    protected virtual WebResponse GetWebResponse(WebRequest request);
    protected virtual WebResponse GetWebResponse(WebRequest request, IAsyncResult result);
    protected virtual void OnDownloadDataCompleted(DownloadDataCompletedEventArgs e);
    protected virtual void OnDownloadFileCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnDownloadProgressChanged(DownloadProgressChangedEventArgs e);
    protected virtual void OnDownloadStringCompleted(DownloadStringCompletedEventArgs e);
    protected virtual void OnOpenReadCompleted(OpenReadCompletedEventArgs e);
    protected virtual void OnOpenWriteCompleted(OpenWriteCompletedEventArgs e);
    protected virtual void OnUploadDataCompleted(UploadDataCompletedEventArgs e);
    protected virtual void OnUploadFileCompleted(UploadFileCompletedEventArgs e);
    protected virtual void OnUploadProgressChanged(UploadProgressChangedEventArgs e);
    protected virtual void OnUploadStringCompleted(UploadStringCompletedEventArgs e);
    protected virtual void OnUploadValuesCompleted(UploadValuesCompletedEventArgs e);
    public Stream OpenRead(string address);
    public Stream OpenRead(Uri address);
    public void OpenReadAsync(Uri address);
    public void OpenReadAsync(Uri address, object userToken);
    public Task`1<Stream> OpenReadTaskAsync(string address);
    public Task`1<Stream> OpenReadTaskAsync(Uri address);
    public Stream OpenWrite(string address);
    public Stream OpenWrite(string address, string method);
    public Stream OpenWrite(Uri address);
    public Stream OpenWrite(Uri address, string method);
    public void OpenWriteAsync(Uri address);
    public void OpenWriteAsync(Uri address, string method);
    public void OpenWriteAsync(Uri address, string method, object userToken);
    public Task`1<Stream> OpenWriteTaskAsync(string address);
    public Task`1<Stream> OpenWriteTaskAsync(string address, string method);
    public Task`1<Stream> OpenWriteTaskAsync(Uri address);
    public Task`1<Stream> OpenWriteTaskAsync(Uri address, string method);
    public Byte[] UploadData(string address, Byte[] data);
    public Byte[] UploadData(string address, string method, Byte[] data);
    public Byte[] UploadData(Uri address, Byte[] data);
    public Byte[] UploadData(Uri address, string method, Byte[] data);
    public void UploadDataAsync(Uri address, Byte[] data);
    public void UploadDataAsync(Uri address, string method, Byte[] data);
    public void UploadDataAsync(Uri address, string method, Byte[] data, object userToken);
    public Task`1<Byte[]> UploadDataTaskAsync(string address, Byte[] data);
    public Task`1<Byte[]> UploadDataTaskAsync(string address, string method, Byte[] data);
    public Task`1<Byte[]> UploadDataTaskAsync(Uri address, Byte[] data);
    public Task`1<Byte[]> UploadDataTaskAsync(Uri address, string method, Byte[] data);
    public Byte[] UploadFile(string address, string fileName);
    public Byte[] UploadFile(string address, string method, string fileName);
    public Byte[] UploadFile(Uri address, string fileName);
    public Byte[] UploadFile(Uri address, string method, string fileName);
    public void UploadFileAsync(Uri address, string fileName);
    public void UploadFileAsync(Uri address, string method, string fileName);
    public void UploadFileAsync(Uri address, string method, string fileName, object userToken);
    public Task`1<Byte[]> UploadFileTaskAsync(string address, string fileName);
    public Task`1<Byte[]> UploadFileTaskAsync(string address, string method, string fileName);
    public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string fileName);
    public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string method, string fileName);
    public string UploadString(string address, string data);
    public string UploadString(string address, string method, string data);
    public string UploadString(Uri address, string data);
    public string UploadString(Uri address, string method, string data);
    public void UploadStringAsync(Uri address, string data);
    public void UploadStringAsync(Uri address, string method, string data);
    public void UploadStringAsync(Uri address, string method, string data, object userToken);
    public Task`1<string> UploadStringTaskAsync(string address, string data);
    public Task`1<string> UploadStringTaskAsync(string address, string method, string data);
    public Task`1<string> UploadStringTaskAsync(Uri address, string data);
    public Task`1<string> UploadStringTaskAsync(Uri address, string method, string data);
    public Byte[] UploadValues(string address, NameValueCollection data);
    public Byte[] UploadValues(string address, string method, NameValueCollection data);
    public Byte[] UploadValues(Uri address, NameValueCollection data);
    public Byte[] UploadValues(Uri address, string method, NameValueCollection data);
    public void UploadValuesAsync(Uri address, NameValueCollection data);
    public void UploadValuesAsync(Uri address, string method, NameValueCollection data);
    public void UploadValuesAsync(Uri address, string method, NameValueCollection data, object userToken);
    public Task`1<Byte[]> UploadValuesTaskAsync(string address, NameValueCollection data);
    public Task`1<Byte[]> UploadValuesTaskAsync(string address, string method, NameValueCollection data);
    public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, NameValueCollection data);
    public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, string method, NameValueCollection data);
}
public class System.Net.WebException : InvalidOperationException {
    public WebResponse Response { get; }
    public WebExceptionStatus Status { get; }
    protected WebException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public WebException(string message);
    public WebException(string message, Exception innerException);
    public WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response);
    public WebException(string message, WebExceptionStatus status);
    public WebResponse get_Response();
    public WebExceptionStatus get_Status();
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.Net.WebExceptionStatus : Enum {
    public int value__;
    public static WebExceptionStatus CacheEntryNotFound;
    public static WebExceptionStatus ConnectFailure;
    public static WebExceptionStatus ConnectionClosed;
    public static WebExceptionStatus KeepAliveFailure;
    public static WebExceptionStatus MessageLengthLimitExceeded;
    public static WebExceptionStatus NameResolutionFailure;
    public static WebExceptionStatus Pending;
    public static WebExceptionStatus PipelineFailure;
    public static WebExceptionStatus ProtocolError;
    public static WebExceptionStatus ProxyNameResolutionFailure;
    public static WebExceptionStatus ReceiveFailure;
    public static WebExceptionStatus RequestCanceled;
    public static WebExceptionStatus RequestProhibitedByCachePolicy;
    public static WebExceptionStatus RequestProhibitedByProxy;
    public static WebExceptionStatus SecureChannelFailure;
    public static WebExceptionStatus SendFailure;
    public static WebExceptionStatus ServerProtocolViolation;
    public static WebExceptionStatus Success;
    public static WebExceptionStatus Timeout;
    public static WebExceptionStatus TrustFailure;
    public static WebExceptionStatus UnknownError;
}
[DefaultMemberAttribute("Item")]
public class System.Net.WebHeaderCollection : NameValueCollection {
    public String[] AllKeys { get; }
    public int Count { get; }
    public string Item { get; public set; }
    public string Item { get; public set; }
    public string Item { get; public set; }
    public KeysCollection Keys { get; }
    protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual String[] get_AllKeys();
    public virtual int get_Count();
    public string get_Item(HttpRequestHeader header);
    public void set_Item(HttpRequestHeader header, string value);
    public string get_Item(HttpResponseHeader header);
    public void set_Item(HttpResponseHeader header, string value);
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public virtual KeysCollection get_Keys();
    public void Add(HttpRequestHeader header, string value);
    public void Add(HttpResponseHeader header, string value);
    public void Add(string header);
    public virtual void Add(string name, string value);
    protected void AddWithoutValidate(string headerName, string headerValue);
    public virtual void Clear();
    public virtual string Get(int index);
    public virtual string Get(string name);
    public virtual IEnumerator GetEnumerator();
    public virtual string GetKey(int index);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual String[] GetValues(int index);
    public virtual String[] GetValues(string header);
    public static bool IsRestricted(string headerName);
    public static bool IsRestricted(string headerName, bool response);
    public virtual void OnDeserialization(object sender);
    public void Remove(HttpRequestHeader header);
    public void Remove(HttpResponseHeader header);
    public virtual void Remove(string name);
    public void Set(HttpRequestHeader header, string value);
    public void Set(HttpResponseHeader header, string value);
    public virtual void Set(string name, string value);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Byte[] ToByteArray();
    public virtual string ToString();
}
public class System.Net.WebProxy : object {
    public Uri Address { get; public set; }
    public ArrayList BypassArrayList { get; }
    public String[] BypassList { get; public set; }
    public bool BypassProxyOnLocal { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    protected WebProxy(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public WebProxy(string Address);
    public WebProxy(string Address, bool BypassOnLocal);
    public WebProxy(string Address, bool BypassOnLocal, String[] BypassList);
    public WebProxy(string Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials);
    public WebProxy(string Host, int Port);
    public WebProxy(Uri Address);
    public WebProxy(Uri Address, bool BypassOnLocal);
    public WebProxy(Uri Address, bool BypassOnLocal, String[] BypassList);
    public WebProxy(Uri Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials);
    public Uri get_Address();
    public void set_Address(Uri value);
    public ArrayList get_BypassArrayList();
    public String[] get_BypassList();
    public void set_BypassList(String[] value);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public sealed virtual ICredentials get_Credentials();
    public sealed virtual void set_Credentials(ICredentials value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    [ObsoleteAttribute("This method has been deprecated. Please use the proxy selected for you by default. https://go.microsoft.com/fwlink/?linkid=14202")]
public static WebProxy GetDefaultProxy();
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri host);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public abstract class System.Net.WebRequest : MarshalByRefObject {
    public AuthenticationLevel AuthenticationLevel { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public static IWebProxy DefaultWebProxy { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public TokenImpersonationLevel ImpersonationLevel { get; public set; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    protected WebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public AuthenticationLevel get_AuthenticationLevel();
    public void set_AuthenticationLevel(AuthenticationLevel value);
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public static IWebProxy get_DefaultWebProxy();
    public static void set_DefaultWebProxy(IWebProxy value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public TokenImpersonationLevel get_ImpersonationLevel();
    public void set_ImpersonationLevel(TokenImpersonationLevel value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual void Abort();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public static WebRequest Create(string requestUriString);
    public static WebRequest Create(Uri requestUri);
    public static WebRequest CreateDefault(Uri requestUri);
    public static HttpWebRequest CreateHttp(string requestUriString);
    public static HttpWebRequest CreateHttp(Uri requestUri);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual Stream GetRequestStream();
    public virtual Task`1<Stream> GetRequestStreamAsync();
    public virtual WebResponse GetResponse();
    public virtual Task`1<WebResponse> GetResponseAsync();
    public static IWebProxy GetSystemWebProxy();
    public static bool RegisterPrefix(string prefix, IWebRequestCreate creator);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public static class System.Net.WebRequestMethods : object {
}
public abstract class System.Net.WebResponse : MarshalByRefObject {
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public WebHeaderCollection Headers { get; }
    public bool IsFromCache { get; }
    public bool IsMutuallyAuthenticated { get; }
    public Uri ResponseUri { get; }
    public bool SupportsHeaders { get; }
    protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_IsFromCache();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual Uri get_ResponseUri();
    public virtual bool get_SupportsHeaders();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual Stream GetResponseStream();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Net.WebSockets.ClientWebSocket : WebSocket {
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public ClientWebSocketOptions Options { get; }
    public WebSocketState State { get; }
    public string SubProtocol { get; }
    public virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public virtual string get_CloseStatusDescription();
    public ClientWebSocketOptions get_Options();
    public virtual WebSocketState get_State();
    public virtual string get_SubProtocol();
    public virtual void Abort();
    public virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public Task ConnectAsync(Uri uri, CancellationToken cancellationToken);
    public virtual void Dispose();
    public virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public virtual ValueTask`1<ValueWebSocketReceiveResult> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public virtual ValueTask SendAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
}
public class System.Net.WebSockets.ClientWebSocketOptions : object {
    public X509CertificateCollection ClientCertificates { get; public set; }
    public CookieContainer Cookies { get; public set; }
    public ICredentials Credentials { get; public set; }
    public TimeSpan KeepAliveInterval { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public CookieContainer get_Cookies();
    public void set_Cookies(CookieContainer value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public TimeSpan get_KeepAliveInterval();
    public void set_KeepAliveInterval(TimeSpan value);
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public void AddSubProtocol(string subProtocol);
    public void SetBuffer(int receiveBufferSize, int sendBufferSize);
    public void SetBuffer(int receiveBufferSize, int sendBufferSize, ArraySegment`1<byte> buffer);
    public void SetRequestHeader(string headerName, string headerValue);
}
public class System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
    public CookieCollection CookieCollection { get; }
    public NameValueCollection Headers { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public string Origin { get; }
    public Uri RequestUri { get; }
    public string SecWebSocketKey { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public IPrincipal User { get; }
    public WebSocket WebSocket { get; }
    public virtual CookieCollection get_CookieCollection();
    public virtual NameValueCollection get_Headers();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual string get_Origin();
    public virtual Uri get_RequestUri();
    public virtual string get_SecWebSocketKey();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual IPrincipal get_User();
    public virtual WebSocket get_WebSocket();
}
[IsReadOnlyAttribute]
public class System.Net.WebSockets.ValueWebSocketReceiveResult : ValueType {
    private int _dummyPrimitive;
    public int Count { get; }
    public bool EndOfMessage { get; }
    public WebSocketMessageType MessageType { get; }
    public ValueWebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage);
    public int get_Count();
    public bool get_EndOfMessage();
    public WebSocketMessageType get_MessageType();
}
public abstract class System.Net.WebSockets.WebSocket : object {
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public static TimeSpan DefaultKeepAliveInterval { get; }
    public WebSocketState State { get; }
    public string SubProtocol { get; }
    public abstract virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public abstract virtual string get_CloseStatusDescription();
    public static TimeSpan get_DefaultKeepAliveInterval();
    public abstract virtual WebSocketState get_State();
    public abstract virtual string get_SubProtocol();
    public abstract virtual void Abort();
    public abstract virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public abstract virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public static ArraySegment`1<byte> CreateClientBuffer(int receiveBufferSize, int sendBufferSize);
    [EditorBrowsableAttribute("1")]
public static WebSocket CreateClientWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval, bool useZeroMaskingKey, ArraySegment`1<byte> internalBuffer);
    public static WebSocket CreateFromStream(Stream stream, bool isServer, string subProtocol, TimeSpan keepAliveInterval);
    public static ArraySegment`1<byte> CreateServerBuffer(int receiveBufferSize);
    public abstract virtual void Dispose();
    protected static bool IsStateTerminal(WebSocketState state);
    public abstract virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public virtual ValueTask`1<ValueWebSocketReceiveResult> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static void RegisterPrefixes();
    public abstract virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public virtual ValueTask SendAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    protected static void ThrowOnInvalidState(WebSocketState state, WebSocketState[] validStates);
}
public enum System.Net.WebSockets.WebSocketCloseStatus : Enum {
    public int value__;
    public static WebSocketCloseStatus Empty;
    public static WebSocketCloseStatus EndpointUnavailable;
    public static WebSocketCloseStatus InternalServerError;
    public static WebSocketCloseStatus InvalidMessageType;
    public static WebSocketCloseStatus InvalidPayloadData;
    public static WebSocketCloseStatus MandatoryExtension;
    public static WebSocketCloseStatus MessageTooBig;
    public static WebSocketCloseStatus NormalClosure;
    public static WebSocketCloseStatus PolicyViolation;
    public static WebSocketCloseStatus ProtocolError;
}
public abstract class System.Net.WebSockets.WebSocketContext : object {
    public CookieCollection CookieCollection { get; }
    public NameValueCollection Headers { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public string Origin { get; }
    public Uri RequestUri { get; }
    public string SecWebSocketKey { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public IPrincipal User { get; }
    public WebSocket WebSocket { get; }
    public abstract virtual CookieCollection get_CookieCollection();
    public abstract virtual NameValueCollection get_Headers();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsLocal();
    public abstract virtual bool get_IsSecureConnection();
    public abstract virtual string get_Origin();
    public abstract virtual Uri get_RequestUri();
    public abstract virtual string get_SecWebSocketKey();
    public abstract virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public abstract virtual string get_SecWebSocketVersion();
    public abstract virtual IPrincipal get_User();
    public abstract virtual WebSocket get_WebSocket();
}
public enum System.Net.WebSockets.WebSocketError : Enum {
    public int value__;
    public static WebSocketError ConnectionClosedPrematurely;
    public static WebSocketError Faulted;
    public static WebSocketError HeaderError;
    public static WebSocketError InvalidMessageType;
    public static WebSocketError InvalidState;
    public static WebSocketError NativeError;
    public static WebSocketError NotAWebSocket;
    public static WebSocketError Success;
    public static WebSocketError UnsupportedProtocol;
    public static WebSocketError UnsupportedVersion;
}
public class System.Net.WebSockets.WebSocketException : Win32Exception {
    public int ErrorCode { get; }
    public WebSocketError WebSocketErrorCode { get; }
    public WebSocketException(int nativeError);
    public WebSocketException(int nativeError, Exception innerException);
    public WebSocketException(int nativeError, string message);
    public WebSocketException(WebSocketError error);
    public WebSocketException(WebSocketError error, Exception innerException);
    public WebSocketException(WebSocketError error, int nativeError);
    public WebSocketException(WebSocketError error, int nativeError, Exception innerException);
    public WebSocketException(WebSocketError error, int nativeError, string message);
    public WebSocketException(WebSocketError error, int nativeError, string message, Exception innerException);
    public WebSocketException(WebSocketError error, string message);
    public WebSocketException(WebSocketError error, string message, Exception innerException);
    public WebSocketException(string message);
    public WebSocketException(string message, Exception innerException);
    public virtual int get_ErrorCode();
    public WebSocketError get_WebSocketErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.Net.WebSockets.WebSocketMessageType : Enum {
    public int value__;
    public static WebSocketMessageType Binary;
    public static WebSocketMessageType Close;
    public static WebSocketMessageType Text;
}
public class System.Net.WebSockets.WebSocketReceiveResult : object {
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public int Count { get; }
    public bool EndOfMessage { get; }
    public WebSocketMessageType MessageType { get; }
    public WebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage);
    public WebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage, Nullable`1<WebSocketCloseStatus> closeStatus, string closeStatusDescription);
    public Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public string get_CloseStatusDescription();
    public int get_Count();
    public bool get_EndOfMessage();
    public WebSocketMessageType get_MessageType();
}
public enum System.Net.WebSockets.WebSocketState : Enum {
    public int value__;
    public static WebSocketState Aborted;
    public static WebSocketState Closed;
    public static WebSocketState CloseReceived;
    public static WebSocketState CloseSent;
    public static WebSocketState Connecting;
    public static WebSocketState None;
    public static WebSocketState Open;
}
public static class System.Net.WebUtility : object {
    public static string HtmlDecode(string value);
    public static void HtmlDecode(string value, TextWriter output);
    public static string HtmlEncode(string value);
    public static void HtmlEncode(string value, TextWriter output);
    public static string UrlDecode(string encodedValue);
    public static Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count);
    public static string UrlEncode(string value);
    public static Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count);
}
public class System.NetPipeStyleUriParser : UriParser {
}
public class System.NetTcpStyleUriParser : UriParser {
}
public class System.NewsStyleUriParser : UriParser {
}
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
}
public class System.NotFiniteNumberException : ArithmeticException {
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    public NotFiniteNumberException(string message, Exception innerException);
    public double get_OffendingNumber();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.NotImplementedException : SystemException {
    protected NotImplementedException(SerializationInfo info, StreamingContext context);
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
}
public class System.NotSupportedException : SystemException {
    protected NotSupportedException(SerializationInfo info, StreamingContext context);
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    public static Type GetUnderlyingType(Type nullableType);
}
public class System.Nullable`1 : ValueType {
    internal T value;
    private int _dummyPrimitive;
    public bool HasValue { get; }
    public T Value { get; }
    public Nullable`1(T value);
    public bool get_HasValue();
    public T get_Value();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
    public static T op_Explicit(Nullable`1<T> value);
    public static Nullable`1<T> op_Implicit(T value);
    public virtual string ToString();
}
public class System.NullReferenceException : SystemException {
    protected NullReferenceException(SerializationInfo info, StreamingContext context);
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.Numerics.BigInteger : ValueType {
    private object _dummy;
    public bool IsEven { get; }
    public bool IsOne { get; }
    public bool IsPowerOfTwo { get; }
    public bool IsZero { get; }
    public static BigInteger MinusOne { get; }
    public static BigInteger One { get; }
    public int Sign { get; }
    public static BigInteger Zero { get; }
    [CLSCompliantAttribute("False")]
public BigInteger(Byte[] value);
    public BigInteger(decimal value);
    public BigInteger(double value);
    public BigInteger(int value);
    public BigInteger(long value);
    public BigInteger(ReadOnlySpan`1<byte> value, bool isUnsigned, bool isBigEndian);
    public BigInteger(float value);
    [CLSCompliantAttribute("False")]
public BigInteger(UInt32 value);
    [CLSCompliantAttribute("False")]
public BigInteger(ulong value);
    public bool get_IsEven();
    public bool get_IsOne();
    public bool get_IsPowerOfTwo();
    public bool get_IsZero();
    public static BigInteger get_MinusOne();
    public static BigInteger get_One();
    public int get_Sign();
    public static BigInteger get_Zero();
    public static BigInteger Abs(BigInteger value);
    public static BigInteger Add(BigInteger left, BigInteger right);
    public static int Compare(BigInteger left, BigInteger right);
    public int CompareTo(long other);
    public sealed virtual int CompareTo(BigInteger other);
    public sealed virtual int CompareTo(object obj);
    [CLSCompliantAttribute("False")]
public int CompareTo(ulong other);
    public static BigInteger Divide(BigInteger dividend, BigInteger divisor);
    public static BigInteger DivRem(BigInteger dividend, BigInteger divisor, BigInteger& remainder);
    public bool Equals(long other);
    public sealed virtual bool Equals(BigInteger other);
    public virtual bool Equals(object obj);
    [CLSCompliantAttribute("False")]
public bool Equals(ulong other);
    public int GetByteCount(bool isUnsigned);
    public virtual int GetHashCode();
    public static BigInteger GreatestCommonDivisor(BigInteger left, BigInteger right);
    public static double Log(BigInteger value);
    public static double Log(BigInteger value, double baseValue);
    public static double Log10(BigInteger value);
    public static BigInteger Max(BigInteger left, BigInteger right);
    public static BigInteger Min(BigInteger left, BigInteger right);
    public static BigInteger ModPow(BigInteger value, BigInteger exponent, BigInteger modulus);
    public static BigInteger Multiply(BigInteger left, BigInteger right);
    public static BigInteger Negate(BigInteger value);
    public static BigInteger op_Addition(BigInteger left, BigInteger right);
    public static BigInteger op_BitwiseAnd(BigInteger left, BigInteger right);
    public static BigInteger op_BitwiseOr(BigInteger left, BigInteger right);
    public static BigInteger op_Decrement(BigInteger value);
    public static BigInteger op_Division(BigInteger dividend, BigInteger divisor);
    public static bool op_Equality(long left, BigInteger right);
    public static bool op_Equality(BigInteger left, long right);
    public static bool op_Equality(BigInteger left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_Equality(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_Equality(ulong left, BigInteger right);
    public static BigInteger op_ExclusiveOr(BigInteger left, BigInteger right);
    public static BigInteger op_Explicit(decimal value);
    public static BigInteger op_Explicit(double value);
    public static byte op_Explicit(BigInteger value);
    public static decimal op_Explicit(BigInteger value);
    public static double op_Explicit(BigInteger value);
    public static short op_Explicit(BigInteger value);
    public static int op_Explicit(BigInteger value);
    public static long op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(BigInteger value);
    public static float op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(BigInteger value);
    public static BigInteger op_Explicit(float value);
    public static bool op_GreaterThan(long left, BigInteger right);
    public static bool op_GreaterThan(BigInteger left, long right);
    public static bool op_GreaterThan(BigInteger left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_GreaterThan(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_GreaterThan(ulong left, BigInteger right);
    public static bool op_GreaterThanOrEqual(long left, BigInteger right);
    public static bool op_GreaterThanOrEqual(BigInteger left, long right);
    public static bool op_GreaterThanOrEqual(BigInteger left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_GreaterThanOrEqual(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_GreaterThanOrEqual(ulong left, BigInteger right);
    public static BigInteger op_Implicit(byte value);
    public static BigInteger op_Implicit(short value);
    public static BigInteger op_Implicit(int value);
    public static BigInteger op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(ulong value);
    public static BigInteger op_Increment(BigInteger value);
    public static bool op_Inequality(long left, BigInteger right);
    public static bool op_Inequality(BigInteger left, long right);
    public static bool op_Inequality(BigInteger left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_Inequality(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_Inequality(ulong left, BigInteger right);
    public static BigInteger op_LeftShift(BigInteger value, int shift);
    public static bool op_LessThan(long left, BigInteger right);
    public static bool op_LessThan(BigInteger left, long right);
    public static bool op_LessThan(BigInteger left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_LessThan(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_LessThan(ulong left, BigInteger right);
    public static bool op_LessThanOrEqual(long left, BigInteger right);
    public static bool op_LessThanOrEqual(BigInteger left, long right);
    public static bool op_LessThanOrEqual(BigInteger left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_LessThanOrEqual(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_LessThanOrEqual(ulong left, BigInteger right);
    public static BigInteger op_Modulus(BigInteger dividend, BigInteger divisor);
    public static BigInteger op_Multiply(BigInteger left, BigInteger right);
    public static BigInteger op_OnesComplement(BigInteger value);
    public static BigInteger op_RightShift(BigInteger value, int shift);
    public static BigInteger op_Subtraction(BigInteger left, BigInteger right);
    public static BigInteger op_UnaryNegation(BigInteger value);
    public static BigInteger op_UnaryPlus(BigInteger value);
    public static BigInteger Parse(ReadOnlySpan`1<char> value, NumberStyles style, IFormatProvider provider);
    public static BigInteger Parse(string value);
    public static BigInteger Parse(string value, NumberStyles style);
    public static BigInteger Parse(string value, NumberStyles style, IFormatProvider provider);
    public static BigInteger Parse(string value, IFormatProvider provider);
    public static BigInteger Pow(BigInteger value, int exponent);
    public static BigInteger Remainder(BigInteger dividend, BigInteger divisor);
    public static BigInteger Subtract(BigInteger left, BigInteger right);
    public Byte[] ToByteArray();
    public Byte[] ToByteArray(bool isUnsigned, bool isBigEndian);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> value, NumberStyles style, IFormatProvider provider, BigInteger& result);
    public static bool TryParse(ReadOnlySpan`1<char> value, BigInteger& result);
    public static bool TryParse(string value, NumberStyles style, IFormatProvider provider, BigInteger& result);
    public static bool TryParse(string value, BigInteger& result);
    public bool TryWriteBytes(Span`1<byte> destination, Int32& bytesWritten, bool isUnsigned, bool isBigEndian);
}
public class System.Numerics.Complex : ValueType {
    private int _dummyPrimitive;
    public static Complex ImaginaryOne;
    public static Complex One;
    public static Complex Zero;
    public double Imaginary { get; }
    public double Magnitude { get; }
    public double Phase { get; }
    public double Real { get; }
    public Complex(double real, double imaginary);
    public double get_Imaginary();
    public double get_Magnitude();
    public double get_Phase();
    public double get_Real();
    public static double Abs(Complex value);
    public static Complex Acos(Complex value);
    public static Complex Add(Complex left, Complex right);
    public static Complex Asin(Complex value);
    public static Complex Atan(Complex value);
    public static Complex Conjugate(Complex value);
    public static Complex Cos(Complex value);
    public static Complex Cosh(Complex value);
    public static Complex Divide(Complex dividend, Complex divisor);
    public sealed virtual bool Equals(Complex value);
    public virtual bool Equals(object obj);
    public static Complex Exp(Complex value);
    public static Complex FromPolarCoordinates(double magnitude, double phase);
    public virtual int GetHashCode();
    public static Complex Log(Complex value);
    public static Complex Log(Complex value, double baseValue);
    public static Complex Log10(Complex value);
    public static Complex Multiply(Complex left, Complex right);
    public static Complex Negate(Complex value);
    public static Complex op_Addition(Complex left, Complex right);
    public static Complex op_Division(Complex left, Complex right);
    public static bool op_Equality(Complex left, Complex right);
    public static Complex op_Explicit(decimal value);
    public static Complex op_Explicit(BigInteger value);
    public static Complex op_Implicit(byte value);
    public static Complex op_Implicit(double value);
    public static Complex op_Implicit(short value);
    public static Complex op_Implicit(int value);
    public static Complex op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(sbyte value);
    public static Complex op_Implicit(float value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(ulong value);
    public static bool op_Inequality(Complex left, Complex right);
    public static Complex op_Multiply(Complex left, Complex right);
    public static Complex op_Subtraction(Complex left, Complex right);
    public static Complex op_UnaryNegation(Complex value);
    public static Complex Pow(Complex value, double power);
    public static Complex Pow(Complex value, Complex power);
    public static Complex Reciprocal(Complex value);
    public static Complex Sin(Complex value);
    public static Complex Sinh(Complex value);
    public static Complex Sqrt(Complex value);
    public static Complex Subtract(Complex left, Complex right);
    public static Complex Tan(Complex value);
    public static Complex Tanh(Complex value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
}
public class System.Numerics.Matrix3x2 : ValueType {
    public float M11;
    public float M12;
    public float M21;
    public float M22;
    public float M31;
    public float M32;
    public static Matrix3x2 Identity { get; }
    public bool IsIdentity { get; }
    public Vector2 Translation { get; public set; }
    public Matrix3x2(float m11, float m12, float m21, float m22, float m31, float m32);
    public static Matrix3x2 get_Identity();
    [IsReadOnlyAttribute]
public bool get_IsIdentity();
    [IsReadOnlyAttribute]
public Vector2 get_Translation();
    public void set_Translation(Vector2 value);
    public static Matrix3x2 Add(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 CreateRotation(float radians);
    public static Matrix3x2 CreateRotation(float radians, Vector2 centerPoint);
    public static Matrix3x2 CreateScale(Vector2 scales);
    public static Matrix3x2 CreateScale(Vector2 scales, Vector2 centerPoint);
    public static Matrix3x2 CreateScale(float scale);
    public static Matrix3x2 CreateScale(float scale, Vector2 centerPoint);
    public static Matrix3x2 CreateScale(float xScale, float yScale);
    public static Matrix3x2 CreateScale(float xScale, float yScale, Vector2 centerPoint);
    public static Matrix3x2 CreateSkew(float radiansX, float radiansY);
    public static Matrix3x2 CreateSkew(float radiansX, float radiansY, Vector2 centerPoint);
    public static Matrix3x2 CreateTranslation(Vector2 position);
    public static Matrix3x2 CreateTranslation(float xPosition, float yPosition);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Matrix3x2 other);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public float GetDeterminant();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public static bool Invert(Matrix3x2 matrix, Matrix3x2& result);
    public static Matrix3x2 Lerp(Matrix3x2 matrix1, Matrix3x2 matrix2, float amount);
    public static Matrix3x2 Multiply(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 Multiply(Matrix3x2 value1, float value2);
    public static Matrix3x2 Negate(Matrix3x2 value);
    public static Matrix3x2 op_Addition(Matrix3x2 value1, Matrix3x2 value2);
    public static bool op_Equality(Matrix3x2 value1, Matrix3x2 value2);
    public static bool op_Inequality(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 op_Multiply(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 op_Multiply(Matrix3x2 value1, float value2);
    public static Matrix3x2 op_Subtraction(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 op_UnaryNegation(Matrix3x2 value);
    public static Matrix3x2 Subtract(Matrix3x2 value1, Matrix3x2 value2);
    [IsReadOnlyAttribute]
public virtual string ToString();
}
public class System.Numerics.Matrix4x4 : ValueType {
    public float M11;
    public float M12;
    public float M13;
    public float M14;
    public float M21;
    public float M22;
    public float M23;
    public float M24;
    public float M31;
    public float M32;
    public float M33;
    public float M34;
    public float M41;
    public float M42;
    public float M43;
    public float M44;
    public static Matrix4x4 Identity { get; }
    public bool IsIdentity { get; }
    public Vector3 Translation { get; public set; }
    public Matrix4x4(Matrix3x2 value);
    public Matrix4x4(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44);
    public static Matrix4x4 get_Identity();
    [IsReadOnlyAttribute]
public bool get_IsIdentity();
    [IsReadOnlyAttribute]
public Vector3 get_Translation();
    public void set_Translation(Vector3 value);
    public static Matrix4x4 Add(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 CreateBillboard(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
    public static Matrix4x4 CreateConstrainedBillboard(Vector3 objectPosition, Vector3 cameraPosition, Vector3 rotateAxis, Vector3 cameraForwardVector, Vector3 objectForwardVector);
    public static Matrix4x4 CreateFromAxisAngle(Vector3 axis, float angle);
    public static Matrix4x4 CreateFromQuaternion(Quaternion quaternion);
    public static Matrix4x4 CreateFromYawPitchRoll(float yaw, float pitch, float roll);
    public static Matrix4x4 CreateLookAt(Vector3 cameraPosition, Vector3 cameraTarget, Vector3 cameraUpVector);
    public static Matrix4x4 CreateOrthographic(float width, float height, float zNearPlane, float zFarPlane);
    public static Matrix4x4 CreateOrthographicOffCenter(float left, float right, float bottom, float top, float zNearPlane, float zFarPlane);
    public static Matrix4x4 CreatePerspective(float width, float height, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreatePerspectiveFieldOfView(float fieldOfView, float aspectRatio, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreatePerspectiveOffCenter(float left, float right, float bottom, float top, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreateReflection(Plane value);
    public static Matrix4x4 CreateRotationX(float radians);
    public static Matrix4x4 CreateRotationX(float radians, Vector3 centerPoint);
    public static Matrix4x4 CreateRotationY(float radians);
    public static Matrix4x4 CreateRotationY(float radians, Vector3 centerPoint);
    public static Matrix4x4 CreateRotationZ(float radians);
    public static Matrix4x4 CreateRotationZ(float radians, Vector3 centerPoint);
    public static Matrix4x4 CreateScale(Vector3 scales);
    public static Matrix4x4 CreateScale(Vector3 scales, Vector3 centerPoint);
    public static Matrix4x4 CreateScale(float scale);
    public static Matrix4x4 CreateScale(float scale, Vector3 centerPoint);
    public static Matrix4x4 CreateScale(float xScale, float yScale, float zScale);
    public static Matrix4x4 CreateScale(float xScale, float yScale, float zScale, Vector3 centerPoint);
    public static Matrix4x4 CreateShadow(Vector3 lightDirection, Plane plane);
    public static Matrix4x4 CreateTranslation(Vector3 position);
    public static Matrix4x4 CreateTranslation(float xPosition, float yPosition, float zPosition);
    public static Matrix4x4 CreateWorld(Vector3 position, Vector3 forward, Vector3 up);
    public static bool Decompose(Matrix4x4 matrix, Vector3& scale, Quaternion& rotation, Vector3& translation);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Matrix4x4 other);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public float GetDeterminant();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public static bool Invert(Matrix4x4 matrix, Matrix4x4& result);
    public static Matrix4x4 Lerp(Matrix4x4 matrix1, Matrix4x4 matrix2, float amount);
    public static Matrix4x4 Multiply(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 Multiply(Matrix4x4 value1, float value2);
    public static Matrix4x4 Negate(Matrix4x4 value);
    public static Matrix4x4 op_Addition(Matrix4x4 value1, Matrix4x4 value2);
    public static bool op_Equality(Matrix4x4 value1, Matrix4x4 value2);
    public static bool op_Inequality(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 op_Multiply(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 op_Multiply(Matrix4x4 value1, float value2);
    public static Matrix4x4 op_Subtraction(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 op_UnaryNegation(Matrix4x4 value);
    public static Matrix4x4 Subtract(Matrix4x4 value1, Matrix4x4 value2);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static Matrix4x4 Transform(Matrix4x4 value, Quaternion rotation);
    public static Matrix4x4 Transpose(Matrix4x4 matrix);
}
public class System.Numerics.Plane : ValueType {
    public float D;
    public Vector3 Normal;
    public Plane(Vector3 normal, float d);
    public Plane(Vector4 value);
    public Plane(float x, float y, float z, float d);
    public static Plane CreateFromVertices(Vector3 point1, Vector3 point2, Vector3 point3);
    public static float Dot(Plane plane, Vector4 value);
    public static float DotCoordinate(Plane plane, Vector3 value);
    public static float DotNormal(Plane plane, Vector3 value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Plane other);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public static Plane Normalize(Plane value);
    public static bool op_Equality(Plane value1, Plane value2);
    public static bool op_Inequality(Plane value1, Plane value2);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static Plane Transform(Plane plane, Matrix4x4 matrix);
    public static Plane Transform(Plane plane, Quaternion rotation);
}
public class System.Numerics.Quaternion : ValueType {
    public float W;
    public float X;
    public float Y;
    public float Z;
    public static Quaternion Identity { get; }
    public bool IsIdentity { get; }
    public Quaternion(Vector3 vectorPart, float scalarPart);
    public Quaternion(float x, float y, float z, float w);
    public static Quaternion get_Identity();
    [IsReadOnlyAttribute]
public bool get_IsIdentity();
    public static Quaternion Add(Quaternion value1, Quaternion value2);
    public static Quaternion Concatenate(Quaternion value1, Quaternion value2);
    public static Quaternion Conjugate(Quaternion value);
    public static Quaternion CreateFromAxisAngle(Vector3 axis, float angle);
    public static Quaternion CreateFromRotationMatrix(Matrix4x4 matrix);
    public static Quaternion CreateFromYawPitchRoll(float yaw, float pitch, float roll);
    public static Quaternion Divide(Quaternion value1, Quaternion value2);
    public static float Dot(Quaternion quaternion1, Quaternion quaternion2);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Quaternion other);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public static Quaternion Inverse(Quaternion value);
    [IsReadOnlyAttribute]
public float Length();
    [IsReadOnlyAttribute]
public float LengthSquared();
    public static Quaternion Lerp(Quaternion quaternion1, Quaternion quaternion2, float amount);
    public static Quaternion Multiply(Quaternion value1, Quaternion value2);
    public static Quaternion Multiply(Quaternion value1, float value2);
    public static Quaternion Negate(Quaternion value);
    public static Quaternion Normalize(Quaternion value);
    public static Quaternion op_Addition(Quaternion value1, Quaternion value2);
    public static Quaternion op_Division(Quaternion value1, Quaternion value2);
    public static bool op_Equality(Quaternion value1, Quaternion value2);
    public static bool op_Inequality(Quaternion value1, Quaternion value2);
    public static Quaternion op_Multiply(Quaternion value1, Quaternion value2);
    public static Quaternion op_Multiply(Quaternion value1, float value2);
    public static Quaternion op_Subtraction(Quaternion value1, Quaternion value2);
    public static Quaternion op_UnaryNegation(Quaternion value);
    public static Quaternion Slerp(Quaternion quaternion1, Quaternion quaternion2, float amount);
    public static Quaternion Subtract(Quaternion value1, Quaternion value2);
    [IsReadOnlyAttribute]
public virtual string ToString();
}
public static class System.Numerics.Vector : object {
    public static bool IsHardwareAccelerated { get; }
    public static bool get_IsHardwareAccelerated();
    public static Vector`1<T> Abs(Vector`1<T> value);
    public static Vector`1<T> Add(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> AndNot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<byte> AsVectorByte(Vector`1<T> value);
    public static Vector`1<double> AsVectorDouble(Vector`1<T> value);
    public static Vector`1<short> AsVectorInt16(Vector`1<T> value);
    public static Vector`1<int> AsVectorInt32(Vector`1<T> value);
    public static Vector`1<long> AsVectorInt64(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<sbyte> AsVectorSByte(Vector`1<T> value);
    public static Vector`1<float> AsVectorSingle(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ushort> AsVectorUInt16(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> AsVectorUInt32(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ulong> AsVectorUInt64(Vector`1<T> value);
    public static Vector`1<T> BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<float> ConditionalSelect(Vector`1<int> condition, Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<double> ConditionalSelect(Vector`1<long> condition, Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<double> ConvertToDouble(Vector`1<long> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<double> ConvertToDouble(Vector`1<ulong> value);
    public static Vector`1<int> ConvertToInt32(Vector`1<float> value);
    public static Vector`1<long> ConvertToInt64(Vector`1<double> value);
    public static Vector`1<float> ConvertToSingle(Vector`1<int> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<float> ConvertToSingle(Vector`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> ConvertToUInt32(Vector`1<float> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ulong> ConvertToUInt64(Vector`1<double> value);
    public static Vector`1<T> Divide(Vector`1<T> left, Vector`1<T> right);
    public static T Dot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<long> Equals(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<int> Equals(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> Equals(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<int> Equals(Vector`1<float> left, Vector`1<float> right);
    public static bool EqualsAll(Vector`1<T> left, Vector`1<T> right);
    public static bool EqualsAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<long> GreaterThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<int> GreaterThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThan(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<int> GreaterThan(Vector`1<float> left, Vector`1<float> right);
    public static bool GreaterThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static bool GreaterThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<long> LessThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<int> LessThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThan(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<int> LessThan(Vector`1<float> left, Vector`1<float> right);
    public static bool LessThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static bool LessThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, T right);
    public static Vector`1<T> Multiply(T left, Vector`1<T> right);
    public static Vector`1<float> Narrow(Vector`1<double> source1, Vector`1<double> source2);
    [CLSCompliantAttribute("False")]
public static Vector`1<sbyte> Narrow(Vector`1<short> source1, Vector`1<short> source2);
    public static Vector`1<short> Narrow(Vector`1<int> source1, Vector`1<int> source2);
    public static Vector`1<int> Narrow(Vector`1<long> source1, Vector`1<long> source2);
    [CLSCompliantAttribute("False")]
public static Vector`1<byte> Narrow(Vector`1<ushort> source1, Vector`1<ushort> source2);
    [CLSCompliantAttribute("False")]
public static Vector`1<ushort> Narrow(Vector`1<UInt32> source1, Vector`1<UInt32> source2);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> Narrow(Vector`1<ulong> source1, Vector`1<ulong> source2);
    public static Vector`1<T> Negate(Vector`1<T> value);
    public static Vector`1<T> OnesComplement(Vector`1<T> value);
    public static Vector`1<T> SquareRoot(Vector`1<T> value);
    public static Vector`1<T> Subtract(Vector`1<T> left, Vector`1<T> right);
    [CLSCompliantAttribute("False")]
public static void Widen(Vector`1<byte> source, Vector`1& dest1, Vector`1& dest2);
    public static void Widen(Vector`1<short> source, Vector`1& dest1, Vector`1& dest2);
    public static void Widen(Vector`1<int> source, Vector`1& dest1, Vector`1& dest2);
    [CLSCompliantAttribute("False")]
public static void Widen(Vector`1<sbyte> source, Vector`1& dest1, Vector`1& dest2);
    public static void Widen(Vector`1<float> source, Vector`1& dest1, Vector`1& dest2);
    [CLSCompliantAttribute("False")]
public static void Widen(Vector`1<ushort> source, Vector`1& dest1, Vector`1& dest2);
    [CLSCompliantAttribute("False")]
public static void Widen(Vector`1<UInt32> source, Vector`1& dest1, Vector`1& dest2);
    public static Vector`1<T> Xor(Vector`1<T> left, Vector`1<T> right);
}
[DefaultMemberAttribute("Item")]
public class System.Numerics.Vector`1 : ValueType {
    private int _dummyPrimitive;
    public static int Count { get; }
    public T Item { get; }
    public static Vector`1<T> One { get; }
    public static Vector`1<T> Zero { get; }
    public Vector`1(Span`1<T> values);
    public Vector`1(T value);
    public Vector`1(T[] values);
    public Vector`1(T[] values, int index);
    public static int get_Count();
    [IsReadOnlyAttribute]
public T get_Item(int index);
    public static Vector`1<T> get_One();
    public static Vector`1<T> get_Zero();
    [IsReadOnlyAttribute]
public void CopyTo(T[] destination);
    [IsReadOnlyAttribute]
public void CopyTo(T[] destination, int startIndex);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Vector`1<T> other);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public static Vector`1<T> op_Addition(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Division(Vector`1<T> left, Vector`1<T> right);
    public static bool op_Equality(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_ExclusiveOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<byte> op_Explicit(Vector`1<T> value);
    public static Vector`1<double> op_Explicit(Vector`1<T> value);
    public static Vector`1<short> op_Explicit(Vector`1<T> value);
    public static Vector`1<int> op_Explicit(Vector`1<T> value);
    public static Vector`1<long> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<sbyte> op_Explicit(Vector`1<T> value);
    public static Vector`1<float> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ushort> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ulong> op_Explicit(Vector`1<T> value);
    public static bool op_Inequality(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> value, T factor);
    public static Vector`1<T> op_Multiply(T factor, Vector`1<T> value);
    public static Vector`1<T> op_OnesComplement(Vector`1<T> value);
    public static Vector`1<T> op_Subtraction(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_UnaryNegation(Vector`1<T> value);
    [IsReadOnlyAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
public string ToString(string format);
    [IsReadOnlyAttribute]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public class System.Numerics.Vector2 : ValueType {
    public float X;
    public float Y;
    public static Vector2 One { get; }
    public static Vector2 UnitX { get; }
    public static Vector2 UnitY { get; }
    public static Vector2 Zero { get; }
    public Vector2(float value);
    public Vector2(float x, float y);
    public static Vector2 get_One();
    public static Vector2 get_UnitX();
    public static Vector2 get_UnitY();
    public static Vector2 get_Zero();
    public static Vector2 Abs(Vector2 value);
    public static Vector2 Add(Vector2 left, Vector2 right);
    public static Vector2 Clamp(Vector2 value1, Vector2 min, Vector2 max);
    [IsReadOnlyAttribute]
public void CopyTo(Single[] array);
    [IsReadOnlyAttribute]
public void CopyTo(Single[] array, int index);
    public static float Distance(Vector2 value1, Vector2 value2);
    public static float DistanceSquared(Vector2 value1, Vector2 value2);
    public static Vector2 Divide(Vector2 left, Vector2 right);
    public static Vector2 Divide(Vector2 left, float divisor);
    public static float Dot(Vector2 value1, Vector2 value2);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Vector2 other);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
public float Length();
    [IsReadOnlyAttribute]
public float LengthSquared();
    public static Vector2 Lerp(Vector2 value1, Vector2 value2, float amount);
    public static Vector2 Max(Vector2 value1, Vector2 value2);
    public static Vector2 Min(Vector2 value1, Vector2 value2);
    public static Vector2 Multiply(Vector2 left, Vector2 right);
    public static Vector2 Multiply(Vector2 left, float right);
    public static Vector2 Multiply(float left, Vector2 right);
    public static Vector2 Negate(Vector2 value);
    public static Vector2 Normalize(Vector2 value);
    public static Vector2 op_Addition(Vector2 left, Vector2 right);
    public static Vector2 op_Division(Vector2 left, Vector2 right);
    public static Vector2 op_Division(Vector2 value1, float value2);
    public static bool op_Equality(Vector2 left, Vector2 right);
    public static bool op_Inequality(Vector2 left, Vector2 right);
    public static Vector2 op_Multiply(Vector2 left, Vector2 right);
    public static Vector2 op_Multiply(Vector2 left, float right);
    public static Vector2 op_Multiply(float left, Vector2 right);
    public static Vector2 op_Subtraction(Vector2 left, Vector2 right);
    public static Vector2 op_UnaryNegation(Vector2 value);
    public static Vector2 Reflect(Vector2 vector, Vector2 normal);
    public static Vector2 SquareRoot(Vector2 value);
    public static Vector2 Subtract(Vector2 left, Vector2 right);
    [IsReadOnlyAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
public string ToString(string format);
    [IsReadOnlyAttribute]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector2 Transform(Vector2 position, Matrix3x2 matrix);
    public static Vector2 Transform(Vector2 position, Matrix4x4 matrix);
    public static Vector2 Transform(Vector2 value, Quaternion rotation);
    public static Vector2 TransformNormal(Vector2 normal, Matrix3x2 matrix);
    public static Vector2 TransformNormal(Vector2 normal, Matrix4x4 matrix);
}
public class System.Numerics.Vector3 : ValueType {
    public float X;
    public float Y;
    public float Z;
    public static Vector3 One { get; }
    public static Vector3 UnitX { get; }
    public static Vector3 UnitY { get; }
    public static Vector3 UnitZ { get; }
    public static Vector3 Zero { get; }
    public Vector3(Vector2 value, float z);
    public Vector3(float value);
    public Vector3(float x, float y, float z);
    public static Vector3 get_One();
    public static Vector3 get_UnitX();
    public static Vector3 get_UnitY();
    public static Vector3 get_UnitZ();
    public static Vector3 get_Zero();
    public static Vector3 Abs(Vector3 value);
    public static Vector3 Add(Vector3 left, Vector3 right);
    public static Vector3 Clamp(Vector3 value1, Vector3 min, Vector3 max);
    [IsReadOnlyAttribute]
public void CopyTo(Single[] array);
    [IsReadOnlyAttribute]
public void CopyTo(Single[] array, int index);
    public static Vector3 Cross(Vector3 vector1, Vector3 vector2);
    public static float Distance(Vector3 value1, Vector3 value2);
    public static float DistanceSquared(Vector3 value1, Vector3 value2);
    public static Vector3 Divide(Vector3 left, Vector3 right);
    public static Vector3 Divide(Vector3 left, float divisor);
    public static float Dot(Vector3 vector1, Vector3 vector2);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Vector3 other);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
public float Length();
    [IsReadOnlyAttribute]
public float LengthSquared();
    public static Vector3 Lerp(Vector3 value1, Vector3 value2, float amount);
    public static Vector3 Max(Vector3 value1, Vector3 value2);
    public static Vector3 Min(Vector3 value1, Vector3 value2);
    public static Vector3 Multiply(Vector3 left, Vector3 right);
    public static Vector3 Multiply(Vector3 left, float right);
    public static Vector3 Multiply(float left, Vector3 right);
    public static Vector3 Negate(Vector3 value);
    public static Vector3 Normalize(Vector3 value);
    public static Vector3 op_Addition(Vector3 left, Vector3 right);
    public static Vector3 op_Division(Vector3 left, Vector3 right);
    public static Vector3 op_Division(Vector3 value1, float value2);
    public static bool op_Equality(Vector3 left, Vector3 right);
    public static bool op_Inequality(Vector3 left, Vector3 right);
    public static Vector3 op_Multiply(Vector3 left, Vector3 right);
    public static Vector3 op_Multiply(Vector3 left, float right);
    public static Vector3 op_Multiply(float left, Vector3 right);
    public static Vector3 op_Subtraction(Vector3 left, Vector3 right);
    public static Vector3 op_UnaryNegation(Vector3 value);
    public static Vector3 Reflect(Vector3 vector, Vector3 normal);
    public static Vector3 SquareRoot(Vector3 value);
    public static Vector3 Subtract(Vector3 left, Vector3 right);
    [IsReadOnlyAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
public string ToString(string format);
    [IsReadOnlyAttribute]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector3 Transform(Vector3 position, Matrix4x4 matrix);
    public static Vector3 Transform(Vector3 value, Quaternion rotation);
    public static Vector3 TransformNormal(Vector3 normal, Matrix4x4 matrix);
}
public class System.Numerics.Vector4 : ValueType {
    public float W;
    public float X;
    public float Y;
    public float Z;
    public static Vector4 One { get; }
    public static Vector4 UnitW { get; }
    public static Vector4 UnitX { get; }
    public static Vector4 UnitY { get; }
    public static Vector4 UnitZ { get; }
    public static Vector4 Zero { get; }
    public Vector4(Vector2 value, float z, float w);
    public Vector4(Vector3 value, float w);
    public Vector4(float value);
    public Vector4(float x, float y, float z, float w);
    public static Vector4 get_One();
    public static Vector4 get_UnitW();
    public static Vector4 get_UnitX();
    public static Vector4 get_UnitY();
    public static Vector4 get_UnitZ();
    public static Vector4 get_Zero();
    public static Vector4 Abs(Vector4 value);
    public static Vector4 Add(Vector4 left, Vector4 right);
    public static Vector4 Clamp(Vector4 value1, Vector4 min, Vector4 max);
    [IsReadOnlyAttribute]
public void CopyTo(Single[] array);
    [IsReadOnlyAttribute]
public void CopyTo(Single[] array, int index);
    public static float Distance(Vector4 value1, Vector4 value2);
    public static float DistanceSquared(Vector4 value1, Vector4 value2);
    public static Vector4 Divide(Vector4 left, Vector4 right);
    public static Vector4 Divide(Vector4 left, float divisor);
    public static float Dot(Vector4 vector1, Vector4 vector2);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Vector4 other);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
public float Length();
    [IsReadOnlyAttribute]
public float LengthSquared();
    public static Vector4 Lerp(Vector4 value1, Vector4 value2, float amount);
    public static Vector4 Max(Vector4 value1, Vector4 value2);
    public static Vector4 Min(Vector4 value1, Vector4 value2);
    public static Vector4 Multiply(Vector4 left, Vector4 right);
    public static Vector4 Multiply(Vector4 left, float right);
    public static Vector4 Multiply(float left, Vector4 right);
    public static Vector4 Negate(Vector4 value);
    public static Vector4 Normalize(Vector4 vector);
    public static Vector4 op_Addition(Vector4 left, Vector4 right);
    public static Vector4 op_Division(Vector4 left, Vector4 right);
    public static Vector4 op_Division(Vector4 value1, float value2);
    public static bool op_Equality(Vector4 left, Vector4 right);
    public static bool op_Inequality(Vector4 left, Vector4 right);
    public static Vector4 op_Multiply(Vector4 left, Vector4 right);
    public static Vector4 op_Multiply(Vector4 left, float right);
    public static Vector4 op_Multiply(float left, Vector4 right);
    public static Vector4 op_Subtraction(Vector4 left, Vector4 right);
    public static Vector4 op_UnaryNegation(Vector4 value);
    public static Vector4 SquareRoot(Vector4 value);
    public static Vector4 Subtract(Vector4 left, Vector4 right);
    [IsReadOnlyAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
public string ToString(string format);
    [IsReadOnlyAttribute]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector4 Transform(Vector2 position, Matrix4x4 matrix);
    public static Vector4 Transform(Vector2 value, Quaternion rotation);
    public static Vector4 Transform(Vector3 position, Matrix4x4 matrix);
    public static Vector4 Transform(Vector3 value, Quaternion rotation);
    public static Vector4 Transform(Vector4 vector, Matrix4x4 matrix);
    public static Vector4 Transform(Vector4 value, Quaternion rotation);
}
public class System.Object {
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    protected virtual void Finalize();
    public virtual int GetHashCode();
    public Type GetType();
    protected object MemberwiseClone();
    public static bool ReferenceEquals(object objA, object objB);
    public virtual string ToString();
}
public class System.ObjectDisposedException : InvalidOperationException {
    public string Message { get; }
    public string ObjectName { get; }
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string message, Exception innerException);
    public ObjectDisposedException(string objectName, string message);
    public virtual string get_Message();
    public string get_ObjectName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    public bool IsError { get; }
    public string Message { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public bool get_IsError();
    public string get_Message();
}
public class System.OperatingSystem : object {
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public string get_VersionString();
    public sealed virtual object Clone();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class System.OperationCanceledException : SystemException {
    public CancellationToken CancellationToken { get; }
    protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(CancellationToken token);
    public CancellationToken get_CancellationToken();
}
public class System.OutOfMemoryException : SystemException {
    protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
}
public class System.OverflowException : ArithmeticException {
    protected OverflowException(SerializationInfo info, StreamingContext context);
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
public enum System.PlatformID : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static PlatformID MacOSX;
    public static PlatformID Unix;
    public static PlatformID Win32NT;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32S;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32Windows;
    [EditorBrowsableAttribute("1")]
public static PlatformID WinCE;
    [EditorBrowsableAttribute("1")]
public static PlatformID Xbox;
}
public class System.PlatformNotSupportedException : NotSupportedException {
    protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Progress`1 : object {
    public Progress`1(Action`1<T> handler);
    public void add_ProgressChanged(EventHandler`1<T> value);
    public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
}
public class System.Random : object {
    public Random(int Seed);
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buffer);
    public virtual void NextBytes(Span`1<byte> buffer);
    public virtual double NextDouble();
    protected virtual double Sample();
}
[IsReadOnlyAttribute]
public class System.Range : ValueType {
    private int _dummyPrimitive;
    public static Range All { get; }
    public Index End { get; }
    public Index Start { get; }
    public Range(Index start, Index end);
    public static Range get_All();
    public Index get_End();
    public Index get_Start();
    public static Range EndAt(Index end);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
    public static Range StartAt(Index start);
    public virtual string ToString();
}
public class System.RankException : SystemException {
    protected RankException(SerializationInfo info, StreamingContext context);
    public RankException(string message);
    public RankException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.ReadOnlyMemory`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static ReadOnlyMemory`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public int Length { get; }
    public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    public static ReadOnlyMemory`1<T> get_Empty();
    public bool get_IsEmpty();
    public int get_Length();
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public MemoryHandle Pin();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public T[] ToArray();
    public virtual string ToString();
    public bool TryCopyTo(Memory`1<T> destination);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.ReadOnlySpan`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static ReadOnlySpan`1<T> Empty { get; }
    public bool IsEmpty { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    public static ReadOnlySpan`1<T> get_Empty();
    public bool get_IsEmpty();
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    public int get_Length();
    public void CopyTo(Span`1<T> destination);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
public virtual bool Equals(object obj);
    public Enumerator<T> GetEnumerator();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
    public virtual string ToString();
    public bool TryCopyTo(Span`1<T> destination);
}
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
}
public abstract class System.Reflection.Assembly : object {
    public string CodeBase { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public MethodInfo EntryPoint { get; }
    public string EscapedCodeBase { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public string FullName { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public bool IsFullyTrusted { get; }
    public string Location { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    public bool ReflectionOnly { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    public virtual string get_CodeBase();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual MethodInfo get_EntryPoint();
    public virtual string get_EscapedCodeBase();
    public virtual IEnumerable`1<Type> get_ExportedTypes();
    public virtual string get_FullName();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_IsDynamic();
    public bool get_IsFullyTrusted();
    public virtual string get_Location();
    public virtual Module get_ManifestModule();
    public virtual IEnumerable`1<Module> get_Modules();
    public virtual bool get_ReflectionOnly();
    public virtual SecurityRuleSet get_SecurityRuleSet();
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public object CreateInstance(string typeName);
    public object CreateInstance(string typeName, bool ignoreCase);
    public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static string CreateQualifiedName(string assemblyName, string typeName);
    public virtual bool Equals(object o);
    public static Assembly GetAssembly(Type type);
    public static Assembly GetCallingAssembly();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public static Assembly GetEntryAssembly();
    public static Assembly GetExecutingAssembly();
    public virtual Type[] GetExportedTypes();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles();
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Type[] GetForwardedTypes();
    public virtual int GetHashCode();
    public Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Module GetModule(string name);
    public Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Type GetType(string name);
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public static Assembly Load(Byte[] rawAssembly);
    public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public static Assembly Load(AssemblyName assemblyRef);
    public static Assembly Load(string assemblyString);
    public static Assembly LoadFile(string path);
    public static Assembly LoadFrom(string assemblyFile);
    public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public Module LoadModule(string moduleName, Byte[] rawModule);
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName);
    public static bool op_Equality(Assembly left, Assembly right);
    public static bool op_Inequality(Assembly left, Assembly right);
    public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    public static Assembly ReflectionOnlyLoad(string assemblyString);
    public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    public virtual string ToString();
    public static Assembly UnsafeLoadFrom(string assemblyFile);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    public UInt32 get_AlgorithmId();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    public string get_Company();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    public string get_Copyright();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    public string get_Culture();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    public int AssemblyFlags { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This property has been deprecated. Please use AssemblyFlags instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public UInt32 Flags { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(UInt32 flags);
    public int get_AssemblyFlags();
    public UInt32 get_Flags();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    public string get_InformationalVersion();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    public string get_KeyFile();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    public string get_KeyName();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    public string get_Key();
    public string get_Value();
}
public class System.Reflection.AssemblyName : object {
    public string CodeBase { get; public set; }
    public AssemblyContentType ContentType { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; public set; }
    public string EscapedCodeBase { get; }
    public AssemblyNameFlags Flags { get; public set; }
    public string FullName { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public StrongNameKeyPair KeyPair { get; public set; }
    public string Name { get; public set; }
    public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public Version Version { get; public set; }
    public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    public AssemblyName(string assemblyName);
    public string get_CodeBase();
    public void set_CodeBase(string value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public void set_CultureName(string value);
    public string get_EscapedCodeBase();
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public string get_FullName();
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    public string get_Name();
    public void set_Name(string value);
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public sealed virtual object Clone();
    public static AssemblyName GetAssemblyName(string assemblyFile);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public Byte[] GetPublicKey();
    public Byte[] GetPublicKeyToken();
    public sealed virtual void OnDeserialization(object sender);
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    public void SetPublicKey(Byte[] publicKey);
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags Retargetable;
}
public class System.Reflection.AssemblyNameProxy : MarshalByRefObject {
    public AssemblyName GetAssemblyName(string assemblyFile);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    public string get_Product();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    public string Countersignature { get; }
    public string PublicKey { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    public string get_Countersignature();
    public string get_PublicKey();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    public string get_Title();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    public string get_Trademark();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    public string get_Version();
}
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags CreateInstance;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Default;
    public static BindingFlags DoNotWrapExceptions;
    public static BindingFlags ExactBinding;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags GetField;
    public static BindingFlags GetProperty;
    public static BindingFlags IgnoreCase;
    public static BindingFlags IgnoreReturn;
    public static BindingFlags Instance;
    public static BindingFlags InvokeMethod;
    public static BindingFlags NonPublic;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags Public;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags SetField;
    public static BindingFlags SetProperty;
    public static BindingFlags Static;
    public static BindingFlags SuppressChangeType;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Any;
    public static CallingConventions ExplicitThis;
    public static CallingConventions HasThis;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
}
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    public static string ConstructorName;
    public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    public virtual MemberTypes get_MemberType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
}
public class System.Reflection.CustomAttributeData : object {
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public Type get_AttributeType();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    public virtual bool Equals(object obj);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
public class System.Reflection.CustomAttributeFormatException : FormatException {
    protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
}
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    private object _dummy;
    public bool IsField { get; }
    public MemberInfo MemberInfo { get; }
    public string MemberName { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    public bool get_IsField();
    public MemberInfo get_MemberInfo();
    public string get_MemberName();
    public CustomAttributeTypedArgument get_TypedValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
}
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    private object _dummy;
    public Type ArgumentType { get; }
    public object Value { get; }
    public CustomAttributeTypedArgument(object value);
    public CustomAttributeTypedArgument(Type argumentType, object value);
    public Type get_ArgumentType();
    public object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public virtual string ToString();
}
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    public string get_MemberName();
}
public abstract class System.Reflection.DispatchProxy : object {
    public static T Create();
    protected abstract virtual object Invoke(MethodInfo targetMethod, Object[] args);
}
public class System.Reflection.Emit.AssemblyBuilder : Assembly {
    public string FullName { get; }
    public bool IsDynamic { get; }
    public Module ManifestModule { get; }
    public virtual string get_FullName();
    public virtual bool get_IsDynamic();
    public virtual Module get_ManifestModule();
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    public ModuleBuilder DefineDynamicModule(string name);
    public virtual bool Equals(object obj);
    public ModuleBuilder GetDynamicModule(string name);
    public virtual int GetHashCode();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
[FlagsAttribute]
public enum System.Reflection.Emit.AssemblyBuilderAccess : Enum {
    public int value__;
    public static AssemblyBuilderAccess Run;
    public static AssemblyBuilderAccess RunAndCollect;
}
public class System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type DeclaringType { get; }
    public bool InitLocals { get; public set; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_DeclaringType();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public virtual string ToString();
}
public class System.Reflection.Emit.CustomAttributeBuilder : object {
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
}
public class System.Reflection.Emit.DynamicILInfo : object {
    public DynamicMethod DynamicMethod { get; }
    public DynamicMethod get_DynamicMethod();
    public int GetTokenFor(Byte[] signature);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);
    public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    [CLSCompliantAttribute("False")]
public void SetCode(Byte* code, int codeSize, int maxStackSize);
    public void SetCode(Byte[] code, int maxStackSize);
    [CLSCompliantAttribute("False")]
public void SetExceptions(Byte* exceptions, int exceptionsSize);
    public void SetExceptions(Byte[] exceptions);
    [CLSCompliantAttribute("False")]
public void SetLocalSignature(Byte* localSignature, int signatureSize);
    public void SetLocalSignature(Byte[] localSignature);
}
public class System.Reflection.Emit.DynamicMethod : MethodInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type DeclaringType { get; }
    public bool InitLocals { get; public set; }
    public RuntimeMethodHandle MethodHandle { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_DeclaringType();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public sealed virtual Delegate CreateDelegate(Type delegateType);
    public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public DynamicILInfo GetDynamicILInfo();
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
public class System.Reflection.Emit.EnumBuilder : Type {
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsSZArray { get; }
    public bool IsTypeDefinition { get; }
    public bool IsVariableBoundArray { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public FieldBuilder UnderlyingField { get; }
    public Type UnderlyingSystemType { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsVariableBoundArray();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public FieldBuilder get_UnderlyingField();
    public virtual Type get_UnderlyingSystemType();
    public TypeInfo CreateTypeInfo();
    public FieldBuilder DefineLiteral(string literalName, object literalValue);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    public virtual Type GetEnumUnderlyingType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakePointerType();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
public class System.Reflection.Emit.EventBuilder : object {
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public void SetAddOnMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetRaiseMethod(MethodBuilder mdBuilder);
    public void SetRemoveOnMethod(MethodBuilder mdBuilder);
}
public class System.Reflection.Emit.FieldBuilder : FieldInfo {
    public FieldAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public virtual FieldAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual object GetValue(object obj);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetOffset(int iOffset);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
}
public enum System.Reflection.Emit.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    [ObsoleteAttribute("This API has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")]
public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
public class System.Reflection.Emit.GenericTypeParameterBuilder : Type {
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Guid GUID { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsTypeDefinition { get; }
    public bool IsVariableBoundArray { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Guid get_GUID();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsVariableBoundArray();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    public virtual bool Equals(object o);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual int GetHashCode();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    public virtual bool IsAssignableFrom(Type c);
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual bool IsSubclassOf(Type c);
    protected virtual bool IsValueTypeImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public void SetBaseTypeConstraint(Type baseTypeConstraint);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
    public void SetInterfaceConstraints(Type[] interfaceConstraints);
    public virtual string ToString();
}
public class System.Reflection.Emit.ILGenerator : object {
    public int ILOffset { get; }
    public virtual int get_ILOffset();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginExceptFilterBlock();
    public virtual Label BeginExceptionBlock();
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual void BeginScope();
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual Label DefineLabel();
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    [CLSCompliantAttribute("False")]
public void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, Type cls);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual void EmitWriteLine(string value);
    public virtual void EndExceptionBlock();
    public virtual void EndScope();
    public virtual void MarkLabel(Label loc);
    public virtual void ThrowException(Type excType);
    public virtual void UsingNamespace(string usingNamespace);
}
[IsReadOnlyAttribute]
public class System.Reflection.Emit.Label : ValueType {
    private int _dummyPrimitive;
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Label obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Label a, Label b);
    public static bool op_Inequality(Label a, Label b);
}
public class System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
}
public class System.Reflection.Emit.MethodBuilder : MethodInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public Type DeclaringType { get; }
    public bool InitLocals { get; public set; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type get_DeclaringType();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public virtual bool get_IsConstructedGenericMethod();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
    public virtual bool Equals(object obj);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual int GetHashCode();
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int size);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public void SetParameters(Type[] parameterTypes);
    public void SetReturnType(Type returnType);
    public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public virtual string ToString();
}
public class System.Reflection.Emit.ModuleBuilder : Module {
    public Assembly Assembly { get; }
    public string FullyQualifiedName { get; }
    public string Name { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual string get_Name();
    public void CreateGlobalFunctions();
    public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public TypeBuilder DefineType(string name);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    public virtual bool Equals(object obj);
    public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public virtual int GetHashCode();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
[IsReadOnlyAttribute]
public class System.Reflection.Emit.OpCode : ValueType {
    private object _dummy;
    public FlowControl FlowControl { get; }
    public string Name { get; }
    public OpCodeType OpCodeType { get; }
    public OperandType OperandType { get; }
    public int Size { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public short Value { get; }
    public FlowControl get_FlowControl();
    public string get_Name();
    public OpCodeType get_OpCodeType();
    public OperandType get_OperandType();
    public int get_Size();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public short get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCode obj);
    public virtual int GetHashCode();
    public static bool op_Equality(OpCode a, OpCode b);
    public static bool op_Inequality(OpCode a, OpCode b);
    public virtual string ToString();
}
public class System.Reflection.Emit.OpCodes : object {
    public static OpCode Add;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode And;
    public static OpCode Arglist;
    public static OpCode Beq;
    public static OpCode Beq_S;
    public static OpCode Bge;
    public static OpCode Bge_S;
    public static OpCode Bge_Un;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt;
    public static OpCode Bgt_S;
    public static OpCode Bgt_Un;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble;
    public static OpCode Ble_S;
    public static OpCode Ble_Un;
    public static OpCode Ble_Un_S;
    public static OpCode Blt;
    public static OpCode Blt_S;
    public static OpCode Blt_Un;
    public static OpCode Blt_Un_S;
    public static OpCode Bne_Un;
    public static OpCode Bne_Un_S;
    public static OpCode Box;
    public static OpCode Br;
    public static OpCode Break;
    public static OpCode Brfalse;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue;
    public static OpCode Brtrue_S;
    public static OpCode Br_S;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Callvirt;
    public static OpCode Castclass;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Ckfinite;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Constrained;
    public static OpCode Conv_I;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_R_Un;
    public static OpCode Conv_U;
    public static OpCode Conv_U1;
    public static OpCode Conv_U2;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Cpblk;
    public static OpCode Cpobj;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Dup;
    public static OpCode Endfilter;
    public static OpCode Endfinally;
    public static OpCode Initblk;
    public static OpCode Initobj;
    public static OpCode Isinst;
    public static OpCode Jmp;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Ldarga_S;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Ldelem;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_U4;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Ldftn;
    public static OpCode Ldind_I;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_U4;
    public static OpCode Ldlen;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Ldloca_S;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Ldloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldobj;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Ldstr;
    public static OpCode Ldtoken;
    public static OpCode Ldvirtftn;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Localloc;
    public static OpCode Mkrefany;
    public static OpCode Mul;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Neg;
    public static OpCode Newarr;
    public static OpCode Newobj;
    public static OpCode Nop;
    public static OpCode Not;
    public static OpCode Or;
    public static OpCode Pop;
    public static OpCode Prefix1;
    public static OpCode Prefix2;
    public static OpCode Prefix3;
    public static OpCode Prefix4;
    public static OpCode Prefix5;
    public static OpCode Prefix6;
    public static OpCode Prefix7;
    public static OpCode Prefixref;
    public static OpCode Readonly;
    public static OpCode Refanytype;
    public static OpCode Refanyval;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode Ret;
    public static OpCode Rethrow;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Sizeof;
    public static OpCode Starg;
    public static OpCode Starg_S;
    public static OpCode Stelem;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Stfld;
    public static OpCode Stind_I;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Stind_Ref;
    public static OpCode Stloc;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Stloc_S;
    public static OpCode Stobj;
    public static OpCode Stsfld;
    public static OpCode Sub;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Switch;
    public static OpCode Tailcall;
    public static OpCode Throw;
    public static OpCode Unaligned;
    public static OpCode Unbox;
    public static OpCode Unbox_Any;
    public static OpCode Volatile;
    public static OpCode Xor;
    public static bool TakesSingleByteArgument(OpCode inst);
}
public enum System.Reflection.Emit.OpCodeType : Enum {
    public int value__;
    [ObsoleteAttribute("This API has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")]
public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
public enum System.Reflection.Emit.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    [ObsoleteAttribute("This API has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")]
public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
}
public enum System.Reflection.Emit.PackingSize : Enum {
    public int value__;
    public static PackingSize Size1;
    public static PackingSize Size128;
    public static PackingSize Size16;
    public static PackingSize Size2;
    public static PackingSize Size32;
    public static PackingSize Size4;
    public static PackingSize Size64;
    public static PackingSize Size8;
    public static PackingSize Unspecified;
}
public class System.Reflection.Emit.ParameterBuilder : object {
    public int Attributes { get; }
    public bool IsIn { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public string Name { get; }
    public int Position { get; }
    public virtual int get_Attributes();
    public bool get_IsIn();
    public bool get_IsOptional();
    public bool get_IsOut();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
public class System.Reflection.Emit.PropertyBuilder : PropertyInfo {
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Type get_DeclaringType();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual Type get_ReflectedType();
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetGetMethod(MethodBuilder mdBuilder);
    public void SetSetMethod(MethodBuilder mdBuilder);
    public virtual void SetValue(object obj, object value, Object[] index);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
}
public class System.Reflection.Emit.SignatureHelper : object {
    public void AddArgument(Type clsArgument);
    public void AddArgument(Type argument, bool pinned);
    public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public void AddSentinel();
    public virtual bool Equals(object obj);
    public static SignatureHelper GetFieldSigHelper(Module mod);
    public virtual int GetHashCode();
    public static SignatureHelper GetLocalVarSigHelper();
    public static SignatureHelper GetLocalVarSigHelper(Module mod);
    public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
    public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public Byte[] GetSignature();
    public virtual string ToString();
}
public enum System.Reflection.Emit.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_pop1;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
}
public class System.Reflection.Emit.TypeBuilder : Type {
    public static int UnspecifiedTypeSize;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Guid GUID { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSZArray { get; }
    public bool IsTypeDefinition { get; }
    public bool IsVariableBoundArray { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public PackingSize PackingSize { get; }
    public Type ReflectedType { get; }
    public int Size { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Guid get_GUID();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsVariableBoundArray();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public PackingSize get_PackingSize();
    public virtual Type get_ReflectedType();
    public int get_Size();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    public void AddInterfaceImplementation(Type interfaceType);
    public Type CreateType();
    public TypeInfo CreateTypeInfo();
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
    public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
    public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
    public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    public TypeBuilder DefineNestedType(string name);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public ConstructorBuilder DefineTypeInitializer();
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public static FieldInfo GetField(Type type, FieldInfo field);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public static MethodInfo GetMethod(Type type, MethodInfo method);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    public virtual bool IsAssignableFrom(Type c);
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    public bool IsCreated();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual bool IsSubclassOf(Type c);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetParent(Type parent);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes ReservedMask;
    public static EventAttributes RTSpecialName;
    public static EventAttributes SpecialName;
}
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MethodInfo AddMethod { get; }
    public EventAttributes Attributes { get; }
    public Type EventHandlerType { get; }
    public bool IsMulticast { get; }
    public bool IsSpecialName { get; }
    public MemberTypes MemberType { get; }
    public MethodInfo RaiseMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public virtual MethodInfo get_AddMethod();
    public abstract virtual EventAttributes get_Attributes();
    public virtual Type get_EventHandlerType();
    public virtual bool get_IsMulticast();
    public bool get_IsSpecialName();
    public virtual MemberTypes get_MemberType();
    public virtual MethodInfo get_RaiseMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual void AddEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public MethodInfo GetAddMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual int GetHashCode();
    public MethodInfo[] GetOtherMethods();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public MethodInfo GetRemoveMethod();
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
    public virtual void RemoveEventHandler(object target, Delegate handler);
}
public class System.Reflection.ExceptionHandlingClause : object {
    public Type CatchType { get; }
    public int FilterOffset { get; }
    public ExceptionHandlingClauseOptions Flags { get; }
    public int HandlerLength { get; }
    public int HandlerOffset { get; }
    public int TryLength { get; }
    public int TryOffset { get; }
    public virtual Type get_CatchType();
    public virtual int get_FilterOffset();
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_HandlerLength();
    public virtual int get_HandlerOffset();
    public virtual int get_TryLength();
    public virtual int get_TryOffset();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Fault;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes Assembly;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes Private;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Public;
    public static FieldAttributes ReservedMask;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes SpecialName;
    public static FieldAttributes Static;
}
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public FieldAttributes Attributes { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public MemberTypes MemberType { get; }
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public abstract virtual Type get_FieldType();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public bool get_IsNotSerialized();
    public bool get_IsPinvokeImpl();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public virtual MemberTypes get_MemberType();
    public virtual bool Equals(object obj);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    public virtual int GetHashCode();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual object GetRawConstantValue();
    public virtual Type[] GetRequiredCustomModifiers();
    public abstract virtual object GetValue(object obj);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes DefaultConstructorConstraint;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes VarianceMask;
}
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
}
public class System.Reflection.InterfaceMapping : ValueType {
    public MethodInfo[] InterfaceMethods;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public Type TargetType;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
}
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual Type get_UnderlyingSystemType();
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
}
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
public class System.Reflection.LocalVariableInfo : object {
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
    public virtual string ToString();
}
public class System.Reflection.ManifestResourceInfo : object {
    public string FileName { get; }
    public Assembly ReferencedAssembly { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    public virtual string get_FileName();
    public virtual Assembly get_ReferencedAssembly();
    public virtual ResourceLocation get_ResourceLocation();
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.MemberInfo : object {
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReflectedType();
    public virtual bool Equals(object obj);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int GetHashCode();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public static bool op_Equality(MemberInfo left, MemberInfo right);
    public static bool op_Inequality(MemberInfo left, MemberInfo right);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes All;
    public static MemberTypes Constructor;
    public static MemberTypes Custom;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes NestedType;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes Abstract;
    public static MethodAttributes Assembly;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Final;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes HideBySig;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes NewSlot;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes Private;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Public;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes SpecialName;
    public static MethodAttributes Static;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes Virtual;
    public static MethodAttributes VtableLayoutMask;
}
public abstract class System.Reflection.MethodBase : MemberInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsConstructor { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsHideBySig { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public abstract virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public bool get_IsAbstract();
    public bool get_IsAssembly();
    public virtual bool get_IsConstructedGenericMethod();
    public bool get_IsConstructor();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsFinal();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public bool get_IsHideBySig();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public virtual bool Equals(object obj);
    public static MethodBase GetCurrentMethod();
    public virtual Type[] GetGenericArguments();
    public virtual int GetHashCode();
    public virtual MethodBody GetMethodBody();
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual ParameterInfo[] GetParameters();
    public object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
}
public class System.Reflection.MethodBody : object {
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public bool InitLocals { get; }
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
    public virtual bool get_InitLocals();
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual Byte[] GetILAsByteArray();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes MaxMethodImplVal;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes Unmanaged;
}
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual bool Equals(object obj);
    public abstract virtual MethodInfo GetBaseDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual int GetHashCode();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public static bool op_Equality(MethodInfo left, MethodInfo right);
    public static bool op_Inequality(MethodInfo left, MethodInfo right);
}
public class System.Reflection.Missing : object {
    public static Missing Value;
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    public Assembly Assembly { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public int MetadataToken { get; }
    public ModuleHandle ModuleHandle { get; }
    public Guid ModuleVersionId { get; }
    public string Name { get; }
    public string ScopeName { get; }
    public virtual Assembly get_Assembly();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual string get_FullyQualifiedName();
    public virtual int get_MDStreamVersion();
    public virtual int get_MetadataToken();
    public ModuleHandle get_ModuleHandle();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_Name();
    public virtual string get_ScopeName();
    public virtual bool Equals(object o);
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual int GetHashCode();
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, Type[] types);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsResource();
    public static bool op_Equality(Module left, Module right);
    public static bool op_Inequality(Module left, Module right);
    public FieldInfo ResolveField(int metadataToken);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MemberInfo ResolveMember(int metadataToken);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MethodBase ResolveMethod(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ToString();
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    public bool get_AssemblyIsPrivate();
    public bool get_StripAfterObfuscation();
    public void set_StripAfterObfuscation(bool value);
}
[AttributeUsageAttribute("8157")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    public bool ApplyToMembers { get; public set; }
    public bool Exclude { get; public set; }
    public string Feature { get; public set; }
    public bool StripAfterObfuscation { get; public set; }
    public bool get_ApplyToMembers();
    public void set_ApplyToMembers(bool value);
    public bool get_Exclude();
    public void set_Exclude(bool value);
    public string get_Feature();
    public void set_Feature(string value);
    public bool get_StripAfterObfuscation();
    public void set_StripAfterObfuscation(bool value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes In;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes None;
    public static ParameterAttributes Optional;
    public static ParameterAttributes Out;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
    public static ParameterAttributes Retval;
}
public class System.Reflection.ParameterInfo : object {
    protected ParameterAttributes AttrsImpl;
    protected Type ClassImpl;
    protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    protected string NameImpl;
    protected int PositionImpl;
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public object DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    public MemberInfo Member { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public object RawDefaultValue { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual object get_DefaultValue();
    public virtual bool get_HasDefaultValue();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    public virtual MemberInfo get_Member();
    public virtual int get_MetadataToken();
    public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public virtual object get_RawDefaultValue();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual object GetRealObject(StreamingContext context);
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Reflection.ParameterModifier : ValueType {
    private object _dummy;
    public bool Item { get; public set; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    public static object Box(Void* ptr, Type type);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static Void* Unbox(object ptr);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Preferred32Bit;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds Unmanaged32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture X86;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes None;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes SpecialName;
}
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public bool IsSpecialName { get; }
    public MemberTypes MemberType { get; }
    public Type PropertyType { get; }
    public MethodInfo SetMethod { get; }
    public abstract virtual PropertyAttributes get_Attributes();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public virtual MethodInfo get_GetMethod();
    public bool get_IsSpecialName();
    public virtual MemberTypes get_MemberType();
    public abstract virtual Type get_PropertyType();
    public virtual MethodInfo get_SetMethod();
    public virtual bool Equals(object obj);
    public MethodInfo[] GetAccessors();
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual object GetConstantValue();
    public MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual int GetHashCode();
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual object GetRawConstantValue();
    public virtual Type[] GetRequiredCustomModifiers();
    public MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public object GetValue(object obj);
    public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
    public void SetValue(object obj, object value);
    public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
}
public abstract class System.Reflection.ReflectionContext : object {
    public virtual TypeInfo GetTypeForObject(object value);
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
}
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    public Exception[] LoaderExceptions { get; }
    public Type[] Types { get; }
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    public Exception[] get_LoaderExceptions();
    public Type[] get_Types();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Private;
    public static ResourceAttributes Public;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
    public static ResourceLocation Embedded;
}
[ExtensionAttribute]
public static class System.Reflection.RuntimeReflectionExtensions : object {
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate del);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeBaseDefinition(MethodInfo method);
    [ExtensionAttribute]
public static EventInfo GetRuntimeEvent(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetRuntimeEvents(Type type);
    [ExtensionAttribute]
public static FieldInfo GetRuntimeField(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetRuntimeFields(Type type);
    [ExtensionAttribute]
public static InterfaceMapping GetRuntimeInterfaceMap(TypeInfo typeInfo, Type interfaceType);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type type, string name, Type[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type type, string name);
}
public class System.Reflection.StrongNameKeyPair : object {
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(Byte[] keyPairArray);
    public StrongNameKeyPair(FileStream keyPairFile);
    protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    public StrongNameKeyPair(string keyPairContainer);
    public Byte[] get_PublicKey();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.TargetException : ApplicationException {
    protected TargetException(SerializationInfo info, StreamingContext context);
    public TargetException(string message);
    public TargetException(string message, Exception inner);
}
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
}
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes Abstract;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes Class;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes Import;
    public static TypeAttributes Interface;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes ReservedMask;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes Sealed;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes Serializable;
    public static TypeAttributes SpecialName;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes WindowsRuntime;
}
public class System.Reflection.TypeDelegator : TypeInfo {
    protected Type typeImpl;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsSZArray { get; }
    public bool IsTypeDefinition { get; }
    public bool IsVariableBoundArray { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsVariableBoundArray();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.TypeInfo : Type {
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual Type[] get_GenericTypeParameters();
    public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    public virtual Type AsType();
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
}
public class System.ResolveEventArgs : EventArgs {
    public string Name { get; }
    public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    public string get_Name();
    public Assembly get_RequestingAssembly();
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
}
public interface System.Resources.IResourceWriter {
    public abstract virtual void AddResource(string name, Byte[] value);
    public abstract virtual void AddResource(string name, object value);
    public abstract virtual void AddResource(string name, string value);
    public abstract virtual void Close();
    public abstract virtual void Generate();
}
public class System.Resources.MissingManifestResourceException : SystemException {
    protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
}
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    public string CultureName { get; }
    protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public string get_CultureName();
}
[AttributeUsageAttribute("1")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    public string get_CultureName();
    public UltimateResourceFallbackLocation get_Location();
}
public class System.Resources.ResourceManager : object {
    public static int HeaderVersionNumber;
    public static int MagicNumber;
    protected Assembly MainAssembly;
    public string BaseName { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    public bool IgnoreCase { get; public set; }
    public Type ResourceSetType { get; }
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    public virtual string get_BaseName();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, CultureInfo culture);
    protected virtual string GetResourceFileName(CultureInfo culture);
    public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    protected static Version GetSatelliteContractVersion(Assembly a);
    public UnmanagedMemoryStream GetStream(string name);
    public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
    public virtual string GetString(string name);
    public virtual string GetString(string name, CultureInfo culture);
    protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    public virtual void ReleaseAllResources();
}
public class System.Resources.ResourceReader : object {
    public ResourceReader(Stream stream);
    public ResourceReader(string fileName);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Resources.ResourceSet : object {
    public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    public ResourceSet(string fileName);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    protected virtual void ReadResources();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Resources.ResourceWriter : object {
    public Func`2<Type, string> TypeNameConverter { get; public set; }
    public ResourceWriter(Stream stream);
    public ResourceWriter(string fileName);
    public Func`2<Type, string> get_TypeNameConverter();
    public void set_TypeNameConverter(Func`2<Type, string> value);
    public sealed virtual void AddResource(string name, Byte[] value);
    public void AddResource(string name, Stream value);
    public void AddResource(string name, Stream value, bool closeAfterWrite);
    public sealed virtual void AddResource(string name, object value);
    public sealed virtual void AddResource(string name, string value);
    public void AddResourceData(string name, string typeName, Byte[] serializedData);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    public sealed virtual void Generate();
}
[AttributeUsageAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    public string get_Version();
}
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
public class System.Runtime.AmbiguousImplementationException : Exception {
    public AmbiguousImplementationException(string message);
    public AmbiguousImplementationException(string message, Exception innerException);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.AssemblyTargetedPatchBandAttribute : Attribute {
    public string TargetedPatchBand { get; }
    public AssemblyTargetedPatchBandAttribute(string targetedPatchBand);
    public string get_TargetedPatchBand();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    public string get_PropertyName();
}
public class System.Runtime.CompilerServices.AsyncIteratorMethodBuilder : ValueType {
    private object _dummy;
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void Complete();
    public static AsyncIteratorMethodBuilder Create();
    public void MoveNext(TStateMachine& stateMachine);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute : StateMachineAttribute {
    public AsyncIteratorStateMachineAttribute(Type stateMachineType);
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    public Type get_BuilderType();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private object _dummy;
    public Task Task { get; }
    public Task get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncTaskMethodBuilder Create();
    public void SetException(Exception exception);
    public void SetResult();
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    private object _dummy;
    public Task`1<TResult> Task { get; }
    public Task`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    public void SetException(Exception exception);
    public void SetResult(TResult result);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ValueTask Task { get; }
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncValueTaskMethodBuilder Create();
    public void SetException(Exception exception);
    public void SetResult();
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    private TResult _result;
    private object _dummy;
    private int _dummyPrimitive;
    public ValueTask`1<TResult> Task { get; }
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void SetException(Exception exception);
    public void SetResult(TResult result);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private object _dummy;
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncVoidMethodBuilder Create();
    public void SetException(Exception exception);
    public void SetResult();
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.CallConvCdecl : object {
}
public class System.Runtime.CompilerServices.CallConvFastcall : object {
}
public class System.Runtime.CompilerServices.CallConvStdcall : object {
}
public class System.Runtime.CompilerServices.CallConvThiscall : object {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
public class System.Runtime.CompilerServices.CallSite : object {
    public CallSiteBinder Binder { get; }
    public CallSiteBinder get_Binder();
    public static CallSite Create(Type delegateType, CallSiteBinder binder);
}
public class System.Runtime.CompilerServices.CallSite`1 : CallSite {
    public T Target;
    public T Update { get; }
    public T get_Update();
    public static CallSite`1<T> Create(CallSiteBinder binder);
}
public abstract class System.Runtime.CompilerServices.CallSiteBinder : object {
    public static LabelTarget UpdateLabel { get; }
    public static LabelTarget get_UpdateLabel();
    public abstract virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public virtual T BindDelegate(CallSite`1<T> site, Object[] args);
    protected void CacheTarget(T target);
}
public static class System.Runtime.CompilerServices.CallSiteHelpers : object {
    public static bool IsInternalFrame(MethodBase mb);
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.CompilerMarshalOverride : object {
}
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    public void Add(TKey key, TValue value);
    public void AddOrUpdate(TKey key, TValue value);
    public void Clear();
    public TValue GetOrCreateValue(TKey key);
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public bool Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool TryGetValue(TKey key, TValue& value);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredAsyncDisposable : ValueType {
    private object _dummy;
    public ConfiguredValueTaskAwaitable DisposeAsync();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1 : ValueType {
    private object _dummy;
    public ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(bool continueOnCapturedContext);
    public Enumerator<T> GetAsyncEnumerator();
    public ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private object _dummy;
    public ConfiguredTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private object _dummy;
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private object _dummy;
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private object _dummy;
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
public static class System.Runtime.CompilerServices.ContractHelper : object {
    public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
}
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
public abstract class System.Runtime.CompilerServices.DebugInfoGenerator : object {
    public static DebugInfoGenerator CreatePdbGenerator();
    public abstract virtual void MarkSequencePoint(LambdaExpression method, int ilOffset, DebugInfoExpression sequencePoint);
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    public decimal Value { get; }
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public decimal get_Value();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    public string get_DependentAssembly();
    public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("10636")]
public class System.Runtime.CompilerServices.DynamicAttribute : Attribute {
    public IList`1<bool> TransformFlags { get; }
    public DynamicAttribute(Boolean[] transformFlags);
    public IList`1<bool> get_TransformFlags();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.EnumeratorCancellationAttribute : Attribute {
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    public Type get_ElementType();
    public int get_Length();
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    public static FormattableString Create(string format, Object[] arguments);
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.HasCopySemanticsAttribute : Attribute {
}
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
}
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    public bool AllInternalsVisible { get; public set; }
    public string AssemblyName { get; }
    public InternalsVisibleToAttribute(string assemblyName);
    public bool get_AllInternalsVisible();
    public void set_AllInternalsVisible(bool value);
    public string get_AssemblyName();
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.IRuntimeVariables {
    public int Count { get; }
    public object Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
}
public static class System.Runtime.CompilerServices.IsBoxed : object {
}
[AttributeUsageAttribute("8")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsByValue : object {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
public static class System.Runtime.CompilerServices.IsCopyConstructed : object {
}
public static class System.Runtime.CompilerServices.IsExplicitlyDereferenced : object {
}
public static class System.Runtime.CompilerServices.IsImplicitlyDereferenced : object {
}
public static class System.Runtime.CompilerServices.IsJitIntrinsic : object {
}
public static class System.Runtime.CompilerServices.IsLong : object {
}
public static class System.Runtime.CompilerServices.IsPinned : object {
}
[AttributeUsageAttribute("32767")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsSignUnspecifiedByte : object {
}
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public static class System.Runtime.CompilerServices.IsUdtReturn : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public object Item { get; }
    public int Length { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual int get_Length();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.IUnknownConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public virtual object get_Value();
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Always;
    public static LoadHint Default;
    public static LoadHint Sometimes;
}
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    public MethodCodeType MethodCodeType;
    public MethodImplOptions Value { get; }
    public MethodImplAttribute(short value);
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions InternalCall;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions Unmanaged;
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.NativeCppClassAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
public class System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1 : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollectionBuilder`1(IEnumerable`1<T> collection);
    public ReadOnlyCollectionBuilder`1(int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public void Reverse();
    public void Reverse(int index, int count);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public T[] ToArray();
    public ReadOnlyCollection`1<T> ToReadOnlyCollection();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("1052")]
public class System.Runtime.CompilerServices.RequiredAttributeAttribute : Attribute {
    public Type RequiredContract { get; }
    public RequiredAttributeAttribute(Type requiredContract);
    public Type get_RequiredContract();
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.RuleCache`1 : object {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    public bool WrapNonExceptionThrows { get; public set; }
    public bool get_WrapNonExceptionThrows();
    public void set_WrapNonExceptionThrows(bool value);
}
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static string DefaultImplementationsOfInterfaces;
    public static string PortablePdb;
    public static bool IsDynamicCodeCompiled { get; }
    public static bool IsDynamicCodeSupported { get; }
    public static bool get_IsDynamicCodeCompiled();
    public static bool get_IsDynamicCodeSupported();
    public static bool IsSupported(string feature);
}
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    public static int OffsetToStringData { get; }
    public static int get_OffsetToStringData();
    public static void EnsureSufficientExecutionStack();
    public static bool Equals(object o1, object o2);
    public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    public static int GetHashCode(object o);
    public static object GetObjectValue(object obj);
    public static T[] GetSubArray(T[] array, Range range);
    public static object GetUninitializedObject(Type type);
    public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    public static bool IsReferenceOrContainsReferences();
    public static void PrepareConstrainedRegions();
    public static void PrepareConstrainedRegionsNoOP();
    public static void PrepareContractedDelegate(Delegate d);
    public static void PrepareDelegate(Delegate d);
    public static void PrepareMethod(RuntimeMethodHandle method);
    public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    public static void ProbeForSufficientStack();
    public static void RunClassConstructor(RuntimeTypeHandle type);
    public static void RunModuleConstructor(ModuleHandle module);
    public static bool TryEnsureSufficientExecutionStack();
}
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    public object WrappedException { get; }
    public RuntimeWrappedException(object thrownObject);
    public object get_WrappedException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("16")]
public class System.Runtime.CompilerServices.ScopelessEnumAttribute : Attribute {
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    public Type get_StateMachineType();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    public T Value;
    private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
public class System.Runtime.CompilerServices.SwitchExpressionException : InvalidOperationException {
    public object UnmatchedValue { get; }
    public SwitchExpressionException(Exception innerException);
    public SwitchExpressionException(object unmatchedValue);
    public SwitchExpressionException(string message);
    public SwitchExpressionException(string message, Exception innerException);
    public object get_UnmatchedValue();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    private object _dummy;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private object _dummy;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public TResult GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("11148")]
[CLSCompliantAttribute("False")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    public Type get_Destination();
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    private object _dummy;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private object _dummy;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public TResult GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer MayFail;
    public static Cer None;
    public static Cer Success;
}
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency MayCorruptProcess;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[AttributeUsageAttribute("96")]
public class System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute : Attribute {
}
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    public Cer Cer { get; }
    public Consistency ConsistencyGuarantee { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    public Cer get_Cer();
    public Consistency get_ConsistencyGuarantee();
}
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    public Exception SourceException { get; }
    public Exception get_SourceException();
    public static ExceptionDispatchInfo Capture(Exception source);
    [DoesNotReturnAttribute]
public void Throw();
    [DoesNotReturnAttribute]
public static void Throw(Exception source);
}
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
    public static GCLargeObjectHeapCompactionMode Default;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode NoGCRegion;
    public static GCLatencyMode SustainedLowLatency;
}
public static class System.Runtime.GCSettings : object {
    public static bool IsServerGC { get; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static GCLatencyMode LatencyMode { get; public set; }
    public static bool get_IsServerGC();
    public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
    public static GCLatencyMode get_LatencyMode();
    public static void set_LatencyMode(GCLatencyMode value);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.AllowReversePInvokeCallsAttribute : Attribute {
}
public enum System.Runtime.InteropServices.Architecture : Enum {
    public int value__;
    public static Architecture Arm;
    public static Architecture Arm64;
    public static Architecture X64;
    public static Architecture X86;
}
public class System.Runtime.InteropServices.ArrayWithOffset : ValueType {
    private object _dummy;
    public ArrayWithOffset(object array, int offset);
    public virtual bool Equals(object obj);
    public bool Equals(ArrayWithOffset obj);
    public object GetArray();
    public virtual int GetHashCode();
    public int GetOffset();
    public static bool op_Equality(ArrayWithOffset a, ArrayWithOffset b);
    public static bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b);
}
[AttributeUsageAttribute("1029")]
public class System.Runtime.InteropServices.AutomationProxyAttribute : Attribute {
    public bool Value { get; }
    public AutomationProxyAttribute(bool val);
    public bool get_Value();
}
[AttributeUsageAttribute("1037")]
public class System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
    public bool ThrowOnUnmappableChar;
    public bool BestFitMapping { get; }
    public BestFitMappingAttribute(bool BestFitMapping);
    public bool get_BestFitMapping();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("BStrWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
public class System.Runtime.InteropServices.BStrWrapper : object {
    public string WrappedObject { get; }
    public BStrWrapper(object value);
    public BStrWrapper(string value);
    public string get_WrappedObject();
}
public enum System.Runtime.InteropServices.CallingConvention : Enum {
    public int value__;
    public static CallingConvention Cdecl;
    public static CallingConvention FastCall;
    public static CallingConvention StdCall;
    public static CallingConvention ThisCall;
    public static CallingConvention Winapi;
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet Ansi;
    public static CharSet Auto;
    public static CharSet None;
    public static CharSet Unicode;
}
[AttributeUsageAttribute("5")]
public class System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
    public ClassInterfaceType Value { get; }
    public ClassInterfaceAttribute(short classInterfaceType);
    public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
    public ClassInterfaceType get_Value();
}
public enum System.Runtime.InteropServices.ClassInterfaceType : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
public static ClassInterfaceType AutoDispatch;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
public static ClassInterfaceType AutoDual;
    public static ClassInterfaceType None;
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.CoClassAttribute : Attribute {
    public Type CoClass { get; }
    public CoClassAttribute(Type coClass);
    public Type get_CoClass();
}
[AttributeUsageAttribute("10624")]
public class System.Runtime.InteropServices.ComAliasNameAttribute : Attribute {
    public string Value { get; }
    public ComAliasNameAttribute(string alias);
    public string get_Value();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ComAwareEventInfo may be unavailable in future releases.")]
public class System.Runtime.InteropServices.ComAwareEventInfo : EventInfo {
    public EventAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ComAwareEventInfo(Type type, string eventName);
    public virtual EventAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual void AddEventHandler(object target, Delegate handler);
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual void RemoveEventHandler(object target, Delegate handler);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.InteropServices.ComCompatibleVersionAttribute : Attribute {
    public int BuildNumber { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int RevisionNumber { get; }
    public ComCompatibleVersionAttribute(int major, int minor, int build, int revision);
    public int get_BuildNumber();
    public int get_MajorVersion();
    public int get_MinorVersion();
    public int get_RevisionNumber();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.InteropServices.ComConversionLossAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
    public Type Value { get; }
    public ComDefaultInterfaceAttribute(Type defaultInterface);
    public Type get_Value();
}
[AttributeUsageAttribute("1024")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ComEventInterfaceAttribute may be unavailable in future releases.")]
public class System.Runtime.InteropServices.ComEventInterfaceAttribute : Attribute {
    public Type EventProvider { get; }
    public Type SourceInterface { get; }
    public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider);
    public Type get_EventProvider();
    public Type get_SourceInterface();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ComEventsHelper may be unavailable in future releases.")]
public static class System.Runtime.InteropServices.ComEventsHelper : object {
    public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
    public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
}
public class System.Runtime.InteropServices.COMException : ExternalException {
    protected COMException(SerializationInfo info, StreamingContext context);
    public COMException(string message);
    public COMException(string message, Exception inner);
    public COMException(string message, int errorCode);
    public virtual string ToString();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.ComImportAttribute : Attribute {
}
public enum System.Runtime.InteropServices.ComInterfaceType : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
public static ComInterfaceType InterfaceIsDual;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
public static ComInterfaceType InterfaceIsIDispatch;
    public static ComInterfaceType InterfaceIsIInspectable;
    public static ComInterfaceType InterfaceIsIUnknown;
}
public enum System.Runtime.InteropServices.ComMemberType : Enum {
    public int value__;
    public static ComMemberType Method;
    public static ComMemberType PropGet;
    public static ComMemberType PropSet;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.ComRegisterFunctionAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ComSourceInterfacesAttribute may be unavailable in future releases.")]
public class System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
    public string Value { get; }
    public ComSourceInterfacesAttribute(string sourceInterfaces);
    public ComSourceInterfacesAttribute(Type sourceInterface);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
    public string get_Value();
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.ADVF : Enum {
    public int value__;
    public static ADVF ADVFCACHE_FORCEBUILTIN;
    public static ADVF ADVFCACHE_NOHANDLER;
    public static ADVF ADVFCACHE_ONSAVE;
    public static ADVF ADVF_DATAONSTOP;
    public static ADVF ADVF_NODATA;
    public static ADVF ADVF_ONLYONCE;
    public static ADVF ADVF_PRIMEFIRST;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
    public int cbStruct;
    public int dwTickCountDeadline;
    public int grfFlags;
    public int grfMode;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lptcomp;
    public IntPtr lpvardesc;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_MAX;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_SYSCALL;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
    public int dwCookie;
    public object pUnk;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.DATADIR : Enum {
    public int value__;
    public static DATADIR DATADIR_GET;
    public static DATADIR DATADIR_SET;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_VARDESC;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
    public int cArgs;
    public int cNamedArgs;
    public IntPtr rgdispidNamedArgs;
    public IntPtr rgvarg;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.DVASPECT : Enum {
    public int value__;
    public static DVASPECT DVASPECT_CONTENT;
    public static DVASPECT DVASPECT_DOCPRINT;
    public static DVASPECT DVASPECT_ICON;
    public static DVASPECT DVASPECT_THUMBNAIL;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
    public DESCUNION desc;
    public TYPEDESC tdesc;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
    public string bstrDescription;
    public string bstrHelpFile;
    public string bstrSource;
    public int dwHelpContext;
    public IntPtr pfnDeferredFillIn;
    public IntPtr pvReserved;
    public int scode;
    public short wCode;
    public short wReserved;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
    public int dwHighDateTime;
    public int dwLowDateTime;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.FORMATETC : ValueType {
    public short cfFormat;
    public DVASPECT dwAspect;
    public int lindex;
    public IntPtr ptd;
    public TYMED tymed;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public IntPtr lprgelemdescParam;
    public IntPtr lprgscode;
    public int memid;
    public short oVft;
    public short wFuncFlags;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_DISPATCH;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_VIRTUAL;
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IAdviseSink {
    public abstract virtual void OnClose();
    public abstract virtual void OnDataChange(FORMATETC& format, STGMEDIUM& stgmedium);
    public abstract virtual void OnRename(IMoniker moniker);
    public abstract virtual void OnSave();
    public abstract virtual void OnViewChange(int aspect, int index);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IBindCtx {
    public abstract virtual void EnumObjectParam(IEnumString& ppenum);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    public abstract virtual void GetRunningObjectTable(IRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual int RevokeObjectParam(string pszKey);
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPoint {
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void EnumConnections(IEnumConnections& ppEnum);
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(IConnectionPointContainer& ppCPC);
    public abstract virtual void Unadvise(int dwCookie);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(IEnumConnectionPoints& ppEnum);
    public abstract virtual void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP);
}
public interface System.Runtime.InteropServices.ComTypes.IDataObject {
    public abstract virtual int DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink adviseSink, Int32& connection);
    public abstract virtual void DUnadvise(int connection);
    public abstract virtual int EnumDAdvise(IEnumSTATDATA& enumAdvise);
    public abstract virtual IEnumFORMATETC EnumFormatEtc(DATADIR direction);
    public abstract virtual int GetCanonicalFormatEtc(FORMATETC& formatIn, FORMATETC& formatOut);
    public abstract virtual void GetData(FORMATETC& format, STGMEDIUM& medium);
    public abstract virtual void GetDataHere(FORMATETC& format, STGMEDIUM& medium);
    public abstract virtual int QueryGetData(FORMATETC& format);
    public abstract virtual void SetData(FORMATETC& formatIn, STGMEDIUM& medium, bool release);
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
    public IntPtr dwReserved;
    public IDLFLAG wIDLFlags;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FRETVAL;
    public static IDLFLAG IDLFLAG_NONE;
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
    public abstract virtual void Clone(IEnumConnectionPoints& ppenum);
    public abstract virtual int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
    public abstract virtual void Reset();
    public abstract virtual int Skip(int celt);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnections {
    public abstract virtual void Clone(IEnumConnections& ppenum);
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
    public abstract virtual void Reset();
    public abstract virtual int Skip(int celt);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumFORMATETC {
    public abstract virtual void Clone(IEnumFORMATETC& newEnum);
    public abstract virtual int Next(int celt, FORMATETC[] rgelt, Int32[] pceltFetched);
    public abstract virtual int Reset();
    public abstract virtual int Skip(int celt);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumMoniker {
    public abstract virtual void Clone(IEnumMoniker& ppenum);
    public abstract virtual int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
    public abstract virtual void Reset();
    public abstract virtual int Skip(int celt);
}
public interface System.Runtime.InteropServices.ComTypes.IEnumSTATDATA {
    public abstract virtual void Clone(IEnumSTATDATA& newEnum);
    public abstract virtual int Next(int celt, STATDATA[] rgelt, Int32[] pceltFetched);
    public abstract virtual int Reset();
    public abstract virtual int Skip(int celt);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumString {
    public abstract virtual void Clone(IEnumString& ppenum);
    public abstract virtual int Next(int celt, String[] rgelt, IntPtr pceltFetched);
    public abstract virtual void Reset();
    public abstract virtual int Skip(int celt);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
    public abstract virtual IEnumVARIANT Clone();
    public abstract virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public abstract virtual int Reset();
    public abstract virtual int Skip(int celt);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IMoniker {
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Hash(Int32& pdwHash);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual int IsDirty();
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual int IsSystemMoniker(Int32& pdwMksys);
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual void GetCurFile(String& ppszFileName);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
    public abstract virtual void EnumRunning(IEnumMoniker& ppenumMoniker);
    public abstract virtual int GetObject(IMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual int IsRunning(IMoniker pmkObjectName);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
    public abstract virtual void Revoke(int dwRegister);
}
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IStream {
    public abstract virtual void Clone(IStream& ppstm);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Revert();
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo {
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetAllFuncCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllImplTypeCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
    public abstract virtual void GetAllVarCustData(int index, IntPtr pCustData);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetFuncCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetTypeFlags(Int32& pTypeFlags);
    public abstract virtual void GetTypeKind(TYPEKIND& pTypeKind);
    public abstract virtual void GetVarCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetVarIndexOfMemId(int memid, Int32& pVarIndex);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib {
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib2 {
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_NONE;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.STATDATA : ValueType {
    public ADVF advf;
    public IAdviseSink advSink;
    public int connection;
    public FORMATETC formatetc;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
    public FILETIME atime;
    public long cbSize;
    public Guid clsid;
    public FILETIME ctime;
    public int grfLocksSupported;
    public int grfMode;
    public int grfStateBits;
    public FILETIME mtime;
    public string pwcsName;
    public int reserved;
    public int type;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.STGMEDIUM : ValueType {
    public object pUnkForRelease;
    public TYMED tymed;
    public IntPtr unionmember;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_MAC;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_WIN64;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYMED : Enum {
    public int value__;
    public static TYMED TYMED_ENHMF;
    public static TYMED TYMED_FILE;
    public static TYMED TYMED_GDI;
    public static TYMED TYMED_HGLOBAL;
    public static TYMED TYMED_ISTORAGE;
    public static TYMED TYMED_ISTREAM;
    public static TYMED TYMED_MFPICT;
    public static TYMED TYMED_NULL;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
    public short cbAlignment;
    public int cbSizeInstance;
    public short cbSizeVft;
    public short cFuncs;
    public short cImplTypes;
    public short cVars;
    public int dwReserved;
    public Guid guid;
    public IDLDESC idldescType;
    public int lcid;
    public IntPtr lpstrSchema;
    public static int MEMBER_ID_NIL;
    public int memidConstructor;
    public int memidDestructor;
    public TYPEDESC tdescAlias;
    public TYPEKIND typekind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEFLAGS wTypeFlags;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_MAX;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_UNION;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public LIBFLAGS wLibFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
    public DESCUNION desc;
    public ELEMDESC elemdescVar;
    public string lpstrSchema;
    public int memid;
    public VARKIND varkind;
    public short wVarFlags;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
    public int value__;
    public static VARKIND VAR_CONST;
    public static VARKIND VAR_DISPATCH;
    public static VARKIND VAR_PERINSTANCE;
    public static VARKIND VAR_STATIC;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.ComUnregisterFunctionAttribute : Attribute {
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    public bool get_Value();
}
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected CriticalHandle(IntPtr invalidHandleValue);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected abstract virtual bool ReleaseHandle();
    protected void SetHandle(IntPtr handle);
    public void SetHandleAsInvalid();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("CurrencyWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
public class System.Runtime.InteropServices.CurrencyWrapper : object {
    public decimal WrappedObject { get; }
    public CurrencyWrapper(decimal obj);
    public CurrencyWrapper(object obj);
    public decimal get_WrappedObject();
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
    public int value__;
    public static CustomQueryInterfaceMode Allow;
    public static CustomQueryInterfaceMode Ignore;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
    public int value__;
    public static CustomQueryInterfaceResult Failed;
    public static CustomQueryInterfaceResult Handled;
    public static CustomQueryInterfaceResult NotHandled;
}
[AttributeUsageAttribute("2")]
public class System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
    public CharSet CharSet { get; }
    public DefaultCharSetAttribute(CharSet charSet);
    public CharSet get_CharSet();
}
[AttributeUsageAttribute("65")]
public class System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
    public DllImportSearchPath Paths { get; }
    public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
    public DllImportSearchPath get_Paths();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
    public object Value { get; }
    public DefaultParameterValueAttribute(object value);
    public object get_Value();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("DispatchWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
public class System.Runtime.InteropServices.DispatchWrapper : object {
    public object WrappedObject { get; }
    public DispatchWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("960")]
public class System.Runtime.InteropServices.DispIdAttribute : Attribute {
    public int Value { get; }
    public DispIdAttribute(int dispId);
    public int get_Value();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.DllImportAttribute : Attribute {
    public bool BestFitMapping;
    public CallingConvention CallingConvention;
    public CharSet CharSet;
    public string EntryPoint;
    public bool ExactSpelling;
    public bool PreserveSig;
    public bool SetLastError;
    public bool ThrowOnUnmappableChar;
    public string Value { get; }
    public DllImportAttribute(string dllName);
    public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.DllImportSearchPath : Enum {
    public int value__;
    public static DllImportSearchPath ApplicationDirectory;
    public static DllImportSearchPath AssemblyDirectory;
    public static DllImportSearchPath LegacyBehavior;
    public static DllImportSearchPath SafeDirectories;
    public static DllImportSearchPath System32;
    public static DllImportSearchPath UseDllDirectoryForDependencies;
    public static DllImportSearchPath UserDirectories;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ErrorWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
public class System.Runtime.InteropServices.ErrorWrapper : object {
    public int ErrorCode { get; }
    public ErrorWrapper(Exception e);
    public ErrorWrapper(int errorCode);
    public ErrorWrapper(object errorCode);
    public int get_ErrorCode();
}
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    protected ExternalException(SerializationInfo info, StreamingContext context);
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    public virtual int get_ErrorCode();
    public virtual string ToString();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    public int get_Value();
}
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private int _dummyPrimitive;
    public bool IsAllocated { get; }
    public object Target { get; public set; }
    public bool get_IsAllocated();
    public object get_Target();
    public void set_Target(object value);
    public IntPtr AddrOfPinnedObject();
    public static GCHandle Alloc(object value);
    public static GCHandle Alloc(object value, GCHandleType type);
    public virtual bool Equals(object o);
    public void Free();
    public static GCHandle FromIntPtr(IntPtr value);
    public virtual int GetHashCode();
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static GCHandle op_Explicit(IntPtr value);
    public static IntPtr op_Explicit(GCHandle value);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    public static IntPtr ToIntPtr(GCHandle value);
}
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
}
[AttributeUsageAttribute("5149")]
public class System.Runtime.InteropServices.GuidAttribute : Attribute {
    public string Value { get; }
    public GuidAttribute(string guid);
    public string get_Value();
}
public class System.Runtime.InteropServices.HandleCollector : object {
    public int Count { get; }
    public int InitialThreshold { get; }
    public int MaximumThreshold { get; }
    public string Name { get; }
    public HandleCollector(string name, int initialThreshold);
    public HandleCollector(string name, int initialThreshold, int maximumThreshold);
    public int get_Count();
    public int get_InitialThreshold();
    public int get_MaximumThreshold();
    public string get_Name();
    public void Add();
    public void Remove();
}
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.HandleRef : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public IntPtr Handle { get; }
    public object Wrapper { get; }
    public HandleRef(object wrapper, IntPtr handle);
    public IntPtr get_Handle();
    public object get_Wrapper();
    public static IntPtr op_Explicit(HandleRef value);
    public static IntPtr ToIntPtr(HandleRef value);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ICustomAdapter may be unavailable in future releases.")]
public interface System.Runtime.InteropServices.ICustomAdapter {
    public abstract virtual object GetUnderlyingObject();
}
public interface System.Runtime.InteropServices.ICustomFactory {
    public abstract virtual MarshalByRefObject CreateInstance(Type serverType);
}
public interface System.Runtime.InteropServices.ICustomMarshaler {
    public abstract virtual void CleanUpManagedData(object ManagedObj);
    public abstract virtual void CleanUpNativeData(IntPtr pNativeData);
    public abstract virtual int GetNativeDataSize();
    public abstract virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public abstract virtual object MarshalNativeToManaged(IntPtr pNativeData);
}
[EditorBrowsableAttribute("1")]
public interface System.Runtime.InteropServices.ICustomQueryInterface {
    public abstract virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.InteropServices.ImportedFromTypeLibAttribute : Attribute {
    public string Value { get; }
    public ImportedFromTypeLibAttribute(string tlbFile);
    public string get_Value();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
    public ComInterfaceType Value { get; }
    public InterfaceTypeAttribute(short interfaceType);
    public InterfaceTypeAttribute(ComInterfaceType interfaceType);
    public ComInterfaceType get_Value();
}
public class System.Runtime.InteropServices.InvalidComObjectException : SystemException {
    protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
    public InvalidComObjectException(string message);
    public InvalidComObjectException(string message, Exception inner);
}
public class System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
    protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
    public InvalidOleVariantTypeException(string message);
    public InvalidOleVariantTypeException(string message, Exception inner);
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Auto;
    public static LayoutKind Explicit;
    public static LayoutKind Sequential;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
    public int Value { get; }
    public LCIDConversionAttribute(int lcid);
    public int get_Value();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.ManagedToNativeComInteropStubAttribute : Attribute {
    public Type ClassType { get; }
    public string MethodName { get; }
    public ManagedToNativeComInteropStubAttribute(Type classType, string methodName);
    public Type get_ClassType();
    public string get_MethodName();
}
public static class System.Runtime.InteropServices.Marshal : object {
    public static int SystemDefaultCharSize;
    public static int SystemMaxDBCSCharSize;
    public static int AddRef(IntPtr pUnk);
    public static IntPtr AllocCoTaskMem(int cb);
    public static IntPtr AllocHGlobal(int cb);
    public static IntPtr AllocHGlobal(IntPtr cb);
    public static bool AreComObjectsAvailableForCleanup();
    public static object BindToMoniker(string monikerName);
    public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
    public static void CleanupUnusedObjectsInCurrentContext();
    public static void Copy(Byte[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Char[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Double[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int16[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int32[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int64[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Char[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Double[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int16[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int32[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int64[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Single[] destination, int startIndex, int length);
    public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Single[] source, int startIndex, IntPtr destination, int length);
    [EditorBrowsableAttribute("1")]
public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);
    [EditorBrowsableAttribute("1")]
public static object CreateWrapperOfType(object o, Type t);
    public static TWrapper CreateWrapperOfType(T o);
    [EditorBrowsableAttribute("1")]
public static void DestroyStructure(IntPtr ptr, Type structuretype);
    public static void DestroyStructure(IntPtr ptr);
    public static int FinalReleaseComObject(object o);
    public static void FreeBSTR(IntPtr ptr);
    public static void FreeCoTaskMem(IntPtr ptr);
    public static void FreeHGlobal(IntPtr hglobal);
    public static Guid GenerateGuidForType(Type type);
    public static string GenerateProgIdForType(Type type);
    [EditorBrowsableAttribute("1")]
public static IntPtr GetComInterfaceForObject(object o, Type T);
    [EditorBrowsableAttribute("1")]
public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
    public static IntPtr GetComInterfaceForObject(T o);
    public static object GetComObjectData(object obj, object key);
    [EditorBrowsableAttribute("1")]
public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetExceptionCode() may be unavailable in future releases.")]
public static int GetExceptionCode();
    public static Exception GetExceptionForHR(int errorCode);
    public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
    [EditorBrowsableAttribute("1")]
public static IntPtr GetFunctionPointerForDelegate(Delegate d);
    public static IntPtr GetFunctionPointerForDelegate(TDelegate d);
    public static IntPtr GetHINSTANCE(Module m);
    public static int GetHRForException(Exception e);
    public static int GetHRForLastWin32Error();
    public static IntPtr GetIDispatchForObject(object o);
    public static IntPtr GetIUnknownForObject(object o);
    public static int GetLastWin32Error();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetNativeVariantForObject(Object, IntPtr) may be unavailable in future releases.")]
public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetNativeVariantForObject<T>(T, IntPtr) may be unavailable in future releases.")]
public static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetObjectForNativeVariant(IntPtr) may be unavailable in future releases.")]
public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetObjectForNativeVariant<T>(IntPtr) may be unavailable in future releases.")]
public static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetObjectsForNativeVariants(IntPtr, Int32) may be unavailable in future releases.")]
public static Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetObjectsForNativeVariants<T>(IntPtr, Int32) may be unavailable in future releases.")]
public static T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static int GetStartComSlot(Type t);
    public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
    public static Type GetTypeFromCLSID(Guid clsid);
    public static string GetTypeInfoName(ITypeInfo typeInfo);
    public static object GetUniqueObjectForIUnknown(IntPtr unknown);
    public static bool IsComObject(object o);
    [EditorBrowsableAttribute("1")]
public static IntPtr OffsetOf(Type t, string fieldName);
    public static IntPtr OffsetOf(string fieldName);
    public static void Prelink(MethodInfo m);
    public static void PrelinkAll(Type c);
    public static string PtrToStringAnsi(IntPtr ptr);
    public static string PtrToStringAnsi(IntPtr ptr, int len);
    public static string PtrToStringAuto(IntPtr ptr);
    public static string PtrToStringAuto(IntPtr ptr, int len);
    public static string PtrToStringBSTR(IntPtr ptr);
    public static string PtrToStringUni(IntPtr ptr);
    public static string PtrToStringUni(IntPtr ptr, int len);
    public static string PtrToStringUTF8(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr, int byteLen);
    [EditorBrowsableAttribute("1")]
public static void PtrToStructure(IntPtr ptr, object structure);
    [EditorBrowsableAttribute("1")]
public static object PtrToStructure(IntPtr ptr, Type structureType);
    public static T PtrToStructure(IntPtr ptr);
    public static void PtrToStructure(IntPtr ptr, T structure);
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static byte ReadByte(IntPtr ptr);
    public static byte ReadByte(IntPtr ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadByte(Object, Int32) may be unavailable in future releases.")]
public static byte ReadByte(object ptr, int ofs);
    public static short ReadInt16(IntPtr ptr);
    public static short ReadInt16(IntPtr ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadInt16(Object, Int32) may be unavailable in future releases.")]
public static short ReadInt16(object ptr, int ofs);
    public static int ReadInt32(IntPtr ptr);
    public static int ReadInt32(IntPtr ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadInt32(Object, Int32) may be unavailable in future releases.")]
public static int ReadInt32(object ptr, int ofs);
    public static long ReadInt64(IntPtr ptr);
    public static long ReadInt64(IntPtr ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadInt64(Object, Int32) may be unavailable in future releases.")]
public static long ReadInt64(object ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr);
    public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadIntPtr(Object, Int32) may be unavailable in future releases.")]
public static IntPtr ReadIntPtr(object ptr, int ofs);
    public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
    public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
    public static int Release(IntPtr pUnk);
    public static int ReleaseComObject(object o);
    [CLSCompliantAttribute("False")]
public static IntPtr SecureStringToBSTR(SecureString s);
    [CLSCompliantAttribute("False")]
public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    [CLSCompliantAttribute("False")]
public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    [CLSCompliantAttribute("False")]
public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    [CLSCompliantAttribute("False")]
public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    public static bool SetComObjectData(object obj, object key, object data);
    [EditorBrowsableAttribute("1")]
public static int SizeOf(object structure);
    [EditorBrowsableAttribute("1")]
public static int SizeOf(Type t);
    public static int SizeOf();
    public static int SizeOf(T structure);
    public static IntPtr StringToBSTR(string s);
    public static IntPtr StringToCoTaskMemAnsi(string s);
    public static IntPtr StringToCoTaskMemAuto(string s);
    public static IntPtr StringToCoTaskMemUni(string s);
    public static IntPtr StringToCoTaskMemUTF8(string s);
    public static IntPtr StringToHGlobalAnsi(string s);
    public static IntPtr StringToHGlobalAuto(string s);
    public static IntPtr StringToHGlobalUni(string s);
    [EditorBrowsableAttribute("1")]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    public static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);
    public static void ThrowExceptionForHR(int errorCode);
    public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
    [EditorBrowsableAttribute("1")]
public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index);
    public static void WriteByte(IntPtr ptr, byte val);
    public static void WriteByte(IntPtr ptr, int ofs, byte val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteByte(Object, Int32, Byte) may be unavailable in future releases.")]
public static void WriteByte(object ptr, int ofs, byte val);
    public static void WriteInt16(IntPtr ptr, char val);
    public static void WriteInt16(IntPtr ptr, short val);
    public static void WriteInt16(IntPtr ptr, int ofs, char val);
    public static void WriteInt16(IntPtr ptr, int ofs, short val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteInt16(Object, Int32, Char) may be unavailable in future releases.")]
public static void WriteInt16(object ptr, int ofs, char val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteInt16(Object, Int32, Int16) may be unavailable in future releases.")]
public static void WriteInt16(object ptr, int ofs, short val);
    public static void WriteInt32(IntPtr ptr, int val);
    public static void WriteInt32(IntPtr ptr, int ofs, int val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteInt32(Object, Int32, Int32) may be unavailable in future releases.")]
public static void WriteInt32(object ptr, int ofs, int val);
    public static void WriteInt64(IntPtr ptr, int ofs, long val);
    public static void WriteInt64(IntPtr ptr, long val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteInt64(Object, Int32, Int64) may be unavailable in future releases.")]
public static void WriteInt64(object ptr, int ofs, long val);
    public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(IntPtr ptr, IntPtr val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteIntPtr(Object, Int32, IntPtr) may be unavailable in future releases.")]
public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
    public static void ZeroFreeBSTR(IntPtr s);
    public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
    public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
    public static void ZeroFreeCoTaskMemUTF8(IntPtr s);
    public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
    public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
}
[AttributeUsageAttribute("10496")]
public class System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
    public UnmanagedType ArraySubType;
    public int IidParameterIndex;
    public string MarshalCookie;
    public string MarshalType;
    public Type MarshalTypeRef;
    public VarEnum SafeArraySubType;
    public Type SafeArrayUserDefinedSubType;
    public int SizeConst;
    public short SizeParamIndex;
    public UnmanagedType Value { get; }
    public MarshalAsAttribute(short unmanagedType);
    public MarshalAsAttribute(UnmanagedType unmanagedType);
    public UnmanagedType get_Value();
}
public class System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
    protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
    public MarshalDirectiveException(string message);
    public MarshalDirectiveException(string message, Exception inner);
}
public static class System.Runtime.InteropServices.MemoryMarshal : object {
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
    public static ReadOnlySpan`1<T> CreateReadOnlySpan(T& reference, int length);
    public static Span`1<T> CreateSpan(T& reference, int length);
    public static T& GetReference(ReadOnlySpan`1<T> span);
    public static T& GetReference(Span`1<T> span);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    public static void Write(Span`1<byte> destination, T& value);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OptionalAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.OSPlatform : ValueType {
    private object _dummy;
    public static OSPlatform Linux { get; }
    public static OSPlatform OSX { get; }
    public static OSPlatform Windows { get; }
    public static OSPlatform get_Linux();
    public static OSPlatform get_OSX();
    public static OSPlatform get_Windows();
    public static OSPlatform Create(string osPlatform);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OSPlatform other);
    public virtual int GetHashCode();
    public static bool op_Equality(OSPlatform left, OSPlatform right);
    public static bool op_Inequality(OSPlatform left, OSPlatform right);
    public virtual string ToString();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute : Attribute {
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public PrimaryInteropAssemblyAttribute(int major, int minor);
    public int get_MajorVersion();
    public int get_MinorVersion();
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ProgIdAttribute : Attribute {
    public string Value { get; }
    public ProgIdAttribute(string progId);
    public string get_Value();
}
public static class System.Runtime.InteropServices.RuntimeEnvironment : object {
    public static string SystemConfigurationFile { get; }
    public static string get_SystemConfigurationFile();
    public static bool FromGlobalAccessCache(Assembly a);
    public static string GetRuntimeDirectory();
    public static IntPtr GetRuntimeInterfaceAsIntPtr(Guid clsid, Guid riid);
    public static object GetRuntimeInterfaceAsObject(Guid clsid, Guid riid);
    public static string GetSystemVersion();
}
public static class System.Runtime.InteropServices.RuntimeInformation : object {
    public static string FrameworkDescription { get; }
    public static Architecture OSArchitecture { get; }
    public static string OSDescription { get; }
    public static Architecture ProcessArchitecture { get; }
    public static string get_FrameworkDescription();
    public static Architecture get_OSArchitecture();
    public static string get_OSDescription();
    public static Architecture get_ProcessArchitecture();
    public static bool IsOSPlatform(OSPlatform osPlatform);
}
public class System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
    protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
    public SafeArrayRankMismatchException(string message);
    public SafeArrayRankMismatchException(string message, Exception inner);
}
public class System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
    protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
    public SafeArrayTypeMismatchException(string message);
    public SafeArrayTypeMismatchException(string message, Exception inner);
}
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    public ulong get_ByteLength();
    [CLSCompliantAttribute("False")]
public void AcquirePointer(Byte*& pointer);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    public void ReleasePointer();
    [CLSCompliantAttribute("False")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void Write(ulong byteOffset, T value);
}
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public void DangerousAddRef(Boolean& success);
    public IntPtr DangerousGetHandle();
    public void DangerousRelease();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected abstract virtual bool ReleaseHandle();
    protected void SetHandle(IntPtr handle);
    public void SetHandleAsInvalid();
}
public class System.Runtime.InteropServices.SEHException : ExternalException {
    protected SEHException(SerializationInfo info, StreamingContext context);
    public SEHException(string message);
    public SEHException(string message, Exception inner);
    public virtual bool CanResume();
}
public static class System.Runtime.InteropServices.SequenceMarshal : object {
    public static bool TryGetArray(ReadOnlySequence`1<T> sequence, ArraySegment`1& segment);
    public static bool TryGetReadOnlyMemory(ReadOnlySequence`1<T> sequence, ReadOnlyMemory`1& memory);
    public static bool TryGetReadOnlySequenceSegment(ReadOnlySequence`1<T> sequence, ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    public static bool TryRead(SequenceReader`1& reader, T& value);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    public CharSet CharSet;
    public int Pack;
    public int Size;
    public LayoutKind Value { get; }
    public StructLayoutAttribute(short layoutKind);
    public StructLayoutAttribute(LayoutKind layoutKind);
    public LayoutKind get_Value();
}
[AttributeUsageAttribute("5144")]
public class System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
    public string Identifier { get; }
    public string Scope { get; }
    public TypeIdentifierAttribute(string scope, string identifier);
    public string get_Identifier();
    public string get_Scope();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.TypeLibFuncAttribute : Attribute {
    public TypeLibFuncFlags Value { get; }
    public TypeLibFuncAttribute(short flags);
    public TypeLibFuncAttribute(TypeLibFuncFlags flags);
    public TypeLibFuncFlags get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.TypeLibFuncFlags : Enum {
    public int value__;
    public static TypeLibFuncFlags FBindable;
    public static TypeLibFuncFlags FDefaultBind;
    public static TypeLibFuncFlags FDefaultCollelem;
    public static TypeLibFuncFlags FDisplayBind;
    public static TypeLibFuncFlags FHidden;
    public static TypeLibFuncFlags FImmediateBind;
    public static TypeLibFuncFlags FNonBrowsable;
    public static TypeLibFuncFlags FReplaceable;
    public static TypeLibFuncFlags FRequestEdit;
    public static TypeLibFuncFlags FRestricted;
    public static TypeLibFuncFlags FSource;
    public static TypeLibFuncFlags FUiDefault;
    public static TypeLibFuncFlags FUsesGetLastError;
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.TypeLibImportClassAttribute : Attribute {
    public string Value { get; }
    public TypeLibImportClassAttribute(Type importClass);
    public string get_Value();
}
[AttributeUsageAttribute("1052")]
public class System.Runtime.InteropServices.TypeLibTypeAttribute : Attribute {
    public TypeLibTypeFlags Value { get; }
    public TypeLibTypeAttribute(short flags);
    public TypeLibTypeAttribute(TypeLibTypeFlags flags);
    public TypeLibTypeFlags get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.TypeLibTypeFlags : Enum {
    public int value__;
    public static TypeLibTypeFlags FAggregatable;
    public static TypeLibTypeFlags FAppObject;
    public static TypeLibTypeFlags FCanCreate;
    public static TypeLibTypeFlags FControl;
    public static TypeLibTypeFlags FDispatchable;
    public static TypeLibTypeFlags FDual;
    public static TypeLibTypeFlags FHidden;
    public static TypeLibTypeFlags FLicensed;
    public static TypeLibTypeFlags FNonExtensible;
    public static TypeLibTypeFlags FOleAutomation;
    public static TypeLibTypeFlags FPreDeclId;
    public static TypeLibTypeFlags FReplaceable;
    public static TypeLibTypeFlags FRestricted;
    public static TypeLibTypeFlags FReverseBind;
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.TypeLibVarAttribute : Attribute {
    public TypeLibVarFlags Value { get; }
    public TypeLibVarAttribute(short flags);
    public TypeLibVarAttribute(TypeLibVarFlags flags);
    public TypeLibVarFlags get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.TypeLibVarFlags : Enum {
    public int value__;
    public static TypeLibVarFlags FBindable;
    public static TypeLibVarFlags FDefaultBind;
    public static TypeLibVarFlags FDefaultCollelem;
    public static TypeLibVarFlags FDisplayBind;
    public static TypeLibVarFlags FHidden;
    public static TypeLibVarFlags FImmediateBind;
    public static TypeLibVarFlags FNonBrowsable;
    public static TypeLibVarFlags FReadOnly;
    public static TypeLibVarFlags FReplaceable;
    public static TypeLibVarFlags FRequestEdit;
    public static TypeLibVarFlags FRestricted;
    public static TypeLibVarFlags FSource;
    public static TypeLibVarFlags FUiDefault;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.InteropServices.TypeLibVersionAttribute : Attribute {
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public TypeLibVersionAttribute(int major, int minor);
    public int get_MajorVersion();
    public int get_MinorVersion();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("UnknownWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
public class System.Runtime.InteropServices.UnknownWrapper : object {
    public object WrappedObject { get; }
    public UnknownWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("4096")]
public class System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
    public bool BestFitMapping;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ThrowOnUnmappableChar;
    public CallingConvention CallingConvention { get; }
    public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
    public CallingConvention get_CallingConvention();
}
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as AnsiBStr may be unavailable in future releases.")]
public static UnmanagedType AnsiBStr;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling arbitrary types may be unavailable in future releases. Please specify the type you wish to marshal as.")]
public static UnmanagedType AsAny;
    public static UnmanagedType Bool;
    public static UnmanagedType BStr;
    public static UnmanagedType ByValArray;
    public static UnmanagedType ByValTStr;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as Currency may be unavailable in future releases.")]
public static UnmanagedType Currency;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    public static UnmanagedType FunctionPtr;
    public static UnmanagedType HString;
    public static UnmanagedType I1;
    public static UnmanagedType I2;
    public static UnmanagedType I4;
    public static UnmanagedType I8;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as IDispatch may be unavailable in future releases.")]
public static UnmanagedType IDispatch;
    public static UnmanagedType IInspectable;
    public static UnmanagedType Interface;
    public static UnmanagedType IUnknown;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPStruct;
    public static UnmanagedType LPTStr;
    public static UnmanagedType LPUTF8Str;
    public static UnmanagedType LPWStr;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as SafeArray may be unavailable in future releases.")]
public static UnmanagedType SafeArray;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Applying UnmanagedType.Struct is unnecessary when marshalling a struct. Support for UnmanagedType.Struct when marshalling a reference type may be unavailable in future releases.")]
public static UnmanagedType Struct;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as TBstr may be unavailable in future releases.")]
public static UnmanagedType TBStr;
    public static UnmanagedType U1;
    public static UnmanagedType U2;
    public static UnmanagedType U4;
    public static UnmanagedType U8;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as VariantBool may be unavailable in future releases.")]
public static UnmanagedType VariantBool;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as VBByRefString may be unavailable in future releases.")]
public static UnmanagedType VBByRefStr;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling VARIANTs may be unavailable in future releases.")]
public enum System.Runtime.InteropServices.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_BYREF;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_I1;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_I8;
    public static VarEnum VT_INT;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_NULL;
    public static VarEnum VT_PTR;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_UI8;
    public static VarEnum VT_UINT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_VOID;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("VariantWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
public class System.Runtime.InteropServices.VariantWrapper : object {
    public object WrappedObject { get; }
    public VariantWrapper(object obj);
    public object get_WrappedObject();
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    public MemoryFailPoint(int sizeInMegabytes);
    public sealed virtual void Dispose();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.Serialization.CollectionDataContractAttribute : Attribute {
    public bool IsItemNameSetExplicitly { get; }
    public bool IsKeyNameSetExplicitly { get; }
    public bool IsNameSetExplicitly { get; }
    public bool IsNamespaceSetExplicitly { get; }
    public bool IsReference { get; public set; }
    public bool IsReferenceSetExplicitly { get; }
    public bool IsValueNameSetExplicitly { get; }
    public string ItemName { get; public set; }
    public string KeyName { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public string ValueName { get; public set; }
    public bool get_IsItemNameSetExplicitly();
    public bool get_IsKeyNameSetExplicitly();
    public bool get_IsNameSetExplicitly();
    public bool get_IsNamespaceSetExplicitly();
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_IsReferenceSetExplicitly();
    public bool get_IsValueNameSetExplicitly();
    public string get_ItemName();
    public void set_ItemName(string value);
    public string get_KeyName();
    public void set_KeyName(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_ValueName();
    public void set_ValueName(string value);
}
[AttributeUsageAttribute("3")]
public class System.Runtime.Serialization.ContractNamespaceAttribute : Attribute {
    public string ClrNamespace { get; public set; }
    public string ContractNamespace { get; }
    public ContractNamespaceAttribute(string contractNamespace);
    public string get_ClrNamespace();
    public void set_ClrNamespace(string value);
    public string get_ContractNamespace();
}
[AttributeUsageAttribute("28")]
public class System.Runtime.Serialization.DataContractAttribute : Attribute {
    public bool IsNameSetExplicitly { get; }
    public bool IsNamespaceSetExplicitly { get; }
    public bool IsReference { get; public set; }
    public bool IsReferenceSetExplicitly { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public bool get_IsNameSetExplicitly();
    public bool get_IsNamespaceSetExplicitly();
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_IsReferenceSetExplicitly();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
}
public abstract class System.Runtime.Serialization.DataContractResolver : object {
    public abstract virtual Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
    public abstract virtual bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
}
public class System.Runtime.Serialization.DataContractSerializer : XmlObjectSerializer {
    public DataContractResolver DataContractResolver { get; }
    public bool IgnoreExtensionDataObject { get; }
    public ReadOnlyCollection`1<Type> KnownTypes { get; }
    public int MaxItemsInObjectGraph { get; }
    public bool PreserveObjectReferences { get; }
    public bool SerializeReadOnlyTypes { get; }
    public DataContractSerializer(Type type);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, DataContractSerializerSettings settings);
    public DataContractSerializer(Type type, string rootName, string rootNamespace);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes);
    public DataContractResolver get_DataContractResolver();
    public bool get_IgnoreExtensionDataObject();
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    public int get_MaxItemsInObjectGraph();
    public bool get_PreserveObjectReferences();
    public bool get_SerializeReadOnlyTypes();
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    public virtual bool IsStartObject(XmlReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public object ReadObject(XmlDictionaryReader reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual void WriteEndObject(XmlWriter writer);
    public void WriteObject(XmlDictionaryWriter writer, object graph, DataContractResolver dataContractResolver);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
}
[ExtensionAttribute]
public static class System.Runtime.Serialization.DataContractSerializerExtensions : object {
    [ExtensionAttribute]
public static ISerializationSurrogateProvider GetSerializationSurrogateProvider(DataContractSerializer serializer);
    [ExtensionAttribute]
public static void SetSerializationSurrogateProvider(DataContractSerializer serializer, ISerializationSurrogateProvider provider);
}
public class System.Runtime.Serialization.DataContractSerializerSettings : object {
    public DataContractResolver DataContractResolver { get; public set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    public IEnumerable`1<Type> KnownTypes { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    public bool PreserveObjectReferences { get; public set; }
    public XmlDictionaryString RootName { get; public set; }
    public XmlDictionaryString RootNamespace { get; public set; }
    public bool SerializeReadOnlyTypes { get; public set; }
    public DataContractResolver get_DataContractResolver();
    public void set_DataContractResolver(DataContractResolver value);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    public IEnumerable`1<Type> get_KnownTypes();
    public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    public bool get_PreserveObjectReferences();
    public void set_PreserveObjectReferences(bool value);
    public XmlDictionaryString get_RootName();
    public void set_RootName(XmlDictionaryString value);
    public XmlDictionaryString get_RootNamespace();
    public void set_RootNamespace(XmlDictionaryString value);
    public bool get_SerializeReadOnlyTypes();
    public void set_SerializeReadOnlyTypes(bool value);
}
[AttributeUsageAttribute("384")]
public class System.Runtime.Serialization.DataMemberAttribute : Attribute {
    public bool EmitDefaultValue { get; public set; }
    public bool IsNameSetExplicitly { get; }
    public bool IsRequired { get; public set; }
    public string Name { get; public set; }
    public int Order { get; public set; }
    public bool get_EmitDefaultValue();
    public void set_EmitDefaultValue(bool value);
    public bool get_IsNameSetExplicitly();
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public string get_Name();
    public void set_Name(string value);
    public int get_Order();
    public void set_Order(int value);
}
public class System.Runtime.Serialization.DateTimeFormat : object {
    public DateTimeStyles DateTimeStyles { get; public set; }
    public IFormatProvider FormatProvider { get; }
    public string FormatString { get; }
    public DateTimeFormat(string formatString);
    public DateTimeFormat(string formatString, IFormatProvider formatProvider);
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    public IFormatProvider get_FormatProvider();
    public string get_FormatString();
}
public enum System.Runtime.Serialization.EmitTypeInformation : Enum {
    public int value__;
    public static EmitTypeInformation Always;
    public static EmitTypeInformation AsNeeded;
    public static EmitTypeInformation Never;
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.EnumMemberAttribute : Attribute {
    public bool IsValueSetExplicitly { get; }
    public string Value { get; public set; }
    public bool get_IsValueSetExplicitly();
    public string get_Value();
    public void set_Value(string value);
}
public class System.Runtime.Serialization.ExportOptions : object {
    public Collection`1<Type> KnownTypes { get; }
    public Collection`1<Type> get_KnownTypes();
}
public class System.Runtime.Serialization.ExtensionDataObject : object {
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Serialization.Formatter : object {
    protected ObjectIDGenerator m_idGenerator;
    protected Queue m_objectQueue;
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public abstract virtual SerializationBinder get_Binder();
    public abstract virtual void set_Binder(SerializationBinder value);
    public abstract virtual StreamingContext get_Context();
    public abstract virtual void set_Context(StreamingContext value);
    public abstract virtual ISurrogateSelector get_SurrogateSelector();
    public abstract virtual void set_SurrogateSelector(ISurrogateSelector value);
    public abstract virtual object Deserialize(Stream serializationStream);
    protected virtual object GetNext(Int64& objID);
    protected virtual long Schedule(object obj);
    public abstract virtual void Serialize(Stream serializationStream, object graph);
    protected abstract virtual void WriteArray(object obj, string name, Type memberType);
    protected abstract virtual void WriteBoolean(bool val, string name);
    protected abstract virtual void WriteByte(byte val, string name);
    protected abstract virtual void WriteChar(char val, string name);
    protected abstract virtual void WriteDateTime(DateTime val, string name);
    protected abstract virtual void WriteDecimal(decimal val, string name);
    protected abstract virtual void WriteDouble(double val, string name);
    protected abstract virtual void WriteInt16(short val, string name);
    protected abstract virtual void WriteInt32(int val, string name);
    protected abstract virtual void WriteInt64(long val, string name);
    protected virtual void WriteMember(string memberName, object data);
    protected abstract virtual void WriteObjectRef(object obj, string name, Type memberType);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteSByte(sbyte val, string name);
    protected abstract virtual void WriteSingle(float val, string name);
    protected abstract virtual void WriteTimeSpan(TimeSpan val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt16(ushort val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt32(UInt32 val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt64(ulong val, string name);
    protected abstract virtual void WriteValueType(object obj, string name, Type memberType);
}
public class System.Runtime.Serialization.FormatterConverter : object {
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual ulong ToUInt64(object value);
}
public class System.Runtime.Serialization.Formatters.Binary.BinaryFormatter : object {
    public FormatterAssemblyStyle AssemblyFormat { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public TypeFilterLevel FilterLevel { get; public set; }
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public FormatterTypeStyle TypeFormat { get; public set; }
    public BinaryFormatter(ISurrogateSelector selector, StreamingContext context);
    public FormatterAssemblyStyle get_AssemblyFormat();
    public void set_AssemblyFormat(FormatterAssemblyStyle value);
    public sealed virtual SerializationBinder get_Binder();
    public sealed virtual void set_Binder(SerializationBinder value);
    public sealed virtual StreamingContext get_Context();
    public sealed virtual void set_Context(StreamingContext value);
    public TypeFilterLevel get_FilterLevel();
    public void set_FilterLevel(TypeFilterLevel value);
    public sealed virtual ISurrogateSelector get_SurrogateSelector();
    public sealed virtual void set_SurrogateSelector(ISurrogateSelector value);
    public FormatterTypeStyle get_TypeFormat();
    public void set_TypeFormat(FormatterTypeStyle value);
    public sealed virtual object Deserialize(Stream serializationStream);
    public sealed virtual void Serialize(Stream serializationStream, object graph);
}
public enum System.Runtime.Serialization.Formatters.FormatterAssemblyStyle : Enum {
    public int value__;
    public static FormatterAssemblyStyle Full;
    public static FormatterAssemblyStyle Simple;
}
public enum System.Runtime.Serialization.Formatters.FormatterTypeStyle : Enum {
    public int value__;
    public static FormatterTypeStyle TypesAlways;
    public static FormatterTypeStyle TypesWhenNeeded;
    public static FormatterTypeStyle XsdString;
}
public interface System.Runtime.Serialization.Formatters.IFieldInfo {
    public String[] FieldNames { get; public set; }
    public Type[] FieldTypes { get; public set; }
    public abstract virtual String[] get_FieldNames();
    public abstract virtual void set_FieldNames(String[] value);
    public abstract virtual Type[] get_FieldTypes();
    public abstract virtual void set_FieldTypes(Type[] value);
}
public enum System.Runtime.Serialization.Formatters.TypeFilterLevel : Enum {
    public int value__;
    public static TypeFilterLevel Full;
    public static TypeFilterLevel Low;
}
public static class System.Runtime.Serialization.FormatterServices : object {
    public static void CheckTypeSecurity(Type t, TypeFilterLevel securityLevel);
    public static Object[] GetObjectData(object obj, MemberInfo[] members);
    public static object GetSafeUninitializedObject(Type type);
    public static MemberInfo[] GetSerializableMembers(Type type);
    public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context);
    public static ISerializationSurrogate GetSurrogateForCyclicalReference(ISerializationSurrogate innerSurrogate);
    public static Type GetTypeFromAssembly(Assembly assem, string name);
    public static object GetUninitializedObject(Type type);
    public static object PopulateObjectMembers(object obj, MemberInfo[] members, Object[] data);
}
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
public interface System.Runtime.Serialization.IExtensibleDataObject {
    public ExtensionDataObject ExtensionData { get; public set; }
    public abstract virtual ExtensionDataObject get_ExtensionData();
    public abstract virtual void set_ExtensionData(ExtensionDataObject value);
}
public interface System.Runtime.Serialization.IFormatter {
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public abstract virtual SerializationBinder get_Binder();
    public abstract virtual void set_Binder(SerializationBinder value);
    public abstract virtual StreamingContext get_Context();
    public abstract virtual void set_Context(StreamingContext value);
    public abstract virtual ISurrogateSelector get_SurrogateSelector();
    public abstract virtual void set_SurrogateSelector(ISurrogateSelector value);
    public abstract virtual object Deserialize(Stream serializationStream);
    public abstract virtual void Serialize(Stream serializationStream, object graph);
}
[CLSCompliantAttribute("False")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual string ToString(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual ulong ToUInt64(object value);
}
[AttributeUsageAttribute("384")]
public class System.Runtime.Serialization.IgnoreDataMemberAttribute : Attribute {
}
public class System.Runtime.Serialization.InvalidDataContractException : Exception {
    protected InvalidDataContractException(SerializationInfo info, StreamingContext context);
    public InvalidDataContractException(string message);
    public InvalidDataContractException(string message, Exception innerException);
}
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
public interface System.Runtime.Serialization.ISerializable {
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public interface System.Runtime.Serialization.ISerializationSurrogate {
    public abstract virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    public abstract virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
public interface System.Runtime.Serialization.ISerializationSurrogateProvider {
    public abstract virtual object GetDeserializedObject(object obj, Type targetType);
    public abstract virtual object GetObjectToSerialize(object obj, Type targetType);
    public abstract virtual Type GetSurrogateType(Type type);
}
public interface System.Runtime.Serialization.ISurrogateSelector {
    public abstract virtual void ChainSelector(ISurrogateSelector selector);
    public abstract virtual ISurrogateSelector GetNextSelector();
    public abstract virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector);
}
public class System.Runtime.Serialization.Json.DataContractJsonSerializer : XmlObjectSerializer {
    public DateTimeFormat DateTimeFormat { get; }
    public EmitTypeInformation EmitTypeInformation { get; }
    public bool IgnoreExtensionDataObject { get; }
    public ReadOnlyCollection`1<Type> KnownTypes { get; }
    public int MaxItemsInObjectGraph { get; }
    public bool SerializeReadOnlyTypes { get; }
    public bool UseSimpleDictionaryFormat { get; }
    public DataContractJsonSerializer(Type type);
    public DataContractJsonSerializer(Type type, IEnumerable`1<Type> knownTypes);
    public DataContractJsonSerializer(Type type, DataContractJsonSerializerSettings settings);
    public DataContractJsonSerializer(Type type, string rootName);
    public DataContractJsonSerializer(Type type, string rootName, IEnumerable`1<Type> knownTypes);
    public DataContractJsonSerializer(Type type, XmlDictionaryString rootName);
    public DataContractJsonSerializer(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes);
    public DateTimeFormat get_DateTimeFormat();
    public EmitTypeInformation get_EmitTypeInformation();
    public bool get_IgnoreExtensionDataObject();
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    public int get_MaxItemsInObjectGraph();
    public bool get_SerializeReadOnlyTypes();
    public bool get_UseSimpleDictionaryFormat();
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    public virtual bool IsStartObject(XmlReader reader);
    public virtual object ReadObject(Stream stream);
    public virtual object ReadObject(XmlDictionaryReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteObject(Stream stream, object graph);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
}
public class System.Runtime.Serialization.Json.DataContractJsonSerializerSettings : object {
    public DateTimeFormat DateTimeFormat { get; public set; }
    public EmitTypeInformation EmitTypeInformation { get; public set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    public IEnumerable`1<Type> KnownTypes { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    public string RootName { get; public set; }
    public bool SerializeReadOnlyTypes { get; public set; }
    public bool UseSimpleDictionaryFormat { get; public set; }
    public DateTimeFormat get_DateTimeFormat();
    public void set_DateTimeFormat(DateTimeFormat value);
    public EmitTypeInformation get_EmitTypeInformation();
    public void set_EmitTypeInformation(EmitTypeInformation value);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    public IEnumerable`1<Type> get_KnownTypes();
    public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    public string get_RootName();
    public void set_RootName(string value);
    public bool get_SerializeReadOnlyTypes();
    public void set_SerializeReadOnlyTypes(bool value);
    public bool get_UseSimpleDictionaryFormat();
    public void set_UseSimpleDictionaryFormat(bool value);
}
public interface System.Runtime.Serialization.Json.IXmlJsonReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
public interface System.Runtime.Serialization.Json.IXmlJsonWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
public static class System.Runtime.Serialization.Json.JsonReaderWriterFactory : object {
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateJsonReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream, bool indent);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream, bool indent, string indentChars);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.Serialization.KnownTypeAttribute : Attribute {
    public string MethodName { get; }
    public Type Type { get; }
    public KnownTypeAttribute(string methodName);
    public KnownTypeAttribute(Type type);
    public string get_MethodName();
    public Type get_Type();
}
public class System.Runtime.Serialization.ObjectIDGenerator : object {
    public virtual long GetId(object obj, Boolean& firstTime);
    public virtual long HasId(object obj, Boolean& firstTime);
}
public class System.Runtime.Serialization.ObjectManager : object {
    public ObjectManager(ISurrogateSelector selector, StreamingContext context);
    public virtual void DoFixups();
    public virtual object GetObject(long objectID);
    public virtual void RaiseDeserializationEvent();
    public void RaiseOnDeserializingEvent(object obj);
    public virtual void RecordArrayElementFixup(long arrayToBeFixed, int index, long objectRequired);
    public virtual void RecordArrayElementFixup(long arrayToBeFixed, Int32[] indices, long objectRequired);
    public virtual void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired);
    public virtual void RecordFixup(long objectToBeFixed, MemberInfo member, long objectRequired);
    public virtual void RegisterObject(object obj, long objectID);
    public void RegisterObject(object obj, long objectID, SerializationInfo info);
    public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member);
    public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member, Int32[] arrayIndex);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    public StreamingContext StreamingContext { get; }
    public StreamingContext get_StreamingContext();
    public void AddSerializedState(ISafeSerializationData serializedState);
}
public abstract class System.Runtime.Serialization.SerializationBinder : object {
    public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
    public abstract virtual Type BindToType(string assemblyName, string typeName);
}
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private object _dummy;
    public string Name { get; }
    public Type ObjectType { get; }
    public object Value { get; }
    public string get_Name();
    public Type get_ObjectType();
    public object get_Value();
}
public class System.Runtime.Serialization.SerializationException : SystemException {
    protected SerializationException(SerializationInfo info, StreamingContext context);
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
}
public class System.Runtime.Serialization.SerializationInfo : object {
    public string AssemblyName { get; public set; }
    public string FullTypeName { get; public set; }
    public bool IsAssemblyNameSetExplicit { get; }
    public bool IsFullTypeNameSetExplicit { get; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public bool get_IsAssemblyNameSetExplicit();
    public bool get_IsFullTypeNameSetExplicit();
    public int get_MemberCount();
    public Type get_ObjectType();
    public void AddValue(string name, bool value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, char value);
    public void AddValue(string name, DateTime value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, double value);
    public void AddValue(string name, short value);
    public void AddValue(string name, int value);
    public void AddValue(string name, long value);
    public void AddValue(string name, object value);
    public void AddValue(string name, object value, Type type);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, float value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public bool GetBoolean(string name);
    public byte GetByte(string name);
    public char GetChar(string name);
    public DateTime GetDateTime(string name);
    public decimal GetDecimal(string name);
    public double GetDouble(string name);
    public SerializationInfoEnumerator GetEnumerator();
    public short GetInt16(string name);
    public int GetInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public float GetSingle(string name);
    public string GetString(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public object GetValue(string name, Type type);
    public void SetType(Type type);
}
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    public SerializationEntry Current { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public object Value { get; }
    public SerializationEntry get_Current();
    public string get_Name();
    public Type get_ObjectType();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public object get_Value();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Runtime.Serialization.SerializationObjectManager : object {
    public SerializationObjectManager(StreamingContext context);
    public void RaiseOnSerializedEvent();
    public void RegisterObject(object obj);
}
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.StreamingContext : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public object Context { get; }
    public StreamingContextStates State { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public object get_Context();
    public StreamingContextStates get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates All;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates File;
    public static StreamingContextStates Other;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
}
public class System.Runtime.Serialization.SurrogateSelector : object {
    public virtual void AddSurrogate(Type type, StreamingContext context, ISerializationSurrogate surrogate);
    public virtual void ChainSelector(ISurrogateSelector selector);
    public virtual ISurrogateSelector GetNextSelector();
    public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector);
    public virtual void RemoveSurrogate(Type type, StreamingContext context);
}
public abstract class System.Runtime.Serialization.XmlObjectSerializer : object {
    public abstract virtual bool IsStartObject(XmlDictionaryReader reader);
    public virtual bool IsStartObject(XmlReader reader);
    public virtual object ReadObject(Stream stream);
    public virtual object ReadObject(XmlDictionaryReader reader);
    public abstract virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public abstract virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteObject(Stream stream, object graph);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public abstract virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public abstract virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
}
public static class System.Runtime.Serialization.XmlSerializableServices : object {
    public static void AddDefaultSchema(XmlSchemaSet schemas, XmlQualifiedName typeQName);
    public static XmlNode[] ReadNodes(XmlReader xmlReader);
    public static void WriteNodes(XmlWriter xmlWriter, XmlNode[] nodes);
}
public static class System.Runtime.Serialization.XPathQueryGenerator : object {
    public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, StringBuilder rootElementXpath, XmlNamespaceManager& namespaces);
    public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, XmlNamespaceManager& namespaces);
}
public class System.Runtime.Serialization.XsdDataContractExporter : object {
    public ExportOptions Options { get; public set; }
    public XmlSchemaSet Schemas { get; }
    public XsdDataContractExporter(XmlSchemaSet schemas);
    public ExportOptions get_Options();
    public void set_Options(ExportOptions value);
    public XmlSchemaSet get_Schemas();
    public bool CanExport(ICollection`1<Assembly> assemblies);
    public bool CanExport(ICollection`1<Type> types);
    public bool CanExport(Type type);
    public void Export(ICollection`1<Assembly> assemblies);
    public void Export(ICollection`1<Type> types);
    public void Export(Type type);
    public XmlQualifiedName GetRootElementName(Type type);
    public XmlSchemaType GetSchemaType(Type type);
    public XmlQualifiedName GetSchemaTypeName(Type type);
}
[AttributeUsageAttribute("96")]
public class System.Runtime.TargetedPatchingOptOutAttribute : Attribute {
    public string Reason { get; }
    public TargetedPatchingOptOutAttribute(string reason);
    public string get_Reason();
}
[AttributeUsageAttribute("5887")]
public class System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
    public ComponentGuaranteesOptions Guarantees { get; }
    public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
    public ComponentGuaranteesOptions get_Guarantees();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
    public int value__;
    public static ComponentGuaranteesOptions Exchange;
    public static ComponentGuaranteesOptions None;
    public static ComponentGuaranteesOptions SideBySide;
    public static ComponentGuaranteesOptions Stable;
}
public class System.Runtime.Versioning.FrameworkName : object {
    public string FullName { get; }
    public string Identifier { get; }
    public string Profile { get; }
    public Version Version { get; }
    public FrameworkName(string frameworkName);
    public FrameworkName(string identifier, Version version);
    public FrameworkName(string identifier, Version version, string profile);
    public string get_FullName();
    public string get_Identifier();
    public string get_Profile();
    public Version get_Version();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FrameworkName other);
    public virtual int GetHashCode();
    public static bool op_Equality(FrameworkName left, FrameworkName right);
    public static bool op_Inequality(FrameworkName left, FrameworkName right);
    public virtual string ToString();
}
[AttributeUsageAttribute("224")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
    public ResourceScope ConsumptionScope { get; }
    public ResourceScope ResourceScope { get; }
    public ResourceConsumptionAttribute(ResourceScope resourceScope);
    public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
    public ResourceScope get_ConsumptionScope();
    public ResourceScope get_ResourceScope();
}
[AttributeUsageAttribute("480")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
    public ResourceScope ResourceExposureLevel { get; }
    public ResourceExposureAttribute(ResourceScope exposureLevel);
    public ResourceScope get_ResourceExposureLevel();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ResourceScope : Enum {
    public int value__;
    public static ResourceScope AppDomain;
    public static ResourceScope Assembly;
    public static ResourceScope Library;
    public static ResourceScope Machine;
    public static ResourceScope None;
    public static ResourceScope Private;
    public static ResourceScope Process;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    public string FrameworkDisplayName { get; public set; }
    public string FrameworkName { get; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkDisplayName();
    public void set_FrameworkDisplayName(string value);
    public string get_FrameworkName();
}
public static class System.Runtime.Versioning.VersioningHelper : object {
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
}
[IsByRefLikeAttribute]
public class System.RuntimeArgumentHandle : ValueType {
    private int _dummyPrimitive;
}
public class System.RuntimeFieldHandle : ValueType {
    private object _dummy;
    public IntPtr Value { get; }
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeFieldHandle handle);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
}
public class System.RuntimeMethodHandle : ValueType {
    private object _dummy;
    public IntPtr Value { get; }
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeMethodHandle handle);
    public IntPtr GetFunctionPointer();
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
}
public class System.RuntimeTypeHandle : ValueType {
    private object _dummy;
    public IntPtr Value { get; }
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeTypeHandle handle);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public ModuleHandle GetModuleHandle();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.SByte : ValueType {
    private sbyte _dummyPrimitive;
    public static sbyte MaxValue;
    public static sbyte MinValue;
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    [CLSCompliantAttribute("False")]
public static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, SByte& result);
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
public class System.Security.Authentication.AuthenticationException : SystemException {
    protected AuthenticationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public AuthenticationException(string message);
    public AuthenticationException(string message, Exception innerException);
}
public enum System.Security.Authentication.CipherAlgorithmType : Enum {
    public int value__;
    public static CipherAlgorithmType Aes;
    public static CipherAlgorithmType Aes128;
    public static CipherAlgorithmType Aes192;
    public static CipherAlgorithmType Aes256;
    public static CipherAlgorithmType Des;
    public static CipherAlgorithmType None;
    public static CipherAlgorithmType Null;
    public static CipherAlgorithmType Rc2;
    public static CipherAlgorithmType Rc4;
    public static CipherAlgorithmType TripleDes;
}
public enum System.Security.Authentication.ExchangeAlgorithmType : Enum {
    public int value__;
    public static ExchangeAlgorithmType DiffieHellman;
    public static ExchangeAlgorithmType None;
    public static ExchangeAlgorithmType RsaKeyX;
    public static ExchangeAlgorithmType RsaSign;
}
public abstract class System.Security.Authentication.ExtendedProtection.ChannelBinding : SafeHandleZeroOrMinusOneIsInvalid {
    public int Size { get; }
    protected ChannelBinding(bool ownsHandle);
    public abstract virtual int get_Size();
}
public enum System.Security.Authentication.ExtendedProtection.ChannelBindingKind : Enum {
    public int value__;
    public static ChannelBindingKind Endpoint;
    public static ChannelBindingKind Unique;
    public static ChannelBindingKind Unknown;
}
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
    public ChannelBinding CustomChannelBinding { get; }
    public ServiceNameCollection CustomServiceNames { get; }
    public static bool OSSupportsExtendedProtection { get; }
    public PolicyEnforcement PolicyEnforcement { get; }
    public ProtectionScenario ProtectionScenario { get; }
    protected ExtendedProtectionPolicy(SerializationInfo info, StreamingContext context);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames);
    public ChannelBinding get_CustomChannelBinding();
    public ServiceNameCollection get_CustomServiceNames();
    public static bool get_OSSupportsExtendedProtection();
    public PolicyEnforcement get_PolicyEnforcement();
    public ProtectionScenario get_ProtectionScenario();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicyTypeConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
    public int value__;
    public static PolicyEnforcement Always;
    public static PolicyEnforcement Never;
    public static PolicyEnforcement WhenSupported;
}
public enum System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
    public int value__;
    public static ProtectionScenario TransportSelected;
    public static ProtectionScenario TrustedProxy;
}
public class System.Security.Authentication.ExtendedProtection.ServiceNameCollection : ReadOnlyCollectionBase {
    public ServiceNameCollection(ICollection items);
    public bool Contains(string searchServiceName);
    public ServiceNameCollection Merge(IEnumerable serviceNames);
    public ServiceNameCollection Merge(string serviceName);
}
public enum System.Security.Authentication.HashAlgorithmType : Enum {
    public int value__;
    public static HashAlgorithmType Md5;
    public static HashAlgorithmType None;
    public static HashAlgorithmType Sha1;
    public static HashAlgorithmType Sha256;
    public static HashAlgorithmType Sha384;
    public static HashAlgorithmType Sha512;
}
public class System.Security.Authentication.InvalidCredentialException : AuthenticationException {
    protected InvalidCredentialException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public InvalidCredentialException(string message);
    public InvalidCredentialException(string message, Exception innerException);
}
[FlagsAttribute]
public enum System.Security.Authentication.SslProtocols : Enum {
    public int value__;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. https://go.microsoft.com/fwlink/?linkid=14202")]
public static SslProtocols Default;
    public static SslProtocols None;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. https://go.microsoft.com/fwlink/?linkid=14202")]
public static SslProtocols Ssl2;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. https://go.microsoft.com/fwlink/?linkid=14202")]
public static SslProtocols Ssl3;
    public static SslProtocols Tls;
    public static SslProtocols Tls11;
    public static SslProtocols Tls12;
}
public class System.Security.Claims.Claim : object {
    protected Byte[] CustomSerializationData { get; }
    public string Issuer { get; }
    public string OriginalIssuer { get; }
    public IDictionary`2<string, string> Properties { get; }
    public ClaimsIdentity Subject { get; }
    public string Type { get; }
    public string Value { get; }
    public string ValueType { get; }
    public Claim(BinaryReader reader);
    public Claim(BinaryReader reader, ClaimsIdentity subject);
    protected Claim(Claim other);
    protected Claim(Claim other, ClaimsIdentity subject);
    public Claim(string type, string value);
    public Claim(string type, string value, string valueType);
    public Claim(string type, string value, string valueType, string issuer);
    public Claim(string type, string value, string valueType, string issuer, string originalIssuer);
    public Claim(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject);
    protected virtual Byte[] get_CustomSerializationData();
    public string get_Issuer();
    public string get_OriginalIssuer();
    public IDictionary`2<string, string> get_Properties();
    public ClaimsIdentity get_Subject();
    public string get_Type();
    public string get_Value();
    public string get_ValueType();
    public virtual Claim Clone();
    public virtual Claim Clone(ClaimsIdentity identity);
    public virtual string ToString();
    public virtual void WriteTo(BinaryWriter writer);
    protected virtual void WriteTo(BinaryWriter writer, Byte[] userData);
}
public class System.Security.Claims.ClaimsIdentity : object {
    public static string DefaultIssuer;
    public static string DefaultNameClaimType;
    public static string DefaultRoleClaimType;
    public ClaimsIdentity Actor { get; public set; }
    public string AuthenticationType { get; }
    public object BootstrapContext { get; public set; }
    public IEnumerable`1<Claim> Claims { get; }
    protected Byte[] CustomSerializationData { get; }
    public bool IsAuthenticated { get; }
    public string Label { get; public set; }
    public string Name { get; }
    public string NameClaimType { get; }
    public string RoleClaimType { get; }
    public ClaimsIdentity(IEnumerable`1<Claim> claims);
    public ClaimsIdentity(IEnumerable`1<Claim> claims, string authenticationType);
    public ClaimsIdentity(IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType);
    public ClaimsIdentity(BinaryReader reader);
    protected ClaimsIdentity(SerializationInfo info);
    protected ClaimsIdentity(SerializationInfo info, StreamingContext context);
    protected ClaimsIdentity(ClaimsIdentity other);
    public ClaimsIdentity(IIdentity identity);
    public ClaimsIdentity(IIdentity identity, IEnumerable`1<Claim> claims);
    public ClaimsIdentity(IIdentity identity, IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType);
    public ClaimsIdentity(string authenticationType);
    public ClaimsIdentity(string authenticationType, string nameType, string roleType);
    public ClaimsIdentity get_Actor();
    public void set_Actor(ClaimsIdentity value);
    public virtual string get_AuthenticationType();
    public object get_BootstrapContext();
    public void set_BootstrapContext(object value);
    public virtual IEnumerable`1<Claim> get_Claims();
    protected virtual Byte[] get_CustomSerializationData();
    public virtual bool get_IsAuthenticated();
    public string get_Label();
    public void set_Label(string value);
    public virtual string get_Name();
    public string get_NameClaimType();
    public string get_RoleClaimType();
    public virtual void AddClaim(Claim claim);
    public virtual void AddClaims(IEnumerable`1<Claim> claims);
    public virtual ClaimsIdentity Clone();
    protected virtual Claim CreateClaim(BinaryReader reader);
    public virtual IEnumerable`1<Claim> FindAll(Predicate`1<Claim> match);
    public virtual IEnumerable`1<Claim> FindAll(string type);
    public virtual Claim FindFirst(Predicate`1<Claim> match);
    public virtual Claim FindFirst(string type);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool HasClaim(Predicate`1<Claim> match);
    public virtual bool HasClaim(string type, string value);
    public virtual void RemoveClaim(Claim claim);
    public virtual bool TryRemoveClaim(Claim claim);
    public virtual void WriteTo(BinaryWriter writer);
    protected virtual void WriteTo(BinaryWriter writer, Byte[] userData);
}
public class System.Security.Claims.ClaimsPrincipal : object {
    public IEnumerable`1<Claim> Claims { get; }
    public static Func`1<ClaimsPrincipal> ClaimsPrincipalSelector { get; public set; }
    public static ClaimsPrincipal Current { get; }
    protected Byte[] CustomSerializationData { get; }
    public IEnumerable`1<ClaimsIdentity> Identities { get; }
    public IIdentity Identity { get; }
    public static Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> PrimaryIdentitySelector { get; public set; }
    public ClaimsPrincipal(IEnumerable`1<ClaimsIdentity> identities);
    public ClaimsPrincipal(BinaryReader reader);
    protected ClaimsPrincipal(SerializationInfo info, StreamingContext context);
    public ClaimsPrincipal(IIdentity identity);
    public ClaimsPrincipal(IPrincipal principal);
    public virtual IEnumerable`1<Claim> get_Claims();
    public static Func`1<ClaimsPrincipal> get_ClaimsPrincipalSelector();
    public static void set_ClaimsPrincipalSelector(Func`1<ClaimsPrincipal> value);
    public static ClaimsPrincipal get_Current();
    protected virtual Byte[] get_CustomSerializationData();
    public virtual IEnumerable`1<ClaimsIdentity> get_Identities();
    public virtual IIdentity get_Identity();
    public static Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> get_PrimaryIdentitySelector();
    public static void set_PrimaryIdentitySelector(Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> value);
    public virtual void AddIdentities(IEnumerable`1<ClaimsIdentity> identities);
    public virtual void AddIdentity(ClaimsIdentity identity);
    public virtual ClaimsPrincipal Clone();
    protected virtual ClaimsIdentity CreateClaimsIdentity(BinaryReader reader);
    public virtual IEnumerable`1<Claim> FindAll(Predicate`1<Claim> match);
    public virtual IEnumerable`1<Claim> FindAll(string type);
    public virtual Claim FindFirst(Predicate`1<Claim> match);
    public virtual Claim FindFirst(string type);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool HasClaim(Predicate`1<Claim> match);
    public virtual bool HasClaim(string type, string value);
    public virtual bool IsInRole(string role);
    public virtual void WriteTo(BinaryWriter writer);
    protected virtual void WriteTo(BinaryWriter writer, Byte[] userData);
}
public static class System.Security.Claims.ClaimTypes : object {
    public static string Actor;
    public static string Anonymous;
    public static string Authentication;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string AuthorizationDecision;
    public static string CookiePath;
    public static string Country;
    public static string DateOfBirth;
    public static string DenyOnlyPrimaryGroupSid;
    public static string DenyOnlyPrimarySid;
    public static string DenyOnlySid;
    public static string DenyOnlyWindowsDeviceGroup;
    public static string Dns;
    public static string Dsa;
    public static string Email;
    public static string Expiration;
    public static string Expired;
    public static string Gender;
    public static string GivenName;
    public static string GroupSid;
    public static string Hash;
    public static string HomePhone;
    public static string IsPersistent;
    public static string Locality;
    public static string MobilePhone;
    public static string Name;
    public static string NameIdentifier;
    public static string OtherPhone;
    public static string PostalCode;
    public static string PrimaryGroupSid;
    public static string PrimarySid;
    public static string Role;
    public static string Rsa;
    public static string SerialNumber;
    public static string Sid;
    public static string Spn;
    public static string StateOrProvince;
    public static string StreetAddress;
    public static string Surname;
    public static string System;
    public static string Thumbprint;
    public static string Upn;
    public static string Uri;
    public static string UserData;
    public static string Version;
    public static string Webpage;
    public static string WindowsAccountName;
    public static string WindowsDeviceClaim;
    public static string WindowsDeviceGroup;
    public static string WindowsFqbnVersion;
    public static string WindowsSubAuthority;
    public static string WindowsUserClaim;
    public static string X500DistinguishedName;
}
public static class System.Security.Claims.ClaimValueTypes : object {
    public static string Base64Binary;
    public static string Base64Octet;
    public static string Boolean;
    public static string Date;
    public static string DateTime;
    public static string DaytimeDuration;
    public static string DnsName;
    public static string Double;
    public static string DsaKeyValue;
    public static string Email;
    public static string Fqbn;
    public static string HexBinary;
    public static string Integer;
    public static string Integer32;
    public static string Integer64;
    public static string KeyInfo;
    public static string Rfc822Name;
    public static string Rsa;
    public static string RsaKeyValue;
    public static string Sid;
    public static string String;
    public static string Time;
    public static string UInteger32;
    public static string UInteger64;
    public static string UpnName;
    public static string X500Name;
    public static string YearMonthDuration;
}
public abstract class System.Security.Cryptography.Aes : SymmetricAlgorithm {
    public static Aes Create();
    public static Aes Create(string algorithmName);
}
public class System.Security.Cryptography.AesCcm : object {
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public AesCcm(Byte[] key);
    public AesCcm(ReadOnlySpan`1<byte> key);
    public static KeySizes get_NonceByteSizes();
    public static KeySizes get_TagByteSizes();
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.AesCryptoServiceProvider : Aes {
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public class System.Security.Cryptography.AesGcm : object {
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public AesGcm(Byte[] key);
    public AesGcm(ReadOnlySpan`1<byte> key);
    public static KeySizes get_NonceByteSizes();
    public static KeySizes get_TagByteSizes();
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.AesManaged : Aes {
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public class System.Security.Cryptography.AsnEncodedData : object {
    public Oid Oid { get; public set; }
    public Byte[] RawData { get; public set; }
    public AsnEncodedData(Byte[] rawData);
    public AsnEncodedData(AsnEncodedData asnEncodedData);
    public AsnEncodedData(Oid oid, Byte[] rawData);
    public AsnEncodedData(string oid, Byte[] rawData);
    public Oid get_Oid();
    public void set_Oid(Oid value);
    public Byte[] get_RawData();
    public void set_RawData(Byte[] value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public virtual string Format(bool multiLine);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.AsnEncodedDataCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public AsnEncodedData Item { get; }
    public object SyncRoot { get; }
    public AsnEncodedDataCollection(AsnEncodedData asnEncodedData);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public AsnEncodedData get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public int Add(AsnEncodedData asnEncodedData);
    public void CopyTo(AsnEncodedData[] array, int index);
    public AsnEncodedDataEnumerator GetEnumerator();
    public void Remove(AsnEncodedData asnEncodedData);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.AsnEncodedDataEnumerator : object {
    public AsnEncodedData Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public AsnEncodedData get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public abstract class System.Security.Cryptography.AsymmetricAlgorithm : object {
    protected int KeySizeValue;
    protected KeySizes[] LegalKeySizesValue;
    public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual string get_SignatureAlgorithm();
    public void Clear();
    public static AsymmetricAlgorithm Create();
    public static AsymmetricAlgorithm Create(string algName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual Byte[] ExportPkcs8PrivateKey();
    public virtual Byte[] ExportSubjectPublicKeyInfo();
    public virtual void FromXmlString(string xmlString);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
    public string Parameters { get; public set; }
    public abstract virtual string get_Parameters();
    public abstract virtual void set_Parameters(string value);
    public abstract virtual Byte[] DecryptKeyExchange(Byte[] rgb);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
}
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
    public string Parameters { get; }
    public abstract virtual string get_Parameters();
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data, Type symAlgType);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
}
public abstract class System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
    public abstract virtual void SetHashAlgorithm(string strName);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    public virtual bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature);
}
public abstract class System.Security.Cryptography.AsymmetricSignatureFormatter : object {
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual Byte[] CreateSignature(HashAlgorithm hash);
    public abstract virtual void SetHashAlgorithm(string strName);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
}
public enum System.Security.Cryptography.CipherMode : Enum {
    public int value__;
    public static CipherMode CBC;
    [EditorBrowsableAttribute("1")]
public static CipherMode CFB;
    public static CipherMode CTS;
    public static CipherMode ECB;
    [EditorBrowsableAttribute("1")]
public static CipherMode OFB;
}
public class System.Security.Cryptography.CryptoConfig : object {
    public static bool AllowOnlyFipsAlgorithms { get; }
    public static bool get_AllowOnlyFipsAlgorithms();
    public static void AddAlgorithm(Type algorithm, String[] names);
    public static void AddOID(string oid, String[] names);
    public static object CreateFromName(string name);
    public static object CreateFromName(string name, Object[] args);
    public static Byte[] EncodeOID(string str);
    public static string MapNameToOID(string name);
}
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(int hr);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
    public CryptographicException(string message);
    public CryptographicException(string message, Exception inner);
    public CryptographicException(string format, string insert);
}
public static class System.Security.Cryptography.CryptographicOperations : object {
    public static bool FixedTimeEquals(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static void ZeroMemory(Span`1<byte> buffer);
}
public class System.Security.Cryptography.CryptographicUnexpectedOperationException : CryptographicException {
    protected CryptographicUnexpectedOperationException(SerializationInfo info, StreamingContext context);
    public CryptographicUnexpectedOperationException(string message);
    public CryptographicUnexpectedOperationException(string message, Exception inner);
    public CryptographicUnexpectedOperationException(string format, string insert);
}
public class System.Security.Cryptography.CryptoStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool HasFlushedFinalBlock { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public bool get_HasFlushedFinalBlock();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public void FlushFinalBlock();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public enum System.Security.Cryptography.CryptoStreamMode : Enum {
    public int value__;
    public static CryptoStreamMode Read;
    public static CryptoStreamMode Write;
}
public class System.Security.Cryptography.CspKeyContainerInfo : object {
    public bool Accessible { get; }
    public bool Exportable { get; }
    public bool HardwareDevice { get; }
    public string KeyContainerName { get; }
    public KeyNumber KeyNumber { get; }
    public bool MachineKeyStore { get; }
    public bool Protected { get; }
    public string ProviderName { get; }
    public int ProviderType { get; }
    public bool RandomlyGenerated { get; }
    public bool Removable { get; }
    public string UniqueKeyContainerName { get; }
    public CspKeyContainerInfo(CspParameters parameters);
    public bool get_Accessible();
    public bool get_Exportable();
    public bool get_HardwareDevice();
    public string get_KeyContainerName();
    public KeyNumber get_KeyNumber();
    public bool get_MachineKeyStore();
    public bool get_Protected();
    public string get_ProviderName();
    public int get_ProviderType();
    public bool get_RandomlyGenerated();
    public bool get_Removable();
    public string get_UniqueKeyContainerName();
}
public class System.Security.Cryptography.CspParameters : object {
    public string KeyContainerName;
    public int KeyNumber;
    public string ProviderName;
    public int ProviderType;
    public CspProviderFlags Flags { get; public set; }
    [CLSCompliantAttribute("False")]
public SecureString KeyPassword { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CspParameters(int dwTypeIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
    public CspProviderFlags get_Flags();
    public void set_Flags(CspProviderFlags value);
    public SecureString get_KeyPassword();
    public void set_KeyPassword(SecureString value);
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CspProviderFlags : Enum {
    public int value__;
    public static CspProviderFlags CreateEphemeralKey;
    public static CspProviderFlags NoFlags;
    public static CspProviderFlags NoPrompt;
    public static CspProviderFlags UseArchivableKey;
    public static CspProviderFlags UseDefaultKeyContainer;
    public static CspProviderFlags UseExistingKey;
    public static CspProviderFlags UseMachineKeyStore;
    public static CspProviderFlags UseNonExportableKey;
    public static CspProviderFlags UseUserProtectedKey;
}
public abstract class System.Security.Cryptography.DeriveBytes : object {
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual Byte[] GetBytes(int cb);
    public abstract virtual void Reset();
}
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.DES : SymmetricAlgorithm {
    public Byte[] Key { get; public set; }
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static DES Create();
    public static DES Create(string algName);
    public static bool IsSemiWeakKey(Byte[] rgbKey);
    public static bool IsWeakKey(Byte[] rgbKey);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.DESCryptoServiceProvider : DES {
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public abstract class System.Security.Cryptography.DSA : AsymmetricAlgorithm {
    public static DSA Create();
    public static DSA Create(int keySizeInBits);
    public static DSA Create(DSAParameters parameters);
    public static DSA Create(string algName);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    public abstract virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void FromXmlString(string xmlString);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public abstract virtual void ImportParameters(DSAParameters parameters);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
}
public class System.Security.Cryptography.DSACryptoServiceProvider : DSA {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    public DSACryptoServiceProvider(int dwKeySize);
    public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    public DSACryptoServiceProvider(CspParameters parameters);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual KeySizes[] get_LegalKeySizes();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    protected virtual void Dispose(bool disposing);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public virtual void ImportParameters(DSAParameters parameters);
    public Byte[] SignData(Byte[] buffer);
    public Byte[] SignData(Byte[] buffer, int offset, int count);
    public Byte[] SignData(Stream inputStream);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public class System.Security.Cryptography.DSAParameters : ValueType {
    public int Counter;
    public Byte[] G;
    public Byte[] J;
    public Byte[] P;
    public Byte[] Q;
    public Byte[] Seed;
    public Byte[] X;
    public Byte[] Y;
}
public class System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
    public DSASignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public class System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
    public DSASignatureFormatter(AsymmetricAlgorithm key);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.ECCurve : ValueType {
    private object _dummy;
    public Byte[] A;
    public Byte[] B;
    public Byte[] Cofactor;
    public ECCurveType CurveType;
    public ECPoint G;
    public Nullable`1<HashAlgorithmName> Hash;
    public Byte[] Order;
    public Byte[] Polynomial;
    public Byte[] Prime;
    public Byte[] Seed;
    public bool IsCharacteristic2 { get; }
    public bool IsExplicit { get; }
    public bool IsNamed { get; }
    public bool IsPrime { get; }
    public Oid Oid { get; }
    public bool get_IsCharacteristic2();
    public bool get_IsExplicit();
    public bool get_IsNamed();
    public bool get_IsPrime();
    public Oid get_Oid();
    public static ECCurve CreateFromFriendlyName(string oidFriendlyName);
    public static ECCurve CreateFromOid(Oid curveOid);
    public static ECCurve CreateFromValue(string oidValue);
    public void Validate();
}
public abstract class System.Security.Cryptography.ECDiffieHellman : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public string SignatureAlgorithm { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public abstract virtual ECDiffieHellmanPublicKey get_PublicKey();
    public virtual string get_SignatureAlgorithm();
    public static ECDiffieHellman Create();
    public static ECDiffieHellman Create(ECCurve curve);
    public static ECDiffieHellman Create(ECParameters parameters);
    public static ECDiffieHellman Create(string algorithm);
    public Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    public Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey);
    public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    public virtual Byte[] ExportECPrivateKey();
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual void FromXmlString(string xmlString);
    public virtual void GenerateKey(ECCurve curve);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.ECDiffieHellmanPublicKey : object {
    protected ECDiffieHellmanPublicKey(Byte[] keyBlob);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ECParameters ExportExplicitParameters();
    public virtual ECParameters ExportParameters();
    public virtual Byte[] ToByteArray();
    public virtual string ToXmlString();
}
public abstract class System.Security.Cryptography.ECDsa : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static ECDsa Create();
    public static ECDsa Create(ECCurve curve);
    public static ECDsa Create(ECParameters parameters);
    public static ECDsa Create(string algorithm);
    public virtual Byte[] ExportECPrivateKey();
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual void FromXmlString(string xmlString);
    public virtual void GenerateKey(ECCurve curve);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignHash(Byte[] hash);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public abstract virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
}
public class System.Security.Cryptography.ECParameters : ValueType {
    public ECCurve Curve;
    public Byte[] D;
    public ECPoint Q;
    public void Validate();
}
public class System.Security.Cryptography.ECPoint : ValueType {
    public Byte[] X;
    public Byte[] Y;
}
public class System.Security.Cryptography.FromBase64Transform : object {
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public FromBase64Transform(FromBase64TransformMode whitespaces);
    public virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public enum System.Security.Cryptography.FromBase64TransformMode : Enum {
    public int value__;
    public static FromBase64TransformMode DoNotIgnoreWhiteSpaces;
    public static FromBase64TransformMode IgnoreWhiteSpaces;
}
public abstract class System.Security.Cryptography.HashAlgorithm : object {
    protected int HashSizeValue;
    protected internal Byte[] HashValue;
    protected int State;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public Byte[] Hash { get; }
    public int HashSize { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public virtual bool get_CanReuseTransform();
    public virtual bool get_CanTransformMultipleBlocks();
    public virtual Byte[] get_Hash();
    public virtual int get_HashSize();
    public virtual int get_InputBlockSize();
    public virtual int get_OutputBlockSize();
    public void Clear();
    public Byte[] ComputeHash(Byte[] buffer);
    public Byte[] ComputeHash(Byte[] buffer, int offset, int count);
    public Byte[] ComputeHash(Stream inputStream);
    public static HashAlgorithm Create();
    public static HashAlgorithm Create(string hashName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected abstract virtual Byte[] HashFinal();
    public abstract virtual void Initialize();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public bool TryComputeHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[IsReadOnlyAttribute]
public class System.Security.Cryptography.HashAlgorithmName : ValueType {
    private object _dummy;
    public static HashAlgorithmName MD5 { get; }
    public string Name { get; }
    public static HashAlgorithmName SHA1 { get; }
    public static HashAlgorithmName SHA256 { get; }
    public static HashAlgorithmName SHA384 { get; }
    public static HashAlgorithmName SHA512 { get; }
    public HashAlgorithmName(string name);
    public static HashAlgorithmName get_MD5();
    public string get_Name();
    public static HashAlgorithmName get_SHA1();
    public static HashAlgorithmName get_SHA256();
    public static HashAlgorithmName get_SHA384();
    public static HashAlgorithmName get_SHA512();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashAlgorithmName other);
    public virtual int GetHashCode();
    public static bool op_Equality(HashAlgorithmName left, HashAlgorithmName right);
    public static bool op_Inequality(HashAlgorithmName left, HashAlgorithmName right);
    public virtual string ToString();
}
public abstract class System.Security.Cryptography.HMAC : KeyedHashAlgorithm {
    protected int BlockSizeValue { get; protected set; }
    public string HashName { get; public set; }
    public Byte[] Key { get; public set; }
    protected int get_BlockSizeValue();
    protected void set_BlockSizeValue(int value);
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static HMAC Create();
    public static HMAC Create(string algorithmName);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.HMACMD5 : HMAC {
    public Byte[] Key { get; public set; }
    public HMACMD5(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.HMACSHA1 : HMAC {
    public Byte[] Key { get; public set; }
    public HMACSHA1(Byte[] key);
    [EditorBrowsableAttribute("1")]
public HMACSHA1(Byte[] key, bool useManagedSha1);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.HMACSHA256 : HMAC {
    public Byte[] Key { get; public set; }
    public HMACSHA256(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.HMACSHA384 : HMAC {
    public Byte[] Key { get; public set; }
    public bool ProduceLegacyHmacValues { get; public set; }
    public HMACSHA384(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.HMACSHA512 : HMAC {
    public Byte[] Key { get; public set; }
    public bool ProduceLegacyHmacValues { get; public set; }
    public HMACSHA512(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public interface System.Security.Cryptography.ICryptoTransform {
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public abstract virtual bool get_CanReuseTransform();
    public abstract virtual bool get_CanTransformMultipleBlocks();
    public abstract virtual int get_InputBlockSize();
    public abstract virtual int get_OutputBlockSize();
    public abstract virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public abstract virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public interface System.Security.Cryptography.ICspAsymmetricAlgorithm {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public abstract virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual void ImportCspBlob(Byte[] rawData);
}
public class System.Security.Cryptography.IncrementalHash : object {
    public HashAlgorithmName AlgorithmName { get; }
    public HashAlgorithmName get_AlgorithmName();
    public void AppendData(Byte[] data);
    public void AppendData(Byte[] data, int offset, int count);
    public void AppendData(ReadOnlySpan`1<byte> data);
    public static IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm);
    public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, Byte[] key);
    public sealed virtual void Dispose();
    public Byte[] GetHashAndReset();
    public bool TryGetHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.KeyedHashAlgorithm : HashAlgorithm {
    protected Byte[] KeyValue;
    public Byte[] Key { get; public set; }
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static KeyedHashAlgorithm Create();
    public static KeyedHashAlgorithm Create(string algName);
    protected virtual void Dispose(bool disposing);
}
public enum System.Security.Cryptography.KeyNumber : Enum {
    public int value__;
    public static KeyNumber Exchange;
    public static KeyNumber Signature;
}
public class System.Security.Cryptography.KeySizes : object {
    public int MaxSize { get; }
    public int MinSize { get; }
    public int SkipSize { get; }
    public KeySizes(int minSize, int maxSize, int skipSize);
    public int get_MaxSize();
    public int get_MinSize();
    public int get_SkipSize();
}
public abstract class System.Security.Cryptography.MaskGenerationMethod : object {
    public abstract virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
public abstract class System.Security.Cryptography.MD5 : HashAlgorithm {
    public static MD5 Create();
    public static MD5 Create(string algName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.Oid : object {
    public string FriendlyName { get; public set; }
    public string Value { get; public set; }
    public Oid(Oid oid);
    public Oid(string oid);
    public Oid(string value, string friendlyName);
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public string get_Value();
    public void set_Value(string value);
    public static Oid FromFriendlyName(string friendlyName, OidGroup group);
    public static Oid FromOidValue(string oidValue, OidGroup group);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.OidCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public Oid Item { get; }
    public Oid Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public Oid get_Item(int index);
    public Oid get_Item(string oid);
    public sealed virtual object get_SyncRoot();
    public int Add(Oid oid);
    public void CopyTo(Oid[] array, int index);
    public OidEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.OidEnumerator : object {
    public Oid Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public Oid get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.OidGroup : Enum {
    public int value__;
    public static OidGroup All;
    public static OidGroup Attribute;
    public static OidGroup EncryptionAlgorithm;
    public static OidGroup EnhancedKeyUsage;
    public static OidGroup ExtensionOrAttribute;
    public static OidGroup HashAlgorithm;
    public static OidGroup KeyDerivationFunction;
    public static OidGroup Policy;
    public static OidGroup PublicKeyAlgorithm;
    public static OidGroup SignatureAlgorithm;
    public static OidGroup Template;
}
public enum System.Security.Cryptography.PaddingMode : Enum {
    public int value__;
    public static PaddingMode ANSIX923;
    public static PaddingMode ISO10126;
    public static PaddingMode None;
    public static PaddingMode PKCS7;
    public static PaddingMode Zeros;
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
    public string HashName { get; public set; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    public PasswordDeriveBytes(Byte[] password, Byte[] salt);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, CspParameters cspParams);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, CspParameters cspParams);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams);
    public string get_HashName();
    public void set_HashName(string value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    [ObsoleteAttribute("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")]
public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
}
public enum System.Security.Cryptography.PbeEncryptionAlgorithm : Enum {
    public int value__;
    public static PbeEncryptionAlgorithm Aes128Cbc;
    public static PbeEncryptionAlgorithm Aes192Cbc;
    public static PbeEncryptionAlgorithm Aes256Cbc;
    public static PbeEncryptionAlgorithm TripleDes3KeyPkcs12;
    public static PbeEncryptionAlgorithm Unknown;
}
public class System.Security.Cryptography.PbeParameters : object {
    public PbeEncryptionAlgorithm EncryptionAlgorithm { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; }
    public PbeParameters(PbeEncryptionAlgorithm encryptionAlgorithm, HashAlgorithmName hashAlgorithm, int iterationCount);
    public PbeEncryptionAlgorithm get_EncryptionAlgorithm();
    public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
}
public class System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
    public string HashName { get; public set; }
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
public abstract class System.Security.Cryptography.RandomNumberGenerator : object {
    public static RandomNumberGenerator Create();
    public static RandomNumberGenerator Create(string rngName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static void Fill(Span`1<byte> data);
    public abstract virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public virtual void GetBytes(Span`1<byte> data);
    public static int GetInt32(int toExclusive);
    public static int GetInt32(int fromInclusive, int toExclusive);
    public virtual void GetNonZeroBytes(Byte[] data);
    public virtual void GetNonZeroBytes(Span`1<byte> data);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.RC2 : SymmetricAlgorithm {
    protected int EffectiveKeySizeValue;
    public int EffectiveKeySize { get; public set; }
    public int KeySize { get; public set; }
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public static RC2 Create();
    public static RC2 Create(string AlgName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
    public int EffectiveKeySize { get; public set; }
    public bool UseSalt { get; public set; }
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public bool get_UseSalt();
    public void set_UseSalt(bool value);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public class System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    public Rfc2898DeriveBytes(string password, Byte[] salt);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    public Rfc2898DeriveBytes(string password, int saltSize);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations, HashAlgorithmName hashAlgorithm);
    public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
}
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
    public static Rijndael Create();
    public static Rijndael Create(string algName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RijndaelManaged : Rijndael {
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
    public RNGCryptoServiceProvider(Byte[] rgb);
    public RNGCryptoServiceProvider(CspParameters cspParams);
    public RNGCryptoServiceProvider(string str);
    protected virtual void Dispose(bool disposing);
    public virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    public virtual void GetNonZeroBytes(Span`1<byte> data);
}
public abstract class System.Security.Cryptography.RSA : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static RSA Create();
    public static RSA Create(int keySizeInBits);
    public static RSA Create(RSAParameters parameters);
    public static RSA Create(string algName);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual Byte[] ExportRSAPrivateKey();
    public virtual Byte[] ExportRSAPublicKey();
    public virtual void FromXmlString(string xmlString);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public abstract virtual void ImportParameters(RSAParameters parameters);
    public virtual void ImportRSAPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportRSAPublicKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryExportRSAPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportRSAPublicKey(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
}
public class System.Security.Cryptography.RSACryptoServiceProvider : RSA {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    public RSACryptoServiceProvider(int dwKeySize);
    public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    public RSACryptoServiceProvider(CspParameters parameters);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual KeySizes[] get_LegalKeySizes();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    public Byte[] Decrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] DecryptValue(Byte[] rgb);
    protected virtual void Dispose(bool disposing);
    public Byte[] Encrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public virtual void ImportParameters(RSAParameters parameters);
    public Byte[] SignData(Byte[] buffer, int offset, int count, object halg);
    public Byte[] SignData(Byte[] buffer, object halg);
    public Byte[] SignData(Stream inputStream, object halg);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public bool VerifyData(Byte[] buffer, object halg, Byte[] signature);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
}
public class System.Security.Cryptography.RSAEncryptionPadding : object {
    public RSAEncryptionPaddingMode Mode { get; }
    public HashAlgorithmName OaepHashAlgorithm { get; }
    public static RSAEncryptionPadding OaepSHA1 { get; }
    public static RSAEncryptionPadding OaepSHA256 { get; }
    public static RSAEncryptionPadding OaepSHA384 { get; }
    public static RSAEncryptionPadding OaepSHA512 { get; }
    public static RSAEncryptionPadding Pkcs1 { get; }
    public RSAEncryptionPaddingMode get_Mode();
    public HashAlgorithmName get_OaepHashAlgorithm();
    public static RSAEncryptionPadding get_OaepSHA1();
    public static RSAEncryptionPadding get_OaepSHA256();
    public static RSAEncryptionPadding get_OaepSHA384();
    public static RSAEncryptionPadding get_OaepSHA512();
    public static RSAEncryptionPadding get_Pkcs1();
    public static RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RSAEncryptionPadding other);
    public virtual int GetHashCode();
    public static bool op_Equality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public static bool op_Inequality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSAEncryptionPaddingMode : Enum {
    public int value__;
    public static RSAEncryptionPaddingMode Oaep;
    public static RSAEncryptionPaddingMode Pkcs1;
}
public class System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    public string Parameters { get; public set; }
    public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbData);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    public Byte[] Parameter { get; public set; }
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
    public Byte[] get_Parameter();
    public void set_Parameter(Byte[] value);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.RSAParameters : ValueType {
    public Byte[] D;
    public Byte[] DP;
    public Byte[] DQ;
    public Byte[] Exponent;
    public Byte[] InverseQ;
    public Byte[] Modulus;
    public Byte[] P;
    public Byte[] Q;
}
public class System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    public string Parameters { get; public set; }
    public RandomNumberGenerator RNG { get; public set; }
    public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public RandomNumberGenerator get_RNG();
    public void set_RNG(RandomNumberGenerator value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbIn);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
    public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public class System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
    public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.RSASignaturePadding : object {
    public RSASignaturePaddingMode Mode { get; }
    public static RSASignaturePadding Pkcs1 { get; }
    public static RSASignaturePadding Pss { get; }
    public RSASignaturePaddingMode get_Mode();
    public static RSASignaturePadding get_Pkcs1();
    public static RSASignaturePadding get_Pss();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RSASignaturePadding other);
    public virtual int GetHashCode();
    public static bool op_Equality(RSASignaturePadding left, RSASignaturePadding right);
    public static bool op_Inequality(RSASignaturePadding left, RSASignaturePadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSASignaturePaddingMode : Enum {
    public int value__;
    public static RSASignaturePaddingMode Pkcs1;
    public static RSASignaturePaddingMode Pss;
}
public abstract class System.Security.Cryptography.SHA1 : HashAlgorithm {
    public static SHA1 Create();
    public static SHA1 Create(string hashName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA1Managed : SHA1 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA256 : HashAlgorithm {
    public static SHA256 Create();
    public static SHA256 Create(string hashName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA256Managed : SHA256 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA384 : HashAlgorithm {
    public static SHA384 Create();
    public static SHA384 Create(string hashName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA384Managed : SHA384 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA512 : HashAlgorithm {
    public static SHA512 Create();
    public static SHA512 Create(string hashName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA512Managed : SHA512 {
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.SignatureDescription : object {
    public string DeformatterAlgorithm { get; public set; }
    public string DigestAlgorithm { get; public set; }
    public string FormatterAlgorithm { get; public set; }
    public string KeyAlgorithm { get; public set; }
    public SignatureDescription(SecurityElement el);
    public string get_DeformatterAlgorithm();
    public void set_DeformatterAlgorithm(string value);
    public string get_DigestAlgorithm();
    public void set_DigestAlgorithm(string value);
    public string get_FormatterAlgorithm();
    public void set_FormatterAlgorithm(string value);
    public string get_KeyAlgorithm();
    public void set_KeyAlgorithm(string value);
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public virtual HashAlgorithm CreateDigest();
    public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
}
public abstract class System.Security.Cryptography.SymmetricAlgorithm : object {
    protected int BlockSizeValue;
    protected int FeedbackSizeValue;
    protected Byte[] IVValue;
    protected int KeySizeValue;
    protected Byte[] KeyValue;
    protected KeySizes[] LegalBlockSizesValue;
    protected KeySizes[] LegalKeySizesValue;
    protected CipherMode ModeValue;
    protected PaddingMode PaddingValue;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public void Clear();
    public static SymmetricAlgorithm Create();
    public static SymmetricAlgorithm Create(string algName);
    public virtual ICryptoTransform CreateDecryptor();
    public abstract virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public abstract virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void GenerateIV();
    public abstract virtual void GenerateKey();
    public bool ValidKeySize(int bitLength);
}
public class System.Security.Cryptography.ToBase64Transform : object {
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public abstract class System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
    public Byte[] Key { get; public set; }
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static TripleDES Create();
    public static TripleDES Create(string str);
    public static bool IsWeakKey(Byte[] rgbKey);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public class System.Security.Cryptography.X509Certificates.CertificateRequest : object {
    public Collection`1<X509Extension> CertificateExtensions { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public PublicKey PublicKey { get; }
    public X500DistinguishedName SubjectName { get; }
    public CertificateRequest(X500DistinguishedName subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Collection`1<X509Extension> get_CertificateExtensions();
    public HashAlgorithmName get_HashAlgorithm();
    public PublicKey get_PublicKey();
    public X500DistinguishedName get_SubjectName();
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 CreateSelfSigned(DateTimeOffset notBefore, DateTimeOffset notAfter);
    public Byte[] CreateSigningRequest();
    public Byte[] CreateSigningRequest(X509SignatureGenerator signatureGenerator);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.DSACertificateExtensions : object {
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, DSA privateKey);
    [ExtensionAttribute]
public static DSA GetDSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static DSA GetDSAPublicKey(X509Certificate2 certificate);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, ECDsa privateKey);
    [ExtensionAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags IncludeArchived;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
}
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    public AsnEncodedData EncodedKeyValue { get; }
    public AsnEncodedData EncodedParameters { get; }
    public AsymmetricAlgorithm Key { get; }
    public Oid Oid { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    public AsnEncodedData get_EncodedKeyValue();
    public AsnEncodedData get_EncodedParameters();
    public AsymmetricAlgorithm get_Key();
    public Oid get_Oid();
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, RSA privateKey);
    [ExtensionAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
public class System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder : object {
    public void AddDnsName(string dnsName);
    public void AddEmailAddress(string emailAddress);
    public void AddIpAddress(IPAddress ipAddress);
    public void AddUri(Uri uri);
    public void AddUserPrincipalName(string upn);
    public X509Extension Build(bool critical);
}
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    public string Name { get; }
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
}
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public X509Certificate(Byte[] data);
    [CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password);
    [CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(Byte[] rawData, string password);
    public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(IntPtr handle);
    public X509Certificate(SerializationInfo info, StreamingContext context);
    public X509Certificate(X509Certificate cert);
    public X509Certificate(string fileName);
    [CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password);
    [CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(string fileName, string password);
    public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public IntPtr get_Handle();
    public string get_Issuer();
    public string get_Subject();
    public static X509Certificate CreateFromCertFile(string filename);
    public static X509Certificate CreateFromSignedFile(string filename);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool Equals(object obj);
    public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    [CLSCompliantAttribute("False")]
public virtual Byte[] Export(X509ContentType contentType, SecureString password);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    protected static string FormatDate(DateTime date);
    public virtual Byte[] GetCertHash();
    public virtual Byte[] GetCertHash(HashAlgorithmName hashAlgorithm);
    public virtual string GetCertHashString();
    public virtual string GetCertHashString(HashAlgorithmName hashAlgorithm);
    public virtual string GetEffectiveDateString();
    public virtual string GetExpirationDateString();
    public virtual string GetFormat();
    public virtual int GetHashCode();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Issuer property instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetIssuerName();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Subject property instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetName();
    public virtual Byte[] GetPublicKey();
    public virtual string GetPublicKeyString();
    public virtual Byte[] GetRawCertData();
    public virtual string GetRawCertDataString();
    public virtual Byte[] GetSerialNumber();
    public virtual string GetSerialNumberString();
    public virtual void Import(Byte[] rawData);
    [CLSCompliantAttribute("False")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName);
    [CLSCompliantAttribute("False")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Reset();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    public virtual bool TryGetCertHash(HashAlgorithmName hashAlgorithm, Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    public X509Certificate2(Byte[] rawData);
    [CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password);
    [CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(Byte[] rawData, string password);
    public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(IntPtr handle);
    protected X509Certificate2(SerializationInfo info, StreamingContext context);
    public X509Certificate2(X509Certificate certificate);
    public X509Certificate2(string fileName);
    [CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password);
    [CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(string fileName, string password);
    public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public bool get_Archived();
    public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public AsymmetricAlgorithm get_PrivateKey();
    public void set_PrivateKey(AsymmetricAlgorithm value);
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    public static X509ContentType GetCertContentType(Byte[] rawData);
    public static X509ContentType GetCertContentType(string fileName);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual void Import(Byte[] rawData);
    [CLSCompliantAttribute("False")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName);
    [CLSCompliantAttribute("False")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Reset();
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    public bool Verify();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void AddRange(X509Certificate2[] certificates);
    public bool Contains(X509Certificate2 certificate);
    public Byte[] Export(X509ContentType contentType);
    public Byte[] Export(X509ContentType contentType, string password);
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    public void Import(Byte[] rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
    public void RemoveRange(X509Certificate2[] certificates);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    public X509Certificate2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    public void Reset();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509CertificateCollection value);
    public X509CertificateCollection(X509Certificate[] value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509CertificateCollection value);
    public void AddRange(X509Certificate[] value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    protected virtual void OnValidate(object value);
    public void Remove(X509Certificate value);
}
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    public IntPtr ChainContext { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public X509Chain(bool useMachineContext);
    public X509Chain(IntPtr chainContext);
    public IntPtr get_ChainContext();
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public SafeX509ChainHandle get_SafeHandle();
    public bool Build(X509Certificate2 certificate);
    public static X509Chain Create();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    public X509Certificate2 Certificate { get; }
    public X509ChainStatus[] ChainElementStatus { get; }
    public string Information { get; }
    public X509Certificate2 get_Certificate();
    public X509ChainStatus[] get_ChainElementStatus();
    public string get_Information();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public X509ChainElement Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public X509ChainElement get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public void CopyTo(X509ChainElement[] array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    public X509ChainElement Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    public OidCollection ApplicationPolicy { get; }
    public OidCollection CertificatePolicy { get; }
    public X509Certificate2Collection ExtraStore { get; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public OidCollection get_ApplicationPolicy();
    public OidCollection get_CertificatePolicy();
    public X509Certificate2Collection get_ExtraStore();
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public TimeSpan get_UrlRetrievalTimeout();
    public void set_UrlRetrievalTimeout(TimeSpan value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    public DateTime get_VerificationTime();
    public void set_VerificationTime(DateTime value);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    private object _dummy;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    public X509ChainStatusFlags get_Status();
    public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasWeakSignature;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags UntrustedRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Authenticode;
    public static X509ContentType Cert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType Pkcs7;
    public static X509ContentType SerializedCert;
    public static X509ContentType SerializedStore;
    public static X509ContentType Unknown;
}
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    public bool get_Critical();
    public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public X509Extension Item { get; }
    public X509Extension Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public sealed virtual object get_SyncRoot();
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    public X509Extension Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindBySubjectKeyIdentifier;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeValid;
}
public enum System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
    public int value__;
    public static X509IncludeOption EndCertOnly;
    public static X509IncludeOption ExcludeRoot;
    public static X509IncludeOption None;
    public static X509IncludeOption WholeChain;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags EphemeralKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags PersistKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags UserProtected;
}
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags DecipherOnly;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags NonRepudiation;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType DnsName;
    public static X509NameType EmailName;
    public static X509NameType SimpleName;
    public static X509NameType UpnName;
    public static X509NameType UrlName;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Offline;
    public static X509RevocationMode Online;
}
public abstract class System.Security.Cryptography.X509Certificates.X509SignatureGenerator : object {
    public PublicKey PublicKey { get; }
    public PublicKey get_PublicKey();
    protected abstract virtual PublicKey BuildPublicKey();
    public static X509SignatureGenerator CreateForECDsa(ECDsa key);
    public static X509SignatureGenerator CreateForRSA(RSA key, RSASignaturePadding signaturePadding);
    public abstract virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
}
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    public X509Certificate2Collection Certificates { get; }
    public bool IsOpen { get; }
    public StoreLocation Location { get; }
    public string Name { get; }
    public IntPtr StoreHandle { get; }
    public X509Store(IntPtr storeHandle);
    public X509Store(StoreLocation storeLocation);
    public X509Store(StoreName storeName);
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(string storeName);
    public X509Store(string storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Certificate2Collection get_Certificates();
    public bool get_IsOpen();
    public StoreLocation get_Location();
    public string get_Name();
    public IntPtr get_StoreHandle();
    public void Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void Close();
    public sealed virtual void Dispose();
    public void Open(OpenFlags flags);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
}
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    public string SubjectKeyIdentifier { get; }
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    public string get_SubjectKeyIdentifier();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags AllFlags;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags NoFlag;
}
public interface System.Security.IPermission {
    public abstract virtual IPermission Copy();
    public abstract virtual void Demand();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
}
public interface System.Security.ISecurityEncodable {
    public abstract virtual void FromXml(SecurityElement e);
    public abstract virtual SecurityElement ToXml();
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
}
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
    protected CodeAccessSecurityAttribute(SecurityAction action);
}
public enum System.Security.Permissions.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Assert;
    public static SecurityAction Demand;
    [ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction Deny;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction LinkDemand;
    public static SecurityAction PermitOnly;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestMinimum;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestOptional;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestRefuse;
}
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.SecurityAttribute : Attribute {
    public SecurityAction Action { get; public set; }
    public bool Unrestricted { get; public set; }
    protected SecurityAttribute(SecurityAction action);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public bool get_Unrestricted();
    public void set_Unrestricted(bool value);
    public abstract virtual IPermission CreatePermission();
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
    public bool Assertion { get; public set; }
    public bool BindingRedirects { get; public set; }
    public bool ControlAppDomain { get; public set; }
    public bool ControlDomainPolicy { get; public set; }
    public bool ControlEvidence { get; public set; }
    public bool ControlPolicy { get; public set; }
    public bool ControlPrincipal { get; public set; }
    public bool ControlThread { get; public set; }
    public bool Execution { get; public set; }
    public SecurityPermissionFlag Flags { get; public set; }
    public bool Infrastructure { get; public set; }
    public bool RemotingConfiguration { get; public set; }
    public bool SerializationFormatter { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public SecurityPermissionAttribute(SecurityAction action);
    public bool get_Assertion();
    public void set_Assertion(bool value);
    public bool get_BindingRedirects();
    public void set_BindingRedirects(bool value);
    public bool get_ControlAppDomain();
    public void set_ControlAppDomain(bool value);
    public bool get_ControlDomainPolicy();
    public void set_ControlDomainPolicy(bool value);
    public bool get_ControlEvidence();
    public void set_ControlEvidence(bool value);
    public bool get_ControlPolicy();
    public void set_ControlPolicy(bool value);
    public bool get_ControlPrincipal();
    public void set_ControlPrincipal(bool value);
    public bool get_ControlThread();
    public void set_ControlThread(bool value);
    public bool get_Execution();
    public void set_Execution(bool value);
    public SecurityPermissionFlag get_Flags();
    public void set_Flags(SecurityPermissionFlag value);
    public bool get_Infrastructure();
    public void set_Infrastructure(bool value);
    public bool get_RemotingConfiguration();
    public void set_RemotingConfiguration(bool value);
    public bool get_SerializationFormatter();
    public void set_SerializationFormatter(bool value);
    public bool get_SkipVerification();
    public void set_SkipVerification(bool value);
    public bool get_UnmanagedCode();
    public void set_UnmanagedCode(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.SecurityPermissionFlag : Enum {
    public int value__;
    public static SecurityPermissionFlag AllFlags;
    public static SecurityPermissionFlag Assertion;
    public static SecurityPermissionFlag BindingRedirects;
    public static SecurityPermissionFlag ControlAppDomain;
    public static SecurityPermissionFlag ControlDomainPolicy;
    public static SecurityPermissionFlag ControlEvidence;
    public static SecurityPermissionFlag ControlPolicy;
    public static SecurityPermissionFlag ControlPrincipal;
    public static SecurityPermissionFlag ControlThread;
    public static SecurityPermissionFlag Execution;
    public static SecurityPermissionFlag Infrastructure;
    public static SecurityPermissionFlag NoFlags;
    public static SecurityPermissionFlag RemotingConfiguration;
    public static SecurityPermissionFlag SerializationFormatter;
    public static SecurityPermissionFlag SkipVerification;
    public static SecurityPermissionFlag UnmanagedCode;
}
public class System.Security.Principal.GenericIdentity : ClaimsIdentity {
    public string AuthenticationType { get; }
    public IEnumerable`1<Claim> Claims { get; }
    public bool IsAuthenticated { get; }
    public string Name { get; }
    protected GenericIdentity(GenericIdentity identity);
    public GenericIdentity(string name);
    public GenericIdentity(string name, string type);
    public virtual string get_AuthenticationType();
    public virtual IEnumerable`1<Claim> get_Claims();
    public virtual bool get_IsAuthenticated();
    public virtual string get_Name();
    public virtual ClaimsIdentity Clone();
}
public class System.Security.Principal.GenericPrincipal : ClaimsPrincipal {
    public IIdentity Identity { get; }
    public GenericPrincipal(IIdentity identity, String[] roles);
    public virtual IIdentity get_Identity();
    public virtual bool IsInRole(string role);
}
public interface System.Security.Principal.IIdentity {
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public string Name { get; }
    public abstract virtual string get_AuthenticationType();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual string get_Name();
}
public interface System.Security.Principal.IPrincipal {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
    public abstract virtual bool IsInRole(string role);
}
public enum System.Security.Principal.PrincipalPolicy : Enum {
    public int value__;
    public static PrincipalPolicy NoPrincipal;
    public static PrincipalPolicy UnauthenticatedPrincipal;
    public static PrincipalPolicy WindowsPrincipal;
}
public enum System.Security.Principal.TokenImpersonationLevel : Enum {
    public int value__;
    public static TokenImpersonationLevel Anonymous;
    public static TokenImpersonationLevel Delegation;
    public static TokenImpersonationLevel Identification;
    public static TokenImpersonationLevel Impersonation;
    public static TokenImpersonationLevel None;
}
public class System.Security.SecureString : object {
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public SecureString(Char* value, int length);
    public int get_Length();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void AppendChar(char c);
    public void Clear();
    public SecureString Copy();
    public sealed virtual void Dispose();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void InsertAt(int index, char c);
    public bool IsReadOnly();
    public void MakeReadOnly();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void RemoveAt(int index);
    [HandleProcessCorruptedStateExceptionsAttribute]
public void SetAt(int index, char c);
}
[EditorBrowsableAttribute("1")]
public static class System.Security.SecureStringMarshal : object {
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Everything;
    public static SecurityCriticalScope Explicit;
}
public class System.Security.SecurityElement : object {
    public Hashtable Attributes { get; public set; }
    public ArrayList Children { get; public set; }
    public string Tag { get; public set; }
    public string Text { get; public set; }
    public SecurityElement(string tag);
    public SecurityElement(string tag, string text);
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    public ArrayList get_Children();
    public void set_Children(ArrayList value);
    public string get_Tag();
    public void set_Tag(string value);
    public string get_Text();
    public void set_Text(string value);
    public void AddAttribute(string name, string value);
    public void AddChild(SecurityElement child);
    public string Attribute(string name);
    public SecurityElement Copy();
    public bool Equal(SecurityElement other);
    public static string Escape(string str);
    public static SecurityElement FromString(string xml);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    public SecurityElement SearchForChildByTag(string tag);
    public string SearchForTextOfTag(string tag);
    public virtual string ToString();
}
public class System.Security.SecurityException : SystemException {
    public object Demanded { get; public set; }
    public object DenySetInstance { get; public set; }
    public AssemblyName FailedAssemblyInfo { get; public set; }
    public string GrantedSet { get; public set; }
    public MethodInfo Method { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public object PermitOnlySetInstance { get; public set; }
    public string RefusedSet { get; public set; }
    public string Url { get; public set; }
    protected SecurityException(SerializationInfo info, StreamingContext context);
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    public object get_Demanded();
    public void set_Demanded(object value);
    public object get_DenySetInstance();
    public void set_DenySetInstance(object value);
    public AssemblyName get_FailedAssemblyInfo();
    public void set_FailedAssemblyInfo(AssemblyName value);
    public string get_GrantedSet();
    public void set_GrantedSet(string value);
    public MethodInfo get_Method();
    public void set_Method(MethodInfo value);
    public string get_PermissionState();
    public void set_PermissionState(string value);
    public Type get_PermissionType();
    public void set_PermissionType(Type value);
    public object get_PermitOnlySetInstance();
    public void set_PermitOnlySetInstance(object value);
    public string get_RefusedSet();
    public void set_RefusedSet(string value);
    public string get_Url();
    public void set_Url(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    public SecurityRuleSet RuleSet { get; }
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    public SecurityRuleSet get_RuleSet();
    public bool get_SkipVerificationInFullTrust();
    public void set_SkipVerificationInFullTrust(bool value);
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
    public static SecurityRuleSet None;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility.  Please use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
public class System.Security.VerificationException : SystemException {
    protected VerificationException(SerializationInfo info, StreamingContext context);
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.SequencePosition : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public SequencePosition(object object, int integer);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SequencePosition other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public int GetInteger();
    [EditorBrowsableAttribute("1")]
public object GetObject();
}
[AttributeUsageAttribute("4124")]
public class System.SerializableAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Single : ValueType {
    private float _dummyPrimitive;
    public static float Epsilon;
    public static float MaxValue;
    public static float MinValue;
    public static float NaN;
    public static float NegativeInfinity;
    public static float PositiveInfinity;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static bool IsFinite(float f);
    public static bool IsInfinity(float f);
    public static bool IsNaN(float f);
    public static bool IsNegative(float f);
    public static bool IsNegativeInfinity(float f);
    public static bool IsNormal(float f);
    public static bool IsPositiveInfinity(float f);
    public static bool IsSubnormal(float f);
    public static bool op_Equality(float left, float right);
    public static bool op_GreaterThan(float left, float right);
    public static bool op_GreaterThanOrEqual(float left, float right);
    public static bool op_Inequality(float left, float right);
    public static bool op_LessThan(float left, float right);
    public static bool op_LessThanOrEqual(float left, float right);
    public static float Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Single& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public static bool TryParse(string s, Single& result);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Span`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static Span`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public T& Item { get; }
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    public static Span`1<T> get_Empty();
    public bool get_IsEmpty();
    public T& get_Item(int index);
    public int get_Length();
    public void Clear();
    public void CopyTo(Span`1<T> destination);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
public virtual bool Equals(object obj);
    public void Fill(T value);
    public Enumerator<T> GetEnumerator();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public static Span`1<T> op_Implicit(T[] array);
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
    public virtual string ToString();
    public bool TryCopyTo(Span`1<T> destination);
}
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[DefaultMemberAttribute("Chars")]
public class System.String : object {
    public static string Empty;
    public char Chars { get; }
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public String(Char* value);
    [CLSCompliantAttribute("False")]
public String(Char* value, int startIndex, int length);
    public String(char c, int count);
    public String(Char[] value);
    public String(Char[] value, int startIndex, int length);
    public String(ReadOnlySpan`1<char> value);
    [CLSCompliantAttribute("False")]
public String(SByte* value);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    public char get_Chars(int index);
    public int get_Length();
    public sealed virtual object Clone();
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    public static int Compare(string strA, string strB);
    public static int Compare(string strA, string strB, bool ignoreCase);
    public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, string strB, StringComparison comparisonType);
    public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    public static int CompareOrdinal(string strA, string strB);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(string strB);
    public static string Concat(IEnumerable`1<string> values);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    public static string Concat(string str0, string str1);
    public static string Concat(string str0, string str1, string str2);
    public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(String[] values);
    public static string Concat(IEnumerable`1<T> values);
    public bool Contains(char value);
    public bool Contains(char value, StringComparison comparisonType);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    public static string Copy(string str);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    public bool EndsWith(char value);
    public bool EndsWith(string value);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(string value, StringComparison comparisonType);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(string value);
    public static bool Equals(string a, string b);
    public static bool Equals(string a, string b, StringComparison comparisonType);
    public bool Equals(string value, StringComparison comparisonType);
    public static string Format(IFormatProvider provider, string format, object arg0);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public CharEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int GetHashCode(StringComparison comparisonType);
    public sealed virtual TypeCode GetTypeCode();
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOf(char value, StringComparison comparisonType);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public string Insert(int startIndex, string value);
    public static string Intern(string str);
    public static string IsInterned(string str);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    public static string Join(char separator, Object[] values);
    public static string Join(char separator, String[] value);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, String[] value);
    public static string Join(string separator, String[] value, int startIndex, int count);
    public static string Join(char separator, IEnumerable`1<T> values);
    public static string Join(string separator, IEnumerable`1<T> values);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    public static bool op_Equality(string a, string b);
    public static ReadOnlySpan`1<char> op_Implicit(string value);
    public static bool op_Inequality(string a, string b);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex);
    public string Remove(int startIndex, int count);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public bool StartsWith(char value);
    public bool StartsWith(string value);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(string value, StringComparison comparisonType);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
}
public abstract class System.StringComparer : object {
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public sealed virtual int Compare(object x, object y);
    public abstract virtual int Compare(string x, string y);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public static StringComparer Create(CultureInfo culture, CompareOptions options);
    public bool Equals(object x, object y);
    public abstract virtual bool Equals(string x, string y);
    public static StringComparer FromComparison(StringComparison comparisonType);
    public int GetHashCode(object obj);
    public abstract virtual int GetHashCode(string obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.StringNormalizationExtensions : object {
    [ExtensionAttribute]
public static bool IsNormalized(string value);
    [ExtensionAttribute]
public static bool IsNormalized(string value, NormalizationForm normalizationForm);
    [ExtensionAttribute]
public static string Normalize(string value);
    [ExtensionAttribute]
public static string Normalize(string value, NormalizationForm normalizationForm);
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
public class System.SystemException : Exception {
    protected SystemException(SerializationInfo info, StreamingContext context);
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
}
public class System.Text.ASCIIEncoding : Encoding {
    public bool IsSingleByte { get; }
    public virtual bool get_IsSingleByte();
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes, int byteIndex, int byteCount);
}
public abstract class System.Text.Decoder : object {
    public DecoderFallback Fallback { get; public set; }
    public DecoderFallbackBuffer FallbackBuffer { get; }
    public DecoderFallback get_Fallback();
    public void set_Fallback(DecoderFallback value);
    public DecoderFallbackBuffer get_FallbackBuffer();
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush);
    public virtual void Reset();
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    public virtual int get_MaxCharCount();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public virtual int get_Remaining();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
}
public abstract class System.Text.DecoderFallback : object {
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual int get_MaxCharCount();
    public static DecoderFallback get_ReplacementFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    public int Remaining { get; }
    public abstract virtual int get_Remaining();
    public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public virtual void Reset();
}
public class System.Text.DecoderFallbackException : ArgumentException {
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    public DecoderFallbackException(string message, Exception innerException);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual int get_MaxCharCount();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual int get_Remaining();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual void Reset();
}
public abstract class System.Text.Encoder : object {
    public EncoderFallback Fallback { get; public set; }
    public EncoderFallbackBuffer FallbackBuffer { get; }
    public EncoderFallback get_Fallback();
    public void set_Fallback(EncoderFallback value);
    public EncoderFallbackBuffer get_FallbackBuffer();
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush);
    public virtual void Reset();
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual int get_MaxCharCount();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual int get_Remaining();
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
}
public abstract class System.Text.EncoderFallback : object {
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual int get_MaxCharCount();
    public static EncoderFallback get_ReplacementFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    public int Remaining { get; }
    public abstract virtual int get_Remaining();
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public virtual void Reset();
}
public class System.Text.EncoderFallbackException : ArgumentException {
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual int get_MaxCharCount();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual int get_Remaining();
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual void Reset();
}
public abstract class System.Text.Encoding : object {
    public static Encoding ASCII { get; }
    public static Encoding BigEndianUnicode { get; }
    public string BodyName { get; }
    public int CodePage { get; }
    public DecoderFallback DecoderFallback { get; public set; }
    public static Encoding Default { get; }
    public EncoderFallback EncoderFallback { get; public set; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsReadOnly { get; }
    public bool IsSingleByte { get; }
    public ReadOnlySpan`1<byte> Preamble { get; }
    public static Encoding Unicode { get; }
    public static Encoding UTF32 { get; }
    public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    protected Encoding(int codePage);
    protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding get_ASCII();
    public static Encoding get_BigEndianUnicode();
    public virtual string get_BodyName();
    public virtual int get_CodePage();
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    public static Encoding get_Default();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public bool get_IsReadOnly();
    public virtual bool get_IsSingleByte();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    public static Encoding get_Unicode();
    public static Encoding get_UTF32();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual object Clone();
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    public virtual bool Equals(object value);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetByteCount(string s);
    public int GetByteCount(string s, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual Byte[] GetBytes(string s);
    public Byte[] GetBytes(string s, int index, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual int GetHashCode();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    [CLSCompliantAttribute("False")]
public string GetString(Byte* bytes, int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public string GetString(ReadOnlySpan`1<byte> bytes);
    public bool IsAlwaysNormalized();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public static void RegisterProvider(EncodingProvider provider);
}
public class System.Text.EncodingInfo : object {
    public int CodePage { get; }
    public string DisplayName { get; }
    public string Name { get; }
    public int get_CodePage();
    public string get_DisplayName();
    public string get_Name();
    public virtual bool Equals(object value);
    public Encoding GetEncoding();
    public virtual int GetHashCode();
}
public abstract class System.Text.EncodingProvider : object {
    public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public abstract virtual Encoding GetEncoding(string name);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    public static NormalizationForm FormKC;
    public static NormalizationForm FormKD;
}
public class System.Text.RegularExpressions.Capture : object {
    public int Index { get; }
    public int Length { get; }
    public string Value { get; }
    public int get_Index();
    public int get_Length();
    public string get_Value();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Text.RegularExpressions.CaptureCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Capture Item { get; }
    public object SyncRoot { get; }
    private Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual Capture get_Item(int i);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.set_Item(int index, Capture value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Capture[] array, int arrayIndex);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Add(Capture item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Contains(Capture item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Remove(Capture item);
    private sealed virtual override IEnumerator`1<Capture> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Capture>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.IndexOf(Capture item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Insert(int index, Capture item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.RemoveAt(int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
public class System.Text.RegularExpressions.Group : Capture {
    public CaptureCollection Captures { get; }
    public string Name { get; }
    public bool Success { get; }
    public CaptureCollection get_Captures();
    public string get_Name();
    public bool get_Success();
    public static Group Synchronized(Group inner);
}
[DefaultMemberAttribute("Item")]
public class System.Text.RegularExpressions.GroupCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Group Item { get; }
    public Group Item { get; }
    public object SyncRoot { get; }
    private Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual Group get_Item(int groupnum);
    public Group get_Item(string groupname);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.set_Item(int index, Group value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Group[] array, int arrayIndex);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Add(Group item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Contains(Group item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Remove(Group item);
    private sealed virtual override IEnumerator`1<Group> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Group>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.IndexOf(Group item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Insert(int index, Group item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.RemoveAt(int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
public class System.Text.RegularExpressions.Match : Group {
    public static Match Empty { get; }
    public GroupCollection Groups { get; }
    public static Match get_Empty();
    public virtual GroupCollection get_Groups();
    public Match NextMatch();
    public virtual string Result(string replacement);
    public static Match Synchronized(Match inner);
}
[DefaultMemberAttribute("Item")]
public class System.Text.RegularExpressions.MatchCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Match Item { get; }
    public object SyncRoot { get; }
    private Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public virtual Match get_Item(int i);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.set_Item(int index, Match value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Match[] array, int arrayIndex);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Add(Match item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Contains(Match item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Remove(Match item);
    private sealed virtual override IEnumerator`1<Match> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Match>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.IndexOf(Match item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Insert(int index, Match item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.RemoveAt(int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
public class System.Text.RegularExpressions.MatchEvaluator : MulticastDelegate {
    public MatchEvaluator(object object, IntPtr method);
    public virtual string Invoke(Match match);
    public virtual IAsyncResult BeginInvoke(Match match, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class System.Text.RegularExpressions.Regex : object {
    protected internal Hashtable capnames;
    protected internal Hashtable caps;
    protected internal int capsize;
    protected internal String[] capslist;
    protected internal RegexRunnerFactory factory;
    public static TimeSpan InfiniteMatchTimeout;
    protected internal TimeSpan internalMatchTimeout;
    protected internal string pattern;
    protected internal RegexOptions roptions;
    public static int CacheSize { get; public set; }
    [CLSCompliantAttribute("False")]
protected IDictionary CapNames { get; protected set; }
    [CLSCompliantAttribute("False")]
protected IDictionary Caps { get; protected set; }
    public TimeSpan MatchTimeout { get; }
    public RegexOptions Options { get; }
    public bool RightToLeft { get; }
    protected Regex(SerializationInfo info, StreamingContext context);
    public Regex(string pattern);
    public Regex(string pattern, RegexOptions options);
    public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout);
    public static int get_CacheSize();
    public static void set_CacheSize(int value);
    protected IDictionary get_CapNames();
    protected void set_CapNames(IDictionary value);
    protected IDictionary get_Caps();
    protected void set_Caps(IDictionary value);
    public TimeSpan get_MatchTimeout();
    public RegexOptions get_Options();
    public bool get_RightToLeft();
    public static string Escape(string str);
    public String[] GetGroupNames();
    public Int32[] GetGroupNumbers();
    public string GroupNameFromNumber(int i);
    public int GroupNumberFromName(string name);
    protected void InitializeReferences();
    public bool IsMatch(string input);
    public bool IsMatch(string input, int startat);
    public static bool IsMatch(string input, string pattern);
    public static bool IsMatch(string input, string pattern, RegexOptions options);
    public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public Match Match(string input);
    public Match Match(string input, int startat);
    public Match Match(string input, int beginning, int length);
    public static Match Match(string input, string pattern);
    public static Match Match(string input, string pattern, RegexOptions options);
    public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public MatchCollection Matches(string input);
    public MatchCollection Matches(string input, int startat);
    public static MatchCollection Matches(string input, string pattern);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, string replacement);
    public string Replace(string input, string replacement, int count);
    public string Replace(string input, string replacement, int count, int startat);
    public static string Replace(string input, string pattern, string replacement);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, MatchEvaluator evaluator);
    public string Replace(string input, MatchEvaluator evaluator, int count);
    public string Replace(string input, MatchEvaluator evaluator, int count, int startat);
    public String[] Split(string input);
    public String[] Split(string input, int count);
    public String[] Split(string input, int count, int startat);
    public static String[] Split(string input, string pattern);
    public static String[] Split(string input, string pattern, RegexOptions options);
    public static String[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    public virtual string ToString();
    public static string Unescape(string str);
    protected bool UseOptionC();
    protected bool UseOptionR();
    protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout);
}
public class System.Text.RegularExpressions.RegexMatchTimeoutException : TimeoutException {
    public string Input { get; }
    public TimeSpan MatchTimeout { get; }
    public string Pattern { get; }
    protected RegexMatchTimeoutException(SerializationInfo info, StreamingContext context);
    public RegexMatchTimeoutException(string message);
    public RegexMatchTimeoutException(string message, Exception inner);
    public RegexMatchTimeoutException(string regexInput, string regexPattern, TimeSpan matchTimeout);
    public string get_Input();
    public TimeSpan get_MatchTimeout();
    public string get_Pattern();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
}
[FlagsAttribute]
public enum System.Text.RegularExpressions.RegexOptions : Enum {
    public int value__;
    public static RegexOptions Compiled;
    public static RegexOptions CultureInvariant;
    public static RegexOptions ECMAScript;
    public static RegexOptions ExplicitCapture;
    public static RegexOptions IgnoreCase;
    public static RegexOptions IgnorePatternWhitespace;
    public static RegexOptions Multiline;
    public static RegexOptions None;
    public static RegexOptions RightToLeft;
    public static RegexOptions Singleline;
}
[EditorBrowsableAttribute("1")]
public abstract class System.Text.RegularExpressions.RegexRunner : object {
    protected internal Int32[] runcrawl;
    protected internal int runcrawlpos;
    protected internal Match runmatch;
    protected internal Regex runregex;
    protected internal Int32[] runstack;
    protected internal int runstackpos;
    protected internal string runtext;
    protected internal int runtextbeg;
    protected internal int runtextend;
    protected internal int runtextpos;
    protected internal int runtextstart;
    protected internal Int32[] runtrack;
    protected internal int runtrackcount;
    protected internal int runtrackpos;
    protected void Capture(int capnum, int start, int end);
    protected static bool CharInClass(char ch, string charClass);
    protected static bool CharInSet(char ch, string set, string category);
    protected void CheckTimeout();
    protected void Crawl(int i);
    protected int Crawlpos();
    protected void DoubleCrawl();
    protected void DoubleStack();
    protected void DoubleTrack();
    protected void EnsureStorage();
    protected abstract virtual bool FindFirstChar();
    protected abstract virtual void Go();
    protected abstract virtual void InitTrackCount();
    protected bool IsBoundary(int index, int startpos, int endpos);
    protected bool IsECMABoundary(int index, int startpos, int endpos);
    protected bool IsMatched(int cap);
    protected int MatchIndex(int cap);
    protected int MatchLength(int cap);
    protected int Popcrawl();
    protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick);
    protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout);
    protected void TransferCapture(int capnum, int uncapnum, int start, int end);
    protected void Uncapture();
}
[EditorBrowsableAttribute("1")]
public abstract class System.Text.RegularExpressions.RegexRunnerFactory : object {
    protected internal abstract virtual RegexRunner CreateInstance();
}
[DefaultMemberAttribute("Chars")]
public class System.Text.StringBuilder : object {
    public int Capacity { get; public set; }
    public char Chars { get; public set; }
    public int Length { get; public set; }
    public int MaxCapacity { get; }
    public StringBuilder(int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    public StringBuilder(string value);
    public StringBuilder(string value, int capacity);
    public StringBuilder(string value, int startIndex, int length, int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public int get_Length();
    public void set_Length(int value);
    public int get_MaxCapacity();
    public StringBuilder Append(bool value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(char value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(Char* value, int valueCount);
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(Char[] value);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(decimal value);
    public StringBuilder Append(double value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(object value);
    public StringBuilder Append(ReadOnlySpan`1<char> value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(float value);
    public StringBuilder Append(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder Append(StringBuilder value);
    public StringBuilder Append(StringBuilder value, int startIndex, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, String[] values);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public StringBuilder Clear();
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public void CopyTo(int sourceIndex, Span`1<char> destination, int count);
    public int EnsureCapacity(int capacity);
    public bool Equals(ReadOnlySpan`1<char> span);
    public bool Equals(StringBuilder sb);
    public StringBuilder Insert(int index, bool value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, decimal value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, object value);
    public StringBuilder Insert(int index, ReadOnlySpan`1<char> value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, string value, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    public StringBuilder Replace(string oldValue, string newValue);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
}
public class System.Text.UnicodeEncoding : Encoding {
    public static int CharSize;
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
    public virtual bool Equals(object value);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetHashCode();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual string GetString(Byte[] bytes, int index, int count);
}
public class System.Text.UTF32Encoding : Encoding {
    public UTF32Encoding(bool bigEndian, bool byteOrderMark);
    public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
    public virtual bool Equals(object value);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetHashCode();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual string GetString(Byte[] bytes, int index, int count);
}
public class System.Text.UTF7Encoding : Encoding {
    public UTF7Encoding(bool allowOptionals);
    public virtual bool Equals(object value);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetHashCode();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
}
public class System.Text.UTF8Encoding : Encoding {
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
    public virtual bool Equals(object value);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetHashCode();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual string GetString(Byte[] bytes, int index, int count);
}
public class System.Threading.AbandonedMutexException : SystemException {
    public Mutex Mutex { get; }
    public int MutexIndex { get; }
    public AbandonedMutexException(int location, WaitHandle handle);
    protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
    public AbandonedMutexException(string message);
    public AbandonedMutexException(string message, Exception inner);
    public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
    public AbandonedMutexException(string message, int location, WaitHandle handle);
    public Mutex get_Mutex();
    public int get_MutexIndex();
}
public enum System.Threading.ApartmentState : Enum {
    public int value__;
    public static ApartmentState MTA;
    public static ApartmentState STA;
    public static ApartmentState Unknown;
}
public class System.Threading.AsyncFlowControl : ValueType {
    private object _dummy;
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public bool Equals(AsyncFlowControl obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AsyncFlowControl a, AsyncFlowControl b);
    public static bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b);
    public void Undo();
}
public class System.Threading.AsyncLocal`1 : object {
    public T Value { get; public set; }
    public AsyncLocal`1(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler);
    public T get_Value();
    public void set_Value(T value);
}
[IsReadOnlyAttribute]
public class System.Threading.AsyncLocalValueChangedArgs`1 : ValueType {
    private T _dummy;
    private int _dummyPrimitive;
    public T CurrentValue { get; }
    public T PreviousValue { get; }
    public bool ThreadContextChanged { get; }
    public T get_CurrentValue();
    public T get_PreviousValue();
    public bool get_ThreadContextChanged();
}
public class System.Threading.AutoResetEvent : EventWaitHandle {
    public AutoResetEvent(bool initialState);
}
public class System.Threading.Barrier : object {
    public long CurrentPhaseNumber { get; }
    public int ParticipantCount { get; }
    public int ParticipantsRemaining { get; }
    public Barrier(int participantCount);
    public Barrier(int participantCount, Action`1<Barrier> postPhaseAction);
    public long get_CurrentPhaseNumber();
    public int get_ParticipantCount();
    public int get_ParticipantsRemaining();
    public long AddParticipant();
    public long AddParticipants(int participantCount);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void RemoveParticipant();
    public void RemoveParticipants(int participantCount);
    public void SignalAndWait();
    public bool SignalAndWait(int millisecondsTimeout);
    public bool SignalAndWait(int millisecondsTimeout, CancellationToken cancellationToken);
    public void SignalAndWait(CancellationToken cancellationToken);
    public bool SignalAndWait(TimeSpan timeout);
    public bool SignalAndWait(TimeSpan timeout, CancellationToken cancellationToken);
}
public class System.Threading.BarrierPostPhaseException : Exception {
    public BarrierPostPhaseException(Exception innerException);
    protected BarrierPostPhaseException(SerializationInfo info, StreamingContext context);
    public BarrierPostPhaseException(string message);
    public BarrierPostPhaseException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.Threading.CancellationToken : ValueType {
    private object _dummy;
    public bool CanBeCanceled { get; }
    public bool IsCancellationRequested { get; }
    public static CancellationToken None { get; }
    public WaitHandle WaitHandle { get; }
    public CancellationToken(bool canceled);
    public bool get_CanBeCanceled();
    public bool get_IsCancellationRequested();
    public static CancellationToken get_None();
    public WaitHandle get_WaitHandle();
    public virtual bool Equals(object other);
    public bool Equals(CancellationToken other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    public void ThrowIfCancellationRequested();
}
[IsReadOnlyAttribute]
public class System.Threading.CancellationTokenRegistration : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public CancellationToken Token { get; }
    public CancellationToken get_Token();
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
}
public class System.Threading.CancellationTokenSource : object {
    public bool IsCancellationRequested { get; }
    public CancellationToken Token { get; }
    public CancellationTokenSource(int millisecondsDelay);
    public CancellationTokenSource(TimeSpan delay);
    public bool get_IsCancellationRequested();
    public CancellationToken get_Token();
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public void CancelAfter(int millisecondsDelay);
    public void CancelAfter(TimeSpan delay);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Threading.CompressedStack : object {
    public static CompressedStack Capture();
    public CompressedStack CreateCopy();
    public static CompressedStack GetCompressedStack();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static void Run(CompressedStack compressedStack, ContextCallback callback, object state);
}
public class System.Threading.ContextCallback : MulticastDelegate {
    public ContextCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.CountdownEvent : object {
    public int CurrentCount { get; }
    public int InitialCount { get; }
    public bool IsSet { get; }
    public WaitHandle WaitHandle { get; }
    public CountdownEvent(int initialCount);
    public int get_CurrentCount();
    public int get_InitialCount();
    public bool get_IsSet();
    public WaitHandle get_WaitHandle();
    public void AddCount();
    public void AddCount(int signalCount);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset();
    public void Reset(int count);
    public bool Signal();
    public bool Signal(int signalCount);
    public bool TryAddCount();
    public bool TryAddCount(int signalCount);
    public void Wait();
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
}
public enum System.Threading.EventResetMode : Enum {
    public int value__;
    public static EventResetMode AutoReset;
    public static EventResetMode ManualReset;
}
public class System.Threading.EventWaitHandle : WaitHandle {
    public EventWaitHandle(bool initialState, EventResetMode mode);
    public EventWaitHandle(bool initialState, EventResetMode mode, string name);
    public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    public static EventWaitHandle OpenExisting(string name);
    public bool Reset();
    public bool Set();
    public static bool TryOpenExisting(string name, EventWaitHandle& result);
}
public class System.Threading.ExecutionContext : object {
    public static ExecutionContext Capture();
    public ExecutionContext CreateCopy();
    public sealed virtual void Dispose();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool IsFlowSuppressed();
    public static void RestoreFlow();
    public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
    public static AsyncFlowControl SuppressFlow();
}
public class System.Threading.HostExecutionContext : object {
    protected internal object State { get; protected internal set; }
    public HostExecutionContext(object state);
    protected internal object get_State();
    protected internal void set_State(object value);
    public virtual HostExecutionContext CreateCopy();
    public sealed virtual void Dispose();
    public virtual void Dispose(bool disposing);
}
public class System.Threading.HostExecutionContextManager : object {
    public virtual HostExecutionContext Capture();
    public virtual void Revert(object previousState);
    public virtual object SetHostExecutionContext(HostExecutionContext hostExecutionContext);
}
public static class System.Threading.Interlocked : object {
    public static int Add(Int32& location1, int value);
    public static long Add(Int64& location1, long value);
    public static double CompareExchange(Double& location1, double value, double comparand);
    public static int CompareExchange(Int32& location1, int value, int comparand);
    public static long CompareExchange(Int64& location1, long value, long comparand);
    public static IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand);
    public static object CompareExchange(Object& location1, object value, object comparand);
    public static float CompareExchange(Single& location1, float value, float comparand);
    public static T CompareExchange(T& location1, T value, T comparand);
    public static int Decrement(Int32& location);
    public static long Decrement(Int64& location);
    public static double Exchange(Double& location1, double value);
    public static int Exchange(Int32& location1, int value);
    public static long Exchange(Int64& location1, long value);
    public static IntPtr Exchange(IntPtr& location1, IntPtr value);
    public static object Exchange(Object& location1, object value);
    public static float Exchange(Single& location1, float value);
    public static T Exchange(T& location1, T value);
    public static int Increment(Int32& location);
    public static long Increment(Int64& location);
    public static void MemoryBarrier();
    public static void MemoryBarrierProcessWide();
    public static long Read(Int64& location);
}
[CLSCompliantAttribute("False")]
public class System.Threading.IOCompletionCallback : MulticastDelegate {
    public IOCompletionCallback(object object, IntPtr method);
    public virtual void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
    public virtual IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Threading.LazyInitializer : object {
    public static T EnsureInitialized(T& target);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Object& syncLock, Func`1<T> valueFactory);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode ExecutionAndPublication;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
}
public class System.Threading.LockCookie : ValueType {
    private int _dummyPrimitive;
    public virtual bool Equals(object obj);
    public bool Equals(LockCookie obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LockCookie a, LockCookie b);
    public static bool op_Inequality(LockCookie a, LockCookie b);
}
public class System.Threading.LockRecursionException : Exception {
    protected LockRecursionException(SerializationInfo info, StreamingContext context);
    public LockRecursionException(string message);
    public LockRecursionException(string message, Exception innerException);
}
public enum System.Threading.LockRecursionPolicy : Enum {
    public int value__;
    public static LockRecursionPolicy NoRecursion;
    public static LockRecursionPolicy SupportsRecursion;
}
public class System.Threading.ManualResetEvent : EventWaitHandle {
    public ManualResetEvent(bool initialState);
}
public class System.Threading.ManualResetEventSlim : object {
    public bool IsSet { get; }
    public int SpinCount { get; }
    public WaitHandle WaitHandle { get; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    public bool get_IsSet();
    public int get_SpinCount();
    public WaitHandle get_WaitHandle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset();
    public void Set();
    public void Wait();
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
}
public static class System.Threading.Monitor : object {
    public static void Enter(object obj);
    public static void Enter(object obj, Boolean& lockTaken);
    public static void Exit(object obj);
    public static bool IsEntered(object obj);
    public static void Pulse(object obj);
    public static void PulseAll(object obj);
    public static bool TryEnter(object obj);
    public static void TryEnter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, int millisecondsTimeout);
    public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    public static bool Wait(object obj);
    public static bool Wait(object obj, int millisecondsTimeout);
    public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
    public static bool Wait(object obj, TimeSpan timeout);
    public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
}
public class System.Threading.Mutex : WaitHandle {
    public Mutex(bool initiallyOwned);
    public Mutex(bool initiallyOwned, string name);
    public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    public static Mutex OpenExisting(string name);
    public void ReleaseMutex();
    public static bool TryOpenExisting(string name, Mutex& result);
}
public class System.Threading.NativeOverlapped : ValueType {
    public IntPtr EventHandle;
    public IntPtr InternalHigh;
    public IntPtr InternalLow;
    public int OffsetHigh;
    public int OffsetLow;
}
public class System.Threading.Overlapped : object {
    public IAsyncResult AsyncResult { get; public set; }
    [ObsoleteAttribute("This property is not 64-bit compatible.  Use EventHandleIntPtr instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public int EventHandle { get; public set; }
    public IntPtr EventHandleIntPtr { get; public set; }
    public int OffsetHigh { get; public set; }
    public int OffsetLow { get; public set; }
    [ObsoleteAttribute("This constructor is not 64-bit compatible.  Use the constructor that takes an IntPtr for the event handle.  https://go.microsoft.com/fwlink/?linkid=14202")]
public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    public IAsyncResult get_AsyncResult();
    public void set_AsyncResult(IAsyncResult value);
    public int get_EventHandle();
    public void set_EventHandle(int value);
    public IntPtr get_EventHandleIntPtr();
    public void set_EventHandleIntPtr(IntPtr value);
    public int get_OffsetHigh();
    public void set_OffsetHigh(int value);
    public int get_OffsetLow();
    public void set_OffsetLow(int value);
    [CLSCompliantAttribute("False")]
public static void Free(NativeOverlapped* nativeOverlappedPtr);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This method is not safe.  Use Pack (iocb, userData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public NativeOverlapped* Pack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [CLSCompliantAttribute("False")]
public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This method is not safe.  Use UnsafePack (iocb, userData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
}
public class System.Threading.ParameterizedThreadStart : MulticastDelegate {
    public ParameterizedThreadStart(object object, IntPtr method);
    public virtual void Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.PreAllocatedOverlapped : object {
    [CLSCompliantAttribute("False")]
public PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData);
    public sealed virtual void Dispose();
}
public class System.Threading.ReaderWriterLock : CriticalFinalizerObject {
    public bool IsReaderLockHeld { get; }
    public bool IsWriterLockHeld { get; }
    public int WriterSeqNum { get; }
    public bool get_IsReaderLockHeld();
    public bool get_IsWriterLockHeld();
    public int get_WriterSeqNum();
    public void AcquireReaderLock(int millisecondsTimeout);
    public void AcquireReaderLock(TimeSpan timeout);
    public void AcquireWriterLock(int millisecondsTimeout);
    public void AcquireWriterLock(TimeSpan timeout);
    public bool AnyWritersSince(int seqNum);
    public void DowngradeFromWriterLock(LockCookie& lockCookie);
    public LockCookie ReleaseLock();
    public void ReleaseReaderLock();
    public void ReleaseWriterLock();
    public void RestoreLock(LockCookie& lockCookie);
    public LockCookie UpgradeToWriterLock(int millisecondsTimeout);
    public LockCookie UpgradeToWriterLock(TimeSpan timeout);
}
public class System.Threading.ReaderWriterLockSlim : object {
    public int CurrentReadCount { get; }
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
    public int get_CurrentReadCount();
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
    public sealed virtual void Dispose();
    public void EnterReadLock();
    public void EnterUpgradeableReadLock();
    public void EnterWriteLock();
    public void ExitReadLock();
    public void ExitUpgradeableReadLock();
    public void ExitWriteLock();
    public bool TryEnterReadLock(int millisecondsTimeout);
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    public bool TryEnterWriteLock(TimeSpan timeout);
}
public class System.Threading.RegisteredWaitHandle : MarshalByRefObject {
    public bool Unregister(WaitHandle waitObject);
}
public class System.Threading.Semaphore : WaitHandle {
    public Semaphore(int initialCount, int maximumCount);
    public Semaphore(int initialCount, int maximumCount, string name);
    public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    public static Semaphore OpenExisting(string name);
    [PrePrepareMethodAttribute]
public int Release();
    public int Release(int releaseCount);
    public static bool TryOpenExisting(string name, Semaphore& result);
}
public class System.Threading.SemaphoreFullException : SystemException {
    protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
    public SemaphoreFullException(string message);
    public SemaphoreFullException(string message, Exception innerException);
}
public class System.Threading.SemaphoreSlim : object {
    public WaitHandle AvailableWaitHandle { get; }
    public int CurrentCount { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    public WaitHandle get_AvailableWaitHandle();
    public int get_CurrentCount();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public int Release();
    public int Release(int releaseCount);
    public void Wait();
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public Task WaitAsync();
    public Task`1<bool> WaitAsync(int millisecondsTimeout);
    public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
}
public class System.Threading.SendOrPostCallback : MulticastDelegate {
    public SendOrPostCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.SpinLock : ValueType {
    private int _dummyPrimitive;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    public bool get_IsHeld();
    public bool get_IsHeldByCurrentThread();
    public bool get_IsThreadOwnerTrackingEnabled();
    public void Enter(Boolean& lockTaken);
    public void Exit();
    public void Exit(bool useMemoryBarrier);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
}
public class System.Threading.SpinWait : ValueType {
    private int _dummyPrimitive;
    public int Count { get; }
    public bool NextSpinWillYield { get; }
    public int get_Count();
    public bool get_NextSpinWillYield();
    public void Reset();
    public void SpinOnce();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
}
public class System.Threading.SynchronizationContext : object {
    public static SynchronizationContext Current { get; }
    public static SynchronizationContext get_Current();
    public virtual SynchronizationContext CreateCopy();
    public bool IsWaitNotificationRequired();
    public virtual void OperationCompleted();
    public virtual void OperationStarted();
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void Send(SendOrPostCallback d, object state);
    public static void SetSynchronizationContext(SynchronizationContext syncContext);
    protected void SetWaitNotificationRequired();
    [CLSCompliantAttribute("False")]
[PrePrepareMethodAttribute]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [CLSCompliantAttribute("False")]
[PrePrepareMethodAttribute]
protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
}
public class System.Threading.SynchronizationLockException : SystemException {
    protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
    public SynchronizationLockException(string message);
    public SynchronizationLockException(string message, Exception innerException);
}
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    public Task Completion { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    public Task get_Completion();
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    public void Complete();
}
public static class System.Threading.Tasks.Parallel : object {
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`2<int, ParallelLoopState> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`1<int> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`2<int, ParallelLoopState> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`1<int> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action`2<long, ParallelLoopState> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action`1<long> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`2<long, ParallelLoopState> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`1<long> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static void Invoke(Action[] actions);
    public static void Invoke(ParallelOptions parallelOptions, Action[] actions);
}
public class System.Threading.Tasks.ParallelLoopResult : ValueType {
    private int _dummyPrimitive;
    public bool IsCompleted { get; }
    public Nullable`1<long> LowestBreakIteration { get; }
    public bool get_IsCompleted();
    public Nullable`1<long> get_LowestBreakIteration();
}
public class System.Threading.Tasks.ParallelLoopState : object {
    public bool IsExceptional { get; }
    public bool IsStopped { get; }
    public Nullable`1<long> LowestBreakIteration { get; }
    public bool ShouldExitCurrentIteration { get; }
    public bool get_IsExceptional();
    public bool get_IsStopped();
    public Nullable`1<long> get_LowestBreakIteration();
    public bool get_ShouldExitCurrentIteration();
    public void Break();
    public void Stop();
}
public class System.Threading.Tasks.ParallelOptions : object {
    public CancellationToken CancellationToken { get; public set; }
    public int MaxDegreeOfParallelism { get; public set; }
    public TaskScheduler TaskScheduler { get; public set; }
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    public int get_MaxDegreeOfParallelism();
    public void set_MaxDegreeOfParallelism(int value);
    public TaskScheduler get_TaskScheduler();
    public void set_TaskScheduler(TaskScheduler value);
}
public interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual void GetResult(short token);
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
}
public interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    public abstract virtual TResult GetResult(short token);
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
}
public class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1 : ValueType {
    private TResult _result;
    private object _dummy;
    private int _dummyPrimitive;
    public bool RunContinuationsAsynchronously { get; public set; }
    public short Version { get; }
    public bool get_RunContinuationsAsynchronously();
    public void set_RunContinuationsAsynchronously(bool value);
    public short get_Version();
    public TResult GetResult(short token);
    public ValueTaskSourceStatus GetStatus(short token);
    public void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public void Reset();
    public void SetException(Exception error);
    public void SetResult(TResult result);
}
[FlagsAttribute]
public enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
}
public enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Canceled;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
}
public class System.Threading.Tasks.Task : object {
    public object AsyncState { get; }
    public static Task CompletedTask { get; }
    public TaskCreationOptions CreationOptions { get; }
    public static Nullable`1<int> CurrentId { get; }
    public AggregateException Exception { get; }
    public static TaskFactory Factory { get; }
    public int Id { get; }
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public TaskStatus Status { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public sealed virtual object get_AsyncState();
    public static Task get_CompletedTask();
    public TaskCreationOptions get_CreationOptions();
    public static Nullable`1<int> get_CurrentId();
    public AggregateException get_Exception();
    public static TaskFactory get_Factory();
    public int get_Id();
    public bool get_IsCanceled();
    public sealed virtual bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public TaskStatus get_Status();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static Task FromCanceled(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    public static Task`1<TResult> FromResult(TResult result);
    public TaskAwaiter GetAwaiter();
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void Wait();
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static YieldAwaitable Yield();
}
public class System.Threading.Tasks.Task`1 : Task {
    public static TaskFactory`1<TResult> Factory { get; }
    public TResult Result { get; }
    public Task`1(Func`2<object, TResult> function, object state);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public static TaskFactory`1<TResult> get_Factory();
    public TResult get_Result();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public TaskAwaiter`1<TResult> GetAwaiter();
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskAsyncEnumerableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredAsyncDisposable ConfigureAwait(IAsyncDisposable source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(IAsyncEnumerable`1<T> source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
}
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    public Task Task { get; }
    protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(string message, Exception innerException, CancellationToken token);
    public TaskCanceledException(Task task);
    public Task get_Task();
}
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(object state);
    public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    public void SetCanceled();
    public void SetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetResult(TResult result);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetException(Exception exception);
    public bool TrySetResult(TResult result);
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions ExecuteSynchronously;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
public class System.Threading.Tasks.TaskFactory : object {
    public CancellationToken CancellationToken { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskScheduler Scheduler { get; }
    public TaskFactory(CancellationToken cancellationToken);
    public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory(TaskScheduler scheduler);
    public CancellationToken get_CancellationToken();
    public TaskContinuationOptions get_ContinuationOptions();
    public TaskCreationOptions get_CreationOptions();
    public TaskScheduler get_Scheduler();
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
}
public class System.Threading.Tasks.TaskFactory`1 : object {
    public CancellationToken CancellationToken { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskScheduler Scheduler { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory`1(TaskScheduler scheduler);
    public CancellationToken get_CancellationToken();
    public TaskContinuationOptions get_ContinuationOptions();
    public TaskCreationOptions get_CreationOptions();
    public TaskScheduler get_Scheduler();
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
}
public abstract class System.Threading.Tasks.TaskScheduler : object {
    public static TaskScheduler Current { get; }
    public static TaskScheduler Default { get; }
    public int Id { get; }
    public int MaximumConcurrencyLevel { get; }
    public static TaskScheduler get_Current();
    public static TaskScheduler get_Default();
    public int get_Id();
    public virtual int get_MaximumConcurrencyLevel();
    public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static TaskScheduler FromCurrentSynchronizationContext();
    protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    protected internal abstract virtual void QueueTask(Task task);
    protected internal virtual bool TryDequeue(Task task);
    protected bool TryExecuteTask(Task task);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
}
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(Exception innerException);
    protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
    public TaskSchedulerException(string message);
    public TaskSchedulerException(string message, Exception innerException);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Canceled;
    public static TaskStatus Created;
    public static TaskStatus Faulted;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Running;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus WaitingToRun;
}
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    public AggregateException Exception { get; }
    public bool Observed { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public AggregateException get_Exception();
    public bool get_Observed();
    public void SetObserved();
}
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
public class System.Threading.Tasks.ValueTask : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public ValueTask(IValueTaskSource source, short token);
    public ValueTask(Task task);
    public bool get_IsCanceled();
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public Task AsTask();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public ValueTaskAwaiter GetAwaiter();
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public ValueTask Preserve();
}
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
public class System.Threading.Tasks.ValueTask`1 : ValueType {
    private TResult _result;
    private object _dummy;
    private int _dummyPrimitive;
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public TResult Result { get; }
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(TResult result);
    public bool get_IsCanceled();
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public TResult get_Result();
    public Task`1<TResult> AsTask();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public ValueTask`1<TResult> Preserve();
    public virtual string ToString();
}
public class System.Threading.Thread : CriticalFinalizerObject {
    [ObsoleteAttribute("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", "False")]
public ApartmentState ApartmentState { get; public set; }
    public CultureInfo CurrentCulture { get; public set; }
    public static IPrincipal CurrentPrincipal { get; public set; }
    public static Thread CurrentThread { get; }
    public CultureInfo CurrentUICulture { get; public set; }
    public ExecutionContext ExecutionContext { get; }
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    public bool IsThreadPoolThread { get; }
    public int ManagedThreadId { get; }
    public string Name { get; public set; }
    public ThreadPriority Priority { get; public set; }
    public ThreadState ThreadState { get; }
    public Thread(ParameterizedThreadStart start);
    public Thread(ParameterizedThreadStart start, int maxStackSize);
    public Thread(ThreadStart start);
    public Thread(ThreadStart start, int maxStackSize);
    public ApartmentState get_ApartmentState();
    public void set_ApartmentState(ApartmentState value);
    public CultureInfo get_CurrentCulture();
    public void set_CurrentCulture(CultureInfo value);
    public static IPrincipal get_CurrentPrincipal();
    public static void set_CurrentPrincipal(IPrincipal value);
    public static Thread get_CurrentThread();
    public CultureInfo get_CurrentUICulture();
    public void set_CurrentUICulture(CultureInfo value);
    public ExecutionContext get_ExecutionContext();
    public bool get_IsAlive();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    public bool get_IsThreadPoolThread();
    public int get_ManagedThreadId();
    public string get_Name();
    public void set_Name(string value);
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    public ThreadState get_ThreadState();
    public void Abort();
    public void Abort(object stateInfo);
    public static LocalDataStoreSlot AllocateDataSlot();
    public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
    public static void BeginCriticalRegion();
    public static void BeginThreadAffinity();
    public void DisableComObjectEagerCleanup();
    public static void EndCriticalRegion();
    public static void EndThreadAffinity();
    public static void FreeNamedDataSlot(string name);
    public ApartmentState GetApartmentState();
    [ObsoleteAttribute("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
public CompressedStack GetCompressedStack();
    public static int GetCurrentProcessorId();
    public static object GetData(LocalDataStoreSlot slot);
    public static AppDomain GetDomain();
    public static int GetDomainID();
    public virtual int GetHashCode();
    public static LocalDataStoreSlot GetNamedDataSlot(string name);
    public void Interrupt();
    public void Join();
    public bool Join(int millisecondsTimeout);
    public bool Join(TimeSpan timeout);
    public static void MemoryBarrier();
    public static void ResetAbort();
    [ObsoleteAttribute("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", "False")]
public void Resume();
    public void SetApartmentState(ApartmentState state);
    [ObsoleteAttribute("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
public void SetCompressedStack(CompressedStack stack);
    public static void SetData(LocalDataStoreSlot slot, object data);
    public static void Sleep(int millisecondsTimeout);
    public static void Sleep(TimeSpan timeout);
    public static void SpinWait(int iterations);
    public void Start();
    public void Start(object parameter);
    [ObsoleteAttribute("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", "False")]
public void Suspend();
    public bool TrySetApartmentState(ApartmentState state);
    public static byte VolatileRead(Byte& address);
    public static double VolatileRead(Double& address);
    public static short VolatileRead(Int16& address);
    public static int VolatileRead(Int32& address);
    public static long VolatileRead(Int64& address);
    public static IntPtr VolatileRead(IntPtr& address);
    public static object VolatileRead(Object& address);
    [CLSCompliantAttribute("False")]
public static sbyte VolatileRead(SByte& address);
    public static float VolatileRead(Single& address);
    [CLSCompliantAttribute("False")]
public static ushort VolatileRead(UInt16& address);
    [CLSCompliantAttribute("False")]
public static UInt32 VolatileRead(UInt32& address);
    [CLSCompliantAttribute("False")]
public static ulong VolatileRead(UInt64& address);
    [CLSCompliantAttribute("False")]
public static UIntPtr VolatileRead(UIntPtr& address);
    public static void VolatileWrite(Byte& address, byte value);
    public static void VolatileWrite(Double& address, double value);
    public static void VolatileWrite(Int16& address, short value);
    public static void VolatileWrite(Int32& address, int value);
    public static void VolatileWrite(Int64& address, long value);
    public static void VolatileWrite(IntPtr& address, IntPtr value);
    public static void VolatileWrite(Object& address, object value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(SByte& address, sbyte value);
    public static void VolatileWrite(Single& address, float value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt16& address, ushort value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt32& address, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt64& address, ulong value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UIntPtr& address, UIntPtr value);
    public static bool Yield();
}
public class System.Threading.ThreadAbortException : SystemException {
    public object ExceptionState { get; }
    public object get_ExceptionState();
}
public class System.Threading.ThreadExceptionEventArgs : EventArgs {
    public Exception Exception { get; }
    public ThreadExceptionEventArgs(Exception t);
    public Exception get_Exception();
}
public class System.Threading.ThreadExceptionEventHandler : MulticastDelegate {
    public ThreadExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ThreadExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ThreadExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.ThreadInterruptedException : SystemException {
    protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
}
public class System.Threading.ThreadLocal`1 : object {
    public bool IsValueCreated { get; }
    public T Value { get; public set; }
    public IList`1<T> Values { get; }
    public ThreadLocal`1(bool trackAllValues);
    public ThreadLocal`1(Func`1<T> valueFactory);
    public ThreadLocal`1(Func`1<T> valueFactory, bool trackAllValues);
    public bool get_IsValueCreated();
    public T get_Value();
    public void set_Value(T value);
    public IList`1<T> get_Values();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public virtual string ToString();
}
public static class System.Threading.ThreadPool : object {
    [ObsoleteAttribute("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", "False")]
public static bool BindHandle(IntPtr osHandle);
    public static bool BindHandle(SafeHandle osHandle);
    public static void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static bool QueueUserWorkItem(WaitCallback callBack);
    public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    public static bool QueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    [CLSCompliantAttribute("False")]
public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
}
public class System.Threading.ThreadPoolBoundHandle : object {
    public SafeHandle Handle { get; }
    public SafeHandle get_Handle();
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated);
    public static ThreadPoolBoundHandle BindHandle(SafeHandle handle);
    public sealed virtual void Dispose();
    [CLSCompliantAttribute("False")]
public void FreeNativeOverlapped(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static object GetNativeOverlappedState(NativeOverlapped* overlapped);
}
public enum System.Threading.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority AboveNormal;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Highest;
    public static ThreadPriority Lowest;
    public static ThreadPriority Normal;
}
public class System.Threading.ThreadStart : MulticastDelegate {
    public ThreadStart(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.ThreadStartException : SystemException {
}
[FlagsAttribute]
public enum System.Threading.ThreadState : Enum {
    public int value__;
    public static ThreadState Aborted;
    public static ThreadState AbortRequested;
    public static ThreadState Background;
    public static ThreadState Running;
    public static ThreadState Stopped;
    public static ThreadState StopRequested;
    public static ThreadState Suspended;
    public static ThreadState SuspendRequested;
    public static ThreadState Unstarted;
    public static ThreadState WaitSleepJoin;
}
public class System.Threading.ThreadStateException : SystemException {
    protected ThreadStateException(SerializationInfo info, StreamingContext context);
    public ThreadStateException(string message);
    public ThreadStateException(string message, Exception innerException);
}
public static class System.Threading.Timeout : object {
    public static int Infinite;
    public static TimeSpan InfiniteTimeSpan;
}
public class System.Threading.Timer : MarshalByRefObject {
    public Timer(TimerCallback callback);
    public Timer(TimerCallback callback, object state, int dueTime, int period);
    public Timer(TimerCallback callback, object state, long dueTime, long period);
    public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public bool Change(int dueTime, int period);
    public bool Change(long dueTime, long period);
    public bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public sealed virtual void Dispose();
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual ValueTask DisposeAsync();
}
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Threading.Volatile : object {
    public static bool Read(Boolean& location);
    public static byte Read(Byte& location);
    public static double Read(Double& location);
    public static short Read(Int16& location);
    public static int Read(Int32& location);
    public static long Read(Int64& location);
    public static IntPtr Read(IntPtr& location);
    [CLSCompliantAttribute("False")]
public static sbyte Read(SByte& location);
    public static float Read(Single& location);
    [CLSCompliantAttribute("False")]
public static ushort Read(UInt16& location);
    [CLSCompliantAttribute("False")]
public static UInt32 Read(UInt32& location);
    [CLSCompliantAttribute("False")]
public static ulong Read(UInt64& location);
    [CLSCompliantAttribute("False")]
public static UIntPtr Read(UIntPtr& location);
    public static T Read(T& location);
    public static void Write(Boolean& location, bool value);
    public static void Write(Byte& location, byte value);
    public static void Write(Double& location, double value);
    public static void Write(Int16& location, short value);
    public static void Write(Int32& location, int value);
    public static void Write(Int64& location, long value);
    public static void Write(IntPtr& location, IntPtr value);
    [CLSCompliantAttribute("False")]
public static void Write(SByte& location, sbyte value);
    public static void Write(Single& location, float value);
    [CLSCompliantAttribute("False")]
public static void Write(UInt16& location, ushort value);
    [CLSCompliantAttribute("False")]
public static void Write(UInt32& location, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void Write(UInt64& location, ulong value);
    [CLSCompliantAttribute("False")]
public static void Write(UIntPtr& location, UIntPtr value);
    public static void Write(T& location, T value);
}
public class System.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    protected static IntPtr InvalidHandle;
    public static int WaitTimeout;
    [ObsoleteAttribute("Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    public virtual IntPtr get_Handle();
    public virtual void set_Handle(IntPtr value);
    public SafeWaitHandle get_SafeWaitHandle();
    public void set_SafeWaitHandle(SafeWaitHandle value);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool explicitDisposing);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
}
public class System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
    protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
    public WaitHandleCannotBeOpenedException(string message);
    public WaitHandleCannotBeOpenedException(string message, Exception innerException);
}
[ExtensionAttribute]
public static class System.Threading.WaitHandleExtensions : object {
    [ExtensionAttribute]
public static SafeWaitHandle GetSafeWaitHandle(WaitHandle waitHandle);
    [ExtensionAttribute]
public static void SetSafeWaitHandle(WaitHandle waitHandle, SafeWaitHandle value);
}
public class System.Threading.WaitOrTimerCallback : MulticastDelegate {
    public WaitOrTimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
public class System.TimeoutException : SystemException {
    protected TimeoutException(SerializationInfo info, StreamingContext context);
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
}
public class System.Timers.ElapsedEventArgs : EventArgs {
    public DateTime SignalTime { get; }
    public DateTime get_SignalTime();
}
public class System.Timers.ElapsedEventHandler : MulticastDelegate {
    public ElapsedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ElapsedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ElapsedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultEventAttribute("Elapsed")]
[DefaultPropertyAttribute("Interval")]
public class System.Timers.Timer : Component {
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("True")]
[TimersDescriptionAttribute("TimerAutoReset")]
public bool AutoReset { get; public set; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("False")]
[TimersDescriptionAttribute("TimerEnabled")]
public bool Enabled { get; public set; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("100")]
[SettingsBindableAttribute("True")]
[TimersDescriptionAttribute("TimerInterval")]
public double Interval { get; public set; }
    public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[TimersDescriptionAttribute("TimerSynchronizingObject")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public Timer(double interval);
    public bool get_AutoReset();
    public void set_AutoReset(bool value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public double get_Interval();
    public void set_Interval(double value);
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public void add_Elapsed(ElapsedEventHandler value);
    public void remove_Elapsed(ElapsedEventHandler value);
    public sealed virtual void BeginInit();
    public void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    public void Start();
    public void Stop();
}
[AttributeUsageAttribute("32767")]
public class System.Timers.TimersDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public TimersDescriptionAttribute(string description);
    public virtual string get_Description();
}
[IsReadOnlyAttribute]
public class System.TimeSpan : ValueType {
    private int _dummyPrimitive;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    public static long TicksPerDay;
    public static long TicksPerHour;
    public static long TicksPerMillisecond;
    public static long TicksPerMinute;
    public static long TicksPerSecond;
    public static TimeSpan Zero;
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public long Ticks { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    public TimeSpan(long ticks);
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public long get_Ticks();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public TimeSpan Duration();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public static TimeSpan FromDays(double value);
    public static TimeSpan FromHours(double value);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public static TimeSpan FromSeconds(double value);
    public static TimeSpan FromTicks(long value);
    public virtual int GetHashCode();
    public TimeSpan Multiply(double factor);
    public TimeSpan Negate();
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public TimeSpan Subtract(TimeSpan ts);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeSpan& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
}
[ObsoleteAttribute("System.TimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo instead.")]
public abstract class System.TimeZone : object {
    public static TimeZone CurrentTimeZone { get; }
    public string DaylightName { get; }
    public string StandardName { get; }
    public static TimeZone get_CurrentTimeZone();
    public abstract virtual string get_DaylightName();
    public abstract virtual string get_StandardName();
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
}
public class System.TimeZoneInfo : object {
    public TimeSpan BaseUtcOffset { get; }
    public string DaylightName { get; }
    public string DisplayName { get; }
    public string Id { get; }
    public static TimeZoneInfo Local { get; }
    public string StandardName { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Utc { get; }
    public TimeSpan get_BaseUtcOffset();
    public string get_DaylightName();
    public string get_DisplayName();
    public string get_Id();
    public static TimeZoneInfo get_Local();
    public string get_StandardName();
    public bool get_SupportsDaylightSavingTime();
    public static TimeZoneInfo get_Utc();
    public static void ClearCachedData();
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TimeZoneInfo other);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    public static TimeZoneInfo FromSerializedString(string source);
    public AdjustmentRule[] GetAdjustmentRules();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public TimeSpan GetUtcOffset(DateTime dateTime);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public bool HasSameRules(TimeZoneInfo other);
    public bool IsAmbiguousTime(DateTime dateTime);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsInvalidTime(DateTime dateTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public string ToSerializedString();
    public virtual string ToString();
}
public class System.TimeZoneNotFoundException : Exception {
    protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
}
public class System.Transactions.CommittableTransaction : Transaction {
    private object System.IAsyncResult.AsyncState { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    private bool System.IAsyncResult.IsCompleted { get; }
    public CommittableTransaction(TimeSpan timeout);
    public CommittableTransaction(TransactionOptions options);
    private sealed virtual override object System.IAsyncResult.get_AsyncState();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    private sealed virtual override bool System.IAsyncResult.get_IsCompleted();
    public IAsyncResult BeginCommit(AsyncCallback asyncCallback, object asyncState);
    public void Commit();
    public void EndCommit(IAsyncResult asyncResult);
}
public enum System.Transactions.DependentCloneOption : Enum {
    public int value__;
    public static DependentCloneOption BlockCommitUntilComplete;
    public static DependentCloneOption RollbackIfNotComplete;
}
public class System.Transactions.DependentTransaction : Transaction {
    public void Complete();
}
public class System.Transactions.Enlistment : object {
    public void Done();
}
[FlagsAttribute]
public enum System.Transactions.EnlistmentOptions : Enum {
    public int value__;
    public static EnlistmentOptions EnlistDuringPrepareRequired;
    public static EnlistmentOptions None;
}
public enum System.Transactions.EnterpriseServicesInteropOption : Enum {
    public int value__;
    public static EnterpriseServicesInteropOption Automatic;
    public static EnterpriseServicesInteropOption Full;
    public static EnterpriseServicesInteropOption None;
}
public class System.Transactions.HostCurrentTransactionCallback : MulticastDelegate {
    public HostCurrentTransactionCallback(object object, IntPtr method);
    public virtual Transaction Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Transaction EndInvoke(IAsyncResult result);
}
public interface System.Transactions.IDtcTransaction {
    public abstract virtual void Abort(IntPtr reason, int retaining, int async);
    public abstract virtual void Commit(int retaining, int commitType, int reserved);
    public abstract virtual void GetTransactionInfo(IntPtr transactionInformation);
}
public interface System.Transactions.IEnlistmentNotification {
    public abstract virtual void Commit(Enlistment enlistment);
    public abstract virtual void InDoubt(Enlistment enlistment);
    public abstract virtual void Prepare(PreparingEnlistment preparingEnlistment);
    public abstract virtual void Rollback(Enlistment enlistment);
}
public interface System.Transactions.IPromotableSinglePhaseNotification {
    public abstract virtual void Initialize();
    public abstract virtual void Rollback(SinglePhaseEnlistment singlePhaseEnlistment);
    public abstract virtual void SinglePhaseCommit(SinglePhaseEnlistment singlePhaseEnlistment);
}
public interface System.Transactions.ISimpleTransactionSuperior {
    public abstract virtual void Rollback();
}
public interface System.Transactions.ISinglePhaseNotification {
    public abstract virtual void SinglePhaseCommit(SinglePhaseEnlistment singlePhaseEnlistment);
}
public enum System.Transactions.IsolationLevel : Enum {
    public int value__;
    public static IsolationLevel Chaos;
    public static IsolationLevel ReadCommitted;
    public static IsolationLevel ReadUncommitted;
    public static IsolationLevel RepeatableRead;
    public static IsolationLevel Serializable;
    public static IsolationLevel Snapshot;
    public static IsolationLevel Unspecified;
}
public interface System.Transactions.ITransactionPromoter {
    public abstract virtual Byte[] Promote();
}
public class System.Transactions.PreparingEnlistment : Enlistment {
    public void ForceRollback();
    public void ForceRollback(Exception e);
    public void Prepared();
    public Byte[] RecoveryInformation();
}
public class System.Transactions.SinglePhaseEnlistment : Enlistment {
    public void Aborted();
    public void Aborted(Exception e);
    public void Committed();
    public void InDoubt();
    public void InDoubt(Exception e);
}
public class System.Transactions.SubordinateTransaction : Transaction {
    public SubordinateTransaction(IsolationLevel isoLevel, ISimpleTransactionSuperior superior);
}
public class System.Transactions.Transaction : object {
    public static Transaction Current { get; public set; }
    public IsolationLevel IsolationLevel { get; }
    public Guid PromoterType { get; }
    public TransactionInformation TransactionInformation { get; }
    public static Transaction get_Current();
    public static void set_Current(Transaction value);
    public IsolationLevel get_IsolationLevel();
    public Guid get_PromoterType();
    public TransactionInformation get_TransactionInformation();
    public void add_TransactionCompleted(TransactionCompletedEventHandler value);
    public void remove_TransactionCompleted(TransactionCompletedEventHandler value);
    public Transaction Clone();
    public DependentTransaction DependentClone(DependentCloneOption cloneOption);
    public sealed virtual void Dispose();
    public Enlistment EnlistDurable(Guid resourceManagerIdentifier, IEnlistmentNotification enlistmentNotification, EnlistmentOptions enlistmentOptions);
    public Enlistment EnlistDurable(Guid resourceManagerIdentifier, ISinglePhaseNotification singlePhaseNotification, EnlistmentOptions enlistmentOptions);
    public bool EnlistPromotableSinglePhase(IPromotableSinglePhaseNotification promotableSinglePhaseNotification);
    public bool EnlistPromotableSinglePhase(IPromotableSinglePhaseNotification promotableSinglePhaseNotification, Guid promoterType);
    public Enlistment EnlistVolatile(IEnlistmentNotification enlistmentNotification, EnlistmentOptions enlistmentOptions);
    public Enlistment EnlistVolatile(ISinglePhaseNotification singlePhaseNotification, EnlistmentOptions enlistmentOptions);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Byte[] GetPromotedToken();
    public static bool op_Equality(Transaction x, Transaction y);
    public static bool op_Inequality(Transaction x, Transaction y);
    public Enlistment PromoteAndEnlistDurable(Guid resourceManagerIdentifier, IPromotableSinglePhaseNotification promotableNotification, ISinglePhaseNotification enlistmentNotification, EnlistmentOptions enlistmentOptions);
    public void Rollback();
    public void Rollback(Exception e);
    public void SetDistributedTransactionIdentifier(IPromotableSinglePhaseNotification promotableNotification, Guid distributedTransactionIdentifier);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext context);
}
public class System.Transactions.TransactionAbortedException : TransactionException {
    protected TransactionAbortedException(SerializationInfo info, StreamingContext context);
    public TransactionAbortedException(string message);
    public TransactionAbortedException(string message, Exception innerException);
}
public class System.Transactions.TransactionCompletedEventHandler : MulticastDelegate {
    public TransactionCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TransactionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TransactionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Transactions.TransactionEventArgs : EventArgs {
    public Transaction Transaction { get; }
    public Transaction get_Transaction();
}
public class System.Transactions.TransactionException : SystemException {
    protected TransactionException(SerializationInfo info, StreamingContext context);
    public TransactionException(string message);
    public TransactionException(string message, Exception innerException);
}
public class System.Transactions.TransactionInDoubtException : TransactionException {
    protected TransactionInDoubtException(SerializationInfo info, StreamingContext context);
    public TransactionInDoubtException(string message);
    public TransactionInDoubtException(string message, Exception innerException);
}
public class System.Transactions.TransactionInformation : object {
    public DateTime CreationTime { get; }
    public Guid DistributedIdentifier { get; }
    public string LocalIdentifier { get; }
    public TransactionStatus Status { get; }
    public DateTime get_CreationTime();
    public Guid get_DistributedIdentifier();
    public string get_LocalIdentifier();
    public TransactionStatus get_Status();
}
public static class System.Transactions.TransactionInterop : object {
    public static Guid PromoterTypeDtc;
    public static IDtcTransaction GetDtcTransaction(Transaction transaction);
    public static Byte[] GetExportCookie(Transaction transaction, Byte[] whereabouts);
    public static Transaction GetTransactionFromDtcTransaction(IDtcTransaction transactionNative);
    public static Transaction GetTransactionFromExportCookie(Byte[] cookie);
    public static Transaction GetTransactionFromTransmitterPropagationToken(Byte[] propagationToken);
    public static Byte[] GetTransmitterPropagationToken(Transaction transaction);
    public static Byte[] GetWhereabouts();
}
public static class System.Transactions.TransactionManager : object {
    public static TimeSpan DefaultTimeout { get; }
    public static HostCurrentTransactionCallback HostCurrentCallback { get; public set; }
    public static TimeSpan MaximumTimeout { get; }
    public static TimeSpan get_DefaultTimeout();
    public static HostCurrentTransactionCallback get_HostCurrentCallback();
    public static void set_HostCurrentCallback(HostCurrentTransactionCallback value);
    public static TimeSpan get_MaximumTimeout();
    public static void add_DistributedTransactionStarted(TransactionStartedEventHandler value);
    public static void remove_DistributedTransactionStarted(TransactionStartedEventHandler value);
    public static void RecoveryComplete(Guid resourceManagerIdentifier);
    public static Enlistment Reenlist(Guid resourceManagerIdentifier, Byte[] recoveryInformation, IEnlistmentNotification enlistmentNotification);
}
public class System.Transactions.TransactionManagerCommunicationException : TransactionException {
    protected TransactionManagerCommunicationException(SerializationInfo info, StreamingContext context);
    public TransactionManagerCommunicationException(string message);
    public TransactionManagerCommunicationException(string message, Exception innerException);
}
public class System.Transactions.TransactionOptions : ValueType {
    private int _dummyPrimitive;
    public IsolationLevel IsolationLevel { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public IsolationLevel get_IsolationLevel();
    public void set_IsolationLevel(IsolationLevel value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TransactionOptions x, TransactionOptions y);
    public static bool op_Inequality(TransactionOptions x, TransactionOptions y);
}
public class System.Transactions.TransactionPromotionException : TransactionException {
    protected TransactionPromotionException(SerializationInfo info, StreamingContext context);
    public TransactionPromotionException(string message);
    public TransactionPromotionException(string message, Exception innerException);
}
public class System.Transactions.TransactionScope : object {
    public TransactionScope(Transaction transactionToUse);
    public TransactionScope(Transaction transactionToUse, TimeSpan scopeTimeout);
    public TransactionScope(Transaction transactionToUse, TimeSpan scopeTimeout, EnterpriseServicesInteropOption interopOption);
    public TransactionScope(Transaction transactionToUse, TimeSpan scopeTimeout, TransactionScopeAsyncFlowOption asyncFlowOption);
    public TransactionScope(Transaction transactionToUse, TransactionScopeAsyncFlowOption asyncFlowOption);
    public TransactionScope(TransactionScopeAsyncFlowOption asyncFlowOption);
    public TransactionScope(TransactionScopeOption scopeOption);
    public TransactionScope(TransactionScopeOption scopeOption, TimeSpan scopeTimeout);
    public TransactionScope(TransactionScopeOption scopeOption, TimeSpan scopeTimeout, TransactionScopeAsyncFlowOption asyncFlowOption);
    public TransactionScope(TransactionScopeOption scopeOption, TransactionOptions transactionOptions);
    public TransactionScope(TransactionScopeOption scopeOption, TransactionOptions transactionOptions, EnterpriseServicesInteropOption interopOption);
    public TransactionScope(TransactionScopeOption scopeOption, TransactionOptions transactionOptions, TransactionScopeAsyncFlowOption asyncFlowOption);
    public TransactionScope(TransactionScopeOption scopeOption, TransactionScopeAsyncFlowOption asyncFlowOption);
    public void Complete();
    public sealed virtual void Dispose();
}
public enum System.Transactions.TransactionScopeAsyncFlowOption : Enum {
    public int value__;
    public static TransactionScopeAsyncFlowOption Enabled;
    public static TransactionScopeAsyncFlowOption Suppress;
}
public enum System.Transactions.TransactionScopeOption : Enum {
    public int value__;
    public static TransactionScopeOption Required;
    public static TransactionScopeOption RequiresNew;
    public static TransactionScopeOption Suppress;
}
public class System.Transactions.TransactionStartedEventHandler : MulticastDelegate {
    public TransactionStartedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TransactionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TransactionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Transactions.TransactionStatus : Enum {
    public int value__;
    public static TransactionStatus Aborted;
    public static TransactionStatus Active;
    public static TransactionStatus Committed;
    public static TransactionStatus InDoubt;
}
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
}
public class System.Tuple`1 : object {
    public T1 Item1 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`2 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`3 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`4 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`5 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`6 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`7 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`8 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
}
public abstract class System.Type : MemberInfo {
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    public static object Missing;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public TypeAttributes Attributes { get; }
    public Type BaseType { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public Type DeclaringType { get; }
    public static Binder DefaultBinder { get; }
    public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Type[] GenericTypeArguments { get; }
    public Guid GUID { get; }
    public bool HasElementType { get; }
    public bool IsAbstract { get; }
    public bool IsAnsiClass { get; }
    public bool IsArray { get; }
    public bool IsAutoClass { get; }
    public bool IsAutoLayout { get; }
    public bool IsByRef { get; }
    public bool IsByRefLike { get; }
    public bool IsClass { get; }
    public bool IsCOMObject { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsContextful { get; }
    public bool IsEnum { get; }
    public bool IsExplicitLayout { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsImport { get; }
    public bool IsInterface { get; }
    public bool IsLayoutSequential { get; }
    public bool IsMarshalByRef { get; }
    public bool IsNested { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPointer { get; }
    public bool IsPrimitive { get; }
    public bool IsPublic { get; }
    public bool IsSealed { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSerializable { get; }
    public bool IsSignatureType { get; }
    public bool IsSpecialName { get; }
    public bool IsSZArray { get; }
    public bool IsTypeDefinition { get; }
    public bool IsUnicodeClass { get; }
    public bool IsValueType { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsVisible { get; }
    public MemberTypes MemberType { get; }
    public Module Module { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public ConstructorInfo TypeInitializer { get; }
    public Type UnderlyingSystemType { get; }
    public abstract virtual Assembly get_Assembly();
    public abstract virtual string get_AssemblyQualifiedName();
    public TypeAttributes get_Attributes();
    public abstract virtual Type get_BaseType();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_DeclaringType();
    public static Binder get_DefaultBinder();
    public abstract virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Type[] get_GenericTypeArguments();
    public abstract virtual Guid get_GUID();
    public bool get_HasElementType();
    public bool get_IsAbstract();
    public bool get_IsAnsiClass();
    public bool get_IsArray();
    public bool get_IsAutoClass();
    public bool get_IsAutoLayout();
    public bool get_IsByRef();
    public virtual bool get_IsByRefLike();
    public bool get_IsClass();
    public bool get_IsCOMObject();
    public virtual bool get_IsConstructedGenericType();
    public bool get_IsContextful();
    public virtual bool get_IsEnum();
    public bool get_IsExplicitLayout();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericTypeParameter();
    public bool get_IsImport();
    public bool get_IsInterface();
    public bool get_IsLayoutSequential();
    public bool get_IsMarshalByRef();
    public bool get_IsNested();
    public bool get_IsNestedAssembly();
    public bool get_IsNestedFamANDAssem();
    public bool get_IsNestedFamily();
    public bool get_IsNestedFamORAssem();
    public bool get_IsNestedPrivate();
    public bool get_IsNestedPublic();
    public bool get_IsNotPublic();
    public bool get_IsPointer();
    public bool get_IsPrimitive();
    public bool get_IsPublic();
    public bool get_IsSealed();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSerializable();
    public virtual bool get_IsSignatureType();
    public bool get_IsSpecialName();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsTypeDefinition();
    public bool get_IsUnicodeClass();
    public bool get_IsValueType();
    public virtual bool get_IsVariableBoundArray();
    public bool get_IsVisible();
    public virtual MemberTypes get_MemberType();
    public abstract virtual Module get_Module();
    public abstract virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public ConstructorInfo get_TypeInitializer();
    public abstract virtual Type get_UnderlyingSystemType();
    public virtual bool Equals(object o);
    public virtual bool Equals(Type o);
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual int GetArrayRank();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo GetConstructor(Type[] types);
    protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo[] GetConstructors();
    public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetDefaultMembers();
    public abstract virtual Type GetElementType();
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    public virtual Type GetEnumUnderlyingType();
    public virtual Array GetEnumValues();
    public EventInfo GetEvent(string name);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public FieldInfo GetField(string name);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetGenericArguments();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type GetGenericTypeDefinition();
    public virtual int GetHashCode();
    public Type GetInterface(string name);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public abstract virtual Type[] GetInterfaces();
    public MemberInfo[] GetMember(string name);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public MemberInfo[] GetMembers();
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public Type GetNestedType(string name);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public Type[] GetNestedTypes();
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public PropertyInfo[] GetProperties();
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public PropertyInfo GetProperty(string name, Type returnType);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public PropertyInfo GetProperty(string name, Type[] types);
    protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public Type GetType();
    public static Type GetType(string typeName);
    public static Type GetType(string typeName, bool throwOnError);
    public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static Type[] GetTypeArray(Object[] args);
    public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    public static Type GetTypeFromCLSID(Guid clsid);
    public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    public static Type GetTypeFromCLSID(Guid clsid, string server);
    public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    public static Type GetTypeFromProgID(string progID);
    public static Type GetTypeFromProgID(string progID, bool throwOnError);
    public static Type GetTypeFromProgID(string progID, string server);
    public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    public static RuntimeTypeHandle GetTypeHandle(object o);
    protected abstract virtual bool HasElementTypeImpl();
    public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected abstract virtual bool IsArrayImpl();
    public virtual bool IsAssignableFrom(Type c);
    protected abstract virtual bool IsByRefImpl();
    protected abstract virtual bool IsCOMObjectImpl();
    protected virtual bool IsContextfulImpl();
    public virtual bool IsEnumDefined(object value);
    public virtual bool IsEquivalentTo(Type other);
    public virtual bool IsInstanceOfType(object o);
    protected virtual bool IsMarshalByRefImpl();
    protected abstract virtual bool IsPointerImpl();
    protected abstract virtual bool IsPrimitiveImpl();
    public virtual bool IsSubclassOf(Type c);
    protected virtual bool IsValueTypeImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public static Type MakeGenericMethodParameter(int position);
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public static bool op_Equality(Type left, Type right);
    public static bool op_Inequality(Type left, Type right);
    public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public virtual string ToString();
}
public class System.TypeAccessException : TypeLoadException {
    protected TypeAccessException(SerializationInfo info, StreamingContext context);
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Boolean;
    public static TypeCode Byte;
    public static TypeCode Char;
    public static TypeCode DateTime;
    public static TypeCode DBNull;
    public static TypeCode Decimal;
    public static TypeCode Double;
    public static TypeCode Empty;
    public static TypeCode Int16;
    public static TypeCode Int32;
    public static TypeCode Int64;
    public static TypeCode Object;
    public static TypeCode SByte;
    public static TypeCode Single;
    public static TypeCode String;
    public static TypeCode UInt16;
    public static TypeCode UInt32;
    public static TypeCode UInt64;
}
[IsByRefLikeAttribute]
[CLSCompliantAttribute("False")]
public class System.TypedReference : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static Type GetTargetType(TypedReference value);
    [CLSCompliantAttribute("False")]
public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    [CLSCompliantAttribute("False")]
public static void SetTypedReference(TypedReference target, object value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    public static object ToObject(TypedReference value);
}
public class System.TypeInitializationException : SystemException {
    public string TypeName { get; }
    public TypeInitializationException(string fullTypeName, Exception innerException);
    public string get_TypeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.TypeLoadException : SystemException {
    public string Message { get; }
    public string TypeName { get; }
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    public virtual string get_Message();
    public string get_TypeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.TypeUnloadedException : SystemException {
    protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt16 : ValueType {
    private ushort _dummyPrimitive;
    public static ushort MaxValue;
    public static ushort MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    [CLSCompliantAttribute("False")]
public static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt32 : ValueType {
    private UInt32 _dummyPrimitive;
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt64 : ValueType {
    private ulong _dummyPrimitive;
    public static ulong MaxValue;
    public static ulong MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    [CLSCompliantAttribute("False")]
public static ulong Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UIntPtr : ValueType {
    private int _dummyPrimitive;
    public static UIntPtr Zero;
    public static int Size { get; }
    public UIntPtr(UInt32 value);
    public UIntPtr(ulong value);
    [CLSCompliantAttribute("False")]
public UIntPtr(Void* value);
    public static int get_Size();
    public static UIntPtr Add(UIntPtr pointer, int offset);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr op_Explicit(UInt32 value);
    public static UIntPtr op_Explicit(ulong value);
    public static UInt32 op_Explicit(UIntPtr value);
    public static ulong op_Explicit(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static Void* op_Explicit(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(Void* value);
    public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    public static UIntPtr Subtract(UIntPtr pointer, int offset);
    private sealed virtual override bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr other);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [CLSCompliantAttribute("False")]
public Void* ToPointer();
    public virtual string ToString();
    public UInt32 ToUInt32();
    public ulong ToUInt64();
}
public class System.UnauthorizedAccessException : SystemException {
    protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
}
public class System.UnhandledExceptionEventArgs : EventArgs {
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Uri : object {
    public static string SchemeDelimiter;
    public static string UriSchemeFile;
    public static string UriSchemeFtp;
    public static string UriSchemeGopher;
    public static string UriSchemeHttp;
    public static string UriSchemeHttps;
    public static string UriSchemeMailto;
    public static string UriSchemeNetPipe;
    public static string UriSchemeNetTcp;
    public static string UriSchemeNews;
    public static string UriSchemeNntp;
    public string AbsolutePath { get; }
    public string AbsoluteUri { get; }
    public string Authority { get; }
    public string DnsSafeHost { get; }
    public string Fragment { get; }
    public string Host { get; }
    public UriHostNameType HostNameType { get; }
    public string IdnHost { get; }
    public bool IsAbsoluteUri { get; }
    public bool IsDefaultPort { get; }
    public bool IsFile { get; }
    public bool IsLoopback { get; }
    public bool IsUnc { get; }
    public string LocalPath { get; }
    public string OriginalString { get; }
    public string PathAndQuery { get; }
    public int Port { get; }
    public string Query { get; }
    public string Scheme { get; }
    public String[] Segments { get; }
    public bool UserEscaped { get; }
    public string UserInfo { get; }
    protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Uri(string uriString);
    [ObsoleteAttribute("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")]
public Uri(string uriString, bool dontEscape);
    public Uri(string uriString, UriKind uriKind);
    public Uri(Uri baseUri, string relativeUri);
    [ObsoleteAttribute("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")]
public Uri(Uri baseUri, string relativeUri, bool dontEscape);
    public Uri(Uri baseUri, Uri relativeUri);
    public string get_AbsolutePath();
    public string get_AbsoluteUri();
    public string get_Authority();
    public string get_DnsSafeHost();
    public string get_Fragment();
    public string get_Host();
    public UriHostNameType get_HostNameType();
    public string get_IdnHost();
    public bool get_IsAbsoluteUri();
    public bool get_IsDefaultPort();
    public bool get_IsFile();
    public bool get_IsLoopback();
    public bool get_IsUnc();
    public string get_LocalPath();
    public string get_OriginalString();
    public string get_PathAndQuery();
    public int get_Port();
    public string get_Query();
    public string get_Scheme();
    public String[] get_Segments();
    public bool get_UserEscaped();
    public string get_UserInfo();
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Canonicalize();
    public static UriHostNameType CheckHostName(string name);
    public static bool CheckSchemeName(string schemeName);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void CheckSecurity();
    public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);
    public virtual bool Equals(object comparand);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Escape();
    public static string EscapeDataString(string stringToEscape);
    [ObsoleteAttribute("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")]
protected static string EscapeString(string str);
    public static string EscapeUriString(string stringToEscape);
    public static int FromHex(char digit);
    public string GetComponents(UriComponents components, UriFormat format);
    public virtual int GetHashCode();
    public string GetLeftPart(UriPartial part);
    protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public static string HexEscape(char character);
    public static char HexUnescape(string pattern, Int32& index);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual bool IsBadFileSystemCharacter(char character);
    public bool IsBaseOf(Uri uri);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]
protected static bool IsExcludedCharacter(char character);
    public static bool IsHexDigit(char character);
    public static bool IsHexEncoding(string pattern, int index);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual bool IsReservedCharacter(char character);
    public bool IsWellFormedOriginalString();
    public static bool IsWellFormedUriString(string uriString, UriKind uriKind);
    [ObsoleteAttribute("The method has been deprecated. Please use MakeRelativeUri(Uri uri). https://go.microsoft.com/fwlink/?linkid=14202")]
public string MakeRelative(Uri toUri);
    public Uri MakeRelativeUri(Uri uri);
    public static bool op_Equality(Uri uri1, Uri uri2);
    public static bool op_Inequality(Uri uri1, Uri uri2);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Parse();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual string ToString();
    public static bool TryCreate(string uriString, UriKind uriKind, Uri& result);
    public static bool TryCreate(Uri baseUri, string relativeUri, Uri& result);
    public static bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result);
    [ObsoleteAttribute("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual string Unescape(string path);
    public static string UnescapeDataString(string stringToUnescape);
}
public class System.UriBuilder : object {
    public string Fragment { get; public set; }
    public string Host { get; public set; }
    public string Password { get; public set; }
    public string Path { get; public set; }
    public int Port { get; public set; }
    public string Query { get; public set; }
    public string Scheme { get; public set; }
    public Uri Uri { get; }
    public string UserName { get; public set; }
    public UriBuilder(string uri);
    public UriBuilder(string schemeName, string hostName);
    public UriBuilder(string scheme, string host, int portNumber);
    public UriBuilder(string scheme, string host, int port, string pathValue);
    public UriBuilder(string scheme, string host, int port, string path, string extraValue);
    public UriBuilder(Uri uri);
    public string get_Fragment();
    public void set_Fragment(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Path();
    public void set_Path(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_Query();
    public void set_Query(string value);
    public string get_Scheme();
    public void set_Scheme(string value);
    public Uri get_Uri();
    public string get_UserName();
    public void set_UserName(string value);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.UriComponents : Enum {
    public int value__;
    public static UriComponents AbsoluteUri;
    public static UriComponents Fragment;
    public static UriComponents Host;
    public static UriComponents HostAndPort;
    public static UriComponents HttpRequestUrl;
    public static UriComponents KeepDelimiter;
    public static UriComponents NormalizedHost;
    public static UriComponents Path;
    public static UriComponents PathAndQuery;
    public static UriComponents Port;
    public static UriComponents Query;
    public static UriComponents Scheme;
    public static UriComponents SchemeAndServer;
    public static UriComponents SerializationInfoString;
    public static UriComponents StrongAuthority;
    public static UriComponents StrongPort;
    public static UriComponents UserInfo;
}
public enum System.UriFormat : Enum {
    public int value__;
    public static UriFormat SafeUnescaped;
    public static UriFormat Unescaped;
    public static UriFormat UriEscaped;
}
public class System.UriFormatException : FormatException {
    protected UriFormatException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public UriFormatException(string textString);
    public UriFormatException(string textString, Exception e);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.UriHostNameType : Enum {
    public int value__;
    public static UriHostNameType Basic;
    public static UriHostNameType Dns;
    public static UriHostNameType IPv4;
    public static UriHostNameType IPv6;
    public static UriHostNameType Unknown;
}
public enum System.UriKind : Enum {
    public int value__;
    public static UriKind Absolute;
    public static UriKind Relative;
    public static UriKind RelativeOrAbsolute;
}
public abstract class System.UriParser : object {
    protected virtual string GetComponents(Uri uri, UriComponents components, UriFormat format);
    protected virtual void InitializeAndValidate(Uri uri, UriFormatException& parsingError);
    protected virtual bool IsBaseOf(Uri baseUri, Uri relativeUri);
    public static bool IsKnownScheme(string schemeName);
    protected virtual bool IsWellFormedOriginalString(Uri uri);
    protected virtual UriParser OnNewUri();
    protected virtual void OnRegister(string schemeName, int defaultPort);
    public static void Register(UriParser uriParser, string schemeName, int defaultPort);
    protected virtual string Resolve(Uri baseUri, Uri relativeUri, UriFormatException& parsingError);
}
public enum System.UriPartial : Enum {
    public int value__;
    public static UriPartial Authority;
    public static UriPartial Path;
    public static UriPartial Query;
    public static UriPartial Scheme;
}
public class System.UriTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
public class System.ValueTuple : ValueType {
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple other);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`1 : ValueType {
    public T1 Item1;
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`1(T1 item1);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`2(T1 item1, T2 item2);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`3 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    public TRest Rest;
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public abstract class System.ValueType : object {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Version : object {
    public int Build { get; }
    public int Major { get; }
    public short MajorRevision { get; }
    public int Minor { get; }
    public short MinorRevision { get; }
    public int Revision { get; }
    public Version(int major, int minor);
    public Version(int major, int minor, int build);
    public Version(int major, int minor, int build, int revision);
    public Version(string version);
    public int get_Build();
    public int get_Major();
    public short get_MajorRevision();
    public int get_Minor();
    public short get_MinorRevision();
    public int get_Revision();
    public sealed virtual object Clone();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static Version Parse(ReadOnlySpan`1<char> input);
    public static Version Parse(string input);
    public virtual string ToString();
    public string ToString(int fieldCount);
    public bool TryFormat(Span`1<char> destination, int fieldCount, Int32& charsWritten);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public static bool TryParse(ReadOnlySpan`1<char> input, Version& result);
    public static bool TryParse(string input, Version& result);
}
public class System.Void : ValueType {
}
public class System.WeakReference : object {
    public bool IsAlive { get; }
    public object Target { get; public set; }
    public bool TrackResurrection { get; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    protected WeakReference(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsAlive();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual bool get_TrackResurrection();
    protected virtual override void Finalize();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.WeakReference`1 : object {
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void SetTarget(T target);
    public bool TryGetTarget(T& target);
}
public class System.Web.HttpUtility : object {
    public static string HtmlAttributeEncode(string s);
    public static void HtmlAttributeEncode(string s, TextWriter output);
    public static string HtmlDecode(string s);
    public static void HtmlDecode(string s, TextWriter output);
    public static string HtmlEncode(object value);
    public static string HtmlEncode(string s);
    public static void HtmlEncode(string s, TextWriter output);
    public static string JavaScriptStringEncode(string value);
    public static string JavaScriptStringEncode(string value, bool addDoubleQuotes);
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    public static string UrlDecode(Byte[] bytes, int offset, int count, Encoding e);
    public static string UrlDecode(Byte[] bytes, Encoding e);
    public static string UrlDecode(string str);
    public static string UrlDecode(string str, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count);
    public static Byte[] UrlDecodeToBytes(string str);
    public static Byte[] UrlDecodeToBytes(string str, Encoding e);
    public static string UrlEncode(Byte[] bytes);
    public static string UrlEncode(Byte[] bytes, int offset, int count);
    public static string UrlEncode(string str);
    public static string UrlEncode(string str, Encoding e);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    public static Byte[] UrlEncodeToBytes(string str);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    [ObsoleteAttribute("This method produces non-standards-compliant output and has interoperability issues. The preferred alternative is UrlEncode(String).")]
public static string UrlEncodeUnicode(string str);
    [ObsoleteAttribute("This method produces non-standards-compliant output and has interoperability issues. The preferred alternative is UrlEncodeToBytes(String).")]
public static Byte[] UrlEncodeUnicodeToBytes(string str);
    public static string UrlPathEncode(string str);
}
public interface System.Windows.Input.ICommand {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CanExecuteChanged(EventHandler value);
    public abstract virtual bool CanExecute(object parameter);
    public abstract virtual void Execute(object parameter);
}
public enum System.Xml.ConformanceLevel : Enum {
    public int value__;
    public static ConformanceLevel Auto;
    public static ConformanceLevel Document;
    public static ConformanceLevel Fragment;
}
public enum System.Xml.DtdProcessing : Enum {
    public int value__;
    public static DtdProcessing Ignore;
    public static DtdProcessing Parse;
    public static DtdProcessing Prohibit;
}
public enum System.Xml.EntityHandling : Enum {
    public int value__;
    public static EntityHandling ExpandCharEntities;
    public static EntityHandling ExpandEntities;
}
public enum System.Xml.Formatting : Enum {
    public int value__;
    public static Formatting Indented;
    public static Formatting None;
}
public interface System.Xml.IFragmentCapableXmlDictionaryWriter {
    public bool CanFragment { get; }
    public abstract virtual bool get_CanFragment();
    public abstract virtual void EndFragment();
    public abstract virtual void StartFragment(Stream stream, bool generateSelfContainedTextFragment);
    public abstract virtual void WriteFragment(Byte[] buffer, int offset, int count);
}
public interface System.Xml.IHasXmlNode {
    public abstract virtual XmlNode GetNode();
}
public interface System.Xml.IStreamProvider {
    public abstract virtual Stream GetStream();
    public abstract virtual void ReleaseStream(Stream stream);
}
public interface System.Xml.IXmlBinaryReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
}
public interface System.Xml.IXmlBinaryWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
}
public interface System.Xml.IXmlDictionary {
    public abstract virtual bool TryLookup(int key, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(string value, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
public interface System.Xml.IXmlLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
    public abstract virtual bool HasLineInfo();
}
public interface System.Xml.IXmlNamespaceResolver {
    public abstract virtual IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    public abstract virtual string LookupNamespace(string prefix);
    public abstract virtual string LookupPrefix(string namespaceName);
}
public interface System.Xml.IXmlTextReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
public interface System.Xml.IXmlTextWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
[ExtensionAttribute]
public static class System.Xml.Linq.Extensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<XElement> AncestorsAndSelf(IEnumerable`1<XElement> source);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> AncestorsAndSelf(IEnumerable`1<XElement> source, XName name);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> Ancestors(IEnumerable`1<T> source, XName name);
    [ExtensionAttribute]
public static IEnumerable`1<XAttribute> Attributes(IEnumerable`1<XElement> source);
    [ExtensionAttribute]
public static IEnumerable`1<XAttribute> Attributes(IEnumerable`1<XElement> source, XName name);
    [ExtensionAttribute]
public static IEnumerable`1<XNode> DescendantNodesAndSelf(IEnumerable`1<XElement> source);
    [ExtensionAttribute]
public static IEnumerable`1<XNode> DescendantNodes(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> DescendantsAndSelf(IEnumerable`1<XElement> source);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> DescendantsAndSelf(IEnumerable`1<XElement> source, XName name);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> Descendants(IEnumerable`1<T> source, XName name);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> Elements(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> Elements(IEnumerable`1<T> source, XName name);
    [ExtensionAttribute]
public static IEnumerable`1<T> InDocumentOrder(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<XNode> Nodes(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static void Remove(IEnumerable`1<XAttribute> source);
    [ExtensionAttribute]
public static void Remove(IEnumerable`1<T> source);
}
[FlagsAttribute]
public enum System.Xml.Linq.LoadOptions : Enum {
    public int value__;
    public static LoadOptions None;
    public static LoadOptions PreserveWhitespace;
    public static LoadOptions SetBaseUri;
    public static LoadOptions SetLineInfo;
}
[FlagsAttribute]
public enum System.Xml.Linq.ReaderOptions : Enum {
    public int value__;
    public static ReaderOptions None;
    public static ReaderOptions OmitDuplicateNamespaces;
}
[FlagsAttribute]
public enum System.Xml.Linq.SaveOptions : Enum {
    public int value__;
    public static SaveOptions DisableFormatting;
    public static SaveOptions None;
    public static SaveOptions OmitDuplicateNamespaces;
}
public class System.Xml.Linq.XAttribute : XObject {
    public static IEnumerable`1<XAttribute> EmptySequence { get; }
    public bool IsNamespaceDeclaration { get; }
    public XName Name { get; }
    public XAttribute NextAttribute { get; }
    public XmlNodeType NodeType { get; }
    public XAttribute PreviousAttribute { get; }
    public string Value { get; public set; }
    public XAttribute(XAttribute other);
    public XAttribute(XName name, object value);
    public static IEnumerable`1<XAttribute> get_EmptySequence();
    public bool get_IsNamespaceDeclaration();
    public XName get_Name();
    public XAttribute get_NextAttribute();
    public virtual XmlNodeType get_NodeType();
    public XAttribute get_PreviousAttribute();
    public string get_Value();
    public void set_Value(string value);
    [CLSCompliantAttribute("False")]
public static bool op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static DateTime op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static DateTimeOffset op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static decimal op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static double op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Guid op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static int op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static long op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<bool> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<DateTimeOffset> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<DateTime> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<decimal> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<double> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<Guid> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<int> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<long> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<float> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<TimeSpan> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static float op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static string op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static TimeSpan op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(XAttribute attribute);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(XAttribute attribute);
    public void Remove();
    public void SetValue(object value);
    public virtual string ToString();
}
public class System.Xml.Linq.XCData : XText {
    public XmlNodeType NodeType { get; }
    public XCData(string value);
    public XCData(XCData other);
    public virtual XmlNodeType get_NodeType();
    public virtual void WriteTo(XmlWriter writer);
    public virtual Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken);
}
public class System.Xml.Linq.XComment : XNode {
    public XmlNodeType NodeType { get; }
    public string Value { get; public set; }
    public XComment(string value);
    public XComment(XComment other);
    public virtual XmlNodeType get_NodeType();
    public string get_Value();
    public void set_Value(string value);
    public virtual void WriteTo(XmlWriter writer);
    public virtual Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken);
}
public abstract class System.Xml.Linq.XContainer : XNode {
    public XNode FirstNode { get; }
    public XNode LastNode { get; }
    public XNode get_FirstNode();
    public XNode get_LastNode();
    public void Add(object content);
    public void Add(Object[] content);
    public void AddFirst(object content);
    public void AddFirst(Object[] content);
    public XmlWriter CreateWriter();
    public IEnumerable`1<XNode> DescendantNodes();
    public IEnumerable`1<XElement> Descendants();
    public IEnumerable`1<XElement> Descendants(XName name);
    public XElement Element(XName name);
    public IEnumerable`1<XElement> Elements();
    public IEnumerable`1<XElement> Elements(XName name);
    public IEnumerable`1<XNode> Nodes();
    public void RemoveNodes();
    public void ReplaceNodes(object content);
    public void ReplaceNodes(Object[] content);
}
public class System.Xml.Linq.XDeclaration : object {
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public string Version { get; public set; }
    public XDeclaration(string version, string encoding, string standalone);
    public XDeclaration(XDeclaration other);
    public string get_Encoding();
    public void set_Encoding(string value);
    public string get_Standalone();
    public void set_Standalone(string value);
    public string get_Version();
    public void set_Version(string value);
    public virtual string ToString();
}
public class System.Xml.Linq.XDocument : XContainer {
    public XDeclaration Declaration { get; public set; }
    public XDocumentType DocumentType { get; }
    public XmlNodeType NodeType { get; }
    public XElement Root { get; }
    public XDocument(Object[] content);
    public XDocument(XDeclaration declaration, Object[] content);
    public XDocument(XDocument other);
    public XDeclaration get_Declaration();
    public void set_Declaration(XDeclaration value);
    public XDocumentType get_DocumentType();
    public virtual XmlNodeType get_NodeType();
    public XElement get_Root();
    public static XDocument Load(Stream stream);
    public static XDocument Load(Stream stream, LoadOptions options);
    public static XDocument Load(TextReader textReader);
    public static XDocument Load(TextReader textReader, LoadOptions options);
    public static XDocument Load(string uri);
    public static XDocument Load(string uri, LoadOptions options);
    public static XDocument Load(XmlReader reader);
    public static XDocument Load(XmlReader reader, LoadOptions options);
    public static Task`1<XDocument> LoadAsync(Stream stream, LoadOptions options, CancellationToken cancellationToken);
    public static Task`1<XDocument> LoadAsync(TextReader textReader, LoadOptions options, CancellationToken cancellationToken);
    public static Task`1<XDocument> LoadAsync(XmlReader reader, LoadOptions options, CancellationToken cancellationToken);
    public static XDocument Parse(string text);
    public static XDocument Parse(string text, LoadOptions options);
    public void Save(Stream stream);
    public void Save(Stream stream, SaveOptions options);
    public void Save(TextWriter textWriter);
    public void Save(TextWriter textWriter, SaveOptions options);
    public void Save(string fileName);
    public void Save(string fileName, SaveOptions options);
    public void Save(XmlWriter writer);
    public Task SaveAsync(Stream stream, SaveOptions options, CancellationToken cancellationToken);
    public Task SaveAsync(TextWriter textWriter, SaveOptions options, CancellationToken cancellationToken);
    public Task SaveAsync(XmlWriter writer, CancellationToken cancellationToken);
    public virtual void WriteTo(XmlWriter writer);
    public virtual Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken);
}
public class System.Xml.Linq.XDocumentType : XNode {
    public string InternalSubset { get; public set; }
    public string Name { get; public set; }
    public XmlNodeType NodeType { get; }
    public string PublicId { get; public set; }
    public string SystemId { get; public set; }
    public XDocumentType(string name, string publicId, string systemId, string internalSubset);
    public XDocumentType(XDocumentType other);
    public string get_InternalSubset();
    public void set_InternalSubset(string value);
    public string get_Name();
    public void set_Name(string value);
    public virtual XmlNodeType get_NodeType();
    public string get_PublicId();
    public void set_PublicId(string value);
    public string get_SystemId();
    public void set_SystemId(string value);
    public virtual void WriteTo(XmlWriter writer);
    public virtual Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken);
}
[XmlSchemaProviderAttribute("")]
public class System.Xml.Linq.XElement : XContainer {
    public static IEnumerable`1<XElement> EmptySequence { get; }
    public XAttribute FirstAttribute { get; }
    public bool HasAttributes { get; }
    public bool HasElements { get; }
    public bool IsEmpty { get; }
    public XAttribute LastAttribute { get; }
    public XName Name { get; public set; }
    public XmlNodeType NodeType { get; }
    public string Value { get; public set; }
    public XElement(XElement other);
    public XElement(XName name);
    public XElement(XName name, object content);
    public XElement(XName name, Object[] content);
    public XElement(XStreamingElement other);
    public static IEnumerable`1<XElement> get_EmptySequence();
    public XAttribute get_FirstAttribute();
    public bool get_HasAttributes();
    public bool get_HasElements();
    public bool get_IsEmpty();
    public XAttribute get_LastAttribute();
    public XName get_Name();
    public void set_Name(XName value);
    public virtual XmlNodeType get_NodeType();
    public string get_Value();
    public void set_Value(string value);
    public IEnumerable`1<XElement> AncestorsAndSelf();
    public IEnumerable`1<XElement> AncestorsAndSelf(XName name);
    public XAttribute Attribute(XName name);
    public IEnumerable`1<XAttribute> Attributes();
    public IEnumerable`1<XAttribute> Attributes(XName name);
    public IEnumerable`1<XNode> DescendantNodesAndSelf();
    public IEnumerable`1<XElement> DescendantsAndSelf();
    public IEnumerable`1<XElement> DescendantsAndSelf(XName name);
    public XNamespace GetDefaultNamespace();
    public XNamespace GetNamespaceOfPrefix(string prefix);
    public string GetPrefixOfNamespace(XNamespace ns);
    public static XElement Load(Stream stream);
    public static XElement Load(Stream stream, LoadOptions options);
    public static XElement Load(TextReader textReader);
    public static XElement Load(TextReader textReader, LoadOptions options);
    public static XElement Load(string uri);
    public static XElement Load(string uri, LoadOptions options);
    public static XElement Load(XmlReader reader);
    public static XElement Load(XmlReader reader, LoadOptions options);
    public static Task`1<XElement> LoadAsync(Stream stream, LoadOptions options, CancellationToken cancellationToken);
    public static Task`1<XElement> LoadAsync(TextReader textReader, LoadOptions options, CancellationToken cancellationToken);
    public static Task`1<XElement> LoadAsync(XmlReader reader, LoadOptions options, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public static bool op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static DateTime op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static DateTimeOffset op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static decimal op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static double op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Guid op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static int op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static long op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<bool> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<DateTimeOffset> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<DateTime> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<decimal> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<double> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<Guid> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<int> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<long> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<float> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<TimeSpan> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static float op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static string op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static TimeSpan op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(XElement element);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(XElement element);
    public static XElement Parse(string text);
    public static XElement Parse(string text, LoadOptions options);
    public void RemoveAll();
    public void RemoveAttributes();
    public void ReplaceAll(object content);
    public void ReplaceAll(Object[] content);
    public void ReplaceAttributes(object content);
    public void ReplaceAttributes(Object[] content);
    public void Save(Stream stream);
    public void Save(Stream stream, SaveOptions options);
    public void Save(TextWriter textWriter);
    public void Save(TextWriter textWriter, SaveOptions options);
    public void Save(string fileName);
    public void Save(string fileName, SaveOptions options);
    public void Save(XmlWriter writer);
    public Task SaveAsync(Stream stream, SaveOptions options, CancellationToken cancellationToken);
    public Task SaveAsync(TextWriter textWriter, SaveOptions options, CancellationToken cancellationToken);
    public Task SaveAsync(XmlWriter writer, CancellationToken cancellationToken);
    public void SetAttributeValue(XName name, object value);
    public void SetElementValue(XName name, object value);
    public void SetValue(object value);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual void WriteTo(XmlWriter writer);
    public virtual Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken);
}
public class System.Xml.Linq.XName : object {
    public string LocalName { get; }
    public XNamespace Namespace { get; }
    public string NamespaceName { get; }
    public string get_LocalName();
    public XNamespace get_Namespace();
    public string get_NamespaceName();
    public virtual bool Equals(object obj);
    public static XName Get(string expandedName);
    public static XName Get(string localName, string namespaceName);
    public virtual int GetHashCode();
    public static bool op_Equality(XName left, XName right);
    [CLSCompliantAttribute("False")]
public static XName op_Implicit(string expandedName);
    public static bool op_Inequality(XName left, XName right);
    private sealed virtual override bool System.IEquatable<System.Xml.Linq.XName>.Equals(XName other);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class System.Xml.Linq.XNamespace : object {
    public string NamespaceName { get; }
    public static XNamespace None { get; }
    public static XNamespace Xml { get; }
    public static XNamespace Xmlns { get; }
    public string get_NamespaceName();
    public static XNamespace get_None();
    public static XNamespace get_Xml();
    public static XNamespace get_Xmlns();
    public virtual bool Equals(object obj);
    public static XNamespace Get(string namespaceName);
    public virtual int GetHashCode();
    public XName GetName(string localName);
    public static XName op_Addition(XNamespace ns, string localName);
    public static bool op_Equality(XNamespace left, XNamespace right);
    [CLSCompliantAttribute("False")]
public static XNamespace op_Implicit(string namespaceName);
    public static bool op_Inequality(XNamespace left, XNamespace right);
    public virtual string ToString();
}
public abstract class System.Xml.Linq.XNode : XObject {
    public static XNodeDocumentOrderComparer DocumentOrderComparer { get; }
    public static XNodeEqualityComparer EqualityComparer { get; }
    public XNode NextNode { get; }
    public XNode PreviousNode { get; }
    public static XNodeDocumentOrderComparer get_DocumentOrderComparer();
    public static XNodeEqualityComparer get_EqualityComparer();
    public XNode get_NextNode();
    public XNode get_PreviousNode();
    public void AddAfterSelf(object content);
    public void AddAfterSelf(Object[] content);
    public void AddBeforeSelf(object content);
    public void AddBeforeSelf(Object[] content);
    public IEnumerable`1<XElement> Ancestors();
    public IEnumerable`1<XElement> Ancestors(XName name);
    public static int CompareDocumentOrder(XNode n1, XNode n2);
    public XmlReader CreateReader();
    public XmlReader CreateReader(ReaderOptions readerOptions);
    public static bool DeepEquals(XNode n1, XNode n2);
    public IEnumerable`1<XElement> ElementsAfterSelf();
    public IEnumerable`1<XElement> ElementsAfterSelf(XName name);
    public IEnumerable`1<XElement> ElementsBeforeSelf();
    public IEnumerable`1<XElement> ElementsBeforeSelf(XName name);
    public bool IsAfter(XNode node);
    public bool IsBefore(XNode node);
    public IEnumerable`1<XNode> NodesAfterSelf();
    public IEnumerable`1<XNode> NodesBeforeSelf();
    public static XNode ReadFrom(XmlReader reader);
    public static Task`1<XNode> ReadFromAsync(XmlReader reader, CancellationToken cancellationToken);
    public void Remove();
    public void ReplaceWith(object content);
    public void ReplaceWith(Object[] content);
    public virtual string ToString();
    public string ToString(SaveOptions options);
    public abstract virtual void WriteTo(XmlWriter writer);
    public abstract virtual Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken);
}
public class System.Xml.Linq.XNodeDocumentOrderComparer : object {
    public sealed virtual int Compare(XNode x, XNode y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public class System.Xml.Linq.XNodeEqualityComparer : object {
    public sealed virtual bool Equals(XNode x, XNode y);
    public sealed virtual int GetHashCode(XNode obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
}
public abstract class System.Xml.Linq.XObject : object {
    public string BaseUri { get; }
    public XDocument Document { get; }
    public XmlNodeType NodeType { get; }
    public XElement Parent { get; }
    private int System.Xml.IXmlLineInfo.LineNumber { get; }
    private int System.Xml.IXmlLineInfo.LinePosition { get; }
    public string get_BaseUri();
    public XDocument get_Document();
    public abstract virtual XmlNodeType get_NodeType();
    public XElement get_Parent();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LineNumber();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LinePosition();
    public void add_Changed(EventHandler`1<XObjectChangeEventArgs> value);
    public void remove_Changed(EventHandler`1<XObjectChangeEventArgs> value);
    public void add_Changing(EventHandler`1<XObjectChangeEventArgs> value);
    public void remove_Changing(EventHandler`1<XObjectChangeEventArgs> value);
    public void AddAnnotation(object annotation);
    public object Annotation(Type type);
    public IEnumerable`1<object> Annotations(Type type);
    public IEnumerable`1<T> Annotations();
    public T Annotation();
    public void RemoveAnnotations(Type type);
    public void RemoveAnnotations();
    private sealed virtual override bool System.Xml.IXmlLineInfo.HasLineInfo();
}
public enum System.Xml.Linq.XObjectChange : Enum {
    public int value__;
    public static XObjectChange Add;
    public static XObjectChange Name;
    public static XObjectChange Remove;
    public static XObjectChange Value;
}
public class System.Xml.Linq.XObjectChangeEventArgs : EventArgs {
    public static XObjectChangeEventArgs Add;
    public static XObjectChangeEventArgs Name;
    public static XObjectChangeEventArgs Remove;
    public static XObjectChangeEventArgs Value;
    public XObjectChange ObjectChange { get; }
    public XObjectChangeEventArgs(XObjectChange objectChange);
    public XObjectChange get_ObjectChange();
}
public class System.Xml.Linq.XProcessingInstruction : XNode {
    public string Data { get; public set; }
    public XmlNodeType NodeType { get; }
    public string Target { get; public set; }
    public XProcessingInstruction(string target, string data);
    public XProcessingInstruction(XProcessingInstruction other);
    public string get_Data();
    public void set_Data(string value);
    public virtual XmlNodeType get_NodeType();
    public string get_Target();
    public void set_Target(string value);
    public virtual void WriteTo(XmlWriter writer);
    public virtual Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken);
}
public class System.Xml.Linq.XStreamingElement : object {
    public XName Name { get; public set; }
    public XStreamingElement(XName name);
    public XStreamingElement(XName name, object content);
    public XStreamingElement(XName name, Object[] content);
    public XName get_Name();
    public void set_Name(XName value);
    public void Add(object content);
    public void Add(Object[] content);
    public void Save(Stream stream);
    public void Save(Stream stream, SaveOptions options);
    public void Save(TextWriter textWriter);
    public void Save(TextWriter textWriter, SaveOptions options);
    public void Save(string fileName);
    public void Save(string fileName, SaveOptions options);
    public void Save(XmlWriter writer);
    public virtual string ToString();
    public string ToString(SaveOptions options);
    public void WriteTo(XmlWriter writer);
}
public class System.Xml.Linq.XText : XNode {
    public XmlNodeType NodeType { get; }
    public string Value { get; public set; }
    public XText(string value);
    public XText(XText other);
    public virtual XmlNodeType get_NodeType();
    public string get_Value();
    public void set_Value(string value);
    public virtual void WriteTo(XmlWriter writer);
    public virtual Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum System.Xml.NamespaceHandling : Enum {
    public int value__;
    public static NamespaceHandling Default;
    public static NamespaceHandling OmitDuplicates;
}
public class System.Xml.NameTable : XmlNameTable {
    public virtual string Add(Char[] key, int start, int len);
    public virtual string Add(string key);
    public virtual string Get(Char[] key, int start, int len);
    public virtual string Get(string value);
}
public enum System.Xml.NewLineHandling : Enum {
    public int value__;
    public static NewLineHandling Entitize;
    public static NewLineHandling None;
    public static NewLineHandling Replace;
}
public class System.Xml.OnXmlDictionaryReaderClose : MulticastDelegate {
    public OnXmlDictionaryReaderClose(object object, IntPtr method);
    public virtual void Invoke(XmlDictionaryReader reader);
    public virtual IAsyncResult BeginInvoke(XmlDictionaryReader reader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Xml.ReadState : Enum {
    public int value__;
    public static ReadState Closed;
    public static ReadState EndOfFile;
    public static ReadState Error;
    public static ReadState Initial;
    public static ReadState Interactive;
}
[FlagsAttribute]
public enum System.Xml.Resolvers.XmlKnownDtds : Enum {
    public int value__;
    public static XmlKnownDtds All;
    public static XmlKnownDtds None;
    public static XmlKnownDtds Rss091;
    public static XmlKnownDtds Xhtml10;
}
public class System.Xml.Resolvers.XmlPreloadedResolver : XmlResolver {
    unknown ICredentials Credentials {public set; }
    public IEnumerable`1<Uri> PreloadedUris { get; }
    public XmlPreloadedResolver(XmlKnownDtds preloadedDtds);
    public XmlPreloadedResolver(XmlResolver fallbackResolver);
    public XmlPreloadedResolver(XmlResolver fallbackResolver, XmlKnownDtds preloadedDtds);
    public XmlPreloadedResolver(XmlResolver fallbackResolver, XmlKnownDtds preloadedDtds, IEqualityComparer`1<Uri> uriComparer);
    public virtual void set_Credentials(ICredentials value);
    public IEnumerable`1<Uri> get_PreloadedUris();
    public void Add(Uri uri, Byte[] value);
    public void Add(Uri uri, Byte[] value, int offset, int count);
    public void Add(Uri uri, Stream value);
    public void Add(Uri uri, string value);
    public virtual object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn);
    public virtual Task`1<object> GetEntityAsync(Uri absoluteUri, string role, Type ofObjectToReturn);
    public void Remove(Uri uri);
    public virtual Uri ResolveUri(Uri baseUri, string relativeUri);
    public virtual bool SupportsType(Uri absoluteUri, Type type);
}
[ExtensionAttribute]
public static class System.Xml.Schema.Extensions : object {
    [ExtensionAttribute]
public static IXmlSchemaInfo GetSchemaInfo(XAttribute source);
    [ExtensionAttribute]
public static IXmlSchemaInfo GetSchemaInfo(XElement source);
    [ExtensionAttribute]
public static void Validate(XAttribute source, XmlSchemaObject partialValidationType, XmlSchemaSet schemas, ValidationEventHandler validationEventHandler);
    [ExtensionAttribute]
public static void Validate(XAttribute source, XmlSchemaObject partialValidationType, XmlSchemaSet schemas, ValidationEventHandler validationEventHandler, bool addSchemaInfo);
    [ExtensionAttribute]
public static void Validate(XDocument source, XmlSchemaSet schemas, ValidationEventHandler validationEventHandler);
    [ExtensionAttribute]
public static void Validate(XDocument source, XmlSchemaSet schemas, ValidationEventHandler validationEventHandler, bool addSchemaInfo);
    [ExtensionAttribute]
public static void Validate(XElement source, XmlSchemaObject partialValidationType, XmlSchemaSet schemas, ValidationEventHandler validationEventHandler);
    [ExtensionAttribute]
public static void Validate(XElement source, XmlSchemaObject partialValidationType, XmlSchemaSet schemas, ValidationEventHandler validationEventHandler, bool addSchemaInfo);
}
public interface System.Xml.Schema.IXmlSchemaInfo {
    public bool IsDefault { get; }
    public bool IsNil { get; }
    public XmlSchemaSimpleType MemberType { get; }
    public XmlSchemaAttribute SchemaAttribute { get; }
    public XmlSchemaElement SchemaElement { get; }
    public XmlSchemaType SchemaType { get; }
    public XmlSchemaValidity Validity { get; }
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool get_IsNil();
    public abstract virtual XmlSchemaSimpleType get_MemberType();
    public abstract virtual XmlSchemaAttribute get_SchemaAttribute();
    public abstract virtual XmlSchemaElement get_SchemaElement();
    public abstract virtual XmlSchemaType get_SchemaType();
    public abstract virtual XmlSchemaValidity get_Validity();
}
public class System.Xml.Schema.ValidationEventArgs : EventArgs {
    public XmlSchemaException Exception { get; }
    public string Message { get; }
    public XmlSeverityType Severity { get; }
    public XmlSchemaException get_Exception();
    public string get_Message();
    public XmlSeverityType get_Severity();
}
public class System.Xml.Schema.ValidationEventHandler : MulticastDelegate {
    public ValidationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Xml.Schema.XmlAtomicValue : XPathItem {
    public bool IsNode { get; }
    public object TypedValue { get; }
    public string Value { get; }
    public bool ValueAsBoolean { get; }
    public DateTime ValueAsDateTime { get; }
    public double ValueAsDouble { get; }
    public int ValueAsInt { get; }
    public long ValueAsLong { get; }
    public Type ValueType { get; }
    public XmlSchemaType XmlType { get; }
    public virtual bool get_IsNode();
    public virtual object get_TypedValue();
    public virtual string get_Value();
    public virtual bool get_ValueAsBoolean();
    public virtual DateTime get_ValueAsDateTime();
    public virtual double get_ValueAsDouble();
    public virtual int get_ValueAsInt();
    public virtual long get_ValueAsLong();
    public virtual Type get_ValueType();
    public virtual XmlSchemaType get_XmlType();
    public XmlAtomicValue Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public virtual object ValueAs(Type type, IXmlNamespaceResolver nsResolver);
}
[XmlRootAttribute("schema")]
public class System.Xml.Schema.XmlSchema : XmlSchemaObject {
    public static string InstanceNamespace;
    public static string Namespace;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("attributeFormDefault")]
public XmlSchemaForm AttributeFormDefault { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable AttributeGroups { get; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable Attributes { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("blockDefault")]
public XmlSchemaDerivationMethod BlockDefault { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("elementFormDefault")]
public XmlSchemaForm ElementFormDefault { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable Elements { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("finalDefault")]
public XmlSchemaDerivationMethod FinalDefault { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable Groups { get; }
    [XmlAttributeAttribute("id")]
public string Id { get; public set; }
    [XmlElementAttribute("import", "System.Xml.Schema.XmlSchemaImport")]
[XmlElementAttribute("include", "System.Xml.Schema.XmlSchemaInclude")]
[XmlElementAttribute("redefine", "System.Xml.Schema.XmlSchemaRedefine")]
public XmlSchemaObjectCollection Includes { get; }
    [XmlIgnoreAttribute]
public bool IsCompiled { get; }
    [XmlElementAttribute("annotation", "System.Xml.Schema.XmlSchemaAnnotation")]
[XmlElementAttribute("attribute", "System.Xml.Schema.XmlSchemaAttribute")]
[XmlElementAttribute("attributeGroup", "System.Xml.Schema.XmlSchemaAttributeGroup")]
[XmlElementAttribute("complexType", "System.Xml.Schema.XmlSchemaComplexType")]
[XmlElementAttribute("element", "System.Xml.Schema.XmlSchemaElement")]
[XmlElementAttribute("group", "System.Xml.Schema.XmlSchemaGroup")]
[XmlElementAttribute("notation", "System.Xml.Schema.XmlSchemaNotation")]
[XmlElementAttribute("simpleType", "System.Xml.Schema.XmlSchemaSimpleType")]
public XmlSchemaObjectCollection Items { get; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable Notations { get; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable SchemaTypes { get; }
    [XmlAttributeAttribute("targetNamespace")]
public string TargetNamespace { get; public set; }
    [XmlAnyAttributeAttribute]
public XmlAttribute[] UnhandledAttributes { get; public set; }
    [XmlAttributeAttribute("version")]
public string Version { get; public set; }
    public XmlSchemaForm get_AttributeFormDefault();
    public void set_AttributeFormDefault(XmlSchemaForm value);
    public XmlSchemaObjectTable get_AttributeGroups();
    public XmlSchemaObjectTable get_Attributes();
    public XmlSchemaDerivationMethod get_BlockDefault();
    public void set_BlockDefault(XmlSchemaDerivationMethod value);
    public XmlSchemaForm get_ElementFormDefault();
    public void set_ElementFormDefault(XmlSchemaForm value);
    public XmlSchemaObjectTable get_Elements();
    public XmlSchemaDerivationMethod get_FinalDefault();
    public void set_FinalDefault(XmlSchemaDerivationMethod value);
    public XmlSchemaObjectTable get_Groups();
    public string get_Id();
    public void set_Id(string value);
    public XmlSchemaObjectCollection get_Includes();
    public bool get_IsCompiled();
    public XmlSchemaObjectCollection get_Items();
    public XmlSchemaObjectTable get_Notations();
    public XmlSchemaObjectTable get_SchemaTypes();
    public string get_TargetNamespace();
    public void set_TargetNamespace(string value);
    public XmlAttribute[] get_UnhandledAttributes();
    public void set_UnhandledAttributes(XmlAttribute[] value);
    public string get_Version();
    public void set_Version(string value);
    [ObsoleteAttribute("Use System.Xml.Schema.XmlSchemaSet for schema compilation and validation. https://go.microsoft.com/fwlink/?linkid=14202")]
public void Compile(ValidationEventHandler validationEventHandler);
    [ObsoleteAttribute("Use System.Xml.Schema.XmlSchemaSet for schema compilation and validation. https://go.microsoft.com/fwlink/?linkid=14202")]
public void Compile(ValidationEventHandler validationEventHandler, XmlResolver resolver);
    public static XmlSchema Read(Stream stream, ValidationEventHandler validationEventHandler);
    public static XmlSchema Read(TextReader reader, ValidationEventHandler validationEventHandler);
    public static XmlSchema Read(XmlReader reader, ValidationEventHandler validationEventHandler);
    public void Write(Stream stream);
    public void Write(Stream stream, XmlNamespaceManager namespaceManager);
    public void Write(TextWriter writer);
    public void Write(TextWriter writer, XmlNamespaceManager namespaceManager);
    public void Write(XmlWriter writer);
    public void Write(XmlWriter writer, XmlNamespaceManager namespaceManager);
}
public class System.Xml.Schema.XmlSchemaAll : XmlSchemaGroupBase {
    [XmlElementAttribute("element", "System.Xml.Schema.XmlSchemaElement")]
public XmlSchemaObjectCollection Items { get; }
    public virtual XmlSchemaObjectCollection get_Items();
}
public class System.Xml.Schema.XmlSchemaAnnotated : XmlSchemaObject {
    [XmlElementAttribute("annotation", "System.Xml.Schema.XmlSchemaAnnotation")]
public XmlSchemaAnnotation Annotation { get; public set; }
    [XmlAttributeAttribute("id")]
public string Id { get; public set; }
    [XmlAnyAttributeAttribute]
public XmlAttribute[] UnhandledAttributes { get; public set; }
    public XmlSchemaAnnotation get_Annotation();
    public void set_Annotation(XmlSchemaAnnotation value);
    public string get_Id();
    public void set_Id(string value);
    public XmlAttribute[] get_UnhandledAttributes();
    public void set_UnhandledAttributes(XmlAttribute[] value);
}
public class System.Xml.Schema.XmlSchemaAnnotation : XmlSchemaObject {
    [XmlAttributeAttribute("id")]
public string Id { get; public set; }
    [XmlElementAttribute("appinfo", "System.Xml.Schema.XmlSchemaAppInfo")]
[XmlElementAttribute("documentation", "System.Xml.Schema.XmlSchemaDocumentation")]
public XmlSchemaObjectCollection Items { get; }
    [XmlAnyAttributeAttribute]
public XmlAttribute[] UnhandledAttributes { get; public set; }
    public string get_Id();
    public void set_Id(string value);
    public XmlSchemaObjectCollection get_Items();
    public XmlAttribute[] get_UnhandledAttributes();
    public void set_UnhandledAttributes(XmlAttribute[] value);
}
public class System.Xml.Schema.XmlSchemaAny : XmlSchemaParticle {
    [XmlAttributeAttribute("namespace")]
public string Namespace { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("processContents")]
public XmlSchemaContentProcessing ProcessContents { get; public set; }
    public string get_Namespace();
    public void set_Namespace(string value);
    public XmlSchemaContentProcessing get_ProcessContents();
    public void set_ProcessContents(XmlSchemaContentProcessing value);
}
public class System.Xml.Schema.XmlSchemaAnyAttribute : XmlSchemaAnnotated {
    [XmlAttributeAttribute("namespace")]
public string Namespace { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("processContents")]
public XmlSchemaContentProcessing ProcessContents { get; public set; }
    public string get_Namespace();
    public void set_Namespace(string value);
    public XmlSchemaContentProcessing get_ProcessContents();
    public void set_ProcessContents(XmlSchemaContentProcessing value);
}
public class System.Xml.Schema.XmlSchemaAppInfo : XmlSchemaObject {
    [XmlAnyElementAttribute]
[XmlTextAttribute]
public XmlNode[] Markup { get; public set; }
    [XmlAttributeAttribute("source")]
public string Source { get; public set; }
    public XmlNode[] get_Markup();
    public void set_Markup(XmlNode[] value);
    public string get_Source();
    public void set_Source(string value);
}
public class System.Xml.Schema.XmlSchemaAttribute : XmlSchemaAnnotated {
    [XmlIgnoreAttribute]
public XmlSchemaSimpleType AttributeSchemaType { get; }
    [ObsoleteAttribute("This property has been deprecated. Please use AttributeSchemaType property that returns a strongly typed attribute type. https://go.microsoft.com/fwlink/?linkid=14202")]
[XmlIgnoreAttribute]
public object AttributeType { get; }
    [DefaultValueAttribute("")]
[XmlAttributeAttribute("default")]
public string DefaultValue { get; public set; }
    [DefaultValueAttribute("")]
[XmlAttributeAttribute("fixed")]
public string FixedValue { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("form")]
public XmlSchemaForm Form { get; public set; }
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlIgnoreAttribute]
public XmlQualifiedName QualifiedName { get; }
    [XmlAttributeAttribute("ref")]
public XmlQualifiedName RefName { get; public set; }
    [XmlElementAttribute("simpleType")]
public XmlSchemaSimpleType SchemaType { get; public set; }
    [XmlAttributeAttribute("type")]
public XmlQualifiedName SchemaTypeName { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("use")]
public XmlSchemaUse Use { get; public set; }
    public XmlSchemaSimpleType get_AttributeSchemaType();
    public object get_AttributeType();
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public string get_FixedValue();
    public void set_FixedValue(string value);
    public XmlSchemaForm get_Form();
    public void set_Form(XmlSchemaForm value);
    public string get_Name();
    public void set_Name(string value);
    public XmlQualifiedName get_QualifiedName();
    public XmlQualifiedName get_RefName();
    public void set_RefName(XmlQualifiedName value);
    public XmlSchemaSimpleType get_SchemaType();
    public void set_SchemaType(XmlSchemaSimpleType value);
    public XmlQualifiedName get_SchemaTypeName();
    public void set_SchemaTypeName(XmlQualifiedName value);
    public XmlSchemaUse get_Use();
    public void set_Use(XmlSchemaUse value);
}
public class System.Xml.Schema.XmlSchemaAttributeGroup : XmlSchemaAnnotated {
    [XmlElementAttribute("anyAttribute")]
public XmlSchemaAnyAttribute AnyAttribute { get; public set; }
    [XmlElementAttribute("attribute", "System.Xml.Schema.XmlSchemaAttribute")]
[XmlElementAttribute("attributeGroup", "System.Xml.Schema.XmlSchemaAttributeGroupRef")]
public XmlSchemaObjectCollection Attributes { get; }
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlIgnoreAttribute]
public XmlQualifiedName QualifiedName { get; }
    [XmlIgnoreAttribute]
public XmlSchemaAttributeGroup RedefinedAttributeGroup { get; }
    public XmlSchemaAnyAttribute get_AnyAttribute();
    public void set_AnyAttribute(XmlSchemaAnyAttribute value);
    public XmlSchemaObjectCollection get_Attributes();
    public string get_Name();
    public void set_Name(string value);
    public XmlQualifiedName get_QualifiedName();
    public XmlSchemaAttributeGroup get_RedefinedAttributeGroup();
}
public class System.Xml.Schema.XmlSchemaAttributeGroupRef : XmlSchemaAnnotated {
    [XmlAttributeAttribute("ref")]
public XmlQualifiedName RefName { get; public set; }
    public XmlQualifiedName get_RefName();
    public void set_RefName(XmlQualifiedName value);
}
public class System.Xml.Schema.XmlSchemaChoice : XmlSchemaGroupBase {
    [XmlElementAttribute("any", "System.Xml.Schema.XmlSchemaAny")]
[XmlElementAttribute("choice", "System.Xml.Schema.XmlSchemaChoice")]
[XmlElementAttribute("element", "System.Xml.Schema.XmlSchemaElement")]
[XmlElementAttribute("group", "System.Xml.Schema.XmlSchemaGroupRef")]
[XmlElementAttribute("sequence", "System.Xml.Schema.XmlSchemaSequence")]
public XmlSchemaObjectCollection Items { get; }
    public virtual XmlSchemaObjectCollection get_Items();
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("Use System.Xml.Schema.XmlSchemaSet for schema compilation and validation. https://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Xml.Schema.XmlSchemaCollection : object {
    public int Count { get; }
    public XmlSchema Item { get; }
    public XmlNameTable NameTable { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public XmlSchemaCollection(XmlNameTable nametable);
    public int get_Count();
    public XmlSchema get_Item(string ns);
    public XmlNameTable get_NameTable();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void add_ValidationEventHandler(ValidationEventHandler value);
    public void remove_ValidationEventHandler(ValidationEventHandler value);
    public XmlSchema Add(string ns, string uri);
    public XmlSchema Add(string ns, XmlReader reader);
    public XmlSchema Add(string ns, XmlReader reader, XmlResolver resolver);
    public XmlSchema Add(XmlSchema schema);
    public XmlSchema Add(XmlSchema schema, XmlResolver resolver);
    public void Add(XmlSchemaCollection schema);
    public bool Contains(string ns);
    public bool Contains(XmlSchema schema);
    public void CopyTo(XmlSchema[] array, int index);
    public XmlSchemaCollectionEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Xml.Schema.XmlSchemaCollectionEnumerator : object {
    public XmlSchema Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public XmlSchema get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public class System.Xml.Schema.XmlSchemaCompilationSettings : object {
    public bool EnableUpaCheck { get; public set; }
    public bool get_EnableUpaCheck();
    public void set_EnableUpaCheck(bool value);
}
public class System.Xml.Schema.XmlSchemaComplexContent : XmlSchemaContentModel {
    [XmlElementAttribute("extension", "System.Xml.Schema.XmlSchemaComplexContentExtension")]
[XmlElementAttribute("restriction", "System.Xml.Schema.XmlSchemaComplexContentRestriction")]
public XmlSchemaContent Content { get; public set; }
    [XmlAttributeAttribute("mixed")]
public bool IsMixed { get; public set; }
    public virtual XmlSchemaContent get_Content();
    public virtual void set_Content(XmlSchemaContent value);
    public bool get_IsMixed();
    public void set_IsMixed(bool value);
}
public class System.Xml.Schema.XmlSchemaComplexContentExtension : XmlSchemaContent {
    [XmlElementAttribute("anyAttribute")]
public XmlSchemaAnyAttribute AnyAttribute { get; public set; }
    [XmlElementAttribute("attribute", "System.Xml.Schema.XmlSchemaAttribute")]
[XmlElementAttribute("attributeGroup", "System.Xml.Schema.XmlSchemaAttributeGroupRef")]
public XmlSchemaObjectCollection Attributes { get; }
    [XmlAttributeAttribute("base")]
public XmlQualifiedName BaseTypeName { get; public set; }
    [XmlElementAttribute("all", "System.Xml.Schema.XmlSchemaAll")]
[XmlElementAttribute("choice", "System.Xml.Schema.XmlSchemaChoice")]
[XmlElementAttribute("group", "System.Xml.Schema.XmlSchemaGroupRef")]
[XmlElementAttribute("sequence", "System.Xml.Schema.XmlSchemaSequence")]
public XmlSchemaParticle Particle { get; public set; }
    public XmlSchemaAnyAttribute get_AnyAttribute();
    public void set_AnyAttribute(XmlSchemaAnyAttribute value);
    public XmlSchemaObjectCollection get_Attributes();
    public XmlQualifiedName get_BaseTypeName();
    public void set_BaseTypeName(XmlQualifiedName value);
    public XmlSchemaParticle get_Particle();
    public void set_Particle(XmlSchemaParticle value);
}
public class System.Xml.Schema.XmlSchemaComplexContentRestriction : XmlSchemaContent {
    [XmlElementAttribute("anyAttribute")]
public XmlSchemaAnyAttribute AnyAttribute { get; public set; }
    [XmlElementAttribute("attribute", "System.Xml.Schema.XmlSchemaAttribute")]
[XmlElementAttribute("attributeGroup", "System.Xml.Schema.XmlSchemaAttributeGroupRef")]
public XmlSchemaObjectCollection Attributes { get; }
    [XmlAttributeAttribute("base")]
public XmlQualifiedName BaseTypeName { get; public set; }
    [XmlElementAttribute("all", "System.Xml.Schema.XmlSchemaAll")]
[XmlElementAttribute("choice", "System.Xml.Schema.XmlSchemaChoice")]
[XmlElementAttribute("group", "System.Xml.Schema.XmlSchemaGroupRef")]
[XmlElementAttribute("sequence", "System.Xml.Schema.XmlSchemaSequence")]
public XmlSchemaParticle Particle { get; public set; }
    public XmlSchemaAnyAttribute get_AnyAttribute();
    public void set_AnyAttribute(XmlSchemaAnyAttribute value);
    public XmlSchemaObjectCollection get_Attributes();
    public XmlQualifiedName get_BaseTypeName();
    public void set_BaseTypeName(XmlQualifiedName value);
    public XmlSchemaParticle get_Particle();
    public void set_Particle(XmlSchemaParticle value);
}
public class System.Xml.Schema.XmlSchemaComplexType : XmlSchemaType {
    [XmlElementAttribute("anyAttribute")]
public XmlSchemaAnyAttribute AnyAttribute { get; public set; }
    [XmlElementAttribute("attribute", "System.Xml.Schema.XmlSchemaAttribute")]
[XmlElementAttribute("attributeGroup", "System.Xml.Schema.XmlSchemaAttributeGroupRef")]
public XmlSchemaObjectCollection Attributes { get; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable AttributeUses { get; }
    [XmlIgnoreAttribute]
public XmlSchemaAnyAttribute AttributeWildcard { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("block")]
public XmlSchemaDerivationMethod Block { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaDerivationMethod BlockResolved { get; }
    [XmlElementAttribute("complexContent", "System.Xml.Schema.XmlSchemaComplexContent")]
[XmlElementAttribute("simpleContent", "System.Xml.Schema.XmlSchemaSimpleContent")]
public XmlSchemaContentModel ContentModel { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaContentType ContentType { get; }
    [XmlIgnoreAttribute]
public XmlSchemaParticle ContentTypeParticle { get; }
    [DefaultValueAttribute("False")]
[XmlAttributeAttribute("abstract")]
public bool IsAbstract { get; public set; }
    [DefaultValueAttribute("False")]
[XmlAttributeAttribute("mixed")]
public bool IsMixed { get; public set; }
    [XmlElementAttribute("all", "System.Xml.Schema.XmlSchemaAll")]
[XmlElementAttribute("choice", "System.Xml.Schema.XmlSchemaChoice")]
[XmlElementAttribute("group", "System.Xml.Schema.XmlSchemaGroupRef")]
[XmlElementAttribute("sequence", "System.Xml.Schema.XmlSchemaSequence")]
public XmlSchemaParticle Particle { get; public set; }
    public XmlSchemaAnyAttribute get_AnyAttribute();
    public void set_AnyAttribute(XmlSchemaAnyAttribute value);
    public XmlSchemaObjectCollection get_Attributes();
    public XmlSchemaObjectTable get_AttributeUses();
    public XmlSchemaAnyAttribute get_AttributeWildcard();
    public XmlSchemaDerivationMethod get_Block();
    public void set_Block(XmlSchemaDerivationMethod value);
    public XmlSchemaDerivationMethod get_BlockResolved();
    public XmlSchemaContentModel get_ContentModel();
    public void set_ContentModel(XmlSchemaContentModel value);
    public XmlSchemaContentType get_ContentType();
    public XmlSchemaParticle get_ContentTypeParticle();
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public virtual bool get_IsMixed();
    public virtual void set_IsMixed(bool value);
    public XmlSchemaParticle get_Particle();
    public void set_Particle(XmlSchemaParticle value);
}
public abstract class System.Xml.Schema.XmlSchemaContent : XmlSchemaAnnotated {
}
public abstract class System.Xml.Schema.XmlSchemaContentModel : XmlSchemaAnnotated {
    [XmlIgnoreAttribute]
public XmlSchemaContent Content { get; public set; }
    public abstract virtual XmlSchemaContent get_Content();
    public abstract virtual void set_Content(XmlSchemaContent value);
}
public enum System.Xml.Schema.XmlSchemaContentProcessing : Enum {
    public int value__;
    [XmlEnumAttribute("lax")]
public static XmlSchemaContentProcessing Lax;
    [XmlIgnoreAttribute]
public static XmlSchemaContentProcessing None;
    [XmlEnumAttribute("skip")]
public static XmlSchemaContentProcessing Skip;
    [XmlEnumAttribute("strict")]
public static XmlSchemaContentProcessing Strict;
}
public enum System.Xml.Schema.XmlSchemaContentType : Enum {
    public int value__;
    public static XmlSchemaContentType ElementOnly;
    public static XmlSchemaContentType Empty;
    public static XmlSchemaContentType Mixed;
    public static XmlSchemaContentType TextOnly;
}
public abstract class System.Xml.Schema.XmlSchemaDatatype : object {
    public XmlTokenizedType TokenizedType { get; }
    public XmlTypeCode TypeCode { get; }
    public Type ValueType { get; }
    public XmlSchemaDatatypeVariety Variety { get; }
    public abstract virtual XmlTokenizedType get_TokenizedType();
    public virtual XmlTypeCode get_TypeCode();
    public abstract virtual Type get_ValueType();
    public virtual XmlSchemaDatatypeVariety get_Variety();
    public virtual object ChangeType(object value, Type targetType);
    public virtual object ChangeType(object value, Type targetType, IXmlNamespaceResolver namespaceResolver);
    public virtual bool IsDerivedFrom(XmlSchemaDatatype datatype);
    public abstract virtual object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr);
}
public enum System.Xml.Schema.XmlSchemaDatatypeVariety : Enum {
    public int value__;
    public static XmlSchemaDatatypeVariety Atomic;
    public static XmlSchemaDatatypeVariety List;
    public static XmlSchemaDatatypeVariety Union;
}
[FlagsAttribute]
public enum System.Xml.Schema.XmlSchemaDerivationMethod : Enum {
    public int value__;
    [XmlEnumAttribute("#all")]
public static XmlSchemaDerivationMethod All;
    [XmlEnumAttribute("")]
public static XmlSchemaDerivationMethod Empty;
    [XmlEnumAttribute("extension")]
public static XmlSchemaDerivationMethod Extension;
    [XmlEnumAttribute("list")]
public static XmlSchemaDerivationMethod List;
    [XmlIgnoreAttribute]
public static XmlSchemaDerivationMethod None;
    [XmlEnumAttribute("restriction")]
public static XmlSchemaDerivationMethod Restriction;
    [XmlEnumAttribute("substitution")]
public static XmlSchemaDerivationMethod Substitution;
    [XmlEnumAttribute("union")]
public static XmlSchemaDerivationMethod Union;
}
public class System.Xml.Schema.XmlSchemaDocumentation : XmlSchemaObject {
    [XmlAttributeAttribute("xml:lang")]
public string Language { get; public set; }
    [XmlAnyElementAttribute]
[XmlTextAttribute]
public XmlNode[] Markup { get; public set; }
    [XmlAttributeAttribute("source")]
public string Source { get; public set; }
    public string get_Language();
    public void set_Language(string value);
    public XmlNode[] get_Markup();
    public void set_Markup(XmlNode[] value);
    public string get_Source();
    public void set_Source(string value);
}
public class System.Xml.Schema.XmlSchemaElement : XmlSchemaParticle {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("block")]
public XmlSchemaDerivationMethod Block { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaDerivationMethod BlockResolved { get; }
    [XmlElementAttribute("key", "System.Xml.Schema.XmlSchemaKey")]
[XmlElementAttribute("keyref", "System.Xml.Schema.XmlSchemaKeyref")]
[XmlElementAttribute("unique", "System.Xml.Schema.XmlSchemaUnique")]
public XmlSchemaObjectCollection Constraints { get; }
    [DefaultValueAttribute("")]
[XmlAttributeAttribute("default")]
public string DefaultValue { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaType ElementSchemaType { get; }
    [ObsoleteAttribute("This property has been deprecated. Please use ElementSchemaType property that returns a strongly typed element type. https://go.microsoft.com/fwlink/?linkid=14202")]
[XmlIgnoreAttribute]
public object ElementType { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("final")]
public XmlSchemaDerivationMethod Final { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaDerivationMethod FinalResolved { get; }
    [DefaultValueAttribute("")]
[XmlAttributeAttribute("fixed")]
public string FixedValue { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("form")]
public XmlSchemaForm Form { get; public set; }
    [DefaultValueAttribute("False")]
[XmlAttributeAttribute("abstract")]
public bool IsAbstract { get; public set; }
    [DefaultValueAttribute("False")]
[XmlAttributeAttribute("nillable")]
public bool IsNillable { get; public set; }
    [DefaultValueAttribute("")]
[XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlIgnoreAttribute]
public XmlQualifiedName QualifiedName { get; }
    [XmlAttributeAttribute("ref")]
public XmlQualifiedName RefName { get; public set; }
    [XmlElementAttribute("complexType", "System.Xml.Schema.XmlSchemaComplexType")]
[XmlElementAttribute("simpleType", "System.Xml.Schema.XmlSchemaSimpleType")]
public XmlSchemaType SchemaType { get; public set; }
    [XmlAttributeAttribute("type")]
public XmlQualifiedName SchemaTypeName { get; public set; }
    [XmlAttributeAttribute("substitutionGroup")]
public XmlQualifiedName SubstitutionGroup { get; public set; }
    public XmlSchemaDerivationMethod get_Block();
    public void set_Block(XmlSchemaDerivationMethod value);
    public XmlSchemaDerivationMethod get_BlockResolved();
    public XmlSchemaObjectCollection get_Constraints();
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public XmlSchemaType get_ElementSchemaType();
    public object get_ElementType();
    public XmlSchemaDerivationMethod get_Final();
    public void set_Final(XmlSchemaDerivationMethod value);
    public XmlSchemaDerivationMethod get_FinalResolved();
    public string get_FixedValue();
    public void set_FixedValue(string value);
    public XmlSchemaForm get_Form();
    public void set_Form(XmlSchemaForm value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsNillable();
    public void set_IsNillable(bool value);
    public string get_Name();
    public void set_Name(string value);
    public XmlQualifiedName get_QualifiedName();
    public XmlQualifiedName get_RefName();
    public void set_RefName(XmlQualifiedName value);
    public XmlSchemaType get_SchemaType();
    public void set_SchemaType(XmlSchemaType value);
    public XmlQualifiedName get_SchemaTypeName();
    public void set_SchemaTypeName(XmlQualifiedName value);
    public XmlQualifiedName get_SubstitutionGroup();
    public void set_SubstitutionGroup(XmlQualifiedName value);
}
public class System.Xml.Schema.XmlSchemaEnumerationFacet : XmlSchemaFacet {
}
public class System.Xml.Schema.XmlSchemaException : SystemException {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Message { get; }
    public XmlSchemaObject SourceSchemaObject { get; }
    public string SourceUri { get; }
    protected XmlSchemaException(SerializationInfo info, StreamingContext context);
    public XmlSchemaException(string message);
    public XmlSchemaException(string message, Exception innerException);
    public XmlSchemaException(string message, Exception innerException, int lineNumber, int linePosition);
    public int get_LineNumber();
    public int get_LinePosition();
    public virtual string get_Message();
    public XmlSchemaObject get_SourceSchemaObject();
    public string get_SourceUri();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.Xml.Schema.XmlSchemaExternal : XmlSchemaObject {
    [XmlAttributeAttribute("id")]
public string Id { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchema Schema { get; public set; }
    [XmlAttributeAttribute("schemaLocation")]
public string SchemaLocation { get; public set; }
    [XmlAnyAttributeAttribute]
public XmlAttribute[] UnhandledAttributes { get; public set; }
    public string get_Id();
    public void set_Id(string value);
    public XmlSchema get_Schema();
    public void set_Schema(XmlSchema value);
    public string get_SchemaLocation();
    public void set_SchemaLocation(string value);
    public XmlAttribute[] get_UnhandledAttributes();
    public void set_UnhandledAttributes(XmlAttribute[] value);
}
public abstract class System.Xml.Schema.XmlSchemaFacet : XmlSchemaAnnotated {
    [DefaultValueAttribute("False")]
[XmlAttributeAttribute("fixed")]
public bool IsFixed { get; public set; }
    [XmlAttributeAttribute("value")]
public string Value { get; public set; }
    public virtual bool get_IsFixed();
    public virtual void set_IsFixed(bool value);
    public string get_Value();
    public void set_Value(string value);
}
public enum System.Xml.Schema.XmlSchemaForm : Enum {
    public int value__;
    [XmlIgnoreAttribute]
public static XmlSchemaForm None;
    [XmlEnumAttribute("qualified")]
public static XmlSchemaForm Qualified;
    [XmlEnumAttribute("unqualified")]
public static XmlSchemaForm Unqualified;
}
public class System.Xml.Schema.XmlSchemaFractionDigitsFacet : XmlSchemaNumericFacet {
}
public class System.Xml.Schema.XmlSchemaGroup : XmlSchemaAnnotated {
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlElementAttribute("all", "System.Xml.Schema.XmlSchemaAll")]
[XmlElementAttribute("choice", "System.Xml.Schema.XmlSchemaChoice")]
[XmlElementAttribute("sequence", "System.Xml.Schema.XmlSchemaSequence")]
public XmlSchemaGroupBase Particle { get; public set; }
    [XmlIgnoreAttribute]
public XmlQualifiedName QualifiedName { get; }
    public string get_Name();
    public void set_Name(string value);
    public XmlSchemaGroupBase get_Particle();
    public void set_Particle(XmlSchemaGroupBase value);
    public XmlQualifiedName get_QualifiedName();
}
public abstract class System.Xml.Schema.XmlSchemaGroupBase : XmlSchemaParticle {
    [XmlIgnoreAttribute]
public XmlSchemaObjectCollection Items { get; }
    public abstract virtual XmlSchemaObjectCollection get_Items();
}
public class System.Xml.Schema.XmlSchemaGroupRef : XmlSchemaParticle {
    [XmlIgnoreAttribute]
public XmlSchemaGroupBase Particle { get; }
    [XmlAttributeAttribute("ref")]
public XmlQualifiedName RefName { get; public set; }
    public XmlSchemaGroupBase get_Particle();
    public XmlQualifiedName get_RefName();
    public void set_RefName(XmlQualifiedName value);
}
public class System.Xml.Schema.XmlSchemaIdentityConstraint : XmlSchemaAnnotated {
    [XmlElementAttribute("field", "System.Xml.Schema.XmlSchemaXPath")]
public XmlSchemaObjectCollection Fields { get; }
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlIgnoreAttribute]
public XmlQualifiedName QualifiedName { get; }
    [XmlElementAttribute("selector", "System.Xml.Schema.XmlSchemaXPath")]
public XmlSchemaXPath Selector { get; public set; }
    public XmlSchemaObjectCollection get_Fields();
    public string get_Name();
    public void set_Name(string value);
    public XmlQualifiedName get_QualifiedName();
    public XmlSchemaXPath get_Selector();
    public void set_Selector(XmlSchemaXPath value);
}
public class System.Xml.Schema.XmlSchemaImport : XmlSchemaExternal {
    [XmlElementAttribute("annotation", "System.Xml.Schema.XmlSchemaAnnotation")]
public XmlSchemaAnnotation Annotation { get; public set; }
    [XmlAttributeAttribute("namespace")]
public string Namespace { get; public set; }
    public XmlSchemaAnnotation get_Annotation();
    public void set_Annotation(XmlSchemaAnnotation value);
    public string get_Namespace();
    public void set_Namespace(string value);
}
public class System.Xml.Schema.XmlSchemaInclude : XmlSchemaExternal {
    [XmlElementAttribute("annotation", "System.Xml.Schema.XmlSchemaAnnotation")]
public XmlSchemaAnnotation Annotation { get; public set; }
    public XmlSchemaAnnotation get_Annotation();
    public void set_Annotation(XmlSchemaAnnotation value);
}
public class System.Xml.Schema.XmlSchemaInference : object {
    public InferenceOption Occurrence { get; public set; }
    public InferenceOption TypeInference { get; public set; }
    public InferenceOption get_Occurrence();
    public void set_Occurrence(InferenceOption value);
    public InferenceOption get_TypeInference();
    public void set_TypeInference(InferenceOption value);
    public XmlSchemaSet InferSchema(XmlReader instanceDocument);
    public XmlSchemaSet InferSchema(XmlReader instanceDocument, XmlSchemaSet schemas);
}
public class System.Xml.Schema.XmlSchemaInferenceException : XmlSchemaException {
    protected XmlSchemaInferenceException(SerializationInfo info, StreamingContext context);
    public XmlSchemaInferenceException(string message);
    public XmlSchemaInferenceException(string message, Exception innerException);
    public XmlSchemaInferenceException(string message, Exception innerException, int lineNumber, int linePosition);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Xml.Schema.XmlSchemaInfo : object {
    public XmlSchemaContentType ContentType { get; public set; }
    public bool IsDefault { get; public set; }
    public bool IsNil { get; public set; }
    public XmlSchemaSimpleType MemberType { get; public set; }
    public XmlSchemaAttribute SchemaAttribute { get; public set; }
    public XmlSchemaElement SchemaElement { get; public set; }
    public XmlSchemaType SchemaType { get; public set; }
    public XmlSchemaValidity Validity { get; public set; }
    public XmlSchemaContentType get_ContentType();
    public void set_ContentType(XmlSchemaContentType value);
    public sealed virtual bool get_IsDefault();
    public void set_IsDefault(bool value);
    public sealed virtual bool get_IsNil();
    public void set_IsNil(bool value);
    public sealed virtual XmlSchemaSimpleType get_MemberType();
    public void set_MemberType(XmlSchemaSimpleType value);
    public sealed virtual XmlSchemaAttribute get_SchemaAttribute();
    public void set_SchemaAttribute(XmlSchemaAttribute value);
    public sealed virtual XmlSchemaElement get_SchemaElement();
    public void set_SchemaElement(XmlSchemaElement value);
    public sealed virtual XmlSchemaType get_SchemaType();
    public void set_SchemaType(XmlSchemaType value);
    public sealed virtual XmlSchemaValidity get_Validity();
    public void set_Validity(XmlSchemaValidity value);
}
public class System.Xml.Schema.XmlSchemaKey : XmlSchemaIdentityConstraint {
}
public class System.Xml.Schema.XmlSchemaKeyref : XmlSchemaIdentityConstraint {
    [XmlAttributeAttribute("refer")]
public XmlQualifiedName Refer { get; public set; }
    public XmlQualifiedName get_Refer();
    public void set_Refer(XmlQualifiedName value);
}
public class System.Xml.Schema.XmlSchemaLengthFacet : XmlSchemaNumericFacet {
}
public class System.Xml.Schema.XmlSchemaMaxExclusiveFacet : XmlSchemaFacet {
}
public class System.Xml.Schema.XmlSchemaMaxInclusiveFacet : XmlSchemaFacet {
}
public class System.Xml.Schema.XmlSchemaMaxLengthFacet : XmlSchemaNumericFacet {
}
public class System.Xml.Schema.XmlSchemaMinExclusiveFacet : XmlSchemaFacet {
}
public class System.Xml.Schema.XmlSchemaMinInclusiveFacet : XmlSchemaFacet {
}
public class System.Xml.Schema.XmlSchemaMinLengthFacet : XmlSchemaNumericFacet {
}
public class System.Xml.Schema.XmlSchemaNotation : XmlSchemaAnnotated {
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("public")]
public string Public { get; public set; }
    [XmlAttributeAttribute("system")]
public string System { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Public();
    public void set_Public(string value);
    public string get_System();
    public void set_System(string value);
}
public abstract class System.Xml.Schema.XmlSchemaNumericFacet : XmlSchemaFacet {
}
public abstract class System.Xml.Schema.XmlSchemaObject : object {
    [XmlIgnoreAttribute]
public int LineNumber { get; public set; }
    [XmlIgnoreAttribute]
public int LinePosition { get; public set; }
    [XmlNamespaceDeclarationsAttribute]
public XmlSerializerNamespaces Namespaces { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaObject Parent { get; public set; }
    [XmlIgnoreAttribute]
public string SourceUri { get; public set; }
    public int get_LineNumber();
    public void set_LineNumber(int value);
    public int get_LinePosition();
    public void set_LinePosition(int value);
    public XmlSerializerNamespaces get_Namespaces();
    public void set_Namespaces(XmlSerializerNamespaces value);
    public XmlSchemaObject get_Parent();
    public void set_Parent(XmlSchemaObject value);
    public string get_SourceUri();
    public void set_SourceUri(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Schema.XmlSchemaObjectCollection : CollectionBase {
    public XmlSchemaObject Item { get; public set; }
    public XmlSchemaObjectCollection(XmlSchemaObject parent);
    public virtual XmlSchemaObject get_Item(int index);
    public virtual void set_Item(int index, XmlSchemaObject value);
    public int Add(XmlSchemaObject item);
    public bool Contains(XmlSchemaObject item);
    public void CopyTo(XmlSchemaObject[] array, int index);
    public XmlSchemaObjectEnumerator GetEnumerator();
    public int IndexOf(XmlSchemaObject item);
    public void Insert(int index, XmlSchemaObject item);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object item);
    protected virtual void OnRemove(int index, object item);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    public void Remove(XmlSchemaObject item);
}
public class System.Xml.Schema.XmlSchemaObjectEnumerator : object {
    public XmlSchemaObject Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public XmlSchemaObject get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    public void Reset();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Schema.XmlSchemaObjectTable : object {
    public int Count { get; }
    public XmlSchemaObject Item { get; }
    public ICollection Names { get; }
    public ICollection Values { get; }
    public int get_Count();
    public XmlSchemaObject get_Item(XmlQualifiedName name);
    public ICollection get_Names();
    public ICollection get_Values();
    public bool Contains(XmlQualifiedName name);
    public IDictionaryEnumerator GetEnumerator();
}
public abstract class System.Xml.Schema.XmlSchemaParticle : XmlSchemaAnnotated {
    [XmlIgnoreAttribute]
public decimal MaxOccurs { get; public set; }
    [XmlAttributeAttribute("maxOccurs")]
public string MaxOccursString { get; public set; }
    [XmlIgnoreAttribute]
public decimal MinOccurs { get; public set; }
    [XmlAttributeAttribute("minOccurs")]
public string MinOccursString { get; public set; }
    public decimal get_MaxOccurs();
    public void set_MaxOccurs(decimal value);
    public string get_MaxOccursString();
    public void set_MaxOccursString(string value);
    public decimal get_MinOccurs();
    public void set_MinOccurs(decimal value);
    public string get_MinOccursString();
    public void set_MinOccursString(string value);
}
public class System.Xml.Schema.XmlSchemaPatternFacet : XmlSchemaFacet {
}
public class System.Xml.Schema.XmlSchemaRedefine : XmlSchemaExternal {
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable AttributeGroups { get; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable Groups { get; }
    [XmlElementAttribute("annotation", "System.Xml.Schema.XmlSchemaAnnotation")]
[XmlElementAttribute("attributeGroup", "System.Xml.Schema.XmlSchemaAttributeGroup")]
[XmlElementAttribute("complexType", "System.Xml.Schema.XmlSchemaComplexType")]
[XmlElementAttribute("group", "System.Xml.Schema.XmlSchemaGroup")]
[XmlElementAttribute("simpleType", "System.Xml.Schema.XmlSchemaSimpleType")]
public XmlSchemaObjectCollection Items { get; }
    [XmlIgnoreAttribute]
public XmlSchemaObjectTable SchemaTypes { get; }
    public XmlSchemaObjectTable get_AttributeGroups();
    public XmlSchemaObjectTable get_Groups();
    public XmlSchemaObjectCollection get_Items();
    public XmlSchemaObjectTable get_SchemaTypes();
}
public class System.Xml.Schema.XmlSchemaSequence : XmlSchemaGroupBase {
    [XmlElementAttribute("any", "System.Xml.Schema.XmlSchemaAny")]
[XmlElementAttribute("choice", "System.Xml.Schema.XmlSchemaChoice")]
[XmlElementAttribute("element", "System.Xml.Schema.XmlSchemaElement")]
[XmlElementAttribute("group", "System.Xml.Schema.XmlSchemaGroupRef")]
[XmlElementAttribute("sequence", "System.Xml.Schema.XmlSchemaSequence")]
public XmlSchemaObjectCollection Items { get; }
    public virtual XmlSchemaObjectCollection get_Items();
}
public class System.Xml.Schema.XmlSchemaSet : object {
    public XmlSchemaCompilationSettings CompilationSettings { get; public set; }
    public int Count { get; }
    public XmlSchemaObjectTable GlobalAttributes { get; }
    public XmlSchemaObjectTable GlobalElements { get; }
    public XmlSchemaObjectTable GlobalTypes { get; }
    public bool IsCompiled { get; }
    public XmlNameTable NameTable { get; }
    unknown XmlResolver XmlResolver {public set; }
    public XmlSchemaSet(XmlNameTable nameTable);
    public XmlSchemaCompilationSettings get_CompilationSettings();
    public void set_CompilationSettings(XmlSchemaCompilationSettings value);
    public int get_Count();
    public XmlSchemaObjectTable get_GlobalAttributes();
    public XmlSchemaObjectTable get_GlobalElements();
    public XmlSchemaObjectTable get_GlobalTypes();
    public bool get_IsCompiled();
    public XmlNameTable get_NameTable();
    public void set_XmlResolver(XmlResolver value);
    public void add_ValidationEventHandler(ValidationEventHandler value);
    public void remove_ValidationEventHandler(ValidationEventHandler value);
    public XmlSchema Add(string targetNamespace, string schemaUri);
    public XmlSchema Add(string targetNamespace, XmlReader schemaDocument);
    public XmlSchema Add(XmlSchema schema);
    public void Add(XmlSchemaSet schemas);
    public void Compile();
    public bool Contains(string targetNamespace);
    public bool Contains(XmlSchema schema);
    public void CopyTo(XmlSchema[] schemas, int index);
    public XmlSchema Remove(XmlSchema schema);
    public bool RemoveRecursive(XmlSchema schemaToRemove);
    public XmlSchema Reprocess(XmlSchema schema);
    public ICollection Schemas();
    public ICollection Schemas(string targetNamespace);
}
public class System.Xml.Schema.XmlSchemaSimpleContent : XmlSchemaContentModel {
    [XmlElementAttribute("extension", "System.Xml.Schema.XmlSchemaSimpleContentExtension")]
[XmlElementAttribute("restriction", "System.Xml.Schema.XmlSchemaSimpleContentRestriction")]
public XmlSchemaContent Content { get; public set; }
    public virtual XmlSchemaContent get_Content();
    public virtual void set_Content(XmlSchemaContent value);
}
public class System.Xml.Schema.XmlSchemaSimpleContentExtension : XmlSchemaContent {
    [XmlElementAttribute("anyAttribute")]
public XmlSchemaAnyAttribute AnyAttribute { get; public set; }
    [XmlElementAttribute("attribute", "System.Xml.Schema.XmlSchemaAttribute")]
[XmlElementAttribute("attributeGroup", "System.Xml.Schema.XmlSchemaAttributeGroupRef")]
public XmlSchemaObjectCollection Attributes { get; }
    [XmlAttributeAttribute("base")]
public XmlQualifiedName BaseTypeName { get; public set; }
    public XmlSchemaAnyAttribute get_AnyAttribute();
    public void set_AnyAttribute(XmlSchemaAnyAttribute value);
    public XmlSchemaObjectCollection get_Attributes();
    public XmlQualifiedName get_BaseTypeName();
    public void set_BaseTypeName(XmlQualifiedName value);
}
public class System.Xml.Schema.XmlSchemaSimpleContentRestriction : XmlSchemaContent {
    [XmlElementAttribute("anyAttribute")]
public XmlSchemaAnyAttribute AnyAttribute { get; public set; }
    [XmlElementAttribute("attribute", "System.Xml.Schema.XmlSchemaAttribute")]
[XmlElementAttribute("attributeGroup", "System.Xml.Schema.XmlSchemaAttributeGroupRef")]
public XmlSchemaObjectCollection Attributes { get; }
    [XmlElementAttribute("simpleType", "System.Xml.Schema.XmlSchemaSimpleType")]
public XmlSchemaSimpleType BaseType { get; public set; }
    [XmlAttributeAttribute("base")]
public XmlQualifiedName BaseTypeName { get; public set; }
    [XmlElementAttribute("enumeration", "System.Xml.Schema.XmlSchemaEnumerationFacet")]
[XmlElementAttribute("fractionDigits", "System.Xml.Schema.XmlSchemaFractionDigitsFacet")]
[XmlElementAttribute("length", "System.Xml.Schema.XmlSchemaLengthFacet")]
[XmlElementAttribute("maxExclusive", "System.Xml.Schema.XmlSchemaMaxExclusiveFacet")]
[XmlElementAttribute("maxInclusive", "System.Xml.Schema.XmlSchemaMaxInclusiveFacet")]
[XmlElementAttribute("maxLength", "System.Xml.Schema.XmlSchemaMaxLengthFacet")]
[XmlElementAttribute("minExclusive", "System.Xml.Schema.XmlSchemaMinExclusiveFacet")]
[XmlElementAttribute("minInclusive", "System.Xml.Schema.XmlSchemaMinInclusiveFacet")]
[XmlElementAttribute("minLength", "System.Xml.Schema.XmlSchemaMinLengthFacet")]
[XmlElementAttribute("pattern", "System.Xml.Schema.XmlSchemaPatternFacet")]
[XmlElementAttribute("totalDigits", "System.Xml.Schema.XmlSchemaTotalDigitsFacet")]
[XmlElementAttribute("whiteSpace", "System.Xml.Schema.XmlSchemaWhiteSpaceFacet")]
public XmlSchemaObjectCollection Facets { get; }
    public XmlSchemaAnyAttribute get_AnyAttribute();
    public void set_AnyAttribute(XmlSchemaAnyAttribute value);
    public XmlSchemaObjectCollection get_Attributes();
    public XmlSchemaSimpleType get_BaseType();
    public void set_BaseType(XmlSchemaSimpleType value);
    public XmlQualifiedName get_BaseTypeName();
    public void set_BaseTypeName(XmlQualifiedName value);
    public XmlSchemaObjectCollection get_Facets();
}
public class System.Xml.Schema.XmlSchemaSimpleType : XmlSchemaType {
    [XmlElementAttribute("list", "System.Xml.Schema.XmlSchemaSimpleTypeList")]
[XmlElementAttribute("restriction", "System.Xml.Schema.XmlSchemaSimpleTypeRestriction")]
[XmlElementAttribute("union", "System.Xml.Schema.XmlSchemaSimpleTypeUnion")]
public XmlSchemaSimpleTypeContent Content { get; public set; }
    public XmlSchemaSimpleTypeContent get_Content();
    public void set_Content(XmlSchemaSimpleTypeContent value);
}
public abstract class System.Xml.Schema.XmlSchemaSimpleTypeContent : XmlSchemaAnnotated {
}
public class System.Xml.Schema.XmlSchemaSimpleTypeList : XmlSchemaSimpleTypeContent {
    [XmlIgnoreAttribute]
public XmlSchemaSimpleType BaseItemType { get; public set; }
    [XmlElementAttribute("simpleType", "System.Xml.Schema.XmlSchemaSimpleType")]
public XmlSchemaSimpleType ItemType { get; public set; }
    [XmlAttributeAttribute("itemType")]
public XmlQualifiedName ItemTypeName { get; public set; }
    public XmlSchemaSimpleType get_BaseItemType();
    public void set_BaseItemType(XmlSchemaSimpleType value);
    public XmlSchemaSimpleType get_ItemType();
    public void set_ItemType(XmlSchemaSimpleType value);
    public XmlQualifiedName get_ItemTypeName();
    public void set_ItemTypeName(XmlQualifiedName value);
}
public class System.Xml.Schema.XmlSchemaSimpleTypeRestriction : XmlSchemaSimpleTypeContent {
    [XmlElementAttribute("simpleType", "System.Xml.Schema.XmlSchemaSimpleType")]
public XmlSchemaSimpleType BaseType { get; public set; }
    [XmlAttributeAttribute("base")]
public XmlQualifiedName BaseTypeName { get; public set; }
    [XmlElementAttribute("enumeration", "System.Xml.Schema.XmlSchemaEnumerationFacet")]
[XmlElementAttribute("fractionDigits", "System.Xml.Schema.XmlSchemaFractionDigitsFacet")]
[XmlElementAttribute("length", "System.Xml.Schema.XmlSchemaLengthFacet")]
[XmlElementAttribute("maxExclusive", "System.Xml.Schema.XmlSchemaMaxExclusiveFacet")]
[XmlElementAttribute("maxInclusive", "System.Xml.Schema.XmlSchemaMaxInclusiveFacet")]
[XmlElementAttribute("maxLength", "System.Xml.Schema.XmlSchemaMaxLengthFacet")]
[XmlElementAttribute("minExclusive", "System.Xml.Schema.XmlSchemaMinExclusiveFacet")]
[XmlElementAttribute("minInclusive", "System.Xml.Schema.XmlSchemaMinInclusiveFacet")]
[XmlElementAttribute("minLength", "System.Xml.Schema.XmlSchemaMinLengthFacet")]
[XmlElementAttribute("pattern", "System.Xml.Schema.XmlSchemaPatternFacet")]
[XmlElementAttribute("totalDigits", "System.Xml.Schema.XmlSchemaTotalDigitsFacet")]
[XmlElementAttribute("whiteSpace", "System.Xml.Schema.XmlSchemaWhiteSpaceFacet")]
public XmlSchemaObjectCollection Facets { get; }
    public XmlSchemaSimpleType get_BaseType();
    public void set_BaseType(XmlSchemaSimpleType value);
    public XmlQualifiedName get_BaseTypeName();
    public void set_BaseTypeName(XmlQualifiedName value);
    public XmlSchemaObjectCollection get_Facets();
}
public class System.Xml.Schema.XmlSchemaSimpleTypeUnion : XmlSchemaSimpleTypeContent {
    [XmlIgnoreAttribute]
public XmlSchemaSimpleType[] BaseMemberTypes { get; }
    [XmlElementAttribute("simpleType", "System.Xml.Schema.XmlSchemaSimpleType")]
public XmlSchemaObjectCollection BaseTypes { get; }
    [XmlAttributeAttribute("memberTypes")]
public XmlQualifiedName[] MemberTypes { get; public set; }
    public XmlSchemaSimpleType[] get_BaseMemberTypes();
    public XmlSchemaObjectCollection get_BaseTypes();
    public XmlQualifiedName[] get_MemberTypes();
    public void set_MemberTypes(XmlQualifiedName[] value);
}
public class System.Xml.Schema.XmlSchemaTotalDigitsFacet : XmlSchemaNumericFacet {
}
public class System.Xml.Schema.XmlSchemaType : XmlSchemaAnnotated {
    [ObsoleteAttribute("This property has been deprecated. Please use BaseXmlSchemaType property that returns a strongly typed base schema type. https://go.microsoft.com/fwlink/?linkid=14202")]
[XmlIgnoreAttribute]
public object BaseSchemaType { get; }
    [XmlIgnoreAttribute]
public XmlSchemaType BaseXmlSchemaType { get; }
    [XmlIgnoreAttribute]
public XmlSchemaDatatype Datatype { get; }
    [XmlIgnoreAttribute]
public XmlSchemaDerivationMethod DerivedBy { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[XmlAttributeAttribute("final")]
public XmlSchemaDerivationMethod Final { get; public set; }
    [XmlIgnoreAttribute]
public XmlSchemaDerivationMethod FinalResolved { get; }
    [XmlIgnoreAttribute]
public bool IsMixed { get; public set; }
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlIgnoreAttribute]
public XmlQualifiedName QualifiedName { get; }
    [XmlIgnoreAttribute]
public XmlTypeCode TypeCode { get; }
    public object get_BaseSchemaType();
    public XmlSchemaType get_BaseXmlSchemaType();
    public XmlSchemaDatatype get_Datatype();
    public XmlSchemaDerivationMethod get_DerivedBy();
    public XmlSchemaDerivationMethod get_Final();
    public void set_Final(XmlSchemaDerivationMethod value);
    public XmlSchemaDerivationMethod get_FinalResolved();
    public virtual bool get_IsMixed();
    public virtual void set_IsMixed(bool value);
    public string get_Name();
    public void set_Name(string value);
    public XmlQualifiedName get_QualifiedName();
    public XmlTypeCode get_TypeCode();
    public static XmlSchemaComplexType GetBuiltInComplexType(XmlTypeCode typeCode);
    public static XmlSchemaComplexType GetBuiltInComplexType(XmlQualifiedName qualifiedName);
    public static XmlSchemaSimpleType GetBuiltInSimpleType(XmlTypeCode typeCode);
    public static XmlSchemaSimpleType GetBuiltInSimpleType(XmlQualifiedName qualifiedName);
    public static bool IsDerivedFrom(XmlSchemaType derivedType, XmlSchemaType baseType, XmlSchemaDerivationMethod except);
}
public class System.Xml.Schema.XmlSchemaUnique : XmlSchemaIdentityConstraint {
}
public enum System.Xml.Schema.XmlSchemaUse : Enum {
    public int value__;
    [XmlIgnoreAttribute]
public static XmlSchemaUse None;
    [XmlEnumAttribute("optional")]
public static XmlSchemaUse Optional;
    [XmlEnumAttribute("prohibited")]
public static XmlSchemaUse Prohibited;
    [XmlEnumAttribute("required")]
public static XmlSchemaUse Required;
}
public class System.Xml.Schema.XmlSchemaValidationException : XmlSchemaException {
    public object SourceObject { get; }
    protected XmlSchemaValidationException(SerializationInfo info, StreamingContext context);
    public XmlSchemaValidationException(string message);
    public XmlSchemaValidationException(string message, Exception innerException);
    public XmlSchemaValidationException(string message, Exception innerException, int lineNumber, int linePosition);
    public object get_SourceObject();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected internal void SetSourceObject(object sourceObject);
}
[FlagsAttribute]
public enum System.Xml.Schema.XmlSchemaValidationFlags : Enum {
    public int value__;
    public static XmlSchemaValidationFlags AllowXmlAttributes;
    public static XmlSchemaValidationFlags None;
    public static XmlSchemaValidationFlags ProcessIdentityConstraints;
    public static XmlSchemaValidationFlags ProcessInlineSchema;
    public static XmlSchemaValidationFlags ProcessSchemaLocation;
    public static XmlSchemaValidationFlags ReportValidationWarnings;
}
public class System.Xml.Schema.XmlSchemaValidator : object {
    public IXmlLineInfo LineInfoProvider { get; public set; }
    public Uri SourceUri { get; public set; }
    public object ValidationEventSender { get; public set; }
    unknown XmlResolver XmlResolver {public set; }
    public XmlSchemaValidator(XmlNameTable nameTable, XmlSchemaSet schemas, IXmlNamespaceResolver namespaceResolver, XmlSchemaValidationFlags validationFlags);
    public IXmlLineInfo get_LineInfoProvider();
    public void set_LineInfoProvider(IXmlLineInfo value);
    public Uri get_SourceUri();
    public void set_SourceUri(Uri value);
    public object get_ValidationEventSender();
    public void set_ValidationEventSender(object value);
    public void set_XmlResolver(XmlResolver value);
    public void add_ValidationEventHandler(ValidationEventHandler value);
    public void remove_ValidationEventHandler(ValidationEventHandler value);
    public void AddSchema(XmlSchema schema);
    public void EndValidation();
    public XmlSchemaAttribute[] GetExpectedAttributes();
    public XmlSchemaParticle[] GetExpectedParticles();
    public void GetUnspecifiedDefaultAttributes(ArrayList defaultAttributes);
    public void Initialize();
    public void Initialize(XmlSchemaObject partialValidationType);
    public void SkipToEndElement(XmlSchemaInfo schemaInfo);
    public object ValidateAttribute(string localName, string namespaceUri, string attributeValue, XmlSchemaInfo schemaInfo);
    public object ValidateAttribute(string localName, string namespaceUri, XmlValueGetter attributeValue, XmlSchemaInfo schemaInfo);
    public void ValidateElement(string localName, string namespaceUri, XmlSchemaInfo schemaInfo);
    public void ValidateElement(string localName, string namespaceUri, XmlSchemaInfo schemaInfo, string xsiType, string xsiNil, string xsiSchemaLocation, string xsiNoNamespaceSchemaLocation);
    public object ValidateEndElement(XmlSchemaInfo schemaInfo);
    public object ValidateEndElement(XmlSchemaInfo schemaInfo, object typedValue);
    public void ValidateEndOfAttributes(XmlSchemaInfo schemaInfo);
    public void ValidateText(string elementValue);
    public void ValidateText(XmlValueGetter elementValue);
    public void ValidateWhitespace(string elementValue);
    public void ValidateWhitespace(XmlValueGetter elementValue);
}
public enum System.Xml.Schema.XmlSchemaValidity : Enum {
    public int value__;
    public static XmlSchemaValidity Invalid;
    public static XmlSchemaValidity NotKnown;
    public static XmlSchemaValidity Valid;
}
public class System.Xml.Schema.XmlSchemaWhiteSpaceFacet : XmlSchemaFacet {
}
public class System.Xml.Schema.XmlSchemaXPath : XmlSchemaAnnotated {
    [DefaultValueAttribute("")]
[XmlAttributeAttribute("xpath")]
public string XPath { get; public set; }
    public string get_XPath();
    public void set_XPath(string value);
}
public enum System.Xml.Schema.XmlSeverityType : Enum {
    public int value__;
    public static XmlSeverityType Error;
    public static XmlSeverityType Warning;
}
public enum System.Xml.Schema.XmlTypeCode : Enum {
    public int value__;
    public static XmlTypeCode AnyAtomicType;
    public static XmlTypeCode AnyUri;
    public static XmlTypeCode Attribute;
    public static XmlTypeCode Base64Binary;
    public static XmlTypeCode Boolean;
    public static XmlTypeCode Byte;
    public static XmlTypeCode Comment;
    public static XmlTypeCode Date;
    public static XmlTypeCode DateTime;
    public static XmlTypeCode DayTimeDuration;
    public static XmlTypeCode Decimal;
    public static XmlTypeCode Document;
    public static XmlTypeCode Double;
    public static XmlTypeCode Duration;
    public static XmlTypeCode Element;
    public static XmlTypeCode Entity;
    public static XmlTypeCode Float;
    public static XmlTypeCode GDay;
    public static XmlTypeCode GMonth;
    public static XmlTypeCode GMonthDay;
    public static XmlTypeCode GYear;
    public static XmlTypeCode GYearMonth;
    public static XmlTypeCode HexBinary;
    public static XmlTypeCode Id;
    public static XmlTypeCode Idref;
    public static XmlTypeCode Int;
    public static XmlTypeCode Integer;
    public static XmlTypeCode Item;
    public static XmlTypeCode Language;
    public static XmlTypeCode Long;
    public static XmlTypeCode Name;
    public static XmlTypeCode Namespace;
    public static XmlTypeCode NCName;
    public static XmlTypeCode NegativeInteger;
    public static XmlTypeCode NmToken;
    public static XmlTypeCode Node;
    public static XmlTypeCode None;
    public static XmlTypeCode NonNegativeInteger;
    public static XmlTypeCode NonPositiveInteger;
    public static XmlTypeCode NormalizedString;
    public static XmlTypeCode Notation;
    public static XmlTypeCode PositiveInteger;
    public static XmlTypeCode ProcessingInstruction;
    public static XmlTypeCode QName;
    public static XmlTypeCode Short;
    public static XmlTypeCode String;
    public static XmlTypeCode Text;
    public static XmlTypeCode Time;
    public static XmlTypeCode Token;
    public static XmlTypeCode UnsignedByte;
    public static XmlTypeCode UnsignedInt;
    public static XmlTypeCode UnsignedLong;
    public static XmlTypeCode UnsignedShort;
    public static XmlTypeCode UntypedAtomic;
    public static XmlTypeCode YearMonthDuration;
}
public class System.Xml.Schema.XmlValueGetter : MulticastDelegate {
    public XmlValueGetter(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum System.Xml.Serialization.CodeGenerationOptions : Enum {
    public int value__;
    public static CodeGenerationOptions EnableDataBinding;
    public static CodeGenerationOptions GenerateNewAsync;
    public static CodeGenerationOptions GenerateOldAsync;
    public static CodeGenerationOptions GenerateOrder;
    public static CodeGenerationOptions GenerateProperties;
    public static CodeGenerationOptions None;
}
public class System.Xml.Serialization.CodeIdentifier : object {
    public static string MakeCamel(string identifier);
    public static string MakePascal(string identifier);
    public static string MakeValid(string identifier);
}
public class System.Xml.Serialization.CodeIdentifiers : object {
    public bool UseCamelCasing { get; public set; }
    public CodeIdentifiers(bool caseSensitive);
    public bool get_UseCamelCasing();
    public void set_UseCamelCasing(bool value);
    public void Add(string identifier, object value);
    public void AddReserved(string identifier);
    public string AddUnique(string identifier, object value);
    public void Clear();
    public bool IsInUse(string identifier);
    public string MakeRightCase(string identifier);
    public string MakeUnique(string identifier);
    public void Remove(string identifier);
    public void RemoveReserved(string identifier);
    public object ToArray(Type type);
}
public class System.Xml.Serialization.ImportContext : object {
    public bool ShareTypes { get; }
    public CodeIdentifiers TypeIdentifiers { get; }
    public StringCollection Warnings { get; }
    public ImportContext(CodeIdentifiers identifiers, bool shareTypes);
    public bool get_ShareTypes();
    public CodeIdentifiers get_TypeIdentifiers();
    public StringCollection get_Warnings();
}
public interface System.Xml.Serialization.IXmlSerializable {
    [EditorBrowsableAttribute("1")]
public abstract virtual XmlSchema GetSchema();
    public abstract virtual void ReadXml(XmlReader reader);
    public abstract virtual void WriteXml(XmlWriter writer);
}
public interface System.Xml.Serialization.IXmlTextParser {
    public bool Normalized { get; public set; }
    public WhitespaceHandling WhitespaceHandling { get; public set; }
    public abstract virtual bool get_Normalized();
    public abstract virtual void set_Normalized(bool value);
    public abstract virtual WhitespaceHandling get_WhitespaceHandling();
    public abstract virtual void set_WhitespaceHandling(WhitespaceHandling value);
}
public abstract class System.Xml.Serialization.SchemaImporter : object {
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.SoapAttributeAttribute : Attribute {
    public string AttributeName { get; public set; }
    public string DataType { get; public set; }
    public string Namespace { get; public set; }
    public SoapAttributeAttribute(string attributeName);
    public string get_AttributeName();
    public void set_AttributeName(string value);
    public string get_DataType();
    public void set_DataType(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Serialization.SoapAttributeOverrides : object {
    public SoapAttributes Item { get; }
    public SoapAttributes Item { get; }
    public SoapAttributes get_Item(Type type);
    public SoapAttributes get_Item(Type type, string member);
    public void Add(Type type, string member, SoapAttributes attributes);
    public void Add(Type type, SoapAttributes attributes);
}
public class System.Xml.Serialization.SoapAttributes : object {
    public SoapAttributeAttribute SoapAttribute { get; public set; }
    public object SoapDefaultValue { get; public set; }
    public SoapElementAttribute SoapElement { get; public set; }
    public SoapEnumAttribute SoapEnum { get; public set; }
    public bool SoapIgnore { get; public set; }
    public SoapTypeAttribute SoapType { get; public set; }
    public SoapAttributes(ICustomAttributeProvider provider);
    public SoapAttributeAttribute get_SoapAttribute();
    public void set_SoapAttribute(SoapAttributeAttribute value);
    public object get_SoapDefaultValue();
    public void set_SoapDefaultValue(object value);
    public SoapElementAttribute get_SoapElement();
    public void set_SoapElement(SoapElementAttribute value);
    public SoapEnumAttribute get_SoapEnum();
    public void set_SoapEnum(SoapEnumAttribute value);
    public bool get_SoapIgnore();
    public void set_SoapIgnore(bool value);
    public SoapTypeAttribute get_SoapType();
    public void set_SoapType(SoapTypeAttribute value);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.SoapElementAttribute : Attribute {
    public string DataType { get; public set; }
    public string ElementName { get; public set; }
    public bool IsNullable { get; public set; }
    public SoapElementAttribute(string elementName);
    public string get_DataType();
    public void set_DataType(string value);
    public string get_ElementName();
    public void set_ElementName(string value);
    public bool get_IsNullable();
    public void set_IsNullable(bool value);
}
[AttributeUsageAttribute("256")]
public class System.Xml.Serialization.SoapEnumAttribute : Attribute {
    public string Name { get; public set; }
    public SoapEnumAttribute(string name);
    public string get_Name();
    public void set_Name(string value);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.SoapIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1100")]
public class System.Xml.Serialization.SoapIncludeAttribute : Attribute {
    public Type Type { get; public set; }
    public SoapIncludeAttribute(Type type);
    public Type get_Type();
    public void set_Type(Type value);
}
public class System.Xml.Serialization.SoapReflectionImporter : object {
    public SoapReflectionImporter(string defaultNamespace);
    public SoapReflectionImporter(SoapAttributeOverrides attributeOverrides);
    public SoapReflectionImporter(SoapAttributeOverrides attributeOverrides, string defaultNamespace);
    public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members);
    public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool writeAccessors);
    public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool writeAccessors, bool validate);
    public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool writeAccessors, bool validate, XmlMappingAccess access);
    public XmlTypeMapping ImportTypeMapping(Type type);
    public XmlTypeMapping ImportTypeMapping(Type type, string defaultNamespace);
    public void IncludeType(Type type);
    public void IncludeTypes(ICustomAttributeProvider provider);
}
public class System.Xml.Serialization.SoapSchemaMember : object {
    public string MemberName { get; public set; }
    public XmlQualifiedName MemberType { get; public set; }
    public string get_MemberName();
    public void set_MemberName(string value);
    public XmlQualifiedName get_MemberType();
    public void set_MemberType(XmlQualifiedName value);
}
[AttributeUsageAttribute("1052")]
public class System.Xml.Serialization.SoapTypeAttribute : Attribute {
    public bool IncludeInSchema { get; public set; }
    public string Namespace { get; public set; }
    public string TypeName { get; public set; }
    public SoapTypeAttribute(string typeName);
    public SoapTypeAttribute(string typeName, string ns);
    public bool get_IncludeInSchema();
    public void set_IncludeInSchema(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
}
public class System.Xml.Serialization.UnreferencedObjectEventArgs : EventArgs {
    public string UnreferencedId { get; }
    public object UnreferencedObject { get; }
    public UnreferencedObjectEventArgs(object o, string id);
    public string get_UnreferencedId();
    public object get_UnreferencedObject();
}
public class System.Xml.Serialization.UnreferencedObjectEventHandler : MulticastDelegate {
    public UnreferencedObjectEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnreferencedObjectEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnreferencedObjectEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlAnyAttributeAttribute : Attribute {
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlAnyElementAttribute : Attribute {
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public int Order { get; public set; }
    public XmlAnyElementAttribute(string name);
    public XmlAnyElementAttribute(string name, string ns);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public int get_Order();
    public void set_Order(int value);
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Serialization.XmlAnyElementAttributes : CollectionBase {
    public XmlAnyElementAttribute Item { get; public set; }
    public XmlAnyElementAttribute get_Item(int index);
    public void set_Item(int index, XmlAnyElementAttribute value);
    public int Add(XmlAnyElementAttribute attribute);
    public bool Contains(XmlAnyElementAttribute attribute);
    public void CopyTo(XmlAnyElementAttribute[] array, int index);
    public int IndexOf(XmlAnyElementAttribute attribute);
    public void Insert(int index, XmlAnyElementAttribute attribute);
    public void Remove(XmlAnyElementAttribute attribute);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlArrayAttribute : Attribute {
    public string ElementName { get; public set; }
    public XmlSchemaForm Form { get; public set; }
    public bool IsNullable { get; public set; }
    public string Namespace { get; public set; }
    public int Order { get; public set; }
    public XmlArrayAttribute(string elementName);
    public string get_ElementName();
    public void set_ElementName(string value);
    public XmlSchemaForm get_Form();
    public void set_Form(XmlSchemaForm value);
    public bool get_IsNullable();
    public void set_IsNullable(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public int get_Order();
    public void set_Order(int value);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlArrayItemAttribute : Attribute {
    public string DataType { get; public set; }
    public string ElementName { get; public set; }
    public XmlSchemaForm Form { get; public set; }
    public bool IsNullable { get; public set; }
    public string Namespace { get; public set; }
    public int NestingLevel { get; public set; }
    public Type Type { get; public set; }
    public XmlArrayItemAttribute(string elementName);
    public XmlArrayItemAttribute(string elementName, Type type);
    public XmlArrayItemAttribute(Type type);
    public string get_DataType();
    public void set_DataType(string value);
    public string get_ElementName();
    public void set_ElementName(string value);
    public XmlSchemaForm get_Form();
    public void set_Form(XmlSchemaForm value);
    public bool get_IsNullable();
    public void set_IsNullable(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public int get_NestingLevel();
    public void set_NestingLevel(int value);
    public Type get_Type();
    public void set_Type(Type value);
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Serialization.XmlArrayItemAttributes : CollectionBase {
    public XmlArrayItemAttribute Item { get; public set; }
    public XmlArrayItemAttribute get_Item(int index);
    public void set_Item(int index, XmlArrayItemAttribute value);
    public int Add(XmlArrayItemAttribute attribute);
    public bool Contains(XmlArrayItemAttribute attribute);
    public void CopyTo(XmlArrayItemAttribute[] array, int index);
    public int IndexOf(XmlArrayItemAttribute attribute);
    public void Insert(int index, XmlArrayItemAttribute attribute);
    public void Remove(XmlArrayItemAttribute attribute);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlAttributeAttribute : Attribute {
    public string AttributeName { get; public set; }
    public string DataType { get; public set; }
    public XmlSchemaForm Form { get; public set; }
    public string Namespace { get; public set; }
    public Type Type { get; public set; }
    public XmlAttributeAttribute(string attributeName);
    public XmlAttributeAttribute(string attributeName, Type type);
    public XmlAttributeAttribute(Type type);
    public string get_AttributeName();
    public void set_AttributeName(string value);
    public string get_DataType();
    public void set_DataType(string value);
    public XmlSchemaForm get_Form();
    public void set_Form(XmlSchemaForm value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public Type get_Type();
    public void set_Type(Type value);
}
public class System.Xml.Serialization.XmlAttributeEventArgs : EventArgs {
    public XmlAttribute Attr { get; }
    public string ExpectedAttributes { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public object ObjectBeingDeserialized { get; }
    public XmlAttribute get_Attr();
    public string get_ExpectedAttributes();
    public int get_LineNumber();
    public int get_LinePosition();
    public object get_ObjectBeingDeserialized();
}
public class System.Xml.Serialization.XmlAttributeEventHandler : MulticastDelegate {
    public XmlAttributeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, XmlAttributeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, XmlAttributeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Serialization.XmlAttributeOverrides : object {
    public XmlAttributes Item { get; }
    public XmlAttributes Item { get; }
    public XmlAttributes get_Item(Type type);
    public XmlAttributes get_Item(Type type, string member);
    public void Add(Type type, string member, XmlAttributes attributes);
    public void Add(Type type, XmlAttributes attributes);
}
public class System.Xml.Serialization.XmlAttributes : object {
    public XmlAnyAttributeAttribute XmlAnyAttribute { get; public set; }
    public XmlAnyElementAttributes XmlAnyElements { get; }
    public XmlArrayAttribute XmlArray { get; public set; }
    public XmlArrayItemAttributes XmlArrayItems { get; }
    public XmlAttributeAttribute XmlAttribute { get; public set; }
    public XmlChoiceIdentifierAttribute XmlChoiceIdentifier { get; }
    public object XmlDefaultValue { get; public set; }
    public XmlElementAttributes XmlElements { get; }
    public XmlEnumAttribute XmlEnum { get; public set; }
    public bool XmlIgnore { get; public set; }
    public bool Xmlns { get; public set; }
    public XmlRootAttribute XmlRoot { get; public set; }
    public XmlTextAttribute XmlText { get; public set; }
    public XmlTypeAttribute XmlType { get; public set; }
    public XmlAttributes(ICustomAttributeProvider provider);
    public XmlAnyAttributeAttribute get_XmlAnyAttribute();
    public void set_XmlAnyAttribute(XmlAnyAttributeAttribute value);
    public XmlAnyElementAttributes get_XmlAnyElements();
    public XmlArrayAttribute get_XmlArray();
    public void set_XmlArray(XmlArrayAttribute value);
    public XmlArrayItemAttributes get_XmlArrayItems();
    public XmlAttributeAttribute get_XmlAttribute();
    public void set_XmlAttribute(XmlAttributeAttribute value);
    public XmlChoiceIdentifierAttribute get_XmlChoiceIdentifier();
    public object get_XmlDefaultValue();
    public void set_XmlDefaultValue(object value);
    public XmlElementAttributes get_XmlElements();
    public XmlEnumAttribute get_XmlEnum();
    public void set_XmlEnum(XmlEnumAttribute value);
    public bool get_XmlIgnore();
    public void set_XmlIgnore(bool value);
    public bool get_Xmlns();
    public void set_Xmlns(bool value);
    public XmlRootAttribute get_XmlRoot();
    public void set_XmlRoot(XmlRootAttribute value);
    public XmlTextAttribute get_XmlText();
    public void set_XmlText(XmlTextAttribute value);
    public XmlTypeAttribute get_XmlType();
    public void set_XmlType(XmlTypeAttribute value);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlChoiceIdentifierAttribute : Attribute {
    public string MemberName { get; public set; }
    public XmlChoiceIdentifierAttribute(string name);
    public string get_MemberName();
    public void set_MemberName(string value);
}
public class System.Xml.Serialization.XmlDeserializationEvents : ValueType {
    private object _dummy;
    public XmlAttributeEventHandler OnUnknownAttribute { get; public set; }
    public XmlElementEventHandler OnUnknownElement { get; public set; }
    public XmlNodeEventHandler OnUnknownNode { get; public set; }
    public UnreferencedObjectEventHandler OnUnreferencedObject { get; public set; }
    public XmlAttributeEventHandler get_OnUnknownAttribute();
    public void set_OnUnknownAttribute(XmlAttributeEventHandler value);
    public XmlElementEventHandler get_OnUnknownElement();
    public void set_OnUnknownElement(XmlElementEventHandler value);
    public XmlNodeEventHandler get_OnUnknownNode();
    public void set_OnUnknownNode(XmlNodeEventHandler value);
    public UnreferencedObjectEventHandler get_OnUnreferencedObject();
    public void set_OnUnreferencedObject(UnreferencedObjectEventHandler value);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlElementAttribute : Attribute {
    public string DataType { get; public set; }
    public string ElementName { get; public set; }
    public XmlSchemaForm Form { get; public set; }
    public bool IsNullable { get; public set; }
    public string Namespace { get; public set; }
    public int Order { get; public set; }
    public Type Type { get; public set; }
    public XmlElementAttribute(string elementName);
    public XmlElementAttribute(string elementName, Type type);
    public XmlElementAttribute(Type type);
    public string get_DataType();
    public void set_DataType(string value);
    public string get_ElementName();
    public void set_ElementName(string value);
    public XmlSchemaForm get_Form();
    public void set_Form(XmlSchemaForm value);
    public bool get_IsNullable();
    public void set_IsNullable(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public int get_Order();
    public void set_Order(int value);
    public Type get_Type();
    public void set_Type(Type value);
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Serialization.XmlElementAttributes : CollectionBase {
    public XmlElementAttribute Item { get; public set; }
    public XmlElementAttribute get_Item(int index);
    public void set_Item(int index, XmlElementAttribute value);
    public int Add(XmlElementAttribute attribute);
    public bool Contains(XmlElementAttribute attribute);
    public void CopyTo(XmlElementAttribute[] array, int index);
    public int IndexOf(XmlElementAttribute attribute);
    public void Insert(int index, XmlElementAttribute attribute);
    public void Remove(XmlElementAttribute attribute);
}
public class System.Xml.Serialization.XmlElementEventArgs : EventArgs {
    public XmlElement Element { get; }
    public string ExpectedElements { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public object ObjectBeingDeserialized { get; }
    public XmlElement get_Element();
    public string get_ExpectedElements();
    public int get_LineNumber();
    public int get_LinePosition();
    public object get_ObjectBeingDeserialized();
}
public class System.Xml.Serialization.XmlElementEventHandler : MulticastDelegate {
    public XmlElementEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, XmlElementEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, XmlElementEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("256")]
public class System.Xml.Serialization.XmlEnumAttribute : Attribute {
    public string Name { get; public set; }
    public XmlEnumAttribute(string name);
    public string get_Name();
    public void set_Name(string value);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1100")]
public class System.Xml.Serialization.XmlIncludeAttribute : Attribute {
    public Type Type { get; public set; }
    public XmlIncludeAttribute(Type type);
    public Type get_Type();
    public void set_Type(Type value);
}
public abstract class System.Xml.Serialization.XmlMapping : object {
    public string ElementName { get; }
    public string Namespace { get; }
    public string XsdElementName { get; }
    public string get_ElementName();
    public string get_Namespace();
    public string get_XsdElementName();
    public void SetKey(string key);
}
[FlagsAttribute]
public enum System.Xml.Serialization.XmlMappingAccess : Enum {
    public int value__;
    public static XmlMappingAccess None;
    public static XmlMappingAccess Read;
    public static XmlMappingAccess Write;
}
public class System.Xml.Serialization.XmlMemberMapping : object {
    public bool Any { get; }
    public bool CheckSpecified { get; }
    public string ElementName { get; }
    public string MemberName { get; }
    public string Namespace { get; }
    public string TypeFullName { get; }
    public string TypeName { get; }
    public string TypeNamespace { get; }
    public string XsdElementName { get; }
    public bool get_Any();
    public bool get_CheckSpecified();
    public string get_ElementName();
    public string get_MemberName();
    public string get_Namespace();
    public string get_TypeFullName();
    public string get_TypeName();
    public string get_TypeNamespace();
    public string get_XsdElementName();
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Serialization.XmlMembersMapping : XmlMapping {
    public int Count { get; }
    public XmlMemberMapping Item { get; }
    public string TypeName { get; }
    public string TypeNamespace { get; }
    public int get_Count();
    public XmlMemberMapping get_Item(int index);
    public string get_TypeName();
    public string get_TypeNamespace();
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlNamespaceDeclarationsAttribute : Attribute {
}
public class System.Xml.Serialization.XmlNodeEventArgs : EventArgs {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNodeType NodeType { get; }
    public object ObjectBeingDeserialized { get; }
    public string Text { get; }
    public int get_LineNumber();
    public int get_LinePosition();
    public string get_LocalName();
    public string get_Name();
    public string get_NamespaceURI();
    public XmlNodeType get_NodeType();
    public object get_ObjectBeingDeserialized();
    public string get_Text();
}
public class System.Xml.Serialization.XmlNodeEventHandler : MulticastDelegate {
    public XmlNodeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, XmlNodeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, XmlNodeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Xml.Serialization.XmlReflectionImporter : object {
    public XmlReflectionImporter(string defaultNamespace);
    public XmlReflectionImporter(XmlAttributeOverrides attributeOverrides);
    public XmlReflectionImporter(XmlAttributeOverrides attributeOverrides, string defaultNamespace);
    public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement);
    public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool rpc);
    public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool rpc, bool openModel);
    public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool rpc, bool openModel, XmlMappingAccess access);
    public XmlTypeMapping ImportTypeMapping(Type type);
    public XmlTypeMapping ImportTypeMapping(Type type, string defaultNamespace);
    public XmlTypeMapping ImportTypeMapping(Type type, XmlRootAttribute root);
    public XmlTypeMapping ImportTypeMapping(Type type, XmlRootAttribute root, string defaultNamespace);
    public void IncludeType(Type type);
    public void IncludeTypes(ICustomAttributeProvider provider);
}
public class System.Xml.Serialization.XmlReflectionMember : object {
    public bool IsReturnValue { get; public set; }
    public string MemberName { get; public set; }
    public Type MemberType { get; public set; }
    public bool OverrideIsNullable { get; public set; }
    public SoapAttributes SoapAttributes { get; public set; }
    public XmlAttributes XmlAttributes { get; public set; }
    public bool get_IsReturnValue();
    public void set_IsReturnValue(bool value);
    public string get_MemberName();
    public void set_MemberName(string value);
    public Type get_MemberType();
    public void set_MemberType(Type value);
    public bool get_OverrideIsNullable();
    public void set_OverrideIsNullable(bool value);
    public SoapAttributes get_SoapAttributes();
    public void set_SoapAttributes(SoapAttributes value);
    public XmlAttributes get_XmlAttributes();
    public void set_XmlAttributes(XmlAttributes value);
}
[AttributeUsageAttribute("9244")]
public class System.Xml.Serialization.XmlRootAttribute : Attribute {
    public string DataType { get; public set; }
    public string ElementName { get; public set; }
    public bool IsNullable { get; public set; }
    public string Namespace { get; public set; }
    public XmlRootAttribute(string elementName);
    public string get_DataType();
    public void set_DataType(string value);
    public string get_ElementName();
    public void set_ElementName(string value);
    public bool get_IsNullable();
    public void set_IsNullable(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
}
public class System.Xml.Serialization.XmlSchemaEnumerator : object {
    public XmlSchema Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public XmlSchemaEnumerator(XmlSchemas list);
    public sealed virtual XmlSchema get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public class System.Xml.Serialization.XmlSchemaExporter : object {
    public XmlSchemaExporter(XmlSchemas schemas);
    public string ExportAnyType(string ns);
    public string ExportAnyType(XmlMembersMapping members);
    public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping);
    public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping, bool exportEnclosingType);
    public XmlQualifiedName ExportTypeMapping(XmlMembersMapping xmlMembersMapping);
    public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping);
}
public class System.Xml.Serialization.XmlSchemaImporter : SchemaImporter {
    public XmlSchemaImporter(XmlSchemas schemas);
    public XmlSchemaImporter(XmlSchemas schemas, CodeIdentifiers typeIdentifiers);
    public XmlMembersMapping ImportAnyType(XmlQualifiedName typeName, string elementName);
    public XmlTypeMapping ImportDerivedTypeMapping(XmlQualifiedName name, Type baseType);
    public XmlTypeMapping ImportDerivedTypeMapping(XmlQualifiedName name, Type baseType, bool baseTypeCanBeIndirect);
    public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember[] members);
    public XmlMembersMapping ImportMembersMapping(XmlQualifiedName name);
    public XmlMembersMapping ImportMembersMapping(XmlQualifiedName[] names);
    public XmlMembersMapping ImportMembersMapping(XmlQualifiedName[] names, Type baseType, bool baseTypeCanBeIndirect);
    public XmlTypeMapping ImportSchemaType(XmlQualifiedName typeName);
    public XmlTypeMapping ImportSchemaType(XmlQualifiedName typeName, Type baseType);
    public XmlTypeMapping ImportSchemaType(XmlQualifiedName typeName, Type baseType, bool baseTypeCanBeIndirect);
    public XmlTypeMapping ImportTypeMapping(XmlQualifiedName name);
}
[AttributeUsageAttribute("1036")]
public class System.Xml.Serialization.XmlSchemaProviderAttribute : Attribute {
    public bool IsAny { get; public set; }
    public string MethodName { get; }
    public XmlSchemaProviderAttribute(string methodName);
    public bool get_IsAny();
    public void set_IsAny(bool value);
    public string get_MethodName();
}
[DefaultMemberAttribute("Item")]
public class System.Xml.Serialization.XmlSchemas : CollectionBase {
    public bool IsCompiled { get; }
    public XmlSchema Item { get; public set; }
    public XmlSchema Item { get; }
    public bool get_IsCompiled();
    public XmlSchema get_Item(int index);
    public void set_Item(int index, XmlSchema value);
    public XmlSchema get_Item(string ns);
    public int Add(XmlSchema schema);
    public int Add(XmlSchema schema, Uri baseUri);
    public void Add(XmlSchemas schemas);
    public void AddReference(XmlSchema schema);
    public void Compile(ValidationEventHandler handler, bool fullCompile);
    public bool Contains(string targetNamespace);
    public bool Contains(XmlSchema schema);
    public void CopyTo(XmlSchema[] array, int index);
    public object Find(XmlQualifiedName name, Type type);
    public IList GetSchemas(string ns);
    public int IndexOf(XmlSchema schema);
    public void Insert(int index, XmlSchema schema);
    public static bool IsDataSet(XmlSchema schema);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    public void Remove(XmlSchema schema);
    private sealed virtual override IEnumerator`1<XmlSchema> System.Collections.Generic.IEnumerable<System.Xml.Schema.XmlSchema>.GetEnumerator();
}
public class System.Xml.Serialization.XmlSerializationCollectionFixupCallback : MulticastDelegate {
    public XmlSerializationCollectionFixupCallback(object object, IntPtr method);
    public virtual void Invoke(object collection, object collectionItems);
    public virtual IAsyncResult BeginInvoke(object collection, object collectionItems, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Xml.Serialization.XmlSerializationFixupCallback : MulticastDelegate {
    public XmlSerializationFixupCallback(object object, IntPtr method);
    public virtual void Invoke(object fixup);
    public virtual IAsyncResult BeginInvoke(object fixup, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Xml.Serialization.XmlSerializationGeneratedCode : object {
}
public class System.Xml.Serialization.XmlSerializationReadCallback : MulticastDelegate {
    public XmlSerializationReadCallback(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public abstract class System.Xml.Serialization.XmlSerializationReader : XmlSerializationGeneratedCode {
    protected bool DecodeName { get; protected set; }
    protected XmlDocument Document { get; }
    protected bool IsReturnValue { get; protected set; }
    protected XmlReader Reader { get; }
    protected int ReaderCount { get; }
    protected bool get_DecodeName();
    protected void set_DecodeName(bool value);
    protected XmlDocument get_Document();
    protected bool get_IsReturnValue();
    protected void set_IsReturnValue(bool value);
    protected XmlReader get_Reader();
    protected int get_ReaderCount();
    protected void AddFixup(CollectionFixup fixup);
    protected void AddFixup(Fixup fixup);
    protected void AddReadCallback(string name, string ns, Type type, XmlSerializationReadCallback read);
    protected void AddTarget(string id, object o);
    protected void CheckReaderCount(Int32& whileIterations, Int32& readerCount);
    protected string CollapseWhitespace(string value);
    protected Exception CreateAbstractTypeException(string name, string ns);
    protected Exception CreateBadDerivationException(string xsdDerived, string nsDerived, string xsdBase, string nsBase, string clrDerived, string clrBase);
    protected Exception CreateCtorHasSecurityException(string typeName);
    protected Exception CreateInaccessibleConstructorException(string typeName);
    protected Exception CreateInvalidCastException(Type type, object value);
    protected Exception CreateInvalidCastException(Type type, object value, string id);
    protected Exception CreateMissingIXmlSerializableType(string name, string ns, string clrType);
    protected Exception CreateReadOnlyCollectionException(string name);
    protected Exception CreateUnknownConstantException(string value, Type enumType);
    protected Exception CreateUnknownNodeException();
    protected Exception CreateUnknownTypeException(XmlQualifiedName type);
    protected Array EnsureArrayIndex(Array a, int index, Type elementType);
    protected void FixupArrayRefs(object fixup);
    protected int GetArrayLength(string name, string ns);
    protected bool GetNullAttr();
    protected object GetTarget(string id);
    protected XmlQualifiedName GetXsiType();
    protected abstract virtual void InitCallbacks();
    protected abstract virtual void InitIDs();
    protected bool IsXmlnsAttribute(string name);
    protected void ParseWsdlArrayType(XmlAttribute attr);
    protected XmlQualifiedName ReadElementQualifiedName();
    protected void ReadEndElement();
    protected bool ReadNull();
    protected XmlQualifiedName ReadNullableQualifiedName();
    protected string ReadNullableString();
    protected bool ReadReference(String& fixupReference);
    protected object ReadReferencedElement();
    protected object ReadReferencedElement(string name, string ns);
    protected void ReadReferencedElements();
    protected object ReadReferencingElement(string name, string ns, bool elementCanBeType, String& fixupReference);
    protected object ReadReferencingElement(string name, string ns, String& fixupReference);
    protected object ReadReferencingElement(String& fixupReference);
    protected IXmlSerializable ReadSerializable(IXmlSerializable serializable);
    protected IXmlSerializable ReadSerializable(IXmlSerializable serializable, bool wrappedAny);
    protected string ReadString(string value);
    protected string ReadString(string value, bool trim);
    protected object ReadTypedNull(XmlQualifiedName type);
    protected object ReadTypedPrimitive(XmlQualifiedName type);
    protected XmlDocument ReadXmlDocument(bool wrapped);
    protected XmlNode ReadXmlNode(bool wrapped);
    protected void Referenced(object o);
    protected static Assembly ResolveDynamicAssembly(string assemblyFullName);
    protected Array ShrinkArray(Array a, int length, Type elementType, bool isNullable);
    protected Byte[] ToByteArrayBase64(bool isNull);
    protected static Byte[] ToByteArrayBase64(string value);
    protected Byte[] ToByteArrayHex(bool isNull);
    protected static Byte[] ToByteArrayHex(string value);
    protected static char ToChar(string value);
    protected static DateTime ToDate(string value);
    protected static DateTime ToDateTime(string value);
    protected static long ToEnum(string value, Hashtable h, string typeName);
    protected static DateTime ToTime(string value);
    protected static string ToXmlName(string value);
    protected static string ToXmlNCName(string value);
    protected static string ToXmlNmToken(string value);
    protected static string ToXmlNmTokens(string value);
    protected XmlQualifiedName ToXmlQualifiedName(string value);
    protected void UnknownAttribute(object o, XmlAttribute attr);
    protected void UnknownAttribute(object o, XmlAttribute attr, string qnames);
    protected void UnknownElement(object o, XmlElement elem);
    protected void UnknownElement(object o, XmlElement elem, string qnames);
    protected void UnknownNode(object o);
    protected void UnknownNode(object o, string qnames);
    protected void UnreferencedObject(string id, object o);
}
public class System.Xml.Serialization.XmlSerializationWriteCallback : MulticastDelegate {
    public XmlSerializationWriteCallback(object object, IntPtr method);
    public virtual void Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Xml.Serialization.XmlSerializationWriter : XmlSerializationGeneratedCode {
    protected bool EscapeName { get; protected set; }
    protected ArrayList Namespaces { get; protected set; }
    protected XmlWriter Writer { get; protected set; }
    protected bool get_EscapeName();
    protected void set_EscapeName(bool value);
    protected ArrayList get_Namespaces();
    protected void set_Namespaces(ArrayList value);
    protected XmlWriter get_Writer();
    protected void set_Writer(XmlWriter value);
    protected void AddWriteCallback(Type type, string typeName, string typeNs, XmlSerializationWriteCallback callback);
    protected Exception CreateChoiceIdentifierValueException(string value, string identifier, string name, string ns);
    protected Exception CreateInvalidAnyTypeException(object o);
    protected Exception CreateInvalidAnyTypeException(Type type);
    protected Exception CreateInvalidChoiceIdentifierValueException(string type, string identifier);
    protected Exception CreateInvalidEnumValueException(object value, string typeName);
    protected Exception CreateMismatchChoiceException(string value, string elementName, string enumValue);
    protected Exception CreateUnknownAnyElementException(string name, string ns);
    protected Exception CreateUnknownTypeException(object o);
    protected Exception CreateUnknownTypeException(Type type);
    protected static Byte[] FromByteArrayBase64(Byte[] value);
    protected static string FromByteArrayHex(Byte[] value);
    protected static string FromChar(char value);
    protected static string FromDate(DateTime value);
    protected static string FromDateTime(DateTime value);
    protected static string FromEnum(long value, String[] values, Int64[] ids);
    protected static string FromEnum(long value, String[] values, Int64[] ids, string typeName);
    protected static string FromTime(DateTime value);
    protected static string FromXmlName(string name);
    protected static string FromXmlNCName(string ncName);
    protected static string FromXmlNmToken(string nmToken);
    protected static string FromXmlNmTokens(string nmTokens);
    protected string FromXmlQualifiedName(XmlQualifiedName xmlQualifiedName);
    protected string FromXmlQualifiedName(XmlQualifiedName xmlQualifiedName, bool ignoreEmpty);
    protected abstract virtual void InitCallbacks();
    protected static Assembly ResolveDynamicAssembly(string assemblyFullName);
    protected void TopLevelElement();
    protected void WriteAttribute(string localName, Byte[] value);
    protected void WriteAttribute(string localName, string value);
    protected void WriteAttribute(string localName, string ns, Byte[] value);
    protected void WriteAttribute(string localName, string ns, string value);
    protected void WriteAttribute(string prefix, string localName, string ns, string value);
    protected void WriteElementEncoded(XmlNode node, string name, string ns, bool isNullable, bool any);
    protected void WriteElementLiteral(XmlNode node, string name, string ns, bool isNullable, bool any);
    protected void WriteElementQualifiedName(string localName, string ns, XmlQualifiedName value);
    protected void WriteElementQualifiedName(string localName, string ns, XmlQualifiedName value, XmlQualifiedName xsiType);
    protected void WriteElementQualifiedName(string localName, XmlQualifiedName value);
    protected void WriteElementQualifiedName(string localName, XmlQualifiedName value, XmlQualifiedName xsiType);
    protected void WriteElementString(string localName, string value);
    protected void WriteElementString(string localName, string ns, string value);
    protected void WriteElementString(string localName, string ns, string value, XmlQualifiedName xsiType);
    protected void WriteElementString(string localName, string value, XmlQualifiedName xsiType);
    protected void WriteElementStringRaw(string localName, Byte[] value);
    protected void WriteElementStringRaw(string localName, Byte[] value, XmlQualifiedName xsiType);
    protected void WriteElementStringRaw(string localName, string value);
    protected void WriteElementStringRaw(string localName, string ns, Byte[] value);
    protected void WriteElementStringRaw(string localName, string ns, Byte[] value, XmlQualifiedName xsiType);
    protected void WriteElementStringRaw(string localName, string ns, string value);
    protected void WriteElementStringRaw(string localName, string ns, string value, XmlQualifiedName xsiType);
    protected void WriteElementStringRaw(string localName, string value, XmlQualifiedName xsiType);
    protected void WriteEmptyTag(string name);
    protected void WriteEmptyTag(string name, string ns);
    protected void WriteEndElement();
    protected void WriteEndElement(object o);
    protected void WriteId(object o);
    protected void WriteNamespaceDeclarations(XmlSerializerNamespaces xmlns);
    protected void WriteNullableQualifiedNameEncoded(string name, string ns, XmlQualifiedName value, XmlQualifiedName xsiType);
    protected void WriteNullableQualifiedNameLiteral(string name, string ns, XmlQualifiedName value);
    protected void WriteNullableStringEncoded(string name, string ns, string value, XmlQualifiedName xsiType);
    protected void WriteNullableStringEncodedRaw(string name, string ns, Byte[] value, XmlQualifiedName xsiType);
    protected void WriteNullableStringEncodedRaw(string name, string ns, string value, XmlQualifiedName xsiType);
    protected void WriteNullableStringLiteral(string name, string ns, string value);
    protected void WriteNullableStringLiteralRaw(string name, string ns, Byte[] value);
    protected void WriteNullableStringLiteralRaw(string name, string ns, string value);
    protected void WriteNullTagEncoded(string name);
    protected void WriteNullTagEncoded(string name, string ns);
    protected void WriteNullTagLiteral(string name);
    protected void WriteNullTagLiteral(string name, string ns);
    protected void WritePotentiallyReferencingElement(string n, string ns, object o);
    protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType);
    protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType, bool suppressReference);
    protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType, bool suppressReference, bool isNullable);
    protected void WriteReferencedElements();
    protected void WriteReferencingElement(string n, string ns, object o);
    protected void WriteReferencingElement(string n, string ns, object o, bool isNullable);
    protected void WriteRpcResult(string name, string ns);
    protected void WriteSerializable(IXmlSerializable serializable, string name, string ns, bool isNullable);
    protected void WriteSerializable(IXmlSerializable serializable, string name, string ns, bool isNullable, bool wrapped);
    protected void WriteStartDocument();
    protected void WriteStartElement(string name);
    protected void WriteStartElement(string name, string ns);
    protected void WriteStartElement(string name, string ns, bool writePrefixed);
    protected void WriteStartElement(string name, string ns, object o);
    protected void WriteStartElement(string name, string ns, object o, bool writePrefixed);
    protected void WriteStartElement(string name, string ns, object o, bool writePrefixed, XmlSerializerNamespaces xmlns);
    protected void WriteTypedPrimitive(string name, string ns, object o, bool xsiType);
    protected void WriteValue(Byte[] value);
    protected void WriteValue(string value);
    protected void WriteXmlAttribute(XmlNode node);
    protected void WriteXmlAttribute(XmlNode node, object container);
    protected void WriteXsiType(string name, string ns);
}
public class System.Xml.Serialization.XmlSerializer : object {
    public XmlSerializer(Type type);
    public XmlSerializer(Type type, string defaultNamespace);
    public XmlSerializer(Type type, Type[] extraTypes);
    public XmlSerializer(Type type, XmlAttributeOverrides overrides);
    public XmlSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace);
    public XmlSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace, string location);
    public XmlSerializer(Type type, XmlRootAttribute root);
    public XmlSerializer(XmlTypeMapping xmlTypeMapping);
    public void add_UnknownAttribute(XmlAttributeEventHandler value);
    public void remove_UnknownAttribute(XmlAttributeEventHandler value);
    public void add_UnknownElement(XmlElementEventHandler value);
    public void remove_UnknownElement(XmlElementEventHandler value);
    public void add_UnknownNode(XmlNodeEventHandler value);
    public void remove_UnknownNode(XmlNodeEventHandler value);
    public void add_UnreferencedObject(UnreferencedObjectEventHandler value);
    public void remove_UnreferencedObject(UnreferencedObjectEventHandler value);
    public virtual bool CanDeserialize(XmlReader xmlReader);
    protected virtual XmlSerializationReader CreateReader();
    protected virtual XmlSerializationWriter CreateWriter();
    public object Deserialize(Stream stream);
    public object Deserialize(TextReader textReader);
    protected virtual object Deserialize(XmlSerializationReader reader);
    public object Deserialize(XmlReader xmlReader);
    public object Deserialize(XmlReader xmlReader, string encodingStyle);
    public object Deserialize(XmlReader xmlReader, string encodingStyle, XmlDeserializationEvents events);
    public object Deserialize(XmlReader xmlReader, XmlDeserializationEvents events);
    public static XmlSerializer[] FromMappings(XmlMapping[] mappings);
    public static XmlSerializer[] FromMappings(XmlMapping[] mappings, Type type);
    public static XmlSerializer[] FromTypes(Type[] types);
    public static string GetXmlSerializerAssemblyName(Type type);
    public static string GetXmlSerializerAssemblyName(Type type, string defaultNamespace);
    public void Serialize(Stream stream, object o);
    public void Serialize(Stream stream, object o, XmlSerializerNamespaces namespaces);
    public void Serialize(TextWriter textWriter, object o);
    public void Serialize(TextWriter textWriter, object o, XmlSerializerNamespaces namespaces);
    protected virtual void Serialize(object o, XmlSerializationWriter writer);
    public void Serialize(XmlWriter xmlWriter, object o);
    public void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces);
    public void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces, string encodingStyle);
    public void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces, string encodingStyle, string id);
}
[AttributeUsageAttribute("1052")]
public class System.Xml.Serialization.XmlSerializerAssemblyAttribute : Attribute {
    public string AssemblyName { get; public set; }
    public string CodeBase { get; public set; }
    public XmlSerializerAssemblyAttribute(string assemblyName);
    public XmlSerializerAssemblyAttribute(string assemblyName, string codeBase);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_CodeBase();
    public void set_CodeBase(string value);
}
public class System.Xml.Serialization.XmlSerializerFactory : object {
    public XmlSerializer CreateSerializer(Type type);
    public XmlSerializer CreateSerializer(Type type, string defaultNamespace);
    public XmlSerializer CreateSerializer(Type type, Type[] extraTypes);
    public XmlSerializer CreateSerializer(Type type, XmlAttributeOverrides overrides);
    public XmlSerializer CreateSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace);
    public XmlSerializer CreateSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace, string location);
    public XmlSerializer CreateSerializer(Type type, XmlRootAttribute root);
    public XmlSerializer CreateSerializer(XmlTypeMapping xmlTypeMapping);
}
public abstract class System.Xml.Serialization.XmlSerializerImplementation : object {
    public XmlSerializationReader Reader { get; }
    public Hashtable ReadMethods { get; }
    public Hashtable TypedSerializers { get; }
    public Hashtable WriteMethods { get; }
    public XmlSerializationWriter Writer { get; }
    public virtual XmlSerializationReader get_Reader();
    public virtual Hashtable get_ReadMethods();
    public virtual Hashtable get_TypedSerializers();
    public virtual Hashtable get_WriteMethods();
    public virtual XmlSerializationWriter get_Writer();
    public virtual bool CanSerialize(Type type);
    public virtual XmlSerializer GetSerializer(Type type);
}
public class System.Xml.Serialization.XmlSerializerNamespaces : object {
    public int Count { get; }
    public XmlSerializerNamespaces(XmlSerializerNamespaces namespaces);
    public XmlSerializerNamespaces(XmlQualifiedName[] namespaces);
    public int get_Count();
    public void Add(string prefix, string ns);
    public XmlQualifiedName[] ToArray();
}
[AttributeUsageAttribute("1")]
public class System.Xml.Serialization.XmlSerializerVersionAttribute : Attribute {
    public string Namespace { get; public set; }
    public string ParentAssemblyId { get; public set; }
    public Type Type { get; public set; }
    public string Version { get; public set; }
    public XmlSerializerVersionAttribute(Type type);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_ParentAssemblyId();
    public void set_ParentAssemblyId(string value);
    public Type get_Type();
    public void set_Type(Type value);
    public string get_Version();
    public void set_Version(string value);
}
[AttributeUsageAttribute("10624")]
public class System.Xml.Serialization.XmlTextAttribute : Attribute {
    public string DataType { get; public set; }
    public Type Type { get; public set; }
    public XmlTextAttribute(Type type);
    public string get_DataType();
    public void set_DataType(string value);
    public Type get_Type();
    public void set_Type(Type value);
}
[AttributeUsageAttribute("1052")]
public class System.Xml.Serialization.XmlTypeAttribute : Attribute {
    public bool AnonymousType { get; public set; }
    public bool IncludeInSchema { get; public set; }
    public string Namespace { get; public set; }
    public string TypeName { get; public set; }
    public XmlTypeAttribute(string typeName);
    public bool get_AnonymousType();
    public void set_AnonymousType(bool value);
    public bool get_IncludeInSchema();
    public void set_IncludeInSchema(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
}
public class System.Xml.Serialization.XmlTypeMapping : XmlMapping {
    public string TypeFullName { get; }
    public string TypeName { get; }
    public string XsdTypeName { get; }
    public string XsdTypeNamespace { get; }
    public string get_TypeFullName();
    public string get_TypeName();
    public string get_XsdTypeName();
    public string get_XsdTypeNamespace();
}
public class System.Xml.UniqueId : object {
    public int CharArrayLength { get; }
    public bool IsGuid { get; }
    public UniqueId(Byte[] guid);
    public UniqueId(Byte[] guid, int offset);
    public UniqueId(Char[] chars, int offset, int count);
    public UniqueId(Guid guid);
    public UniqueId(string value);
    public int get_CharArrayLength();
    public bool get_IsGuid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(UniqueId id1, UniqueId id2);
    public static bool op_Inequality(UniqueId id1, UniqueId id2);
    public int ToCharArray(Char[] chars, int offset);
    public virtual string ToString();
    public bool TryGetGuid(Byte[] buffer, int offset);
    public bool TryGetGuid(Guid& guid);
}
public enum System.Xml.ValidationType : Enum {
    public int value__;
    [ObsoleteAttribute("Validation type should be specified as DTD or Schema.")]
public static ValidationType Auto;
    public static ValidationType DTD;
    public static ValidationType None;
    public static ValidationType Schema;
    [ObsoleteAttribute("XDR Validation through XmlValidatingReader is obsoleted")]
public static ValidationType XDR;
}
public enum System.Xml.WhitespaceHandling : Enum {
    public int value__;
    public static WhitespaceHandling All;
    public static WhitespaceHandling None;
    public static WhitespaceHandling Significant;
}
public enum System.Xml.WriteState : Enum {
    public int value__;
    public static WriteState Attribute;
    public static WriteState Closed;
    public static WriteState Content;
    public static WriteState Element;
    public static WriteState Error;
    public static WriteState Prolog;
    public static WriteState Start;
}
public class System.Xml.XmlAttribute : XmlNode {
    public string BaseURI { get; }
    unknown string InnerText {public set; }
    unknown string InnerXml {public set; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNodeType NodeType { get; }
    public XmlDocument OwnerDocument { get; }
    public XmlElement OwnerElement { get; }
    public XmlNode ParentNode { get; }
    public string Prefix { get; public set; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public bool Specified { get; }
    public string Value { get; public set; }
    protected internal XmlAttribute(string prefix, string localName, string namespaceURI, XmlDocument doc);
    public virtual string get_BaseURI();
    public virtual void set_InnerText(string value);
    public virtual void set_InnerXml(string value);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlDocument get_OwnerDocument();
    public virtual XmlElement get_OwnerElement();
    public virtual XmlNode get_ParentNode();
    public virtual string get_Prefix();
    public virtual void set_Prefix(string value);
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual bool get_Specified();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual XmlNode AppendChild(XmlNode newChild);
    public virtual XmlNode CloneNode(bool deep);
    public virtual XmlNode InsertAfter(XmlNode newChild, XmlNode refChild);
    public virtual XmlNode InsertBefore(XmlNode newChild, XmlNode refChild);
    public virtual XmlNode PrependChild(XmlNode newChild);
    public virtual XmlNode RemoveChild(XmlNode oldChild);
    public virtual XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
[DefaultMemberAttribute("ItemOf")]
public class System.Xml.XmlAttributeCollection : XmlNamedNodeMap {
    public XmlAttribute ItemOf { get; }
    public XmlAttribute ItemOf { get; }
    public XmlAttribute ItemOf { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public XmlAttribute get_ItemOf(int i);
    public XmlAttribute get_ItemOf(string name);
    public XmlAttribute get_ItemOf(string localName, string namespaceURI);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public XmlAttribute Append(XmlAttribute node);
    public void CopyTo(XmlAttribute[] array, int index);
    public XmlAttribute InsertAfter(XmlAttribute newNode, XmlAttribute refNode);
    public XmlAttribute InsertBefore(XmlAttribute newNode, XmlAttribute refNode);
    public XmlAttribute Prepend(XmlAttribute node);
    public XmlAttribute Remove(XmlAttribute node);
    public void RemoveAll();
    public XmlAttribute RemoveAt(int i);
    public virtual XmlNode SetNamedItem(XmlNode node);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
public class System.Xml.XmlBinaryReaderSession : object {
    public XmlDictionaryString Add(int id, string value);
    public void Clear();
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(string value, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
public class System.Xml.XmlBinaryWriterSession : object {
    public void Reset();
    public virtual bool TryAdd(XmlDictionaryString value, Int32& key);
}
public class System.Xml.XmlCDataSection : XmlCharacterData {
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public XmlNode ParentNode { get; }
    public XmlNode PreviousText { get; }
    protected internal XmlCDataSection(string data, XmlDocument doc);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlNode get_ParentNode();
    public virtual XmlNode get_PreviousText();
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public abstract class System.Xml.XmlCharacterData : XmlLinkedNode {
    public string Data { get; public set; }
    public string InnerText { get; public set; }
    public int Length { get; }
    public string Value { get; public set; }
    protected internal XmlCharacterData(string data, XmlDocument doc);
    public virtual string get_Data();
    public virtual void set_Data(string value);
    public virtual string get_InnerText();
    public virtual void set_InnerText(string value);
    public virtual int get_Length();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual void AppendData(string strData);
    public virtual void DeleteData(int offset, int count);
    public virtual void InsertData(int offset, string strData);
    public virtual void ReplaceData(int offset, int count, string strData);
    public virtual string Substring(int offset, int count);
}
public class System.Xml.XmlComment : XmlCharacterData {
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    protected internal XmlComment(string comment, XmlDocument doc);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlConvert : object {
    public static string DecodeName(string name);
    public static string EncodeLocalName(string name);
    public static string EncodeName(string name);
    public static string EncodeNmToken(string name);
    public static bool IsNCNameChar(char ch);
    public static bool IsPublicIdChar(char ch);
    public static bool IsStartNCNameChar(char ch);
    public static bool IsWhitespaceChar(char ch);
    public static bool IsXmlChar(char ch);
    public static bool IsXmlSurrogatePair(char lowChar, char highChar);
    public static bool ToBoolean(string s);
    public static byte ToByte(string s);
    public static char ToChar(string s);
    [ObsoleteAttribute("Use XmlConvert.ToDateTime() that takes in XmlDateTimeSerializationMode")]
public static DateTime ToDateTime(string s);
    public static DateTime ToDateTime(string s, string format);
    public static DateTime ToDateTime(string s, String[] formats);
    public static DateTime ToDateTime(string s, XmlDateTimeSerializationMode dateTimeOption);
    public static DateTimeOffset ToDateTimeOffset(string s);
    public static DateTimeOffset ToDateTimeOffset(string s, string format);
    public static DateTimeOffset ToDateTimeOffset(string s, String[] formats);
    public static decimal ToDecimal(string s);
    public static double ToDouble(string s);
    public static Guid ToGuid(string s);
    public static short ToInt16(string s);
    public static int ToInt32(string s);
    public static long ToInt64(string s);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string s);
    public static float ToSingle(string s);
    public static string ToString(bool value);
    public static string ToString(byte value);
    public static string ToString(char value);
    [ObsoleteAttribute("Use XmlConvert.ToString() that takes in XmlDateTimeSerializationMode")]
public static string ToString(DateTime value);
    public static string ToString(DateTime value, string format);
    public static string ToString(DateTime value, XmlDateTimeSerializationMode dateTimeOption);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, string format);
    public static string ToString(decimal value);
    public static string ToString(double value);
    public static string ToString(Guid value);
    public static string ToString(short value);
    public static string ToString(int value);
    public static string ToString(long value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(float value);
    public static string ToString(TimeSpan value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static TimeSpan ToTimeSpan(string s);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string s);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string s);
    public static string VerifyName(string name);
    public static string VerifyNCName(string name);
    public static string VerifyNMTOKEN(string name);
    public static string VerifyPublicId(string publicId);
    public static string VerifyTOKEN(string token);
    public static string VerifyWhitespace(string content);
    public static string VerifyXmlChars(string content);
}
public enum System.Xml.XmlDateTimeSerializationMode : Enum {
    public int value__;
    public static XmlDateTimeSerializationMode Local;
    public static XmlDateTimeSerializationMode RoundtripKind;
    public static XmlDateTimeSerializationMode Unspecified;
    public static XmlDateTimeSerializationMode Utc;
}
public class System.Xml.XmlDeclaration : XmlLinkedNode {
    public string Encoding { get; public set; }
    public string InnerText { get; public set; }
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public string Standalone { get; public set; }
    public string Value { get; public set; }
    public string Version { get; }
    protected internal XmlDeclaration(string version, string encoding, string standalone, XmlDocument doc);
    public string get_Encoding();
    public void set_Encoding(string value);
    public virtual string get_InnerText();
    public virtual void set_InnerText(string value);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public string get_Standalone();
    public void set_Standalone(string value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public string get_Version();
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlDictionary : object {
    public static IXmlDictionary Empty { get; }
    public XmlDictionary(int capacity);
    public static IXmlDictionary get_Empty();
    public virtual XmlDictionaryString Add(string value);
    public virtual bool TryLookup(int key, XmlDictionaryString& result);
    public virtual bool TryLookup(string value, XmlDictionaryString& result);
    public virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
public abstract class System.Xml.XmlDictionaryReader : XmlReader {
    public bool CanCanonicalize { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public virtual bool get_CanCanonicalize();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateDictionaryReader(XmlReader reader);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public virtual void EndCanonicalization();
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void GetNonAtomizedNames(String& localName, String& namespaceUri);
    public virtual int IndexOfLocalName(String[] localNames, string namespaceUri);
    public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string namespaceUri);
    public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
    public virtual bool IsStartArray(Type& type);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    protected bool IsTextNode(XmlNodeType nodeType);
    public virtual void MoveToStartElement();
    public virtual void MoveToStartElement(string name);
    public virtual void MoveToStartElement(string localName, string namespaceUri);
    public virtual void MoveToStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual Boolean[] ReadBooleanArray(string localName, string namespaceUri);
    public virtual Boolean[] ReadBooleanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
    public virtual Byte[] ReadContentAsBase64();
    public virtual Byte[] ReadContentAsBinHex();
    protected Byte[] ReadContentAsBinHex(int maxByteArrayContentLength);
    public virtual int ReadContentAsChars(Char[] chars, int offset, int count);
    public virtual decimal ReadContentAsDecimal();
    public virtual float ReadContentAsFloat();
    public virtual Guid ReadContentAsGuid();
    public virtual void ReadContentAsQualifiedName(String& localName, String& namespaceUri);
    public virtual string ReadContentAsString();
    protected string ReadContentAsString(int maxStringContentLength);
    public virtual string ReadContentAsString(String[] strings, Int32& index);
    public virtual string ReadContentAsString(XmlDictionaryString[] strings, Int32& index);
    public virtual TimeSpan ReadContentAsTimeSpan();
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
    public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Double[] ReadDoubleArray(string localName, string namespaceUri);
    public virtual Double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Byte[] ReadElementContentAsBase64();
    public virtual Byte[] ReadElementContentAsBinHex();
    public virtual bool ReadElementContentAsBoolean();
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual decimal ReadElementContentAsDecimal();
    public virtual double ReadElementContentAsDouble();
    public virtual float ReadElementContentAsFloat();
    public virtual Guid ReadElementContentAsGuid();
    public virtual int ReadElementContentAsInt();
    public virtual long ReadElementContentAsLong();
    public virtual string ReadElementContentAsString();
    public virtual TimeSpan ReadElementContentAsTimeSpan();
    public virtual UniqueId ReadElementContentAsUniqueId();
    public virtual void ReadFullStartElement();
    public virtual void ReadFullStartElement(string name);
    public virtual void ReadFullStartElement(string localName, string namespaceUri);
    public virtual void ReadFullStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
    public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int16[] ReadInt16Array(string localName, string namespaceUri);
    public virtual Int16[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int32[] ReadInt32Array(string localName, string namespaceUri);
    public virtual Int32[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int64[] ReadInt64Array(string localName, string namespaceUri);
    public virtual Int64[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Single[] ReadSingleArray(string localName, string namespaceUri);
    public virtual Single[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void ReadStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual string ReadString();
    protected string ReadString(int maxStringContentLength);
    public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual bool TryGetArrayLength(Int32& count);
    public virtual bool TryGetBase64ContentLength(Int32& length);
    public virtual bool TryGetLocalNameAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetNamespaceUriAsDictionaryString(XmlDictionaryString& namespaceUri);
    public virtual bool TryGetValueAsDictionaryString(XmlDictionaryString& value);
}
public class System.Xml.XmlDictionaryReaderQuotas : object {
    public static XmlDictionaryReaderQuotas Max { get; }
    [DefaultValueAttribute("16384")]
public int MaxArrayLength { get; public set; }
    [DefaultValueAttribute("4096")]
public int MaxBytesPerRead { get; public set; }
    [DefaultValueAttribute("32")]
public int MaxDepth { get; public set; }
    [DefaultValueAttribute("16384")]
public int MaxNameTableCharCount { get; public set; }
    [DefaultValueAttribute("8192")]
public int MaxStringContentLength { get; public set; }
    public XmlDictionaryReaderQuotaTypes ModifiedQuotas { get; }
    public static XmlDictionaryReaderQuotas get_Max();
    public int get_MaxArrayLength();
    public void set_MaxArrayLength(int value);
    public int get_MaxBytesPerRead();
    public void set_MaxBytesPerRead(int value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public int get_MaxNameTableCharCount();
    public void set_MaxNameTableCharCount(int value);
    public int get_MaxStringContentLength();
    public void set_MaxStringContentLength(int value);
    public XmlDictionaryReaderQuotaTypes get_ModifiedQuotas();
    public void CopyTo(XmlDictionaryReaderQuotas quotas);
}
[FlagsAttribute]
public enum System.Xml.XmlDictionaryReaderQuotaTypes : Enum {
    public int value__;
    public static XmlDictionaryReaderQuotaTypes MaxArrayLength;
    public static XmlDictionaryReaderQuotaTypes MaxBytesPerRead;
    public static XmlDictionaryReaderQuotaTypes MaxDepth;
    public static XmlDictionaryReaderQuotaTypes MaxNameTableCharCount;
    public static XmlDictionaryReaderQuotaTypes MaxStringContentLength;
}
public class System.Xml.XmlDictionaryString : object {
    public IXmlDictionary Dictionary { get; }
    public static XmlDictionaryString Empty { get; }
    public int Key { get; }
    public string Value { get; }
    public XmlDictionaryString(IXmlDictionary dictionary, string value, int key);
    public IXmlDictionary get_Dictionary();
    public static XmlDictionaryString get_Empty();
    public int get_Key();
    public string get_Value();
    public virtual string ToString();
}
public abstract class System.Xml.XmlDictionaryWriter : XmlWriter {
    public bool CanCanonicalize { get; }
    public virtual bool get_CanCanonicalize();
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    public static XmlDictionaryWriter CreateDictionaryWriter(XmlWriter writer);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding, bool ownsStream);
    public virtual void EndCanonicalization();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    public void WriteAttributeString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public void WriteAttributeString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual Task WriteBase64Async(Byte[] buffer, int index, int count);
    public void WriteElementString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public void WriteElementString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual void WriteNode(XmlDictionaryReader reader, bool defattr);
    public virtual void WriteNode(XmlReader reader, bool defattr);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteStartAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteString(XmlDictionaryString value);
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool isAttribute);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(IStreamProvider value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual Task WriteValueAsync(IStreamProvider value);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
}
public class System.Xml.XmlDocument : XmlNode {
    public string BaseURI { get; }
    public XmlElement DocumentElement { get; }
    public XmlDocumentType DocumentType { get; }
    public XmlImplementation Implementation { get; }
    unknown string InnerText {public set; }
    public string InnerXml { get; public set; }
    public bool IsReadOnly { get; }
    public string LocalName { get; }
    public string Name { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public XmlDocument OwnerDocument { get; }
    public XmlNode ParentNode { get; }
    public bool PreserveWhitespace { get; public set; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public XmlSchemaSet Schemas { get; public set; }
    unknown XmlResolver XmlResolver {public set; }
    protected internal XmlDocument(XmlImplementation imp);
    public XmlDocument(XmlNameTable nt);
    public virtual string get_BaseURI();
    public XmlElement get_DocumentElement();
    public virtual XmlDocumentType get_DocumentType();
    public XmlImplementation get_Implementation();
    public virtual void set_InnerText(string value);
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public virtual bool get_IsReadOnly();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlDocument get_OwnerDocument();
    public virtual XmlNode get_ParentNode();
    public bool get_PreserveWhitespace();
    public void set_PreserveWhitespace(bool value);
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public XmlSchemaSet get_Schemas();
    public void set_Schemas(XmlSchemaSet value);
    public virtual void set_XmlResolver(XmlResolver value);
    public void add_NodeChanged(XmlNodeChangedEventHandler value);
    public void remove_NodeChanged(XmlNodeChangedEventHandler value);
    public void add_NodeChanging(XmlNodeChangedEventHandler value);
    public void remove_NodeChanging(XmlNodeChangedEventHandler value);
    public void add_NodeInserted(XmlNodeChangedEventHandler value);
    public void remove_NodeInserted(XmlNodeChangedEventHandler value);
    public void add_NodeInserting(XmlNodeChangedEventHandler value);
    public void remove_NodeInserting(XmlNodeChangedEventHandler value);
    public void add_NodeRemoved(XmlNodeChangedEventHandler value);
    public void remove_NodeRemoved(XmlNodeChangedEventHandler value);
    public void add_NodeRemoving(XmlNodeChangedEventHandler value);
    public void remove_NodeRemoving(XmlNodeChangedEventHandler value);
    public virtual XmlNode CloneNode(bool deep);
    public XmlAttribute CreateAttribute(string name);
    public XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI);
    public virtual XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI);
    public virtual XmlCDataSection CreateCDataSection(string data);
    public virtual XmlComment CreateComment(string data);
    protected internal virtual XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI);
    public virtual XmlDocumentFragment CreateDocumentFragment();
    public virtual XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset);
    public XmlElement CreateElement(string name);
    public XmlElement CreateElement(string qualifiedName, string namespaceURI);
    public virtual XmlElement CreateElement(string prefix, string localName, string namespaceURI);
    public virtual XmlEntityReference CreateEntityReference(string name);
    public virtual XPathNavigator CreateNavigator();
    protected internal virtual XPathNavigator CreateNavigator(XmlNode node);
    public virtual XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI);
    public virtual XmlNode CreateNode(XmlNodeType type, string name, string namespaceURI);
    public virtual XmlNode CreateNode(XmlNodeType type, string prefix, string name, string namespaceURI);
    public virtual XmlProcessingInstruction CreateProcessingInstruction(string target, string data);
    public virtual XmlSignificantWhitespace CreateSignificantWhitespace(string text);
    public virtual XmlText CreateTextNode(string text);
    public virtual XmlWhitespace CreateWhitespace(string text);
    public virtual XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone);
    public virtual XmlElement GetElementById(string elementId);
    public virtual XmlNodeList GetElementsByTagName(string name);
    public virtual XmlNodeList GetElementsByTagName(string localName, string namespaceURI);
    public virtual XmlNode ImportNode(XmlNode node, bool deep);
    public virtual void Load(Stream inStream);
    public virtual void Load(TextReader txtReader);
    public virtual void Load(string filename);
    public virtual void Load(XmlReader reader);
    public virtual void LoadXml(string xml);
    public virtual XmlNode ReadNode(XmlReader reader);
    public virtual void Save(Stream outStream);
    public virtual void Save(TextWriter writer);
    public virtual void Save(string filename);
    public virtual void Save(XmlWriter w);
    public void Validate(ValidationEventHandler validationEventHandler);
    public void Validate(ValidationEventHandler validationEventHandler, XmlNode nodeToValidate);
    public virtual void WriteContentTo(XmlWriter xw);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlDocumentFragment : XmlNode {
    public string InnerXml { get; public set; }
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public XmlDocument OwnerDocument { get; }
    public XmlNode ParentNode { get; }
    protected internal XmlDocumentFragment(XmlDocument ownerDocument);
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlDocument get_OwnerDocument();
    public virtual XmlNode get_ParentNode();
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlDocumentType : XmlLinkedNode {
    public XmlNamedNodeMap Entities { get; }
    public string InternalSubset { get; }
    public bool IsReadOnly { get; }
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public XmlNamedNodeMap Notations { get; }
    public string PublicId { get; }
    public string SystemId { get; }
    protected internal XmlDocumentType(string name, string publicId, string systemId, string internalSubset, XmlDocument doc);
    public XmlNamedNodeMap get_Entities();
    public string get_InternalSubset();
    public virtual bool get_IsReadOnly();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public XmlNamedNodeMap get_Notations();
    public string get_PublicId();
    public string get_SystemId();
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlElement : XmlLinkedNode {
    public XmlAttributeCollection Attributes { get; }
    public bool HasAttributes { get; }
    public string InnerText { get; public set; }
    public string InnerXml { get; public set; }
    public bool IsEmpty { get; public set; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNode NextSibling { get; }
    public XmlNodeType NodeType { get; }
    public XmlDocument OwnerDocument { get; }
    public XmlNode ParentNode { get; }
    public string Prefix { get; public set; }
    public IXmlSchemaInfo SchemaInfo { get; }
    protected internal XmlElement(string prefix, string localName, string namespaceURI, XmlDocument doc);
    public virtual XmlAttributeCollection get_Attributes();
    public virtual bool get_HasAttributes();
    public virtual string get_InnerText();
    public virtual void set_InnerText(string value);
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public bool get_IsEmpty();
    public void set_IsEmpty(bool value);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNode get_NextSibling();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlDocument get_OwnerDocument();
    public virtual XmlNode get_ParentNode();
    public virtual string get_Prefix();
    public virtual void set_Prefix(string value);
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual XmlNode CloneNode(bool deep);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual XmlAttribute GetAttributeNode(string name);
    public virtual XmlAttribute GetAttributeNode(string localName, string namespaceURI);
    public virtual XmlNodeList GetElementsByTagName(string name);
    public virtual XmlNodeList GetElementsByTagName(string localName, string namespaceURI);
    public virtual bool HasAttribute(string name);
    public virtual bool HasAttribute(string localName, string namespaceURI);
    public virtual void RemoveAll();
    public virtual void RemoveAllAttributes();
    public virtual void RemoveAttribute(string name);
    public virtual void RemoveAttribute(string localName, string namespaceURI);
    public virtual XmlNode RemoveAttributeAt(int i);
    public virtual XmlAttribute RemoveAttributeNode(string localName, string namespaceURI);
    public virtual XmlAttribute RemoveAttributeNode(XmlAttribute oldAttr);
    public virtual void SetAttribute(string name, string value);
    public virtual string SetAttribute(string localName, string namespaceURI, string value);
    public virtual XmlAttribute SetAttributeNode(string localName, string namespaceURI);
    public virtual XmlAttribute SetAttributeNode(XmlAttribute newAttr);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlEntity : XmlNode {
    public string BaseURI { get; }
    public string InnerText { get; public set; }
    public string InnerXml { get; public set; }
    public bool IsReadOnly { get; }
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public string NotationName { get; }
    public string OuterXml { get; }
    public string PublicId { get; }
    public string SystemId { get; }
    public virtual string get_BaseURI();
    public virtual string get_InnerText();
    public virtual void set_InnerText(string value);
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public virtual bool get_IsReadOnly();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public string get_NotationName();
    public virtual string get_OuterXml();
    public string get_PublicId();
    public string get_SystemId();
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlEntityReference : XmlLinkedNode {
    public string BaseURI { get; }
    public bool IsReadOnly { get; }
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public string Value { get; public set; }
    protected internal XmlEntityReference(string name, XmlDocument doc);
    public virtual string get_BaseURI();
    public virtual bool get_IsReadOnly();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlException : SystemException {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Message { get; }
    public string SourceUri { get; }
    protected XmlException(SerializationInfo info, StreamingContext context);
    public XmlException(string message);
    public XmlException(string message, Exception innerException);
    public XmlException(string message, Exception innerException, int lineNumber, int linePosition);
    public int get_LineNumber();
    public int get_LinePosition();
    public virtual string get_Message();
    public string get_SourceUri();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Xml.XmlImplementation : object {
    public XmlImplementation(XmlNameTable nt);
    public virtual XmlDocument CreateDocument();
    public bool HasFeature(string strFeature, string strVersion);
}
public abstract class System.Xml.XmlLinkedNode : XmlNode {
    public XmlNode NextSibling { get; }
    public XmlNode PreviousSibling { get; }
    public virtual XmlNode get_NextSibling();
    public virtual XmlNode get_PreviousSibling();
}
public class System.Xml.XmlNamedNodeMap : object {
    public int Count { get; }
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual XmlNode GetNamedItem(string name);
    public virtual XmlNode GetNamedItem(string localName, string namespaceURI);
    public virtual XmlNode Item(int index);
    public virtual XmlNode RemoveNamedItem(string name);
    public virtual XmlNode RemoveNamedItem(string localName, string namespaceURI);
    public virtual XmlNode SetNamedItem(XmlNode node);
}
public class System.Xml.XmlNamespaceManager : object {
    public string DefaultNamespace { get; }
    public XmlNameTable NameTable { get; }
    public XmlNamespaceManager(XmlNameTable nameTable);
    public virtual string get_DefaultNamespace();
    public virtual XmlNameTable get_NameTable();
    public virtual void AddNamespace(string prefix, string uri);
    public virtual IEnumerator GetEnumerator();
    public virtual IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    public virtual bool HasNamespace(string prefix);
    public virtual string LookupNamespace(string prefix);
    public virtual string LookupPrefix(string uri);
    public virtual bool PopScope();
    public virtual void PushScope();
    public virtual void RemoveNamespace(string prefix, string uri);
}
public enum System.Xml.XmlNamespaceScope : Enum {
    public int value__;
    public static XmlNamespaceScope All;
    public static XmlNamespaceScope ExcludeXml;
    public static XmlNamespaceScope Local;
}
public abstract class System.Xml.XmlNameTable : object {
    public abstract virtual string Add(Char[] array, int offset, int length);
    public abstract virtual string Add(string array);
    public abstract virtual string Get(Char[] array, int offset, int length);
    public abstract virtual string Get(string array);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Xml.XmlNode : object {
    public XmlAttributeCollection Attributes { get; }
    public string BaseURI { get; }
    public XmlNodeList ChildNodes { get; }
    public XmlNode FirstChild { get; }
    public bool HasChildNodes { get; }
    public string InnerText { get; public set; }
    public string InnerXml { get; public set; }
    public bool IsReadOnly { get; }
    public XmlElement Item { get; }
    public XmlElement Item { get; }
    public XmlNode LastChild { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNode NextSibling { get; }
    public XmlNodeType NodeType { get; }
    public string OuterXml { get; }
    public XmlDocument OwnerDocument { get; }
    public XmlNode ParentNode { get; }
    public string Prefix { get; public set; }
    public XmlNode PreviousSibling { get; }
    public XmlNode PreviousText { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public string Value { get; public set; }
    public virtual XmlAttributeCollection get_Attributes();
    public virtual string get_BaseURI();
    public virtual XmlNodeList get_ChildNodes();
    public virtual XmlNode get_FirstChild();
    public virtual bool get_HasChildNodes();
    public virtual string get_InnerText();
    public virtual void set_InnerText(string value);
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public virtual bool get_IsReadOnly();
    public virtual XmlElement get_Item(string name);
    public virtual XmlElement get_Item(string localname, string ns);
    public virtual XmlNode get_LastChild();
    public abstract virtual string get_LocalName();
    public abstract virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNode get_NextSibling();
    public abstract virtual XmlNodeType get_NodeType();
    public virtual string get_OuterXml();
    public virtual XmlDocument get_OwnerDocument();
    public virtual XmlNode get_ParentNode();
    public virtual string get_Prefix();
    public virtual void set_Prefix(string value);
    public virtual XmlNode get_PreviousSibling();
    public virtual XmlNode get_PreviousText();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual XmlNode AppendChild(XmlNode newChild);
    public virtual XmlNode Clone();
    public abstract virtual XmlNode CloneNode(bool deep);
    public virtual XPathNavigator CreateNavigator();
    public IEnumerator GetEnumerator();
    public virtual string GetNamespaceOfPrefix(string prefix);
    public virtual string GetPrefixOfNamespace(string namespaceURI);
    public virtual XmlNode InsertAfter(XmlNode newChild, XmlNode refChild);
    public virtual XmlNode InsertBefore(XmlNode newChild, XmlNode refChild);
    public virtual void Normalize();
    public virtual XmlNode PrependChild(XmlNode newChild);
    public virtual void RemoveAll();
    public virtual XmlNode RemoveChild(XmlNode oldChild);
    public virtual XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild);
    public XmlNodeList SelectNodes(string xpath);
    public XmlNodeList SelectNodes(string xpath, XmlNamespaceManager nsmgr);
    public XmlNode SelectSingleNode(string xpath);
    public XmlNode SelectSingleNode(string xpath, XmlNamespaceManager nsmgr);
    public virtual bool Supports(string feature, string version);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override object System.ICloneable.Clone();
    public abstract virtual void WriteContentTo(XmlWriter w);
    public abstract virtual void WriteTo(XmlWriter w);
}
public enum System.Xml.XmlNodeChangedAction : Enum {
    public int value__;
    public static XmlNodeChangedAction Change;
    public static XmlNodeChangedAction Insert;
    public static XmlNodeChangedAction Remove;
}
public class System.Xml.XmlNodeChangedEventArgs : EventArgs {
    public XmlNodeChangedAction Action { get; }
    public XmlNode NewParent { get; }
    public string NewValue { get; }
    public XmlNode Node { get; }
    public XmlNode OldParent { get; }
    public string OldValue { get; }
    public XmlNodeChangedEventArgs(XmlNode node, XmlNode oldParent, XmlNode newParent, string oldValue, string newValue, XmlNodeChangedAction action);
    public XmlNodeChangedAction get_Action();
    public XmlNode get_NewParent();
    public string get_NewValue();
    public XmlNode get_Node();
    public XmlNode get_OldParent();
    public string get_OldValue();
}
public class System.Xml.XmlNodeChangedEventHandler : MulticastDelegate {
    public XmlNodeChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, XmlNodeChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, XmlNodeChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("ItemOf")]
public abstract class System.Xml.XmlNodeList : object {
    public int Count { get; }
    public XmlNode ItemOf { get; }
    public abstract virtual int get_Count();
    public virtual XmlNode get_ItemOf(int i);
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual XmlNode Item(int index);
    protected virtual void PrivateDisposeNodeList();
    private sealed virtual override void System.IDisposable.Dispose();
}
public enum System.Xml.XmlNodeOrder : Enum {
    public int value__;
    public static XmlNodeOrder After;
    public static XmlNodeOrder Before;
    public static XmlNodeOrder Same;
    public static XmlNodeOrder Unknown;
}
public class System.Xml.XmlNodeReader : XmlReader {
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanResolveEntity { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool HasAttributes { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public ReadState ReadState { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public string Value { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public XmlNodeReader(XmlNode node);
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanResolveEntity();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual bool get_HasAttributes();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual ReadState get_ReadState();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual string get_Value();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual void Close();
    public virtual string GetAttribute(int attributeIndex);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string LookupNamespace(string prefix);
    public virtual void MoveToAttribute(int attributeIndex);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string namespaceURI);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool Read();
    public virtual bool ReadAttributeValue();
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual string ReadString();
    public virtual void ResolveEntity();
    public virtual void Skip();
    private sealed virtual override IDictionary`2<string, string> System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName);
}
public enum System.Xml.XmlNodeType : Enum {
    public int value__;
    public static XmlNodeType Attribute;
    public static XmlNodeType CDATA;
    public static XmlNodeType Comment;
    public static XmlNodeType Document;
    public static XmlNodeType DocumentFragment;
    public static XmlNodeType DocumentType;
    public static XmlNodeType Element;
    public static XmlNodeType EndElement;
    public static XmlNodeType EndEntity;
    public static XmlNodeType Entity;
    public static XmlNodeType EntityReference;
    public static XmlNodeType None;
    public static XmlNodeType Notation;
    public static XmlNodeType ProcessingInstruction;
    public static XmlNodeType SignificantWhitespace;
    public static XmlNodeType Text;
    public static XmlNodeType Whitespace;
    public static XmlNodeType XmlDeclaration;
}
public class System.Xml.XmlNotation : XmlNode {
    public string InnerXml { get; public set; }
    public bool IsReadOnly { get; }
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public string OuterXml { get; }
    public string PublicId { get; }
    public string SystemId { get; }
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public virtual bool get_IsReadOnly();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_OuterXml();
    public string get_PublicId();
    public string get_SystemId();
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public enum System.Xml.XmlOutputMethod : Enum {
    public int value__;
    public static XmlOutputMethod AutoDetect;
    public static XmlOutputMethod Html;
    public static XmlOutputMethod Text;
    public static XmlOutputMethod Xml;
}
public class System.Xml.XmlParserContext : object {
    public string BaseURI { get; public set; }
    public string DocTypeName { get; public set; }
    public Encoding Encoding { get; public set; }
    public string InternalSubset { get; public set; }
    public XmlNamespaceManager NamespaceManager { get; public set; }
    public XmlNameTable NameTable { get; public set; }
    public string PublicId { get; public set; }
    public string SystemId { get; public set; }
    public string XmlLang { get; public set; }
    public XmlSpace XmlSpace { get; public set; }
    public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string docTypeName, string pubId, string sysId, string internalSubset, string baseURI, string xmlLang, XmlSpace xmlSpace);
    public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string docTypeName, string pubId, string sysId, string internalSubset, string baseURI, string xmlLang, XmlSpace xmlSpace, Encoding enc);
    public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string xmlLang, XmlSpace xmlSpace);
    public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string xmlLang, XmlSpace xmlSpace, Encoding enc);
    public string get_BaseURI();
    public void set_BaseURI(string value);
    public string get_DocTypeName();
    public void set_DocTypeName(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string get_InternalSubset();
    public void set_InternalSubset(string value);
    public XmlNamespaceManager get_NamespaceManager();
    public void set_NamespaceManager(XmlNamespaceManager value);
    public XmlNameTable get_NameTable();
    public void set_NameTable(XmlNameTable value);
    public string get_PublicId();
    public void set_PublicId(string value);
    public string get_SystemId();
    public void set_SystemId(string value);
    public string get_XmlLang();
    public void set_XmlLang(string value);
    public XmlSpace get_XmlSpace();
    public void set_XmlSpace(XmlSpace value);
}
public class System.Xml.XmlProcessingInstruction : XmlLinkedNode {
    public string Data { get; public set; }
    public string InnerText { get; public set; }
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public string Target { get; }
    public string Value { get; public set; }
    protected internal XmlProcessingInstruction(string target, string data, XmlDocument doc);
    public string get_Data();
    public void set_Data(string value);
    public virtual string get_InnerText();
    public virtual void set_InnerText(string value);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public string get_Target();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public class System.Xml.XmlQualifiedName : object {
    public static XmlQualifiedName Empty;
    public bool IsEmpty { get; }
    public string Name { get; }
    public string Namespace { get; }
    public XmlQualifiedName(string name);
    public XmlQualifiedName(string name, string ns);
    public bool get_IsEmpty();
    public string get_Name();
    public string get_Namespace();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(XmlQualifiedName a, XmlQualifiedName b);
    public static bool op_Inequality(XmlQualifiedName a, XmlQualifiedName b);
    public virtual string ToString();
    public static string ToString(string name, string ns);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Xml.XmlReader : object {
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public bool CanResolveEntity { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool HasAttributes { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public XmlReaderSettings Settings { get; }
    public string Value { get; }
    public Type ValueType { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public abstract virtual int get_AttributeCount();
    public abstract virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_CanResolveEntity();
    public abstract virtual int get_Depth();
    public abstract virtual bool get_EOF();
    public virtual bool get_HasAttributes();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public abstract virtual bool get_IsEmptyElement();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public abstract virtual string get_LocalName();
    public virtual string get_Name();
    public abstract virtual string get_NamespaceURI();
    public abstract virtual XmlNameTable get_NameTable();
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public abstract virtual ReadState get_ReadState();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual XmlReaderSettings get_Settings();
    public abstract virtual string get_Value();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual void Close();
    public static XmlReader Create(Stream input);
    public static XmlReader Create(Stream input, XmlReaderSettings settings);
    public static XmlReader Create(Stream input, XmlReaderSettings settings, string baseUri);
    public static XmlReader Create(Stream input, XmlReaderSettings settings, XmlParserContext inputContext);
    public static XmlReader Create(TextReader input);
    public static XmlReader Create(TextReader input, XmlReaderSettings settings);
    public static XmlReader Create(TextReader input, XmlReaderSettings settings, string baseUri);
    public static XmlReader Create(TextReader input, XmlReaderSettings settings, XmlParserContext inputContext);
    public static XmlReader Create(string inputUri);
    public static XmlReader Create(string inputUri, XmlReaderSettings settings);
    public static XmlReader Create(string inputUri, XmlReaderSettings settings, XmlParserContext inputContext);
    public static XmlReader Create(XmlReader reader, XmlReaderSettings settings);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual string GetAttribute(int i);
    public abstract virtual string GetAttribute(string name);
    public abstract virtual string GetAttribute(string name, string namespaceURI);
    public virtual Task`1<string> GetValueAsync();
    public static bool IsName(string str);
    public static bool IsNameToken(string str);
    public virtual bool IsStartElement();
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localname, string ns);
    public abstract virtual string LookupNamespace(string prefix);
    public virtual void MoveToAttribute(int i);
    public abstract virtual bool MoveToAttribute(string name);
    public abstract virtual bool MoveToAttribute(string name, string ns);
    public virtual XmlNodeType MoveToContent();
    public virtual Task`1<XmlNodeType> MoveToContentAsync();
    public abstract virtual bool MoveToElement();
    public abstract virtual bool MoveToFirstAttribute();
    public abstract virtual bool MoveToNextAttribute();
    public abstract virtual bool Read();
    public virtual Task`1<bool> ReadAsync();
    public abstract virtual bool ReadAttributeValue();
    public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual Task`1<object> ReadContentAsAsync(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual Task`1<int> ReadContentAsBase64Async(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual Task`1<int> ReadContentAsBinHexAsync(Byte[] buffer, int index, int count);
    public virtual bool ReadContentAsBoolean();
    public virtual DateTime ReadContentAsDateTime();
    public virtual DateTimeOffset ReadContentAsDateTimeOffset();
    public virtual decimal ReadContentAsDecimal();
    public virtual double ReadContentAsDouble();
    public virtual float ReadContentAsFloat();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual object ReadContentAsObject();
    public virtual Task`1<object> ReadContentAsObjectAsync();
    public virtual string ReadContentAsString();
    public virtual Task`1<string> ReadContentAsStringAsync();
    public virtual object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);
    public virtual Task`1<object> ReadElementContentAsAsync(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int index, int count);
    public virtual Task`1<int> ReadElementContentAsBase64Async(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual Task`1<int> ReadElementContentAsBinHexAsync(Byte[] buffer, int index, int count);
    public virtual bool ReadElementContentAsBoolean();
    public virtual bool ReadElementContentAsBoolean(string localName, string namespaceURI);
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual DateTime ReadElementContentAsDateTime(string localName, string namespaceURI);
    public virtual decimal ReadElementContentAsDecimal();
    public virtual decimal ReadElementContentAsDecimal(string localName, string namespaceURI);
    public virtual double ReadElementContentAsDouble();
    public virtual double ReadElementContentAsDouble(string localName, string namespaceURI);
    public virtual float ReadElementContentAsFloat();
    public virtual float ReadElementContentAsFloat(string localName, string namespaceURI);
    public virtual int ReadElementContentAsInt();
    public virtual int ReadElementContentAsInt(string localName, string namespaceURI);
    public virtual long ReadElementContentAsLong();
    public virtual long ReadElementContentAsLong(string localName, string namespaceURI);
    public virtual object ReadElementContentAsObject();
    public virtual object ReadElementContentAsObject(string localName, string namespaceURI);
    public virtual Task`1<object> ReadElementContentAsObjectAsync();
    public virtual string ReadElementContentAsString();
    public virtual string ReadElementContentAsString(string localName, string namespaceURI);
    public virtual Task`1<string> ReadElementContentAsStringAsync();
    [EditorBrowsableAttribute("1")]
public virtual string ReadElementString();
    [EditorBrowsableAttribute("1")]
public virtual string ReadElementString(string name);
    [EditorBrowsableAttribute("1")]
public virtual string ReadElementString(string localname, string ns);
    public virtual void ReadEndElement();
    public virtual string ReadInnerXml();
    public virtual Task`1<string> ReadInnerXmlAsync();
    public virtual string ReadOuterXml();
    public virtual Task`1<string> ReadOuterXmlAsync();
    public virtual void ReadStartElement();
    public virtual void ReadStartElement(string name);
    public virtual void ReadStartElement(string localname, string ns);
    [EditorBrowsableAttribute("1")]
public virtual string ReadString();
    public virtual XmlReader ReadSubtree();
    public virtual bool ReadToDescendant(string name);
    public virtual bool ReadToDescendant(string localName, string namespaceURI);
    public virtual bool ReadToFollowing(string name);
    public virtual bool ReadToFollowing(string localName, string namespaceURI);
    public virtual bool ReadToNextSibling(string name);
    public virtual bool ReadToNextSibling(string localName, string namespaceURI);
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadValueChunkAsync(Char[] buffer, int index, int count);
    public abstract virtual void ResolveEntity();
    public virtual void Skip();
    public virtual Task SkipAsync();
}
public class System.Xml.XmlReaderSettings : object {
    public bool Async { get; public set; }
    public bool CheckCharacters { get; public set; }
    public bool CloseInput { get; public set; }
    public ConformanceLevel ConformanceLevel { get; public set; }
    public DtdProcessing DtdProcessing { get; public set; }
    public bool IgnoreComments { get; public set; }
    public bool IgnoreProcessingInstructions { get; public set; }
    public bool IgnoreWhitespace { get; public set; }
    public int LineNumberOffset { get; public set; }
    public int LinePositionOffset { get; public set; }
    public long MaxCharactersFromEntities { get; public set; }
    public long MaxCharactersInDocument { get; public set; }
    public XmlNameTable NameTable { get; public set; }
    [ObsoleteAttribute("Use XmlReaderSettings.DtdProcessing property instead.")]
public bool ProhibitDtd { get; public set; }
    public XmlSchemaSet Schemas { get; public set; }
    public XmlSchemaValidationFlags ValidationFlags { get; public set; }
    public ValidationType ValidationType { get; public set; }
    unknown XmlResolver XmlResolver {public set; }
    public bool get_Async();
    public void set_Async(bool value);
    public bool get_CheckCharacters();
    public void set_CheckCharacters(bool value);
    public bool get_CloseInput();
    public void set_CloseInput(bool value);
    public ConformanceLevel get_ConformanceLevel();
    public void set_ConformanceLevel(ConformanceLevel value);
    public DtdProcessing get_DtdProcessing();
    public void set_DtdProcessing(DtdProcessing value);
    public bool get_IgnoreComments();
    public void set_IgnoreComments(bool value);
    public bool get_IgnoreProcessingInstructions();
    public void set_IgnoreProcessingInstructions(bool value);
    public bool get_IgnoreWhitespace();
    public void set_IgnoreWhitespace(bool value);
    public int get_LineNumberOffset();
    public void set_LineNumberOffset(int value);
    public int get_LinePositionOffset();
    public void set_LinePositionOffset(int value);
    public long get_MaxCharactersFromEntities();
    public void set_MaxCharactersFromEntities(long value);
    public long get_MaxCharactersInDocument();
    public void set_MaxCharactersInDocument(long value);
    public XmlNameTable get_NameTable();
    public void set_NameTable(XmlNameTable value);
    public bool get_ProhibitDtd();
    public void set_ProhibitDtd(bool value);
    public XmlSchemaSet get_Schemas();
    public void set_Schemas(XmlSchemaSet value);
    public XmlSchemaValidationFlags get_ValidationFlags();
    public void set_ValidationFlags(XmlSchemaValidationFlags value);
    public ValidationType get_ValidationType();
    public void set_ValidationType(ValidationType value);
    public void set_XmlResolver(XmlResolver value);
    public void add_ValidationEventHandler(ValidationEventHandler value);
    public void remove_ValidationEventHandler(ValidationEventHandler value);
    public XmlReaderSettings Clone();
    public void Reset();
}
public abstract class System.Xml.XmlResolver : object {
    unknown ICredentials Credentials {public set; }
    public virtual void set_Credentials(ICredentials value);
    public abstract virtual object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn);
    public virtual Task`1<object> GetEntityAsync(Uri absoluteUri, string role, Type ofObjectToReturn);
    public virtual Uri ResolveUri(Uri baseUri, string relativeUri);
    public virtual bool SupportsType(Uri absoluteUri, Type type);
}
public class System.Xml.XmlSecureResolver : XmlResolver {
    unknown ICredentials Credentials {public set; }
    public XmlSecureResolver(XmlResolver resolver, string securityUrl);
    public virtual void set_Credentials(ICredentials value);
    public virtual object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn);
    public virtual Task`1<object> GetEntityAsync(Uri absoluteUri, string role, Type ofObjectToReturn);
    public virtual Uri ResolveUri(Uri baseUri, string relativeUri);
}
public class System.Xml.XmlSignificantWhitespace : XmlCharacterData {
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public XmlNode ParentNode { get; }
    public XmlNode PreviousText { get; }
    public string Value { get; public set; }
    protected internal XmlSignificantWhitespace(string strData, XmlDocument doc);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlNode get_ParentNode();
    public virtual XmlNode get_PreviousText();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public enum System.Xml.XmlSpace : Enum {
    public int value__;
    public static XmlSpace Default;
    public static XmlSpace None;
    public static XmlSpace Preserve;
}
public class System.Xml.XmlText : XmlCharacterData {
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public XmlNode ParentNode { get; }
    public XmlNode PreviousText { get; }
    public string Value { get; public set; }
    protected internal XmlText(string strData, XmlDocument doc);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlNode get_ParentNode();
    public virtual XmlNode get_PreviousText();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual XmlNode CloneNode(bool deep);
    public virtual XmlText SplitText(int offset);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.XmlTextReader : XmlReader {
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public bool CanResolveEntity { get; }
    public int Depth { get; }
    public DtdProcessing DtdProcessing { get; public set; }
    public Encoding Encoding { get; }
    public EntityHandling EntityHandling { get; public set; }
    public bool EOF { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string LocalName { get; }
    public string Name { get; }
    public bool Namespaces { get; public set; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public bool Normalization { get; public set; }
    public string Prefix { get; }
    [ObsoleteAttribute("Use DtdProcessing property instead.")]
public bool ProhibitDtd { get; public set; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public string Value { get; }
    public WhitespaceHandling WhitespaceHandling { get; public set; }
    public string XmlLang { get; }
    unknown XmlResolver XmlResolver {public set; }
    public XmlSpace XmlSpace { get; }
    public XmlTextReader(Stream input);
    public XmlTextReader(Stream input, XmlNameTable nt);
    public XmlTextReader(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context);
    public XmlTextReader(TextReader input);
    public XmlTextReader(TextReader input, XmlNameTable nt);
    public XmlTextReader(string url);
    public XmlTextReader(string url, Stream input);
    public XmlTextReader(string url, Stream input, XmlNameTable nt);
    public XmlTextReader(string url, TextReader input);
    public XmlTextReader(string url, TextReader input, XmlNameTable nt);
    public XmlTextReader(string url, XmlNameTable nt);
    public XmlTextReader(string xmlFragment, XmlNodeType fragType, XmlParserContext context);
    protected XmlTextReader(XmlNameTable nt);
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_CanResolveEntity();
    public virtual int get_Depth();
    public DtdProcessing get_DtdProcessing();
    public void set_DtdProcessing(DtdProcessing value);
    public Encoding get_Encoding();
    public EntityHandling get_EntityHandling();
    public void set_EntityHandling(EntityHandling value);
    public virtual bool get_EOF();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public bool get_Namespaces();
    public void set_Namespaces(bool value);
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public bool get_Normalization();
    public void set_Normalization(bool value);
    public virtual string get_Prefix();
    public bool get_ProhibitDtd();
    public void set_ProhibitDtd(bool value);
    public virtual char get_QuoteChar();
    public virtual ReadState get_ReadState();
    public virtual string get_Value();
    public WhitespaceHandling get_WhitespaceHandling();
    public void set_WhitespaceHandling(WhitespaceHandling value);
    public virtual string get_XmlLang();
    public void set_XmlResolver(XmlResolver value);
    public virtual XmlSpace get_XmlSpace();
    public virtual void Close();
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    public TextReader GetRemainder();
    public sealed virtual bool HasLineInfo();
    public virtual string LookupNamespace(string prefix);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool Read();
    public virtual bool ReadAttributeValue();
    public int ReadBase64(Byte[] array, int offset, int len);
    public int ReadBinHex(Byte[] array, int offset, int len);
    public int ReadChars(Char[] buffer, int index, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual string ReadString();
    public void ResetState();
    public virtual void ResolveEntity();
    public virtual void Skip();
    private sealed virtual override IDictionary`2<string, string> System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.XmlTextWriter : XmlWriter {
    public Stream BaseStream { get; }
    public Formatting Formatting { get; public set; }
    public int Indentation { get; public set; }
    public char IndentChar { get; public set; }
    public bool Namespaces { get; public set; }
    public char QuoteChar { get; public set; }
    public WriteState WriteState { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public XmlTextWriter(Stream w, Encoding encoding);
    public XmlTextWriter(TextWriter w);
    public XmlTextWriter(string filename, Encoding encoding);
    public Stream get_BaseStream();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_Namespaces();
    public void set_Namespaces(bool value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public virtual WriteState get_WriteState();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual void Close();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    public virtual void WriteName(string name);
    public virtual void WriteNmToken(string name);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string ws);
}
public enum System.Xml.XmlTokenizedType : Enum {
    public int value__;
    public static XmlTokenizedType CDATA;
    public static XmlTokenizedType ENTITIES;
    public static XmlTokenizedType ENTITY;
    public static XmlTokenizedType ENUMERATION;
    public static XmlTokenizedType ID;
    public static XmlTokenizedType IDREF;
    public static XmlTokenizedType IDREFS;
    public static XmlTokenizedType NCName;
    public static XmlTokenizedType NMTOKEN;
    public static XmlTokenizedType NMTOKENS;
    public static XmlTokenizedType None;
    public static XmlTokenizedType NOTATION;
    public static XmlTokenizedType QName;
}
public class System.Xml.XmlUrlResolver : XmlResolver {
    unknown RequestCachePolicy CachePolicy {public set; }
    unknown ICredentials Credentials {public set; }
    unknown IWebProxy Proxy {public set; }
    public void set_CachePolicy(RequestCachePolicy value);
    public virtual void set_Credentials(ICredentials value);
    public void set_Proxy(IWebProxy value);
    public virtual object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn);
    public virtual Task`1<object> GetEntityAsync(Uri absoluteUri, string role, Type ofObjectToReturn);
    public virtual Uri ResolveUri(Uri baseUri, string relativeUri);
}
[ObsoleteAttribute("Use XmlReader created by XmlReader.Create() method using appropriate XmlReaderSettings instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Xml.XmlValidatingReader : XmlReader {
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanResolveEntity { get; }
    public int Depth { get; }
    public Encoding Encoding { get; }
    public EntityHandling EntityHandling { get; public set; }
    public bool EOF { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string LocalName { get; }
    public string Name { get; }
    public bool Namespaces { get; public set; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public XmlReader Reader { get; }
    public ReadState ReadState { get; }
    public XmlSchemaCollection Schemas { get; }
    public object SchemaType { get; }
    public ValidationType ValidationType { get; public set; }
    public string Value { get; }
    public string XmlLang { get; }
    unknown XmlResolver XmlResolver {public set; }
    public XmlSpace XmlSpace { get; }
    public XmlValidatingReader(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context);
    public XmlValidatingReader(string xmlFragment, XmlNodeType fragType, XmlParserContext context);
    public XmlValidatingReader(XmlReader reader);
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanResolveEntity();
    public virtual int get_Depth();
    public Encoding get_Encoding();
    public EntityHandling get_EntityHandling();
    public void set_EntityHandling(EntityHandling value);
    public virtual bool get_EOF();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public bool get_Namespaces();
    public void set_Namespaces(bool value);
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public XmlReader get_Reader();
    public virtual ReadState get_ReadState();
    public XmlSchemaCollection get_Schemas();
    public object get_SchemaType();
    public ValidationType get_ValidationType();
    public void set_ValidationType(ValidationType value);
    public virtual string get_Value();
    public virtual string get_XmlLang();
    public void set_XmlResolver(XmlResolver value);
    public virtual XmlSpace get_XmlSpace();
    public void add_ValidationEventHandler(ValidationEventHandler value);
    public void remove_ValidationEventHandler(ValidationEventHandler value);
    public virtual void Close();
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public sealed virtual bool HasLineInfo();
    public virtual string LookupNamespace(string prefix);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool Read();
    public virtual bool ReadAttributeValue();
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual string ReadString();
    public object ReadTypedValue();
    public virtual void ResolveEntity();
    private sealed virtual override IDictionary`2<string, string> System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName);
}
public class System.Xml.XmlWhitespace : XmlCharacterData {
    public string LocalName { get; }
    public string Name { get; }
    public XmlNodeType NodeType { get; }
    public XmlNode ParentNode { get; }
    public XmlNode PreviousText { get; }
    public string Value { get; public set; }
    protected internal XmlWhitespace(string strData, XmlDocument doc);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual XmlNodeType get_NodeType();
    public virtual XmlNode get_ParentNode();
    public virtual XmlNode get_PreviousText();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual XmlNode CloneNode(bool deep);
    public virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter w);
}
public abstract class System.Xml.XmlWriter : object {
    public XmlWriterSettings Settings { get; }
    public WriteState WriteState { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public virtual XmlWriterSettings get_Settings();
    public abstract virtual WriteState get_WriteState();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual void Close();
    public static XmlWriter Create(Stream output);
    public static XmlWriter Create(Stream output, XmlWriterSettings settings);
    public static XmlWriter Create(TextWriter output);
    public static XmlWriter Create(TextWriter output, XmlWriterSettings settings);
    public static XmlWriter Create(string outputFileName);
    public static XmlWriter Create(string outputFileName, XmlWriterSettings settings);
    public static XmlWriter Create(StringBuilder output);
    public static XmlWriter Create(StringBuilder output, XmlWriterSettings settings);
    public static XmlWriter Create(XmlWriter output);
    public static XmlWriter Create(XmlWriter output, XmlWriterSettings settings);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Flush();
    public virtual Task FlushAsync();
    public abstract virtual string LookupPrefix(string ns);
    public virtual void WriteAttributes(XmlReader reader, bool defattr);
    public virtual Task WriteAttributesAsync(XmlReader reader, bool defattr);
    public void WriteAttributeString(string localName, string value);
    public void WriteAttributeString(string localName, string ns, string value);
    public void WriteAttributeString(string prefix, string localName, string ns, string value);
    public Task WriteAttributeStringAsync(string prefix, string localName, string ns, string value);
    public abstract virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual Task WriteBase64Async(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual Task WriteBinHexAsync(Byte[] buffer, int index, int count);
    public abstract virtual void WriteCData(string text);
    public virtual Task WriteCDataAsync(string text);
    public abstract virtual void WriteCharEntity(char ch);
    public virtual Task WriteCharEntityAsync(char ch);
    public abstract virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual Task WriteCharsAsync(Char[] buffer, int index, int count);
    public abstract virtual void WriteComment(string text);
    public virtual Task WriteCommentAsync(string text);
    public abstract virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual Task WriteDocTypeAsync(string name, string pubid, string sysid, string subset);
    public void WriteElementString(string localName, string value);
    public void WriteElementString(string localName, string ns, string value);
    public void WriteElementString(string prefix, string localName, string ns, string value);
    public Task WriteElementStringAsync(string prefix, string localName, string ns, string value);
    public abstract virtual void WriteEndAttribute();
    protected internal virtual Task WriteEndAttributeAsync();
    public abstract virtual void WriteEndDocument();
    public virtual Task WriteEndDocumentAsync();
    public abstract virtual void WriteEndElement();
    public virtual Task WriteEndElementAsync();
    public abstract virtual void WriteEntityRef(string name);
    public virtual Task WriteEntityRefAsync(string name);
    public abstract virtual void WriteFullEndElement();
    public virtual Task WriteFullEndElementAsync();
    public virtual void WriteName(string name);
    public virtual Task WriteNameAsync(string name);
    public virtual void WriteNmToken(string name);
    public virtual Task WriteNmTokenAsync(string name);
    public virtual void WriteNode(XmlReader reader, bool defattr);
    public virtual void WriteNode(XPathNavigator navigator, bool defattr);
    public virtual Task WriteNodeAsync(XmlReader reader, bool defattr);
    public virtual Task WriteNodeAsync(XPathNavigator navigator, bool defattr);
    public abstract virtual void WriteProcessingInstruction(string name, string text);
    public virtual Task WriteProcessingInstructionAsync(string name, string text);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual Task WriteQualifiedNameAsync(string localName, string ns);
    public abstract virtual void WriteRaw(Char[] buffer, int index, int count);
    public abstract virtual void WriteRaw(string data);
    public virtual Task WriteRawAsync(Char[] buffer, int index, int count);
    public virtual Task WriteRawAsync(string data);
    public void WriteStartAttribute(string localName);
    public void WriteStartAttribute(string localName, string ns);
    public abstract virtual void WriteStartAttribute(string prefix, string localName, string ns);
    protected internal virtual Task WriteStartAttributeAsync(string prefix, string localName, string ns);
    public abstract virtual void WriteStartDocument();
    public abstract virtual void WriteStartDocument(bool standalone);
    public virtual Task WriteStartDocumentAsync();
    public virtual Task WriteStartDocumentAsync(bool standalone);
    public void WriteStartElement(string localName);
    public void WriteStartElement(string localName, string ns);
    public abstract virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual Task WriteStartElementAsync(string prefix, string localName, string ns);
    public abstract virtual void WriteString(string text);
    public virtual Task WriteStringAsync(string text);
    public abstract virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual Task WriteSurrogateCharEntityAsync(char lowChar, char highChar);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(string value);
    public abstract virtual void WriteWhitespace(string ws);
    public virtual Task WriteWhitespaceAsync(string ws);
}
public class System.Xml.XmlWriterSettings : object {
    public bool Async { get; public set; }
    public bool CheckCharacters { get; public set; }
    public bool CloseOutput { get; public set; }
    public ConformanceLevel ConformanceLevel { get; public set; }
    public bool DoNotEscapeUriAttributes { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool Indent { get; public set; }
    public string IndentChars { get; public set; }
    public NamespaceHandling NamespaceHandling { get; public set; }
    public string NewLineChars { get; public set; }
    public NewLineHandling NewLineHandling { get; public set; }
    public bool NewLineOnAttributes { get; public set; }
    public bool OmitXmlDeclaration { get; public set; }
    public XmlOutputMethod OutputMethod { get; }
    public bool WriteEndDocumentOnClose { get; public set; }
    public bool get_Async();
    public void set_Async(bool value);
    public bool get_CheckCharacters();
    public void set_CheckCharacters(bool value);
    public bool get_CloseOutput();
    public void set_CloseOutput(bool value);
    public ConformanceLevel get_ConformanceLevel();
    public void set_ConformanceLevel(ConformanceLevel value);
    public bool get_DoNotEscapeUriAttributes();
    public void set_DoNotEscapeUriAttributes(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_Indent();
    public void set_Indent(bool value);
    public string get_IndentChars();
    public void set_IndentChars(string value);
    public NamespaceHandling get_NamespaceHandling();
    public void set_NamespaceHandling(NamespaceHandling value);
    public string get_NewLineChars();
    public void set_NewLineChars(string value);
    public NewLineHandling get_NewLineHandling();
    public void set_NewLineHandling(NewLineHandling value);
    public bool get_NewLineOnAttributes();
    public void set_NewLineOnAttributes(bool value);
    public bool get_OmitXmlDeclaration();
    public void set_OmitXmlDeclaration(bool value);
    public XmlOutputMethod get_OutputMethod();
    public bool get_WriteEndDocumentOnClose();
    public void set_WriteEndDocumentOnClose(bool value);
    public XmlWriterSettings Clone();
    public void Reset();
}
[ExtensionAttribute]
public static class System.Xml.XPath.Extensions : object {
    [ExtensionAttribute]
public static XPathNavigator CreateNavigator(XNode node);
    [ExtensionAttribute]
public static XPathNavigator CreateNavigator(XNode node, XmlNameTable nameTable);
    [ExtensionAttribute]
public static object XPathEvaluate(XNode node, string expression);
    [ExtensionAttribute]
public static object XPathEvaluate(XNode node, string expression, IXmlNamespaceResolver resolver);
    [ExtensionAttribute]
public static XElement XPathSelectElement(XNode node, string expression);
    [ExtensionAttribute]
public static XElement XPathSelectElement(XNode node, string expression, IXmlNamespaceResolver resolver);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> XPathSelectElements(XNode node, string expression);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> XPathSelectElements(XNode node, string expression, IXmlNamespaceResolver resolver);
}
public interface System.Xml.XPath.IXPathNavigable {
    public abstract virtual XPathNavigator CreateNavigator();
}
[ExtensionAttribute]
public static class System.Xml.XPath.XDocumentExtensions : object {
    [ExtensionAttribute]
public static IXPathNavigable ToXPathNavigable(XNode node);
}
public enum System.Xml.XPath.XmlCaseOrder : Enum {
    public int value__;
    public static XmlCaseOrder LowerFirst;
    public static XmlCaseOrder None;
    public static XmlCaseOrder UpperFirst;
}
public enum System.Xml.XPath.XmlDataType : Enum {
    public int value__;
    public static XmlDataType Number;
    public static XmlDataType Text;
}
public enum System.Xml.XPath.XmlSortOrder : Enum {
    public int value__;
    public static XmlSortOrder Ascending;
    public static XmlSortOrder Descending;
}
public class System.Xml.XPath.XPathDocument : object {
    public XPathDocument(Stream stream);
    public XPathDocument(TextReader textReader);
    public XPathDocument(string uri);
    public XPathDocument(string uri, XmlSpace space);
    public XPathDocument(XmlReader reader);
    public XPathDocument(XmlReader reader, XmlSpace space);
    public sealed virtual XPathNavigator CreateNavigator();
}
public class System.Xml.XPath.XPathException : SystemException {
    public string Message { get; }
    protected XPathException(SerializationInfo info, StreamingContext context);
    public XPathException(string message);
    public XPathException(string message, Exception innerException);
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.Xml.XPath.XPathExpression : object {
    public string Expression { get; }
    public XPathResultType ReturnType { get; }
    public abstract virtual string get_Expression();
    public abstract virtual XPathResultType get_ReturnType();
    public abstract virtual void AddSort(object expr, IComparer comparer);
    public abstract virtual void AddSort(object expr, XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType);
    public abstract virtual XPathExpression Clone();
    public static XPathExpression Compile(string xpath);
    public static XPathExpression Compile(string xpath, IXmlNamespaceResolver nsResolver);
    public abstract virtual void SetContext(IXmlNamespaceResolver nsResolver);
    public abstract virtual void SetContext(XmlNamespaceManager nsManager);
}
public abstract class System.Xml.XPath.XPathItem : object {
    public bool IsNode { get; }
    public object TypedValue { get; }
    public string Value { get; }
    public bool ValueAsBoolean { get; }
    public DateTime ValueAsDateTime { get; }
    public double ValueAsDouble { get; }
    public int ValueAsInt { get; }
    public long ValueAsLong { get; }
    public Type ValueType { get; }
    public XmlSchemaType XmlType { get; }
    public abstract virtual bool get_IsNode();
    public abstract virtual object get_TypedValue();
    public abstract virtual string get_Value();
    public abstract virtual bool get_ValueAsBoolean();
    public abstract virtual DateTime get_ValueAsDateTime();
    public abstract virtual double get_ValueAsDouble();
    public abstract virtual int get_ValueAsInt();
    public abstract virtual long get_ValueAsLong();
    public abstract virtual Type get_ValueType();
    public abstract virtual XmlSchemaType get_XmlType();
    public virtual object ValueAs(Type returnType);
    public abstract virtual object ValueAs(Type returnType, IXmlNamespaceResolver nsResolver);
}
public enum System.Xml.XPath.XPathNamespaceScope : Enum {
    public int value__;
    public static XPathNamespaceScope All;
    public static XPathNamespaceScope ExcludeXml;
    public static XPathNamespaceScope Local;
}
public abstract class System.Xml.XPath.XPathNavigator : XPathItem {
    public string BaseURI { get; }
    public bool CanEdit { get; }
    public bool HasAttributes { get; }
    public bool HasChildren { get; }
    public string InnerXml { get; public set; }
    public bool IsEmptyElement { get; }
    public bool IsNode { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public static IEqualityComparer NavigatorComparer { get; }
    public XPathNodeType NodeType { get; }
    public string OuterXml { get; public set; }
    public string Prefix { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public object TypedValue { get; }
    public object UnderlyingObject { get; }
    public bool ValueAsBoolean { get; }
    public DateTime ValueAsDateTime { get; }
    public double ValueAsDouble { get; }
    public int ValueAsInt { get; }
    public long ValueAsLong { get; }
    public Type ValueType { get; }
    public string XmlLang { get; }
    public XmlSchemaType XmlType { get; }
    public abstract virtual string get_BaseURI();
    public virtual bool get_CanEdit();
    public virtual bool get_HasAttributes();
    public virtual bool get_HasChildren();
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public abstract virtual bool get_IsEmptyElement();
    public sealed virtual bool get_IsNode();
    public abstract virtual string get_LocalName();
    public abstract virtual string get_Name();
    public abstract virtual string get_NamespaceURI();
    public abstract virtual XmlNameTable get_NameTable();
    public static IEqualityComparer get_NavigatorComparer();
    public abstract virtual XPathNodeType get_NodeType();
    public virtual string get_OuterXml();
    public virtual void set_OuterXml(string value);
    public abstract virtual string get_Prefix();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual object get_TypedValue();
    public virtual object get_UnderlyingObject();
    public virtual bool get_ValueAsBoolean();
    public virtual DateTime get_ValueAsDateTime();
    public virtual double get_ValueAsDouble();
    public virtual int get_ValueAsInt();
    public virtual long get_ValueAsLong();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSchemaType get_XmlType();
    public virtual XmlWriter AppendChild();
    public virtual void AppendChild(string newChild);
    public virtual void AppendChild(XmlReader newChild);
    public virtual void AppendChild(XPathNavigator newChild);
    public virtual void AppendChildElement(string prefix, string localName, string namespaceURI, string value);
    public virtual bool CheckValidity(XmlSchemaSet schemas, ValidationEventHandler validationEventHandler);
    public abstract virtual XPathNavigator Clone();
    public virtual XmlNodeOrder ComparePosition(XPathNavigator nav);
    public virtual XPathExpression Compile(string xpath);
    public virtual void CreateAttribute(string prefix, string localName, string namespaceURI, string value);
    public virtual XmlWriter CreateAttributes();
    public virtual XPathNavigator CreateNavigator();
    public virtual void DeleteRange(XPathNavigator lastSiblingToDelete);
    public virtual void DeleteSelf();
    public virtual object Evaluate(string xpath);
    public virtual object Evaluate(string xpath, IXmlNamespaceResolver resolver);
    public virtual object Evaluate(XPathExpression expr);
    public virtual object Evaluate(XPathExpression expr, XPathNodeIterator context);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual string GetNamespace(string name);
    public virtual IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    public virtual XmlWriter InsertAfter();
    public virtual void InsertAfter(string newSibling);
    public virtual void InsertAfter(XmlReader newSibling);
    public virtual void InsertAfter(XPathNavigator newSibling);
    public virtual XmlWriter InsertBefore();
    public virtual void InsertBefore(string newSibling);
    public virtual void InsertBefore(XmlReader newSibling);
    public virtual void InsertBefore(XPathNavigator newSibling);
    public virtual void InsertElementAfter(string prefix, string localName, string namespaceURI, string value);
    public virtual void InsertElementBefore(string prefix, string localName, string namespaceURI, string value);
    public virtual bool IsDescendant(XPathNavigator nav);
    public abstract virtual bool IsSamePosition(XPathNavigator other);
    public virtual string LookupNamespace(string prefix);
    public virtual string LookupPrefix(string namespaceURI);
    public virtual bool Matches(string xpath);
    public virtual bool Matches(XPathExpression expr);
    public abstract virtual bool MoveTo(XPathNavigator other);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToChild(string localName, string namespaceURI);
    public virtual bool MoveToChild(XPathNodeType type);
    public virtual bool MoveToFirst();
    public abstract virtual bool MoveToFirstAttribute();
    public abstract virtual bool MoveToFirstChild();
    public bool MoveToFirstNamespace();
    public abstract virtual bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToFollowing(string localName, string namespaceURI);
    public virtual bool MoveToFollowing(string localName, string namespaceURI, XPathNavigator end);
    public virtual bool MoveToFollowing(XPathNodeType type);
    public virtual bool MoveToFollowing(XPathNodeType type, XPathNavigator end);
    public abstract virtual bool MoveToId(string id);
    public virtual bool MoveToNamespace(string name);
    public abstract virtual bool MoveToNext();
    public virtual bool MoveToNext(string localName, string namespaceURI);
    public virtual bool MoveToNext(XPathNodeType type);
    public abstract virtual bool MoveToNextAttribute();
    public bool MoveToNextNamespace();
    public abstract virtual bool MoveToNextNamespace(XPathNamespaceScope namespaceScope);
    public abstract virtual bool MoveToParent();
    public abstract virtual bool MoveToPrevious();
    public virtual void MoveToRoot();
    public virtual XmlWriter PrependChild();
    public virtual void PrependChild(string newChild);
    public virtual void PrependChild(XmlReader newChild);
    public virtual void PrependChild(XPathNavigator newChild);
    public virtual void PrependChildElement(string prefix, string localName, string namespaceURI, string value);
    public virtual XmlReader ReadSubtree();
    public virtual XmlWriter ReplaceRange(XPathNavigator lastSiblingToReplace);
    public virtual void ReplaceSelf(string newNode);
    public virtual void ReplaceSelf(XmlReader newNode);
    public virtual void ReplaceSelf(XPathNavigator newNode);
    public virtual XPathNodeIterator Select(string xpath);
    public virtual XPathNodeIterator Select(string xpath, IXmlNamespaceResolver resolver);
    public virtual XPathNodeIterator Select(XPathExpression expr);
    public virtual XPathNodeIterator SelectAncestors(string name, string namespaceURI, bool matchSelf);
    public virtual XPathNodeIterator SelectAncestors(XPathNodeType type, bool matchSelf);
    public virtual XPathNodeIterator SelectChildren(string name, string namespaceURI);
    public virtual XPathNodeIterator SelectChildren(XPathNodeType type);
    public virtual XPathNodeIterator SelectDescendants(string name, string namespaceURI, bool matchSelf);
    public virtual XPathNodeIterator SelectDescendants(XPathNodeType type, bool matchSelf);
    public virtual XPathNavigator SelectSingleNode(string xpath);
    public virtual XPathNavigator SelectSingleNode(string xpath, IXmlNamespaceResolver resolver);
    public virtual XPathNavigator SelectSingleNode(XPathExpression expression);
    public virtual void SetTypedValue(object typedValue);
    public virtual void SetValue(string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
    public virtual object ValueAs(Type returnType, IXmlNamespaceResolver nsResolver);
    public virtual void WriteSubtree(XmlWriter writer);
}
public abstract class System.Xml.XPath.XPathNodeIterator : object {
    public int Count { get; }
    public XPathNavigator Current { get; }
    public int CurrentPosition { get; }
    public virtual int get_Count();
    public abstract virtual XPathNavigator get_Current();
    public abstract virtual int get_CurrentPosition();
    public abstract virtual XPathNodeIterator Clone();
    public virtual IEnumerator GetEnumerator();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.ICloneable.Clone();
}
public enum System.Xml.XPath.XPathNodeType : Enum {
    public int value__;
    public static XPathNodeType All;
    public static XPathNodeType Attribute;
    public static XPathNodeType Comment;
    public static XPathNodeType Element;
    public static XPathNodeType Namespace;
    public static XPathNodeType ProcessingInstruction;
    public static XPathNodeType Root;
    public static XPathNodeType SignificantWhitespace;
    public static XPathNodeType Text;
    public static XPathNodeType Whitespace;
}
public enum System.Xml.XPath.XPathResultType : Enum {
    public int value__;
    public static XPathResultType Any;
    public static XPathResultType Boolean;
    public static XPathResultType Error;
    public static XPathResultType Navigator;
    public static XPathResultType NodeSet;
    public static XPathResultType Number;
    public static XPathResultType String;
}
public interface System.Xml.Xsl.IXsltContextFunction {
    public XPathResultType[] ArgTypes { get; }
    public int Maxargs { get; }
    public int Minargs { get; }
    public XPathResultType ReturnType { get; }
    public abstract virtual XPathResultType[] get_ArgTypes();
    public abstract virtual int get_Maxargs();
    public abstract virtual int get_Minargs();
    public abstract virtual XPathResultType get_ReturnType();
    public abstract virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
public interface System.Xml.Xsl.IXsltContextVariable {
    public bool IsLocal { get; }
    public bool IsParam { get; }
    public XPathResultType VariableType { get; }
    public abstract virtual bool get_IsLocal();
    public abstract virtual bool get_IsParam();
    public abstract virtual XPathResultType get_VariableType();
    public abstract virtual object Evaluate(XsltContext xsltContext);
}
public class System.Xml.Xsl.XslCompiledTransform : object {
    public XmlWriterSettings OutputSettings { get; }
    public XslCompiledTransform(bool enableDebug);
    public XmlWriterSettings get_OutputSettings();
    public void Load(MethodInfo executeMethod, Byte[] queryData, Type[] earlyBoundTypes);
    public void Load(string stylesheetUri);
    public void Load(string stylesheetUri, XsltSettings settings, XmlResolver stylesheetResolver);
    public void Load(Type compiledStylesheet);
    public void Load(XmlReader stylesheet);
    public void Load(XmlReader stylesheet, XsltSettings settings, XmlResolver stylesheetResolver);
    public void Load(IXPathNavigable stylesheet);
    public void Load(IXPathNavigable stylesheet, XsltSettings settings, XmlResolver stylesheetResolver);
    public void Transform(string inputUri, string resultsFile);
    public void Transform(string inputUri, XmlWriter results);
    public void Transform(string inputUri, XsltArgumentList arguments, Stream results);
    public void Transform(string inputUri, XsltArgumentList arguments, TextWriter results);
    public void Transform(string inputUri, XsltArgumentList arguments, XmlWriter results);
    public void Transform(XmlReader input, XmlWriter results);
    public void Transform(XmlReader input, XsltArgumentList arguments, Stream results);
    public void Transform(XmlReader input, XsltArgumentList arguments, TextWriter results);
    public void Transform(XmlReader input, XsltArgumentList arguments, XmlWriter results);
    public void Transform(XmlReader input, XsltArgumentList arguments, XmlWriter results, XmlResolver documentResolver);
    public void Transform(IXPathNavigable input, XmlWriter results);
    public void Transform(IXPathNavigable input, XsltArgumentList arguments, Stream results);
    public void Transform(IXPathNavigable input, XsltArgumentList arguments, TextWriter results);
    public void Transform(IXPathNavigable input, XsltArgumentList arguments, XmlWriter results);
    public void Transform(IXPathNavigable input, XsltArgumentList arguments, XmlWriter results, XmlResolver documentResolver);
}
public class System.Xml.Xsl.XsltArgumentList : object {
    public void add_XsltMessageEncountered(XsltMessageEncounteredEventHandler value);
    public void remove_XsltMessageEncountered(XsltMessageEncounteredEventHandler value);
    public void AddExtensionObject(string namespaceUri, object extension);
    public void AddParam(string name, string namespaceUri, object parameter);
    public void Clear();
    public object GetExtensionObject(string namespaceUri);
    public object GetParam(string name, string namespaceUri);
    public object RemoveExtensionObject(string namespaceUri);
    public object RemoveParam(string name, string namespaceUri);
}
public class System.Xml.Xsl.XsltCompileException : XsltException {
    public XsltCompileException(Exception inner, string sourceUri, int lineNumber, int linePosition);
    protected XsltCompileException(SerializationInfo info, StreamingContext context);
    public XsltCompileException(string message);
    public XsltCompileException(string message, Exception innerException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.Xml.Xsl.XsltContext : XmlNamespaceManager {
    public bool Whitespace { get; }
    protected XsltContext(NameTable table);
    public abstract virtual bool get_Whitespace();
    public abstract virtual int CompareDocument(string baseUri, string nextbaseUri);
    public abstract virtual bool PreserveWhitespace(XPathNavigator node);
    public abstract virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] ArgTypes);
    public abstract virtual IXsltContextVariable ResolveVariable(string prefix, string name);
}
public class System.Xml.Xsl.XsltException : SystemException {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Message { get; }
    public string SourceUri { get; }
    protected XsltException(SerializationInfo info, StreamingContext context);
    public XsltException(string message);
    public XsltException(string message, Exception innerException);
    public virtual int get_LineNumber();
    public virtual int get_LinePosition();
    public virtual string get_Message();
    public virtual string get_SourceUri();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.Xml.Xsl.XsltMessageEncounteredEventArgs : EventArgs {
    public string Message { get; }
    public abstract virtual string get_Message();
}
public class System.Xml.Xsl.XsltMessageEncounteredEventHandler : MulticastDelegate {
    public XsltMessageEncounteredEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, XsltMessageEncounteredEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, XsltMessageEncounteredEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Xml.Xsl.XslTransform : object {
    unknown XmlResolver XmlResolver {public set; }
    public void set_XmlResolver(XmlResolver value);
    public void Load(string url);
    public void Load(string url, XmlResolver resolver);
    public void Load(XmlReader stylesheet);
    public void Load(XmlReader stylesheet, XmlResolver resolver);
    public void Load(IXPathNavigable stylesheet);
    public void Load(IXPathNavigable stylesheet, XmlResolver resolver);
    public void Load(XPathNavigator stylesheet);
    public void Load(XPathNavigator stylesheet, XmlResolver resolver);
    public void Transform(string inputfile, string outputfile);
    public void Transform(string inputfile, string outputfile, XmlResolver resolver);
    public XmlReader Transform(IXPathNavigable input, XsltArgumentList args);
    public void Transform(IXPathNavigable input, XsltArgumentList args, Stream output);
    public void Transform(IXPathNavigable input, XsltArgumentList args, Stream output, XmlResolver resolver);
    public void Transform(IXPathNavigable input, XsltArgumentList args, TextWriter output);
    public void Transform(IXPathNavigable input, XsltArgumentList args, TextWriter output, XmlResolver resolver);
    public XmlReader Transform(IXPathNavigable input, XsltArgumentList args, XmlResolver resolver);
    public void Transform(IXPathNavigable input, XsltArgumentList args, XmlWriter output);
    public void Transform(IXPathNavigable input, XsltArgumentList args, XmlWriter output, XmlResolver resolver);
    public XmlReader Transform(XPathNavigator input, XsltArgumentList args);
    public void Transform(XPathNavigator input, XsltArgumentList args, Stream output);
    public void Transform(XPathNavigator input, XsltArgumentList args, Stream output, XmlResolver resolver);
    public void Transform(XPathNavigator input, XsltArgumentList args, TextWriter output);
    public void Transform(XPathNavigator input, XsltArgumentList args, TextWriter output, XmlResolver resolver);
    public XmlReader Transform(XPathNavigator input, XsltArgumentList args, XmlResolver resolver);
    public void Transform(XPathNavigator input, XsltArgumentList args, XmlWriter output);
    public void Transform(XPathNavigator input, XsltArgumentList args, XmlWriter output, XmlResolver resolver);
}
public class System.Xml.Xsl.XsltSettings : object {
    public static XsltSettings Default { get; }
    public bool EnableDocumentFunction { get; public set; }
    public bool EnableScript { get; public set; }
    public static XsltSettings TrustedXslt { get; }
    public XsltSettings(bool enableDocumentFunction, bool enableScript);
    public static XsltSettings get_Default();
    public bool get_EnableDocumentFunction();
    public void set_EnableDocumentFunction(bool value);
    public bool get_EnableScript();
    public void set_EnableScript(bool value);
    public static XsltSettings get_TrustedXslt();
}
