internal static class Consts : object {
    public static string PublicKeyToken;
}
public class GeoAPI.NetTopologySuiteBootstrapper : object {
    public static void Bootstrap();
}
public static class NetTopologySuite.Algorithm.AngleUtility : object {
    public static double PiTimes2;
    public static double PiOver2;
    public static double PiOver4;
    public static double ToDegrees(double radians);
    public static double ToRadians(double angleDegrees);
    public static double Angle(Coordinate p0, Coordinate p1);
    public static double Angle(Coordinate p);
    public static bool IsAcute(Coordinate p0, Coordinate p1, Coordinate p2);
    public static bool IsObtuse(Coordinate p0, Coordinate p1, Coordinate p2);
    public static double AngleBetween(Coordinate tip1, Coordinate tail, Coordinate tip2);
    public static double AngleBetweenOriented(Coordinate tip1, Coordinate tail, Coordinate tip2);
    public static double InteriorAngle(Coordinate p0, Coordinate p1, Coordinate p2);
    public static OrientationIndex GetTurn(double ang1, double ang2);
    public static double Normalize(double angle);
    public static double NormalizePositive(double angle);
    public static double Diff(double ang1, double ang2);
}
public static class NetTopologySuite.Algorithm.Area : object {
    public static double OfRing(Coordinate[] ring);
    public static double OfRing(ICoordinateSequence ring);
    public static double OfRingSigned(Coordinate[] ring);
    public static double OfRingSigned(ICoordinateSequence ring);
}
public static class NetTopologySuite.Algorithm.BoundaryNodeRules : object {
    public static IBoundaryNodeRule Mod2BoundaryRule;
    public static IBoundaryNodeRule EndpointBoundaryRule;
    public static IBoundaryNodeRule MultivalentEndpointBoundaryRule;
    public static IBoundaryNodeRule MonoValentEndpointBoundaryRule;
    public static IBoundaryNodeRule OgcSfsBoundaryRule;
    private static BoundaryNodeRules();
}
public class NetTopologySuite.Algorithm.Centroid : object {
    private Coordinate _areaBasePt;
    private Coordinate _triangleCent3;
    private double _areasum2;
    private Coordinate _cg3;
    private Coordinate _lineCentSum;
    private double _totalLength;
    private int _ptCount;
    private Coordinate _ptCentSum;
    public Centroid(IGeometry geom);
    public static Coordinate GetCentroid(IGeometry geom);
    private void Add(IGeometry geom);
    public Coordinate GetCentroid();
    private void SetAreaBasePoint(Coordinate basePt);
    private void Add(IPolygon poly);
    private void AddShell(Coordinate[] pts);
    private void AddHole(Coordinate[] pts);
    private void AddTriangle(Coordinate p0, Coordinate p1, Coordinate p2, bool isPositiveArea);
    private static void Centroid3(Coordinate p1, Coordinate p2, Coordinate p3, Coordinate c);
    private static double Area2(Coordinate p1, Coordinate p2, Coordinate p3);
    private void AddLineSegments(Coordinate[] pts);
    private void AddPoint(Coordinate pt);
}
[ObsoleteAttribute("Use Centroid instead")]
public class NetTopologySuite.Algorithm.CentroidArea : object {
    private Coordinate _basePt;
    private Coordinate _triangleCent3;
    private double _areasum2;
    private Coordinate _cg3;
    private Coordinate _centSum;
    private double _totalLength;
    public Coordinate Centroid { get; }
    unknown Coordinate BasePoint {private set; }
    public void Add(IGeometry geom);
    public void Add(Coordinate[] ring);
    public Coordinate get_Centroid();
    private void set_BasePoint(Coordinate value);
    private void Add(IPolygon poly);
    private void AddShell(Coordinate[] pts);
    private void AddHole(Coordinate[] pts);
    private void AddTriangle(Coordinate p0, Coordinate p1, Coordinate p2, bool isPositiveArea);
    private static void Centroid3(Coordinate p1, Coordinate p2, Coordinate p3, Coordinate& c);
    private static double Area2(Coordinate p1, Coordinate p2, Coordinate p3);
    private void AddLinearSegments(Coordinate[] pts);
}
[ObsoleteAttribute("Use Centroid instead")]
public class NetTopologySuite.Algorithm.CentroidLine : object {
    private Coordinate _centSum;
    private double _totalLength;
    public Coordinate Centroid { get; }
    public void Add(IGeometry geom);
    public Coordinate get_Centroid();
    public void Add(Coordinate[] pts);
}
[ObsoleteAttribute("Use Centroid instead")]
public class NetTopologySuite.Algorithm.CentroidPoint : object {
    private int _ptCount;
    private Coordinate _centSum;
    public Coordinate Centroid { get; }
    public void Add(IGeometry geom);
    public void Add(Coordinate pt);
    public Coordinate get_Centroid();
}
[ObsoleteAttribute("Functionality has been split into Area, Length, Orientation, PointLocation and DistanceComputer classes")]
public static class NetTopologySuite.Algorithm.CGAlgorithms : object {
    public static int Clockwise;
    public static int Right;
    public static int CounterClockwise;
    public static int Left;
    public static int Collinear;
    public static int Straight;
    [ObsoleteAttribute("Use Orientation.Index")]
public static int OrientationIndex(Coordinate p1, Coordinate p2, Coordinate q);
    [ObsoleteAttribute("Use PointLocation.IsInRing")]
public static bool IsPointInRing(Coordinate p, Coordinate[] ring);
    [ObsoleteAttribute("Use PointLocation.IsInRing")]
public static bool IsPointInRing(Coordinate p, ICoordinateSequence ring);
    [ObsoleteAttribute("Use PointLocation.LocateInRing")]
public static Location LocatePointInRing(Coordinate p, Coordinate[] ring);
    [ObsoleteAttribute("Use PointLocation.LocateInRing")]
public static Location LocatePointInRing(Coordinate p, ICoordinateSequence ring);
    [ObsoleteAttribute("Use PointLocation.IsOnLine")]
public static bool IsOnLine(Coordinate p, Coordinate[] pt);
    [ObsoleteAttribute("Use Orientation.IsCCW")]
public static bool IsCCW(Coordinate[] ring);
    [ObsoleteAttribute("Use Orientation.IsCCW")]
public static bool IsCCW(ICoordinateSequence ring);
    [ObsoleteAttribute("Use Orientation.Index")]
public static int ComputeOrientation(Coordinate p1, Coordinate p2, Coordinate q);
    [ObsoleteAttribute("Use DistanceComputer.PointToSegment")]
public static double DistancePointLine(Coordinate p, Coordinate A, Coordinate B);
    [ObsoleteAttribute("Use DistanceComputer.PointToLinePerpendicular")]
public static double DistancePointLinePerpendicular(Coordinate p, Coordinate A, Coordinate B);
    [ObsoleteAttribute("Use DistanceComputer.PointToSegmentString")]
public static double DistancePointLine(Coordinate p, Coordinate[] line);
    [ObsoleteAttribute("Use DistanceComputer.SegmentToSegment")]
public static double DistanceLineLine(Coordinate A, Coordinate B, Coordinate C, Coordinate D);
    [ObsoleteAttribute("Use Area.OfRingSigned")]
public static double SignedArea(Coordinate[] ring);
    [ObsoleteAttribute("Use Area.OfRingSigned")]
public static double SignedArea(ICoordinateSequence ring);
    [ObsoleteAttribute("Use Length.OfLine")]
public static double Length(ICoordinateSequence pts);
}
public static class NetTopologySuite.Algorithm.CGAlgorithms3D : object {
    public static double Distance(Coordinate p0, Coordinate p1);
    public static double DistancePointSegment(Coordinate p, Coordinate A, Coordinate B);
    public static double DistanceSegmentSegment(Coordinate A, Coordinate B, Coordinate C, Coordinate D);
}
public static class NetTopologySuite.Algorithm.CGAlgorithmsDD : object {
    private static double DoublePrecisionSafeEpsilon;
    public static int OrientationIndex(Coordinate p1, Coordinate p2, Coordinate q);
    public static int SignOfDet2x2(DD x1, DD y1, DD x2, DD y2);
    private static int OrientationIndexFilter(Coordinate pa, Coordinate pb, Coordinate pc);
    private static int Signum(double x);
    public static Coordinate Intersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
}
public class NetTopologySuite.Algorithm.ConvexHull : object {
    private IGeometryFactory _geomFactory;
    private Coordinate[] _inputPts;
    public ConvexHull(IGeometry geometry);
    public ConvexHull(Coordinate[] pts, IGeometryFactory geomFactory);
    private static Coordinate[] ExtractCoordinates(IGeometry geom);
    public IGeometry GetConvexHull();
    private static Coordinate[] Reduce(Coordinate[] pts);
    private static Coordinate[] PadArray3(Coordinate[] pts);
    private static Coordinate[] PreSort(Coordinate[] pts);
    private static Stack`1<Coordinate> GrahamScan(Coordinate[] c);
    private static bool IsBetween(Coordinate c1, Coordinate c2, Coordinate c3);
    private static Coordinate[] ComputeOctRing(Coordinate[] inputPts);
    private static Coordinate[] ComputeOctPts(Coordinate[] inputPts);
    private IGeometry LineOrPolygon(Coordinate[] coordinates);
    private static Coordinate[] CleanRing(Coordinate[] original);
}
public class NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance : object {
    private IGeometry _g0;
    private IGeometry _g1;
    private PointPairDistance _ptDist;
    private double _densifyFrac;
    public double DensifyFraction { get; public set; }
    public Coordinate[] Coordinates { get; }
    public DiscreteHausdorffDistance(IGeometry g0, IGeometry g1);
    public static double Distance(IGeometry g0, IGeometry g1);
    public static double Distance(IGeometry g0, IGeometry g1, double densifyFraction);
    public double get_DensifyFraction();
    public void set_DensifyFraction(double value);
    public double Distance();
    public double OrientedDistance();
    public Coordinate[] get_Coordinates();
    private void Compute(IGeometry g0, IGeometry g1);
    private void ComputeOrientedDistance(IGeometry discreteGeom, IGeometry geom, PointPairDistance ptDist);
}
public static class NetTopologySuite.Algorithm.Distance.DistanceToPoint : object {
    public static void ComputeDistance(IGeometry geom, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(ILineString line, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(LineSegment segment, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(IPolygon poly, Coordinate pt, PointPairDistance ptDist);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Algorithm.Distance.PointPairDistance : object {
    private Coordinate[] _pt;
    private double _distance;
    private bool _isNull;
    public double Distance { get; }
    public Coordinate[] Coordinates { get; }
    public Coordinate Item { get; }
    public void Initialize();
    public void Initialize(Coordinate p0, Coordinate p1);
    private void Initialize(Coordinate p0, Coordinate p1, double distance);
    public double get_Distance();
    public Coordinate[] get_Coordinates();
    public Coordinate get_Item(int i);
    public void SetMaximum(PointPairDistance ptDist);
    public void SetMaximum(Coordinate p0, Coordinate p1);
    public void SetMinimum(PointPairDistance ptDist);
    public void SetMinimum(Coordinate p0, Coordinate p1);
    public virtual string ToString();
}
public static class NetTopologySuite.Algorithm.DistanceComputer : object {
    public static double SegmentToSegment(Coordinate A, Coordinate B, Coordinate C, Coordinate D);
    public static double PointToSegmentString(Coordinate p, Coordinate[] line);
    public static double PointToSegmentString(Coordinate p, ICoordinateSequence line);
    public static double PointToSegment(Coordinate p, Coordinate A, Coordinate B);
    public static double PointToLinePerpendicular(Coordinate p, Coordinate A, Coordinate B);
}
public class NetTopologySuite.Algorithm.HCoordinate : object {
    private double _x;
    private double _y;
    private double _w;
    [ObsoleteAttribute("This is a simple access to x private field: use GetX() instead.")]
protected double X { get; protected set; }
    [ObsoleteAttribute("This is a simple access to y private field: use GetY() instead.")]
protected double Y { get; protected set; }
    [ObsoleteAttribute("This is a simple access to w private field: how do you use this field for?...")]
protected double W { get; protected set; }
    public Coordinate Coordinate { get; }
    public HCoordinate(double x, double y, double w);
    public HCoordinate(Coordinate p);
    public HCoordinate(HCoordinate p1, HCoordinate p2);
    public HCoordinate(Coordinate p1, Coordinate p2);
    public HCoordinate(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public static Coordinate Intersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public static Coordinate OldIntersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    protected double get_X();
    protected void set_X(double value);
    protected double get_Y();
    protected void set_Y(double value);
    protected double get_W();
    protected void set_W(double value);
    public double GetX();
    public double GetY();
    public Coordinate get_Coordinate();
}
public interface NetTopologySuite.Algorithm.IBoundaryNodeRule {
    public abstract virtual bool IsInBoundary(int boundaryCount);
}
public class NetTopologySuite.Algorithm.InteriorPointArea : object {
    private IGeometryFactory _factory;
    private Coordinate _interiorPoint;
    private double _maxWidth;
    public Coordinate InteriorPoint { get; }
    public InteriorPointArea(IGeometry g);
    private static double Avg(double a, double b);
    public Coordinate get_InteriorPoint();
    private void Add(IGeometry geom);
    private void AddPolygon(IGeometry geometry);
    private static IGeometry WidestGeometry(IGeometry geometry);
    private static IGeometry WidestGeometry(IGeometryCollection gc);
    protected ILineString HorizontalBisector(IGeometry geometry);
    public static Coordinate Centre(Envelope envelope);
}
public class NetTopologySuite.Algorithm.InteriorPointLine : object {
    private Coordinate _centroid;
    private double _minDistance;
    private Coordinate _interiorPoint;
    public Coordinate InteriorPoint { get; }
    public InteriorPointLine(IGeometry g);
    public Coordinate get_InteriorPoint();
    private void AddInterior(IGeometry geom);
    private void AddInterior(Coordinate[] pts);
    private void AddEndpoints(IGeometry geom);
    private void AddEndpoints(Coordinate[] pts);
    private void Add(Coordinate point);
}
public class NetTopologySuite.Algorithm.InteriorPointPoint : object {
    private Coordinate _centroid;
    private double _minDistance;
    private Coordinate _interiorPoint;
    public Coordinate InteriorPoint { get; }
    public InteriorPointPoint(IGeometry g);
    private void Add(IGeometry geom);
    private void Add(Coordinate point);
    public Coordinate get_InteriorPoint();
}
public interface NetTopologySuite.Algorithm.IPointInAreaLocator {
    public abstract virtual Location Locate(Coordinate p);
}
public class NetTopologySuite.Algorithm.Length : object {
    public static double OfLine(ICoordinateSequence pts);
}
public abstract class NetTopologySuite.Algorithm.LineIntersector : object {
    [ObsoleteAttribute("Ambiguous naming, use NoIntersection")]
public static int DontIntersect;
    [ObsoleteAttribute("Ambiguous naming, use PointIntersection")]
public static int DoIntersect;
    [ObsoleteAttribute("Ambiguous naming, use CollinearIntersection")]
public static int Collinear;
    public static int NoIntersection;
    public static int PointIntersection;
    public static int CollinearIntersection;
    protected int Result;
    protected Coordinate[][] InputLines;
    protected Coordinate[] IntersectionPoint;
    protected Int32[] IntersectionLineIndex;
    private bool _isProper;
    private IPrecisionModel _precisionModel;
    protected Coordinate Pa { get; }
    protected Coordinate Pb { get; }
    [ObsoleteAttribute("Use PrecisionModel instead")]
unknown IPrecisionModel MakePrecise {public set; }
    public IPrecisionModel PrecisionModel { get; public set; }
    protected bool IsCollinear { get; }
    protected bool IsEndPoint { get; }
    public bool HasIntersection { get; }
    public int IntersectionNum { get; }
    public bool IsProper { get; protected set; }
    public static double ComputeEdgeDistance(Coordinate p, Coordinate p0, Coordinate p1);
    public static double NonRobustComputeEdgeDistance(Coordinate p, Coordinate p1, Coordinate p2);
    protected Coordinate get_Pa();
    protected Coordinate get_Pb();
    public void set_MakePrecise(IPrecisionModel value);
    public IPrecisionModel get_PrecisionModel();
    public void set_PrecisionModel(IPrecisionModel value);
    public Coordinate GetEndpoint(int segmentIndex, int ptIndex);
    public abstract virtual void ComputeIntersection(Coordinate p, Coordinate p1, Coordinate p2);
    protected bool get_IsCollinear();
    public void ComputeIntersection(Coordinate p1, Coordinate p2, Coordinate p3, Coordinate p4);
    public abstract virtual int ComputeIntersect(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public virtual string ToString();
    protected bool get_IsEndPoint();
    public bool get_HasIntersection();
    public int get_IntersectionNum();
    public Coordinate GetIntersection(int intIndex);
    protected void ComputeIntLineIndex();
    public bool IsIntersection(Coordinate pt);
    public bool IsInteriorIntersection();
    public bool IsInteriorIntersection(int inputLineIndex);
    public bool get_IsProper();
    protected void set_IsProper(bool value);
    public Coordinate GetIntersectionAlongSegment(int segmentIndex, int intIndex);
    public int GetIndexAlongSegment(int segmentIndex, int intIndex);
    protected void ComputeIntLineIndex(int segmentIndex);
    public double GetEdgeDistance(int segmentIndex, int intIndex);
}
public class NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator : object {
    private IntervalIndexedGeometry _index;
    public IndexedPointInAreaLocator(IGeometry g);
    public sealed virtual Location Locate(Coordinate p);
}
public interface NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator {
    public abstract virtual Location Locate(Coordinate p);
}
public static class NetTopologySuite.Algorithm.Locate.PointOnGeometryLocatorExtensions : object {
    public static bool Intersects(IPointOnGeometryLocator locator, Coordinate coordinate);
}
public class NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator : object {
    private IGeometry _geom;
    public SimplePointInAreaLocator(IGeometry geom);
    public static Location Locate(Coordinate p, IGeometry geom);
    private static Location LocateInGeometry(Coordinate p, IGeometry geom);
    public static Location LocatePointInPolygon(Coordinate p, IPolygon poly);
    public static bool ContainsPointInPolygon(Coordinate p, IPolygon poly);
    private static Location LocatePointInRing(Coordinate p, ILinearRing ring);
    public sealed virtual Location Locate(Coordinate p);
}
public class NetTopologySuite.Algorithm.Match.AreaSimilarityMeasure : object {
    public sealed virtual double Measure(IGeometry g1, IGeometry g2);
}
public class NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure : object {
    private static double DensifyFraction;
    private static HausdorffSimilarityMeasure();
    public sealed virtual double Measure(IGeometry g1, IGeometry g2);
    public static double DiagonalSize(Envelope env);
}
public interface NetTopologySuite.Algorithm.Match.ISimilarityMeasure {
    public abstract virtual double Measure(IGeometry g1, IGeometry g2);
}
public static class NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner : object {
    public static double Combine(double measure1, double measure2);
}
public class NetTopologySuite.Algorithm.MinimumBoundingCircle : object {
    private IGeometry _input;
    private Coordinate[] _extremalPts;
    private Coordinate _centre;
    private double _radius;
    public MinimumBoundingCircle(IGeometry geom);
    public IGeometry GetCircle();
    public IGeometry GetFarthestPoints();
    public IGeometry GetDiameter();
    public Coordinate[] GetExtremalPoints();
    public Coordinate GetCentre();
    public double GetRadius();
    private void ComputeCentre();
    private void Compute();
    private void ComputeCirclePoints();
    private static Coordinate LowestPoint(Coordinate[] pts);
    private static Coordinate PointWitMinAngleWithX(Coordinate[] pts, Coordinate P);
    private static Coordinate PointWithMinAngleWithSegment(Coordinate[] pts, Coordinate P, Coordinate Q);
}
public class NetTopologySuite.Algorithm.MinimumDiameter : object {
    private IGeometry _inputGeom;
    private bool _isConvex;
    private Coordinate[] _convexHullPts;
    private LineSegment _minBaseSeg;
    private Coordinate _minWidthPt;
    private int _minPtIndex;
    private double _minWidth;
    public double Length { get; }
    public Coordinate WidthCoordinate { get; }
    public ILineString SupportingSegment { get; }
    public ILineString Diameter { get; }
    public MinimumDiameter(IGeometry inputGeom);
    public MinimumDiameter(IGeometry inputGeom, bool isConvex);
    public static IGeometry GetMinimumRectangle(IGeometry geom);
    public static IGeometry GetMinimumDiameter(Geometry geom);
    public double get_Length();
    public Coordinate get_WidthCoordinate();
    public ILineString get_SupportingSegment();
    public ILineString get_Diameter();
    private void ComputeMinimumDiameter();
    private void ComputeWidthConvex(IGeometry convexGeom);
    private void ComputeConvexRingMinDiameter(Coordinate[] pts);
    private int FindMaxPerpDistance(Coordinate[] pts, LineSegment seg, int startIndex);
    private static int NextIndex(Coordinate[] pts, int index);
    public IGeometry GetMinimumRectangle();
    private static double ComputeC(double a, double b, Coordinate p);
    private static LineSegment ComputeSegmentForLine(double a, double b, double c);
}
public class NetTopologySuite.Algorithm.NotRepresentableException : ApplicationException {
}
public static class NetTopologySuite.Algorithm.Orientation : object {
    public static OrientationIndex Index(Coordinate p1, Coordinate p2, Coordinate q);
    public static bool IsCCW(Coordinate[] ring);
    public static bool IsCCW(ICoordinateSequence ring);
    public static OrientationIndex ReOrient(OrientationIndex orientation);
}
public enum NetTopologySuite.Algorithm.OrientationIndex : Enum {
    public int value__;
    public static OrientationIndex Collinear;
    public static OrientationIndex None;
    public static OrientationIndex Straight;
    public static OrientationIndex CounterClockwise;
    public static OrientationIndex Left;
    public static OrientationIndex Clockwise;
    public static OrientationIndex Right;
}
public static class NetTopologySuite.Algorithm.PointLocation : object {
    public static bool IsOnLine(Coordinate p, Coordinate[] line);
    public static bool IsOnLine(Coordinate p, ICoordinateSequence line);
    public static bool IsInRing(Coordinate p, Coordinate[] ring);
    public static bool IsInRing(Coordinate p, ICoordinateSequence ring);
    public static Location LocateInRing(Coordinate p, Coordinate[] ring);
    public static Location LocateInRing(Coordinate p, ICoordinateSequence ring);
}
public class NetTopologySuite.Algorithm.PointLocator : object {
    private IBoundaryNodeRule _boundaryRule;
    private bool _isIn;
    private int _numBoundaries;
    public PointLocator(IBoundaryNodeRule boundaryRule);
    public bool Intersects(Coordinate p, IGeometry geom);
    public Location Locate(Coordinate p, IGeometry geom);
    private void ComputeLocation(Coordinate p, IGeometry geom);
    private void UpdateLocationInfo(Location loc);
    private static Location LocateOnPoint(Coordinate p, IPoint pt);
    private static Location LocateOnLineString(Coordinate p, ILineString l);
    private static Location LocateInPolygonRing(Coordinate p, ILinearRing ring);
    private Location LocateInPolygon(Coordinate p, IPolygon poly);
}
public class NetTopologySuite.Algorithm.RayCrossingCounter : object {
    private Coordinate _p;
    private int _crossingCount;
    private bool _isPointOnSegment;
    public bool IsOnSegment { get; }
    public Location Location { get; }
    public bool IsPointInPolygon { get; }
    public RayCrossingCounter(Coordinate p);
    public static Location LocatePointInRing(Coordinate p, Coordinate[] ring);
    public static Location LocatePointInRing(Coordinate p, ICoordinateSequence ring);
    public void CountSegment(Coordinate p1, Coordinate p2);
    public bool get_IsOnSegment();
    public Location get_Location();
    public bool get_IsPointInPolygon();
}
public class NetTopologySuite.Algorithm.RectangleLineIntersector : object {
    private LineIntersector _li;
    private Envelope _rectEnv;
    private Coordinate _diagUp0;
    private Coordinate _diagUp1;
    private Coordinate _diagDown0;
    private Coordinate _diagDown1;
    public RectangleLineIntersector(Envelope rectEnv);
    public bool Intersects(Coordinate p0, Coordinate p1);
}
public class NetTopologySuite.Algorithm.RobustDeterminant : object {
    public static int SignOfDet2x2(double x1, double y1, double x2, double y2);
    public static int OrientationIndex(Coordinate p1, Coordinate p2, Coordinate q);
}
public class NetTopologySuite.Algorithm.RobustLineIntersector : LineIntersector {
    public virtual void ComputeIntersection(Coordinate p, Coordinate p1, Coordinate p2);
    public virtual int ComputeIntersect(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private int ComputeCollinearIntersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private Coordinate Intersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private void CheckDD(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2, Coordinate intPt);
    private Coordinate IntersectionWithNormalization(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private static Coordinate SafeHCoordinateIntersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private void NormalizeToEnvCentre(Coordinate n00, Coordinate n01, Coordinate n10, Coordinate n11, Coordinate normPt);
    private bool IsInSegmentEnvelopes(Coordinate intPoint);
    private static Coordinate NearestEndpoint(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
}
public class NetTopologySuite.Densify.Densifier : object {
    private IGeometry _inputGeom;
    private double _distanceTolerance;
    public double DistanceTolerance { get; public set; }
    public Densifier(IGeometry inputGeom);
    public static IGeometry Densify(IGeometry geom, double distanceTolerance);
    private static Coordinate[] DensifyPoints(Coordinate[] pts, double distanceTolerance, IPrecisionModel precModel);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public IGeometry GetResultGeometry();
}
public class NetTopologySuite.Dissolve.DissolveEdgeGraph : EdgeGraph {
    protected virtual HalfEdge CreateEdge(Coordinate p0);
}
public class NetTopologySuite.Dissolve.DissolveHalfEdge : MarkHalfEdge {
    private bool _isStart;
    public bool IsStart { get; }
    public DissolveHalfEdge(Coordinate orig);
    public bool get_IsStart();
    public void SetStart();
}
public class NetTopologySuite.Dissolve.LineDissolver : object {
    private IGeometry _result;
    private IGeometryFactory _factory;
    private DissolveEdgeGraph _graph;
    private IList`1<IGeometry> _lines;
    private Stack`1<HalfEdge> _nodeEdgeStack;
    private DissolveHalfEdge _ringStartEdge;
    public static IGeometry Dissolve(IGeometry g);
    public void Add(IGeometry geometry);
    public void Add(IEnumerable`1<IGeometry> geometries);
    private void Add(ILineString lineString);
    public IGeometry GetResult();
    private void ComputeResult();
    private void Process(HalfEdge e);
    private void BuildLines();
    private void UpdateRingStartEdge(DissolveHalfEdge e);
    private void BuildLine(HalfEdge eStart);
    private void BuildRing(HalfEdge eStartRing);
    private void AddLine(CoordinateList line);
    private void StackEdges(HalfEdge node);
    [CompilerGeneratedAttribute]
private void <Add>b__6_0(IGeometry c);
}
public class NetTopologySuite.EdgeGraph.EdgeGraph : object {
    private IDictionary`2<Coordinate, HalfEdge> vertexMap;
    protected virtual HalfEdge CreateEdge(Coordinate orig);
    private HalfEdge Create(Coordinate p0, Coordinate p1);
    public virtual HalfEdge AddEdge(Coordinate orig, Coordinate dest);
    public static bool IsValidEdge(Coordinate orig, Coordinate dest);
    private HalfEdge Insert(Coordinate orig, Coordinate dest, HalfEdge eAdj);
    public IEnumerable`1<HalfEdge> GetVertexEdges();
    public HalfEdge FindEdge(Coordinate orig, Coordinate dest);
}
public class NetTopologySuite.EdgeGraph.EdgeGraphBuilder : object {
    private EdgeGraph graph;
    public static EdgeGraph Build(IEnumerable`1<IGeometry> geoms);
    public EdgeGraph GetGraph();
    public void Add(IGeometry geometry);
    public void Add(IEnumerable`1<IGeometry> geometries);
    private void Add(ILineString lineString);
    [CompilerGeneratedAttribute]
private void <Add>b__4_0(IGeometry c);
}
public class NetTopologySuite.EdgeGraph.HalfEdge : object {
    private Coordinate _orig;
    private HalfEdge _sym;
    private HalfEdge _next;
    public Coordinate Orig { get; }
    public Coordinate Dest { get; }
    public HalfEdge Sym { get; private set; }
    public HalfEdge Next { get; private set; }
    public HalfEdge Prev { get; }
    public HalfEdge ONext { get; }
    public double DeltaX { get; }
    public double DeltaY { get; }
    public HalfEdge(Coordinate orig);
    public static HalfEdge Create(Coordinate p0, Coordinate p1);
    public static HalfEdge Init(HalfEdge e0, HalfEdge e1);
    protected virtual void Init(HalfEdge e);
    public Coordinate get_Orig();
    public Coordinate get_Dest();
    public HalfEdge get_Sym();
    private void set_Sym(HalfEdge value);
    public HalfEdge get_Next();
    private void set_Next(HalfEdge value);
    public HalfEdge get_Prev();
    public HalfEdge get_ONext();
    public HalfEdge Find(Coordinate dest);
    public bool Equals(Coordinate p0, Coordinate p1);
    public void Insert(HalfEdge e);
    private void InsertAfter(HalfEdge e);
    public sealed virtual int CompareTo(HalfEdge e);
    public int CompareAngularDirection(HalfEdge e);
    public double get_DeltaX();
    public double get_DeltaY();
    public virtual string ToString();
    public int Degree();
    public HalfEdge PrevNode();
}
public class NetTopologySuite.EdgeGraph.MarkHalfEdge : HalfEdge {
    private bool _marked;
    public bool Marked { get; public set; }
    public MarkHalfEdge(Coordinate orig);
    public static bool IsMarked(HalfEdge e);
    public static void Mark(HalfEdge e);
    public static void SetMark(HalfEdge e, bool isMarked);
    public static void SetMarkBoth(HalfEdge e, bool isMarked);
    public static void MarkBoth(HalfEdge e);
    public void Mark();
    public bool get_Marked();
    public void set_Marked(bool value);
}
public static class NetTopologySuite.Geometries.CoordinateArrays : object {
    public static bool IsRing(Coordinate[] pts);
    public static Coordinate PointNotInList(Coordinate[] testPts, Coordinate[] pts);
    public static int Compare(Coordinate[] pts1, Coordinate[] pts2);
    public static int IncreasingDirection(Coordinate[] pts);
    private static bool IsEqualReversed(Coordinate[] pts1, Coordinate[] pts2);
    public static Coordinate[] CopyDeep(Coordinate[] coordinates);
    public static void CopyDeep(Coordinate[] src, int srcStart, Coordinate[] dest, int destStart, int length);
    [ObsoleteAttribute("Use generic method instead")]
public static Coordinate[] ToCoordinateArray(ICollection coordList);
    public static Coordinate[] ToCoordinateArray(ICollection`1<Coordinate> coordList);
    public static bool HasRepeatedPoints(Coordinate[] coord);
    public static Coordinate[] AtLeastNCoordinatesOrNothing(int n, Coordinate[] c);
    public static Coordinate[] RemoveRepeatedPoints(Coordinate[] coord);
    public static Coordinate[] RemoveNull(Coordinate[] coord);
    public static void Reverse(Coordinate[] coord);
    public static bool Equals(Coordinate[] coord1, Coordinate[] coord2);
    public static bool Equals(Coordinate[] coord1, Coordinate[] coord2, IComparer`1<Coordinate[]> coordinateComparer);
    public static Coordinate MinCoordinate(Coordinate[] coordinates);
    public static void Scroll(Coordinate[] coordinates, Coordinate firstCoordinate);
    public static int IndexOf(Coordinate coordinate, Coordinate[] coordinates);
    public static Coordinate[] Extract(Coordinate[] pts, int start, int end);
    public static Envelope Envelope(Coordinate[] coordinates);
    public static Coordinate[] Intersection(Coordinate[] coordinates, Envelope env);
}
public class NetTopologySuite.Geometries.CoordinateList : List`1<Coordinate> {
    public CoordinateList(Coordinate[] coord);
    public CoordinateList(IList`1<Coordinate> coordList);
    public CoordinateList(IList`1<Coordinate> coordList, bool allowRepeated);
    public CoordinateList(Coordinate[] coord, bool allowRepeated);
    public Coordinate GetCoordinate(int i);
    public bool Add(Coordinate[] coord, bool allowRepeated, int start, int end);
    public bool Add(Coordinate[] coord, bool allowRepeated, bool direction);
    public bool Add(Coordinate[] coord, bool allowRepeated);
    public bool Add(object obj, bool allowRepeated);
    public bool Add(Coordinate coord, bool allowRepeated);
    public void Add(int i, Coordinate coord, bool allowRepeated);
    public bool AddAll(IList`1<Coordinate> coll, bool allowRepeated);
    public void CloseRing();
    public Coordinate[] ToCoordinateArray();
    public sealed virtual object Clone();
}
public class NetTopologySuite.Geometries.CoordinateSequenceComparator : object {
    protected int DimensionLimit;
    public CoordinateSequenceComparator(int dimensionLimit);
    public static int Compare(double a, double b);
    public int Compare(object o1, object o2);
    protected int CompareCoordinate(ICoordinateSequence s1, ICoordinateSequence s2, int i, int dimension);
    public sealed virtual int Compare(ICoordinateSequence s1, ICoordinateSequence s2);
}
[ExtensionAttribute]
public static class NetTopologySuite.Geometries.CoordinateSequenceEx : object {
    [ExtensionAttribute]
public static int GetHashCode(ICoordinateSequence sequence, int baseValue, Func`2<int, int> operation);
}
public static class NetTopologySuite.Geometries.CoordinateSequences : object {
    public static void Reverse(ICoordinateSequence seq);
    public static void Swap(ICoordinateSequence seq, int i, int j);
    public static void Copy(ICoordinateSequence src, int srcPos, ICoordinateSequence dest, int destPos, int length);
    public static void CopyCoord(ICoordinateSequence src, int srcPos, ICoordinateSequence dest, int destPos);
    public static bool IsRing(ICoordinateSequence seq);
    public static ICoordinateSequence EnsureValidRing(ICoordinateSequenceFactory fact, ICoordinateSequence seq);
    private static ICoordinateSequence CreateClosedRing(ICoordinateSequenceFactory fact, ICoordinateSequence seq, int size);
    public static ICoordinateSequence Extend(ICoordinateSequenceFactory fact, ICoordinateSequence seq, int size);
    public static bool IsEqual(ICoordinateSequence cs1, ICoordinateSequence cs2);
    public static string ToString(ICoordinateSequence cs);
    public static Coordinate MinCoordinate(ICoordinateSequence seq);
    public static int MinCoordinateIndex(ICoordinateSequence seq);
    public static int MinCoordinateIndex(ICoordinateSequence seq, int from, int to);
    public static void Scroll(ICoordinateSequence seq, Coordinate firstCoordinate);
    public static void Scroll(ICoordinateSequence seq, int indexOfFirstCoordinate);
    public static void Scroll(ICoordinateSequence seq, int indexOfFirstCoordinate, bool ensureRing);
    public static int IndexOf(Coordinate coordinate, ICoordinateSequence seq);
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("No longer used.")]
public class NetTopologySuite.Geometries.DefaultCoordinateSequence : object {
    private Coordinate[] _coordinates;
    public int Dimension { get; }
    public Ordinates Ordinates { get; }
    public object Item { get; }
    public int Count { get; }
    public int Length { get; }
    public DefaultCoordinateSequence(Coordinate[] coordinates);
    public DefaultCoordinateSequence(ICoordinateSequence coordSeq);
    public DefaultCoordinateSequence(int size);
    public sealed virtual int get_Dimension();
    public sealed virtual Ordinates get_Ordinates();
    public sealed virtual Coordinate GetCoordinate(int i);
    public sealed virtual Coordinate GetCoordinateCopy(int i);
    public sealed virtual void GetCoordinate(int index, Coordinate coord);
    public sealed virtual double GetX(int index);
    public sealed virtual double GetY(int index);
    public sealed virtual double GetOrdinate(int index, Ordinate ordinate);
    public sealed virtual void SetOrdinate(int index, Ordinate ordinate, double value);
    public object get_Item(int i);
    public sealed virtual Envelope ExpandEnvelope(Envelope env);
    public sealed virtual ICoordinateSequence Reversed();
    [ObsoleteAttribute("Use Copy()")]
public sealed virtual object Clone();
    public sealed virtual ICoordinateSequence Copy();
    public sealed virtual int get_Count();
    public int get_Length();
    public sealed virtual Coordinate[] ToCoordinateArray();
    public virtual string ToString();
}
[ObsoleteAttribute("No longer used")]
public class NetTopologySuite.Geometries.DefaultCoordinateSequenceFactory : object {
    private static DefaultCoordinateSequenceFactory instance;
    public static DefaultCoordinateSequenceFactory Instance { get; }
    public Ordinates Ordinates { get; }
    private static DefaultCoordinateSequenceFactory();
    private object ReadResolve();
    public static DefaultCoordinateSequenceFactory get_Instance();
    public sealed virtual ICoordinateSequence Create(Coordinate[] coordinates);
    public sealed virtual ICoordinateSequence Create(ICoordinateSequence coordSeq);
    public sealed virtual ICoordinateSequence Create(int size, int dimension);
    public sealed virtual ICoordinateSequence Create(int size, Ordinates ordinates);
    public sealed virtual Ordinates get_Ordinates();
}
public class NetTopologySuite.Geometries.FilterMethod : MulticastDelegate {
    public FilterMethod(object object, IntPtr method);
    public virtual void Invoke(IGeometry geom);
    public virtual IAsyncResult BeginInvoke(IGeometry geom, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class NetTopologySuite.Geometries.Geometry : object {
    private IGeometryFactory _factory;
    private object _userData;
    private Envelope _envelope;
    private int _srid;
    private Dimension _dimension;
    [CompilerGeneratedAttribute]
private IGeometry <Boundary>k__BackingField;
    [CompilerGeneratedAttribute]
private Dimension <BoundaryDimension>k__BackingField;
    public static IGeometryFactory DefaultFactory;
    public IGeometryFactory Factory { get; }
    public object UserData { get; public set; }
    public int SRID { get; public set; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public IPrecisionModel PrecisionModel { get; }
    public Coordinate Coordinate { get; }
    public Coordinate[] Coordinates { get; }
    public int NumPoints { get; }
    public int NumGeometries { get; }
    public bool IsSimple { get; }
    public bool IsValid { get; }
    public bool IsEmpty { get; }
    public double Area { get; }
    public double Length { get; }
    public IPoint Centroid { get; }
    public IPoint InteriorPoint { get; }
    public IPoint PointOnSurface { get; }
    public Dimension Dimension { get; public set; }
    public IGeometry Boundary { get; public set; }
    public Dimension BoundaryDimension { get; public set; }
    public IGeometry Envelope { get; }
    public Envelope EnvelopeInternal { get; }
    protected bool IsGeometryCollection { get; }
    protected SortIndexValue SortIndex { get; }
    public bool IsRectangle { get; }
    protected Geometry(IGeometryFactory factory);
    private static Geometry();
    public sealed virtual IGeometryFactory get_Factory();
    public sealed virtual object get_UserData();
    public sealed virtual void set_UserData(object value);
    public sealed virtual int get_SRID();
    public sealed virtual void set_SRID(int value);
    public abstract virtual string get_GeometryType();
    public abstract virtual OgcGeometryType get_OgcGeometryType();
    protected static bool HasNonEmptyElements(IGeometry[] geometries);
    public static bool HasNullElements(Object[] array);
    public sealed virtual IPrecisionModel get_PrecisionModel();
    public abstract virtual Coordinate get_Coordinate();
    public abstract virtual Coordinate[] get_Coordinates();
    public abstract virtual Double[] GetOrdinates(Ordinate ordinate);
    public abstract virtual int get_NumPoints();
    public virtual int get_NumGeometries();
    public virtual IGeometry GetGeometryN(int n);
    public sealed virtual bool get_IsSimple();
    public virtual bool get_IsValid();
    public abstract virtual bool get_IsEmpty();
    public sealed virtual double Distance(IGeometry g);
    public sealed virtual bool IsWithinDistance(IGeometry geom, double distance);
    public virtual double get_Area();
    public virtual double get_Length();
    public sealed virtual IPoint get_Centroid();
    public sealed virtual IPoint get_InteriorPoint();
    public sealed virtual IPoint get_PointOnSurface();
    public virtual Dimension get_Dimension();
    public virtual void set_Dimension(Dimension value);
    [CompilerGeneratedAttribute]
public virtual IGeometry get_Boundary();
    [CompilerGeneratedAttribute]
public virtual void set_Boundary(IGeometry value);
    [CompilerGeneratedAttribute]
public virtual Dimension get_BoundaryDimension();
    [CompilerGeneratedAttribute]
public virtual void set_BoundaryDimension(Dimension value);
    public sealed virtual IGeometry get_Envelope();
    public sealed virtual Envelope get_EnvelopeInternal();
    public sealed virtual void GeometryChanged();
    public sealed virtual void GeometryChangedAction();
    public sealed virtual bool Disjoint(IGeometry g);
    public sealed virtual bool Touches(IGeometry g);
    public sealed virtual bool Intersects(IGeometry g);
    public sealed virtual bool Crosses(IGeometry g);
    public sealed virtual bool Within(IGeometry g);
    public sealed virtual bool Contains(IGeometry g);
    public sealed virtual bool Overlaps(IGeometry g);
    public sealed virtual bool Covers(IGeometry g);
    public sealed virtual bool CoveredBy(IGeometry g);
    public sealed virtual bool Relate(IGeometry g, string intersectionPattern);
    public sealed virtual IntersectionMatrix Relate(IGeometry g);
    public sealed virtual bool Equals(IGeometry g);
    public sealed virtual bool EqualsTopologically(IGeometry g);
    public virtual bool Equals(object o);
    private static bool CompareGeometryCollections(IGeometry obj1, IGeometry obj2);
    public static bool op_Equality(Geometry obj1, IGeometry obj2);
    public static bool op_Inequality(Geometry obj1, IGeometry obj2);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToText();
    public sealed virtual string AsText();
    public Byte[] ToBinary();
    public sealed virtual Byte[] AsBinary();
    public XmlReader ToGMLFeature();
    public sealed virtual IGeometry Buffer(double distance);
    [ObsoleteAttribute]
public sealed virtual IGeometry Buffer(double distance, BufferStyle endCapStyle);
    public IGeometry Buffer(double distance, EndCapStyle endCapStyle);
    public sealed virtual IGeometry Buffer(double distance, int quadrantSegments);
    [ObsoleteAttribute]
public sealed virtual IGeometry Buffer(double distance, int quadrantSegments, BufferStyle endCapStyle);
    public sealed virtual IGeometry Buffer(double distance, int quadrantSegments, EndCapStyle endCapStyle);
    public sealed virtual IGeometry Buffer(double distance, IBufferParameters bufferParameters);
    public virtual IGeometry ConvexHull();
    public abstract virtual IGeometry Reverse();
    public sealed virtual IGeometry Intersection(IGeometry other);
    public sealed virtual IGeometry Union(IGeometry other);
    public sealed virtual IGeometry Difference(IGeometry other);
    public sealed virtual IGeometry SymmetricDifference(IGeometry other);
    public sealed virtual IGeometry Union();
    public abstract virtual bool EqualsExact(IGeometry other, double tolerance);
    public sealed virtual bool EqualsExact(IGeometry other);
    public sealed virtual bool EqualsNormalized(IGeometry g);
    public abstract virtual void Apply(ICoordinateFilter filter);
    public abstract virtual void Apply(ICoordinateSequenceFilter filter);
    public abstract virtual void Apply(IGeometryFilter filter);
    public abstract virtual void Apply(IGeometryComponentFilter filter);
    [ObsoleteAttribute("Use Copy()")]
public virtual object Clone();
    public sealed virtual IGeometry Copy();
    protected abstract virtual IGeometry CopyInternal();
    public abstract virtual void Normalize();
    public sealed virtual IGeometry Normalized();
    public sealed virtual int CompareTo(object o);
    public sealed virtual int CompareTo(IGeometry geom);
    public int CompareTo(object o, IComparer`1<ICoordinateSequence> comp);
    protected virtual bool IsEquivalentClass(IGeometry other);
    protected static void CheckNotGeometryCollection(IGeometry g);
    protected bool get_IsGeometryCollection();
    protected abstract virtual Envelope ComputeEnvelopeInternal();
    protected internal abstract virtual int CompareToSameClass(object o);
    protected internal abstract virtual int CompareToSameClass(object o, IComparer`1<ICoordinateSequence> comp);
    protected static int Compare(List`1<IGeometry> a, List`1<IGeometry> b);
    protected static bool Equal(Coordinate a, Coordinate b, double tolerance);
    protected abstract virtual SortIndexValue get_SortIndex();
    private static IPoint CreatePointFromInternalCoord(Coordinate coord, IGeometry exemplar);
    public virtual bool get_IsRectangle();
    protected static Double[] CreateArray(int size, double value);
    protected static Double[] CreateArray(ICoordinateSequence sequence, Ordinate ordinate);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.GeometryCollection : Geometry {
    public static IGeometryCollection Empty;
    private IGeometry[] _geometries;
    protected SortIndexValue SortIndex { get; }
    public Coordinate Coordinate { get; }
    public Coordinate[] Coordinates { get; }
    public bool IsEmpty { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public int NumGeometries { get; }
    public IGeometry[] Geometries { get; protected set; }
    public int NumPoints { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public IGeometry Boundary { get; }
    public double Area { get; }
    public double Length { get; }
    public bool IsHomogeneous { get; }
    public IGeometry Item { get; }
    public int Count { get; }
    public GeometryCollection(IGeometry[] geometries);
    public GeometryCollection(IGeometry[] geometries, IGeometryFactory factory);
    private static GeometryCollection();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Coordinate get_Coordinate();
    public virtual Coordinate[] get_Coordinates();
    public virtual Double[] GetOrdinates(Ordinate ordinate);
    public virtual bool get_IsEmpty();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual int get_NumGeometries();
    public virtual IGeometry GetGeometryN(int n);
    public sealed virtual IGeometry[] get_Geometries();
    protected void set_Geometries(IGeometry[] value);
    public virtual int get_NumPoints();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual IGeometry get_Boundary();
    public virtual double get_Area();
    public virtual double get_Length();
    public virtual bool EqualsExact(IGeometry other, double tolerance);
    public virtual void Apply(ICoordinateFilter filter);
    public virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IGeometryFilter filter);
    public virtual void Apply(IGeometryComponentFilter filter);
    [ObsoleteAttribute("Use Copy()")]
public virtual object Clone();
    protected virtual IGeometry CopyInternal();
    public virtual void Normalize();
    protected virtual Envelope ComputeEnvelopeInternal();
    protected internal virtual int CompareToSameClass(object o);
    protected internal virtual int CompareToSameClass(object o, IComparer`1<ICoordinateSequence> comp);
    public sealed virtual bool get_IsHomogeneous();
    public sealed virtual IEnumerator`1<IGeometry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IGeometry get_Item(int i);
    public virtual IGeometry Reverse();
    public sealed virtual int get_Count();
}
public class NetTopologySuite.Geometries.GeometryCollectionEnumerator : object {
    private IGeometry _parent;
    private bool _atStart;
    private int _max;
    private int _index;
    private GeometryCollectionEnumerator _subcollectionEnumerator;
    private IGeometry _current;
    private object System.Collections.IEnumerator.Current { get; }
    public IGeometry Current { get; }
    public GeometryCollectionEnumerator(IGeometry parent);
    private bool HasNext();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Reset();
    public sealed virtual IGeometry get_Current();
    private static bool IsAtomic(IGeometry geom);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<IGeometry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NetTopologySuite.Geometries.GeometryComponentFilter : object {
    private FilterMethod _do;
    public GeometryComponentFilter(FilterMethod filterMethod);
    public sealed virtual void Filter(IGeometry geom);
}
[ExtensionAttribute]
public static class NetTopologySuite.Geometries.GeometryEx : object {
    [ExtensionAttribute]
public static Byte[] AsBinary(IGeometry self, IBinaryGeometryWriter writer);
}
public class NetTopologySuite.Geometries.GeometryFactory : object {
    public static IGeometryFactory Default;
    public static IGeometryFactory Floating;
    public static IGeometryFactory FloatingSingle;
    public static IGeometryFactory Fixed;
    private IPrecisionModel _precisionModel;
    private ICoordinateSequenceFactory _coordinateSequenceFactory;
    private int _srid;
    public IPrecisionModel PrecisionModel { get; }
    public ICoordinateSequenceFactory CoordinateSequenceFactory { get; }
    public int SRID { get; }
    public GeometryFactory(IPrecisionModel precisionModel, int srid, ICoordinateSequenceFactory coordinateSequenceFactory);
    public GeometryFactory(ICoordinateSequenceFactory coordinateSequenceFactory);
    public GeometryFactory(IPrecisionModel precisionModel);
    public GeometryFactory(IPrecisionModel precisionModel, int srid);
    private static GeometryFactory();
    public sealed virtual IPrecisionModel get_PrecisionModel();
    public sealed virtual ICoordinateSequenceFactory get_CoordinateSequenceFactory();
    public sealed virtual int get_SRID();
    public static IPoint CreatePointFromInternalCoord(Coordinate coord, IGeometry exemplar);
    public static IPoint[] ToPointArray(ICollection`1<IGeometry> points);
    public static IGeometry[] ToGeometryArray(ICollection`1<IGeometry> geometries);
    public static ILineString[] ToLineStringArray(ICollection`1<IGeometry> lineStrings);
    public static ILinearRing[] ToLinearRingArray(ICollection`1<IGeometry> linearRings);
    public static IPolygon[] ToPolygonArray(ICollection`1<IGeometry> polygons);
    public static IMultiPoint[] ToMultiPointArray(ICollection`1<IGeometry> multiPoints);
    public static IMultiLineString[] ToMultiLineStringArray(ICollection`1<IGeometry> multiLineStrings);
    public static IMultiPolygon[] ToMultiPolygonArray(ICollection`1<IGeometry> multiPolygons);
    public virtual IGeometry ToGeometry(Envelope envelope);
    public sealed virtual IPoint CreatePoint();
    public sealed virtual IPoint CreatePoint(Coordinate coordinate);
    public sealed virtual IPoint CreatePoint(ICoordinateSequence coordinates);
    public sealed virtual ILineString CreateLineString();
    public sealed virtual ILineString CreateLineString(Coordinate[] coordinates);
    public sealed virtual ILineString CreateLineString(ICoordinateSequence coordinates);
    public sealed virtual ILinearRing CreateLinearRing();
    public sealed virtual ILinearRing CreateLinearRing(Coordinate[] coordinates);
    public sealed virtual ILinearRing CreateLinearRing(ICoordinateSequence coordinates);
    public sealed virtual IPolygon CreatePolygon();
    public virtual IPolygon CreatePolygon(ILinearRing shell, ILinearRing[] holes);
    public virtual IPolygon CreatePolygon(ICoordinateSequence coordinates);
    public virtual IPolygon CreatePolygon(Coordinate[] coordinates);
    public virtual IPolygon CreatePolygon(ILinearRing shell);
    public sealed virtual IMultiPoint CreateMultiPoint();
    public sealed virtual IMultiPoint CreateMultiPoint(IPoint[] point);
    [ObsoleteAttribute("Use CreateMultiPointFromCoords")]
public sealed virtual IMultiPoint CreateMultiPoint(Coordinate[] coordinates);
    public sealed virtual IMultiPoint CreateMultiPointFromCoords(Coordinate[] coordinates);
    public sealed virtual IMultiPoint CreateMultiPoint(ICoordinateSequence coordinates);
    public sealed virtual IMultiLineString CreateMultiLineString();
    public sealed virtual IMultiLineString CreateMultiLineString(ILineString[] lineStrings);
    public sealed virtual IMultiPolygon CreateMultiPolygon();
    public sealed virtual IMultiPolygon CreateMultiPolygon(IPolygon[] polygons);
    public sealed virtual IGeometryCollection CreateGeometryCollection();
    public sealed virtual IGeometryCollection CreateGeometryCollection(IGeometry[] geometries);
    public sealed virtual IGeometry BuildGeometry(ICollection`1<IGeometry> geomList);
    public sealed virtual IGeometry CreateGeometry(IGeometry g);
    private static ICoordinateSequenceFactory GetDefaultCoordinateSequenceFactory();
    [CompilerGeneratedAttribute]
private ICoordinateSequence <CreateGeometry>b__54_0(ICoordinateSequence x, IGeometry y);
}
public class NetTopologySuite.Geometries.Implementation.CoordinateArraySequence : object {
    protected Coordinate[] Coordinates;
    private int _dimension;
    public int Dimension { get; }
    public Ordinates Ordinates { get; }
    public int Count { get; }
    public CoordinateArraySequence(Coordinate[] coordinates);
    public CoordinateArraySequence(Coordinate[] coordinates, int dimension);
    public CoordinateArraySequence(int size);
    public CoordinateArraySequence(int size, int dimension);
    public CoordinateArraySequence(ICoordinateSequence coordSeq);
    public sealed virtual int get_Dimension();
    public sealed virtual Ordinates get_Ordinates();
    public sealed virtual Coordinate GetCoordinate(int i);
    public virtual Coordinate GetCoordinateCopy(int i);
    public sealed virtual void GetCoordinate(int index, Coordinate coord);
    public sealed virtual double GetX(int index);
    public sealed virtual double GetY(int index);
    public sealed virtual double GetOrdinate(int index, Ordinate ordinate);
    [ObsoleteAttribute]
public virtual object Clone();
    public virtual ICoordinateSequence Copy();
    protected Coordinate[] GetClonedCoordinates();
    public sealed virtual int get_Count();
    public sealed virtual void SetOrdinate(int index, Ordinate ordinate, double value);
    public sealed virtual Coordinate[] ToCoordinateArray();
    public sealed virtual Envelope ExpandEnvelope(Envelope env);
    public sealed virtual ICoordinateSequence Reversed();
    public virtual string ToString();
}
public class NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory : object {
    private static CoordinateArraySequenceFactory instance;
    public static CoordinateArraySequenceFactory Instance { get; }
    public Ordinates Ordinates { get; }
    private static CoordinateArraySequenceFactory();
    public static CoordinateArraySequenceFactory get_Instance();
    public sealed virtual ICoordinateSequence Create(Coordinate[] coordinates);
    public sealed virtual ICoordinateSequence Create(ICoordinateSequence coordSeq);
    public sealed virtual ICoordinateSequence Create(int size, int dimension);
    public sealed virtual ICoordinateSequence Create(int size, Ordinates ordinates);
    public sealed virtual Ordinates get_Ordinates();
}
public class NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence : object {
    private Double[] _xy;
    private Double[] _z;
    private Double[] _m;
    private Ordinates _ordinates;
    private WeakReference _coordinateArrayRef;
    public int Dimension { get; }
    public Ordinates Ordinates { get; }
    public int Count { get; }
    public Double[] XY { get; }
    public Double[] Z { get; }
    public Double[] M { get; }
    public DotSpatialAffineCoordinateSequence(IList`1<Coordinate> coordinates, Ordinates ordinates);
    public DotSpatialAffineCoordinateSequence(int size, int dimension);
    public DotSpatialAffineCoordinateSequence(int size, Ordinates ordinates);
    public DotSpatialAffineCoordinateSequence(ICoordinateSequence coordSeq, Ordinates ordinates);
    public DotSpatialAffineCoordinateSequence(Double[] xy, Double[] z);
    public DotSpatialAffineCoordinateSequence(Double[] xy, Double[] z, Double[] m);
    private static Double[] NullOrdinateArray(int size);
    [ObsoleteAttribute]
public sealed virtual object Clone();
    public sealed virtual ICoordinateSequence Copy();
    public sealed virtual Coordinate GetCoordinate(int i);
    public sealed virtual Coordinate GetCoordinateCopy(int i);
    public sealed virtual void GetCoordinate(int index, Coordinate coord);
    public sealed virtual double GetX(int index);
    public sealed virtual double GetY(int index);
    public sealed virtual double GetOrdinate(int index, Ordinate ordinate);
    public sealed virtual void SetOrdinate(int index, Ordinate ordinate, double value);
    private Coordinate[] GetCachedCoords();
    public sealed virtual Coordinate[] ToCoordinateArray();
    public sealed virtual Envelope ExpandEnvelope(Envelope env);
    public sealed virtual ICoordinateSequence Reversed();
    public sealed virtual int get_Dimension();
    public sealed virtual Ordinates get_Ordinates();
    public sealed virtual int get_Count();
    public Double[] get_XY();
    public Double[] get_Z();
    public Double[] get_M();
    public void ReleaseCoordinateArray();
}
public class NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory : object {
    private static DotSpatialAffineCoordinateSequenceFactory _instance;
    private static object InstanceLock;
    private Ordinates _ordinates;
    public static DotSpatialAffineCoordinateSequenceFactory Instance { get; public set; }
    public Ordinates Ordinates { get; }
    public DotSpatialAffineCoordinateSequenceFactory(Ordinates ordinates);
    private static DotSpatialAffineCoordinateSequenceFactory();
    public static DotSpatialAffineCoordinateSequenceFactory get_Instance();
    public static void set_Instance(DotSpatialAffineCoordinateSequenceFactory value);
    public sealed virtual ICoordinateSequence Create(Coordinate[] coordinates);
    public sealed virtual ICoordinateSequence Create(ICoordinateSequence coordSeq);
    public sealed virtual ICoordinateSequence Create(int size, int dimension);
    public sealed virtual ICoordinateSequence Create(int size, Ordinates ordinates);
    public ICoordinateSequence Create(Double[] xy);
    public ICoordinateSequence Create(Double[] xy, Double[] zm, bool isMeasure);
    public ICoordinateSequence Create(Double[] xy, Double[] z, Double[] m);
    public sealed virtual Ordinates get_Ordinates();
}
public abstract class NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence : object {
    protected WeakReference CoordRef;
    private int _dimension;
    private Ordinates _ordinates;
    public int Dimension { get; protected set; }
    public Ordinates Ordinates { get; }
    public int Count { get; }
    private static Ordinates DimensionToOrdinate(int dimension);
    public sealed virtual int get_Dimension();
    protected void set_Dimension(int value);
    public sealed virtual Ordinates get_Ordinates();
    public abstract virtual int get_Count();
    public sealed virtual Coordinate GetCoordinate(int i);
    public sealed virtual Coordinate GetCoordinateCopy(int i);
    public sealed virtual void GetCoordinate(int i, Coordinate c);
    public sealed virtual Coordinate[] ToCoordinateArray();
    private Coordinate[] GetCachedCoords();
    public sealed virtual double GetX(int index);
    public sealed virtual double GetY(int index);
    public abstract virtual double GetOrdinate(int index, Ordinate ordinate);
    public void SetX(int index, double value);
    public void SetY(int index, double value);
    public abstract virtual void SetOrdinate(int index, Ordinate ordinate, double value);
    public virtual string ToString();
    protected abstract virtual Coordinate GetCoordinateInternal(int index);
    [ObsoleteAttribute("Use Copy()")]
public abstract virtual object Clone();
    public abstract virtual ICoordinateSequence Copy();
    public abstract virtual Envelope ExpandEnvelope(Envelope env);
    public abstract virtual ICoordinateSequence Reversed();
    [OnDeserializedAttribute]
private void OnDeserialization(StreamingContext context);
}
public class NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory : object {
    public static PackedCoordinateSequenceFactory DoubleFactory;
    public static PackedCoordinateSequenceFactory FloatFactory;
    private PackedType type;
    private int dimension;
    public PackedType Type { get; public set; }
    public int Dimension { get; public set; }
    public Ordinates Ordinates { get; }
    public PackedCoordinateSequenceFactory(PackedType type);
    public PackedCoordinateSequenceFactory(PackedType type, int dimension);
    private static PackedCoordinateSequenceFactory();
    public PackedType get_Type();
    public void set_Type(PackedType value);
    public int get_Dimension();
    public void set_Dimension(int value);
    public sealed virtual ICoordinateSequence Create(Coordinate[] coordinates);
    public sealed virtual ICoordinateSequence Create(ICoordinateSequence coordSeq);
    public sealed virtual ICoordinateSequence Create(int size, Ordinates ordinates);
    public sealed virtual Ordinates get_Ordinates();
    public ICoordinateSequence Create(Double[] packedCoordinates, int dimension);
    public ICoordinateSequence Create(Single[] packedCoordinates, int dimension);
    public sealed virtual ICoordinateSequence Create(int size, int dimension);
}
public class NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence : PackedCoordinateSequence {
    private Double[] _coords;
    public int Count { get; }
    public PackedDoubleCoordinateSequence(Double[] coords, int dimensions);
    public PackedDoubleCoordinateSequence(Single[] coordinates, int dimensions);
    public PackedDoubleCoordinateSequence(Coordinate[] coordinates, int dimension);
    public PackedDoubleCoordinateSequence(Coordinate[] coordinates);
    public PackedDoubleCoordinateSequence(int size, int dimension);
    protected virtual Coordinate GetCoordinateInternal(int index);
    public Double[] GetRawCoordinates();
    public virtual int get_Count();
    [ObsoleteAttribute]
public virtual object Clone();
    public virtual ICoordinateSequence Copy();
    public virtual double GetOrdinate(int index, Ordinate ordinate);
    public virtual void SetOrdinate(int index, Ordinate ordinate, double value);
    public virtual Envelope ExpandEnvelope(Envelope env);
    public virtual ICoordinateSequence Reversed();
}
public class NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence : PackedCoordinateSequence {
    private Single[] _coords;
    public int Count { get; }
    public PackedFloatCoordinateSequence(Single[] coords, int dimensions);
    public PackedFloatCoordinateSequence(Double[] coordinates, int dimensions);
    public PackedFloatCoordinateSequence(Coordinate[] coordinates, int dimension);
    public PackedFloatCoordinateSequence(int size, int dimension);
    protected virtual Coordinate GetCoordinateInternal(int index);
    public Single[] GetRawCoordinates();
    public virtual int get_Count();
    [ObsoleteAttribute]
public virtual object Clone();
    public virtual ICoordinateSequence Copy();
    public virtual double GetOrdinate(int index, Ordinate ordinate);
    public virtual void SetOrdinate(int index, Ordinate ordinate, double value);
    public virtual Envelope ExpandEnvelope(Envelope env);
    public virtual ICoordinateSequence Reversed();
}
public class NetTopologySuite.Geometries.LinearRing : LineString {
    public static int MinimumValidSize;
    protected SortIndexValue SortIndex { get; }
    public Dimension BoundaryDimension { get; }
    public bool IsClosed { get; }
    public string GeometryType { get; }
    public bool IsCCW { get; }
    public LinearRing(ICoordinateSequence points, IGeometryFactory factory);
    public LinearRing(Coordinate[] points);
    private void ValidateConstruction();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Dimension get_BoundaryDimension();
    public virtual bool get_IsClosed();
    public virtual string get_GeometryType();
    protected virtual IGeometry CopyInternal();
    public virtual IGeometry Reverse();
    public sealed virtual bool get_IsCCW();
}
public class NetTopologySuite.Geometries.LineSegment : object {
    private Coordinate _p0;
    private Coordinate _p1;
    private static CultureInfo _cultureInfo;
    public Coordinate P1 { get; public set; }
    public Coordinate P0 { get; public set; }
    public double MinX { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public double MaxY { get; }
    public double Length { get; }
    public bool IsHorizontal { get; }
    public bool IsVertical { get; }
    public double Angle { get; }
    public Coordinate MidPoint { get; }
    public LineSegment(Coordinate p0, Coordinate p1);
    public LineSegment(LineSegment ls);
    public LineSegment(double x0, double y0, double x1, double y1);
    private static LineSegment();
    public Coordinate get_P1();
    public void set_P1(Coordinate value);
    public Coordinate get_P0();
    public void set_P0(Coordinate value);
    public Coordinate GetCoordinate(int i);
    public void SetCoordinates(LineSegment ls);
    public void SetCoordinates(Coordinate p0, Coordinate p1);
    public double get_MinX();
    public double get_MaxX();
    public double get_MinY();
    public double get_MaxY();
    public double get_Length();
    public bool get_IsHorizontal();
    public bool get_IsVertical();
    public int OrientationIndex(LineSegment seg);
    public int OrientationIndex(Coordinate p);
    public void Reverse();
    public void Normalize();
    public double get_Angle();
    public Coordinate get_MidPoint();
    public double Distance(LineSegment ls);
    public double Distance(Coordinate p);
    public double DistancePerpendicular(Coordinate p);
    public Coordinate PointAlong(double segmentLengthFraction);
    public Coordinate PointAlongOffset(double segmentLengthFraction, double offsetDistance);
    public double ProjectionFactor(Coordinate p);
    public double SegmentFraction(Coordinate inputPt);
    public Coordinate Project(Coordinate p);
    public LineSegment Project(LineSegment seg);
    public Coordinate ClosestPoint(Coordinate p);
    public Coordinate[] ClosestPoints(LineSegment line);
    public Coordinate Intersection(LineSegment line);
    public Coordinate LineIntersection(LineSegment line);
    public ILineString ToGeometry(IGeometryFactory geomFactory);
    public virtual bool Equals(object o);
    public static bool op_Equality(LineSegment obj1, LineSegment obj2);
    public static bool op_Inequality(LineSegment obj1, LineSegment obj2);
    public sealed virtual int CompareTo(LineSegment other);
    public bool EqualsTopologically(LineSegment other);
    public virtual string ToString();
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.LineString : Geometry {
    public static ILineString Empty;
    private ICoordinateSequence _points;
    protected SortIndexValue SortIndex { get; }
    public Coordinate[] Coordinates { get; }
    public ICoordinateSequence CoordinateSequence { get; }
    public Coordinate Coordinate { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public bool IsEmpty { get; }
    public int NumPoints { get; }
    public IPoint StartPoint { get; }
    public IPoint EndPoint { get; }
    public bool IsClosed { get; }
    public bool IsRing { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public double Length { get; }
    public IGeometry Boundary { get; }
    public Coordinate Item { get; public set; }
    public int Count { get; }
    [ObsoleteAttribute("Use AngleUtility")]
public double Angle { get; }
    public LineString(Coordinate[] points);
    public LineString(ICoordinateSequence points, IGeometryFactory factory);
    private static LineString();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Coordinate[] get_Coordinates();
    public virtual Double[] GetOrdinates(Ordinate ordinate);
    public sealed virtual ICoordinateSequence get_CoordinateSequence();
    public sealed virtual Coordinate GetCoordinateN(int n);
    public virtual Coordinate get_Coordinate();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual bool get_IsEmpty();
    public virtual int get_NumPoints();
    public sealed virtual IPoint GetPointN(int n);
    public sealed virtual IPoint get_StartPoint();
    public sealed virtual IPoint get_EndPoint();
    public virtual bool get_IsClosed();
    public sealed virtual bool get_IsRing();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual double get_Length();
    public virtual IGeometry get_Boundary();
    public virtual IGeometry Reverse();
    public bool IsCoordinate(Coordinate pt);
    protected virtual Envelope ComputeEnvelopeInternal();
    public virtual bool EqualsExact(IGeometry other, double tolerance);
    public virtual void Apply(ICoordinateFilter filter);
    public virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IGeometryFilter filter);
    public virtual void Apply(IGeometryComponentFilter filter);
    [ObsoleteAttribute("Use Copy()")]
public virtual object Clone();
    protected virtual IGeometry CopyInternal();
    public virtual void Normalize();
    protected virtual bool IsEquivalentClass(IGeometry other);
    protected internal virtual int CompareToSameClass(object o);
    protected internal virtual int CompareToSameClass(object o, IComparer`1<ICoordinateSequence> comp);
    public Coordinate get_Item(int n);
    public void set_Item(int n, Coordinate value);
    public int get_Count();
    public double get_Angle();
}
public class NetTopologySuite.Geometries.MultiLineString : GeometryCollection {
    public static IMultiLineString Empty;
    protected SortIndexValue SortIndex { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public bool IsClosed { get; }
    public IGeometry Boundary { get; }
    public MultiLineString(ILineString[] lineStrings, IGeometryFactory factory);
    public MultiLineString(ILineString[] lineStrings);
    private static MultiLineString();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public sealed virtual bool get_IsClosed();
    public virtual IGeometry get_Boundary();
    public virtual IGeometry Reverse();
    private sealed virtual override IMultiLineString GeoAPI.Geometries.IMultiLineString.Reverse();
    protected virtual IGeometry CopyInternal();
    public virtual bool EqualsExact(IGeometry other, double tolerance);
}
public class NetTopologySuite.Geometries.MultiPoint : GeometryCollection {
    public static IMultiPoint Empty;
    protected SortIndexValue SortIndex { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public IGeometry Boundary { get; }
    public bool IsValid { get; }
    public MultiPoint(IPoint[] points, IGeometryFactory factory);
    public MultiPoint(IPoint[] points);
    private static MultiPoint();
    protected virtual IGeometry CopyInternal();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual IGeometry get_Boundary();
    public virtual bool get_IsValid();
    public virtual bool EqualsExact(IGeometry other, double tolerance);
    protected Coordinate GetCoordinate(int n);
}
public class NetTopologySuite.Geometries.MultiPolygon : GeometryCollection {
    public static IMultiPolygon Empty;
    protected SortIndexValue SortIndex { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public IGeometry Boundary { get; }
    public MultiPolygon(IPolygon[] polygons);
    public MultiPolygon(IPolygon[] polygons, IGeometryFactory factory);
    private static MultiPolygon();
    protected virtual IGeometry CopyInternal();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual IGeometry get_Boundary();
    public virtual bool EqualsExact(IGeometry other, double tolerance);
    public virtual IGeometry Reverse();
}
public class NetTopologySuite.Geometries.OctagonalEnvelope : object {
    private static double SQRT2;
    private double _minX;
    private double _maxX;
    private double _minY;
    private double _maxY;
    private double _minA;
    private double _maxA;
    private double _minB;
    private double _maxB;
    public double MinX { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public double MaxY { get; }
    public double MinA { get; }
    public double MaxA { get; }
    public double MinB { get; }
    public double MaxB { get; }
    public bool IsNull { get; private set; }
    private bool IsValid { get; }
    public OctagonalEnvelope(Coordinate p);
    public OctagonalEnvelope(Coordinate p0, Coordinate p1);
    public OctagonalEnvelope(Envelope env);
    public OctagonalEnvelope(OctagonalEnvelope oct);
    public OctagonalEnvelope(IGeometry geom);
    private static OctagonalEnvelope();
    public static IGeometry GetOctagonalEnvelope(IGeometry geom);
    private static double ComputeA(double x, double y);
    private static double ComputeB(double x, double y);
    public double get_MinX();
    public double get_MaxX();
    public double get_MinY();
    public double get_MaxY();
    public double get_MinA();
    public double get_MaxA();
    public double get_MinB();
    public double get_MaxB();
    public bool get_IsNull();
    private void set_IsNull(bool value);
    public void ExpandToInclude(IGeometry g);
    public OctagonalEnvelope ExpandToInclude(ICoordinateSequence seq);
    public OctagonalEnvelope ExpandToInclude(OctagonalEnvelope oct);
    public OctagonalEnvelope ExpandToInclude(Coordinate p);
    public OctagonalEnvelope ExpandToInclude(Envelope env);
    public OctagonalEnvelope ExpandToInclude(double x, double y);
    public void ExpandBy(double distance);
    private bool get_IsValid();
    public bool Intersects(OctagonalEnvelope other);
    public bool Intersects(Coordinate p);
    public bool Contains(OctagonalEnvelope other);
    public IGeometry ToGeometry(IGeometryFactory geomFactory);
}
public class NetTopologySuite.Geometries.OgcCompliantGeometryFactory : GeometryFactory {
    public OgcCompliantGeometryFactory(ICoordinateSequenceFactory factory);
    public OgcCompliantGeometryFactory(IPrecisionModel pm);
    public OgcCompliantGeometryFactory(IPrecisionModel pm, int srid);
    public OgcCompliantGeometryFactory(IPrecisionModel pm, int srid, ICoordinateSequenceFactory factory);
    private static ILinearRing ReverseRing(ILinearRing ring);
    private ILinearRing CreateLinearRing(Coordinate[] coordinates, bool ccw);
    private ILinearRing CreateLinearRing(ICoordinateSequence coordinates, bool ccw);
    public virtual IGeometry ToGeometry(Envelope envelope);
    public virtual IPolygon CreatePolygon(Coordinate[] coordinates);
    public virtual IPolygon CreatePolygon(ICoordinateSequence coordinates);
    public virtual IPolygon CreatePolygon(ILinearRing shell);
    public virtual IPolygon CreatePolygon(ILinearRing shell, ILinearRing[] holes);
}
public class NetTopologySuite.Geometries.Point : Geometry {
    private static Coordinate EmptyCoordinate;
    public static IPoint Empty;
    private ICoordinateSequence _coordinates;
    protected SortIndexValue SortIndex { get; }
    public ICoordinateSequence CoordinateSequence { get; }
    public Coordinate[] Coordinates { get; }
    public int NumPoints { get; }
    public bool IsEmpty { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public Coordinate Coordinate { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public IGeometry Boundary { get; }
    public double Z { get; public set; }
    public double M { get; public set; }
    public Point(Coordinate coordinate);
    public Point(ICoordinateSequence coordinates, IGeometryFactory factory);
    public Point(double x, double y, double z);
    public Point(double x, double y);
    private static Point();
    protected virtual SortIndexValue get_SortIndex();
    public sealed virtual ICoordinateSequence get_CoordinateSequence();
    public virtual Coordinate[] get_Coordinates();
    public virtual Double[] GetOrdinates(Ordinate ordinate);
    public virtual int get_NumPoints();
    public virtual bool get_IsEmpty();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public sealed virtual double get_X();
    public sealed virtual void set_X(double value);
    public sealed virtual double get_Y();
    public sealed virtual void set_Y(double value);
    public virtual Coordinate get_Coordinate();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual IGeometry get_Boundary();
    protected virtual Envelope ComputeEnvelopeInternal();
    public virtual bool EqualsExact(IGeometry other, double tolerance);
    public virtual void Apply(ICoordinateFilter filter);
    public virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IGeometryFilter filter);
    public virtual void Apply(IGeometryComponentFilter filter);
    [ObsoleteAttribute("Use Copy()")]
public virtual object Clone();
    protected virtual IGeometry CopyInternal();
    public virtual IGeometry Reverse();
    public virtual void Normalize();
    protected internal virtual int CompareToSameClass(object other);
    protected internal virtual int CompareToSameClass(object other, IComparer`1<ICoordinateSequence> comparer);
    public sealed virtual double get_Z();
    public sealed virtual void set_Z(double value);
    public sealed virtual double get_M();
    public sealed virtual void set_M(double value);
}
public class NetTopologySuite.Geometries.Polygon : Geometry {
    public static IPolygon Empty;
    private ILinearRing _shell;
    private ILinearRing[] _holes;
    protected SortIndexValue SortIndex { get; }
    public Coordinate Coordinate { get; }
    public Coordinate[] Coordinates { get; }
    public int NumPoints { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public bool IsEmpty { get; }
    public ILineString ExteriorRing { get; }
    public int NumInteriorRings { get; }
    public ILineString[] InteriorRings { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public double Area { get; }
    public double Length { get; }
    public IGeometry Boundary { get; }
    public bool IsRectangle { get; }
    public ILinearRing Shell { get; private set; }
    public ILinearRing[] Holes { get; private set; }
    public Polygon(ILinearRing shell, ILinearRing[] holes);
    public Polygon(ILinearRing shell, ILinearRing[] holes, IGeometryFactory factory);
    public Polygon(ILinearRing shell, IGeometryFactory factory);
    public Polygon(ILinearRing shell);
    private static Polygon();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Coordinate get_Coordinate();
    public virtual Coordinate[] get_Coordinates();
    public virtual Double[] GetOrdinates(Ordinate ordinate);
    public virtual int get_NumPoints();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual bool get_IsEmpty();
    public sealed virtual ILineString get_ExteriorRing();
    public sealed virtual int get_NumInteriorRings();
    public sealed virtual ILineString[] get_InteriorRings();
    public sealed virtual ILineString GetInteriorRingN(int n);
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual double get_Area();
    public virtual double get_Length();
    public virtual IGeometry get_Boundary();
    protected virtual Envelope ComputeEnvelopeInternal();
    public virtual bool EqualsExact(IGeometry other, double tolerance);
    public virtual void Apply(ICoordinateFilter filter);
    public virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IGeometryFilter filter);
    public virtual void Apply(IGeometryComponentFilter filter);
    [ObsoleteAttribute("Use Copy()")]
public virtual object Clone();
    protected virtual IGeometry CopyInternal();
    public virtual IGeometry ConvexHull();
    public virtual void Normalize();
    protected internal virtual int CompareToSameClass(object o);
    protected internal virtual int CompareToSameClass(object other, IComparer`1<ICoordinateSequence> comparer);
    private static ILinearRing Normalized(ILinearRing ring, bool clockwise);
    private static void Normalize(ILinearRing ring, bool clockwise);
    public virtual bool get_IsRectangle();
    public virtual IGeometry Reverse();
    public sealed virtual ILinearRing get_Shell();
    private void set_Shell(ILinearRing value);
    public sealed virtual ILinearRing[] get_Holes();
    private void set_Holes(ILinearRing[] value);
}
public class NetTopologySuite.Geometries.PrecisionModel : object {
    private static int FloatingPrecisionDigits;
    private static int FloatingSinglePrecisionDigits;
    private static int FixedPrecisionDigits;
    public static double MaximumPreciseValue;
    private PrecisionModels _modelType;
    private double _scale;
    public bool IsFloating { get; }
    public int MaximumSignificantDigits { get; }
    public double Scale { get; public set; }
    public PrecisionModels PrecisionModelType { get; }
    [ObsoleteAttribute("Offsets are no longer used")]
public double OffsetX { get; }
    [ObsoleteAttribute("Offsets are no longer used")]
public double OffsetY { get; }
    public PrecisionModel(PrecisionModels modelType);
    [ObsoleteAttribute("Offsets are no longer supported, since internal representation is rounded floating point")]
public PrecisionModel(double scale, double offsetX, double offsetY);
    public PrecisionModel(double scale);
    public PrecisionModel(PrecisionModel pm);
    public static IPrecisionModel MostPrecise(IPrecisionModel pm1, IPrecisionModel pm2);
    public virtual int GetHashCode();
    public sealed virtual bool get_IsFloating();
    public sealed virtual int get_MaximumSignificantDigits();
    public sealed virtual double get_Scale();
    public void set_Scale(double value);
    public sealed virtual PrecisionModels get_PrecisionModelType();
    public double get_OffsetX();
    public double get_OffsetY();
    [ObsoleteAttribute("Use MakePrecise instead")]
public void ToInternal(Coordinate cexternal, Coordinate cinternal);
    [ObsoleteAttribute("Use MakePrecise instead")]
public Coordinate ToInternal(Coordinate cexternal);
    [ObsoleteAttribute("No longer needed, since internal representation is same as external representation")]
public Coordinate ToExternal(Coordinate cinternal);
    [ObsoleteAttribute("No longer needed, since internal representation is same as external representation")]
public void ToExternal(Coordinate cinternal, Coordinate cexternal);
    public sealed virtual double MakePrecise(double val);
    public sealed virtual void MakePrecise(Coordinate coord);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public bool Equals(IPrecisionModel otherPrecisionModel);
    public static bool op_Equality(PrecisionModel obj1, PrecisionModel obj2);
    public static bool op_Inequality(PrecisionModel obj1, PrecisionModel obj2);
    public sealed virtual int CompareTo(object o);
    public sealed virtual int CompareTo(IPrecisionModel other);
}
internal abstract class NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains : PreparedPolygonPredicate {
    protected bool RequireSomePointInInterior;
    private bool _hasSegmentIntersection;
    private bool _hasProperIntersection;
    private bool _hasNonProperIntersection;
    protected AbstractPreparedPolygonContains(PreparedPolygon prepPoly);
    protected bool Eval(IGeometry geom);
    private bool IsProperIntersectionImpliesNotContainedSituation(IGeometry testGeom);
    private static bool IsSingleShell(IGeometry geom);
    private void FindAndClassifyIntersections(IGeometry geom);
    protected abstract virtual bool FullTopologicalPredicate(IGeometry geom);
}
public class NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry : object {
    private IGeometry _baseGeom;
    private List`1<Coordinate> _representativePts;
    public IGeometry Geometry { get; }
    public IList`1<Coordinate> RepresentativePoints { get; }
    public BasicPreparedGeometry(IGeometry geom);
    public sealed virtual IGeometry get_Geometry();
    public IList`1<Coordinate> get_RepresentativePoints();
    public bool IsAnyTargetComponentInTest(IGeometry testGeom);
    protected bool EnvelopesIntersect(IGeometry g);
    protected bool EnvelopeCovers(IGeometry g);
    public virtual bool Contains(IGeometry g);
    public virtual bool ContainsProperly(IGeometry g);
    public sealed virtual bool CoveredBy(IGeometry g);
    public virtual bool Covers(IGeometry g);
    public sealed virtual bool Crosses(IGeometry g);
    public sealed virtual bool Disjoint(IGeometry g);
    public virtual bool Intersects(IGeometry g);
    public sealed virtual bool Overlaps(IGeometry g);
    public sealed virtual bool Touches(IGeometry g);
    public sealed virtual bool Within(IGeometry g);
    public virtual string ToString();
}
public class NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory : object {
    public static IPreparedGeometry Prepare(IGeometry geom);
    public IPreparedGeometry Create(IGeometry geom);
}
public class NetTopologySuite.Geometries.Prepared.PreparedLineString : BasicPreparedGeometry {
    private object _lock;
    private FastSegmentSetIntersectionFinder modreq(System.Runtime.CompilerServices.IsVolatile) _segIntFinder;
    public FastSegmentSetIntersectionFinder IntersectionFinder { get; }
    public PreparedLineString(ILineal line);
    public FastSegmentSetIntersectionFinder get_IntersectionFinder();
    public virtual bool Intersects(IGeometry g);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects : object {
    protected PreparedLineString prepLine;
    public PreparedLineStringIntersects(PreparedLineString prepLine);
    public static bool Intersects(PreparedLineString prep, IGeometry geom);
    public bool Intersects(IGeometry geom);
    protected bool IsAnyTestPointInTarget(IGeometry testGeom);
}
public class NetTopologySuite.Geometries.Prepared.PreparedPoint : BasicPreparedGeometry {
    public PreparedPoint(IPuntal point);
    public virtual bool Intersects(IGeometry g);
}
public class NetTopologySuite.Geometries.Prepared.PreparedPolygon : BasicPreparedGeometry {
    private bool _isRectangle;
    private object _lockSif;
    private object _lockPia;
    private FastSegmentSetIntersectionFinder modreq(System.Runtime.CompilerServices.IsVolatile) _segIntFinder;
    private IPointOnGeometryLocator modreq(System.Runtime.CompilerServices.IsVolatile) _pia;
    public FastSegmentSetIntersectionFinder IntersectionFinder { get; }
    public IPointOnGeometryLocator PointLocator { get; }
    public PreparedPolygon(IPolygonal poly);
    public FastSegmentSetIntersectionFinder get_IntersectionFinder();
    public IPointOnGeometryLocator get_PointLocator();
    public virtual bool Intersects(IGeometry g);
    public virtual bool Contains(IGeometry g);
    public virtual bool ContainsProperly(IGeometry g);
    public virtual bool Covers(IGeometry g);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedPolygonContains : AbstractPreparedPolygonContains {
    public PreparedPolygonContains(PreparedPolygon prepPoly);
    public static bool Contains(PreparedPolygon prep, IGeometry geom);
    public bool Contains(IGeometry geom);
    protected virtual bool FullTopologicalPredicate(IGeometry geom);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly : PreparedPolygonPredicate {
    public PreparedPolygonContainsProperly(PreparedPolygon prepPoly);
    public static bool ContainsProperly(PreparedPolygon prep, IGeometry geom);
    public bool ContainsProperly(IGeometry geom);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers : AbstractPreparedPolygonContains {
    public PreparedPolygonCovers(PreparedPolygon prepPoly);
    public static bool Covers(PreparedPolygon prep, IGeometry geom);
    public bool Covers(IGeometry geom);
    protected virtual bool FullTopologicalPredicate(IGeometry geom);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects : PreparedPolygonPredicate {
    public PreparedPolygonIntersects(PreparedPolygon prepPoly);
    public static bool Intersects(PreparedPolygon prep, IGeometry geom);
    public bool Intersects(IGeometry geom);
}
internal abstract class NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate : object {
    protected PreparedPolygon prepPoly;
    private IPointOnGeometryLocator _targetPointLocator;
    protected PreparedPolygonPredicate(PreparedPolygon prepPoly);
    protected bool IsAllTestComponentsInTarget(IGeometry testGeom);
    protected bool IsAllTestComponentsInTargetInterior(IGeometry testGeom);
    protected bool IsAnyTestComponentInTarget(IGeometry testGeom);
    protected bool IsAnyTestComponentInTargetInterior(IGeometry testGeom);
    protected bool IsAnyTargetComponentInAreaTest(IGeometry testGeom, IList`1<Coordinate> targetRepPts);
}
public class NetTopologySuite.Geometries.TopologyException : ApplicationException {
    private Coordinate pt;
    public Coordinate Coordinate { get; }
    public TopologyException(string msg);
    public TopologyException(string msg, Coordinate pt);
    private static string MsgWithCoord(string msg, Coordinate pt);
    public Coordinate get_Coordinate();
}
public class NetTopologySuite.Geometries.Triangle : object {
    private Coordinate _p0;
    private Coordinate _p1;
    private Coordinate _p2;
    public Coordinate P0 { get; public set; }
    public Coordinate P1 { get; public set; }
    public Coordinate P2 { get; public set; }
    public Triangle(Coordinate p0, Coordinate p1, Coordinate p2);
    public Coordinate get_P0();
    public void set_P0(Coordinate value);
    public Coordinate get_P1();
    public void set_P1(Coordinate value);
    public Coordinate get_P2();
    public void set_P2(Coordinate value);
    public static bool IsAcute(Coordinate a, Coordinate b, Coordinate c);
    public static HCoordinate PerpendicularBisector(Coordinate a, Coordinate b);
    public static Coordinate Circumcentre(Coordinate a, Coordinate b, Coordinate c);
    private static double Det(double m00, double m01, double m10, double m11);
    public static Coordinate InCentre(Coordinate a, Coordinate b, Coordinate c);
    public static Coordinate Centroid(Coordinate a, Coordinate b, Coordinate c);
    public static double LongestSideLength(Coordinate a, Coordinate b, Coordinate c);
    public static Coordinate AngleBisector(Coordinate a, Coordinate b, Coordinate c);
    public static double Area(Coordinate a, Coordinate b, Coordinate c);
    public static double SignedArea(Coordinate a, Coordinate b, Coordinate c);
    public static double Area3D(Coordinate a, Coordinate b, Coordinate c);
    public static double InterpolateZ(Coordinate p, Coordinate v0, Coordinate v1, Coordinate v2);
    public Coordinate InCentre();
    public bool IsAcute();
    public Coordinate Circumcentre();
    public Coordinate Centroid();
    public double LongestSideLength();
    public double Area();
    public double SignedArea();
    public double Area3D();
    public double InterpolateZ(Coordinate p);
}
public class NetTopologySuite.Geometries.Utilities.AffineTransformation : object {
    private double _m00;
    private double _m01;
    private double _m02;
    private double _m10;
    private double _m11;
    private double _m12;
    public Double[] MatrixEntries { get; }
    public double Determinant { get; }
    public bool GeometryChanged { get; }
    public bool Done { get; }
    public bool IsIdentity { get; }
    public AffineTransformation(Double[] matrix);
    public AffineTransformation(double m00, double m01, double m02, double m10, double m11, double m12);
    public AffineTransformation(AffineTransformation trans);
    public AffineTransformation(Coordinate src0, Coordinate src1, Coordinate src2, Coordinate dest0, Coordinate dest1, Coordinate dest2);
    public static AffineTransformation ReflectionInstance(double x0, double y0, double x1, double y1);
    public static AffineTransformation ReflectionInstance(double x, double y);
    public static AffineTransformation RotationInstance(double theta);
    public static AffineTransformation RotationInstance(double sinTheta, double cosTheta);
    public static AffineTransformation RotationInstance(double theta, double x, double y);
    public static AffineTransformation RotationInstance(double sinTheta, double cosTheta, double x, double y);
    public static AffineTransformation ScaleInstance(double xScale, double yScale);
    public static AffineTransformation ScaleInstance(double xScale, double yScale, double x, double y);
    public static AffineTransformation ShearInstance(double xShear, double yShear);
    public static AffineTransformation TranslationInstance(double x, double y);
    public AffineTransformation SetToIdentity();
    public AffineTransformation SetTransformation(double m00, double m01, double m02, double m10, double m11, double m12);
    public AffineTransformation SetTransformation(AffineTransformation trans);
    public Double[] get_MatrixEntries();
    public double get_Determinant();
    public AffineTransformation GetInverse();
    public AffineTransformation SetToReflectionBasic(double x0, double y0, double x1, double y1);
    public AffineTransformation SetToReflection(double x0, double y0, double x1, double y1);
    public AffineTransformation SetToReflection(double x, double y);
    public AffineTransformation SetToRotation(double theta);
    public AffineTransformation SetToRotation(double sinTheta, double cosTheta);
    public AffineTransformation SetToRotation(double theta, double x, double y);
    public AffineTransformation SetToRotation(double sinTheta, double cosTheta, double x, double y);
    public AffineTransformation SetToScale(double xScale, double yScale);
    public AffineTransformation SetToShear(double xShear, double yShear);
    public AffineTransformation SetToTranslation(double dx, double dy);
    public AffineTransformation Reflect(double x0, double y0, double x1, double y1);
    public AffineTransformation Reflect(double x, double y);
    public AffineTransformation Rotate(double theta);
    public AffineTransformation Rotate(double sinTheta, double cosTheta);
    public AffineTransformation Rotate(double theta, double x, double y);
    public AffineTransformation Rotate(double sinTheta, double cosTheta, double x, double y);
    public AffineTransformation Scale(double xScale, double yScale);
    public AffineTransformation Shear(double xShear, double yShear);
    public AffineTransformation Translate(double x, double y);
    public AffineTransformation Compose(AffineTransformation trans);
    public AffineTransformation ComposeBefore(AffineTransformation trans);
    public Coordinate Transform(Coordinate src, Coordinate dest);
    public IGeometry Transform(IGeometry g);
    public void Transform(ICoordinateSequence seq, int i);
    public sealed virtual void Filter(ICoordinateSequence seq, int i);
    public sealed virtual bool get_GeometryChanged();
    public sealed virtual bool get_Done();
    public bool get_IsIdentity();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AffineTransformation trans);
    public virtual string ToString();
    public sealed virtual object Clone();
}
public class NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder : object {
    private Coordinate _src0;
    private Coordinate _src1;
    private Coordinate _src2;
    private Coordinate _dest0;
    private Coordinate _dest1;
    private Coordinate _dest2;
    private double _m00;
    private double _m01;
    private double _m02;
    private double _m10;
    private double _m11;
    private double _m12;
    public AffineTransformationBuilder(Coordinate src0, Coordinate src1, Coordinate src2, Coordinate dest0, Coordinate dest1, Coordinate dest2);
    public AffineTransformation GetTransformation();
    private bool Compute();
    private Double[] Solve(Double[] b);
}
public static class NetTopologySuite.Geometries.Utilities.AffineTransformationFactory : object {
    public static AffineTransformation CreateFromControlVectors(Coordinate src0, Coordinate src1, Coordinate src2, Coordinate dest0, Coordinate dest1, Coordinate dest2);
    public static AffineTransformation CreateFromControlVectors(Coordinate src0, Coordinate src1, Coordinate dest0, Coordinate dest1);
    public static AffineTransformation CreateFromControlVectors(Coordinate src0, Coordinate dest0);
    public static AffineTransformation CreateFromControlVectors(Coordinate[] src, Coordinate[] dest);
    public static AffineTransformation CreateFromBaseLines(Coordinate src0, Coordinate src1, Coordinate dest0, Coordinate dest1);
}
public class NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter : object {
    private List`1<Coordinate> _coords;
    public ComponentCoordinateExtracter(List`1<Coordinate> coords);
    public static List`1<Coordinate> GetCoordinates(IGeometry geom);
    public sealed virtual void Filter(IGeometry geom);
}
public class NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper : object {
    private Func`2<IGeometry, IGeometry> _mapOp;
    public GeometryCollectionMapper(Func`2<IGeometry, IGeometry> mapOp);
    public static IGeometryCollection Map(IGeometryCollection gc, Func`2<IGeometry, IGeometry> op);
    public IGeometryCollection Map(IGeometryCollection gc);
}
public class NetTopologySuite.Geometries.Utilities.GeometryCombiner : object {
    private IGeometryFactory _geomFactory;
    [CompilerGeneratedAttribute]
private static bool <SkipEmpty>k__BackingField;
    private ICollection`1<IGeometry> _inputGeoms;
    public static bool SkipEmpty { get; public set; }
    public GeometryCombiner(ICollection`1<IGeometry> geoms);
    public static IGeometry Combine(ICollection`1<IGeometry> geoms);
    public static IGeometry Combine(IGeometry g0, IGeometry g1);
    public static IGeometry Combine(IGeometry g0, IGeometry g1, IGeometry g2);
    private static List`1<IGeometry> CreateList(IGeometry obj0, IGeometry obj1);
    private static List`1<IGeometry> CreateList(IGeometry obj0, IGeometry obj1, IGeometry obj2);
    [CompilerGeneratedAttribute]
public static bool get_SkipEmpty();
    [CompilerGeneratedAttribute]
public static void set_SkipEmpty(bool value);
    public static IGeometryFactory ExtractFactory(ICollection`1<IGeometry> geoms);
    public IGeometry Combine();
    private static void ExtractElements(IGeometry geom, ICollection`1<IGeometry> elems);
}
public class NetTopologySuite.Geometries.Utilities.GeometryEditor : object {
    private IGeometryFactory _factory;
    private bool _isUserDataCopied;
    public bool CopyUserData { get; public set; }
    public GeometryEditor(IGeometryFactory factory);
    public bool get_CopyUserData();
    public void set_CopyUserData(bool value);
    public IGeometry Edit(IGeometry geometry, IGeometryEditorOperation operation);
    private IGeometry EditInternal(IGeometry geometry, IGeometryEditorOperation operation);
    private IPolygon EditPolygon(IPolygon polygon, IGeometryEditorOperation operation);
    private IGeometryCollection EditGeometryCollection(IGeometryCollection collection, IGeometryEditorOperation operation);
}
public static class NetTopologySuite.Geometries.Utilities.GeometryExtracter : object {
    public static IList`1<IGeometry> Extract(IGeometry geom, IList`1<IGeometry> list);
    public static IList`1<IGeometry> Extract(IGeometry geom);
}
public class NetTopologySuite.Geometries.Utilities.GeometryExtracter`1 : object {
    private IList`1<IGeometry> _comps;
    public GeometryExtracter`1(IList`1<IGeometry> comps);
    public sealed virtual void Filter(IGeometry geom);
}
public class NetTopologySuite.Geometries.Utilities.GeometryMapper : object {
    public static IGeometry Map(IGeometry geom, Func`2<IGeometry, IGeometry> op);
    public static IGeometry Map(IGeometry geom, IMapOp op);
    public static ICollection`1<IGeometry> Map(ICollection`1<IGeometry> geoms, IMapOp op);
}
public class NetTopologySuite.Geometries.Utilities.GeometryTransformer : object {
    private IGeometry _inputGeom;
    protected IGeometryFactory Factory;
    private bool pruneEmptyGeometry;
    private bool preserveGeometryCollectionType;
    private bool _preserveType;
    public IGeometry InputGeometry { get; }
    public IGeometry get_InputGeometry();
    public IGeometry Transform(IGeometry inputGeom);
    protected virtual ICoordinateSequence CreateCoordinateSequence(Coordinate[] coords);
    protected virtual ICoordinateSequence Copy(ICoordinateSequence seq);
    protected virtual ICoordinateSequence TransformCoordinates(ICoordinateSequence coords, IGeometry parent);
    protected virtual IGeometry TransformPoint(IPoint geom, IGeometry parent);
    protected virtual IGeometry TransformMultiPoint(IMultiPoint geom, IGeometry parent);
    protected virtual IGeometry TransformLinearRing(ILinearRing geom, IGeometry parent);
    protected virtual IGeometry TransformLineString(ILineString geom, IGeometry parent);
    protected virtual IGeometry TransformMultiLineString(IMultiLineString geom, IGeometry parent);
    protected virtual IGeometry TransformPolygon(IPolygon geom, IGeometry parent);
    protected virtual IGeometry TransformMultiPolygon(IMultiPolygon geom, IGeometry parent);
    protected virtual IGeometry TransformGeometryCollection(IGeometryCollection geom, IGeometry parent);
}
public class NetTopologySuite.Geometries.Utilities.LinearComponentExtracter : object {
    private ICollection`1<IGeometry> _lines;
    [CompilerGeneratedAttribute]
private bool <IsForcedToLineString>k__BackingField;
    public bool IsForcedToLineString { get; public set; }
    public LinearComponentExtracter(ICollection`1<IGeometry> lines);
    public LinearComponentExtracter(ICollection`1<IGeometry> lines, bool isForcedToLineString);
    public static ICollection`1<IGeometry> GetLines(ICollection`1<IGeometry> geoms, ICollection`1<IGeometry> lines);
    public static ICollection`1<IGeometry> GetLines(ICollection`1<IGeometry> geoms, ICollection`1<IGeometry> lines, bool forceToLineString);
    public static ICollection`1<IGeometry> GetLines(IGeometry geom, ICollection`1<IGeometry> lines);
    public static ICollection`1<IGeometry> GetLines(IGeometry geom, ICollection`1<IGeometry> lines, bool forceToLineString);
    public static ICollection`1<IGeometry> GetLines(IGeometry geom);
    public static ICollection`1<IGeometry> GetLines(IGeometry geom, bool forceToLineString);
    public static IGeometry GetGeometry(IGeometry geom);
    public static IGeometry GetGeometry(IGeometry geom, bool forceToLineString);
    [CompilerGeneratedAttribute]
public bool get_IsForcedToLineString();
    [CompilerGeneratedAttribute]
public void set_IsForcedToLineString(bool value);
    public sealed virtual void Filter(IGeometry geom);
}
public class NetTopologySuite.Geometries.Utilities.LineStringExtracter : object {
    private ICollection`1<IGeometry> _comps;
    public LineStringExtracter(ICollection`1<IGeometry> comps);
    public static ICollection`1<IGeometry> GetLines(IGeometry geom, ICollection`1<IGeometry> lines);
    public static ICollection`1<IGeometry> GetLines(IGeometry geom);
    public static IGeometry GetGeometry(IGeometry geom);
    public sealed virtual void Filter(IGeometry geom);
}
public class NetTopologySuite.Geometries.Utilities.Matrix : object {
    private static void SwapRows(Double[][] m, int i, int j);
    private static void SwapRows(Double[] m, int i, int j);
    public static Double[] Solve(Double[][] a, Double[] b);
}
public class NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException : Exception {
    public NoninvertibleTransformationException(string transformationIsNonInvertible);
}
public class NetTopologySuite.Geometries.Utilities.PointExtracter : object {
    private List`1<IGeometry> _pts;
    public PointExtracter(List`1<IGeometry> pts);
    public static ICollection`1<IGeometry> GetPoints(IGeometry geom, List`1<IGeometry> list);
    public static ICollection`1<IGeometry> GetPoints(IGeometry geom);
    public sealed virtual void Filter(IGeometry geom);
}
public class NetTopologySuite.Geometries.Utilities.PolygonExtracter : object {
    private IList`1<IGeometry> _comps;
    public PolygonExtracter(IList`1<IGeometry> comps);
    public static IList`1<IGeometry> GetPolygons(IGeometry geom, IList`1<IGeometry> list);
    public static IList`1<IGeometry> GetPolygons(IGeometry geom);
    public sealed virtual void Filter(IGeometry geom);
}
public abstract class NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor : object {
    private bool _isDone;
    public void ApplyTo(IGeometry geom);
    protected abstract virtual void Visit(IGeometry element);
    protected abstract virtual bool IsDone();
}
public class NetTopologySuite.Geometries.Utilities.SineStarFactory : GeometricShapeFactory {
    [CompilerGeneratedAttribute]
private int <NumArms>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ArmLengthRatio>k__BackingField;
    public int NumArms { get; public set; }
    public double ArmLengthRatio { get; public set; }
    public SineStarFactory(IGeometryFactory geomFact);
    [CompilerGeneratedAttribute]
public int get_NumArms();
    [CompilerGeneratedAttribute]
public void set_NumArms(int value);
    [CompilerGeneratedAttribute]
public double get_ArmLengthRatio();
    [CompilerGeneratedAttribute]
public void set_ArmLengthRatio(double value);
    public IGeometry CreateSineStar();
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.GeometriesGraph.Depth : object {
    private static int null;
    private Int32[0...,0...] depth;
    public int Item { get; public set; }
    public static int DepthAtLocation(Location _location);
    public int GetDepth(int geomIndex, Positions posIndex);
    public void SetDepth(int geomIndex, Positions posIndex, int depthValue);
    public int get_Item(int geomIndex, Positions posIndex);
    public void set_Item(int geomIndex, Positions posIndex, int value);
    public Location GetLocation(int geomIndex, Positions posIndex);
    public void Add(int geomIndex, Positions posIndex, Location _location);
    public bool IsNull();
    public bool IsNull(int geomIndex);
    public bool IsNull(int geomIndex, Positions posIndex);
    public void Add(Label lbl);
    public int GetDelta(int geomIndex);
    public void Normalize();
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.DirectedEdge : EdgeEnd {
    private bool _isForward;
    private bool _isInResult;
    private bool _isVisited;
    private DirectedEdge _sym;
    private Int32[] _depth;
    [CompilerGeneratedAttribute]
private EdgeRing <EdgeRing>k__BackingField;
    [CompilerGeneratedAttribute]
private EdgeRing <MinEdgeRing>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectedEdge <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectedEdge <NextMin>k__BackingField;
    public bool InResult { get; public set; }
    public bool IsInResult { get; }
    public bool Visited { get; public set; }
    public bool IsVisited { get; }
    public EdgeRing EdgeRing { get; public set; }
    public EdgeRing MinEdgeRing { get; public set; }
    public int DepthDelta { get; }
    public bool VisitedEdge { get; public set; }
    public bool IsForward { get; protected set; }
    public DirectedEdge Sym { get; public set; }
    public DirectedEdge Next { get; public set; }
    public DirectedEdge NextMin { get; public set; }
    public bool IsLineEdge { get; }
    public bool IsInteriorAreaEdge { get; }
    public DirectedEdge(Edge edge, bool isForward);
    public static int DepthFactor(Location currLocation, Location nextLocation);
    public bool get_InResult();
    public void set_InResult(bool value);
    public bool get_IsInResult();
    public bool get_Visited();
    public void set_Visited(bool value);
    public bool get_IsVisited();
    [CompilerGeneratedAttribute]
public EdgeRing get_EdgeRing();
    [CompilerGeneratedAttribute]
public void set_EdgeRing(EdgeRing value);
    [CompilerGeneratedAttribute]
public EdgeRing get_MinEdgeRing();
    [CompilerGeneratedAttribute]
public void set_MinEdgeRing(EdgeRing value);
    public int GetDepth(Positions position);
    public void SetDepth(Positions position, int depthVal);
    public int get_DepthDelta();
    public bool get_VisitedEdge();
    public void set_VisitedEdge(bool value);
    public bool get_IsForward();
    protected void set_IsForward(bool value);
    public DirectedEdge get_Sym();
    public void set_Sym(DirectedEdge value);
    [CompilerGeneratedAttribute]
public DirectedEdge get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(DirectedEdge value);
    [CompilerGeneratedAttribute]
public DirectedEdge get_NextMin();
    [CompilerGeneratedAttribute]
public void set_NextMin(DirectedEdge value);
    public bool get_IsLineEdge();
    public bool get_IsInteriorAreaEdge();
    private void ComputeDirectedLabel();
    public void SetEdgeDepths(Positions position, int depth);
    [ObsoleteAttribute("Use SetEdgeDepths instead")]
public void OLDSetEdgeDepths(Positions position, int depth);
    public virtual void Write(StreamWriter outstream);
    public void WriteEdge(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.DirectedEdgeStar : EdgeEndStar {
    private IList`1<DirectedEdge> _resultAreaEdgeList;
    private Label _label;
    private static int ScanningForIncoming;
    private static int LinkingToOutgoing;
    public Label Label { get; }
    public virtual void Insert(EdgeEnd ee);
    public Label get_Label();
    public int GetOutgoingDegree();
    public int GetOutgoingDegree(EdgeRing er);
    public DirectedEdge GetRightmostEdge();
    public virtual void ComputeLabelling(GeometryGraph[] geom);
    public void MergeSymLabels();
    public void UpdateLabelling(Label nodeLabel);
    private IList`1<DirectedEdge> GetResultAreaEdges();
    public void LinkResultDirectedEdges();
    public void LinkMinimalDirectedEdges(EdgeRing er);
    public void LinkAllDirectedEdges();
    public void FindCoveredLineEdges();
    public void ComputeDepths(DirectedEdge de);
    private int ComputeDepths(int startIndex, int endIndex, int startDepth);
    public virtual void Write(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.Edge : GraphComponent {
    private Coordinate[] _pts;
    private Envelope _env;
    private EdgeIntersectionList _eiList;
    private string _name;
    private MonotoneChainEdge _mce;
    private bool _isIsolated;
    private Depth _depth;
    private int _depthDelta;
    public Coordinate[] Points { get; public set; }
    public int NumPoints { get; }
    public string Name { get; public set; }
    public Coordinate[] Coordinates { get; }
    public Coordinate Coordinate { get; protected set; }
    public Envelope Envelope { get; }
    public Depth Depth { get; }
    public int DepthDelta { get; public set; }
    public int MaximumSegmentIndex { get; }
    public EdgeIntersectionList EdgeIntersectionList { get; }
    public MonotoneChainEdge MonotoneChainEdge { get; }
    public bool IsClosed { get; }
    public bool IsCollapsed { get; }
    public Edge CollapsedEdge { get; }
    public bool Isolated { get; public set; }
    public bool IsIsolated { get; }
    public Edge(Coordinate[] pts, Label label);
    public Edge(Coordinate[] pts);
    public static void UpdateIM(Label label, IntersectionMatrix im);
    public Coordinate[] get_Points();
    public void set_Points(Coordinate[] value);
    public int get_NumPoints();
    public string get_Name();
    public void set_Name(string value);
    public Coordinate[] get_Coordinates();
    public Coordinate GetCoordinate(int i);
    public virtual Coordinate get_Coordinate();
    protected virtual void set_Coordinate(Coordinate value);
    public Envelope get_Envelope();
    public Depth get_Depth();
    public int get_DepthDelta();
    public void set_DepthDelta(int value);
    public int get_MaximumSegmentIndex();
    public EdgeIntersectionList get_EdgeIntersectionList();
    public MonotoneChainEdge get_MonotoneChainEdge();
    public bool get_IsClosed();
    public bool get_IsCollapsed();
    public Edge get_CollapsedEdge();
    public bool get_Isolated();
    public void set_Isolated(bool value);
    public virtual bool get_IsIsolated();
    public void AddIntersections(LineIntersector li, int segmentIndex, int geomIndex);
    public void AddIntersection(LineIntersector li, int segmentIndex, int geomIndex, int intIndex);
    public virtual void ComputeIM(IntersectionMatrix im);
    public virtual bool Equals(object o);
    protected bool Equals(Edge e);
    public static bool op_Equality(Edge obj1, Edge obj2);
    public static bool op_Inequality(Edge obj1, Edge obj2);
    public virtual int GetHashCode();
    public bool IsPointwiseEqual(Edge e);
    public virtual string ToString();
    public void Write(TextWriter outstream);
    public void WriteReverse(TextWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.EdgeEnd : object {
    private Label _label;
    private Coordinate _p0;
    private Coordinate _p1;
    private double _dx;
    private double _dy;
    private int _quadrant;
    [CompilerGeneratedAttribute]
private Edge <Edge>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Node>k__BackingField;
    public Edge Edge { get; protected set; }
    public Label Label { get; protected set; }
    public Coordinate Coordinate { get; }
    public Coordinate DirectedCoordinate { get; }
    public int Quadrant { get; }
    public double Dx { get; }
    public double Dy { get; }
    public Node Node { get; public set; }
    protected EdgeEnd(Edge edge);
    public EdgeEnd(Edge edge, Coordinate p0, Coordinate p1);
    public EdgeEnd(Edge edge, Coordinate p0, Coordinate p1, Label label);
    protected void Init(Coordinate p0, Coordinate p1);
    [CompilerGeneratedAttribute]
public Edge get_Edge();
    [CompilerGeneratedAttribute]
protected void set_Edge(Edge value);
    public Label get_Label();
    protected void set_Label(Label value);
    public Coordinate get_Coordinate();
    public Coordinate get_DirectedCoordinate();
    public int get_Quadrant();
    public double get_Dx();
    public double get_Dy();
    [CompilerGeneratedAttribute]
public Node get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(Node value);
    public sealed virtual int CompareTo(EdgeEnd e);
    public int CompareDirection(EdgeEnd e);
    public virtual void ComputeLabel(IBoundaryNodeRule boundaryNodeRule);
    public virtual void Write(StreamWriter outstream);
    public virtual string ToString();
}
public abstract class NetTopologySuite.GeometriesGraph.EdgeEndStar : object {
    protected IDictionary`2<EdgeEnd, EdgeEnd> edgeMap;
    protected IList`1<EdgeEnd> edgeList;
    private Location[] _ptInAreaLocation;
    public Coordinate Coordinate { get; }
    public int Degree { get; }
    public IList`1<EdgeEnd> Edges { get; }
    public abstract virtual void Insert(EdgeEnd e);
    protected void InsertEdgeEnd(EdgeEnd e, EdgeEnd obj);
    public Coordinate get_Coordinate();
    public int get_Degree();
    public IEnumerator`1<EdgeEnd> GetEnumerator();
    public IList`1<EdgeEnd> get_Edges();
    public EdgeEnd GetNextCW(EdgeEnd ee);
    public virtual void ComputeLabelling(GeometryGraph[] geomGraph);
    private void ComputeEdgeEndLabels(IBoundaryNodeRule boundaryNodeRule);
    private Location GetLocation(int geomIndex, Coordinate p, GeometryGraph[] geom);
    public bool IsAreaLabelsConsistent(GeometryGraph geometryGraph);
    private bool CheckAreaLabelsConsistent(int geomIndex);
    public void PropagateSideLabels(int geomIndex);
    public int FindIndex(EdgeEnd eSearch);
    public virtual void Write(StreamWriter outstream);
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.EdgeIntersection : object {
    private Coordinate _coordinate;
    private int _segmentIndex;
    private double _distance;
    public Coordinate Coordinate { get; }
    public int SegmentIndex { get; }
    public double Distance { get; }
    public EdgeIntersection(Coordinate coord, int segmentIndex, double dist);
    public Coordinate get_Coordinate();
    public int get_SegmentIndex();
    public double get_Distance();
    public sealed virtual int CompareTo(object obj);
    public int Compare(int segmentIndex, double dist);
    public bool IsEndPoint(int maxSegmentIndex);
    public void Write(StreamWriter outstream);
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.EdgeIntersectionList : object {
    private IDictionary`2<EdgeIntersection, EdgeIntersection> nodeMap;
    private Edge edge;
    public int Count { get; }
    public EdgeIntersectionList(Edge edge);
    public int get_Count();
    public EdgeIntersection Add(Coordinate intPt, int segmentIndex, double dist);
    public IEnumerator`1<EdgeIntersection> GetEnumerator();
    public bool IsIntersection(Coordinate pt);
    public void AddEndpoints();
    public void AddSplitEdges(IList`1<Edge> edgeList);
    public Edge CreateSplitEdge(EdgeIntersection ei0, EdgeIntersection ei1);
    public void Write(StreamWriter outstream);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.GeometriesGraph.EdgeList : object {
    private List`1<Edge> _edges;
    private IDictionary`2<OrientedCoordinateArray, Edge> _ocaMap;
    public IList`1<Edge> Edges { get; }
    public Edge Item { get; }
    public void Remove(Edge e);
    public void Add(Edge e);
    public void AddAll(IEnumerable`1<Edge> edgeColl);
    public IList`1<Edge> get_Edges();
    public Edge FindEqualEdge(Edge e);
    public IEnumerator`1<Edge> GetEnumerator();
    public Edge get_Item(int index);
    public Edge Get(int i);
    public int FindEdgeIndex(Edge e);
    public void Write(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.EdgeNodingValidator : object {
    private FastNodingValidator _nv;
    public EdgeNodingValidator(IEnumerable`1<Edge> edges);
    public static void CheckValid(IEnumerable`1<Edge> edges);
    public static IEnumerable`1<ISegmentString> ToSegmentStrings(IEnumerable`1<Edge> edges);
    public void CheckValid();
}
public abstract class NetTopologySuite.GeometriesGraph.EdgeRing : object {
    protected DirectedEdge startDe;
    private int _maxNodeDegree;
    private List`1<DirectedEdge> _edges;
    private List`1<Coordinate> _pts;
    private Label _label;
    private ILinearRing _ring;
    private bool _isHole;
    private EdgeRing _shell;
    private List`1<EdgeRing> _holes;
    private IGeometryFactory _geometryFactory;
    protected IGeometryFactory GeometryFactory { get; }
    public bool IsIsolated { get; }
    public bool IsHole { get; }
    public ILinearRing LinearRing { get; }
    public Label Label { get; }
    public bool IsShell { get; }
    public EdgeRing Shell { get; public set; }
    public IList`1<DirectedEdge> Edges { get; }
    public int MaxNodeDegree { get; }
    protected EdgeRing(DirectedEdge start, IGeometryFactory geometryFactory);
    protected IGeometryFactory get_GeometryFactory();
    public bool get_IsIsolated();
    public bool get_IsHole();
    public Coordinate GetCoordinate(int i);
    public ILinearRing get_LinearRing();
    public Label get_Label();
    public bool get_IsShell();
    public EdgeRing get_Shell();
    public void set_Shell(EdgeRing value);
    public void AddHole(EdgeRing ring);
    public IPolygon ToPolygon(IGeometryFactory geometryFactory);
    public void ComputeRing();
    public abstract virtual DirectedEdge GetNext(DirectedEdge de);
    public abstract virtual void SetEdgeRing(DirectedEdge de, EdgeRing er);
    public IList`1<DirectedEdge> get_Edges();
    protected void ComputePoints(DirectedEdge start);
    public int get_MaxNodeDegree();
    private void ComputeMaxNodeDegree();
    public void SetInResult();
    protected void MergeLabel(Label deLabel);
    protected void MergeLabel(Label deLabel, int geomIndex);
    protected void AddPoints(Edge edge, bool isForward, bool isFirstEdge);
    public bool ContainsPoint(Coordinate p);
}
public class NetTopologySuite.GeometriesGraph.GeometryGraph : PlanarGraph {
    private IGeometry _parentGeom;
    private IDictionary`2<ILineString, Edge> _lineEdgeMap;
    private IBoundaryNodeRule _boundaryNodeRule;
    private bool _useBoundaryDeterminationRule;
    private int _argIndex;
    private IList`1<Node> _boundaryNodes;
    private bool _hasTooFewPoints;
    private Coordinate _invalidPoint;
    private IPointOnGeometryLocator _areaPtLocator;
    private PointLocator _ptLocator;
    public bool HasTooFewPoints { get; }
    public Coordinate InvalidPoint { get; }
    public IGeometry Geometry { get; }
    public IBoundaryNodeRule BoundaryNodeRule { get; }
    public IList`1<Node> BoundaryNodes { get; }
    public GeometryGraph(int argIndex, IGeometry parentGeom);
    public GeometryGraph(int argIndex, IGeometry parentGeom, IBoundaryNodeRule boundaryNodeRule);
    public static Location DetermineBoundary(IBoundaryNodeRule boundaryNodeRule, int boundaryCount);
    private static EdgeSetIntersector CreateEdgeSetIntersector();
    public bool get_HasTooFewPoints();
    public Coordinate get_InvalidPoint();
    public IGeometry get_Geometry();
    public IBoundaryNodeRule get_BoundaryNodeRule();
    public IList`1<Node> get_BoundaryNodes();
    public Coordinate[] GetBoundaryPoints();
    public Edge FindEdge(ILineString line);
    public void ComputeSplitEdges(IList`1<Edge> edgelist);
    private void Add(IGeometry g);
    private void AddCollection(IGeometryCollection gc);
    private void AddPoint(IPoint p);
    private void AddPolygonRing(ILinearRing lr, Location cwLeft, Location cwRight);
    private void AddPolygon(IPolygon p);
    private void AddLineString(ILineString line);
    public void AddEdge(Edge e);
    public void AddPoint(Coordinate pt);
    public SegmentIntersector ComputeSelfNodes(LineIntersector li, bool computeRingSelfNodes);
    public SegmentIntersector ComputeSelfNodes(LineIntersector li, bool computeRingSelfNodes, bool isDoneIfProperInt);
    public SegmentIntersector ComputeEdgeIntersections(GeometryGraph g, LineIntersector li, bool includeProper);
    private void InsertPoint(int argIndex, Coordinate coord, Location onLocation);
    private void InsertBoundaryPoint(int argIndex, Coordinate coord);
    private void AddSelfIntersectionNodes(int argIndex);
    private void AddSelfIntersectionNode(int argIndex, Coordinate coord, Location loc);
    public Location Locate(Coordinate pt);
}
public abstract class NetTopologySuite.GeometriesGraph.GraphComponent : object {
    private Label _label;
    private bool _isCovered;
    private bool _isCoveredSet;
    private bool _isVisited;
    [CompilerGeneratedAttribute]
private bool <InResult>k__BackingField;
    public Label Label { get; protected internal set; }
    public bool InResult { get; public set; }
    public bool IsInResult { get; }
    public bool Covered { get; public set; }
    public bool IsCovered { get; }
    public bool IsCoveredSet { get; }
    public bool Visited { get; public set; }
    public bool IsVisited { get; }
    public Coordinate Coordinate { get; protected set; }
    public bool IsIsolated { get; }
    protected GraphComponent(Label label);
    public Label get_Label();
    protected internal void set_Label(Label value);
    [CompilerGeneratedAttribute]
public bool get_InResult();
    [CompilerGeneratedAttribute]
public void set_InResult(bool value);
    public bool get_IsInResult();
    public bool get_Covered();
    public void set_Covered(bool value);
    public bool get_IsCovered();
    public bool get_IsCoveredSet();
    public bool get_Visited();
    public void set_Visited(bool value);
    public bool get_IsVisited();
    public abstract virtual Coordinate get_Coordinate();
    protected abstract virtual void set_Coordinate(Coordinate value);
    public abstract virtual void ComputeIM(IntersectionMatrix im);
    public abstract virtual bool get_IsIsolated();
    public void UpdateIM(IntersectionMatrix im);
}
public abstract class NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector : object {
    public abstract virtual void ComputeIntersections(IList`1<Edge> edges, SegmentIntersector si, bool testAllSegments);
    public abstract virtual void ComputeIntersections(IList`1<Edge> edges0, IList`1<Edge> edges1, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.MonotoneChain : object {
    private MonotoneChainEdge mce;
    private int chainIndex;
    public MonotoneChain(MonotoneChainEdge mce, int chainIndex);
    public void ComputeIntersections(MonotoneChain mc, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge : object {
    private Edge e;
    private Coordinate[] pts;
    private Int32[] startIndex;
    public Coordinate[] Coordinates { get; }
    public Int32[] StartIndexes { get; }
    public MonotoneChainEdge(Edge e);
    public Coordinate[] get_Coordinates();
    public Int32[] get_StartIndexes();
    public double GetMinX(int chainIndex);
    public double GetMaxX(int chainIndex);
    public void ComputeIntersects(MonotoneChainEdge mce, SegmentIntersector si);
    public void ComputeIntersectsForChain(int chainIndex0, MonotoneChainEdge mce, int chainIndex1, SegmentIntersector si);
    private void ComputeIntersectsForChain(int start0, int end0, MonotoneChainEdge mce, int start1, int end1, SegmentIntersector ei);
    private bool Overlaps(int start0, int end0, MonotoneChainEdge mce, int start1, int end1);
}
public class NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer : object {
    [ObsoleteAttribute("Use List<int>.ToArray()")]
public static Int32[] ToIntArray(IList`1<int> list);
    public Int32[] GetChainStartIndices(Coordinate[] pts);
    private static int FindChainEnd(Coordinate[] pts, int start);
}
public class NetTopologySuite.GeometriesGraph.Index.SegmentIntersector : object {
    private bool _hasIntersection;
    private bool _hasProper;
    private bool _hasProperInterior;
    private Coordinate _properIntersectionPoint;
    private LineIntersector _li;
    private bool _includeProper;
    private bool _recordIsolated;
    private int _numIntersections;
    public int NumTests;
    private IList`1[] _bdyNodes;
    private bool _isDone;
    private bool _isDoneWhenProperInt;
    unknown bool IsDoneIfProperInt {public set; }
    public bool IsDone { get; }
    public Coordinate ProperIntersectionPoint { get; }
    public bool HasIntersection { get; }
    public bool HasProperIntersection { get; }
    public bool HasProperInteriorIntersection { get; }
    public SegmentIntersector(LineIntersector li, bool includeProper, bool recordIsolated);
    public static bool IsAdjacentSegments(int i1, int i2);
    public void SetBoundaryNodes(IList`1<Node> bdyNodes0, IList`1<Node> bdyNodes1);
    public void set_IsDoneIfProperInt(bool value);
    public bool get_IsDone();
    public Coordinate get_ProperIntersectionPoint();
    public bool get_HasIntersection();
    public bool get_HasProperIntersection();
    public bool get_HasProperInteriorIntersection();
    private bool IsTrivialIntersection(Edge e0, int segIndex0, Edge e1, int segIndex1);
    public void AddIntersections(Edge e0, int segIndex0, Edge e1, int segIndex1);
    private static bool IsBoundaryPoint(LineIntersector li, IList`1[] bdyNodes);
    private static bool IsBoundaryPointInternal(LineIntersector li, IEnumerable`1<Node> bdyNodes);
}
public class NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector : EdgeSetIntersector {
    public virtual void ComputeIntersections(IList`1<Edge> edges, SegmentIntersector si, bool testAllSegments);
    public virtual void ComputeIntersections(IList`1<Edge> edges0, IList`1<Edge> edges1, SegmentIntersector si);
    private static void ComputeIntersects(Edge e0, Edge e1, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector : EdgeSetIntersector {
    private List`1<SweepLineEvent> _events;
    private int _nOverlaps;
    public virtual void ComputeIntersections(IList`1<Edge> edges, SegmentIntersector si, bool testAllSegments);
    public virtual void ComputeIntersections(IList`1<Edge> edges0, IList`1<Edge> edges1, SegmentIntersector si);
    private void AddEdges(IEnumerable`1<Edge> edges);
    private void AddEdges(IEnumerable`1<Edge> edges, object edgeSet);
    private void AddEdge(Edge edge, object edgeSet);
    private void PrepareEvents();
    private void ComputeIntersections(SegmentIntersector si);
    private void ProcessOverlaps(int start, int end, SweepLineEvent ev0, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector : EdgeSetIntersector {
    private List`1<SweepLineEvent> _events;
    private int _nOverlaps;
    public virtual void ComputeIntersections(IList`1<Edge> edges, SegmentIntersector si, bool testAllSegments);
    public virtual void ComputeIntersections(IList`1<Edge> edges0, IList`1<Edge> edges1, SegmentIntersector si);
    private void Add(IEnumerable`1<Edge> edges);
    private void Add(IEnumerable`1<Edge> edges, object edgeSet);
    private void Add(Edge edge, object edgeSet);
    private void PrepareEvents();
    private void ComputeIntersections(SegmentIntersector si);
    private void ProcessOverlaps(int start, int end, SweepLineEvent ev0, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.SweepLineEvent : object {
    private static int Insert;
    private static int Delete;
    private object _label;
    private double _xValue;
    private int _eventType;
    private SweepLineEvent _insertEvent;
    private int _deleteEventIndex;
    private object _obj;
    public bool IsInsert { get; }
    public bool IsDelete { get; }
    public SweepLineEvent InsertEvent { get; }
    public int DeleteEventIndex { get; public set; }
    public object Object { get; }
    public SweepLineEvent(object label, double x, object obj);
    public SweepLineEvent(double x, SweepLineEvent insertEvent);
    public bool get_IsInsert();
    public bool get_IsDelete();
    public SweepLineEvent get_InsertEvent();
    public int get_DeleteEventIndex();
    public void set_DeleteEventIndex(int value);
    public object get_Object();
    public bool IsSameLabel(SweepLineEvent ev);
    public sealed virtual int CompareTo(object o);
}
public class NetTopologySuite.GeometriesGraph.Index.SweepLineSegment : object {
    private Edge edge;
    private Coordinate[] pts;
    private int ptIndex;
    public double MinX { get; }
    public double MaxX { get; }
    public SweepLineSegment(Edge edge, int ptIndex);
    public double get_MinX();
    public double get_MaxX();
    public void ComputeIntersections(SweepLineSegment ss, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Label : object {
    private TopologyLocation[] elt;
    public int GeometryCount { get; }
    public Label(Location onLoc);
    public Label(int geomIndex, Location onLoc);
    public Label(Location onLoc, Location leftLoc, Location rightLoc);
    public Label(int geomIndex, Location onLoc, Location leftLoc, Location rightLoc);
    public Label(Label lbl);
    public static Label ToLineLabel(Label label);
    public void Flip();
    public Location GetLocation(int geomIndex, Positions posIndex);
    public Location GetLocation(int geomIndex);
    public void SetLocation(int geomIndex, Positions posIndex, Location _location);
    public void SetLocation(int geomIndex, Location _location);
    public void SetAllLocations(int geomIndex, Location _location);
    public void SetAllLocationsIfNull(int geomIndex, Location _location);
    public void SetAllLocationsIfNull(Location _location);
    public void Merge(Label lbl);
    private void SetGeometryLocation(int geomIndex, TopologyLocation tl);
    public int get_GeometryCount();
    public bool IsNull(int geomIndex);
    public bool IsAnyNull(int geomIndex);
    public bool IsArea();
    public bool IsArea(int geomIndex);
    public bool IsLine(int geomIndex);
    public bool IsEqualOnSide(Label lbl, int side);
    public bool AllPositionsEqual(int geomIndex, Location loc);
    public void ToLine(int geomIndex);
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.Node : GraphComponent {
    private Coordinate _coord;
    private EdgeEndStar _edges;
    public Coordinate Coordinate { get; protected set; }
    public EdgeEndStar Edges { get; protected set; }
    public bool IsIsolated { get; }
    public Node(Coordinate coord, EdgeEndStar edges);
    public virtual Coordinate get_Coordinate();
    protected virtual void set_Coordinate(Coordinate value);
    public EdgeEndStar get_Edges();
    protected void set_Edges(EdgeEndStar value);
    public bool IsIncidentEdgeInResult();
    public virtual bool get_IsIsolated();
    public virtual void ComputeIM(IntersectionMatrix im);
    public void Add(EdgeEnd e);
    public void MergeLabel(Node n);
    public void MergeLabel(Label label2);
    public void SetLabel(int argIndex, Location onLocation);
    public void SetLabelBoundary(int argIndex);
    public Location ComputeMergedLocation(Label label2, int eltIndex);
    public void Write(TextWriter outstream);
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.NodeFactory : object {
    public virtual Node CreateNode(Coordinate coord);
}
public class NetTopologySuite.GeometriesGraph.NodeMap : object {
    private IDictionary`2<Coordinate, Node> _nodeMap;
    private NodeFactory _nodeFact;
    public IList`1<Node> Values { get; }
    public NodeMap(NodeFactory nodeFact);
    public Node AddNode(Coordinate coord);
    public Node AddNode(Node n);
    public void Add(EdgeEnd e);
    public Node Find(Coordinate coord);
    public IEnumerator`1<Node> GetEnumerator();
    public IList`1<Node> get_Values();
    public IList`1<Node> GetBoundaryNodes(int geomIndex);
    public void Write(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.PlanarGraph : object {
    private List`1<Edge> _edges;
    private NodeMap _nodes;
    protected IList`1<EdgeEnd> edgeEndList;
    public IList`1<EdgeEnd> EdgeEnds { get; }
    protected internal IList`1<Edge> Edges { get; }
    public IList`1<Node> Nodes { get; }
    protected NodeMap NodeMap { get; }
    public PlanarGraph(NodeFactory nodeFact);
    public static void LinkResultDirectedEdges(IList`1<Node> nodes);
    public IEnumerator`1<Edge> GetEdgeEnumerator();
    public IList`1<EdgeEnd> get_EdgeEnds();
    protected internal IList`1<Edge> get_Edges();
    public bool IsBoundaryNode(int geomIndex, Coordinate coord);
    protected void InsertEdge(Edge e);
    public void Add(EdgeEnd e);
    public IEnumerator`1<Node> GetNodeEnumerator();
    public IList`1<Node> get_Nodes();
    protected NodeMap get_NodeMap();
    public Node AddNode(Node node);
    public Node AddNode(Coordinate coord);
    public Node Find(Coordinate coord);
    public void AddEdges(IList`1<Edge> edgesToAdd);
    public void LinkResultDirectedEdges();
    public void LinkAllDirectedEdges();
    public EdgeEnd FindEdgeEnd(Edge e);
    public Edge FindEdge(Coordinate p0, Coordinate p1);
    public Edge FindEdgeInSameDirection(Coordinate p0, Coordinate p1);
    private static bool MatchInSameDirection(Coordinate p0, Coordinate p1, Coordinate ep0, Coordinate ep1);
    public void WriteEdges(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.Position : object {
    public static Positions Opposite(Positions position);
}
public enum NetTopologySuite.GeometriesGraph.Positions : Enum {
    public int value__;
    public static Positions On;
    public static Positions Left;
    public static Positions Right;
    public static Positions Parallel;
}
public class NetTopologySuite.GeometriesGraph.QuadrantOp : object {
    public static int NE;
    public static int NW;
    public static int SW;
    public static int SE;
    private static QuadrantOp();
    public static int Quadrant(double dx, double dy);
    public static int Quadrant(Coordinate p0, Coordinate p1);
    public static bool IsOpposite(int quad1, int quad2);
    public static int CommonHalfPlane(int quad1, int quad2);
    public static bool IsInHalfPlane(int quad, int halfPlane);
    public static bool IsNorthern(int quad);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.GeometriesGraph.TopologyLocation : object {
    private Location[] _location;
    public Location Item { get; public set; }
    public bool IsNull { get; }
    public bool IsAnyNull { get; }
    public bool IsArea { get; }
    public bool IsLine { get; }
    public TopologyLocation(Location[] location);
    public TopologyLocation(Location on, Location left, Location right);
    public TopologyLocation(Location on);
    public TopologyLocation(TopologyLocation gl);
    private void Init(int size);
    public Location Get(Positions posIndex);
    public Location get_Item(Positions posIndex);
    public void set_Item(Positions posIndex, Location value);
    public bool get_IsNull();
    public bool get_IsAnyNull();
    public bool IsEqualOnSide(TopologyLocation le, int locIndex);
    public bool get_IsArea();
    public bool get_IsLine();
    public void Flip();
    public void SetAllLocations(Location locValue);
    public void SetAllLocationsIfNull(Location locValue);
    public void SetLocation(Positions locIndex, Location locValue);
    public void SetLocation(Location locValue);
    public Location[] GetLocations();
    public void SetLocations(Location on, Location left, Location right);
    public void SetLocations(TopologyLocation gl);
    public bool AllPositionsEqual(Location loc);
    public void Merge(TopologyLocation gl);
    public virtual string ToString();
}
public class NetTopologySuite.Index.ArrayListVisitor : ArrayListVisitor`1<object> {
}
public class NetTopologySuite.Index.ArrayListVisitor`1 : object {
    private List`1<T> _items;
    public IList`1<T> Items { get; }
    public sealed virtual void VisitItem(T item);
    public IList`1<T> get_Items();
}
public class NetTopologySuite.Index.Bintree.Bintree : Bintree`1<object> {
}
public class NetTopologySuite.Index.Bintree.Bintree`1 : object {
    private Root`1<T> _root;
    private double _minExtent;
    public int Depth { get; }
    public int Count { get; }
    public int NodeSize { get; }
    public static Interval EnsureExtent(Interval itemInterval, double minExtent);
    public int get_Depth();
    public int get_Count();
    public int get_NodeSize();
    public void Insert(Interval itemInterval, T item);
    public bool Remove(Interval itemInterval, T item);
    public IEnumerator`1<T> GetEnumerator();
    public IList`1<T> Query(double x);
    public IList`1<T> Query(Interval interval);
    public void Query(Interval interval, ICollection`1<T> foundItems);
    private void CollectStats(Interval interval);
}
public class NetTopologySuite.Index.Bintree.Interval : object {
    private double _min;
    private double _max;
    public double Min { get; public set; }
    public double Max { get; public set; }
    public double Width { get; }
    public double Centre { get; }
    public Interval(double min, double max);
    public Interval(Interval interval);
    public double get_Min();
    public void set_Min(double value);
    public double get_Max();
    public void set_Max(double value);
    public double get_Width();
    public double get_Centre();
    public void Init(double min, double max);
    public void ExpandToInclude(Interval interval);
    public bool Overlaps(Interval interval);
    public bool Overlaps(double min, double max);
    public bool Contains(Interval interval);
    public bool Contains(double min, double max);
    public bool Contains(double p);
}
public class NetTopologySuite.Index.Bintree.Key : object {
    private double _pt;
    private int _level;
    private Interval _interval;
    public double Point { get; }
    public int Level { get; }
    public Interval Interval { get; }
    public Key(Interval interval);
    public static int ComputeLevel(Interval interval);
    public double get_Point();
    public int get_Level();
    public Interval get_Interval();
    public void ComputeKey(Interval itemInterval);
    private void ComputeInterval(int level, Interval itemInterval);
}
public class NetTopologySuite.Index.Bintree.Node`1 : NodeBase`1<T> {
    private Interval _interval;
    private double _centre;
    private int _level;
    public Interval Interval { get; }
    public Node`1(Interval interval, int level);
    public static Node`1<T> CreateNode(Interval itemInterval);
    public static Node`1<T> CreateExpanded(Node`1<T> node, Interval addInterval);
    public Interval get_Interval();
    protected virtual bool IsSearchMatch(Interval itemInterval);
    public Node`1<T> GetNode(Interval searchInterval);
    public NodeBase`1<T> Find(Interval searchInterval);
    public void Insert(Node`1<T> node);
    private Node`1<T> GetSubnode(int index);
    private Node`1<T> CreateSubnode(int index);
}
public abstract class NetTopologySuite.Index.Bintree.NodeBase`1 : object {
    private IList`1<T> _items;
    protected Node`1[] Subnode;
    public IList`1<T> Items { get; protected set; }
    public bool IsPrunable { get; }
    public bool HasChildren { get; }
    public bool HasItems { get; }
    public int Depth { get; }
    public int Count { get; }
    public int NodeCount { get; }
    public static int GetSubnodeIndex(Interval interval, double centre);
    public IList`1<T> get_Items();
    protected void set_Items(IList`1<T> value);
    public void Add(T item);
    public IList`1<T> AddAllItems(IList`1<T> items);
    protected abstract virtual bool IsSearchMatch(Interval interval);
    public void AddAllItemsFromOverlapping(Interval interval, ICollection`1<T> resultItems);
    public bool Remove(Interval itemInterval, T item);
    public bool get_IsPrunable();
    public bool get_HasChildren();
    public bool get_HasItems();
    public int get_Depth();
    public int get_Count();
    public int get_NodeCount();
}
public class NetTopologySuite.Index.Bintree.Root`1 : NodeBase`1<T> {
    private static double Origin;
    public void Insert(Interval itemInterval, T item);
    private static void InsertContained(Node`1<T> tree, Interval itemInterval, T item);
    protected virtual bool IsSearchMatch(Interval interval);
}
public class NetTopologySuite.Index.Chain.MonotoneChain : object {
    private Coordinate[] _pts;
    private int _start;
    private int _end;
    private Envelope _env;
    private object _context;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public int Id { get; public set; }
    public object Context { get; }
    public Envelope Envelope { get; }
    public int StartIndex { get; }
    public int EndIndex { get; }
    public Coordinate[] Coordinates { get; }
    public MonotoneChain(Coordinate[] pts, int start, int end, object context);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    public object get_Context();
    public Envelope get_Envelope();
    public int get_StartIndex();
    public int get_EndIndex();
    public void GetLineSegment(int index, LineSegment& ls);
    public Coordinate[] get_Coordinates();
    public void Select(Envelope searchEnv, MonotoneChainSelectAction mcs);
    private void ComputeSelect(Envelope searchEnv, int start0, int end0, MonotoneChainSelectAction mcs);
    public void ComputeOverlaps(MonotoneChain mc, MonotoneChainOverlapAction mco);
    private void ComputeOverlaps(int start0, int end0, MonotoneChain mc, int start1, int end1, MonotoneChainOverlapAction mco);
    private bool Overlaps(int start0, int end0, MonotoneChain mc, int start1, int end1);
}
public class NetTopologySuite.Index.Chain.MonotoneChainBuilder : object {
    public static Int32[] ToIntArray(IList`1<int> list);
    public static IList`1<MonotoneChain> GetChains(Coordinate[] pts);
    public static IList`1<MonotoneChain> GetChains(Coordinate[] pts, object context);
    public static Int32[] GetChainStartIndices(Coordinate[] pts);
    private static int FindChainEnd(Coordinate[] pts, int start);
}
public class NetTopologySuite.Index.Chain.MonotoneChainOverlapAction : object {
    protected LineSegment overlapSeg1;
    protected LineSegment overlapSeg2;
    public virtual void Overlap(MonotoneChain mc1, int start1, MonotoneChain mc2, int start2);
    public virtual void Overlap(LineSegment seg1, LineSegment seg2);
}
public class NetTopologySuite.Index.Chain.MonotoneChainSelectAction : object {
    public LineSegment SelectedSegment;
    public virtual void Select(MonotoneChain mc, int startIndex);
    public virtual void Select(LineSegment seg);
}
public interface NetTopologySuite.Index.IIndexVisitor {
    public abstract virtual void VisitItem(object item);
}
public interface NetTopologySuite.Index.IItemVisitor`1 {
    public abstract virtual void VisitItem(T item);
}
public class NetTopologySuite.Index.IntervalRTree.IntervalRTreeBranchNode`1 : IntervalRTreeNode`1<T> {
    private IntervalRTreeNode`1<T> _node1;
    private IntervalRTreeNode`1<T> _node2;
    public IntervalRTreeBranchNode`1(IntervalRTreeNode`1<T> n1, IntervalRTreeNode`1<T> n2);
    private void BuildExtent(IntervalRTreeNode`1<T> n1, IntervalRTreeNode`1<T> n2);
    public virtual void Query(double queryMin, double queryMax, IItemVisitor`1<T> visitor);
}
public class NetTopologySuite.Index.IntervalRTree.IntervalRTreeLeafNode`1 : IntervalRTreeNode`1<T> {
    private T _item;
    public IntervalRTreeLeafNode`1(double min, double max, T item);
    public virtual void Query(double queryMin, double queryMax, IItemVisitor`1<T> visitor);
}
public abstract class NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode`1 : object {
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    public double Min { get; protected set; }
    public double Max { get; protected set; }
    protected IntervalRTreeNode`1(double min, double max);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
protected void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
protected void set_Max(double value);
    public abstract virtual void Query(double queryMin, double queryMax, IItemVisitor`1<T> visitor);
    protected bool Intersects(double queryMin, double queryMax);
    public virtual string ToString();
}
public class NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree`1 : object {
    private object _leavesLock;
    private List`1<IntervalRTreeNode`1<T>> _leaves;
    private IntervalRTreeNode`1 modreq(System.Runtime.CompilerServices.IsVolatile) _root;
    public void Insert(double min, double max, T item);
    private void Init();
    private IntervalRTreeNode`1<T> BuildTree();
    private static void BuildLevel(List`1<IntervalRTreeNode`1<T>> src, List`1<IntervalRTreeNode`1<T>> dest, Int32& level);
    public void Query(double min, double max, IItemVisitor`1<T> visitor);
}
public interface NetTopologySuite.Index.ISpatialIndex {
}
public interface NetTopologySuite.Index.ISpatialIndex`1 {
    public abstract virtual void Insert(Envelope itemEnv, T item);
    public abstract virtual IList`1<T> Query(Envelope searchEnv);
    public abstract virtual void Query(Envelope searchEnv, IItemVisitor`1<T> visitor);
    public abstract virtual bool Remove(Envelope itemEnv, T item);
}
public interface NetTopologySuite.Index.KdTree.IKdNodeVisitor`1 {
    public abstract virtual void Visit(KdNode`1<T> node);
}
public class NetTopologySuite.Index.KdTree.KdNode`1 : object {
    private Coordinate _p;
    private T _data;
    private int _count;
    [CompilerGeneratedAttribute]
private KdNode`1<T> <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private KdNode`1<T> <Right>k__BackingField;
    public double X { get; }
    public double Y { get; }
    public Coordinate Coordinate { get; }
    public T Data { get; }
    public KdNode`1<T> Left { get; public set; }
    public KdNode`1<T> Right { get; public set; }
    public int Count { get; }
    public bool IsRepeated { get; }
    public KdNode`1(double x, double y, T data);
    public KdNode`1(Coordinate p, T data);
    public double get_X();
    public double get_Y();
    public Coordinate get_Coordinate();
    public T get_Data();
    [CompilerGeneratedAttribute]
public KdNode`1<T> get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(KdNode`1<T> value);
    [CompilerGeneratedAttribute]
public KdNode`1<T> get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(KdNode`1<T> value);
    internal void Increment();
    public int get_Count();
    public bool get_IsRepeated();
}
public class NetTopologySuite.Index.KdTree.KdTree`1 : object {
    private KdNode`1<T> _root;
    private long _numberOfNodes;
    private double _tolerance;
    public bool IsEmpty { get; }
    internal KdNode`1<T> Root { get; }
    public KdTree`1(double tolerance);
    public static Coordinate[] ToCoordinates(ICollection`1<KdNode`1<T>> kdnodes);
    public static Coordinate[] ToCoordinates(ICollection`1<KdNode`1<T>> kdnodes, bool includeRepeated);
    public bool get_IsEmpty();
    internal KdNode`1<T> get_Root();
    public KdNode`1<T> Insert(Coordinate p);
    public KdNode`1<T> Insert(Coordinate p, T data);
    private KdNode`1<T> FindBestMatchNode(Coordinate p);
    public KdNode`1<T> InsertExact(Coordinate p, T data);
    private static void QueryNode(KdNode`1<T> currentNode, Envelope queryEnv, bool odd, IKdNodeVisitor`1<T> visitor);
    public void Query(Envelope queryEnv, IKdNodeVisitor`1<T> visitor);
    public IList`1<KdNode`1<T>> Query(Envelope queryEnv);
    public void Query(Envelope queryEnv, IList`1<KdNode`1<T>> result);
}
[ExtensionAttribute]
public static class NetTopologySuite.Index.KdTree.KdTreeExtensions : object {
    [ExtensionAttribute]
public static KdNode`1<T> NearestNeighbor(KdTree`1<T> self, Coordinate coord);
    private static void NearestNeighbor(KdNode`1<T> currentNode, Coordinate queryCoordinate, KdNode`1& closestNode, Double& closestDistanceSq, bool isOddLevel);
    private static bool NeedsToBeSearched(Coordinate target, KdNode`1<T> node, double closestDistSq, bool left, bool isOddLevel);
}
public class NetTopologySuite.Index.Quadtree.DoubleBits : object {
    public static int ExponentBias;
    private double x;
    private long _xBits;
    public double Double { get; }
    public int BiasedExponent { get; }
    public int Exponent { get; }
    public DoubleBits(double x);
    public static double PowerOf2(int exp);
    public static int GetExponent(double d);
    public static double TruncateToPowerOfTwo(double d);
    public static string ToBinaryString(double d);
    public static double MaximumCommonMantissa(double d1, double d2);
    public double get_Double();
    public int get_BiasedExponent();
    public int get_Exponent();
    public void ZeroLowerBits(int nBits);
    public int GetBit(int i);
    public int NumCommonMantissaBits(DoubleBits db);
    public virtual string ToString();
}
public class NetTopologySuite.Index.Quadtree.IntervalSize : object {
    public static int MinBinaryExponent;
    public static bool IsZeroWidth(double min, double max);
}
public class NetTopologySuite.Index.Quadtree.Key : object {
    private Coordinate _pt;
    private int _level;
    private Envelope _env;
    public Coordinate Point { get; }
    public int Level { get; }
    public Envelope Envelope { get; }
    public Coordinate Centre { get; }
    public Key(Envelope itemEnv);
    public static int ComputeQuadLevel(Envelope env);
    public Coordinate get_Point();
    public int get_Level();
    public Envelope get_Envelope();
    public Coordinate get_Centre();
    public void ComputeKey(Envelope itemEnv);
    private void ComputeKey(int level, Envelope itemEnv);
}
public class NetTopologySuite.Index.Quadtree.Node`1 : NodeBase`1<T> {
    private Envelope _env;
    private double _centreX;
    private double _centreY;
    private int _level;
    public Envelope Envelope { get; }
    public Node`1(Envelope env, int level);
    public static Node`1<T> CreateNode(Envelope env);
    public static Node`1<T> CreateExpanded(Node`1<T> node, Envelope addEnv);
    public Envelope get_Envelope();
    protected virtual bool IsSearchMatch(Envelope searchEnv);
    public Node`1<T> GetNode(Envelope searchEnv);
    public NodeBase`1<T> Find(Envelope searchEnv);
    public void InsertNode(Node`1<T> node);
    private Node`1<T> GetSubnode(int index);
    private Node`1<T> CreateSubnode(int index);
}
public abstract class NetTopologySuite.Index.Quadtree.NodeBase`1 : object {
    private List`1<T> _items;
    protected Node`1[] Subnode;
    public IList`1<T> Items { get; protected set; }
    public bool HasItems { get; }
    public bool IsPrunable { get; }
    public bool HasChildren { get; }
    public bool IsEmpty { get; }
    public int Depth { get; }
    public int Count { get; }
    public int NodeCount { get; }
    public static int GetSubnodeIndex(Envelope env, double centreX, double centreY);
    public IList`1<T> get_Items();
    protected void set_Items(IList`1<T> value);
    public bool get_HasItems();
    public void Add(T item);
    public bool Remove(Envelope itemEnv, T item);
    public bool get_IsPrunable();
    public bool get_HasChildren();
    public bool get_IsEmpty();
    public IList`1<T> AddAllItems(IList`1& resultItems);
    protected abstract virtual bool IsSearchMatch(Envelope searchEnv);
    public void AddAllItemsFromOverlapping(Envelope searchEnv, IList`1& resultItems);
    public void Visit(Envelope searchEnv, IItemVisitor`1<T> visitor);
    private void VisitItems(Envelope searchEnv, IItemVisitor`1<T> visitor);
    public int get_Depth();
    public int get_Count();
    public int get_NodeCount();
}
public class NetTopologySuite.Index.Quadtree.Quadtree`1 : object {
    private Root`1<T> _root;
    private double _minExtent;
    public int Depth { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public static Envelope EnsureExtent(Envelope itemEnv, double minExtent);
    public int get_Depth();
    public bool get_IsEmpty();
    public int get_Count();
    public sealed virtual void Insert(Envelope itemEnv, T item);
    public sealed virtual bool Remove(Envelope itemEnv, T item);
    public sealed virtual IList`1<T> Query(Envelope searchEnv);
    public sealed virtual void Query(Envelope searchEnv, IItemVisitor`1<T> visitor);
    public IList`1<T> QueryAll();
    private void CollectStats(Envelope itemEnv);
}
public class NetTopologySuite.Index.Quadtree.Root`1 : NodeBase`1<T> {
    private static Coordinate Origin;
    private static Root`1();
    public void Insert(Envelope itemEnv, T item);
    private static void InsertContained(Node`1<T> tree, Envelope itemEnv, T item);
    protected virtual bool IsSearchMatch(Envelope searchEnv);
}
public abstract class NetTopologySuite.Index.Strtree.AbstractNode`2 : object {
    private List`1<IBoundable`2<T, TItem>> _childBoundables;
    private T _bounds;
    private int _level;
    public IList`1<IBoundable`2<T, TItem>> ChildBoundables { get; }
    public T Bounds { get; }
    public TItem Item { get; }
    public int Level { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    protected AbstractNode`2(int level);
    public IList`1<IBoundable`2<T, TItem>> get_ChildBoundables();
    protected abstract virtual T ComputeBounds();
    public sealed virtual T get_Bounds();
    public sealed virtual TItem get_Item();
    public int get_Level();
    public int get_Count();
    public bool get_IsEmpty();
    public void AddChildBoundable(IBoundable`2<T, TItem> childBoundable);
}
public abstract class NetTopologySuite.Index.Strtree.AbstractSTRtree`2 : object {
    private object _buildLock;
    private AbstractNode`2 modreq(System.Runtime.CompilerServices.IsVolatile) _root;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _built;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _building;
    private List`1<IBoundable`2<T, TItem>> _itemBoundables;
    private int _nodeCapacity;
    public AbstractNode`2<T, TItem> Root { get; public set; }
    public int NodeCapacity { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public int Depth { get; }
    protected IIntersectsOp<T, TItem> IntersectsOp { get; }
    protected AbstractSTRtree`2(int nodeCapacity);
    public void Build();
    protected abstract virtual AbstractNode`2<T, TItem> CreateNode(int level);
    protected virtual IList`1<IBoundable`2<T, TItem>> CreateParentBoundables(IList`1<IBoundable`2<T, TItem>> childBoundables, int newLevel);
    protected AbstractNode`2<T, TItem> LastNode(IList`1<IBoundable`2<T, TItem>> nodes);
    protected static int CompareDoubles(double a, double b);
    private AbstractNode`2<T, TItem> CreateHigherLevels(IList`1<IBoundable`2<T, TItem>> boundablesOfALevel, int level);
    public AbstractNode`2<T, TItem> get_Root();
    public void set_Root(AbstractNode`2<T, TItem> value);
    public int get_NodeCapacity();
    public bool get_IsEmpty();
    public int get_Count();
    protected int GetSize(AbstractNode`2<T, TItem> node);
    public int get_Depth();
    protected int GetDepth(AbstractNode`2<T, TItem> node);
    protected void Insert(T bounds, TItem item);
    protected IList`1<TItem> Query(T searchBounds);
    protected void Query(T searchBounds, IItemVisitor`1<TItem> visitor);
    private void QueryInternal(T searchBounds, AbstractNode`2<T, TItem> node, IList`1<TItem> matches);
    private void QueryInternal(T searchBounds, AbstractNode`2<T, TItem> node, IItemVisitor`1<TItem> visitor);
    public IList`1<object> ItemsTree();
    private static IList`1<object> ItemsTree(AbstractNode`2<T, TItem> node);
    protected abstract virtual IIntersectsOp<T, TItem> get_IntersectsOp();
    protected bool Remove(T searchBounds, TItem item);
    private static bool RemoveItem(AbstractNode`2<T, TItem> node, TItem item);
    private bool Remove(T searchBounds, AbstractNode`2<T, TItem> node, TItem item);
    protected IList`1<IBoundable`2<T, TItem>> BoundablesAtLevel(int level);
    private static void BoundablesAtLevel(int level, AbstractNode`2<T, TItem> top, ICollection`1<IBoundable`2<T, TItem>> boundables);
    protected abstract virtual IComparer`1<IBoundable`2<T, TItem>> GetComparer();
}
internal class NetTopologySuite.Index.Strtree.BoundablePair`1 : object {
    private IBoundable`2<Envelope, TItem> _boundable1;
    private IBoundable`2<Envelope, TItem> _boundable2;
    private double _distance;
    private IItemDistance`2<Envelope, TItem> _itemDistance;
    public double Distance { get; }
    public bool IsLeaves { get; }
    public BoundablePair`1(IBoundable`2<Envelope, TItem> boundable1, IBoundable`2<Envelope, TItem> boundable2, IItemDistance`2<Envelope, TItem> itemDistance);
    public IBoundable`2<Envelope, TItem> GetBoundable(int i);
    private double GetDistance();
    public double get_Distance();
    public sealed virtual int CompareTo(BoundablePair`1<TItem> o);
    public bool get_IsLeaves();
    public static bool IsComposite(IBoundable`2<Envelope, TItem> item);
    public void ExpandToQueue(PriorityQueue`1<BoundablePair`1<TItem>> priQ, double minDistance);
    private void Expand(IBoundable`2<Envelope, TItem> bndComposite, IBoundable`2<Envelope, TItem> bndOther, PriorityQueue`1<BoundablePair`1<TItem>> priQ, double minDistance);
}
internal class NetTopologySuite.Index.Strtree.BoundablePairDistanceComparer`1 : object {
    private bool _normalOrder;
    public BoundablePairDistanceComparer`1(bool normalOrder);
    public sealed virtual int Compare(BoundablePair`1<TItem> p1, BoundablePair`1<TItem> p2);
}
public class NetTopologySuite.Index.Strtree.GeometryItemDistance : object {
    public sealed virtual double Distance(IBoundable`2<Envelope, IGeometry> item1, IBoundable`2<Envelope, IGeometry> item2);
}
[ObsoleteAttribute]
public interface NetTopologySuite.Index.Strtree.IBoundable {
    public object Bounds { get; }
    public abstract virtual object get_Bounds();
}
public interface NetTopologySuite.Index.Strtree.IItemDistance`2 {
    public abstract virtual double Distance(IBoundable`2<T, TItem> item1, IBoundable`2<T, TItem> item2);
}
public class NetTopologySuite.Index.Strtree.Interval : object {
    private double _min;
    private double _max;
    public double Centre { get; }
    public Interval(Interval other);
    public Interval(double min, double max);
    public double get_Centre();
    public sealed virtual void ExpandToInclude(Interval other);
    public sealed virtual Interval ExpandedBy(Interval other);
    public sealed virtual bool Intersects(Interval other);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class NetTopologySuite.Index.Strtree.ItemBoundable`2 : object {
    private T _bounds;
    private TItem _item;
    public T Bounds { get; }
    public TItem Item { get; }
    public ItemBoundable`2(T bounds, TItem item);
    public sealed virtual T get_Bounds();
    public sealed virtual TItem get_Item();
}
public class NetTopologySuite.Index.Strtree.SIRtree`1 : AbstractSTRtree`2<Interval, TItem> {
    private static IComparer`1<IBoundable`2<Interval, TItem>> Comparator;
    private static IIntersectsOp<Interval, TItem> IntersectsOperation;
    protected IIntersectsOp<Interval, TItem> IntersectsOp { get; }
    public SIRtree`1(int nodeCapacity);
    private static SIRtree`1();
    protected virtual AbstractNode`2<Interval, TItem> CreateNode(int level);
    public void Insert(double x1, double x2, TItem item);
    public IList`1<TItem> Query(double x);
    public IList`1<TItem> Query(double x1, double x2);
    protected virtual IIntersectsOp<Interval, TItem> get_IntersectsOp();
    protected virtual IComparer`1<IBoundable`2<Interval, TItem>> GetComparer();
}
public class NetTopologySuite.Index.Strtree.STRtree`1 : AbstractSTRtree`2<Envelope, TItem> {
    private static AnonymousXComparerImpl<TItem> XComparer;
    private static AnonymousYComparerImpl<TItem> YComparer;
    private static IIntersectsOp<Envelope, TItem> IntersectsOperation;
    private static int DefaultNodeCapacity;
    protected IIntersectsOp<Envelope, TItem> IntersectsOp { get; }
    public STRtree`1(int nodeCapacity);
    private static STRtree`1();
    private static double Avg(double a, double b);
    private static double CentreX(Envelope e);
    private static double CentreY(Envelope e);
    protected virtual IList`1<IBoundable`2<Envelope, TItem>> CreateParentBoundables(IList`1<IBoundable`2<Envelope, TItem>> childBoundables, int newLevel);
    private List`1<IBoundable`2<Envelope, TItem>> CreateParentBoundablesFromVerticalSlices(IList`1[] verticalSlices, int newLevel);
    protected IList`1<IBoundable`2<Envelope, TItem>> CreateParentBoundablesFromVerticalSlice(IList`1<IBoundable`2<Envelope, TItem>> childBoundables, int newLevel);
    protected IList`1[] VerticalSlices(IList`1<IBoundable`2<Envelope, TItem>> childBoundables, int sliceCount);
    protected virtual AbstractNode`2<Envelope, TItem> CreateNode(int level);
    protected virtual IIntersectsOp<Envelope, TItem> get_IntersectsOp();
    public sealed virtual void Insert(Envelope itemEnv, TItem item);
    public sealed virtual IList`1<TItem> Query(Envelope searchEnv);
    public sealed virtual void Query(Envelope searchEnv, IItemVisitor`1<TItem> visitor);
    public sealed virtual bool Remove(Envelope itemEnv, TItem item);
    protected virtual IComparer`1<IBoundable`2<Envelope, TItem>> GetComparer();
    public TItem[] NearestNeighbour(IItemDistance`2<Envelope, TItem> itemDist);
    public TItem[] NearestNeighbour(Envelope env, TItem item, IItemDistance`2<Envelope, TItem> itemDist, int k);
    public TItem NearestNeighbour(Envelope env, TItem item, IItemDistance`2<Envelope, TItem> itemDist);
    public TItem[] NearestNeighbour(STRtree`1<TItem> tree, IItemDistance`2<Envelope, TItem> itemDist);
    private static TItem[] NearestNeighbour(BoundablePair`1<TItem> initBndPair);
    private TItem[] NearestNeighbour(BoundablePair`1<TItem> initBndPair, int k);
    private static TItem[] NearestNeighbour(BoundablePair`1<TItem> initBndPair, double maxDistance);
    private TItem[] NearestNeighbour(BoundablePair`1<TItem> initBndPair, double maxDistance, int k);
    private static TItem[] GetItems(PriorityQueue`1<BoundablePair`1<TItem>> kNearestNeighbors);
}
public interface NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction {
    public abstract virtual void Overlap(SweepLineInterval s0, SweepLineInterval s1);
}
public class NetTopologySuite.Index.Sweepline.SweepLineEvent : object {
    private double xValue;
    private SweepLineEvents eventType;
    private SweepLineEvent insertEvent;
    private SweepLineInterval sweepInt;
    [CompilerGeneratedAttribute]
private int <DeleteEventIndex>k__BackingField;
    public bool IsInsert { get; }
    public bool IsDelete { get; }
    public SweepLineEvent InsertEvent { get; }
    public int DeleteEventIndex { get; public set; }
    public SweepLineInterval Interval { get; }
    public SweepLineEvent(double x, SweepLineEvent insertEvent, SweepLineInterval sweepInt);
    public bool get_IsInsert();
    public bool get_IsDelete();
    public SweepLineEvent get_InsertEvent();
    [CompilerGeneratedAttribute]
public int get_DeleteEventIndex();
    [CompilerGeneratedAttribute]
public void set_DeleteEventIndex(int value);
    public SweepLineInterval get_Interval();
    public sealed virtual int CompareTo(object o);
}
public enum NetTopologySuite.Index.Sweepline.SweepLineEvents : Enum {
    public int value__;
    public static SweepLineEvents Insert;
    public static SweepLineEvents Delete;
}
public class NetTopologySuite.Index.Sweepline.SweepLineIndex : object {
    private List`1<SweepLineEvent> _events;
    private bool _indexBuilt;
    private int _nOverlaps;
    public void Add(SweepLineInterval sweepInt);
    private void BuildIndex();
    public void ComputeOverlaps(ISweepLineOverlapAction action);
    private void ProcessOverlaps(int start, int end, SweepLineInterval s0, ISweepLineOverlapAction action);
}
public class NetTopologySuite.Index.Sweepline.SweepLineInterval : object {
    private double min;
    private double max;
    private object item;
    public double Min { get; }
    public double Max { get; }
    public object Item { get; }
    public SweepLineInterval(double min, double max);
    public SweepLineInterval(double min, double max, object item);
    public double get_Min();
    public double get_Max();
    public object get_Item();
}
[ObsoleteAttribute("Use BiEndianBinaryReader")]
public class NetTopologySuite.IO.BEBinaryReader : BinaryReader {
    public BEBinaryReader(Stream stream);
    public BEBinaryReader(Stream input, Encoding encoding);
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
    [ObsoleteAttribute("Not implemented")]
public virtual string ReadString();
    [ObsoleteAttribute("Not implemented")]
public virtual decimal ReadDecimal();
}
public class NetTopologySuite.IO.BEBinaryWriter : BinaryWriter {
    public BEBinaryWriter(Stream output);
    public BEBinaryWriter(Stream output, Encoding encoding);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    [ObsoleteAttribute("Not implemented")]
public virtual void Write(string value);
    [ObsoleteAttribute("Not implemented")]
public virtual void Write(decimal value);
}
public class NetTopologySuite.IO.BiEndianBinaryReader : BinaryReader {
    [CompilerGeneratedAttribute]
private ByteOrder <Endianess>k__BackingField;
    public ByteOrder Endianess { get; public set; }
    public BiEndianBinaryReader(Stream stream);
    public BiEndianBinaryReader(Stream input, ByteOrder endianess);
    [CompilerGeneratedAttribute]
public ByteOrder get_Endianess();
    [CompilerGeneratedAttribute]
public void set_Endianess(ByteOrder value);
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
    public virtual string ReadString();
    public virtual decimal ReadDecimal();
}
internal static class NetTopologySuite.IO.GML2.GMLElements : object {
    internal static string gmlPrefix;
    internal static string gmlNS;
    internal static string gmlNSDecl;
}
public class NetTopologySuite.IO.GML2.GMLReader : object {
    private IGeometryFactory _factory;
    protected IGeometryFactory Factory { get; }
    public GMLReader(IGeometryFactory factory);
    protected IGeometryFactory get_Factory();
    public IGeometry Read(XmlDocument document);
    public IGeometry Read(XDocument document);
    public IGeometry Read(string xmlText);
    public IGeometry Read(StringReader stringReader);
    public IGeometry Read(XmlReader reader);
    protected Coordinate ReadCoordinate(XmlReader reader);
    protected Coordinate ReadCoordinates(string value);
    protected Coordinate ReadPosAsCoordinate(String[] value);
    protected IEnumerable`1<Coordinate> ReadPosListAsCoordinates(int numOrdinates, String[] value);
    protected IPoint ReadPoint(XmlReader reader);
    protected ILineString ReadLineString(XmlReader reader);
    protected ILinearRing ReadLinearRing(XmlReader reader);
    protected IPolygon ReadPolygon(XmlReader reader);
    protected IMultiPoint ReadMultiPoint(XmlReader reader);
    protected IMultiLineString ReadMultiLineString(XmlReader reader);
    protected IMultiPolygon ReadMultiPolygon(XmlReader reader);
    protected IGeometryCollection ReadGeometryCollection(XmlReader reader);
    private static bool IsStartElement(XmlReader reader, string name);
}
public class NetTopologySuite.IO.GML2.GMLWriter : object {
    private static int InitValue;
    private static int CoordSize;
    protected static NumberFormatInfo NumberFormatter { get; }
    protected static NumberFormatInfo get_NumberFormatter();
    public XmlReader Write(IGeometry geometry);
    public void Write(IGeometry geometry, Stream stream);
    protected void Write(Coordinate coordinate, XmlWriter writer);
    protected void Write(Coordinate[] coordinates, XmlWriter writer);
    protected void WriteCoordinates(Coordinate[] coordinates, XmlWriter writer);
    public void Write(IGeometry geometry, XmlWriter writer);
    protected void Write(IPoint point, XmlWriter writer);
    protected void Write(ILineString lineString, XmlWriter writer);
    protected void Write(ILinearRing linearRing, XmlWriter writer);
    protected void Write(IPolygon polygon, XmlWriter writer);
    protected void Write(IMultiPoint multiPoint, XmlWriter writer);
    protected void Write(IMultiLineString multiLineString, XmlWriter writer);
    protected void Write(IMultiPolygon multiPolygon, XmlWriter writer);
    protected void Write(IGeometryCollection geometryCollection, XmlWriter writer);
    protected int SetByteStreamLength(IGeometry geometry);
    protected int SetByteStreamLength(IGeometryCollection geometryCollection);
    protected int SetByteStreamLength(IMultiPolygon multiPolygon);
    protected int SetByteStreamLength(IMultiLineString multiLineString);
    protected int SetByteStreamLength(IMultiPoint multiPoint);
    protected int SetByteStreamLength(IPolygon polygon);
    protected int SetByteStreamLength(ILineString lineString);
    protected int SetByteStreamLength(IPoint point);
}
public class NetTopologySuite.IO.KML.KMLWriter : object {
    public static string AltitudeModeClampToGround;
    public static string AltitudeModeRelativeToGround;
    public static string AltitudeModeAbsolute;
    private static int IndentSize;
    private static string CoordinateSeparator;
    private static string TupleSeparator;
    private string _linePrefix;
    private int _maxCoordinatesPerLine;
    private double _z;
    private bool _extrude;
    private bool _tesselate;
    private string _altitudeMode;
    private NumberFormatInfo _formatter;
    private string _format;
    public string LinePrefix { get; public set; }
    public int MaxCoordinatesPerLine { get; public set; }
    public double Z { get; public set; }
    public bool Extrude { get; public set; }
    public bool Tesselate { get; public set; }
    public string AltitudeMode { get; public set; }
    public int Precision { get; public set; }
    public static string WriteGeometry(IGeometry geometry, double z);
    private void CreateDefaultFormatter();
    public static string WriteGeometry(IGeometry geometry, double z, int precision, bool extrude, string altitudeMode);
    public string get_LinePrefix();
    public void set_LinePrefix(string value);
    public int get_MaxCoordinatesPerLine();
    public void set_MaxCoordinatesPerLine(int value);
    public double get_Z();
    public void set_Z(double value);
    public bool get_Extrude();
    public void set_Extrude(bool value);
    public bool get_Tesselate();
    public void set_Tesselate(bool value);
    public string get_AltitudeMode();
    public void set_AltitudeMode(string value);
    public int get_Precision();
    public void set_Precision(int value);
    private void CreateFormatter(int precision);
    public string Write(IGeometry geom);
    public void Write(IGeometry geom, TextWriter writer);
    public void Write(IGeometry geom, StringBuilder sb);
    private void WriteGeometry(IGeometry g, int level, StringBuilder sb);
    private void StartLine(string text, int level, StringBuilder sb);
    private string GeometryTag(string geometryName);
    private void WriteModifiers(int level, StringBuilder sb);
    private void WritePoint(IPoint p, int level, StringBuilder sb);
    private void WriteLineString(ILineString ls, int level, StringBuilder sb);
    private void WriteLinearRing(ILinearRing lr, int level, StringBuilder sb, bool writeModifiers);
    private void WritePolygon(IPolygon p, int level, StringBuilder sb);
    private void WriteGeometryCollection(IGeometryCollection gc, int level, StringBuilder sb);
    private void Write(Coordinate[] coords, int level, StringBuilder sb);
    private void Write(Coordinate p, StringBuilder sb);
    private void Write(double d, StringBuilder sb);
}
[ObsoleteAttribute("Use GeoAPI.IO.ParseException")]
public class NetTopologySuite.IO.ParseException : ParseException {
    public ParseException(string message);
    public ParseException(Exception e);
}
public enum NetTopologySuite.IO.WKBGeometryTypes : Enum {
    public int value__;
    public static WKBGeometryTypes WKBPoint;
    public static WKBGeometryTypes WKBLineString;
    public static WKBGeometryTypes WKBPolygon;
    public static WKBGeometryTypes WKBMultiPoint;
    public static WKBGeometryTypes WKBMultiLineString;
    public static WKBGeometryTypes WKBMultiPolygon;
    public static WKBGeometryTypes WKBGeometryCollection;
    public static WKBGeometryTypes WKBPointZ;
    public static WKBGeometryTypes WKBLineStringZ;
    public static WKBGeometryTypes WKBPolygonZ;
    public static WKBGeometryTypes WKBMultiPointZ;
    public static WKBGeometryTypes WKBMultiLineStringZ;
    public static WKBGeometryTypes WKBMultiPolygonZ;
    public static WKBGeometryTypes WKBGeometryCollectionZ;
    public static WKBGeometryTypes WKBPointM;
    public static WKBGeometryTypes WKBLineStringM;
    public static WKBGeometryTypes WKBPolygonM;
    public static WKBGeometryTypes WKBMultiPointM;
    public static WKBGeometryTypes WKBMultiLineStringM;
    public static WKBGeometryTypes WKBMultiPolygonM;
    public static WKBGeometryTypes WKBGeometryCollectionM;
    public static WKBGeometryTypes WKBPointZM;
    public static WKBGeometryTypes WKBLineStringZM;
    public static WKBGeometryTypes WKBPolygonZM;
    public static WKBGeometryTypes WKBMultiPointZM;
    public static WKBGeometryTypes WKBMultiLineStringZM;
    public static WKBGeometryTypes WKBMultiPolygonZM;
    public static WKBGeometryTypes WKBGeometryCollectionZM;
}
public class NetTopologySuite.IO.WKBHexFileReader : object {
    private IBinaryGeometryReader _wkbReader;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int Limit { get; public set; }
    public int Offset { get; public set; }
    public WKBHexFileReader(IBinaryGeometryReader wkbReader);
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    public ICollection`1<IGeometry> Read(string file);
    public ICollection`1<IGeometry> Read(Stream stream);
    private ICollection`1<IGeometry> Read(StreamReader streamReader);
    private bool IsAtLimit(ICollection`1<IGeometry> geoms);
    private static bool IsAtEndOfFile(StreamReader bufferedReader);
}
public class NetTopologySuite.IO.WKBReader : object {
    [ObsoleteAttribute]
private IGeometryFactory _factory;
    private ICoordinateSequenceFactory _sequenceFactory;
    private IPrecisionModel _precisionModel;
    private IGeometryServices _geometryServices;
    private bool _isStrict;
    [CompilerGeneratedAttribute]
private bool <HandleSRID>k__BackingField;
    private Ordinates _handleOrdinates;
    [ObsoleteAttribute]
protected IGeometryFactory Factory { get; }
    public bool HandleSRID { get; public set; }
    public Ordinates AllowedOrdinates { get; }
    public Ordinates HandleOrdinates { get; public set; }
    public bool RepairRings { get; public set; }
    [ObsoleteAttribute]
public WKBReader(IGeometryFactory factory);
    public WKBReader(IGeometryServices services);
    public static Byte[] HexToBytes(string hex);
    private static int HexToInt(char hex);
    protected IGeometryFactory get_Factory();
    public sealed virtual IGeometry Read(Byte[] data);
    public virtual IGeometry Read(Stream stream);
    protected IGeometry Read(BinaryReader reader);
    private void ReadByteOrder(BinaryReader reader);
    private WKBGeometryTypes ReadGeometryType(BinaryReader reader, CoordinateSystem& coordinateSystem, Int32& srid);
    protected ICoordinateSequence ReadCoordinateSequence(BinaryReader reader, int size, CoordinateSystem cs);
    protected ICoordinateSequence ReadCoordinateSequenceRing(BinaryReader reader, int size, CoordinateSystem cs);
    protected ICoordinateSequence ReadCoordinateSequenceLineString(BinaryReader reader, int size, CoordinateSystem cs);
    private static Ordinates ToOrdinates(CoordinateSystem cs);
    protected ILinearRing ReadLinearRing(BinaryReader reader, CoordinateSystem cs, int srid);
    protected IGeometry ReadPoint(BinaryReader reader, CoordinateSystem cs, int srid);
    protected IGeometry ReadLineString(BinaryReader reader, CoordinateSystem cs, int srid);
    protected IGeometry ReadPolygon(BinaryReader reader, CoordinateSystem cs, int srid);
    protected IGeometry ReadMultiPoint(BinaryReader reader, CoordinateSystem cs, int srid);
    protected IGeometry ReadMultiLineString(BinaryReader reader, CoordinateSystem cs, int srid);
    protected IGeometry ReadMultiPolygon(BinaryReader reader, CoordinateSystem cs, int srid);
    protected IGeometry ReadGeometryCollection(BinaryReader reader, CoordinateSystem cs, int srid);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HandleSRID();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HandleSRID(bool value);
    public sealed virtual Ordinates get_AllowedOrdinates();
    public sealed virtual Ordinates get_HandleOrdinates();
    public sealed virtual void set_HandleOrdinates(Ordinates value);
    public sealed virtual bool get_RepairRings();
    public sealed virtual void set_RepairRings(bool value);
    private bool HandleOrdinate(Ordinate ordinate);
}
public class NetTopologySuite.IO.WKBWriter : object {
    private bool _emitZ;
    private bool _emitM;
    protected ByteOrder EncodingType;
    private int _coordinateSize;
    private Ordinates _handleOrdinates;
    private bool _handleSRID;
    private bool _strict;
    [ObsoleteAttribute("Use HandleSRID instead")]
public bool EmitSRID { get; public set; }
    [ObsoleteAttribute("Use HandleOrdinates instead")]
public bool EmitZ { get; public set; }
    [ObsoleteAttribute("Use HandleOrdintes instead.")]
public bool EmitM { get; public set; }
    protected int InitCount { get; }
    public bool Strict { get; public set; }
    public bool HandleSRID { get; public set; }
    public Ordinates AllowedOrdinates { get; }
    public Ordinates HandleOrdinates { get; public set; }
    public ByteOrder ByteOrder { get; public set; }
    public WKBWriter(ByteOrder encodingType);
    public WKBWriter(ByteOrder encodingType, bool handleSRID);
    public WKBWriter(ByteOrder encodingType, bool handleSRID, bool emitZ);
    public WKBWriter(ByteOrder encodingType, bool handleSRID, bool emitZ, bool emitM);
    [ObsoleteAttribute("Use ToHex(byte[])")]
public static string BytesToHex(Byte[] bytes);
    public static string ToHex(Byte[] bytes);
    private static char ToHexDigit(int n);
    public bool get_EmitSRID();
    public void set_EmitSRID(bool value);
    public bool get_EmitZ();
    public void set_EmitZ(bool value);
    public bool get_EmitM();
    public void set_EmitM(bool value);
    private void WriteHeader(BinaryWriter writer, IGeometry geom);
    protected int get_InitCount();
    public virtual Byte[] Write(IGeometry geometry);
    public virtual void Write(IGeometry geometry, Stream stream);
    protected void Write(IGeometry geometry, BinaryWriter writer);
    protected void WriteByteOrder(BinaryWriter writer);
    protected void Write(Coordinate coordinate, BinaryWriter writer);
    protected void Write(ICoordinateSequence sequence, bool emitSize, BinaryWriter writer);
    protected void Write(IPoint point, BinaryWriter writer);
    protected void Write(ILineString lineString, BinaryWriter writer);
    protected void Write(ILinearRing ring, BinaryWriter writer);
    protected void Write(IPolygon polygon, BinaryWriter writer);
    protected void Write(IMultiPoint multiPoint, BinaryWriter writer);
    protected void Write(IMultiLineString multiLineString, BinaryWriter writer);
    protected void Write(IMultiPolygon multiPolygon, BinaryWriter writer);
    protected void Write(IGeometryCollection geomCollection, BinaryWriter writer);
    protected Byte[] GetBytes(IGeometry geometry);
    protected virtual int SetByteStream(IGeometry geometry);
    protected int SetByteStream(IGeometryCollection geometry);
    protected int SetByteStream(IMultiPolygon geometry);
    protected int SetByteStream(IMultiLineString geometry);
    protected int SetByteStream(IMultiPoint geometry);
    protected int SetByteStream(IPolygon geometry);
    protected int SetByteStream(ILineString geometry);
    protected int SetByteStream(IPoint geometry);
    private void CalcCoordinateSize();
    public bool get_Strict();
    public void set_Strict(bool value);
    public sealed virtual bool get_HandleSRID();
    public sealed virtual void set_HandleSRID(bool value);
    public sealed virtual Ordinates get_AllowedOrdinates();
    public sealed virtual Ordinates get_HandleOrdinates();
    public sealed virtual void set_HandleOrdinates(Ordinates value);
    public sealed virtual ByteOrder get_ByteOrder();
    public sealed virtual void set_ByteOrder(ByteOrder value);
}
public class NetTopologySuite.IO.WKTFileReader : object {
    private static int MaxLookahead;
    private FileInfo _file;
    private TextReader _reader;
    private WKTReader _wktReader;
    private int _count;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int Limit { get; public set; }
    public int Offset { get; public set; }
    private WKTFileReader(WKTReader wktReader);
    public WKTFileReader(FileInfo file, WKTReader wktReader);
    public WKTFileReader(string filename, WKTReader wktReader);
    public WKTFileReader(Stream stream, WKTReader wktReader);
    public WKTFileReader(TextReader reader, WKTReader wktReader);
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    public IList`1<IGeometry> Read();
    private IList`1<IGeometry> Read(TextReader bufferedReader);
    private bool IsAtLimit(IList`1<IGeometry> geoms);
    private static bool IsAtEndOfTokens(Token token);
    private bool IsAtEndOfFile(StreamReader bufferedReader);
}
public class NetTopologySuite.IO.WKTReader : object {
    private ICoordinateSequenceFactory _coordinateSequencefactory;
    private IPrecisionModel _precisionModel;
    private static CultureInfo InvariantCulture;
    private static string NaNString;
    [CompilerGeneratedAttribute]
private int <DefaultSRID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RepairRings>k__BackingField;
    public IGeometryFactory Factory { get; public set; }
    public int DefaultSRID { get; public set; }
    public bool HandleSRID { get; public set; }
    public Ordinates AllowedOrdinates { get; }
    public Ordinates HandleOrdinates { get; public set; }
    public bool RepairRings { get; public set; }
    public WKTReader(IGeometryFactory geometryFactory);
    private static WKTReader();
    public IGeometryFactory get_Factory();
    public void set_Factory(IGeometryFactory value);
    [CompilerGeneratedAttribute]
public int get_DefaultSRID();
    [CompilerGeneratedAttribute]
public void set_DefaultSRID(int value);
    public sealed virtual IGeometry Read(string wellKnownText);
    public sealed virtual IGeometry Read(Stream stream);
    public IGeometry Read(TextReader reader);
    internal IEnumerator`1<Token> Tokenizer(TextReader reader);
    internal IList`1<Token> Tokenize(TextReader reader);
    private Coordinate[] GetCoordinates(IEnumerator`1<Token> tokens, bool skipExtraParenthesis, Boolean& hasZ);
    private Coordinate GetPreciseCoordinate(IEnumerator`1<Token> tokens, bool skipExtraParenthesis, Boolean& hasZ);
    private static bool IsStringValueNext(IEnumerator`1<Token> tokens, string stringValue);
    private static bool IsNumberNext(IEnumerator`1<Token> tokens);
    private static double GetNextNumber(IEnumerator`1<Token> tokens);
    private static string GetNextEmptyOrOpener(IEnumerator`1<Token> tokens);
    private static string GetNextCloserOrComma(IEnumerator`1<Token> tokens);
    private static string GetNextCloser(IEnumerator`1<Token> tokens);
    private static string GetNextWord(IEnumerator`1<Token> tokens);
    internal IGeometry ReadGeometryTaggedText(IEnumerator`1<Token> tokens);
    private IPoint ReadPointText(IEnumerator`1<Token> tokens, IGeometryFactory factory);
    private ICoordinateSequence ToSequence(bool hasZ, Coordinate[] coords);
    private ILineString ReadLineStringText(IEnumerator`1<Token> tokens, IGeometryFactory factory);
    private ILinearRing ReadLinearRingText(IEnumerator`1<Token> tokens, IGeometryFactory factory);
    private IMultiPoint ReadMultiPointText(IEnumerator`1<Token> tokens, IGeometryFactory factory);
    private IPoint[] ToPoints(ICoordinateSequence coordinates, IGeometryFactory factory);
    private IPolygon ReadPolygonText(IEnumerator`1<Token> tokens, IGeometryFactory factory);
    private IMultiLineString ReadMultiLineStringText(IEnumerator`1<Token> tokens, IGeometryFactory factory);
    private IMultiPolygon ReadMultiPolygonText(IEnumerator`1<Token> tokens, IGeometryFactory factory);
    private IGeometryCollection ReadGeometryCollectionText(IEnumerator`1<Token> tokens, IGeometryFactory factory);
    public sealed virtual bool get_HandleSRID();
    public sealed virtual void set_HandleSRID(bool value);
    public sealed virtual Ordinates get_AllowedOrdinates();
    public sealed virtual Ordinates get_HandleOrdinates();
    public sealed virtual void set_HandleOrdinates(Ordinates value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RepairRings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RepairRings(bool value);
}
public class NetTopologySuite.IO.WKTWriter : object {
    private int _outputDimension;
    private static string MaxPrecisionFormat;
    private NumberFormatInfo _formatter;
    private string _format;
    private bool _isFormatted;
    private bool _useFormating;
    private bool _useMaxPrecision;
    private int _coordsPerLine;
    private string _indentTabStr;
    [CompilerGeneratedAttribute]
private bool <EmitSRID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitZ>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitM>k__BackingField;
    public bool Formatted { get; public set; }
    public int MaxCoordinatesPerLine { get; public set; }
    public int Tab { get; public set; }
    public bool EmitSRID { get; public set; }
    public bool EmitZ { get; public set; }
    public bool EmitM { get; public set; }
    public bool HandleSRID { get; public set; }
    public Ordinates AllowedOrdinates { get; }
    public Ordinates HandleOrdinates { get; public set; }
    public WKTWriter(int outputDimension);
    public static string ToPoint(Coordinate p0);
    public static string ToLineString(ICoordinateSequence seq);
    public static string ToLineString(Coordinate[] coord);
    public static string ToLineString(Coordinate p0, Coordinate p1);
    internal static NumberFormatInfo CreateFormatter(IPrecisionModel precisionModel);
    public static string StringOfChar(char ch, int count);
    public bool get_Formatted();
    public void set_Formatted(bool value);
    public int get_MaxCoordinatesPerLine();
    public void set_MaxCoordinatesPerLine(int value);
    public int get_Tab();
    public void set_Tab(int value);
    [CompilerGeneratedAttribute]
public bool get_EmitSRID();
    [CompilerGeneratedAttribute]
public void set_EmitSRID(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitZ();
    [CompilerGeneratedAttribute]
public void set_EmitZ(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitM();
    [CompilerGeneratedAttribute]
public void set_EmitM(bool value);
    public virtual string Write(IGeometry geometry);
    public sealed virtual void Write(IGeometry geometry, Stream stream);
    private void TryWrite(IGeometry geometry, TextWriter sw);
    public virtual void Write(IGeometry geometry, TextWriter writer);
    public virtual string WriteFormatted(IGeometry geometry);
    public virtual void WriteFormatted(IGeometry geometry, TextWriter writer);
    private void WriteFormatted(IGeometry geometry, bool useFormatting, TextWriter writer);
    private void AppendGeometryTaggedText(IGeometry geometry, int level, TextWriter writer);
    private void AppendPointTaggedText(Coordinate coordinate, int level, TextWriter writer, IPrecisionModel precisionModel);
    private void AppendLineStringTaggedText(ILineString lineString, int level, TextWriter writer);
    private void AppendLinearRingTaggedText(ILinearRing linearRing, int level, TextWriter writer);
    private void AppendPolygonTaggedText(IPolygon polygon, int level, TextWriter writer);
    private void AppendMultiPointTaggedText(IMultiPoint multipoint, int level, TextWriter writer);
    private void AppendMultiLineStringTaggedText(IMultiLineString multiLineString, int level, TextWriter writer);
    private void AppendMultiPolygonTaggedText(IMultiPolygon multiPolygon, int level, TextWriter writer);
    private void AppendGeometryCollectionTaggedText(IGeometryCollection geometryCollection, int level, TextWriter writer);
    private void AppendPointText(Coordinate coordinate, int level, TextWriter writer, IPrecisionModel precisionModel);
    private void AppendCoordinate(ICoordinateSequence seq, int i, TextWriter writer);
    private void AppendCoordinate(Coordinate coordinate, TextWriter writer, IPrecisionModel precisionModel);
    private string WriteNumber(double d);
    private void AppendSequenceText(ICoordinateSequence seq, int level, bool doIndent, TextWriter writer);
    private void AppendLineStringText(ILineString lineString, int level, bool doIndent, TextWriter writer);
    private void AppendPolygonText(IPolygon polygon, int level, bool indentFirst, TextWriter writer);
    private void AppendMultiPointText(IMultiPoint multiPoint, int level, TextWriter writer);
    private void AppendMultiLineStringText(IMultiLineString multiLineString, int level, bool indentFirst, TextWriter writer);
    private void AppendMultiPolygonText(IMultiPolygon multiPolygon, int level, TextWriter writer);
    private void AppendGeometryCollectionText(IGeometryCollection geometryCollection, int level, TextWriter writer);
    private void IndentCoords(int coordIndex, int level, TextWriter writer);
    private void Indent(int level, TextWriter writer);
    public sealed virtual bool get_HandleSRID();
    public sealed virtual void set_HandleSRID(bool value);
    public sealed virtual Ordinates get_AllowedOrdinates();
    public sealed virtual Ordinates get_HandleOrdinates();
    public sealed virtual void set_HandleOrdinates(Ordinates value);
}
public class NetTopologySuite.LinearReferencing.ExtractLineByLocation : object {
    private IGeometry _line;
    public ExtractLineByLocation(IGeometry line);
    public static IGeometry Extract(IGeometry line, LinearLocation start, LinearLocation end);
    public IGeometry Extract(LinearLocation start, LinearLocation end);
    private static IGeometry Reverse(IGeometry linear);
    private IGeometry ComputeLinear(LinearLocation start, LinearLocation end);
}
public class NetTopologySuite.LinearReferencing.LengthIndexedLine : object {
    private IGeometry _linearGeom;
    public double StartIndex { get; }
    public double EndIndex { get; }
    public LengthIndexedLine(IGeometry linearGeom);
    public Coordinate ExtractPoint(double index);
    public Coordinate ExtractPoint(double index, double offsetDistance);
    public IGeometry ExtractLine(double startIndex, double endIndex);
    private LinearLocation LocationOf(double index);
    private LinearLocation LocationOf(double index, bool resolveLower);
    public double IndexOf(Coordinate pt);
    public double IndexOfAfter(Coordinate pt, double minIndex);
    public Double[] IndicesOf(IGeometry subLine);
    public double Project(Coordinate pt);
    public double get_StartIndex();
    public double get_EndIndex();
    public bool IsValidIndex(double index);
    public double ClampIndex(double index);
    private double PositiveIndex(double index);
}
public class NetTopologySuite.LinearReferencing.LengthIndexOfPoint : object {
    private IGeometry _linearGeom;
    public LengthIndexOfPoint(IGeometry linearGeom);
    public static double IndexOf(IGeometry linearGeom, Coordinate inputPt);
    public static double IndexOfAfter(IGeometry linearGeom, Coordinate inputPt, double minIndex);
    public double IndexOf(Coordinate inputPt);
    public double IndexOfAfter(Coordinate inputPt, double minIndex);
    private double IndexOfFromStart(Coordinate inputPt, double minIndex);
    private static double SegmentNearestMeasure(LineSegment seg, Coordinate inputPt, double segmentStartMeasure);
}
public class NetTopologySuite.LinearReferencing.LengthLocationMap : object {
    private IGeometry _linearGeom;
    public LengthLocationMap(IGeometry linearGeom);
    public static LinearLocation GetLocation(IGeometry linearGeom, double length);
    public static LinearLocation GetLocation(IGeometry linearGeom, double length, bool resolveLower);
    public static double GetLength(IGeometry linearGeom, LinearLocation loc);
    public LinearLocation GetLocation(double length);
    public LinearLocation GetLocation(double length, bool resolveLower);
    private LinearLocation GetLocationForward(double length);
    private LinearLocation ResolveHigher(LinearLocation loc);
    public double GetLength(LinearLocation loc);
}
public class NetTopologySuite.LinearReferencing.LinearGeometryBuilder : object {
    private IGeometryFactory _geomFact;
    private List`1<IGeometry> _lines;
    private CoordinateList _coordList;
    private Coordinate _lastPt;
    [CompilerGeneratedAttribute]
private bool <FixInvalidLines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreInvalidLines>k__BackingField;
    public bool FixInvalidLines { get; public set; }
    public bool IgnoreInvalidLines { get; public set; }
    public Coordinate LastCoordinate { get; }
    public LinearGeometryBuilder(IGeometryFactory geomFact);
    [CompilerGeneratedAttribute]
public bool get_FixInvalidLines();
    [CompilerGeneratedAttribute]
public void set_FixInvalidLines(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreInvalidLines();
    [CompilerGeneratedAttribute]
public void set_IgnoreInvalidLines(bool value);
    public void Add(Coordinate pt);
    public void Add(Coordinate pt, bool allowRepeatedPoints);
    public Coordinate get_LastCoordinate();
    public void EndLine();
    private static Coordinate[] ValidCoordinateSequence(Coordinate[] pts);
    public IGeometry GetGeometry();
}
public class NetTopologySuite.LinearReferencing.LinearIterator : object {
    private IGeometry _linearGeom;
    private int _numLines;
    private ILineString _currentLine;
    private int _componentIndex;
    private int _vertexIndex;
    public bool IsEndOfLine { get; }
    public int ComponentIndex { get; }
    public int VertexIndex { get; }
    public ILineString Line { get; }
    public Coordinate SegmentStart { get; }
    public Coordinate SegmentEnd { get; }
    public LinearIterator(IGeometry linearGeom);
    public LinearIterator(IGeometry linearGeom, LinearLocation start);
    public LinearIterator(IGeometry linearGeom, int componentIndex, int vertexIndex);
    public static int SegmentEndVertexIndex(LinearLocation loc);
    private void LoadCurrentLine();
    public bool HasNext();
    public void Next();
    public bool get_IsEndOfLine();
    public int get_ComponentIndex();
    public int get_VertexIndex();
    public ILineString get_Line();
    public Coordinate get_SegmentStart();
    public Coordinate get_SegmentEnd();
}
public class NetTopologySuite.LinearReferencing.LinearLocation : object {
    private int _componentIndex;
    private int _segmentIndex;
    private double _segmentFraction;
    public int ComponentIndex { get; }
    public int SegmentIndex { get; }
    public double SegmentFraction { get; }
    public bool IsVertex { get; }
    public LinearLocation(int segmentIndex, double segmentFraction);
    public LinearLocation(int componentIndex, int segmentIndex, double segmentFraction);
    private LinearLocation(int componentIndex, int segmentIndex, double segmentFraction, bool normalize);
    public LinearLocation(LinearLocation loc);
    public static LinearLocation GetEndLocation(IGeometry linear);
    public static Coordinate PointAlongSegmentByFraction(Coordinate p0, Coordinate p1, double fraction);
    private void Normalize();
    public void Clamp(IGeometry linear);
    public void SnapToVertex(IGeometry linearGeom, double minDistance);
    public double GetSegmentLength(IGeometry linearGeom);
    public void SetToEnd(IGeometry linear);
    public int get_ComponentIndex();
    public int get_SegmentIndex();
    public double get_SegmentFraction();
    public bool get_IsVertex();
    public Coordinate GetCoordinate(IGeometry linearGeom);
    public LineSegment GetSegment(IGeometry linearGeom);
    public bool IsValid(IGeometry linearGeom);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(LinearLocation other);
    public int CompareLocationValues(int componentIndex1, int segmentIndex1, double segmentFraction1);
    public static int CompareLocationValues(int componentIndex0, int segmentIndex0, double segmentFraction0, int componentIndex1, int segmentIndex1, double segmentFraction1);
    public bool IsOnSameSegment(LinearLocation loc);
    public bool IsEndpoint(IGeometry linearGeom);
    public LinearLocation ToLowest(IGeometry linearGeom);
    [ObsoleteAttribute("Use Copy()")]
public sealed virtual object Clone();
    public LinearLocation Copy();
}
public class NetTopologySuite.LinearReferencing.LocationIndexedLine : object {
    private IGeometry _linearGeom;
    public LinearLocation StartIndex { get; }
    public LinearLocation EndIndex { get; }
    public LocationIndexedLine(IGeometry linearGeom);
    private static bool CheckGeometryType(IGeometry linearGeometry);
    public Coordinate ExtractPoint(LinearLocation index);
    public Coordinate ExtractPoint(LinearLocation index, double offsetDistance);
    public Coordinate ExtractPoint(double index, double offsetDistance);
    public IGeometry ExtractLine(LinearLocation startIndex, LinearLocation endIndex);
    public LinearLocation IndexOf(Coordinate pt);
    public LinearLocation[] IndicesOf(IGeometry subLine);
    public LinearLocation IndexOfAfter(Coordinate pt, LinearLocation minIndex);
    public LinearLocation Project(Coordinate pt);
    public LinearLocation get_StartIndex();
    public LinearLocation get_EndIndex();
    public bool IsValidIndex(LinearLocation index);
    public LinearLocation ClampIndex(LinearLocation index);
}
public class NetTopologySuite.LinearReferencing.LocationIndexOfLine : object {
    private IGeometry _linearGeom;
    public LocationIndexOfLine(IGeometry linearGeom);
    public static LinearLocation[] IndicesOf(IGeometry linearGeom, IGeometry subLine);
    public virtual LinearLocation[] IndicesOf(IGeometry subLine);
}
public class NetTopologySuite.LinearReferencing.LocationIndexOfPoint : object {
    private IGeometry _linearGeom;
    public LocationIndexOfPoint(IGeometry linearGeom);
    public static LinearLocation IndexOf(IGeometry linearGeom, Coordinate inputPt);
    public static LinearLocation IndexOfAfter(IGeometry linearGeom, Coordinate inputPt, LinearLocation minIndex);
    public LinearLocation IndexOf(Coordinate inputPt);
    public LinearLocation IndexOfAfter(Coordinate inputPt, LinearLocation minIndex);
    private LinearLocation IndexOfFromStart(Coordinate inputPt, LinearLocation minIndex);
}
public class NetTopologySuite.Mathematics.DD : ValueType {
    public static DD PI;
    public static DD TwoPi;
    public static DD PiHalf;
    public static DD E;
    public static DD NaN;
    public static double Epsilon;
    private static double Split;
    private double _hi;
    private double _lo;
    private static int MaxPrintDigits;
    private static DD Ten;
    private static DD One;
    private static string SCI_NOT_EXPONENT_CHAR;
    private static string SCI_NOT_ZERO;
    public bool IsZero { get; }
    public bool IsNegative { get; }
    public DD(double x);
    public DD(double hi, double lo);
    public DD(DD dd);
    public DD(string str);
    private static DD();
    private static DD CreateNaN();
    public static DD ValueOf(string str);
    public static DD op_Explicit(string val);
    public static DD ValueOf(double x);
    public static DD op_Implicit(double val);
    public static DD Copy(DD dd);
    public object Clone();
    [ObsoleteAttribute("Use operator +")]
public DD Add(DD y);
    public static DD op_Addition(DD lhs, DD rhs);
    public static DD op_Addition(DD lhs, double rhs);
    public static DD op_Subtraction(DD lhs, DD rhs);
    public static DD op_Subtraction(DD lhs, double rhs);
    [ObsoleteAttribute("Use Operator +")]
public DD Add(double y);
    [ObsoleteAttribute("Use operator -")]
public DD Subtract(DD y);
    [ObsoleteAttribute("Use operator -")]
public DD Subtract(double y);
    [ObsoleteAttribute("Use operator -")]
public DD Negate();
    public static DD op_UnaryNegation(DD val);
    [ObsoleteAttribute("Use *-operator instead")]
public DD Multiply(DD y);
    [ObsoleteAttribute("Use *-operator instead")]
public DD Multiply(double y);
    public static DD op_Multiply(DD lhs, double rhs);
    public static DD op_Multiply(DD lhs, DD rhs);
    [ObsoleteAttribute("Use /-operator instead")]
public DD Divide(DD y);
    [ObsoleteAttribute("Use /-operator instead")]
public DD Divide(double y);
    public static DD op_Division(DD lhs, double rhs);
    public static DD op_Division(DD lhs, DD rhs);
    public DD Reciprocal();
    public DD Min(DD x);
    public DD Max(DD x);
    public DD Floor();
    public DD Ceiling();
    public int Signum();
    public DD Rint();
    public DD Truncate();
    public DD Abs();
    public DD Sqr();
    public static DD Sqr(double x);
    public DD Sqrt();
    public static DD Sqrt(double x);
    public DD Pow(int exp);
    public double ToDoubleValue();
    public int ToIntValue();
    public bool get_IsZero();
    public bool get_IsNegative();
    public bool IsPositive();
    public static bool IsNaN(DD value);
    public static bool IsInfinity(DD value);
    public bool Equals(DD y);
    public static bool op_Equality(DD lhs, DD rhs);
    public static bool op_Inequality(DD rhs, DD lhs);
    public bool GreaterThan(DD y);
    public bool GreaterOrEqualThan(DD y);
    public bool LessThan(DD y);
    public bool LessOrEqualThan(DD y);
    public sealed virtual int CompareTo(DD other);
    public sealed virtual int CompareTo(object o);
    public string Dump();
    public virtual string ToString();
    public string ToStandardNotation();
    public string ToSciNotation();
    private string ExtractSignificantDigits(bool insertDecimalPoint, Int32[] magnitudes);
    private string GetSpecialNumberString();
    private static int Magnitude(double x);
    public static DD Parse(string str);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NetTopologySuite.Mathematics.MathUtil : object {
    private static double LOG10;
    private static MathUtil();
    public static double Clamp(double x, double min, double max);
    public static int Clamp(int x, int min, int max);
    public static double Log10(double x);
    public static int Wrap(int index, int max);
    public static double Average(double x1, double x2);
    public static double Max(double v1, double v2, double v3);
    public static double Max(double v1, double v2, double v3, double v4);
    public static double Min(double v1, double v2, double v3);
    public static double Min(double v1, double v2, double v3, double v4);
}
public class NetTopologySuite.Mathematics.Matrix : object {
    private static void SwapRows(Double[][] m, int i, int j);
    private static void SwapRows(Double[] m, int i, int j);
    public static Double[] Solve(Double[][] a, Double[] b);
}
public enum NetTopologySuite.Mathematics.Plane : Enum {
    public int value__;
    public static Plane Undefined;
    public static Plane XY;
    public static Plane YZ;
    public static Plane XZ;
}
public class NetTopologySuite.Mathematics.Plane3D : object {
    private Vector3D _normal;
    private Coordinate _basePt;
    public Plane3D(Vector3D normal, Coordinate basePt);
    public double OrientedDistance(Coordinate p);
    public Plane ClosestAxisPlane();
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Mathematics.Vector2D : object {
    private double _x;
    private double _y;
    public double X { get; }
    public double Y { get; }
    public double Item { get; }
    public Vector2D(double x, double y);
    public Vector2D(Vector2D v);
    public Vector2D(Coordinate from, Coordinate to);
    public Vector2D(Coordinate v);
    public static Vector2D Create(double x, double y);
    public static Vector2D Create(Vector2D v);
    public static Vector2D Create(Coordinate coord);
    public static Vector2D Create(Coordinate from, Coordinate to);
    public double get_X();
    public double get_Y();
    public double get_Item(int index);
    public Vector2D Add(Vector2D v);
    public Vector2D Subtract(Vector2D v);
    public Vector2D Multiply(double d);
    public Vector2D Divide(double d);
    public Vector2D Negate();
    public double Length();
    public double LengthSquared();
    public Vector2D Normalize();
    public Vector2D Average(Vector2D v);
    public Vector2D WeightedSum(Vector2D v, double frac);
    public double Distance(Vector2D v);
    public double Dot(Vector2D v);
    public double Angle();
    public double Angle(Vector2D v);
    public double AngleTo(Vector2D v);
    public Vector2D Rotate(double angle);
    public Vector2D RotateByQuarterCircle(int numQuarters);
    public bool IsParallel(Vector2D v);
    public Coordinate Translate(Coordinate coord);
    public Coordinate ToCoordinate();
    public sealed virtual object Clone();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class NetTopologySuite.Mathematics.Vector3D : object {
    private double _x;
    private double _y;
    private double _z;
    public double X { get; }
    public double Y { get; }
    public double Z { get; }
    public Vector3D(Coordinate v);
    public Vector3D(Coordinate from, Coordinate to);
    public Vector3D(double x, double y, double z);
    public static double Dot(Coordinate A, Coordinate B, Coordinate C, Coordinate D);
    public static Vector3D Create(double x, double y, double z);
    public static Vector3D Create(Coordinate coord);
    public static double Dot(Coordinate v1, Coordinate v2);
    public double get_X();
    public double get_Y();
    public double get_Z();
    public double Dot(Vector3D v);
    public double Length();
    public static double Length(Coordinate v);
    public Vector3D Normalize();
    private Vector3D Divide(double d);
    public static Coordinate Normalize(Coordinate v);
    public virtual string ToString();
}
public static class NetTopologySuite.Mathematics.VectorMath : object {
    public static Coordinate NormalToTriangle(Coordinate p0, Coordinate p1, Coordinate p2);
    public static void Normalize(Coordinate v);
    public static Coordinate CrossProduct(Coordinate v1, Coordinate v2);
    public static double DotProduct(Coordinate v1, Coordinate v2);
    public static double Det(double a1, double a2, double b1, double b2);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Noding.BasicSegmentString : object {
    private Coordinate[] _pts;
    [CompilerGeneratedAttribute]
private object <Context>k__BackingField;
    public object Context { get; public set; }
    public Coordinate[] Coordinates { get; }
    public bool IsClosed { get; }
    public int Count { get; }
    public LineSegment Item { get; public set; }
    public BasicSegmentString(Coordinate[] pts, object data);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Context(object value);
    public sealed virtual Coordinate[] get_Coordinates();
    public sealed virtual bool get_IsClosed();
    public sealed virtual int get_Count();
    public Octants GetSegmentOctant(int index);
    public sealed virtual LineSegment get_Item(int index);
    public sealed virtual void set_Item(int index, LineSegment value);
    public virtual string ToString();
}
public class NetTopologySuite.Noding.FastNodingValidator : object {
    private LineIntersector _li;
    private List`1<ISegmentString> _segStrings;
    private NodingIntersectionFinder _segInt;
    private bool _isValid;
    [CompilerGeneratedAttribute]
private bool <FindAllIntersections>k__BackingField;
    public bool FindAllIntersections { get; public set; }
    public IList`1<Coordinate> Intersections { get; }
    public bool IsValid { get; }
    public FastNodingValidator(IEnumerable`1<ISegmentString> segStrings);
    public static IList`1<Coordinate> ComputeIntersections(IEnumerable`1<ISegmentString> segStrings);
    [CompilerGeneratedAttribute]
public bool get_FindAllIntersections();
    [CompilerGeneratedAttribute]
public void set_FindAllIntersections(bool value);
    public IList`1<Coordinate> get_Intersections();
    public bool get_IsValid();
    public string GetErrorMessage();
    public void CheckValid();
    private void Execute();
    private void CheckInteriorIntersections();
}
public class NetTopologySuite.Noding.FastSegmentSetIntersectionFinder : object {
    private ISegmentSetMutualIntersector _segSetMutInt;
    public ISegmentSetMutualIntersector SegmentSetIntersector { get; }
    public FastSegmentSetIntersectionFinder(IEnumerable`1<ISegmentString> baseSegStrings);
    public ISegmentSetMutualIntersector get_SegmentSetIntersector();
    public bool Intersects(IList`1<ISegmentString> segStrings);
    public bool Intersects(IList`1<ISegmentString> segStrings, SegmentIntersectionDetector intDetector);
}
public interface NetTopologySuite.Noding.INodableSegmentString {
    public abstract virtual void AddIntersection(Coordinate intPt, int segmentIndex);
}
public interface NetTopologySuite.Noding.INoder {
    public abstract virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    public abstract virtual IList`1<ISegmentString> GetNodedSubstrings();
}
public class NetTopologySuite.Noding.InteriorIntersectionFinderAdder : object {
    private LineIntersector _li;
    private IList`1<Coordinate> _interiorIntersections;
    public IList`1<Coordinate> InteriorIntersections { get; }
    public bool IsDone { get; }
    public InteriorIntersectionFinderAdder(LineIntersector li);
    public IList`1<Coordinate> get_InteriorIntersections();
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual bool get_IsDone();
}
public class NetTopologySuite.Noding.IntersectionAdder : object {
    private bool _hasIntersection;
    private bool _hasProper;
    private bool _hasProperInterior;
    private bool _hasInterior;
    private Coordinate _properIntersectionPoint;
    private LineIntersector _li;
    public int NumIntersections;
    public int NumInteriorIntersections;
    public int NumProperIntersections;
    public int NumTests;
    public LineIntersector LineIntersector { get; }
    public Coordinate ProperIntersectionPoint { get; }
    public bool HasIntersection { get; }
    public bool HasProperIntersection { get; }
    public bool HasProperInteriorIntersection { get; }
    public bool HasInteriorIntersection { get; }
    public bool IsDone { get; }
    public IntersectionAdder(LineIntersector li);
    public static bool IsAdjacentSegments(int i1, int i2);
    public LineIntersector get_LineIntersector();
    public Coordinate get_ProperIntersectionPoint();
    public bool get_HasIntersection();
    public bool get_HasProperIntersection();
    public bool get_HasProperInteriorIntersection();
    public bool get_HasInteriorIntersection();
    private bool IsTrivialIntersection(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual bool get_IsDone();
}
[ObsoleteAttribute("see InteriorIntersectionFinderAdder")]
public class NetTopologySuite.Noding.IntersectionFinderAdder : object {
    private LineIntersector _li;
    private IList`1<Coordinate> _interiorIntersections;
    public IList`1<Coordinate> InteriorIntersections { get; }
    public bool IsDone { get; }
    public IntersectionFinderAdder(LineIntersector li);
    public IList`1<Coordinate> get_InteriorIntersections();
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual bool get_IsDone();
}
public interface NetTopologySuite.Noding.ISegmentIntersector {
    public bool IsDone { get; }
    public abstract virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public abstract virtual bool get_IsDone();
}
public interface NetTopologySuite.Noding.ISegmentSetMutualIntersector {
    public abstract virtual void Process(ICollection`1<ISegmentString> segmentStrings, ISegmentIntersector segmentIntersector);
}
[DefaultMemberAttribute("Item")]
public interface NetTopologySuite.Noding.ISegmentString {
    public object Context { get; public set; }
    public Coordinate[] Coordinates { get; }
    public int Count { get; }
    public bool IsClosed { get; }
    public LineSegment Item { get; public set; }
    public abstract virtual object get_Context();
    public abstract virtual void set_Context(object value);
    public abstract virtual Coordinate[] get_Coordinates();
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsClosed();
    public abstract virtual LineSegment get_Item(int index);
    public abstract virtual void set_Item(int index, LineSegment value);
}
public class NetTopologySuite.Noding.IteratedNoder : object {
    public static int MaxIterations;
    private LineIntersector _li;
    private IList`1<ISegmentString> _nodedSegStrings;
    private int _maxIter;
    public int MaximumIterations { get; public set; }
    public IteratedNoder(IPrecisionModel pm);
    public int get_MaximumIterations();
    public void set_MaximumIterations(int value);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    private void Node(IList`1<ISegmentString> segStrings, Int32[] numInteriorIntersections);
}
public class NetTopologySuite.Noding.MCIndexNoder : SinglePassNoder {
    private List`1<MonotoneChain> _monoChains;
    private ISpatialIndex`1<MonotoneChain> _index;
    private int _idCounter;
    private IList`1<ISegmentString> _nodedSegStrings;
    private int _nOverlaps;
    public IList`1<MonotoneChain> MonotoneChains { get; }
    public ISpatialIndex`1<MonotoneChain> Index { get; }
    public MCIndexNoder(ISegmentIntersector segInt);
    public IList`1<MonotoneChain> get_MonotoneChains();
    public ISpatialIndex`1<MonotoneChain> get_Index();
    public virtual IList`1<ISegmentString> GetNodedSubstrings();
    public virtual void ComputeNodes(IList`1<ISegmentString> inputSegStrings);
    private void IntersectChains();
    private void Add(ISegmentString segStr);
}
public class NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector : object {
    private STRtree`1<MonotoneChain> _index;
    public ISpatialIndex`1<MonotoneChain> Index { get; }
    public MCIndexSegmentSetMutualIntersector(IEnumerable`1<ISegmentString> baseSegStrings);
    public ISpatialIndex`1<MonotoneChain> get_Index();
    private void InitBaseSegments(IEnumerable`1<ISegmentString> segStrings);
    private void AddToIndex(ISegmentString segStr);
    public sealed virtual void Process(ICollection`1<ISegmentString> segmentStrings, ISegmentIntersector segmentIntersector);
    private static void AddToMonoChains(ISegmentString segStr, List`1<MonotoneChain> monotoneChains);
    private void IntersectChains(IEnumerable`1<MonotoneChain> monoChains, ISegmentIntersector segmentIntersector);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Noding.NodedSegmentString : object {
    private SegmentNodeList _nodeList;
    private Coordinate[] _pts;
    [CompilerGeneratedAttribute]
private object <Context>k__BackingField;
    public object Context { get; public set; }
    public SegmentNodeList NodeList { get; }
    public int Count { get; }
    public Coordinate[] Coordinates { get; }
    public bool IsClosed { get; }
    public LineSegment Item { get; public set; }
    public NodedSegmentString(Coordinate[] pts, object data);
    public static IList`1<ISegmentString> GetNodedSubstrings(IList`1<ISegmentString> segStrings);
    public static void GetNodedSubstrings(IList`1<ISegmentString> segStrings, IList`1<ISegmentString> resultEdgelist);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Context(object value);
    public SegmentNodeList get_NodeList();
    public sealed virtual int get_Count();
    public Coordinate GetCoordinate(int i);
    public sealed virtual Coordinate[] get_Coordinates();
    public sealed virtual bool get_IsClosed();
    public Octants GetSegmentOctant(int index);
    private static Octants SafeOctant(Coordinate p0, Coordinate p1);
    public void AddIntersections(LineIntersector li, int segmentIndex, int geomIndex);
    public void AddIntersection(LineIntersector li, int segmentIndex, int geomIndex, int intIndex);
    public sealed virtual void AddIntersection(Coordinate intPt, int segmentIndex);
    public sealed virtual LineSegment get_Item(int index);
    public sealed virtual void set_Item(int index, LineSegment value);
    public virtual string ToString();
}
internal class NetTopologySuite.Noding.NodeVertexIterator : object {
    private SegmentNodeList _nodeList;
    private ISegmentString _edge;
    private IEnumerator`1<object> _nodeIt;
    private SegmentNode _currNode;
    private SegmentNode _nextNode;
    private int _currSegIndex;
    public object Current { get; }
    private NodeVertexIterator(SegmentNodeList nodeList);
    public sealed virtual void Dispose();
    private void ReadNextNode();
    [ObsoleteAttribute("Not implemented!")]
public void Remove();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class NetTopologySuite.Noding.NodingIntersectionFinder : object {
    private LineIntersector _li;
    private Coordinate _interiorIntersection;
    private Coordinate[] _intSegments;
    private List`1<Coordinate> _intersections;
    private int intersectionCount;
    private bool _keepIntersections;
    [CompilerGeneratedAttribute]
private bool <FindAllIntersections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckEndSegmentsOnly>k__BackingField;
    public bool FindAllIntersections { get; public set; }
    public bool KeepIntersections { get; public set; }
    public bool CheckEndSegmentsOnly { get; public set; }
    public bool HasIntersection { get; }
    public IList`1<Coordinate> Intersections { get; }
    public int Count { get; }
    public Coordinate InteriorIntersection { get; }
    public Coordinate[] IntersectionSegments { get; }
    public bool IsDone { get; }
    public NodingIntersectionFinder(LineIntersector li);
    public static NodingIntersectionFinder CreateAnyIntersectionFinder(LineIntersector li);
    public static NodingIntersectionFinder CreateAllIntersectionsFinder(LineIntersector li);
    public static NodingIntersectionFinder CreateIntersectionCounter(LineIntersector li);
    [CompilerGeneratedAttribute]
public bool get_FindAllIntersections();
    [CompilerGeneratedAttribute]
public void set_FindAllIntersections(bool value);
    public bool get_KeepIntersections();
    public void set_KeepIntersections(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckEndSegmentsOnly();
    [CompilerGeneratedAttribute]
public void set_CheckEndSegmentsOnly(bool value);
    public bool get_HasIntersection();
    public IList`1<Coordinate> get_Intersections();
    public int get_Count();
    public Coordinate get_InteriorIntersection();
    public Coordinate[] get_IntersectionSegments();
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    private static bool IsInteriorVertexIntersection(Coordinate p00, Coordinate p01, Coordinate p10, Coordinate p11, bool isEnd00, bool isEnd01, bool isEnd10, bool isEnd11);
    private static bool IsInteriorVertexIntersection(Coordinate p0, Coordinate p1, bool isEnd0, bool isEnd1);
    private static bool IsEndSegment(ISegmentString segStr, int index);
    public sealed virtual bool get_IsDone();
}
public class NetTopologySuite.Noding.NodingValidator : object {
    private static IGeometryFactory Factory;
    private LineIntersector _li;
    private IList`1<ISegmentString> _segStrings;
    public NodingValidator(IList`1<ISegmentString> segStrings);
    private static NodingValidator();
    public void CheckValid();
    private void CheckCollapses();
    private static void CheckCollapses(ISegmentString ss);
    private static void CheckCollapse(Coordinate p0, Coordinate p1, Coordinate p2);
    private void CheckInteriorIntersections();
    private void CheckInteriorIntersections(ISegmentString ss0, ISegmentString ss1);
    private void CheckInteriorIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    private static bool HasInteriorIntersection(LineIntersector li, Coordinate p0, Coordinate p1);
    private void CheckEndPtVertexIntersections();
    private static void CheckEndPtVertexIntersections(Coordinate testPt, IEnumerable`1<ISegmentString> segStrings);
}
public static class NetTopologySuite.Noding.Octant : object {
    public static Octants GetOctant(double dx, double dy);
    public static Octants GetOctant(Coordinate p0, Coordinate p1);
}
public enum NetTopologySuite.Noding.Octants : Enum {
    public int value__;
    public static Octants Null;
    public static Octants Zero;
    public static Octants One;
    public static Octants Two;
    public static Octants Three;
    public static Octants Four;
    public static Octants Five;
    public static Octants Six;
    public static Octants Seven;
}
public class NetTopologySuite.Noding.OrientedCoordinateArray : object {
    private Coordinate[] _pts;
    private bool _orientation;
    public OrientedCoordinateArray(Coordinate[] pts);
    private static bool Orientation(Coordinate[] pts);
    public sealed virtual int CompareTo(object o1);
    private static int CompareOriented(Coordinate[] pts1, bool orientation1, Coordinate[] pts2, bool orientation2);
}
public class NetTopologySuite.Noding.ScaledNoder : object {
    private INoder _noder;
    private double _scaleFactor;
    private double _offsetX;
    private double _offsetY;
    private bool _isScaled;
    public bool IsIntegerPrecision { get; }
    public ScaledNoder(INoder noder, double scaleFactor);
    [ObsoleteAttribute("Do not use offsetX and offsetY")]
public ScaledNoder(INoder noder, double scaleFactor, double offsetX, double offsetY);
    public bool get_IsIntegerPrecision();
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> inputSegStrings);
    private IList`1<ISegmentString> Scale(IList`1<ISegmentString> segStrings);
    private Coordinate[] Scale(Coordinate[] pts);
    private void Rescale(IList`1<ISegmentString> segStrings);
    private void Rescale(Coordinate[] pts);
}
public class NetTopologySuite.Noding.SegmentIntersectionDetector : object {
    private LineIntersector _li;
    private bool _hasIntersection;
    private bool _hasProperIntersection;
    private bool _hasNonProperIntersection;
    private Coordinate _intPt;
    private Coordinate[] _intSegments;
    [CompilerGeneratedAttribute]
private bool <FindProper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindAllIntersectionTypes>k__BackingField;
    public bool FindProper { get; public set; }
    public bool FindAllIntersectionTypes { get; public set; }
    public bool HasIntersection { get; }
    public bool HasProperIntersection { get; }
    public bool HasNonProperIntersection { get; }
    public Coordinate Intersection { get; }
    public Coordinate[] IntersectionSegments { get; }
    public bool IsDone { get; }
    public SegmentIntersectionDetector(LineIntersector li);
    [CompilerGeneratedAttribute]
public bool get_FindProper();
    [CompilerGeneratedAttribute]
public void set_FindProper(bool value);
    [CompilerGeneratedAttribute]
public bool get_FindAllIntersectionTypes();
    [CompilerGeneratedAttribute]
public void set_FindAllIntersectionTypes(bool value);
    public bool get_HasIntersection();
    public bool get_HasProperIntersection();
    public bool get_HasNonProperIntersection();
    public Coordinate get_Intersection();
    public Coordinate[] get_IntersectionSegments();
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual bool get_IsDone();
}
public class NetTopologySuite.Noding.SegmentNode : object {
    public Coordinate Coord;
    public int SegmentIndex;
    private INodableSegmentString _segString;
    private Octants _segmentOctant;
    private bool _isInterior;
    public Coordinate Coordinate { get; }
    public bool IsInterior { get; }
    public SegmentNode(INodableSegmentString segString, Coordinate coord, int segmentIndex, Octants segmentOctant);
    public Coordinate get_Coordinate();
    public bool get_IsInterior();
    public bool IsEndPoint(int maxSegmentIndex);
    public sealed virtual int CompareTo(object obj);
    public void Write(StreamWriter outstream);
}
public class NetTopologySuite.Noding.SegmentNodeList : object {
    private IDictionary`2<SegmentNode, object> _nodeMap;
    private NodedSegmentString _edge;
    public NodedSegmentString Edge { get; }
    public SegmentNodeList(NodedSegmentString edge);
    public NodedSegmentString get_Edge();
    public SegmentNode Add(Coordinate intPt, int segmentIndex);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void AddEndpoints();
    private void AddCollapsedNodes();
    private void FindCollapsesFromExistingVertices(IList`1<int> collapsedVertexIndexes);
    private void FindCollapsesFromInsertedNodes(IList`1<int> collapsedVertexIndexes);
    private static bool FindCollapseIndex(SegmentNode ei0, SegmentNode ei1, Int32[] collapsedVertexIndex);
    public void AddSplitEdges(IList`1<ISegmentString> edgeList);
    private ISegmentString CreateSplitEdge(SegmentNode ei0, SegmentNode ei1);
    public Coordinate[] GetSplitCoordinates();
    private void AddEdgeCoordinates(SegmentNode ei0, SegmentNode ei1, CoordinateList coordList);
    public void Write(StreamWriter outstream);
}
public class NetTopologySuite.Noding.SegmentPointComparator : object {
    public static int Compare(Octants octant, Coordinate p0, Coordinate p1);
    public static int RelativeSign(double x0, double x1);
    private static int CompareValue(int compareSign0, int compareSign1);
}
public class NetTopologySuite.Noding.SegmentStringDissolver : object {
    private ISegmentStringMerger _merger;
    private IDictionary`2<OrientedCoordinateArray, ISegmentString> _ocaMap;
    public ICollection`1<ISegmentString> Dissolved { get; }
    public SegmentStringDissolver(ISegmentStringMerger merger);
    public void Dissolve(IEnumerable`1<ISegmentString> segStrings);
    private void Add(OrientedCoordinateArray oca, ISegmentString segString);
    public void Dissolve(ISegmentString segString);
    private ISegmentString FindMatching(OrientedCoordinateArray oca);
    public ICollection`1<ISegmentString> get_Dissolved();
}
public class NetTopologySuite.Noding.SegmentStringUtil : object {
    public static IList`1<ISegmentString> ExtractSegmentStrings(IGeometry geom);
    public static IList`1<ISegmentString> ExtractNodedSegmentStrings(IGeometry geom);
    public static IGeometry ToGeometry(IList`1<ISegmentString> segStrings, IGeometryFactory geomFact);
    public static string ToString(IEnumerable`1<ISegmentString> segStrings);
}
public class NetTopologySuite.Noding.SimpleNoder : SinglePassNoder {
    private IList`1<ISegmentString> _nodedSegStrings;
    public SimpleNoder(ISegmentIntersector segInt);
    public virtual IList`1<ISegmentString> GetNodedSubstrings();
    public virtual void ComputeNodes(IList`1<ISegmentString> inputSegStrings);
    private void ComputeIntersects(ISegmentString e0, ISegmentString e1);
}
public class NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector : object {
    private ICollection`1<ISegmentString> _baseBaseSegStrings;
    public SimpleSegmentSetMutualIntersector(ICollection`1<ISegmentString> baseSegStrings);
    public sealed virtual void Process(ICollection`1<ISegmentString> segmentStrings, ISegmentIntersector segmentIntersector);
    private static void Intersect(ISegmentString ss0, ISegmentString ss1, ISegmentIntersector segInt);
}
public abstract class NetTopologySuite.Noding.SinglePassNoder : object {
    [CompilerGeneratedAttribute]
private ISegmentIntersector <SegmentIntersector>k__BackingField;
    public ISegmentIntersector SegmentIntersector { get; public set; }
    protected SinglePassNoder(ISegmentIntersector segInt);
    [CompilerGeneratedAttribute]
public ISegmentIntersector get_SegmentIntersector();
    [CompilerGeneratedAttribute]
public void set_SegmentIntersector(ISegmentIntersector value);
    public abstract virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    public abstract virtual IList`1<ISegmentString> GetNodedSubstrings();
}
public class NetTopologySuite.Noding.Snapround.GeometryNoder : object {
    private IGeometryFactory _geomFact;
    private IPrecisionModel _pm;
    [CompilerGeneratedAttribute]
private bool <IsValidityChecked>k__BackingField;
    public bool IsValidityChecked { get; public set; }
    public GeometryNoder(IPrecisionModel pm);
    [CompilerGeneratedAttribute]
public bool get_IsValidityChecked();
    [CompilerGeneratedAttribute]
public void set_IsValidityChecked(bool value);
    public IList`1<ILineString> Node(ICollection`1<IGeometry> geoms);
    private IList`1<ILineString> ToLineStrings(IEnumerable`1<ISegmentString> segStrings);
    private static IEnumerable`1<IGeometry> ExtractLines(IEnumerable`1<IGeometry> geoms);
    private static IList`1<ISegmentString> ToSegmentStrings(IEnumerable`1<IGeometry> lines);
}
public class NetTopologySuite.Noding.Snapround.HotPixel : object {
    private LineIntersector _li;
    private Coordinate _pt;
    private Coordinate _originalPt;
    private Coordinate _p0Scaled;
    private Coordinate _p1Scaled;
    private double _scaleFactor;
    private double _minx;
    private double _maxx;
    private double _miny;
    private double _maxy;
    private Coordinate[] _corner;
    private Envelope _safeEnv;
    private static double SafeEnvelopeExpansionFactor;
    public Coordinate Coordinate { get; }
    public HotPixel(Coordinate pt, double scaleFactor, LineIntersector li);
    public Coordinate get_Coordinate();
    public Envelope GetSafeEnvelope();
    private void InitCorners(Coordinate pt);
    private double Scale(double val);
    public bool Intersects(Coordinate p0, Coordinate p1);
    private void CopyScaled(Coordinate p, Coordinate pScaled);
    public bool IntersectsScaled(Coordinate p0, Coordinate p1);
    private bool IntersectsToleranceSquare(Coordinate p0, Coordinate p1);
    private bool IntersectsPixelClosure(Coordinate p0, Coordinate p1);
    public bool AddSnappedNode(INodableSegmentString segStr, int segIndex);
}
public class NetTopologySuite.Noding.Snapround.MCIndexPointSnapper : object {
    private STRtree`1<MonotoneChain> _index;
    public MCIndexPointSnapper(ISpatialIndex`1<MonotoneChain> index);
    public bool Snap(HotPixel hotPixel, ISegmentString parentEdge, int hotPixelVertexIndex);
    public bool Snap(HotPixel hotPixel);
}
public class NetTopologySuite.Noding.Snapround.MCIndexSnapRounder : object {
    private LineIntersector _li;
    private double _scaleFactor;
    private MCIndexNoder _noder;
    private MCIndexPointSnapper _pointSnapper;
    private IList`1<ISegmentString> _nodedSegStrings;
    public MCIndexSnapRounder(IPrecisionModel pm);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> inputSegmentStrings);
    private void SnapRound(IList`1<ISegmentString> segStrings, LineIntersector li);
    private IList`1<Coordinate> FindInteriorIntersections(IList`1<ISegmentString> segStrings, LineIntersector li);
    private void ComputeIntersectionSnaps(IEnumerable`1<Coordinate> snapPts);
    public void ComputeVertexSnaps(IList`1<ISegmentString> edges);
    private void ComputeVertexSnaps(INodableSegmentString e);
}
public class NetTopologySuite.Noding.Snapround.SimpleSnapRounder : object {
    private LineIntersector _li;
    private double _scaleFactor;
    private IList`1<ISegmentString> _nodedSegStrings;
    public SimpleSnapRounder(PrecisionModel pm);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> inputSegmentStrings);
    private void SnapRound(IList`1<ISegmentString> segStrings, LineIntersector li);
    private static IList`1<Coordinate> FindInteriorIntersections(IList`1<ISegmentString> segStrings, LineIntersector li);
    private void ComputeSnaps(IEnumerable`1<ISegmentString> segStrings, ICollection`1<Coordinate> snapPts);
    private void ComputeSnaps(INodableSegmentString ss, IEnumerable`1<Coordinate> snapPts);
    public void ComputeVertexSnaps(IList`1<ISegmentString> edges);
    private void ComputeVertexSnaps(INodableSegmentString e0, INodableSegmentString e1);
}
public class NetTopologySuite.NtsGeometryServices : object {
    private static IGeometryServices modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    private static object LockObject1;
    private static object LockObject2;
    private object _factoriesLock;
    private SaveDictionary`2<GeometryFactoryKey, IGeometryFactory> _factories;
    [CompilerGeneratedAttribute]
private int <DefaultSRID>k__BackingField;
    [CompilerGeneratedAttribute]
private ICoordinateSequenceFactory <DefaultCoordinateSequenceFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrecisionModel <DefaultPrecisionModel>k__BackingField;
    public static IGeometryServices Instance { get; public set; }
    public int DefaultSRID { get; public set; }
    public ICoordinateSequenceFactory DefaultCoordinateSequenceFactory { get; private set; }
    public IPrecisionModel DefaultPrecisionModel { get; private set; }
    public int NumFactories { get; }
    public NtsGeometryServices(ICoordinateSequenceFactory coordinateSequenceFactory, IPrecisionModel precisionModel, int srid);
    private static NtsGeometryServices();
    public static IGeometryServices get_Instance();
    public static void set_Instance(IGeometryServices value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DefaultSRID();
    [CompilerGeneratedAttribute]
public void set_DefaultSRID(int value);
    [CompilerGeneratedAttribute]
public sealed virtual ICoordinateSequenceFactory get_DefaultCoordinateSequenceFactory();
    [CompilerGeneratedAttribute]
private void set_DefaultCoordinateSequenceFactory(ICoordinateSequenceFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual IPrecisionModel get_DefaultPrecisionModel();
    [CompilerGeneratedAttribute]
private void set_DefaultPrecisionModel(IPrecisionModel value);
    public sealed virtual IPrecisionModel CreatePrecisionModel(PrecisionModels modelType);
    public sealed virtual IPrecisionModel CreatePrecisionModel(IPrecisionModel precisionModel);
    public sealed virtual IPrecisionModel CreatePrecisionModel(double scale);
    public sealed virtual IGeometryFactory CreateGeometryFactory();
    public sealed virtual IGeometryFactory CreateGeometryFactory(int srid);
    public sealed virtual void ReadConfiguration();
    public sealed virtual void WriteConfiguration();
    public sealed virtual IGeometryFactory CreateGeometryFactory(ICoordinateSequenceFactory coordinateSequenceFactory);
    public sealed virtual IGeometryFactory CreateGeometryFactory(IPrecisionModel precisionModel);
    public sealed virtual IGeometryFactory CreateGeometryFactory(IPrecisionModel precisionModel, int srid);
    public sealed virtual IGeometryFactory CreateGeometryFactory(IPrecisionModel precisionModel, int srid, ICoordinateSequenceFactory coordinateSequenceFactory);
    public int get_NumFactories();
}
public class NetTopologySuite.Operation.BoundaryOp : object {
    private IGeometry _geom;
    private IGeometryFactory _geomFact;
    private IBoundaryNodeRule _bnRule;
    private IDictionary`2<Coordinate, Counter> _endpointMap;
    public BoundaryOp(IGeometry geom);
    public BoundaryOp(IGeometry geom, IBoundaryNodeRule bnRule);
    public static IGeometry GetBoundary(IGeometry g);
    public static IGeometry GetBoundary(IGeometry g, IBoundaryNodeRule bnRule);
    public IGeometry GetBoundary();
    private IMultiPoint GetEmptyMultiPoint();
    private IGeometry BoundaryMultiLineString(IMultiLineString mLine);
    private Coordinate[] ComputeBoundaryCoordinates(IMultiLineString mLine);
    private void AddEndpoint(Coordinate pt);
    private IGeometry BoundaryLineString(ILineString line);
}
internal class NetTopologySuite.Operation.Buffer.BufferBuilder : object {
    private IBufferParameters _bufParams;
    private IPrecisionModel _workingPrecisionModel;
    private INoder _workingNoder;
    private IGeometryFactory _geomFact;
    private PlanarGraph _graph;
    private EdgeList _edgeList;
    public IPrecisionModel WorkingPrecisionModel { get; public set; }
    public INoder Noder { get; public set; }
    public BufferBuilder(IBufferParameters bufParams);
    private static int DepthDelta(Label label);
    public IPrecisionModel get_WorkingPrecisionModel();
    public void set_WorkingPrecisionModel(IPrecisionModel value);
    public INoder get_Noder();
    public void set_Noder(INoder value);
    public IGeometry Buffer(IGeometry g, double distance);
    private INoder GetNoder(IPrecisionModel precisionModel);
    private void ComputeNodedEdges(IList`1<ISegmentString> bufferSegStrList, IPrecisionModel precisionModel);
    protected void InsertUniqueEdge(Edge e);
    private static IEnumerable`1<BufferSubgraph> CreateSubgraphs(PlanarGraph graph);
    private static void BuildSubgraphs(IEnumerable`1<BufferSubgraph> subgraphList, PolygonBuilder polyBuilder);
    private static IGeometry ConvertSegStrings(IEnumerator`1<ISegmentString> it);
    private IGeometry CreateEmptyResultGeometry();
}
public class NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier : object {
    private static int NumPtsToCheck;
    private static int Delete;
    private Coordinate[] _inputLine;
    private double _distanceTol;
    private Byte[] _isDeleted;
    private OrientationIndex _angleOrientation;
    public BufferInputLineSimplifier(Coordinate[] inputLine);
    public static Coordinate[] Simplify(Coordinate[] inputLine, double distanceTol);
    public Coordinate[] Simplify(double distanceTol);
    private bool DeleteShallowConcavities();
    private int FindNextNonDeletedIndex(int index);
    private Coordinate[] CollapseLine();
    private bool IsDeletable(int i0, int i1, int i2, double distanceTol);
    private bool IsShallowSampled(Coordinate p0, Coordinate p2, int i0, int i2, double distanceTol);
    private static bool IsShallow(Coordinate p0, Coordinate p1, Coordinate p2, double distanceTol);
    private bool IsConcave(Coordinate p0, Coordinate p1, Coordinate p2);
}
public class NetTopologySuite.Operation.Buffer.BufferOp : object {
    private static int MaxPrecisionDigits;
    private IGeometry _argGeom;
    private double _distance;
    private IBufferParameters _bufParams;
    private IGeometry _resultGeometry;
    private Exception _saveException;
    [ObsoleteAttribute]
public BufferStyle BufferStyle { get; public set; }
    public int QuadrantSegments { get; public set; }
    public BufferOp(IGeometry g);
    public BufferOp(IGeometry g, IBufferParameters bufParams);
    private static double PrecisionScaleFactor(IGeometry g, double distance, int maxPrecisionDigits);
    public static IGeometry Buffer(IGeometry g, double distance);
    public static IGeometry Buffer(IGeometry g, double distance, IBufferParameters parameters);
    public static IGeometry Buffer(IGeometry g, double distance, int quadrantSegments);
    [ObsoleteAttribute("use Buffer(IGeometry, distance, IBufferParameters) instead!")]
public static IGeometry Buffer(IGeometry g, double distance, int quadrantSegments, BufferStyle endCapStyle);
    public BufferStyle get_BufferStyle();
    public void set_BufferStyle(BufferStyle value);
    public int get_QuadrantSegments();
    public void set_QuadrantSegments(int value);
    public IGeometry GetResultGeometry(double distance);
    private void ComputeGeometry();
    private void BufferReducedPrecision();
    private void BufferOriginalPrecision();
    private void BufferReducedPrecision(int precisionDigits);
    private void BufferFixedPrecision(IPrecisionModel fixedPrecModel);
}
public class NetTopologySuite.Operation.Buffer.BufferParameters : object {
    public static int DefaultQuadrantSegments;
    public static double DefaultMitreLimit;
    public static double DefaultSimplifyFactor;
    private int _quadrantSegments;
    private EndCapStyle _endCapStyle;
    private JoinStyle _joinStyle;
    private double _mitreLimit;
    private double _simplifyFactor;
    [CompilerGeneratedAttribute]
private bool <IsSingleSided>k__BackingField;
    public int QuadrantSegments { get; public set; }
    public EndCapStyle EndCapStyle { get; public set; }
    public JoinStyle JoinStyle { get; public set; }
    public double MitreLimit { get; public set; }
    public bool IsSingleSided { get; public set; }
    public double SimplifyFactor { get; public set; }
    public BufferParameters(int quadrantSegments);
    public BufferParameters(int quadrantSegments, EndCapStyle endCapStyle);
    public BufferParameters(int quadrantSegments, EndCapStyle endCapStyle, JoinStyle joinStyle, double mitreLimit);
    public sealed virtual int get_QuadrantSegments();
    public sealed virtual void set_QuadrantSegments(int value);
    public static double BufferDistanceError(int quadSegs);
    public sealed virtual EndCapStyle get_EndCapStyle();
    public sealed virtual void set_EndCapStyle(EndCapStyle value);
    public sealed virtual JoinStyle get_JoinStyle();
    public sealed virtual void set_JoinStyle(JoinStyle value);
    public sealed virtual double get_MitreLimit();
    public sealed virtual void set_MitreLimit(double value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSingleSided();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsSingleSided(bool value);
    public sealed virtual double get_SimplifyFactor();
    public sealed virtual void set_SimplifyFactor(double value);
}
internal class NetTopologySuite.Operation.Buffer.BufferSubgraph : object {
    private RightmostEdgeFinder _finder;
    private List`1<DirectedEdge> _dirEdgeList;
    private List`1<Node> _nodes;
    private Coordinate _rightMostCoord;
    public IList`1<DirectedEdge> DirectedEdges { get; }
    public IList`1<Node> Nodes { get; }
    public Coordinate RightMostCoordinate { get; }
    public IList`1<DirectedEdge> get_DirectedEdges();
    public IList`1<Node> get_Nodes();
    public Coordinate get_RightMostCoordinate();
    public void Create(Node node);
    private void AddReachable(Node startNode);
    private void Add(Node node, Stack`1<Node> nodeStack);
    private void ClearVisitedEdges();
    public void ComputeDepth(int outsideDepth);
    private static void ComputeDepths(DirectedEdge startEdge);
    private static void ComputeNodeDepth(Node n);
    private static void CopySymDepths(DirectedEdge de);
    public void FindResultEdges();
    public sealed virtual int CompareTo(object o);
}
public class NetTopologySuite.Operation.Buffer.OffsetCurveBuilder : object {
    private double _distance;
    private IPrecisionModel _precisionModel;
    private IBufferParameters _bufParams;
    public IBufferParameters BufferParameters { get; }
    public OffsetCurveBuilder(IPrecisionModel precisionModel, IBufferParameters bufParams);
    public IBufferParameters get_BufferParameters();
    public Coordinate[] GetLineCurve(Coordinate[] inputPts, double distance);
    public Coordinate[] GetRingCurve(Coordinate[] inputPts, Positions side, double distance);
    public Coordinate[] GetOffsetCurve(Coordinate[] inputPts, double distance);
    private static Coordinate[] CopyCoordinates(Coordinate[] pts);
    private OffsetSegmentGenerator GetSegmentGenerator(double distance);
    private double SimplifyTolerance(double bufDistance);
    private void ComputePointCurve(Coordinate pt, OffsetSegmentGenerator segGen);
    private void ComputeLineBufferCurve(Coordinate[] inputPts, OffsetSegmentGenerator segGen);
    private void ComputeSingleSidedBufferCurve(Coordinate[] inputPts, bool isRightSide, OffsetSegmentGenerator segGen);
    private void ComputeOffsetCurve(Coordinate[] inputPts, bool isRightSide, OffsetSegmentGenerator segGen);
    private void ComputeRingBufferCurve(Coordinate[] inputPts, Positions side, OffsetSegmentGenerator segGen);
}
public class NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder : object {
    private IGeometry _inputGeom;
    private double _distance;
    private OffsetCurveBuilder _curveBuilder;
    private IList`1<ISegmentString> _curveList;
    public OffsetCurveSetBuilder(IGeometry inputGeom, double distance, OffsetCurveBuilder curveBuilder);
    public IList`1<ISegmentString> GetCurves();
    private void AddCurve(Coordinate[] coord, Location leftLoc, Location rightLoc);
    private void Add(IGeometry g);
    private void AddCollection(IGeometry gc);
    private void AddPoint(IGeometry p);
    private void AddLineString(IGeometry line);
    private void AddPolygon(IPolygon p);
    private void AddPolygonRing(Coordinate[] coord, double offsetDistance, Positions side, Location cwLeftLoc, Location cwRightLoc);
    private bool IsErodedCompletely(Coordinate[] ringCoord, double bufferDistance);
    private static bool IsTriangleErodedCompletely(Coordinate[] triangleCoord, double bufferDistance);
}
public class NetTopologySuite.Operation.Buffer.OffsetCurveVertexList : object {
    private List`1<Coordinate> _ptList;
    private IPrecisionModel _precisionModel;
    private double _minimimVertexDistance;
    public IPrecisionModel PrecisionModel { get; public set; }
    public double MinimumVertexDistance { get; public set; }
    public Coordinate[] Coordinates { get; }
    public IPrecisionModel get_PrecisionModel();
    public void set_PrecisionModel(IPrecisionModel value);
    public double get_MinimumVertexDistance();
    public void set_MinimumVertexDistance(double value);
    public void AddPt(Coordinate pt);
    private bool IsDuplicate(Coordinate pt);
    public void CloseRing();
    public Coordinate[] get_Coordinates();
    public virtual string ToString();
}
internal class NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator : object {
    private static double OffsetSegmentSeparationFactor;
    private static double InsideTurnVertexSnapDistanceFactor;
    private static double CurveVertexSnapDistanceFactor;
    private static int MaxClosingSegLenFactor;
    private double _maxCurveSegmentError;
    private double _filletAngleQuantum;
    private int _closingSegLengthFactor;
    private OffsetSegmentString _segList;
    private double _distance;
    private IPrecisionModel _precisionModel;
    private IBufferParameters _bufParams;
    private LineIntersector _li;
    private Coordinate _s0;
    private Coordinate _s1;
    private Coordinate _s2;
    private LineSegment _seg0;
    private LineSegment _seg1;
    private LineSegment _offset0;
    private LineSegment _offset1;
    private Positions _side;
    private bool _hasNarrowConcaveAngle;
    public bool HasNarrowConcaveAngle { get; }
    public OffsetSegmentGenerator(IPrecisionModel precisionModel, IBufferParameters bufParams, double distance);
    public bool get_HasNarrowConcaveAngle();
    private void Init(double distance);
    public void InitSideSegments(Coordinate s1, Coordinate s2, Positions side);
    public Coordinate[] GetCoordinates();
    public void CloseRing();
    public void AddSegments(Coordinate[] pt, bool isForward);
    public void AddFirstSegment();
    public void AddLastSegment();
    public void AddNextSegment(Coordinate p, bool addStartPoint);
    private void AddCollinear(bool addStartPoint);
    private void AddOutsideTurn(OrientationIndex orientation, bool addStartPoint);
    private void AddInsideTurn(OrientationIndex orientation, bool addStartPoint);
    private static void ComputeOffsetSegment(LineSegment seg, Positions side, double distance, LineSegment offset);
    public void AddLineEndCap(Coordinate p0, Coordinate p1);
    private void AddMitreJoin(Coordinate p, LineSegment offset0, LineSegment offset1, double distance);
    private void AddLimitedMitreJoin(LineSegment offset0, LineSegment offset1, double distance, double mitreLimit);
    private void AddBevelJoin(LineSegment offset0, LineSegment offset1);
    private void AddCornerFillet(Coordinate p, Coordinate p0, Coordinate p1, OrientationIndex direction, double radius);
    private void AddDirectedFillet(Coordinate p, double startAngle, double endAngle, OrientationIndex direction, double radius);
    public void CreateCircle(Coordinate p);
    public void CreateSquare(Coordinate p);
}
internal class NetTopologySuite.Operation.Buffer.OffsetSegmentString : object {
    private List`1<Coordinate> _ptList;
    private IPrecisionModel _precisionModel;
    private double _minimimVertexDistance;
    public IPrecisionModel PrecisionModel { get; public set; }
    public double MinimumVertexDistance { get; public set; }
    public IPrecisionModel get_PrecisionModel();
    public void set_PrecisionModel(IPrecisionModel value);
    public double get_MinimumVertexDistance();
    public void set_MinimumVertexDistance(double value);
    public void AddPt(Coordinate pt);
    public void AddPts(Coordinate[] pt, bool isForward);
    private bool IsRedundant(Coordinate pt);
    public void CloseRing();
    public void Reverse();
    public Coordinate[] GetCoordinates();
    public virtual string ToString();
}
public class NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder : object {
    private double _filletAngleQuantum;
    private double _maxCurveSegmentError;
    private static double CurveVertexSnapDistanceFactor;
    private static double OFFSET_SEGMENT_SEPARATION_FACTOR;
    private static double INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR;
    private static int MAX_CLOSING_SEG_FRACTION;
    private double _distance;
    private IPrecisionModel _precisionModel;
    private IBufferParameters _bufParams;
    private int closingSegFactor;
    private OffsetCurveVertexList _vertexList;
    private LineIntersector _li;
    private static double SimplifyFactor;
    private Coordinate _s0;
    private Coordinate _s1;
    private Coordinate _s2;
    private LineSegment _seg0;
    private LineSegment _seg1;
    private LineSegment _offset0;
    private LineSegment _offset1;
    private Positions _side;
    private static double _maxClosingSegLen;
    public OldOffsetCurveBuilder(IPrecisionModel precisionModel, IBufferParameters bufParams);
    private static OldOffsetCurveBuilder();
    public IList`1<Coordinate[]> GetLineCurve(Coordinate[] inputPts, double distance);
    public IList`1<Coordinate[]> GetRingCurve(Coordinate[] inputPts, Positions side, double distance);
    private static Coordinate[] CopyCoordinates(Coordinate[] pts);
    private void Init(double distance);
    private static double SimplifyTolerance(double bufDistance);
    private void ComputeLineBufferCurve(Coordinate[] inputPts);
    private void OldcomputeLineBufferCurve(Coordinate[] inputPts);
    private void ComputeRingBufferCurve(Coordinate[] inputPts, Positions side);
    private void InitSideSegments(Coordinate s1, Coordinate s2, Positions side);
    private void AddNextSegment(Coordinate p, bool addStartPoint);
    private void AddCollinear(bool addStartPoint);
    private void AddOutsideTurn(OrientationIndex orientation, bool addStartPoint);
    private void AddInsideTurn(OrientationIndex orientation, bool addStartPoint);
    private void AddLastSegment();
    private static void ComputeOffsetSegment(LineSegment seg, Positions side, double distance, LineSegment offset);
    private void AddLineEndCap(Coordinate p0, Coordinate p1);
    private void AddMitreJoin(Coordinate p, LineSegment offset0, LineSegment offset1, double distance);
    private void AddLimitedMitreJoin(LineSegment offset0, LineSegment offset1, double distance, double mitreLimit);
    private void AddBevelJoin(LineSegment offset0, LineSegment offset1);
    private void AddFillet(Coordinate p, Coordinate p0, Coordinate p1, OrientationIndex direction, double radius);
    private void AddFillet(Coordinate p, double startAngle, double endAngle, OrientationIndex direction, double radius);
    private void AddCircle(Coordinate p, double distance);
    private void AddSquare(Coordinate p, double distance);
}
internal class NetTopologySuite.Operation.Buffer.RightmostEdgeFinder : object {
    private int minIndex;
    private Coordinate minCoord;
    private DirectedEdge minDe;
    private DirectedEdge orientedDe;
    public DirectedEdge Edge { get; }
    public Coordinate Coordinate { get; }
    public DirectedEdge get_Edge();
    public Coordinate get_Coordinate();
    public void FindEdge(IList dirEdgeList);
    private void FindRightmostEdgeAtNode();
    private void FindRightmostEdgeAtVertex();
    private void CheckForRightmostCoordinate(DirectedEdge de);
    private Positions GetRightmostSide(DirectedEdge de, int index);
    private Positions GetRightmostSideOfSegment(DirectedEdge de, int i);
}
internal class NetTopologySuite.Operation.Buffer.SubgraphDepthLocater : object {
    private IList`1<BufferSubgraph> _subgraphs;
    private LineSegment _seg;
    public SubgraphDepthLocater(IList`1<BufferSubgraph> subgraphs);
    public int GetDepth(Coordinate p);
    private IList`1<DepthSegment> FindStabbedSegments(Coordinate stabbingRayLeftPt);
    private void FindStabbedSegments(Coordinate stabbingRayLeftPt, IEnumerable`1<DirectedEdge> dirEdges, IList`1<DepthSegment> stabbedSegments);
    private void FindStabbedSegments(Coordinate stabbingRayLeftPt, DirectedEdge dirEdge, IList`1<DepthSegment> stabbedSegments);
}
public class NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder : object {
    private IGeometry _inputGeom;
    private PointPairDistance _maxPtDist;
    public PointPairDistance DistancePoints { get; }
    public BufferCurveMaximumDistanceFinder(IGeometry inputGeom);
    public double FindDistance(IGeometry bufferCurve);
    public PointPairDistance get_DistancePoints();
    private void ComputeMaxVertexDistance(IGeometry curve);
    private void computeMaxMidpointDistance(IGeometry curve);
}
public class NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator : object {
    public static bool Verbose;
    private static double MaxDistanceDiffFrac;
    private IGeometry _input;
    private double _bufDistance;
    private IGeometry _result;
    private double _minValidDistance;
    private double _maxValidDistance;
    private double _minDistanceFound;
    private double _maxDistanceFound;
    private bool _isValid;
    private string _errMsg;
    private Coordinate _errorLocation;
    private IGeometry _errorIndicator;
    public string ErrorMessage { get; }
    public Coordinate ErrorLocation { get; }
    public IGeometry ErrorIndicator { get; }
    public BufferDistanceValidator(IGeometry input, double bufDistance, IGeometry result);
    public bool IsValid();
    public string get_ErrorMessage();
    public Coordinate get_ErrorLocation();
    public IGeometry get_ErrorIndicator();
    private void CheckPositiveValid();
    private void CheckNegativeValid();
    private static IGeometry GetPolygonLines(IGeometry g);
    private void CheckMinimumDistance(IGeometry g1, IGeometry g2, double minDist);
    private void CheckMaximumDistance(IGeometry input, IGeometry bufCurve, double maxDist);
}
public class NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator : object {
    public static bool Verbose;
    private static double MaxEnvDiffFrac;
    private IGeometry _input;
    private double _distance;
    private IGeometry _result;
    private bool _isValid;
    private string _errorMsg;
    private Coordinate _errorLocation;
    private IGeometry _errorIndicator;
    public string ErrorMessage { get; }
    public Coordinate ErrorLocation { get; }
    public IGeometry ErrorIndicator { get; }
    public BufferResultValidator(IGeometry input, double distance, IGeometry result);
    public static bool IsValid(IGeometry g, double distance, IGeometry result);
    public static string IsValidMessage(IGeometry g, double distance, IGeometry result);
    public bool IsValid();
    public string get_ErrorMessage();
    public Coordinate get_ErrorLocation();
    public IGeometry get_ErrorIndicator();
    private void Report(string checkName);
    private void CheckPolygonal();
    private void CheckExpectedEmpty();
    private void CheckEnvelope();
    private void CheckArea();
    private void CheckDistance();
}
public static class NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder : object {
    public static void ComputeDistance(IGeometry geom, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(ILineString line, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(LineSegment segment, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(IPolygon poly, Coordinate pt, PointPairDistance ptDist);
}
public class NetTopologySuite.Operation.Buffer.Validate.PointPairDistance : object {
    private Coordinate[] _pt;
    private double _distance;
    private bool _isNull;
    public double Distance { get; }
    public Coordinate[] Coordinates { get; }
    public void Initialize();
    public void Initialize(Coordinate p0, Coordinate p1);
    private void Initialize(Coordinate p0, Coordinate p1, double distance);
    public double get_Distance();
    public Coordinate[] get_Coordinates();
    public Coordinate GetCoordinate(int i);
    public void SetMaximum(PointPairDistance ptDist);
    public void SetMaximum(Coordinate p0, Coordinate p1);
    public void SetMinimum(PointPairDistance ptDist);
    public void SetMinimum(Coordinate p0, Coordinate p1);
}
internal class NetTopologySuite.Operation.Counter : object {
    public int Count;
}
public class NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter : object {
    private IList`1<GeometryLocation> _locations;
    private ConnectedElementLocationFilter(IList`1<GeometryLocation> locations);
    public static IList`1<GeometryLocation> GetLocations(IGeometry geom);
    public sealed virtual void Filter(IGeometry geom);
}
public class NetTopologySuite.Operation.Distance.ConnectedElementPointFilter : object {
    private IList`1<Coordinate> _pts;
    private ConnectedElementPointFilter(IList`1<Coordinate> pts);
    public static IList`1<Coordinate> GetCoordinates(Geometry geom);
    public sealed virtual void Filter(IGeometry geom);
}
public class NetTopologySuite.Operation.Distance.DistanceOp : object {
    private PointLocator _ptLocator;
    private IGeometry[] _geom;
    private GeometryLocation[] _minDistanceLocation;
    private double _minDistance;
    private double _terminateDistance;
    public DistanceOp(IGeometry g0, IGeometry g1);
    public DistanceOp(IGeometry g0, IGeometry g1, double terminateDistance);
    public static double Distance(IGeometry g0, IGeometry g1);
    public static bool IsWithinDistance(IGeometry g0, IGeometry g1, double distance);
    public static Coordinate[] NearestPoints(IGeometry g0, IGeometry g1);
    [ObsoleteAttribute("Renamed to NearestPoints")]
public static Coordinate[] ClosestPoints(IGeometry g0, IGeometry g1);
    public double Distance();
    [ObsoleteAttribute("Renamed to NearestPoints")]
public Coordinate[] ClosestPoints();
    [ObsoleteAttribute("Renamed to NearestLocations")]
public GeometryLocation[] ClosestLocations();
    public Coordinate[] NearestPoints();
    public GeometryLocation[] NearestLocations();
    private void UpdateMinDistance(double dist);
    private void UpdateMinDistance(GeometryLocation[] locGeom, bool flip);
    private void ComputeMinDistance();
    private void ComputeContainmentDistance();
    private void ComputeContainmentDistance(int polyGeomIndex, GeometryLocation[] locPtPoly);
    private void ComputeContainmentDistance(IList`1<GeometryLocation> locs, ICollection`1<IGeometry> polys, GeometryLocation[] locPtPoly);
    private void ComputeContainmentDistance(GeometryLocation ptLoc, IPolygon poly, GeometryLocation[] locPtPoly);
    private void ComputeFacetDistance();
    private void ComputeMinDistanceLines(IEnumerable`1<IGeometry> lines0, ICollection`1<IGeometry> lines1, GeometryLocation[] locGeom);
    private void ComputeMinDistancePoints(IEnumerable`1<IGeometry> points0, ICollection`1<IGeometry> points1, GeometryLocation[] locGeom);
    private void ComputeMinDistanceLinesPoints(IEnumerable`1<IGeometry> lines, ICollection`1<IGeometry> points, GeometryLocation[] locGeom);
    private void ComputeMinDistance(ILineString line0, ILineString line1, GeometryLocation[] locGeom);
    private void ComputeMinDistance(ILineString line, IPoint pt, GeometryLocation[] locGeom);
}
public class NetTopologySuite.Operation.Distance.FacetSequence : object {
    private ICoordinateSequence _pts;
    private int _start;
    private int _end;
    private Coordinate _pt;
    private Coordinate _seqPt;
    public Envelope Envelope { get; }
    public int Count { get; }
    public bool IsPoint { get; }
    public FacetSequence(ICoordinateSequence pts, int start, int end);
    public FacetSequence(ICoordinateSequence pts, int index);
    public Envelope get_Envelope();
    public int get_Count();
    public Coordinate GetCoordinate(int index);
    public bool get_IsPoint();
    public double Distance(FacetSequence facetSeq);
    private double ComputeLineLineDistance(FacetSequence facetSeq);
    private static double ComputePointLineDistance(Coordinate pt, FacetSequence facetSeq);
    public virtual string ToString();
}
public static class NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder : object {
    private static int FacetSequenceSize;
    private static int STRtreeNodeCapacity;
    public static STRtree`1<FacetSequence> BuildSTRtree(IGeometry g);
    private static List`1<FacetSequence> ComputeFacetSequences(IGeometry g);
    private static void AddFacetSequences(ICoordinateSequence pts, List`1<FacetSequence> sections);
}
public class NetTopologySuite.Operation.Distance.GeometryLocation : object {
    public static int InsideArea;
    private IGeometry _component;
    private int _segIndex;
    private Coordinate _pt;
    public IGeometry GeometryComponent { get; }
    public int SegmentIndex { get; }
    public Coordinate Coordinate { get; }
    public bool IsInsideArea { get; }
    public GeometryLocation(IGeometry component, int segIndex, Coordinate pt);
    public GeometryLocation(IGeometry component, Coordinate pt);
    public IGeometry get_GeometryComponent();
    public int get_SegmentIndex();
    public Coordinate get_Coordinate();
    public bool get_IsInsideArea();
}
public class NetTopologySuite.Operation.Distance.IndexedFacetDistance : object {
    private STRtree`1<FacetSequence> _cachedTree;
    public IndexedFacetDistance(IGeometry g1);
    public static double Distance(IGeometry g1, IGeometry g2);
    public double GetDistance(IGeometry g);
    private static double FacetDistance(FacetSequence[] obj);
}
public class NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence : object {
    private static Ordinate[] XYIndex;
    private static Ordinate[] XZIndex;
    private static Ordinate[] YZIndex;
    private ICoordinateSequence _seq;
    private Ordinate[] _indexMap;
    public int Dimension { get; }
    public Ordinates Ordinates { get; }
    public int Count { get; }
    private AxisPlaneCoordinateSequence(ICoordinateSequence seq, Ordinate[] indexMap);
    private static AxisPlaneCoordinateSequence();
    public static ICoordinateSequence ProjectToXY(ICoordinateSequence seq);
    public static ICoordinateSequence ProjectToXZ(ICoordinateSequence seq);
    public static ICoordinateSequence ProjectToYZ(ICoordinateSequence seq);
    public sealed virtual int get_Dimension();
    public sealed virtual Ordinates get_Ordinates();
    public sealed virtual Coordinate GetCoordinate(int i);
    public sealed virtual Coordinate GetCoordinateCopy(int i);
    public sealed virtual void GetCoordinate(int index, Coordinate coord);
    public sealed virtual double GetX(int index);
    public sealed virtual double GetY(int index);
    public double GetZ(int index);
    public sealed virtual double GetOrdinate(int index, Ordinate ordinateIndex);
    public sealed virtual int get_Count();
    public sealed virtual void SetOrdinate(int index, Ordinate ordinateIndex, double value);
    public sealed virtual Coordinate[] ToCoordinateArray();
    public sealed virtual Envelope ExpandEnvelope(Envelope env);
    [ObsoleteAttribute]
public sealed virtual object Clone();
    public sealed virtual ICoordinateSequence Copy();
    public sealed virtual ICoordinateSequence Reversed();
}
public class NetTopologySuite.Operation.Distance3D.Distance3DOp : object {
    private IGeometry[] _geom;
    private double _terminateDistance;
    private GeometryLocation[] _minDistanceLocation;
    private double _minDistance;
    private bool _isDone;
    public Distance3DOp(IGeometry g0, IGeometry g1);
    public Distance3DOp(IGeometry g0, IGeometry g1, double terminateDistance);
    public static double Distance(IGeometry g0, IGeometry g1);
    public static bool IsWithinDistance(IGeometry g0, IGeometry g1, double distance);
    public static Coordinate[] NearestPoints(IGeometry g0, IGeometry g1);
    public double Distance();
    public Coordinate[] NearestPoints();
    public GeometryLocation[] NearestLocations();
    private void UpdateDistance(double dist, GeometryLocation loc0, GeometryLocation loc1, bool flip);
    private void ComputeMinDistance();
    private int MostPolygonalIndex();
    private void ComputeMinDistanceMultiMulti(IGeometry g0, IGeometry g1, bool flip);
    private void ComputeMinDistanceOneMulti(IGeometry g0, IGeometry g1, bool flip);
    private void ComputeMinDistanceOneMulti(PlanarPolygon3D poly, IGeometry geom, bool flip);
    private static PlanarPolygon3D PolyPlane(IGeometry poly);
    private void ComputeMinDistance(IGeometry g0, IGeometry g1, bool flip);
    private void ComputeMinDistancePolygonPolygon(PlanarPolygon3D poly0, IPolygon poly1, bool flip);
    private void ComputeMinDistancePolygonRings(PlanarPolygon3D poly, IPolygon ringPoly, bool flip);
    private void ComputeMinDistancePolygonLine(PlanarPolygon3D poly, ILineString line, bool flip);
    private static Coordinate Intersection(PlanarPolygon3D poly, ILineString line);
    private void ComputeMinDistancePolygonPoint(PlanarPolygon3D polyPlane, IPoint point, bool flip);
    private void ComputeMinDistanceLineLine(ILineString line0, ILineString line1, bool flip);
    private void ComputeMinDistanceLinePoint(ILineString line, IPoint point, bool flip);
    private void ComputeMinDistancePointPoint(IPoint point0, IPoint point1, bool flip);
    private static Coordinate SegmentPoint(Coordinate p0, Coordinate p1, double d0, double d1);
}
public class NetTopologySuite.Operation.Distance3D.PlanarPolygon3D : object {
    private Plane3D _plane;
    private IPolygon _poly;
    private Plane _facingPlane;
    public Plane3D Plane { get; }
    public IPolygon Polygon { get; }
    public PlanarPolygon3D(IPolygon poly);
    private static Plane3D FindBestFitPlane(IPolygon poly);
    private static Vector3D AverageNormal(ICoordinateSequence seq);
    private static Coordinate AveragePoint(ICoordinateSequence seq);
    public Plane3D get_Plane();
    public IPolygon get_Polygon();
    public bool Intersects(Coordinate intPt);
    private Location Locate(Coordinate pt, ILineString ring);
    public bool Intersects(Coordinate pt, ILineString ring);
    private static ICoordinateSequence Project(ICoordinateSequence seq, Plane facingPlane);
    private static Coordinate Project(Coordinate p, Plane facingPlane);
}
public class NetTopologySuite.Operation.GeometryGraphOperation : object {
    private LineIntersector _li;
    protected IPrecisionModel resultPrecisionModel;
    protected GeometryGraph[] arg;
    protected LineIntersector lineIntersector { get; protected set; }
    protected IPrecisionModel ComputationPrecision { get; protected set; }
    public GeometryGraphOperation(IGeometry g0, IGeometry g1);
    public GeometryGraphOperation(IGeometry g0, IGeometry g1, IBoundaryNodeRule boundaryNodeRule);
    public GeometryGraphOperation(IGeometry g0);
    protected LineIntersector get_lineIntersector();
    protected void set_lineIntersector(LineIntersector value);
    public IGeometry GetArgGeometry(int i);
    protected IPrecisionModel get_ComputationPrecision();
    protected void set_ComputationPrecision(IPrecisionModel value);
}
public class NetTopologySuite.Operation.IsSimpleOp : object {
    private IGeometry _inputGeom;
    private bool _isClosedEndpointsInInterior;
    private Coordinate _nonSimpleLocation;
    public Coordinate NonSimpleLocation { get; }
    public IsSimpleOp(IGeometry geom);
    public IsSimpleOp(IGeometry geom, IBoundaryNodeRule boundaryNodeRule);
    public bool IsSimple();
    private bool ComputeSimple(IGeometry geom);
    public Coordinate get_NonSimpleLocation();
    [ObsoleteAttribute("Use IsSimple()")]
public bool IsSimple(ILineString geom);
    [ObsoleteAttribute("Use IsSimple()")]
public bool IsSimple(IMultiLineString geom);
    [ObsoleteAttribute("Use IsSimple()")]
public bool IsSimple(IMultiPoint mp);
    private bool IsSimpleMultiPoint(IMultiPoint mp);
    private bool IsSimplePolygonal(IGeometry geom);
    private bool IsSimpleGeometryCollection(IGeometry geom);
    private bool IsSimpleLinearGeometry(IGeometry geom);
    private bool HasNonEndpointIntersection(GeometryGraph graph);
    private bool HasClosedEndpointIntersection(GeometryGraph graph);
    private static void AddEndpoint(IDictionary`2<Coordinate, EndpointInfo> endPoints, Coordinate p, bool isClosed);
}
public class NetTopologySuite.Operation.Linemerge.EdgeString : object {
    private IGeometryFactory factory;
    private List`1<LineMergeDirectedEdge> directedEdges;
    private Coordinate[] coordinates;
    private Coordinate[] Coordinates { get; }
    public EdgeString(IGeometryFactory factory);
    public void Add(LineMergeDirectedEdge directedEdge);
    private Coordinate[] get_Coordinates();
    public ILineString ToLineString();
}
public class NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge : DirectedEdge {
    public LineMergeDirectedEdge Next { get; }
    public LineMergeDirectedEdge(Node from, Node to, Coordinate directionPt, bool edgeDirection);
    public LineMergeDirectedEdge get_Next();
}
public class NetTopologySuite.Operation.Linemerge.LineMergeEdge : Edge {
    private ILineString line;
    public ILineString Line { get; }
    public LineMergeEdge(ILineString line);
    public ILineString get_Line();
}
public class NetTopologySuite.Operation.Linemerge.LineMergeGraph : PlanarGraph {
    public void AddEdge(ILineString lineString);
    private Node GetNode(Coordinate coordinate);
}
public class NetTopologySuite.Operation.Linemerge.LineMerger : object {
    private LineMergeGraph _graph;
    private List`1<IGeometry> _mergedLineStrings;
    private List`1<EdgeString> _edgeStrings;
    private IGeometryFactory _factory;
    public void Add(IGeometry geometry);
    public void Add(IEnumerable`1<IGeometry> geometries);
    private void Add(ILineString lineString);
    private void Merge();
    private void BuildEdgeStringsForObviousStartNodes();
    private void BuildEdgeStringsForIsolatedLoops();
    private void BuildEdgeStringsForUnprocessedNodes();
    private void BuildEdgeStringsForNonDegree2Nodes();
    private void BuildEdgeStringsStartingAt(Node node);
    private EdgeString BuildEdgeStringStartingWith(LineMergeDirectedEdge start);
    public IList`1<IGeometry> GetMergedLineStrings();
}
public class NetTopologySuite.Operation.Linemerge.LineSequencer : object {
    private LineMergeGraph _graph;
    private IGeometryFactory _factory;
    private IGeometry _sequencedGeometry;
    private int _lineCount;
    private bool _isRun;
    private bool _isSequenceable;
    public static bool IsSequenced(IGeometry geom);
    public void Add(IEnumerable`1<IGeometry> geometries);
    public void Add(IGeometry geometry);
    internal void AddLine(ILineString lineString);
    public bool IsSequenceable();
    public IGeometry GetSequencedLineStrings();
    private void ComputeSequence();
    private IList`1<IEnumerable`1<DirectedEdge>> FindSequences();
    private static bool HasSequence(Subgraph graph);
    private static IEnumerable`1<DirectedEdge> FindSequence(Subgraph graph);
    private static DirectedEdge FindUnvisitedBestOrientedDE(Node node);
    private static LinkedListNode`1<DirectedEdge> AddReverseSubpath(DirectedEdge de, LinkedListNode`1<DirectedEdge> pos, LinkedList`1<DirectedEdge> list, bool expectedClosed);
    private static Node FindLowestDegreeNode(Subgraph graph);
    private static List`1<DirectedEdge> Orient(LinkedList`1<DirectedEdge> seq);
    private static List`1<DirectedEdge> Reverse(IEnumerable`1<DirectedEdge> seq);
    private IGeometry BuildSequencedGeometry(IEnumerable`1<IEnumerable`1<DirectedEdge>> sequences);
    private static ILineString Reverse(ILineString line);
}
public class NetTopologySuite.Operation.Overlay.EdgeSetNoder : object {
    private LineIntersector _li;
    private List`1<Edge> _inputEdges;
    public IList`1<Edge> NodedEdges { get; }
    public EdgeSetNoder(LineIntersector li);
    public void AddEdges(IEnumerable`1<Edge> edges);
    public IList`1<Edge> get_NodedEdges();
}
public class NetTopologySuite.Operation.Overlay.LineBuilder : object {
    private OverlayOp _op;
    private IGeometryFactory _geometryFactory;
    private PointLocator _ptLocator;
    private List`1<Edge> _lineEdgesList;
    private List`1<IGeometry> _resultLineList;
    public LineBuilder(OverlayOp op, IGeometryFactory geometryFactory, PointLocator ptLocator);
    public IList`1<IGeometry> Build(SpatialFunction opCode);
    private void FindCoveredLineEdges();
    private void CollectLines(SpatialFunction opCode);
    public void CollectLineEdge(DirectedEdge de, SpatialFunction opCode, IList`1<Edge> edges);
    public void CollectBoundaryTouchEdge(DirectedEdge de, SpatialFunction opCode, IList`1<Edge> edges);
    private void BuildLines(SpatialFunction opCode);
    private void LabelIsolatedLines(IEnumerable`1<Edge> edgesList);
    private void LabelIsolatedLine(Edge e, int targetIndex);
}
public class NetTopologySuite.Operation.Overlay.MaximalEdgeRing : EdgeRing {
    public MaximalEdgeRing(DirectedEdge start, IGeometryFactory geometryFactory);
    public virtual DirectedEdge GetNext(DirectedEdge de);
    public virtual void SetEdgeRing(DirectedEdge de, EdgeRing er);
    public void LinkDirectedEdgesForMinimalEdgeRings();
    public IList`1<EdgeRing> BuildMinimalRings();
}
public class NetTopologySuite.Operation.Overlay.MinimalEdgeRing : EdgeRing {
    public MinimalEdgeRing(DirectedEdge start, IGeometryFactory geometryFactory);
    public virtual DirectedEdge GetNext(DirectedEdge de);
    public virtual void SetEdgeRing(DirectedEdge de, EdgeRing er);
}
public class NetTopologySuite.Operation.Overlay.OverlayNodeFactory : NodeFactory {
    public virtual Node CreateNode(Coordinate coord);
}
public class NetTopologySuite.Operation.Overlay.OverlayOp : GeometryGraphOperation {
    [CompilerGeneratedAttribute]
private static bool <NodingValidatorDisabled>k__BackingField;
    private PointLocator _ptLocator;
    private IGeometryFactory _geomFact;
    private IGeometry _resultGeom;
    private PlanarGraph _graph;
    private EdgeList _edgeList;
    private IList`1<IGeometry> _resultPolyList;
    private IList`1<IGeometry> _resultLineList;
    private IList`1<IGeometry> _resultPointList;
    public static bool NodingValidatorDisabled { get; public set; }
    public PlanarGraph Graph { get; }
    public OverlayOp(IGeometry g0, IGeometry g1);
    [CompilerGeneratedAttribute]
public static bool get_NodingValidatorDisabled();
    [CompilerGeneratedAttribute]
public static void set_NodingValidatorDisabled(bool value);
    public static IGeometry Overlay(IGeometry geom0, IGeometry geom1, SpatialFunction opCode);
    public static bool IsResultOfOp(Label label, SpatialFunction overlayOpCode);
    public static bool IsResultOfOp(Location loc0, Location loc1, SpatialFunction overlayOpCode);
    public IGeometry GetResultGeometry(SpatialFunction overlayOpCode);
    public PlanarGraph get_Graph();
    private void ComputeOverlay(SpatialFunction opCode);
    private void InsertUniqueEdges(IEnumerable`1<Edge> edges);
    protected void InsertUniqueEdge(Edge e);
    private void ComputeLabelsFromDepths();
    private void ReplaceCollapsedEdges();
    private void CopyPoints(int argIndex);
    private void ComputeLabelling();
    private void MergeSymLabels();
    private void UpdateNodeLabelling();
    private void LabelIncompleteNodes();
    private void LabelIncompleteNode(GraphComponent n, int targetIndex);
    private void FindResultAreaEdges(SpatialFunction opCode);
    private void CancelDuplicateResultEdges();
    public bool IsCoveredByLA(Coordinate coord);
    public bool IsCoveredByA(Coordinate coord);
    private bool IsCovered(Coordinate coord, IEnumerable`1<IGeometry> geomList);
    private IGeometry ComputeGeometry(IEnumerable`1<IGeometry> resultPtList, IEnumerable`1<IGeometry> resultLiList, IEnumerable`1<IGeometry> resultPlList, SpatialFunction opCode);
    public static IGeometry CreateEmptyResult(SpatialFunction overlayOpCode, IGeometry a, IGeometry b, IGeometryFactory geomFact);
    private static Dimension ResultDimension(SpatialFunction opCode, IGeometry g0, IGeometry g1);
}
public class NetTopologySuite.Operation.Overlay.PointBuilder : object {
    private OverlayOp _op;
    private IGeometryFactory _geometryFactory;
    private List`1<IGeometry> _resultPointList;
    public PointBuilder(OverlayOp op, IGeometryFactory geometryFactory);
    [ObsoleteAttribute("point locator no longer used!")]
public PointBuilder(OverlayOp op, IGeometryFactory geometryFactory, PointLocator ptLocator);
    public IList`1<IGeometry> Build(SpatialFunction opCode);
    private void ExtractNonCoveredResultNodes(SpatialFunction opCode);
    private void FilterCoveredNodeToPoint(Node n);
}
public class NetTopologySuite.Operation.Overlay.PolygonBuilder : object {
    private IGeometryFactory _geometryFactory;
    private List`1<EdgeRing> _shellList;
    public IList`1<IGeometry> Polygons { get; }
    public PolygonBuilder(IGeometryFactory geometryFactory);
    public void Add(PlanarGraph graph);
    public void Add(IList`1<EdgeEnd> dirEdges, IList`1<Node> nodes);
    public IList`1<IGeometry> get_Polygons();
    private List`1<EdgeRing> BuildMaximalEdgeRings(IEnumerable`1<EdgeEnd> dirEdges);
    private List`1<EdgeRing> BuildMinimalEdgeRings(List`1<EdgeRing> maxEdgeRings, IList`1<EdgeRing> shellList, IList`1<EdgeRing> freeHoleList);
    private static EdgeRing FindShell(IEnumerable`1<EdgeRing> minEdgeRings);
    private static void PlacePolygonHoles(EdgeRing shell, IEnumerable`1<EdgeRing> minEdgeRings);
    private static void SortShellsAndHoles(IEnumerable`1<EdgeRing> edgeRings, IList`1<EdgeRing> shellList, IList`1<EdgeRing> freeHoleList);
    private static void PlaceFreeHoles(IList`1<EdgeRing> shellList, IEnumerable`1<EdgeRing> freeHoleList);
    private static EdgeRing FindEdgeRingContaining(EdgeRing testEr, IEnumerable`1<EdgeRing> shellList);
    private IList`1<IGeometry> ComputePolygons(IEnumerable`1<EdgeRing> shellList);
}
public class NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper : object {
    private static double SnapPrexisionFactor;
    private IGeometry _srcGeom;
    public GeometrySnapper(IGeometry g);
    public static double ComputeOverlaySnapTolerance(IGeometry g);
    public static double ComputeSizeBasedSnapTolerance(IGeometry g);
    public static double ComputeOverlaySnapTolerance(IGeometry g0, IGeometry g1);
    public static IGeometry[] Snap(IGeometry g0, IGeometry g1, double snapTolerance);
    public static IGeometry SnapToSelf(IGeometry geom, double snapTolerance, bool cleanResult);
    public IGeometry SnapTo(IGeometry g, double tolerance);
    public IGeometry SnapToSelf(double snapTolerance, bool cleanResult);
    private Coordinate[] ExtractTargetCoordinates(IGeometry g);
    private static double ComputeSnapTolerance(Coordinate[] ringPts);
    private static double ComputeMinimumSegmentLength(Coordinate[] pts);
}
public class NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper : object {
    private double _snapTolerance;
    private Coordinate[] _srcPts;
    private LineSegment _seg;
    private bool _allowSnappingToSourceVertices;
    private bool _isClosed;
    public bool AllowSnappingToSourceVertices { get; public set; }
    public LineStringSnapper(ILineString srcLine, double snapTolerance);
    public LineStringSnapper(Coordinate[] srcPts, double snapTolerance);
    public bool get_AllowSnappingToSourceVertices();
    public void set_AllowSnappingToSourceVertices(bool value);
    private static bool IsClosed(Coordinate[] pts);
    public Coordinate[] SnapTo(Coordinate[] snapPts);
    private void SnapVertices(CoordinateList srcCoords, Coordinate[] snapPts);
    private Coordinate FindSnapForVertex(Coordinate pt, Coordinate[] snapPts);
    private void SnapSegments(CoordinateList srcCoords, Coordinate[] snapPts);
    private int FindSegmentIndexToSnap(Coordinate snapPt, CoordinateList srcCoords);
}
public class NetTopologySuite.Operation.Overlay.Snap.SnapIfNeededOverlayOp : object {
    private IGeometry[] _geom;
    public SnapIfNeededOverlayOp(IGeometry g1, IGeometry g2);
    public static IGeometry Overlay(IGeometry g0, IGeometry g1, SpatialFunction opCode);
    public static IGeometry Intersection(IGeometry g0, IGeometry g1);
    public static IGeometry Union(IGeometry g0, IGeometry g1);
    public static IGeometry Difference(IGeometry g0, IGeometry g1);
    public static IGeometry SymDifference(IGeometry g0, IGeometry g1);
    public IGeometry GetResultGeometry(SpatialFunction opCode);
}
public class NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp : object {
    private IGeometry[] _geom;
    private double _snapTolerance;
    private CommonBitsRemover cbr;
    public SnapOverlayOp(IGeometry g1, IGeometry g2);
    public static IGeometry Overlay(IGeometry g0, IGeometry g1, SpatialFunction opCode);
    public static IGeometry Intersection(IGeometry g0, IGeometry g1);
    public static IGeometry Union(IGeometry g0, IGeometry g1);
    public static IGeometry Difference(IGeometry g0, IGeometry g1);
    public static IGeometry SymDifference(IGeometry g0, IGeometry g1);
    private void ComputeSnapTolerance();
    public IGeometry GetResultGeometry(SpatialFunction opCode);
    private IGeometry SelfSnap(IGeometry geom);
    private IGeometry[] Snap(IGeometry[] geom);
    private IGeometry PrepareResult(IGeometry geom);
    private IGeometry[] RemoveCommonBits(IGeometry[] geom);
    private void CheckValid(IGeometry g);
}
internal class NetTopologySuite.Operation.Overlay.Snap.SnapTransformer : GeometryTransformer {
    private double _snapTolerance;
    private Coordinate[] _snapPts;
    private bool _isSelfSnap;
    public SnapTransformer(double snapTolerance, Coordinate[] snapPts);
    public SnapTransformer(double snapTolerance, Coordinate[] snapPts, bool isSelfSnap);
    protected virtual ICoordinateSequence TransformCoordinates(ICoordinateSequence coords, IGeometry parent);
    private Coordinate[] SnapLine(Coordinate[] srcPts, Coordinate[] snapPts);
}
public enum NetTopologySuite.Operation.Overlay.SpatialFunction : Enum {
    public int value__;
    public static SpatialFunction Intersection;
    public static SpatialFunction Union;
    public static SpatialFunction Difference;
    public static SpatialFunction SymDifference;
}
public class NetTopologySuite.Operation.Overlay.Validate.FuzzyPointLocator : object {
    private IGeometry _g;
    private double _boundaryDistanceTolerance;
    private IMultiLineString _linework;
    private PointLocator _ptLocator;
    private LineSegment _seg;
    public FuzzyPointLocator(IGeometry g, double boundaryDistanceTolerance);
    public Location GetLocation(Coordinate pt);
    private static IMultiLineString ExtractLinework(IGeometry g);
    private bool IsWithinToleranceOfBoundary(Coordinate pt);
}
public class NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator : object {
    private bool _doLeft;
    private bool _doRight;
    private IGeometry _g;
    public OffsetPointGenerator(IGeometry g);
    public void SetSidesToGenerate(bool doLeft, bool doRight);
    public List`1<Coordinate> GetPoints(double offsetDistance);
    private void ExtractPoints(ILineString line, double offsetDistance, IList`1<Coordinate> offsetPts);
    private void ComputeOffsetPoints(Coordinate p0, Coordinate p1, double offsetDistance, IList`1<Coordinate> offsetPts);
}
public class NetTopologySuite.Operation.Overlay.Validate.OverlayResultValidator : object {
    private static double Tolerance;
    private IGeometry[] _geom;
    private FuzzyPointLocator[] _locFinder;
    private Location[] _location;
    private double _boundaryDistanceTolerance;
    private List`1<Coordinate> _testCoords;
    private Coordinate _invalidLocation;
    public Coordinate InvalidLocation { get; }
    public OverlayResultValidator(IGeometry a, IGeometry b, IGeometry result);
    public static bool IsValid(IGeometry a, IGeometry b, SpatialFunction overlayOp, IGeometry result);
    private static double ComputeBoundaryDistanceTolerance(IGeometry g0, IGeometry g1);
    public bool IsValid(SpatialFunction overlayOp);
    public Coordinate get_InvalidLocation();
    private void AddTestPts(IGeometry g);
    private bool CheckValid(SpatialFunction overlayOp);
    private bool CheckValid(SpatialFunction overlayOp, Coordinate pt);
    private static bool HasLocation(Location[] location, Location loc);
    private static bool IsValidResult(SpatialFunction overlayOp, Location[] location);
    private static void ReportResult(SpatialFunction overlayOp, Location[] location, bool expectedInterior);
}
internal class NetTopologySuite.Operation.Overlay.Validate.PolygonalLineworkExtracter : object {
    private List`1<ILineString> _linework;
    public List`1<ILineString> Linework { get; }
    public sealed virtual void Filter(IGeometry g);
    public List`1<ILineString> get_Linework();
}
public class NetTopologySuite.Operation.Polygonize.EdgeRing : object {
    private IGeometryFactory _factory;
    private List`1<DirectedEdge> _deList;
    private DirectedEdge lowestEdge;
    private ILinearRing _ring;
    private Coordinate[] _ringPts;
    private List`1<ILinearRing> _holes;
    private EdgeRing _shell;
    private bool _isHole;
    private bool _isProcessed;
    private bool _isIncludedSet;
    private bool _isIncluded;
    public bool IsHole { get; }
    public IPolygon Polygon { get; }
    public bool IsValid { get; }
    public bool IsIncludedSet { get; }
    public bool IsIncluded { get; public set; }
    private Coordinate[] Coordinates { get; }
    public ILineString LineString { get; }
    public ILinearRing Ring { get; }
    public EdgeRing Shell { get; private set; }
    public bool HasShell { get; }
    public bool IsOuterHole { get; }
    public bool IsOuterShell { get; }
    public EdgeRing OuterHole { get; }
    public bool IsProcessed { get; public set; }
    public EdgeRing(IGeometryFactory factory);
    public static EdgeRing FindEdgeRingContaining(EdgeRing testEr, IList`1<EdgeRing> shellList);
    [ObsoleteAttribute("Use CoordinateArrays.PointNotInList instead")]
public static Coordinate PointNotInList(Coordinate[] testPts, Coordinate[] pts);
    [ObsoleteAttribute]
public static bool IsInList(Coordinate pt, Coordinate[] pts);
    public static List`1<DirectedEdge> FindDirEdgesInRing(PolygonizeDirectedEdge startDE);
    public void Build(PolygonizeDirectedEdge startDE);
    private void Add(DirectedEdge de);
    public bool get_IsHole();
    public void ComputeHole();
    public void AddHole(ILinearRing hole);
    public void AddHole(EdgeRing holeER);
    public IPolygon get_Polygon();
    public bool get_IsValid();
    public bool get_IsIncludedSet();
    public bool get_IsIncluded();
    public void set_IsIncluded(bool value);
    private Coordinate[] get_Coordinates();
    public ILineString get_LineString();
    public ILinearRing get_Ring();
    private static void AddEdge(Coordinate[] coords, bool isForward, CoordinateList coordList);
    public EdgeRing get_Shell();
    private void set_Shell(EdgeRing value);
    public bool get_HasShell();
    public bool get_IsOuterHole();
    public bool get_IsOuterShell();
    public EdgeRing get_OuterHole();
    internal void UpdateIncluded();
    public virtual string ToString();
    public bool get_IsProcessed();
    public void set_IsProcessed(bool value);
}
public class NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge : DirectedEdge {
    private long label;
    [CompilerGeneratedAttribute]
private PolygonizeDirectedEdge <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private EdgeRing <Ring>k__BackingField;
    public long Label { get; public set; }
    public PolygonizeDirectedEdge Next { get; public set; }
    public bool IsInRing { get; }
    public EdgeRing Ring { get; public set; }
    public PolygonizeDirectedEdge(Node from, Node to, Coordinate directionPt, bool edgeDirection);
    public long get_Label();
    public void set_Label(long value);
    [CompilerGeneratedAttribute]
public PolygonizeDirectedEdge get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(PolygonizeDirectedEdge value);
    public bool get_IsInRing();
    [CompilerGeneratedAttribute]
public EdgeRing get_Ring();
    [CompilerGeneratedAttribute]
public void set_Ring(EdgeRing value);
}
public class NetTopologySuite.Operation.Polygonize.PolygonizeEdge : Edge {
    private ILineString line;
    public ILineString Line { get; }
    public PolygonizeEdge(ILineString line);
    public ILineString get_Line();
}
public class NetTopologySuite.Operation.Polygonize.PolygonizeGraph : PlanarGraph {
    private IGeometryFactory _factory;
    public PolygonizeGraph(IGeometryFactory factory);
    private static int GetDegreeNonDeleted(Node node);
    private static int GetDegree(Node node, long label);
    public static void DeleteAllEdges(Node node);
    public void AddEdge(ILineString line);
    private Node GetNode(Coordinate pt);
    private void ComputeNextCWEdges();
    private static void ConvertMaximalToMinimalEdgeRings(IEnumerable`1<DirectedEdge> ringEdges);
    private static IEnumerable`1<Node> FindIntersectionNodes(PolygonizeDirectedEdge startDE, long label);
    public IList`1<EdgeRing> GetEdgeRings();
    private static IList`1<DirectedEdge> FindLabeledEdgeRings(IEnumerable`1<DirectedEdge> dirEdges);
    public IList`1<ILineString> DeleteCutEdges();
    private static void Label(IEnumerable`1<DirectedEdge> dirEdges, long label);
    private static void ComputeNextCWEdges(Node node);
    private static void ComputeNextCCWEdges(Node node, long label);
    private EdgeRing FindEdgeRing(PolygonizeDirectedEdge startDE);
    public ICollection`1<ILineString> DeleteDangles();
    public void ComputeDepthParity();
    private void ComputeDepthParity(PolygonizeDirectedEdge de);
}
public class NetTopologySuite.Operation.Polygonize.Polygonizer : object {
    public static bool AllPolys;
    private LineStringAdder _lineStringAdder;
    private PolygonizeGraph _graph;
    private ICollection`1<ILineString> _dangles;
    private ICollection`1<ILineString> _cutEdges;
    private IList`1<IGeometry> _invalidRingLines;
    private List`1<EdgeRing> _holeList;
    private List`1<EdgeRing> _shellList;
    private ICollection`1<IGeometry> _polyList;
    private bool _isCheckingRingsValid;
    private bool _extractOnlyPolygonal;
    private IGeometryFactory _geomFactory;
    public bool IsCheckingRingsValid { get; public set; }
    public Polygonizer(bool extractOnlyPolygonal);
    public bool get_IsCheckingRingsValid();
    public void set_IsCheckingRingsValid(bool value);
    public void Add(ICollection`1<IGeometry> geomList);
    public void Add(IGeometry g);
    private void Add(ILineString line);
    public ICollection`1<IGeometry> GetPolygons();
    public IGeometry GetGeometry();
    public ICollection`1<ILineString> GetDangles();
    public ICollection`1<ILineString> GetCutEdges();
    public IList`1<IGeometry> GetInvalidRingLines();
    private void Polygonize();
    private static void FindValidRings(IEnumerable`1<EdgeRing> edgeRingList, ICollection`1<EdgeRing> validEdgeRingList, ICollection`1<IGeometry> invalidRingList);
    private void FindShellsAndHoles(IEnumerable`1<EdgeRing> edgeRingList);
    private static void AssignHolesToShells(IEnumerable`1<EdgeRing> holeList, List`1<EdgeRing> shellList);
    private static void AssignHoleToShell(EdgeRing holeEdgeRing, IList`1<EdgeRing> shellList);
    private static void FindDisjointShells(List`1<EdgeRing> shellList);
    private static void FindOuterShells(List`1<EdgeRing> shellList);
    private static List`1<IGeometry> ExtractPolygons(List`1<EdgeRing> shellList, bool includeAll);
}
internal class NetTopologySuite.Operation.Predicate.EnvelopeIntersectsVisitor : ShortCircuitedGeometryVisitor {
    private Envelope _rectEnv;
    [CompilerGeneratedAttribute]
private bool <Intersects>k__BackingField;
    public bool Intersects { get; private set; }
    public EnvelopeIntersectsVisitor(Envelope rectEnv);
    [CompilerGeneratedAttribute]
public bool get_Intersects();
    [CompilerGeneratedAttribute]
private void set_Intersects(bool value);
    protected virtual void Visit(IGeometry element);
    protected virtual bool IsDone();
}
internal class NetTopologySuite.Operation.Predicate.GeometryContainsPointVisitor : ShortCircuitedGeometryVisitor {
    private ICoordinateSequence _rectSeq;
    private Envelope _rectEnv;
    [CompilerGeneratedAttribute]
private bool <ContainsPoint>k__BackingField;
    public bool ContainsPoint { get; private set; }
    public GeometryContainsPointVisitor(IPolygon rectangle);
    [CompilerGeneratedAttribute]
public bool get_ContainsPoint();
    [CompilerGeneratedAttribute]
private void set_ContainsPoint(bool value);
    protected virtual void Visit(IGeometry geom);
    protected virtual bool IsDone();
}
public class NetTopologySuite.Operation.Predicate.RectangleContains : object {
    private IPolygon rectangle;
    private Envelope rectEnv;
    public RectangleContains(IPolygon rectangle);
    public static bool Contains(IPolygon rectangle, IGeometry b);
    public bool Contains(IGeometry geom);
    private bool IsContainedInBoundary(IGeometry geom);
    private bool IsPointContainedInBoundary(IPoint point);
    private bool IsPointContainedInBoundary(Coordinate pt);
    private bool IsLineStringContainedInBoundary(ILineString line);
    private bool IsLineSegmentContainedInBoundary(Coordinate p0, Coordinate p1);
}
public class NetTopologySuite.Operation.Predicate.RectangleIntersects : object {
    public static int MaximumScanSegmentCount;
    private IPolygon _rectangle;
    private Envelope _rectEnv;
    public RectangleIntersects(IPolygon rectangle);
    public static bool Intersects(IPolygon rectangle, IGeometry b);
    public bool Intersects(IGeometry geom);
}
internal class NetTopologySuite.Operation.Predicate.RectangleIntersectsSegmentVisitor : ShortCircuitedGeometryVisitor {
    private Envelope _rectEnv;
    private RectangleLineIntersector _rectIntersector;
    private Coordinate _p0;
    private Coordinate _p1;
    [CompilerGeneratedAttribute]
private bool <Intersects>k__BackingField;
    public bool Intersects { get; private set; }
    public RectangleIntersectsSegmentVisitor(IPolygon rectangle);
    [CompilerGeneratedAttribute]
public bool get_Intersects();
    [CompilerGeneratedAttribute]
private void set_Intersects(bool value);
    protected virtual void Visit(IGeometry geom);
    private void CheckIntersectionWithLineStrings(IEnumerable`1<IGeometry> lines);
    private void CheckIntersectionWithSegments(ICurve testLine);
    protected virtual bool IsDone();
}
public class NetTopologySuite.Operation.Predicate.SegmentIntersectionTester : object {
    private LineIntersector li;
    private bool _hasIntersection;
    private Coordinate pt00;
    private Coordinate pt01;
    private Coordinate pt10;
    private Coordinate pt11;
    public bool HasIntersectionWithLineStrings(ICoordinateSequence seq, ICollection`1<IGeometry> lines);
    public bool HasIntersection(ICoordinateSequence seq0, ICoordinateSequence seq1);
}
public class NetTopologySuite.Operation.Relate.EdgeEndBuilder : object {
    public IList`1<EdgeEnd> ComputeEdgeEnds(IEnumerable`1<Edge> edges);
    public void ComputeEdgeEnds(Edge edge, IList`1<EdgeEnd> l);
    public void CreateEdgeEndForPrev(Edge edge, IList`1<EdgeEnd> l, EdgeIntersection eiCurr, EdgeIntersection eiPrev);
    public void CreateEdgeEndForNext(Edge edge, IList`1<EdgeEnd> l, EdgeIntersection eiCurr, EdgeIntersection eiNext);
}
public class NetTopologySuite.Operation.Relate.EdgeEndBundle : EdgeEnd {
    private IList`1<EdgeEnd> _edgeEnds;
    public IList`1<EdgeEnd> EdgeEnds { get; }
    public EdgeEndBundle(IBoundaryNodeRule boundaryNodeRule, EdgeEnd e);
    public EdgeEndBundle(EdgeEnd e);
    public IEnumerator`1<EdgeEnd> GetEnumerator();
    public IList`1<EdgeEnd> get_EdgeEnds();
    public void Insert(EdgeEnd e);
    public virtual void ComputeLabel(IBoundaryNodeRule boundaryNodeRule);
    private void ComputeLabelOn(int geomIndex, IBoundaryNodeRule boundaryNodeRule);
    private void ComputeLabelSides(int geomIndex);
    private void ComputeLabelSide(int geomIndex, Positions side);
    public void UpdateIM(IntersectionMatrix im);
    public virtual void Write(StreamWriter outstream);
}
public class NetTopologySuite.Operation.Relate.EdgeEndBundleStar : EdgeEndStar {
    public virtual void Insert(EdgeEnd e);
    public void UpdateIM(IntersectionMatrix im);
}
public class NetTopologySuite.Operation.Relate.RelateComputer : object {
    private LineIntersector _li;
    private PointLocator _ptLocator;
    private GeometryGraph[] _arg;
    private NodeMap _nodes;
    private List`1<Edge> _isolatedEdges;
    public RelateComputer(GeometryGraph[] arg);
    public IntersectionMatrix ComputeIM();
    private void InsertEdgeEnds(IEnumerable`1<EdgeEnd> ee);
    private void ComputeProperIntersectionIM(SegmentIntersector intersector, IntersectionMatrix im);
    private void CopyNodesAndLabels(int argIndex);
    private void ComputeIntersectionNodes(int argIndex);
    private void LabelIntersectionNodes(int argIndex);
    private void ComputeDisjointIM(IntersectionMatrix im);
    private void LabelNodeEdges();
    private void UpdateIM(IntersectionMatrix im);
    private void LabelIsolatedEdges(int thisIndex, int targetIndex);
    private void LabelIsolatedEdge(Edge e, int targetIndex, IGeometry target);
    private void LabelIsolatedNodes();
    private void LabelIsolatedNode(Node n, int targetIndex);
}
public class NetTopologySuite.Operation.Relate.RelateNode : Node {
    public RelateNode(Coordinate coord, EdgeEndStar edges);
    public virtual void ComputeIM(IntersectionMatrix im);
    public void UpdateIMFromEdges(IntersectionMatrix im);
}
public class NetTopologySuite.Operation.Relate.RelateNodeFactory : NodeFactory {
    public virtual Node CreateNode(Coordinate coord);
}
public class NetTopologySuite.Operation.Relate.RelateNodeGraph : object {
    private NodeMap _nodes;
    public IEnumerator`1<Node> GetNodeEnumerator();
    public void Build(GeometryGraph geomGraph);
    public void ComputeIntersectionNodes(GeometryGraph geomGraph, int argIndex);
    public void CopyNodesAndLabels(GeometryGraph geomGraph, int argIndex);
    public void InsertEdgeEnds(IList`1<EdgeEnd> ee);
}
public class NetTopologySuite.Operation.Relate.RelateOp : GeometryGraphOperation {
    private RelateComputer _relate;
    public IntersectionMatrix IntersectionMatrix { get; }
    public RelateOp(IGeometry g0, IGeometry g1);
    public RelateOp(IGeometry g0, IGeometry g1, IBoundaryNodeRule boundaryNodeRule);
    public static IntersectionMatrix Relate(IGeometry a, IGeometry b);
    public static IntersectionMatrix Relate(IGeometry a, IGeometry b, IBoundaryNodeRule boundaryNodeRule);
    public IntersectionMatrix get_IntersectionMatrix();
}
public class NetTopologySuite.Operation.Union.CascadedPolygonUnion : object {
    private ICollection`1<IGeometry> _inputPolys;
    private IGeometryFactory _geomFactory;
    private static int StrtreeNodeCapacity;
    public CascadedPolygonUnion(ICollection`1<IGeometry> polys);
    public static IGeometry Union(ICollection`1<IGeometry> polys);
    private IGeometryFactory Factory();
    public IGeometry Union();
    private IGeometry UnionTree(IList`1<object> geomTree);
    private IGeometry RepeatedUnion(IEnumerable`1<IGeometry> geoms);
    private IGeometry BufferUnion(ICollection`1<IGeometry> geoms);
    private IGeometry BufferUnion(IGeometry g0, IGeometry g1);
    private IGeometry BinaryUnion(IList`1<IGeometry> geoms);
    private IGeometry BinaryUnion(IList`1<IGeometry> geoms, int start, int end, bool multiple);
    private static IGeometry GetGeometry(IList`1<IGeometry> list, int index);
    private IList`1<IGeometry> ReduceToGeometries(IList`1<object> geomTree);
    private IGeometry UnionSafe(IGeometry g0, IGeometry g1);
    private IGeometry UnionOptimized(IGeometry g0, IGeometry g1);
    private IGeometry UnionUsingEnvelopeIntersection(IGeometry g0, IGeometry g1, Envelope common);
    private IGeometry ExtractByEnvelope(Envelope env, IGeometry geom, IList`1<IGeometry> disjointGeoms);
    private static IGeometry UnionActual(IGeometry g0, IGeometry g1);
    private static IGeometry RestrictToPolygons(IGeometry g);
}
public class NetTopologySuite.Operation.Union.PointGeometryUnion : object {
    private IGeometryFactory _geomFact;
    private IGeometry _otherGeom;
    private IGeometry _pointGeom;
    public PointGeometryUnion(IPuntal pointGeom, IGeometry otherGeom);
    public static IGeometry Union(IPuntal pointGeom, IGeometry otherGeom);
    public IGeometry Union();
}
public class NetTopologySuite.Operation.Union.UnaryUnionOp : object {
    private List`1<IGeometry> _polygons;
    private List`1<IGeometry> _lines;
    private List`1<IGeometry> _points;
    private IGeometryFactory _geomFact;
    public UnaryUnionOp(IEnumerable`1<IGeometry> geoms);
    public UnaryUnionOp(IEnumerable`1<IGeometry> geoms, IGeometryFactory geomFact);
    public UnaryUnionOp(IGeometry geom);
    public static IGeometry Union(IList`1<IGeometry> geoms);
    public static IGeometry Union(IList`1<IGeometry> geoms, IGeometryFactory geomFact);
    public static IGeometry Union(IGeometry geom);
    private void Extract(IEnumerable`1<IGeometry> geoms);
    private void Extract(IGeometry geom);
    public IGeometry Union();
    private static IGeometry UnionWithNull(IGeometry g0, IGeometry g1);
    private IGeometry UnionNoOpt(IGeometry g0);
}
public class NetTopologySuite.Operation.Union.UnionInteracting : object {
    private IGeometryFactory _geomFactory;
    private IGeometry _g0;
    private IGeometry _g1;
    private Boolean[] _interacts0;
    private Boolean[] _interacts1;
    public UnionInteracting(IGeometry g0, IGeometry g1);
    public static IGeometry Union(IGeometry g0, IGeometry g1);
    public IGeometry Union();
    private IGeometry BufferUnion(IGeometry g0, IGeometry g1);
    private void ComputeInteracting();
    private bool ComputeInteracting(IGeometry elem0);
    private IGeometry ExtractElements(IGeometry geom, Boolean[] interacts, bool isInteracting);
}
public class NetTopologySuite.Operation.Valid.ConnectedInteriorTester : object {
    private GeometryFactory _geometryFactory;
    private GeometryGraph _geomGraph;
    private Coordinate _disconnectedRingcoord;
    public Coordinate Coordinate { get; }
    public ConnectedInteriorTester(GeometryGraph geomGraph);
    public static Coordinate FindDifferentPoint(Coordinate[] coord, Coordinate pt);
    public Coordinate get_Coordinate();
    public bool IsInteriorsConnected();
    private static void SetInteriorEdgesInResult(PlanarGraph graph);
    private IList`1<EdgeRing> BuildEdgeRings(IEnumerable`1<EdgeEnd> dirEdges);
    private void VisitShellInteriors(IGeometry g, PlanarGraph graph);
    private void VisitInteriorRing(ILineString ring, PlanarGraph graph);
    protected void VisitLinkedDirectedEdges(DirectedEdge start);
    private bool HasUnvisitedShellEdge(IList`1<EdgeRing> edgeRings);
}
public class NetTopologySuite.Operation.Valid.ConsistentAreaTester : object {
    private LineIntersector li;
    private GeometryGraph geomGraph;
    private RelateNodeGraph nodeGraph;
    private Coordinate invalidPoint;
    public Coordinate InvalidPoint { get; }
    public bool IsNodeConsistentArea { get; }
    private bool IsNodeEdgeAreaLabelsConsistent { get; }
    public bool HasDuplicateRings { get; }
    public ConsistentAreaTester(GeometryGraph geomGraph);
    public Coordinate get_InvalidPoint();
    public bool get_IsNodeConsistentArea();
    private bool get_IsNodeEdgeAreaLabelsConsistent();
    public bool get_HasDuplicateRings();
}
public class NetTopologySuite.Operation.Valid.IndexedNestedRingTester : object {
    private GeometryGraph _graph;
    private IList`1<ILineString> _rings;
    private Envelope _totalEnv;
    private ISpatialIndex`1<ILineString> _index;
    private Coordinate _nestedPt;
    public Coordinate NestedPoint { get; }
    public IndexedNestedRingTester(GeometryGraph graph);
    public Coordinate get_NestedPoint();
    public void Add(ILinearRing ring);
    public bool IsNonNested();
    private void BuildIndex();
}
public class NetTopologySuite.Operation.Valid.IsValidOp : object {
    private IGeometry _parentGeometry;
    private bool _isSelfTouchingRingFormingHoleValid;
    private TopologyValidationError _validErr;
    public bool IsSelfTouchingRingFormingHoleValid { get; public set; }
    public bool IsValid { get; }
    public TopologyValidationError ValidationError { get; }
    public IsValidOp(IGeometry parentGeometry);
    public static bool IsValidCoordinate(Coordinate coord);
    public static Coordinate FindPointNotNode(Coordinate[] testCoords, ILinearRing searchRing, GeometryGraph graph);
    public bool get_IsSelfTouchingRingFormingHoleValid();
    public void set_IsSelfTouchingRingFormingHoleValid(bool value);
    public bool get_IsValid();
    public TopologyValidationError get_ValidationError();
    private void CheckValid(IGeometry g);
    private void CheckValid(IPoint g);
    private void CheckValid(IMultiPoint g);
    private void CheckValid(ILineString g);
    private void CheckValid(ILinearRing g);
    private void CheckValid(IPolygon g);
    private void CheckValid(IMultiPolygon g);
    private void CheckValid(IGeometryCollection gc);
    private void CheckInvalidCoordinates(Coordinate[] coords);
    private void CheckInvalidCoordinates(IPolygon poly);
    private void CheckClosedRings(IPolygon poly);
    private void CheckClosedRing(ILinearRing ring);
    private void CheckTooFewPoints(GeometryGraph graph);
    private void CheckConsistentArea(GeometryGraph graph);
    private void CheckNoSelfIntersectingRings(GeometryGraph graph);
    private void CheckNoSelfIntersectingRing(EdgeIntersectionList eiList);
    private void CheckHolesInShell(IPolygon p, GeometryGraph graph);
    private void CheckHolesNotNested(IPolygon p, GeometryGraph graph);
    private void CheckShellsNotNested(IMultiPolygon mp, GeometryGraph graph);
    private void CheckShellNotNested(ILinearRing shell, IPolygon p, GeometryGraph graph);
    private Coordinate CheckShellInsideHole(ILinearRing shell, ILinearRing hole, GeometryGraph graph);
    private void CheckConnectedInteriors(GeometryGraph graph);
}
public class NetTopologySuite.Operation.Valid.RepeatedPointTester : object {
    private Coordinate repeatedCoord;
    public Coordinate Coordinate { get; }
    public Coordinate get_Coordinate();
    public bool HasRepeatedPoint(IGeometry g);
    public bool HasRepeatedPoint(Coordinate[] coord);
    private bool HasRepeatedPoint(IPolygon p);
    private bool HasRepeatedPoint(IGeometryCollection gc);
}
public class NetTopologySuite.Operation.Valid.TopologyValidationError : object {
    private static String[] errMsg;
    private TopologyValidationErrors errorType;
    private Coordinate pt;
    public Coordinate Coordinate { get; }
    public TopologyValidationErrors ErrorType { get; }
    public string Message { get; }
    public TopologyValidationError(TopologyValidationErrors errorType, Coordinate pt);
    public TopologyValidationError(TopologyValidationErrors errorType);
    private static TopologyValidationError();
    public Coordinate get_Coordinate();
    public TopologyValidationErrors get_ErrorType();
    public string get_Message();
    public virtual string ToString();
}
public enum NetTopologySuite.Operation.Valid.TopologyValidationErrors : Enum {
    public int value__;
    [ObsoleteAttribute("Not used")]
public static TopologyValidationErrors Error;
    [ObsoleteAttribute("No longer used: repeated points are considered valid as per the SFS")]
public static TopologyValidationErrors RepeatedPoint;
    public static TopologyValidationErrors HoleOutsideShell;
    public static TopologyValidationErrors NestedHoles;
    public static TopologyValidationErrors DisconnectedInteriors;
    public static TopologyValidationErrors SelfIntersection;
    public static TopologyValidationErrors RingSelfIntersection;
    public static TopologyValidationErrors NestedShells;
    public static TopologyValidationErrors DuplicateRings;
    public static TopologyValidationErrors TooFewPoints;
    public static TopologyValidationErrors InvalidCoordinate;
    public static TopologyValidationErrors RingNotClosed;
}
public class NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder : object {
    private PlanarGraph graph;
    public ConnectedSubgraphFinder(PlanarGraph graph);
    public IList`1<Subgraph> GetConnectedSubgraphs();
    private Subgraph FindSubgraph(Node node);
    private void AddReachable(Node startNode, Subgraph subgraph);
    private static void AddEdges(Node node, Stack`1<Node> nodeStack, Subgraph subgraph);
}
public class NetTopologySuite.Planargraph.DirectedEdge : GraphComponent {
    protected Edge parentEdge;
    protected Node from;
    protected Node to;
    protected Coordinate p0;
    protected Coordinate p1;
    private DirectedEdge _sym;
    private int _quadrant;
    private double _angle;
    [CompilerGeneratedAttribute]
private bool <EdgeDirection>k__BackingField;
    public Edge Edge { get; public set; }
    public int Quadrant { get; }
    public Coordinate DirectionPt { get; }
    public bool EdgeDirection { get; protected set; }
    public Node FromNode { get; }
    public Node ToNode { get; }
    public Coordinate Coordinate { get; }
    public double Angle { get; }
    public DirectedEdge Sym { get; public set; }
    public bool IsRemoved { get; }
    public DirectedEdge(Node from, Node to, Coordinate directionPt, bool edgeDirection);
    public static IList`1<Edge> ToEdges(IList`1<DirectedEdge> dirEdges);
    public Edge get_Edge();
    public void set_Edge(Edge value);
    public int get_Quadrant();
    public Coordinate get_DirectionPt();
    [CompilerGeneratedAttribute]
public bool get_EdgeDirection();
    [CompilerGeneratedAttribute]
protected void set_EdgeDirection(bool value);
    public Node get_FromNode();
    public Node get_ToNode();
    public Coordinate get_Coordinate();
    public double get_Angle();
    public DirectedEdge get_Sym();
    public void set_Sym(DirectedEdge value);
    public sealed virtual int CompareTo(object obj);
    public int CompareDirection(DirectedEdge e);
    public void Write(StreamWriter outstream);
    public virtual bool get_IsRemoved();
    internal void Remove();
    public virtual string ToString();
}
public class NetTopologySuite.Planargraph.DirectedEdgeStar : object {
    private List`1<DirectedEdge> _outEdges;
    private bool _sorted;
    public int Degree { get; }
    public Coordinate Coordinate { get; }
    public IList`1<DirectedEdge> Edges { get; }
    public void Add(DirectedEdge de);
    public void Remove(DirectedEdge de);
    public IEnumerator`1<DirectedEdge> GetEnumerator();
    public int get_Degree();
    public Coordinate get_Coordinate();
    public IList`1<DirectedEdge> get_Edges();
    private void SortEdges();
    public int GetIndex(Edge edge);
    public int GetIndex(DirectedEdge dirEdge);
    public int GetIndex(int i);
    public DirectedEdge GetNextEdge(DirectedEdge dirEdge);
    public DirectedEdge GetNextCWEdge(DirectedEdge dirEdge);
}
public class NetTopologySuite.Planargraph.Edge : GraphComponent {
    protected DirectedEdge[] dirEdge;
    public bool IsRemoved { get; }
    public Edge(DirectedEdge de0, DirectedEdge de1);
    public void SetDirectedEdges(DirectedEdge de0, DirectedEdge de1);
    public DirectedEdge GetDirEdge(int i);
    public DirectedEdge GetDirEdge(Node fromNode);
    public Node GetOppositeNode(Node node);
    internal void Remove();
    public virtual bool get_IsRemoved();
}
public abstract class NetTopologySuite.Planargraph.GraphComponent : object {
    [CompilerGeneratedAttribute]
private bool <Visited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Marked>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public bool IsVisited { get; }
    public bool Visited { get; public set; }
    public bool IsMarked { get; }
    public bool Marked { get; public set; }
    public bool IsRemoved { get; }
    public object Data { get; public set; }
    public static void SetVisited(IEnumerator i, bool visited);
    public static void SetMarked(IEnumerator i, bool marked);
    public static GraphComponent GetComponentWithVisitedState(IEnumerator i, bool visitedState);
    public bool get_IsVisited();
    [CompilerGeneratedAttribute]
public bool get_Visited();
    [CompilerGeneratedAttribute]
public void set_Visited(bool value);
    public bool get_IsMarked();
    [CompilerGeneratedAttribute]
public bool get_Marked();
    [CompilerGeneratedAttribute]
public void set_Marked(bool value);
    public abstract virtual bool get_IsRemoved();
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
}
public class NetTopologySuite.Planargraph.Node : GraphComponent {
    protected Coordinate pt;
    protected DirectedEdgeStar deStar;
    public Coordinate Coordinate { get; }
    public DirectedEdgeStar OutEdges { get; }
    public int Degree { get; }
    public bool IsRemoved { get; }
    public Node(Coordinate pt);
    public Node(Coordinate pt, DirectedEdgeStar deStar);
    public static IList`1<DirectedEdge> GetEdgesBetween(Node node0, Node node1);
    public Coordinate get_Coordinate();
    public void AddOutEdge(DirectedEdge de);
    public DirectedEdgeStar get_OutEdges();
    public int get_Degree();
    public int GetIndex(Edge edge);
    public void Remove(DirectedEdge de);
    internal void Remove();
    public virtual bool get_IsRemoved();
    public virtual string ToString();
}
public class NetTopologySuite.Planargraph.NodeMap : object {
    private IDictionary`2<Coordinate, Node> _nodeMap;
    public ICollection`1<Node> Values { get; }
    public int Count { get; }
    public Node Add(Node n);
    public Node Remove(Coordinate pt);
    public Node Find(Coordinate coord);
    public IEnumerator`1<Node> GetEnumerator();
    public ICollection`1<Node> get_Values();
    public int get_Count();
}
public abstract class NetTopologySuite.Planargraph.PlanarGraph : object {
    private IList`1<Edge> _edges;
    protected IList`1<DirectedEdge> dirEdges;
    protected NodeMap nodeMap;
    public ICollection`1<Node> Nodes { get; }
    public IList`1<Edge> Edges { get; protected set; }
    public Node FindNode(Coordinate pt);
    protected void Add(Node node);
    protected void Add(Edge edge);
    protected void Add(DirectedEdge dirEdge);
    public IEnumerator`1<Node> GetNodeEnumerator();
    public ICollection`1<Node> get_Nodes();
    public IEnumerator`1<DirectedEdge> GetDirEdgeEnumerator();
    public IEnumerator`1<Edge> GetEdgeEnumerator();
    public IList`1<Edge> get_Edges();
    protected void set_Edges(IList`1<Edge> value);
    public void Remove(Edge edge);
    public void Remove(DirectedEdge de);
    public void Remove(Node node);
    public IList`1<Node> FindNodesOfDegree(int degree);
}
public class NetTopologySuite.Planargraph.Subgraph : object {
    protected PlanarGraph parentGraph;
    protected HashSet`1<Edge> edges;
    protected IList`1<DirectedEdge> dirEdges;
    protected NodeMap nodeMap;
    public Subgraph(PlanarGraph parentGraph);
    public PlanarGraph GetParent();
    public void Add(Edge e);
    public IEnumerator`1<DirectedEdge> GetDirEdgeEnumerator();
    public IEnumerator`1<Edge> GetEdgeEnumerator();
    public IEnumerator`1<Node> GetNodeEnumerator();
    public bool Contains(Edge e);
}
public class NetTopologySuite.Precision.CommonBits : object {
    private bool _isFirst;
    private int _commonMantissaBitsCount;
    private long _commonBits;
    private long _commonSignExp;
    public double Common { get; }
    public static long SignExpBits(long num);
    public static int NumCommonMostSigMantissaBits(long num1, long num2);
    public static long ZeroLowerBits(long bits, int nBits);
    public static int GetBit(long bits, int i);
    public void Add(double num);
    public double get_Common();
    public string ToString(long bits);
}
public class NetTopologySuite.Precision.CommonBitsOp : object {
    private bool _returnToOriginalPrecision;
    private CommonBitsRemover _cbr;
    public CommonBitsOp(bool returnToOriginalPrecision);
    public IGeometry Intersection(IGeometry geom0, IGeometry geom1);
    public IGeometry Union(IGeometry geom0, IGeometry geom1);
    public IGeometry Difference(IGeometry geom0, IGeometry geom1);
    public IGeometry SymDifference(IGeometry geom0, IGeometry geom1);
    public IGeometry Buffer(IGeometry geom0, double distance);
    private IGeometry ComputeResultPrecision(IGeometry result);
    private IGeometry RemoveCommonBits(IGeometry geom0);
    private IGeometry[] RemoveCommonBits(IGeometry geom0, IGeometry geom1);
}
public class NetTopologySuite.Precision.CommonBitsRemover : object {
    private Coordinate _commonCoord;
    private CommonCoordinateFilter _ccFilter;
    public Coordinate CommonCoordinate { get; }
    public void Add(IGeometry geom);
    public Coordinate get_CommonCoordinate();
    public IGeometry RemoveCommonBits(IGeometry geom);
    public void AddCommonBits(IGeometry geom);
}
public class NetTopologySuite.Precision.CoordinatePrecisionReducerFilter : object {
    private IPrecisionModel _precModel;
    public bool Done { get; }
    public bool GeometryChanged { get; }
    public CoordinatePrecisionReducerFilter(IPrecisionModel precModel);
    public sealed virtual void Filter(ICoordinateSequence seq, int i);
    public sealed virtual bool get_Done();
    public sealed virtual bool get_GeometryChanged();
}
public class NetTopologySuite.Precision.EnhancedPrecisionOp : object {
    public static IGeometry Intersection(IGeometry geom0, IGeometry geom1);
    public static IGeometry Union(IGeometry geom0, IGeometry geom1);
    public static IGeometry Difference(IGeometry geom0, IGeometry geom1);
    public static IGeometry SymDifference(IGeometry geom0, IGeometry geom1);
    [ObsoleteAttribute("This method should no longer be necessary, since the buffer algorithm now is highly robust.")]
public static IGeometry Buffer(IGeometry geom, double distance);
}
public class NetTopologySuite.Precision.GeometryPrecisionReducer : object {
    private IPrecisionModel _targetPrecModel;
    private bool _removeCollapsed;
    private bool _changePrecisionModel;
    private bool _isPointwise;
    public bool RemoveCollapsedComponents { get; public set; }
    public bool ChangePrecisionModel { get; public set; }
    public bool Pointwise { get; public set; }
    public GeometryPrecisionReducer(IPrecisionModel pm);
    public static IGeometry Reduce(IGeometry g, IPrecisionModel precModel);
    public static IGeometry ReducePointwise(IGeometry g, IPrecisionModel precModel);
    public bool get_RemoveCollapsedComponents();
    public void set_RemoveCollapsedComponents(bool value);
    public bool get_ChangePrecisionModel();
    public void set_ChangePrecisionModel(bool value);
    public bool get_Pointwise();
    public void set_Pointwise(bool value);
    public IGeometry Reduce(IGeometry geom);
    private IGeometry ReducePointwise(IGeometry geom);
    private IGeometry FixPolygonalTopology(IGeometry geom);
    private static IGeometry ChangePrecModel(IGeometry geom, IPrecisionModel pm);
    private static GeometryEditor CreateEditor(IGeometryFactory geomFactory, IPrecisionModel newPrecModel);
    private static IGeometryFactory CreateFactory(IGeometryFactory inputFactory, IPrecisionModel pm);
}
public class NetTopologySuite.Precision.MinimumClearance : object {
    private IGeometry _inputGeom;
    private double _minClearance;
    private Coordinate[] _minClearancePts;
    public MinimumClearance(IGeometry geom);
    public static double GetDistance(IGeometry g);
    public static IGeometry GetLine(IGeometry g);
    public double GetDistance();
    public ILineString GetLine();
    private void Compute();
}
public class NetTopologySuite.Precision.PrecisionReducerCoordinateOperation : CoordinateOperation {
    private IPrecisionModel _targetPrecModel;
    private bool _removeCollapsed;
    public PrecisionReducerCoordinateOperation(IPrecisionModel targetPrecModel, bool removeCollapsed);
    public virtual Coordinate[] Edit(Coordinate[] coordinates, IGeometry geom);
}
[ObsoleteAttribute("Use GeometryPrecisionReducer")]
public class NetTopologySuite.Precision.SimpleGeometryPrecisionReducer : object {
    private PrecisionModel _newPrecisionModel;
    private bool _removeCollapsed;
    private bool _changePrecisionModel;
    public bool RemoveCollapsedComponents { get; public set; }
    public bool ChangePrecisionModel { get; public set; }
    public SimpleGeometryPrecisionReducer(PrecisionModel pm);
    public static IGeometry Reduce(IGeometry g, PrecisionModel precModel);
    public bool get_RemoveCollapsedComponents();
    public void set_RemoveCollapsedComponents(bool value);
    public bool get_ChangePrecisionModel();
    public void set_ChangePrecisionModel(bool value);
    public IGeometry Reduce(IGeometry geom);
}
public class NetTopologySuite.Precision.SimpleMinimumClearance : object {
    private IGeometry _inputGeom;
    private double _minClearance;
    private Coordinate[] _minClearancePts;
    public SimpleMinimumClearance(IGeometry geom);
    public static double GetDistance(IGeometry g);
    public static IGeometry GetLine(IGeometry g);
    public double GetDistance();
    public ILineString GetLine();
    private void Compute();
    private void UpdateClearance(double candidateValue, Coordinate p0, Coordinate p1);
    private void UpdateClearance(double candidateValue, Coordinate p, Coordinate seg0, Coordinate seg1);
}
public class NetTopologySuite.Shape.Fractal.KochSnowflakeBuilder : GeometricShapeBuilder {
    private CoordinateList _coordList;
    private static double HeightFactor;
    private static double OneThird;
    private static double ThirdHeight;
    private static double TwoThirds;
    public KochSnowflakeBuilder(IGeometryFactory geomFactory);
    private static KochSnowflakeBuilder();
    private static int RecursionLevelForSize(int numPts);
    public virtual IGeometry GetGeometry();
    private Coordinate[] GetBoundary(int level, Coordinate origin, double width);
    private void AddSide(int level, Coordinate p0, Coordinate p1);
    private void AddSegment(Coordinate p0, Coordinate p1);
}
public class NetTopologySuite.Shape.Fractal.SierpinskiCarpetBuilder : GeometricShapeBuilder {
    public SierpinskiCarpetBuilder(IGeometryFactory geomFactory);
    private static int RecursionLevelForSize(int numPts);
    public virtual IGeometry GetGeometry();
    private ILinearRing[] GetHoles(int n, double originX, double originY, double width);
    private void AddHoles(int n, double originX, double originY, double width, ICollection`1<IGeometry> holeList);
    private ILinearRing CreateSquareHole(double x, double y, double width);
}
public abstract class NetTopologySuite.Shape.GeometricShapeBuilder : object {
    private Envelope _extent;
    protected IGeometryFactory GeomFactory;
    [CompilerGeneratedAttribute]
private int <NumPoints>k__BackingField;
    public Envelope Extent { get; public set; }
    public Coordinate Centre { get; }
    public double Diameter { get; }
    public double Radius { get; }
    public int NumPoints { get; public set; }
    protected GeometricShapeBuilder(IGeometryFactory geomFactory);
    public Envelope get_Extent();
    public void set_Extent(Envelope value);
    public Coordinate get_Centre();
    public double get_Diameter();
    public double get_Radius();
    public LineSegment GetSquareBaseLine();
    public Envelope GetSquareExtent();
    [CompilerGeneratedAttribute]
public int get_NumPoints();
    [CompilerGeneratedAttribute]
public void set_NumPoints(int value);
    public abstract virtual IGeometry GetGeometry();
    protected Coordinate CreateCoord(double x, double y);
}
public class NetTopologySuite.Shape.Random.RandomPointsBuilder : GeometricShapeBuilder {
    protected static Random Rnd;
    private IGeometry _maskPoly;
    private IPointOnGeometryLocator _extentLocator;
    public RandomPointsBuilder(IGeometryFactory geomFact);
    private static RandomPointsBuilder();
    public void SetExtent(IGeometry mask);
    public virtual IGeometry GetGeometry();
    protected bool IsInExtent(Coordinate p);
    protected Coordinate CreateRandomCoord(Envelope env);
}
public class NetTopologySuite.Shape.Random.RandomPointsInGridBuilder : GeometricShapeBuilder {
    protected static Random Rnd;
    private bool _isConstrainedToCircle;
    [CompilerGeneratedAttribute]
private double <GutterFraction>k__BackingField;
    public bool ConstrainedToCircle { get; public set; }
    public double GutterFraction { get; public set; }
    public RandomPointsInGridBuilder(IGeometryFactory geomFact);
    private static RandomPointsInGridBuilder();
    public bool get_ConstrainedToCircle();
    public void set_ConstrainedToCircle(bool value);
    [CompilerGeneratedAttribute]
public double get_GutterFraction();
    [CompilerGeneratedAttribute]
public void set_GutterFraction(double value);
    public virtual IGeometry GetGeometry();
    private Coordinate RandomPointInCell(double orgX, double orgY, double xLen, double yLen);
    private Coordinate RandomPointInGridCell(double orgX, double orgY, double xLen, double yLen);
    private static Coordinate RandomPointInCircle(double orgX, double orgY, double width, double height);
}
public class NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier : object {
    private Coordinate[] _pts;
    private Boolean[] _usePt;
    [CompilerGeneratedAttribute]
private double <DistanceTolerance>k__BackingField;
    private LineSegment _seg;
    public double DistanceTolerance { get; public set; }
    public DouglasPeuckerLineSimplifier(Coordinate[] pts);
    public static Coordinate[] Simplify(Coordinate[] pts, double distanceTolerance);
    [CompilerGeneratedAttribute]
public double get_DistanceTolerance();
    [CompilerGeneratedAttribute]
public void set_DistanceTolerance(double value);
    public Coordinate[] Simplify();
    private void SimplifySection(int i, int j);
}
public class NetTopologySuite.Simplify.DouglasPeuckerSimplifier : object {
    private IGeometry _inputGeom;
    private double _distanceTolerance;
    private bool _isEnsureValidTopology;
    public double DistanceTolerance { get; public set; }
    public bool EnsureValidTopology { get; public set; }
    public DouglasPeuckerSimplifier(IGeometry inputGeom);
    public static IGeometry Simplify(IGeometry geom, double distanceTolerance);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public bool get_EnsureValidTopology();
    public void set_EnsureValidTopology(bool value);
    public IGeometry GetResultGeometry();
}
public class NetTopologySuite.Simplify.LineSegmentIndex : object {
    private ISpatialIndex`1<LineSegment> _index;
    public void Add(TaggedLineString line);
    public void Add(LineSegment seg);
    public void Remove(LineSegment seg);
    public IList`1<LineSegment> Query(LineSegment querySeg);
}
public class NetTopologySuite.Simplify.LineSegmentVisitor : object {
    private LineSegment _querySeg;
    private IList`1<LineSegment> _items;
    public IList`1<LineSegment> Items { get; }
    public LineSegmentVisitor(LineSegment querySeg);
    public sealed virtual void VisitItem(LineSegment item);
    public IList`1<LineSegment> get_Items();
}
public class NetTopologySuite.Simplify.OldVWLineSimplifier : object {
    private Coordinate[] _pts;
    private double _tolerance;
    public OldVWLineSimplifier(Coordinate[] pts, double distanceTolerance);
    public static Coordinate[] Simplify(Coordinate[] pts, double distanceTolerance);
    public Coordinate[] Simplify();
    private double SimplifyVertex(VWVertex vwLine);
}
public class NetTopologySuite.Simplify.TaggedLineSegment : LineSegment {
    private IGeometry _parent;
    private int _index;
    public IGeometry Parent { get; }
    public int Index { get; }
    public TaggedLineSegment(Coordinate p0, Coordinate p1, IGeometry parent, int index);
    public TaggedLineSegment(Coordinate p0, Coordinate p1);
    public IGeometry get_Parent();
    public int get_Index();
}
public class NetTopologySuite.Simplify.TaggedLinesSimplifier : object {
    private LineSegmentIndex _inputIndex;
    private LineSegmentIndex _outputIndex;
    [CompilerGeneratedAttribute]
private double <DistanceTolerance>k__BackingField;
    public double DistanceTolerance { get; public set; }
    [CompilerGeneratedAttribute]
public double get_DistanceTolerance();
    [CompilerGeneratedAttribute]
public void set_DistanceTolerance(double value);
    public void Simplify(ICollection`1<TaggedLineString> taggedLines);
}
public class NetTopologySuite.Simplify.TaggedLineString : object {
    private ILineString _parentLine;
    private TaggedLineSegment[] _segs;
    private IList`1<LineSegment> _resultSegs;
    private int _minimumSize;
    public int MinimumSize { get; }
    public ILineString Parent { get; }
    public Coordinate[] ParentCoordinates { get; }
    public Coordinate[] ResultCoordinates { get; }
    public int ResultSize { get; }
    public TaggedLineSegment[] Segments { get; }
    public TaggedLineString(ILineString parentLine);
    public TaggedLineString(ILineString parentLine, int minimumSize);
    public int get_MinimumSize();
    public ILineString get_Parent();
    public Coordinate[] get_ParentCoordinates();
    public Coordinate[] get_ResultCoordinates();
    public int get_ResultSize();
    public TaggedLineSegment GetSegment(int i);
    private void Init();
    public TaggedLineSegment[] get_Segments();
    public void AddToResult(LineSegment seg);
    public ILineString AsLineString();
    public ILinearRing AsLinearRing();
    private static Coordinate[] ExtractCoordinates(IList`1<LineSegment> segs);
}
public class NetTopologySuite.Simplify.TaggedLineStringSimplifier : object {
    private LineIntersector _li;
    private LineSegmentIndex _inputIndex;
    private LineSegmentIndex _outputIndex;
    private TaggedLineString _line;
    private Coordinate[] _linePts;
    private double _distanceTolerance;
    public double DistanceTolerance { get; public set; }
    public TaggedLineStringSimplifier(LineSegmentIndex inputIndex, LineSegmentIndex outputIndex);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public void Simplify(TaggedLineString line);
    private void SimplifySection(int i, int j, int depth);
    private int FindFurthestPoint(Coordinate[] pts, int i, int j, Double[] maxDistance);
    private LineSegment Flatten(int start, int end);
    private bool HasBadIntersection(TaggedLineString parentLine, Int32[] sectionIndex, LineSegment candidateSeg);
    private bool HasBadOutputIntersection(LineSegment candidateSeg);
    private bool HasBadInputIntersection(TaggedLineString parentLine, Int32[] sectionIndex, LineSegment candidateSeg);
    private static bool IsInLineSection(TaggedLineString line, Int32[] sectionIndex, TaggedLineSegment seg);
    private bool HasInteriorIntersection(LineSegment seg0, LineSegment seg1);
    private void Remove(TaggedLineString line, int start, int end);
}
public class NetTopologySuite.Simplify.TopologyPreservingSimplifier : object {
    private IGeometry _inputGeom;
    private TaggedLinesSimplifier _lineSimplifier;
    private Dictionary`2<ILineString, TaggedLineString> _lineStringMap;
    public double DistanceTolerance { get; public set; }
    public TopologyPreservingSimplifier(IGeometry inputGeom);
    public static IGeometry Simplify(IGeometry geom, double distanceTolerance);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public IGeometry GetResultGeometry();
}
public class NetTopologySuite.Simplify.VWLineSimplifier : object {
    private Coordinate[] _pts;
    private double _tolerance;
    public VWLineSimplifier(Coordinate[] pts, double distanceTolerance);
    public static Coordinate[] Simplify(Coordinate[] pts, double distanceTolerance);
    public Coordinate[] Simplify();
}
public class NetTopologySuite.Simplify.VWSimplifier : object {
    private IGeometry _inputGeom;
    private double _distanceTolerance;
    private bool _isEnsureValidTopology;
    public double DistanceTolerance { get; public set; }
    public bool IsEnsureValidTopology { get; public set; }
    public VWSimplifier(IGeometry inputGeom);
    public static IGeometry Simplify(IGeometry geom, double distanceTolerance);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public bool get_IsEnsureValidTopology();
    public void set_IsEnsureValidTopology(bool value);
    public IGeometry GetResultGeometry();
}
public class NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder : object {
    private ICollection`1<Coordinate> _siteCoords;
    private IGeometry _constraintLines;
    private double _tolerance;
    private QuadEdgeSubdivision _subdiv;
    private IDictionary`2<Coordinate, Vertex> _constraintVertexMap;
    unknown IGeometry Constraints {public set; }
    public double Tolerance { get; public set; }
    public void SetSites(IGeometry sites);
    public void set_Constraints(IGeometry value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    private void Create();
    private IEnumerable`1<Vertex> CreateSiteVertices(IEnumerable`1<Coordinate> coords);
    private void CreateVertices(IGeometry geom);
    private static List`1<Segment> CreateConstraintSegments(IGeometry geom);
    private static void CreateConstraintSegments(ILineString line, IList`1<Segment> constraintSegs);
    public QuadEdgeSubdivision GetSubdivision();
    public IMultiLineString GetEdges(IGeometryFactory geomFact);
    public IGeometryCollection GetTriangles(IGeometryFactory geomFact);
}
public class NetTopologySuite.Triangulate.ConformingDelaunayTriangulator : object {
    private IList`1<Vertex> _initialVertices;
    private IList`1<Vertex> _segVertices;
    private IList`1<Segment> _segments;
    private QuadEdgeSubdivision _subdiv;
    private IncrementalDelaunayTriangulator _incDel;
    private IGeometry _convexHull;
    private IConstraintSplitPointFinder _splitFinder;
    private KdTree`1<Vertex> _kdt;
    private ConstraintVertexFactory _vertexFactory;
    private Envelope _computeAreaEnv;
    private Coordinate _splitPt;
    private double _tolerance;
    private static int MaxSplitIteration;
    public IConstraintSplitPointFinder SplitPointFinder { get; public set; }
    public double Tolerance { get; }
    public ConstraintVertexFactory VertexFactory { get; public set; }
    public QuadEdgeSubdivision Subdivision { get; }
    public KdTree`1<Vertex> KDT { get; }
    public IList`1<Vertex> InitialVertices { get; }
    public ICollection`1<Segment> ConstraintSegments { get; }
    public IGeometry ConvexHull { get; }
    public ConformingDelaunayTriangulator(IEnumerable`1<Vertex> initialVertices, double tolerance);
    private static Envelope ComputeVertexEnvelope(IEnumerable`1<Vertex> vertices);
    public void SetConstraints(IList`1<Segment> segments, IList`1<Vertex> segVertices);
    public IConstraintSplitPointFinder get_SplitPointFinder();
    public void set_SplitPointFinder(IConstraintSplitPointFinder value);
    public double get_Tolerance();
    public ConstraintVertexFactory get_VertexFactory();
    public void set_VertexFactory(ConstraintVertexFactory value);
    public QuadEdgeSubdivision get_Subdivision();
    public KdTree`1<Vertex> get_KDT();
    public IList`1<Vertex> get_InitialVertices();
    public ICollection`1<Segment> get_ConstraintSegments();
    public IGeometry get_ConvexHull();
    private void ComputeBoundingBox();
    private void ComputeConvexHull();
    private Coordinate[] GetPointArray();
    private ConstraintVertex CreateVertex(Coordinate p);
    private ConstraintVertex CreateVertex(Coordinate p, Segment seg);
    private void InsertSites(ICollection`1<Vertex> vertices);
    private ConstraintVertex InsertSite(ConstraintVertex v);
    public void InsertSite(Coordinate p);
    public void FormInitialDelaunay();
    public void EnforceConstraints();
    private void AddConstraintVertices();
    private int EnforceGabriel(ICollection`1<Segment> segsToInsert);
    private Coordinate FindNonGabrielPoint(Segment seg);
}
public class NetTopologySuite.Triangulate.ConstraintEnforcementException : Exception {
    private Coordinate _pt;
    public Coordinate Coordinate { get; }
    public ConstraintEnforcementException(string msg);
    public ConstraintEnforcementException(string msg, Coordinate pt);
    private static string MsgWithCoord(string msg, Coordinate pt);
    public Coordinate get_Coordinate();
}
public class NetTopologySuite.Triangulate.ConstraintVertex : Vertex {
    private bool isOnConstraint;
    private object constraint;
    public bool IsOnConstraint { get; public set; }
    public object Constraint { get; public set; }
    public ConstraintVertex(Coordinate p);
    public bool get_IsOnConstraint();
    public void set_IsOnConstraint(bool value);
    public object get_Constraint();
    public void set_Constraint(object value);
    protected internal void Merge(ConstraintVertex other);
}
public interface NetTopologySuite.Triangulate.ConstraintVertexFactory {
    public abstract virtual ConstraintVertex CreateVertex(Coordinate p, Segment constraintSeg);
}
public class NetTopologySuite.Triangulate.DelaunayTriangulationBuilder : object {
    private ICollection`1<Coordinate> _siteCoords;
    private double _tolerance;
    private QuadEdgeSubdivision _subdiv;
    unknown double Tolerance {public set; }
    public static CoordinateList ExtractUniqueCoordinates(IGeometry geom);
    public static CoordinateList Unique(Coordinate[] coords);
    public static IList`1<Vertex> ToVertices(ICollection`1<Coordinate> coords);
    public static Envelope Envelope(ICollection`1<Coordinate> coords);
    public void SetSites(IGeometry geom);
    public void SetSites(ICollection`1<Coordinate> coords);
    public void set_Tolerance(double value);
    private void Create();
    public QuadEdgeSubdivision GetSubdivision();
    public IMultiLineString GetEdges(IGeometryFactory geomFact);
    public IGeometryCollection GetTriangles(IGeometryFactory geomFact);
}
public interface NetTopologySuite.Triangulate.IConstraintSplitPointFinder {
    public abstract virtual Coordinate FindSplitPoint(Segment seg, Coordinate encroachPt);
}
public class NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator : object {
    private QuadEdgeSubdivision _subdiv;
    private bool _isUsingTolerance;
    public IncrementalDelaunayTriangulator(QuadEdgeSubdivision subdiv);
    public void InsertSites(ICollection`1<Vertex> vertices);
    public QuadEdge InsertSite(Vertex v);
}
public class NetTopologySuite.Triangulate.MidpointSplitPointFinder : object {
    public sealed virtual Coordinate FindSplitPoint(Segment seg, Coordinate encroachPt);
}
public class NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder : object {
    public sealed virtual Coordinate FindSplitPoint(Segment seg, Coordinate encroachPt);
    public static Coordinate ProjectedSplitPoint(Segment seg, Coordinate encroachPt);
}
public class NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal : object {
    private LinkedList`1<QuadEdgeTriangle> _triQueue;
    public void Init(QuadEdgeTriangle tri);
    public void Init(IEnumerable`1<QuadEdgeTriangle> tris);
    public void VisitAll(ITraversalVisitor visitor);
    private void Process(QuadEdgeTriangle currTri, ITraversalVisitor visitor);
}
public interface NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator {
    public abstract virtual QuadEdge Locate(Vertex v);
}
public interface NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor {
    public abstract virtual bool Visit(QuadEdgeTriangle currTri, int edgeIndex, QuadEdgeTriangle neighbTri);
}
public interface NetTopologySuite.Triangulate.QuadEdge.ITriangleVisitor {
    public abstract virtual void Visit(QuadEdge[] triEdges);
}
public class NetTopologySuite.Triangulate.QuadEdge.LastFoundQuadEdgeLocator : object {
    private QuadEdgeSubdivision _subdiv;
    private QuadEdge _lastEdge;
    public LastFoundQuadEdgeLocator(QuadEdgeSubdivision subdiv);
    private void Init();
    private QuadEdge FindEdge();
    public sealed virtual QuadEdge Locate(Vertex v);
}
public class NetTopologySuite.Triangulate.QuadEdge.LocateFailureException : Exception {
    [CompilerGeneratedAttribute]
private LineSegment <Segment>k__BackingField;
    public LineSegment Segment { get; private set; }
    public LocateFailureException(string msg);
    public LocateFailureException(string msg, LineSegment seg);
    public LocateFailureException(LineSegment seg);
    private static string MsgWithSpatial(string msg, LineSegment seg);
    [CompilerGeneratedAttribute]
public LineSegment get_Segment();
    [CompilerGeneratedAttribute]
private void set_Segment(LineSegment value);
}
public class NetTopologySuite.Triangulate.QuadEdge.QuadEdge : object {
    private Vertex _vertex;
    private QuadEdge _next;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private QuadEdge <Rot>k__BackingField;
    public object Data { get; public set; }
    public bool IsLive { get; }
    internal QuadEdge Rot { get; internal set; }
    private QuadEdge InvRot { get; }
    internal QuadEdge Sym { get; }
    internal QuadEdge ONext { get; }
    internal QuadEdge OPrev { get; }
    internal QuadEdge DNext { get; }
    internal QuadEdge DPrev { get; }
    internal QuadEdge LNext { get; }
    internal QuadEdge LPrev { get; }
    internal QuadEdge RNext { get; }
    internal QuadEdge RPrev { get; }
    public Vertex Orig { get; internal set; }
    public Vertex Dest { get; internal set; }
    public double Length { get; }
    public static QuadEdge MakeEdge(Vertex o, Vertex d);
    public static QuadEdge Connect(QuadEdge a, QuadEdge b);
    public static void Splice(QuadEdge a, QuadEdge b);
    public static void Swap(QuadEdge e);
    public QuadEdge GetPrimary();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    [CompilerGeneratedAttribute]
public object get_Data();
    public void Delete();
    public bool get_IsLive();
    public void SetNext(QuadEdge next);
    [CompilerGeneratedAttribute]
internal QuadEdge get_Rot();
    [CompilerGeneratedAttribute]
internal void set_Rot(QuadEdge value);
    private QuadEdge get_InvRot();
    internal QuadEdge get_Sym();
    internal QuadEdge get_ONext();
    internal QuadEdge get_OPrev();
    internal QuadEdge get_DNext();
    internal QuadEdge get_DPrev();
    internal QuadEdge get_LNext();
    internal QuadEdge get_LPrev();
    internal QuadEdge get_RNext();
    internal QuadEdge get_RPrev();
    public Vertex get_Orig();
    internal void set_Orig(Vertex value);
    public Vertex get_Dest();
    internal void set_Dest(Vertex value);
    public double get_Length();
    public bool EqualsNonOriented(QuadEdge qe);
    public bool EqualsOriented(QuadEdge qe);
    public LineSegment ToLineSegment();
    public virtual string ToString();
}
public class NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision : object {
    private static double EdgeCoincidenceToleranceFactor;
    private int _visitedKey;
    private List`1<QuadEdge> _quadEdges;
    private QuadEdge _startingEdge;
    private double _tolerance;
    private double _edgeCoincidenceTolerance;
    private Vertex[] _frameVertex;
    private Envelope _frameEnv;
    private IQuadEdgeLocator _locator;
    private LineSegment seg;
    private QuadEdge[] _triEdges;
    public double Tolerance { get; }
    public Envelope Envelope { get; }
    public QuadEdgeSubdivision(Envelope env, double tolerance);
    public static void GetTriangleEdges(QuadEdge startQE, QuadEdge[] triEdge);
    private void CreateFrame(Envelope env);
    private QuadEdge InitSubdiv();
    public double get_Tolerance();
    public Envelope get_Envelope();
    public IList`1<QuadEdge> GetEdges();
    public void SetLocator(IQuadEdgeLocator locator);
    public QuadEdge MakeEdge(Vertex o, Vertex d);
    public QuadEdge Connect(QuadEdge a, QuadEdge b);
    public void Delete(QuadEdge e);
    public QuadEdge LocateFromEdge(Vertex v, QuadEdge startEdge);
    public QuadEdge Locate(Vertex v);
    public QuadEdge Locate(Coordinate p);
    public QuadEdge Locate(Coordinate p0, Coordinate p1);
    public QuadEdge InsertSite(Vertex v);
    public bool IsFrameEdge(QuadEdge e);
    public bool IsFrameBorderEdge(QuadEdge e);
    public bool IsFrameVertex(Vertex v);
    public bool IsOnEdge(QuadEdge e, Coordinate p);
    public bool IsVertexOfEdge(QuadEdge e, Vertex v);
    public IEnumerable`1<Vertex> GetVertices(bool includeFrame);
    public IList`1<QuadEdge> GetVertexUniqueEdges(bool includeFrame);
    public IList`1<QuadEdge> GetPrimaryEdges(bool includeFrame);
    public void VisitTriangles(ITriangleVisitor triVisitor, bool includeFrame);
    private QuadEdge[] FetchTriangleToVisit(QuadEdge edge, Stack`1<QuadEdge> edgeStack, bool includeFrame, HashSet`1<QuadEdge> visitedEdges);
    public IList`1<QuadEdge[]> GetTriangleEdges(bool includeFrame);
    public IList`1<Vertex[]> GetTriangleVertices(bool includeFrame);
    public IList`1<Coordinate[]> GetTriangleCoordinates(bool includeFrame);
    public IMultiLineString GetEdges(IGeometryFactory geomFact);
    public IGeometryCollection GetTriangles(IGeometryFactory geomFact);
    public IGeometryCollection GetVoronoiDiagram(IGeometryFactory geomFact);
    public IList`1<IGeometry> GetVoronoiCellPolygons(IGeometryFactory geomFact);
    public IPolygon GetVoronoiCellPolygon(QuadEdge qe, IGeometryFactory geomFact);
}
public class NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle : object {
    private QuadEdge[] _edge;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public object Data { get; public set; }
    public QuadEdgeTriangle(QuadEdge[] edge);
    public static IList`1<QuadEdgeTriangle> CreateOn(QuadEdgeSubdivision subdiv);
    public static bool Contains(Vertex[] tri, Coordinate pt);
    public static bool Contains(QuadEdge[] tri, Coordinate pt);
    public static IGeometry ToPolygon(Vertex[] v);
    public static IGeometry ToPolygon(QuadEdge[] e);
    private static QuadEdge[] CopyOf(QuadEdge[] edge);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    public void Kill();
    public bool IsLive();
    public QuadEdge[] GetEdges();
    public QuadEdge GetEdge(int i);
    public Vertex GetVertex(int i);
    public Vertex[] GetVertices();
    public Coordinate GetCoordinate(int i);
    public int GetEdgeIndex(QuadEdge e);
    public int GetEdgeIndex(Vertex v);
    public void GetEdgeSegment(int i, LineSegment seg);
    public Coordinate[] GetCoordinates();
    public bool Contains(Coordinate pt);
    public IGeometry GetGeometry(GeometryFactory fact);
    public virtual string ToString();
    public bool IsBorder();
    public bool IsBorder(int i);
    public QuadEdgeTriangle GetAdjacentTriangleAcrossEdge(int edgeIndex);
    public int GetAdjacentTriangleEdgeIndex(int i);
    public IList`1<QuadEdgeTriangle> GetTrianglesAdjacentToVertex(int vertexIndex);
    public QuadEdgeTriangle[] GetNeighbours();
}
public class NetTopologySuite.Triangulate.QuadEdge.QuadEdgeUtil : object {
    public static IList`1<QuadEdge> FindEdgesIncidentOnOrigin(QuadEdge start);
}
public static class NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate : object {
    public static bool IsInCircleNonRobust(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    public static bool IsInCircleNormalized(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    private static double TriArea(Coordinate a, Coordinate b, Coordinate c);
    public static bool IsInCircleRobust(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    [ObsoleteAttribute]
public static bool IsInCircleDDSlow(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    [ObsoleteAttribute]
private static DD TriAreaDDSlow(DD ax, DD ay, DD bx, DD by, DD cx, DD cy);
    public static bool IsInCircleDDFast(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    private static DD TriAreaDDFast(Coordinate a, Coordinate b, Coordinate c);
    public static bool IsInCircleDDNormalized(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    public static bool IsInCircleCC(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    [ObsoleteAttribute]
private static void CheckRobustInCircle(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
}
public class NetTopologySuite.Triangulate.QuadEdge.Vertex : object {
    private static int LEFT;
    private static int RIGHT;
    private static int BEYOND;
    private static int BEHIND;
    private static int BETWEEN;
    private static int ORIGIN;
    private static int DESTINATION;
    private Coordinate _p;
    public double X { get; }
    public double Y { get; }
    public double Z { get; public set; }
    public Coordinate Coordinate { get; }
    public Vertex(double x, double y);
    public Vertex(double x, double y, double z);
    public Vertex(Coordinate p);
    public double get_X();
    public double get_Y();
    public double get_Z();
    public void set_Z(double value);
    public Coordinate get_Coordinate();
    public virtual string ToString();
    public sealed virtual bool Equals(Vertex x);
    public bool Equals(Vertex x, double tolerance);
    public int Classify(Vertex p0, Vertex p1);
    private double CrossProduct(Vertex v);
    private double Dot(Vertex v);
    private Vertex Times(double c);
    private Vertex Sum(Vertex v);
    private Vertex Sub(Vertex v);
    private double Magnitude();
    private Vertex Cross();
    public bool IsInCircle(Vertex a, Vertex b, Vertex c);
    private bool IsCcw(Vertex b, Vertex c);
    internal bool RightOf(QuadEdge e);
    private bool LeftOf(QuadEdge e);
    private static HCoordinate Bisector(Vertex a, Vertex b);
    private static double Distance(Vertex v1, Vertex v2);
    public double CircumRadiusRatio(Vertex b, Vertex c);
    public Vertex MidPoint(Vertex a);
    public Vertex CircleCenter(Vertex b, Vertex c);
    public double InterpolateZValue(Vertex v0, Vertex v1, Vertex v2);
    public static double InterpolateZ(Coordinate p, Coordinate v0, Coordinate v1, Coordinate v2);
    public static double InterpolateZ(Coordinate p, Coordinate p0, Coordinate p1);
}
public class NetTopologySuite.Triangulate.Segment : object {
    private LineSegment _ls;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public Coordinate Start { get; }
    public Coordinate End { get; }
    public double StartX { get; }
    public double StartY { get; }
    public double StartZ { get; }
    public double EndX { get; }
    public double EndY { get; }
    public double EndZ { get; }
    public LineSegment LineSegment { get; }
    public object Data { get; public set; }
    public Segment(double x1, double y1, double z1, double x2, double y2, double z2);
    public Segment(double x1, double y1, double z1, double x2, double y2, double z2, object data);
    public Segment(Coordinate p0, Coordinate p1, object data);
    public Segment(Coordinate p0, Coordinate p1);
    public Coordinate get_Start();
    public Coordinate get_End();
    public double get_StartX();
    public double get_StartY();
    public double get_StartZ();
    public double get_EndX();
    public double get_EndY();
    public double get_EndZ();
    public LineSegment get_LineSegment();
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    public bool EqualsTopologically(Segment s);
    public Coordinate Intersection(Segment s);
    public virtual string ToString();
}
public class NetTopologySuite.Triangulate.SplitSegment : object {
    private LineSegment _seg;
    private double _segLen;
    private Coordinate _splitPt;
    private double _minimumLen;
    public double MinimumLength { get; public set; }
    public Coordinate SplitPoint { get; }
    public SplitSegment(LineSegment seg);
    private static Coordinate PointAlongReverse(LineSegment seg, double segmentLengthFraction);
    public double get_MinimumLength();
    public void set_MinimumLength(double value);
    public Coordinate get_SplitPoint();
    public void SplitAt(double length, Coordinate endPt);
    public void SplitAt(Coordinate pt);
    private double GetConstrainedLength(double len);
}
public class NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper : object {
    private IDictionary`2<Coordinate, object> _coordDataMap;
    public IList`1<Coordinate> Coordinates { get; }
    public void LoadSourceGeometries(IGeometry geoms);
    public void LoadSourceGeometries(ICollection`1<IGeometry> geoms);
    public void LoadSourceGeometries(IGeometryCollection geomColl);
    private void LoadVertices(Coordinate[] pts, object data);
    public IList`1<Coordinate> get_Coordinates();
    public void TransferData(IGeometry targetGeom);
}
public class NetTopologySuite.Triangulate.VoronoiDiagramBuilder : object {
    private ICollection`1<Coordinate> _siteCoords;
    private double _tolerance;
    private QuadEdgeSubdivision _subdiv;
    private Envelope _clipEnv;
    private Envelope _diagramEnv;
    unknown Envelope ClipEnvelope {public set; }
    unknown double Tolerance {public set; }
    public void SetSites(IGeometry geom);
    public void SetSites(ICollection`1<Coordinate> coords);
    public void set_ClipEnvelope(Envelope value);
    public void set_Tolerance(double value);
    private void Create();
    public QuadEdgeSubdivision GetSubdivision();
    public IGeometryCollection GetDiagram(IGeometryFactory geomFact);
    private static IGeometryCollection ClipGeometryCollection(IGeometryCollection geom, Envelope clipEnv);
}
public class NetTopologySuite.Utilities.AlternativePriorityQueue`2 : object {
    private static int DefaultCapacity;
    private List`1<PriorityQueueNode`2<TPriority, TData>> nodes;
    private IComparer`1<TPriority> priorityComparer;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public PriorityQueueNode`2<TPriority, TData> Head { get; }
    public AlternativePriorityQueue`2(int capacity);
    public AlternativePriorityQueue`2(IComparer`1<TPriority> priorityComparer);
    public AlternativePriorityQueue`2(int capacity, IComparer`1<TPriority> priorityComparer);
    public AlternativePriorityQueue`2(AlternativePriorityQueue`2<TPriority, TData> copyFrom);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public PriorityQueueNode`2<TPriority, TData> get_Head();
    public void Clear();
    public bool Contains(PriorityQueueNode`2<TPriority, TData> node);
    public void Enqueue(PriorityQueueNode`2<TPriority, TData> node, TPriority priority);
    public PriorityQueueNode`2<TPriority, TData> Dequeue();
    public void ChangePriority(PriorityQueueNode`2<TPriority, TData> node, TPriority priority);
    public bool Remove(PriorityQueueNode`2<TPriority, TData> node);
    public sealed virtual IEnumerator`1<PriorityQueueNode`2<TPriority, TData>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void HeapifyUp(PriorityQueueNode`2<TPriority, TData> node);
    private void HeapifyDown(PriorityQueueNode`2<TPriority, TData> node);
    private void OnNodeUpdated(PriorityQueueNode`2<TPriority, TData> node);
    private void Swap(PriorityQueueNode`2<TPriority, TData> node1, PriorityQueueNode`2<TPriority, TData> node2);
    private bool HasHigherPriority(PriorityQueueNode`2<TPriority, TData> higher, PriorityQueueNode`2<TPriority, TData> lower);
}
public static class NetTopologySuite.Utilities.Assert : object {
    public static void IsTrue(bool assertion);
    public static void IsTrue(bool assertion, string message);
    public static void IsEquals(object expectedValue, object actualValue);
    public static void IsEquals(object expectedValue, object actualValue, string message);
    public static void ShouldNeverReachHere();
    public static void ShouldNeverReachHere(string message);
}
public class NetTopologySuite.Utilities.AssertionFailedException : ApplicationException {
    public AssertionFailedException(string message);
}
[ObsoleteAttribute("All supported platforms would be better off using the more efficient System.BitConverter methods instead.", "True")]
public class NetTopologySuite.Utilities.BitConverter : object {
    [ObsoleteAttribute("Use System.BitConverter.DoubleToInt64Bits instead.", "True")]
public static long DoubleToInt64Bits(double x);
    [ObsoleteAttribute("Use System.BitConverter.Int64BitsToDouble instead.", "True")]
public static double Int64BitsToDouble(long x);
}
internal static class NetTopologySuite.Utilities.BitTweaks : object {
    internal static short ReverseByteOrder(short value);
    internal static int ReverseByteOrder(int value);
    internal static long ReverseByteOrder(long value);
    internal static float ReverseByteOrder(float value);
    internal static double ReverseByteOrder(double value);
    internal static ushort ReverseByteOrder(ushort value);
    internal static UInt32 ReverseByteOrder(UInt32 value);
    internal static ulong ReverseByteOrder(ulong value);
}
[ObsoleteAttribute("No longer used anywhere in NTS; see error messages on individual methods for what to use instead.", "True")]
public static class NetTopologySuite.Utilities.Caster : object {
    [ObsoleteAttribute("No longer used anywhere in NTS; use System.Linq.Enumerable.Cast<TResult>(this IEnumerable source) instead.", "True")]
public static IEnumerable`1<T> Cast(IEnumerable inputs);
    [ObsoleteAttribute("No longer used anywhere in NTS; use generic type parameter covariance instead.  Upcast<TSub, TSuper>(something) should be equivalent to System.Linq.Enumerable.AsEnumerable<TSuper>(something), but you might be able to do better in your specific case.", "True")]
public static IEnumerable`1<TSuper> Upcast(IEnumerable`1<TSub> inputs);
    [ObsoleteAttribute("No longer used anywhere in NTS; use System.Linq.Enumerable.Cast<TResult>(this IEnumerable source) instead.", "True")]
public static IEnumerable`1<TSub> Downcast(IEnumerable`1<TSuper> inputs);
}
[ObsoleteAttribute("Use LINQ-to-Objects instead.")]
public class NetTopologySuite.Utilities.CollectionUtil : object {
    [ObsoleteAttribute]
public static IList`1<TOut> Cast(ICollection`1<TIn> coll);
    [ObsoleteAttribute]
public static IList`1<T> Transform(IList`1<T> list, FunctionDelegate`1<T> function);
    [ObsoleteAttribute]
public static IList`1<TResult> Transform(IList`1<T> list, FunctionDelegate`2<T, TResult> function);
    [ObsoleteAttribute]
public static void Apply(IEnumerable`1<T> coll, FunctionDelegate`1<T> func);
    [ObsoleteAttribute]
public static IList`1<T> Select(IEnumerable`1<T> items, FunctionDelegate`2<T, bool> func);
    [ObsoleteAttribute("Use 'array.Cast<TOut>().ToArray()' instead.")]
public static TOut[] Cast(TIn[] array);
    internal static IEnumerable`1<T> StableSort(IEnumerable`1<T> items);
    internal static IEnumerable`1<T> StableSort(IEnumerable`1<T> items, IComparer`1<T> comparer);
    [ObsoleteAttribute("Not used anywhere in NTS; use LINQ or a generic overload instead.", "True")]
public static IList`1<T> Cast(ICollection coll);
    [ObsoleteAttribute("Not used anywhere in NTS; use LINQ or a generic overload instead.", "True")]
public static IList Transform(ICollection coll, FunctionDelegate`1<object> func);
    [ObsoleteAttribute("Not used anywhere in NTS; use LINQ or a generic overload instead.", "True")]
public static void Apply(ICollection coll, FunctionDelegate`1<object> func);
    [ObsoleteAttribute("Not used anywhere in NTS; use LINQ or a generic overload instead.", "True")]
public static IList Select(ICollection coll, FunctionDelegate`2<object, bool> func);
}
public class NetTopologySuite.Utilities.CoordinateArrayFilter : object {
    private Coordinate[] _pts;
    private int _n;
    public Coordinate[] Coordinates { get; }
    public CoordinateArrayFilter(int size);
    public Coordinate[] get_Coordinates();
    public sealed virtual void Filter(Coordinate coord);
}
public class NetTopologySuite.Utilities.CoordinateCompare : object {
    public sealed virtual int Compare(object x, object y);
}
public class NetTopologySuite.Utilities.CoordinateCountFilter : object {
    private int _n;
    public int Count { get; }
    public int get_Count();
    public sealed virtual void Filter(Coordinate coord);
}
public class NetTopologySuite.Utilities.Degrees : object {
    public static double ToRadians(double degrees);
}
public static class NetTopologySuite.Utilities.EnumUtility : object {
    public static object Parse(Type type, string value);
    public static string Format(Type type, object value, string formatString);
}
public class NetTopologySuite.Utilities.FunctionsUtil : object {
    public static Envelope DefaultEnvelope;
    private static IGeometryFactory Factory;
    private static FunctionsUtil();
    public static Envelope GetEnvelopeOrDefault(IGeometry g);
    public static IGeometryFactory GetFactoryOrDefault(IGeometry g);
    public static IGeometryFactory GetFactoryOrDefault(IEnumerable`1<IGeometry> gs);
    public static IGeometry BuildGeometry(List`1<IGeometry> geoms, IGeometry parentGeom);
    public static IGeometry BuildGeometry(IGeometry[] geoms);
    public static IGeometry BuildGeometry(IGeometry a, IGeometry b);
}
public class NetTopologySuite.Utilities.GeometricShapeFactory : object {
    protected IGeometryFactory GeomFact;
    protected IPrecisionModel PrecModel;
    private Dimensions _dim;
    private int _nPts;
    private double _rotationAngle;
    unknown Coordinate Base {public set; }
    unknown Coordinate Centre {public set; }
    public Envelope Envelope { get; public set; }
    public int NumPoints { get; public set; }
    unknown double Size {public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Rotation { get; public set; }
    public GeometricShapeFactory(IGeometryFactory geomFact);
    public void set_Base(Coordinate value);
    public void set_Centre(Coordinate value);
    public Envelope get_Envelope();
    public void set_Envelope(Envelope value);
    public int get_NumPoints();
    public void set_NumPoints(int value);
    public void set_Size(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Rotation();
    public void set_Rotation(double value);
    protected IGeometry Rotate(IGeometry geom);
    protected Coordinate CreateCoord(double x, double y);
    protected Coordinate CreateCoordTrans(double x, double y, Coordinate trans);
    public IPolygon CreateRectangle();
    public IPolygon CreateCircle();
    [ObsoleteAttribute("Use CreateEllipse")]
public IPolygon CeateEllipse();
    public IPolygon CreateEllipse();
    public IPolygon CreateSquircle();
    public IPolygon CreateSupercircle(double power);
    public ILineString CreateArc(double startAng, double angExtent);
    public IPolygon CreateArcPolygon(double startAng, double angExtent);
}
public class NetTopologySuite.Utilities.Global : object {
    private NumberFormatInfo _nfi;
    private static Global global;
    private static Global();
    public static NumberFormatInfo GetNfi();
}
public static class NetTopologySuite.Utilities.Guard : object {
    public static void IsNotNull(object candidate, string propertyName);
}
public class NetTopologySuite.Utilities.HexConverter : object {
    public static string ConvertAny2Any(string valueIn, int baseIn, int baseOut);
}
public class NetTopologySuite.Utilities.Memory : object {
    public static double KB;
    public static double MB;
    public static double GB;
    public static long Total { get; }
    public static string TotalString { get; }
    public static long get_Total();
    public static string get_TotalString();
    public static string Format(long mem);
    public static double Round(double d);
}
[ObsoleteAttribute("Not used anywhere within NTS")]
public static class NetTopologySuite.Utilities.PlatformUtilityEx : object {
    [ObsoleteAttribute("Not used anywhere within NTS")]
public static ICollection CastPlatform(ICollection self);
    [ObsoleteAttribute("Not used anywhere within NTS")]
public static ICollection CastPlatform(IList self);
    [ObsoleteAttribute("Not used anywhere within NTS")]
public static ICollection`1<T> CastPlatform(IList`1<T> self);
    [ObsoleteAttribute("Not used anywhere within NTS")]
public static Encoding GetDefaultEncoding();
    [ObsoleteAttribute("Not used anywhere within NTS")]
public static Encoding GetASCIIEncoding();
}
public class NetTopologySuite.Utilities.PriorityQueue`1 : object {
    private AlternativePriorityQueue`2<T, T> _queue;
    public int Size { get; }
    public PriorityQueue`1(int capacity, IComparer`1<T> comparer);
    public void Add(T x);
    public bool IsEmpty();
    public int get_Size();
    public void Clear();
    public T Poll();
    public T Peek();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NetTopologySuite.Utilities.PriorityQueueNode`2 : object {
    private TData data;
    [CompilerGeneratedAttribute]
private TPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueueIndex>k__BackingField;
    public TData Data { get; }
    public TPriority Priority { get; internal set; }
    internal int QueueIndex { get; internal set; }
    public PriorityQueueNode`2(TData data);
    internal PriorityQueueNode`2(PriorityQueueNode`2<TPriority, TData> copyFrom);
    public TData get_Data();
    [CompilerGeneratedAttribute]
public TPriority get_Priority();
    [CompilerGeneratedAttribute]
internal void set_Priority(TPriority value);
    [CompilerGeneratedAttribute]
internal int get_QueueIndex();
    [CompilerGeneratedAttribute]
internal void set_QueueIndex(int value);
}
public class NetTopologySuite.Utilities.Radians : object {
    public static double ToDegrees(double radians);
}
internal class NetTopologySuite.Utilities.ReverseOrder : object {
    public sealed virtual int Compare(object x, object y);
}
public class NetTopologySuite.Utilities.UniqueCoordinateArrayFilter : object {
    private List`1<Coordinate> _list;
    public Coordinate[] Coordinates { get; }
    public static Coordinate[] FilterCoordinates(Coordinate[] coords);
    public Coordinate[] get_Coordinates();
    public sealed virtual void Filter(Coordinate coord);
}
internal class ProcessedByFody : object {
    internal static string FodyVersion;
    internal static string ModuleInit;
}
[DefaultMemberAttribute("Item")]
public class RTools_NTS.Util.CharBuffer : object {
    private int capacity;
    private Char[] buffer;
    private int headIndex;
    private int tailIndex;
    public int Length { get; public set; }
    public int Capacity { get; }
    public char Item { get; public set; }
    public CharBuffer(int capacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    protected void Grow(int requestedLen);
    protected void CheckCapacity(int requestedLength);
    protected void ShiftToZero();
    public void SetBuffer(Char[] b, int len);
    public void Append(char c);
    public void Append(string s);
    public void Append(CharBuffer s);
    public void Remove(int i);
    public void Remove(int i, int n);
    public int IndexOf(char c);
    public void Clear();
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public virtual string ToString();
}
public class RTools_NTS.Util.CharToken : Token {
    public string StringValue { get; }
    public CharToken(string s, int line);
    public CharToken(char c);
    public CharToken(char c, int line);
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string get_StringValue();
    public virtual bool Equals(object other);
}
[FlagsAttribute]
public enum RTools_NTS.Util.CharTypeBits : Enum {
    public byte value__;
    public static CharTypeBits Word;
    public static CharTypeBits Comment;
    public static CharTypeBits Whitespace;
    public static CharTypeBits Quote;
    public static CharTypeBits Digit;
    public static CharTypeBits HexDigit;
    public static CharTypeBits Eof;
}
public class RTools_NTS.Util.CommentToken : StringToken {
    public CommentToken(string s);
    public CommentToken(string s, int line);
}
public class RTools_NTS.Util.EofToken : Token {
    public string StringValue { get; }
    public EofToken(int line);
    public virtual string ToString();
    public virtual string ToDebugString();
    public virtual bool Equals(object other);
    public virtual string get_StringValue();
    public virtual int GetHashCode();
}
public class RTools_NTS.Util.EolToken : Token {
    public string StringValue { get; }
    public EolToken(int line);
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual string get_StringValue();
    public virtual int GetHashCode();
}
public class RTools_NTS.Util.FloatToken : Token {
    private NumberFormatInfo numberFormatInfo;
    public string StringValue { get; }
    public FloatToken(string s);
    public FloatToken(float f);
    public FloatToken(double d);
    public FloatToken(string s, int line);
    public FloatToken(double f, int line);
    private NumberFormatInfo GetNumberFormatInfo();
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string get_StringValue();
    public virtual bool Equals(object other);
}
public class RTools_NTS.Util.IntToken : Token {
    public string StringValue { get; }
    public IntToken(int i);
    public IntToken(long i);
    public IntToken(string s);
    public IntToken(string s, int line);
    public IntToken(int i, int line);
    public IntToken(long l, int line);
    public static IntToken ParseHex(string s, int lineNumber);
    private void Parse(string s);
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string get_StringValue();
    public virtual bool Equals(object other);
}
public class RTools_NTS.Util.QuoteToken : StringToken {
    public QuoteToken(string s);
    public QuoteToken(string s, int line);
}
public class RTools_NTS.Util.StreamTokenizer : object {
    public static int NChars;
    private static int Eof;
    private TextReader textReader;
    private int lineNumber;
    private CharBuffer backString;
    private CharBuffer nextTokenSb;
    private CharBuffer tmpSb;
    private CharBuffer expSb;
    private StreamTokenizerSettings settings;
    public TextReader TextReader { get; public set; }
    public StreamTokenizerSettings Settings { get; }
    public StreamTokenizer(TextReader sr);
    public StreamTokenizer(string str);
    private static StreamTokenizer();
    public TextReader get_TextReader();
    public void set_TextReader(TextReader value);
    public StreamTokenizerSettings get_Settings();
    private void Initialize();
    private void InitializeStream();
    public void Display();
    public void Display(string prefix);
    private NextTokenState PickNextState(byte ctype, int c);
    private NextTokenState PickNextState(byte ctype, int c, NextTokenState excludeState);
    private int GetNextChar();
    public bool NextToken(Token& token);
    private bool GrabInt(CharBuffer sb, bool allowPlus, Char& thisChar);
    public bool Tokenize(IList`1<Token> tokens);
    public bool TokenizeReader(TextReader tr, IList`1<Token> tokens);
    public bool TokenizeFile(string fileName, IList`1<Token> tokens);
    public Token[] TokenizeFile(string fileName);
    public bool TokenizeString(string str, IList`1<Token> tokens);
    public bool TokenizeStream(Stream s, IList`1<Token> tokens);
    public sealed virtual IEnumerator`1<Token> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class RTools_NTS.Util.StreamTokenizerSettings : object {
    private Byte[] charTypes;
    private bool grabWhitespace;
    private bool grabEol;
    private bool slashSlashComments;
    private bool slashStarComments;
    private bool grabComments;
    private bool doUntermCheck;
    private bool parseNumbers;
    private bool parseHexNumbers;
    public Byte[] CharTypes { get; }
    public bool GrabWhitespace { get; public set; }
    public bool GrabEol { get; public set; }
    public bool SlashSlashComments { get; public set; }
    public bool SlashStarComments { get; public set; }
    public bool GrabComments { get; public set; }
    public bool DoUntermCheck { get; public set; }
    public bool ParseNumbers { get; public set; }
    public bool ParseHexNumbers { get; public set; }
    public StreamTokenizerSettings(StreamTokenizerSettings other);
    public Byte[] get_CharTypes();
    public bool get_GrabWhitespace();
    public void set_GrabWhitespace(bool value);
    public bool get_GrabEol();
    public void set_GrabEol(bool value);
    public bool get_SlashSlashComments();
    public void set_SlashSlashComments(bool value);
    public bool get_SlashStarComments();
    public void set_SlashStarComments(bool value);
    public bool get_GrabComments();
    public void set_GrabComments(bool value);
    public bool get_DoUntermCheck();
    public void set_DoUntermCheck(bool value);
    public bool get_ParseNumbers();
    public void set_ParseNumbers(bool value);
    public bool get_ParseHexNumbers();
    public void set_ParseHexNumbers(bool value);
    public void Copy(StreamTokenizerSettings other);
    public bool SetDefaults();
    public bool SetupForCodeParse();
    public void ResetCharTypeTable();
    public void WordChar(int c);
    public void WordChars(int startChar, int endChar);
    public void WordChars(string s);
    public void WhitespaceChar(int c);
    public void WhitespaceChars(int startChar, int endChar);
    public void OrdinaryChars(int startChar, int endChar);
    public void OrdinaryChar(int c);
    public void CommentChar(int c);
    public void QuoteChar(int c);
    public string CharTypeToString(byte ctype);
    public bool IsCharType(byte ctype, CharTypeBits type);
    public bool IsCharType(char c, CharTypeBits type);
    public bool IsCharType(int c, CharTypeBits type);
    public void Display();
    public void Display(string prefix);
}
public class RTools_NTS.Util.StreamTokenizerUntermCommentException : StreamTokenizerUntermException {
    public StreamTokenizerUntermCommentException(string msg);
}
public class RTools_NTS.Util.StreamTokenizerUntermException : Exception {
    public StreamTokenizerUntermException(string msg);
}
public class RTools_NTS.Util.StreamTokenizerUntermQuoteException : StreamTokenizerUntermException {
    public StreamTokenizerUntermQuoteException(string msg);
}
public abstract class RTools_NTS.Util.StringToken : Token {
    public string StringValue { get; }
    public StringToken(string s);
    public StringToken(string s, int line);
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual string get_StringValue();
    public virtual int GetHashCode();
}
public abstract class RTools_NTS.Util.Token : object {
    private int _lineNumber;
    protected object obj;
    private bool untermError;
    private string untermErrorMsg;
    public int LineNumber { get; }
    public object Object { get; }
    public bool UntermError { get; public set; }
    public string UntermErrorMsg { get; public set; }
    public string StringValue { get; }
    public Token(int line);
    public int get_LineNumber();
    public object get_Object();
    public bool get_UntermError();
    public void set_UntermError(bool value);
    public string get_UntermErrorMsg();
    public void set_UntermErrorMsg(string value);
    public virtual bool Equals(object other);
    public bool Equals(string s);
    public bool Equals(char c);
    public static bool op_Equality(Token t, object o);
    public static bool op_Inequality(Token t, object o);
    public static bool op_Equality(Token t, char c);
    public static bool op_Inequality(Token t, char c);
    public static bool op_Equality(Token t, string s);
    public static bool op_Inequality(Token t, string s);
    public virtual int GetHashCode();
    public virtual string get_StringValue();
    public string ToLineString();
    public virtual string ToDebugString();
    public object ConvertToType(Type t);
}
public enum RTools_NTS.Util.VerbosityLevel : Enum {
    public int value__;
    public static VerbosityLevel Error;
    public static VerbosityLevel Warn;
    public static VerbosityLevel Info;
    public static VerbosityLevel Debug;
}
public class RTools_NTS.Util.WhitespaceToken : StringToken {
    public WhitespaceToken(string s);
    public WhitespaceToken(string s, int line);
}
public class RTools_NTS.Util.WordToken : StringToken {
    public WordToken(string s);
    public WordToken(string s, int line);
}
