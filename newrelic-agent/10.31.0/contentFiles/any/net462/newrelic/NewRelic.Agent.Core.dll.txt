internal class Autofac.Builder.ConcreteReflectionActivatorData : ReflectionActivatorData {
    public IInstanceActivator Activator { get; }
    public ConcreteReflectionActivatorData(Type implementer);
    public sealed virtual IInstanceActivator get_Activator();
}
[FlagsAttribute]
internal enum Autofac.Builder.ContainerBuildOptions : Enum {
    public int value__;
    public static ContainerBuildOptions None;
    public static ContainerBuildOptions ExcludeDefaultModules;
    public static ContainerBuildOptions IgnoreStartableComponents;
}
internal class Autofac.Builder.DeferredCallback : object {
    private Action`1<IComponentRegistry> _callback;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Action`1<IComponentRegistry> Callback { get; public set; }
    public Guid Id { get; }
    public DeferredCallback(Action`1<IComponentRegistry> callback);
    public Action`1<IComponentRegistry> get_Callback();
    public void set_Callback(Action`1<IComponentRegistry> value);
    [CompilerGeneratedAttribute]
public Guid get_Id();
}
internal class Autofac.Builder.DynamicRegistrationStyle : object {
}
internal interface Autofac.Builder.IConcreteActivatorData {
    public IInstanceActivator Activator { get; }
    public abstract virtual IInstanceActivator get_Activator();
}
[EditorBrowsableAttribute("1")]
internal interface Autofac.Builder.IHideObjectMembers {
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object other);
}
internal interface Autofac.Builder.IRegistrationBuilder`3 {
    [EditorBrowsableAttribute("1")]
public TActivatorData ActivatorData { get; }
    [EditorBrowsableAttribute("1")]
public TRegistrationStyle RegistrationStyle { get; }
    [EditorBrowsableAttribute("1")]
public RegistrationData RegistrationData { get; }
    public abstract virtual TActivatorData get_ActivatorData();
    public abstract virtual TRegistrationStyle get_RegistrationStyle();
    public abstract virtual RegistrationData get_RegistrationData();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> ExternallyOwned();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OwnedByLifetimeScope();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerDependency();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> SingleInstance();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerLifetimeScope();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerMatchingLifetimeScope(Object[] lifetimeScopeTag);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Type[] services);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Service[] services);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnPreparing(Action`1<PreparingEventArgs> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivating(Action`1<IActivatingEventArgs`1<TLimit>> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivated(Action`1<IActivatedEventArgs`1<TLimit>> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IPropertySelector propertySelector, bool allowCircularDependencies);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(string key, object value);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(Action`1<MetadataConfiguration`1<TMetadata>> configurationAction);
}
internal class Autofac.Builder.MetadataConfiguration`1 : object {
    private IDictionary`2<string, object> _properties;
    internal IEnumerable`1<KeyValuePair`2<string, object>> Properties { get; }
    internal IEnumerable`1<KeyValuePair`2<string, object>> get_Properties();
    public MetadataConfiguration`1<TMetadata> For(Expression`1<Func`2<TMetadata, TProperty>> propertyAccessor, TProperty value);
}
internal static class Autofac.Builder.MetadataKeys : object {
    internal static string RegistrationOrderMetadataKey;
    internal static string AutoActivated;
}
internal class Autofac.Builder.ReflectionActivatorData : object {
    private Type _implementer;
    private IConstructorFinder _constructorFinder;
    private IConstructorSelector _constructorSelector;
    private static IConstructorFinder DefaultConstructorFinder;
    private static IConstructorSelector DefaultConstructorSelector;
    [CompilerGeneratedAttribute]
private IList`1<Parameter> <ConfiguredParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Parameter> <ConfiguredProperties>k__BackingField;
    public Type ImplementationType { get; public set; }
    public IConstructorFinder ConstructorFinder { get; public set; }
    public IConstructorSelector ConstructorSelector { get; public set; }
    public IList`1<Parameter> ConfiguredParameters { get; }
    public IList`1<Parameter> ConfiguredProperties { get; }
    public ReflectionActivatorData(Type implementer);
    private static ReflectionActivatorData();
    public Type get_ImplementationType();
    public void set_ImplementationType(Type value);
    public IConstructorFinder get_ConstructorFinder();
    public void set_ConstructorFinder(IConstructorFinder value);
    public IConstructorSelector get_ConstructorSelector();
    public void set_ConstructorSelector(IConstructorSelector value);
    [CompilerGeneratedAttribute]
public IList`1<Parameter> get_ConfiguredParameters();
    [CompilerGeneratedAttribute]
public IList`1<Parameter> get_ConfiguredProperties();
}
[ExtensionAttribute]
internal static class Autofac.Builder.RegistrationBuilder : object {
    public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> ForDelegate(Func`3<IComponentContext, IEnumerable`1<Parameter>, T> delegate);
    public static IRegistrationBuilder`3<object, SimpleActivatorData, SingleRegistrationStyle> ForDelegate(Type limitType, Func`3<IComponentContext, IEnumerable`1<Parameter>, object> delegate);
    public static IRegistrationBuilder`3<TImplementer, ConcreteReflectionActivatorData, SingleRegistrationStyle> ForType();
    public static IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle> ForType(Type implementationType);
    [ExtensionAttribute]
public static IComponentRegistration CreateRegistration(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> builder);
    public static IComponentRegistration CreateRegistration(Guid id, RegistrationData data, IInstanceActivator activator, IEnumerable`1<Service> services);
    public static IComponentRegistration CreateRegistration(Guid id, RegistrationData data, IInstanceActivator activator, IEnumerable`1<Service> services, IComponentRegistration target);
    public static void RegisterSingleComponent(IComponentRegistry cr, IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> builder);
}
internal class Autofac.Builder.RegistrationBuilder`3 : object {
    [CompilerGeneratedAttribute]
private TActivatorData <ActivatorData>k__BackingField;
    [CompilerGeneratedAttribute]
private TRegistrationStyle <RegistrationStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistrationData <RegistrationData>k__BackingField;
    [EditorBrowsableAttribute("1")]
public TActivatorData ActivatorData { get; }
    [EditorBrowsableAttribute("1")]
public TRegistrationStyle RegistrationStyle { get; }
    [EditorBrowsableAttribute("1")]
public RegistrationData RegistrationData { get; }
    public RegistrationBuilder`3(Service defaultService, TActivatorData activatorData, TRegistrationStyle style);
    [CompilerGeneratedAttribute]
public sealed virtual TActivatorData get_ActivatorData();
    [CompilerGeneratedAttribute]
public sealed virtual TRegistrationStyle get_RegistrationStyle();
    [CompilerGeneratedAttribute]
public sealed virtual RegistrationData get_RegistrationData();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> ExternallyOwned();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OwnedByLifetimeScope();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerDependency();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> SingleInstance();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerLifetimeScope();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerMatchingLifetimeScope(Object[] lifetimeScopeTag);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Type[] services);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Service[] services);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnPreparing(Action`1<PreparingEventArgs> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivating(Action`1<IActivatingEventArgs`1<TLimit>> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivated(Action`1<IActivatedEventArgs`1<TLimit>> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IPropertySelector propertySelector, bool allowCircularDependencies);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(string key, object value);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(Action`1<MetadataConfiguration`1<TMetadata>> configurationAction);
    private sealed virtual override Type Autofac.Builder.IHideObjectMembers.GetType();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Builder.RegistrationBuilderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ComponentDoesNotSupportService { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ComponentDoesNotSupportService();
}
internal class Autofac.Builder.RegistrationData : object {
    private bool _defaultServiceOverridden;
    private Service _defaultService;
    private ICollection`1<Service> _services;
    private IComponentLifetime _lifetime;
    [CompilerGeneratedAttribute]
private InstanceOwnership <Ownership>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceSharing <Sharing>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DeferredCallback <DeferredCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<PreparingEventArgs>> <PreparingHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> <ActivatingHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> <ActivatedHandlers>k__BackingField;
    public IEnumerable`1<Service> Services { get; }
    public InstanceOwnership Ownership { get; public set; }
    public IComponentLifetime Lifetime { get; public set; }
    public InstanceSharing Sharing { get; public set; }
    public IDictionary`2<string, object> Metadata { get; }
    public DeferredCallback DeferredCallback { get; public set; }
    public ICollection`1<EventHandler`1<PreparingEventArgs>> PreparingHandlers { get; }
    public ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> ActivatingHandlers { get; }
    public ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> ActivatedHandlers { get; }
    public RegistrationData(Service defaultService);
    public IEnumerable`1<Service> get_Services();
    public void AddServices(IEnumerable`1<Service> services);
    public void AddService(Service service);
    [CompilerGeneratedAttribute]
public InstanceOwnership get_Ownership();
    [CompilerGeneratedAttribute]
public void set_Ownership(InstanceOwnership value);
    public IComponentLifetime get_Lifetime();
    public void set_Lifetime(IComponentLifetime value);
    [CompilerGeneratedAttribute]
public InstanceSharing get_Sharing();
    [CompilerGeneratedAttribute]
public void set_Sharing(InstanceSharing value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public DeferredCallback get_DeferredCallback();
    [CompilerGeneratedAttribute]
public void set_DeferredCallback(DeferredCallback value);
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<PreparingEventArgs>> get_PreparingHandlers();
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> get_ActivatingHandlers();
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> get_ActivatedHandlers();
    public void CopyFrom(RegistrationData that, bool includeDefaultService);
    private static void AddAll(ICollection`1<T> to, IEnumerable`1<T> from);
    public void ClearServices();
}
[ExtensionAttribute]
internal static class Autofac.Builder.RegistrationExtensions : object {
    [ExtensionAttribute]
public static IRegistrationBuilder`3<Delegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<Delegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType, Service service);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Service service);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> NamedParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> PositionalParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> TypedParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
}
[ExtensionAttribute]
internal static class Autofac.Builder.RegistrationOrderExtensions : object {
    [ExtensionAttribute]
internal static long GetRegistrationOrder(IComponentRegistration registration);
    [ExtensionAttribute]
internal static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> InheritRegistrationOrderFrom(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, IComponentRegistration source);
}
internal class Autofac.Builder.SimpleActivatorData : object {
    [CompilerGeneratedAttribute]
private IInstanceActivator <Activator>k__BackingField;
    public IInstanceActivator Activator { get; }
    public SimpleActivatorData(IInstanceActivator activator);
    [CompilerGeneratedAttribute]
public sealed virtual IInstanceActivator get_Activator();
}
internal class Autofac.Builder.SingleRegistrationStyle : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> <RegisteredHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Target>k__BackingField;
    public Guid Id { get; public set; }
    public ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> RegisteredHandlers { get; }
    public bool PreserveDefaults { get; public set; }
    public IComponentRegistration Target { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> get_RegisteredHandlers();
    [CompilerGeneratedAttribute]
public bool get_PreserveDefaults();
    [CompilerGeneratedAttribute]
public void set_PreserveDefaults(bool value);
    [CompilerGeneratedAttribute]
public IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(IComponentRegistration value);
}
internal class Autofac.ContainerBuilder : object {
    private IList`1<DeferredCallback> _configurationCallbacks;
    private IList`1<Action`1<IContainer>> _buildCallbacks;
    private bool _wasBuilt;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public IDictionary`2<string, object> Properties { get; }
    internal ContainerBuilder(IDictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    public virtual DeferredCallback RegisterCallback(Action`1<IComponentRegistry> configurationCallback);
    public ContainerBuilder RegisterBuildCallback(Action`1<IContainer> buildCallback);
    public IContainer Build(ContainerBuildOptions options);
    private static void StartStartableComponents(IComponentContext componentContext);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IContainer container);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IContainer container, ContainerBuildOptions options);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IComponentRegistry componentRegistry);
    internal void UpdateRegistry(IComponentRegistry componentRegistry);
    private void Build(IComponentRegistry componentRegistry, bool excludeDefaultModules);
    private void RegisterDefaultAdapters(IComponentRegistry componentRegistry);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.ContainerBuilderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BuildCanOnlyBeCalledOnce { get; }
    internal static string ErrorAutoActivating { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BuildCanOnlyBeCalledOnce();
    internal static string get_ErrorAutoActivating();
}
internal class Autofac.Core.ActivatedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Instance>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public T Instance { get; }
    public ActivatedEventArgs`1(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters, T instance);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_Component();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Instance();
}
internal class Autofac.Core.ActivatingEventArgs`1 : EventArgs {
    private T _instance;
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public T Instance { get; public set; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public ActivatingEventArgs`1(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters, T instance);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_Component();
    public sealed virtual T get_Instance();
    public void set_Instance(T value);
    public sealed virtual void ReplaceInstance(object instance);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
}
internal class Autofac.Core.Activators.Delegate.DelegateActivator : InstanceActivator {
    private Func`3<IComponentContext, IEnumerable`1<Parameter>, object> _activationFunction;
    public DelegateActivator(Type limitType, Func`3<IComponentContext, IEnumerable`1<Parameter>, object> activationFunction);
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Delegate.DelegateActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NullFromActivationDelegateFor { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NullFromActivationDelegateFor();
}
internal abstract class Autofac.Core.Activators.InstanceActivator : Disposable {
    [CompilerGeneratedAttribute]
private Type <LimitType>k__BackingField;
    public Type LimitType { get; }
    protected InstanceActivator(Type limitType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_LimitType();
    public virtual string ToString();
}
internal class Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator : InstanceActivator {
    private object _instance;
    private bool _activated;
    [CompilerGeneratedAttribute]
private bool <DisposeInstance>k__BackingField;
    public bool DisposeInstance { get; public set; }
    public ProvidedInstanceActivator(object instance);
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public bool get_DisposeInstance();
    [CompilerGeneratedAttribute]
public void set_DisposeInstance(bool value);
    protected virtual void Dispose(bool disposing);
    private static Type GetType(object instance);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string InstanceAlreadyActivated { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_InstanceAlreadyActivated();
}
internal class Autofac.Core.Activators.Reflection.AutowiringParameter : Parameter {
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
internal class Autofac.Core.Activators.Reflection.AutowiringPropertyInjector : object {
    public static string InstanceTypeNamedParameter;
    public static void InjectProperties(IComponentContext context, object instance, IPropertySelector propertySelector, IEnumerable`1<Parameter> parameters);
}
internal class Autofac.Core.Activators.Reflection.ConstructorParameterBinding : object {
    private ConstructorInfo _ci;
    private Func`1[] _valueRetrievers;
    private static ConcurrentDictionary`2<ConstructorInfo, Func`2<Object[], object>> ConstructorInvokers;
    private ParameterInfo _firstNonBindableParameter;
    [CompilerGeneratedAttribute]
private bool <CanInstantiate>k__BackingField;
    public ConstructorInfo TargetConstructor { get; }
    public bool CanInstantiate { get; }
    public string Description { get; }
    public ConstructorParameterBinding(ConstructorInfo ci, IEnumerable`1<Parameter> availableParameters, IComponentContext context);
    private static ConstructorParameterBinding();
    public ConstructorInfo get_TargetConstructor();
    [CompilerGeneratedAttribute]
public bool get_CanInstantiate();
    public object Instantiate();
    public string get_Description();
    public virtual string ToString();
    private static Func`2<Object[], object> GetConstructorInvoker(ConstructorInfo constructorInfo);
    public static MethodCallExpression ConvertPrimitiveType(Expression valueExpression, Type conversionType);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.ConstructorParameterBindingResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string BoundConstructor { get; }
    public static string CannotInstantitate { get; }
    public static string ExceptionDuringInstantiation { get; }
    public static string NonBindableConstructor { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_BoundConstructor();
    public static string get_CannotInstantitate();
    public static string get_ExceptionDuringInstantiation();
    public static string get_NonBindableConstructor();
}
internal class Autofac.Core.Activators.Reflection.DefaultConstructorFinder : object {
    private Func`2<Type, ConstructorInfo[]> _finder;
    private static ConcurrentDictionary`2<Type, ConstructorInfo[]> DefaultPublicConstructorsCache;
    public DefaultConstructorFinder(Func`2<Type, ConstructorInfo[]> finder);
    private static DefaultConstructorFinder();
    public sealed virtual ConstructorInfo[] FindConstructors(Type targetType);
    private static ConstructorInfo[] GetDefaultPublicConstructors(Type type);
}
internal class Autofac.Core.Activators.Reflection.DefaultValueParameter : Parameter {
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
internal interface Autofac.Core.Activators.Reflection.IConstructorFinder {
    public abstract virtual ConstructorInfo[] FindConstructors(Type targetType);
}
internal interface Autofac.Core.Activators.Reflection.IConstructorSelector {
    public abstract virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings);
}
internal class Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector : object {
    private Type[] _signature;
    public MatchingSignatureConstructorSelector(Type[] signature);
    public sealed virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings);
    [CompilerGeneratedAttribute]
private bool <SelectConstructorBinding>b__2_0(ConstructorParameterBinding b);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AtLeastOneBindingRequired { get; }
    internal static string RequiredConstructorNotAvailable { get; }
    internal static string TooManyConstructorsMatch { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AtLeastOneBindingRequired();
    internal static string get_RequiredConstructorNotAvailable();
    internal static string get_TooManyConstructorsMatch();
}
internal class Autofac.Core.Activators.Reflection.MostParametersConstructorSelector : object {
    public sealed virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.MostParametersConstructorSelectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string UnableToChooseFromMultipleConstructors { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_UnableToChooseFromMultipleConstructors();
}
internal class Autofac.Core.Activators.Reflection.ReflectionActivator : InstanceActivator {
    private Type _implementationType;
    private Parameter[] _configuredProperties;
    private Parameter[] _defaultParameters;
    private ConstructorInfo[] _availableConstructors;
    [CompilerGeneratedAttribute]
private IConstructorFinder <ConstructorFinder>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstructorSelector <ConstructorSelector>k__BackingField;
    public IConstructorFinder ConstructorFinder { get; }
    public IConstructorSelector ConstructorSelector { get; }
    public ReflectionActivator(Type implementationType, IConstructorFinder constructorFinder, IConstructorSelector constructorSelector, IEnumerable`1<Parameter> configuredParameters, IEnumerable`1<Parameter> configuredProperties);
    [CompilerGeneratedAttribute]
public IConstructorFinder get_ConstructorFinder();
    [CompilerGeneratedAttribute]
public IConstructorSelector get_ConstructorSelector();
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    private ConstructorParameterBinding[] GetValidConstructorBindings(IComponentContext context, IEnumerable`1<Parameter> parameters);
    private string GetBindingFailureMessage(IEnumerable`1<ConstructorParameterBinding> constructorBindings);
    private void InjectProperties(object instance, IComponentContext context);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.ReflectionActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NoConstructorsAvailable { get; }
    internal static string NoConstructorsBindable { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NoConstructorsAvailable();
    internal static string get_NoConstructorsBindable();
}
internal class Autofac.Core.AutoActivateService : Service {
    public string Description { get; }
    public virtual string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Autofac.Core.ComponentRegisteredEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <ComponentRegistration>k__BackingField;
    public IComponentRegistry ComponentRegistry { get; }
    public IComponentRegistration ComponentRegistration { get; }
    public ComponentRegisteredEventArgs(IComponentRegistry registry, IComponentRegistration componentRegistration);
    [CompilerGeneratedAttribute]
public IComponentRegistry get_ComponentRegistry();
    [CompilerGeneratedAttribute]
public IComponentRegistration get_ComponentRegistration();
}
internal abstract class Autofac.Core.ConstantParameter : Parameter {
    private Predicate`1<ParameterInfo> _predicate;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    protected ConstantParameter(object value, Predicate`1<ParameterInfo> predicate);
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
    [CompilerGeneratedAttribute]
private object <CanSupplyValue>b__5_0();
}
[DebuggerDisplayAttribute("Tag = {Tag}, IsDisposed = {IsDisposed}")]
internal class Autofac.Core.Container : Disposable {
    private ILifetimeScope _rootLifetimeScope;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public IComponentRegistry ComponentRegistry { get; }
    internal Container(IDictionary`2<string, object> properties);
    public sealed virtual ILifetimeScope BeginLifetimeScope();
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag);
    public sealed virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    public sealed virtual IDisposer get_Disposer();
    public sealed virtual object get_Tag();
    public sealed virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    public sealed virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    public sealed virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    public sealed virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    public sealed virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    public sealed virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistry get_ComponentRegistry();
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    protected virtual void Dispose(bool disposing);
    public sealed virtual object GetService(Type serviceType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.ContainerResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SelfRegistrationCannotBeActivated { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SelfRegistrationCannotBeActivated();
}
internal class Autofac.Core.DefaultPropertySelector : object {
    [CompilerGeneratedAttribute]
private bool <PreserveSetValues>k__BackingField;
    [CompilerGeneratedAttribute]
private static IPropertySelector <OverwriteSetValueInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private static IPropertySelector <PreserveSetValueInstance>k__BackingField;
    public bool PreserveSetValues { get; protected set; }
    internal static IPropertySelector OverwriteSetValueInstance { get; }
    internal static IPropertySelector PreserveSetValueInstance { get; }
    public DefaultPropertySelector(bool preserveSetValues);
    private static DefaultPropertySelector();
    [CompilerGeneratedAttribute]
public bool get_PreserveSetValues();
    [CompilerGeneratedAttribute]
protected void set_PreserveSetValues(bool value);
    [CompilerGeneratedAttribute]
internal static IPropertySelector get_OverwriteSetValueInstance();
    [CompilerGeneratedAttribute]
internal static IPropertySelector get_PreserveSetValueInstance();
    public virtual bool InjectProperty(PropertyInfo propertyInfo, object instance);
}
internal class Autofac.Core.DelegatePropertySelector : object {
    private Func`3<PropertyInfo, object, bool> _finder;
    public DelegatePropertySelector(Func`3<PropertyInfo, object, bool> finder);
    public sealed virtual bool InjectProperty(PropertyInfo property, object instance);
}
internal class Autofac.Core.DependencyResolutionException : Exception {
    public string Message { get; }
    public DependencyResolutionException(string message);
    public DependencyResolutionException(string message, Exception innerException);
    public virtual string get_Message();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.DependencyResolutionExceptionResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MessageNestingFormat { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MessageNestingFormat();
}
[ObsoleteAttribute("Use the more general Autofac.IStartable interface instead. The IContainer parameter can be emulated when implementing IStartable by taking a dependency on IComponentContext or ILifetimeScope.", "True")]
internal interface Autofac.Core.Diagnostics.IContainerAwareComponent {
    public abstract virtual void SetContainer(IContainer container);
}
internal class Autofac.Core.Disposer : Disposable {
    private Stack`1<IDisposable> _items;
    private object _synchRoot;
    protected virtual void Dispose(bool disposing);
    public sealed virtual void AddInstanceForDisposal(IDisposable instance);
}
internal interface Autofac.Core.IActivatedEventArgs`1 {
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public T Instance { get; }
    public abstract virtual IComponentContext get_Context();
    public abstract virtual IComponentRegistration get_Component();
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
    public abstract virtual T get_Instance();
}
internal interface Autofac.Core.IActivatingEventArgs`1 {
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public T Instance { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public abstract virtual IComponentContext get_Context();
    public abstract virtual IComponentRegistration get_Component();
    public abstract virtual T get_Instance();
    public abstract virtual void ReplaceInstance(object instance);
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
}
internal interface Autofac.Core.IComponentLifetime {
    public abstract virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
internal interface Autofac.Core.IComponentRegistration {
    public Guid Id { get; }
    public IInstanceActivator Activator { get; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public IComponentRegistration Target { get; }
    public abstract virtual Guid get_Id();
    public abstract virtual IInstanceActivator get_Activator();
    public abstract virtual IComponentLifetime get_Lifetime();
    public abstract virtual InstanceSharing get_Sharing();
    public abstract virtual InstanceOwnership get_Ownership();
    public abstract virtual IEnumerable`1<Service> get_Services();
    public abstract virtual IDictionary`2<string, object> get_Metadata();
    public abstract virtual IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public abstract virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public abstract virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public abstract virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
}
internal interface Autofac.Core.IComponentRegistry {
    public IDictionary`2<string, object> Properties { get; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public abstract virtual bool IsRegistered(Service service);
    public abstract virtual void Register(IComponentRegistration registration);
    public abstract virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    public abstract virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public abstract virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public abstract virtual void AddRegistrationSource(IRegistrationSource source);
    public abstract virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public abstract virtual bool get_HasLocalComponents();
    [CompilerGeneratedAttribute]
public abstract virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
}
internal interface Autofac.Core.IDisposer {
    public abstract virtual void AddInstanceForDisposal(IDisposable instance);
}
internal interface Autofac.Core.IInstanceActivator {
    public Type LimitType { get; }
    public abstract virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    public abstract virtual Type get_LimitType();
}
internal interface Autofac.Core.IModule {
    public abstract virtual void Configure(IComponentRegistry componentRegistry);
}
internal enum Autofac.Core.InstanceOwnership : Enum {
    public int value__;
    public static InstanceOwnership ExternallyOwned;
    public static InstanceOwnership OwnedByLifetimeScope;
}
internal enum Autofac.Core.InstanceSharing : Enum {
    public int value__;
    public static InstanceSharing None;
    public static InstanceSharing Shared;
}
internal interface Autofac.Core.IPropertySelector {
    public abstract virtual bool InjectProperty(PropertyInfo propertyInfo, object instance);
}
internal interface Autofac.Core.IRegistrationSource {
    public bool IsAdapterForIndividualComponents { get; }
    public abstract virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public abstract virtual bool get_IsAdapterForIndividualComponents();
}
internal interface Autofac.Core.IServiceWithType {
    public Type ServiceType { get; }
    public abstract virtual Type get_ServiceType();
    public abstract virtual Service ChangeType(Type newType);
}
internal interface Autofac.Core.ISharingLifetimeScope {
    public ISharingLifetimeScope RootLifetimeScope { get; }
    public ISharingLifetimeScope ParentLifetimeScope { get; }
    public abstract virtual ISharingLifetimeScope get_RootLifetimeScope();
    public abstract virtual ISharingLifetimeScope get_ParentLifetimeScope();
    public abstract virtual object GetOrCreateAndShare(Guid id, Func`1<object> creator);
}
internal class Autofac.Core.KeyedService : Service {
    [CompilerGeneratedAttribute]
private object <ServiceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public object ServiceKey { get; }
    public Type ServiceType { get; }
    public string Description { get; }
    public KeyedService(object serviceKey, Type serviceType);
    [CompilerGeneratedAttribute]
public object get_ServiceKey();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    public virtual string get_Description();
    public sealed virtual bool Equals(KeyedService other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Service ChangeType(Type newType);
}
internal class Autofac.Core.Lifetime.CurrentScopeLifetime : object {
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
[DebuggerDisplayAttribute("Tag = {Tag}, IsDisposed = {IsDisposed}")]
internal class Autofac.Core.Lifetime.LifetimeScope : Disposable {
    private object _synchRoot;
    private IDictionary`2<Guid, object> _sharedInstances;
    private ISharingLifetimeScope _parent;
    [CompilerGeneratedAttribute]
private static Guid <SelfRegistrationId>k__BackingField;
    private static Action`1<ContainerBuilder> NoConfiguration;
    public static object RootTag;
    [CompilerGeneratedAttribute]
private ISharingLifetimeScope <RootLifetimeScope>k__BackingField;
    [CompilerGeneratedAttribute]
private IDisposer <Disposer>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<LifetimeScopeBeginningEventArgs> ChildLifetimeScopeBeginning;
    [CompilerGeneratedAttribute]
private EventHandler`1<LifetimeScopeEndingEventArgs> CurrentScopeEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<ResolveOperationBeginningEventArgs> ResolveOperationBeginning;
    internal static Guid SelfRegistrationId { get; }
    public ISharingLifetimeScope ParentLifetimeScope { get; }
    public ISharingLifetimeScope RootLifetimeScope { get; }
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public IComponentRegistry ComponentRegistry { get; }
    protected LifetimeScope(IComponentRegistry componentRegistry, LifetimeScope parent, object tag);
    public LifetimeScope(IComponentRegistry componentRegistry, object tag);
    public LifetimeScope(IComponentRegistry componentRegistry);
    private static LifetimeScope();
    [CompilerGeneratedAttribute]
internal static Guid get_SelfRegistrationId();
    private static object MakeAnonymousTag();
    public sealed virtual ILifetimeScope BeginLifetimeScope();
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag);
    private void RaiseBeginning(ILifetimeScope scope);
    public sealed virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    private ScopeRestrictedRegistry CreateScopeRestrictedRegistry(object tag, Action`1<ContainerBuilder> configurationAction);
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    public sealed virtual ISharingLifetimeScope get_ParentLifetimeScope();
    [CompilerGeneratedAttribute]
public sealed virtual ISharingLifetimeScope get_RootLifetimeScope();
    public sealed virtual object GetOrCreateAndShare(Guid id, Func`1<object> creator);
    [CompilerGeneratedAttribute]
public sealed virtual IDisposer get_Disposer();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistry get_ComponentRegistry();
    protected virtual void Dispose(bool disposing);
    private void CheckNotDisposed();
    public sealed virtual object GetService(Type serviceType);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
}
internal class Autofac.Core.Lifetime.LifetimeScopeBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ILifetimeScope <LifetimeScope>k__BackingField;
    public ILifetimeScope LifetimeScope { get; }
    public LifetimeScopeBeginningEventArgs(ILifetimeScope lifetimeScope);
    [CompilerGeneratedAttribute]
public ILifetimeScope get_LifetimeScope();
}
internal class Autofac.Core.Lifetime.LifetimeScopeEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ILifetimeScope <LifetimeScope>k__BackingField;
    public ILifetimeScope LifetimeScope { get; }
    public LifetimeScopeEndingEventArgs(ILifetimeScope lifetimeScope);
    [CompilerGeneratedAttribute]
public ILifetimeScope get_LifetimeScope();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Lifetime.LifetimeScopeResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ScopeIsDisposed { get; }
    internal static string SelfConstructingDependencyDetected { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ScopeIsDisposed();
    internal static string get_SelfConstructingDependencyDetected();
}
internal class Autofac.Core.Lifetime.MatchingScopeLifetime : object {
    private Object[] _tagsToMatch;
    public MatchingScopeLifetime(Object[] lifetimeScopeTagsToMatch);
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Lifetime.MatchingScopeLifetimeResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MatchingScopeNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MatchingScopeNotFound();
}
internal static class Autofac.Core.Lifetime.MatchingScopeLifetimeTags : object {
    public static object RequestLifetimeScopeTag;
    private static MatchingScopeLifetimeTags();
}
internal class Autofac.Core.Lifetime.RootScopeLifetime : object {
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
internal class Autofac.Core.NamedPropertyParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public NamedPropertyParameter(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
internal abstract class Autofac.Core.Parameter : object {
    public abstract virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
internal class Autofac.Core.PreparingEventArgs : EventArgs {
    private IEnumerable`1<Parameter> _parameters;
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; public set; }
    public PreparingEventArgs(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public IComponentRegistration get_Component();
    public IEnumerable`1<Parameter> get_Parameters();
    public void set_Parameters(IEnumerable`1<Parameter> value);
}
internal class Autofac.Core.Registration.AdaptationSandbox : object {
    private IEnumerable`1<IRegistrationSource> _adapters;
    private IComponentRegistration _registration;
    private IEnumerable`1<Service> _adapterServices;
    private IDictionary`2<Service, IList`1<IRegistrationSource>> _adaptersToQuery;
    private IList`1<IComponentRegistration> _registrations;
    public AdaptationSandbox(IEnumerable`1<IRegistrationSource> adapters, IComponentRegistration registration, IEnumerable`1<Service> adapterServices);
    public IEnumerable`1<IComponentRegistration> GetAdapters();
    private IEnumerable`1<IComponentRegistration> GetAndInitialiseRegistrationsFor(Service service);
    [CompilerGeneratedAttribute]
private bool <GetAdapters>b__6_0(IComponentRegistration r);
}
internal class Autofac.Core.Registration.ComponentNotRegisteredException : DependencyResolutionException {
    public ComponentNotRegisteredException(Service service);
    public ComponentNotRegisteredException(Service service, Exception innerException);
    private static string FormatMessage(Service service);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ComponentNotRegisteredExceptionResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Message { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Message();
}
internal class Autofac.Core.Registration.ComponentRegistration : Disposable {
    private IComponentRegistration _target;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstanceActivator <Activator>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentLifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceSharing <Sharing>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceOwnership <Ownership>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Service> <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PreparingEventArgs> Preparing;
    [CompilerGeneratedAttribute]
private EventHandler`1<ActivatingEventArgs`1<object>> Activating;
    [CompilerGeneratedAttribute]
private EventHandler`1<ActivatedEventArgs`1<object>> Activated;
    public IComponentRegistration Target { get; }
    public Guid Id { get; }
    public IInstanceActivator Activator { get; public set; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public ComponentRegistration(Guid id, IInstanceActivator activator, IComponentLifetime lifetime, InstanceSharing sharing, InstanceOwnership ownership, IEnumerable`1<Service> services, IDictionary`2<string, object> metadata);
    public ComponentRegistration(Guid id, IInstanceActivator activator, IComponentLifetime lifetime, InstanceSharing sharing, InstanceOwnership ownership, IEnumerable`1<Service> services, IDictionary`2<string, object> metadata, IComponentRegistration target);
    public sealed virtual IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual IInstanceActivator get_Activator();
    [CompilerGeneratedAttribute]
public void set_Activator(IInstanceActivator value);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentLifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public sealed virtual InstanceSharing get_Sharing();
    [CompilerGeneratedAttribute]
public sealed virtual InstanceOwnership get_Ownership();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Service> get_Services();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Autofac.Core.Registration.ComponentRegistrationExtensions : object {
    [ExtensionAttribute]
public static bool IsAdapting(IComponentRegistration componentRegistration);
}
internal class Autofac.Core.Registration.ComponentRegistrationLifetimeDecorator : Disposable {
    private IComponentRegistration _inner;
    [CompilerGeneratedAttribute]
private IComponentLifetime <Lifetime>k__BackingField;
    public Guid Id { get; }
    public IInstanceActivator Activator { get; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public IComponentRegistration Target { get; }
    public ComponentRegistrationLifetimeDecorator(IComponentRegistration inner, IComponentLifetime lifetime);
    public sealed virtual Guid get_Id();
    public sealed virtual IInstanceActivator get_Activator();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentLifetime get_Lifetime();
    public sealed virtual InstanceSharing get_Sharing();
    public sealed virtual InstanceOwnership get_Ownership();
    public sealed virtual IEnumerable`1<Service> get_Services();
    public sealed virtual IDictionary`2<string, object> get_Metadata();
    public sealed virtual IComponentRegistration get_Target();
    public sealed virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    public sealed virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    public sealed virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ComponentRegistrationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ToStringFormat { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ToStringFormat();
}
internal class Autofac.Core.Registration.ComponentRegistry : Disposable {
    private object _synchRoot;
    private IList`1<IRegistrationSource> _dynamicRegistrationSources;
    private ICollection`1<IComponentRegistration> _registrations;
    private IDictionary`2<Service, ServiceRegistrationInfo> _serviceInfo;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ComponentRegisteredEventArgs> Registered;
    [CompilerGeneratedAttribute]
private EventHandler`1<RegistrationSourceAddedEventArgs> RegistrationSourceAdded;
    public IDictionary`2<string, object> Properties { get; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    internal ComponentRegistry(IDictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Properties();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public sealed virtual bool IsRegistered(Service service);
    public sealed virtual void Register(IComponentRegistration registration);
    public virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    private void UpdateInitialisedAdapters(IComponentRegistration registration);
    private void AddRegistration(IComponentRegistration registration, bool preserveDefaults, bool originatedFromSource);
    public sealed virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void AddRegistrationSource(IRegistrationSource source);
    public sealed virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public sealed virtual bool get_HasLocalComponents();
    [CompilerGeneratedAttribute]
public sealed virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    private ServiceRegistrationInfo GetInitializedServiceInfo(Service service);
    private ServiceRegistrationInfo GetServiceInfo(Service service);
}
internal class Autofac.Core.Registration.CopyOnWriteRegistry : object {
    private IComponentRegistry _readRegistry;
    private Func`1<IComponentRegistry> _createWriteRegistry;
    private IComponentRegistry _writeRegistry;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    private IComponentRegistry Registry { get; }
    private IComponentRegistry WriteRegistry { get; }
    public IDictionary`2<string, object> Properties { get; public set; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    public CopyOnWriteRegistry(IComponentRegistry readRegistry, Func`1<IComponentRegistry> createWriteRegistry);
    private IComponentRegistry get_Registry();
    private IComponentRegistry get_WriteRegistry();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
    public sealed virtual void Dispose();
    public sealed virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public sealed virtual bool IsRegistered(Service service);
    public sealed virtual void Register(IComponentRegistration registration);
    public sealed virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    public sealed virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    public sealed virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void AddRegistrationSource(IRegistrationSource source);
    public sealed virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public sealed virtual bool get_HasLocalComponents();
    public sealed virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    public sealed virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
}
internal class Autofac.Core.Registration.ExternalRegistrySource : object {
    private IComponentRegistry _registry;
    public bool IsAdapterForIndividualComponents { get; }
    public ExternalRegistrySource(IComponentRegistry registry);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
}
internal interface Autofac.Core.Registration.IModuleRegistrar {
    public abstract virtual IModuleRegistrar RegisterModule(IModule module);
}
internal class Autofac.Core.Registration.ModuleRegistrar : object {
    private ContainerBuilder _builder;
    public ModuleRegistrar(ContainerBuilder builder);
    public sealed virtual IModuleRegistrar RegisterModule(IModule module);
}
internal class Autofac.Core.Registration.ScopeRestrictedRegistry : ComponentRegistry {
    private IComponentLifetime _restrictedRootScopeLifetime;
    internal ScopeRestrictedRegistry(object scopeTag, IDictionary`2<string, object> properties);
    public virtual void Register(IComponentRegistration registration, bool preserveDefaults);
}
internal class Autofac.Core.Registration.ServiceRegistrationInfo : object {
    private Service _service;
    private List`1<IComponentRegistration> _defaultImplementations;
    private List`1<IComponentRegistration> _sourceImplementations;
    private List`1<IComponentRegistration> _preserveDefaultImplementations;
    private IComponentRegistration _defaultImplementation;
    private Queue`1<IRegistrationSource> _sourcesToQuery;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public bool IsInitialized { get; private set; }
    public IEnumerable`1<IComponentRegistration> Implementations { get; }
    public bool IsRegistered { get; }
    private bool Any { get; }
    public bool IsInitializing { get; }
    public bool HasSourcesToQuery { get; }
    public ServiceRegistrationInfo(Service service);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public IEnumerable`1<IComponentRegistration> get_Implementations();
    private void RequiresInitialization();
    public bool get_IsRegistered();
    private bool get_Any();
    public void AddImplementation(IComponentRegistration registration, bool preserveDefaults, bool originatedFromSource);
    public bool TryGetRegistration(IComponentRegistration& registration);
    public void Include(IRegistrationSource source);
    public bool get_IsInitializing();
    public bool get_HasSourcesToQuery();
    public void BeginInitialization(IEnumerable`1<IRegistrationSource> sources);
    public void SkipSource(IRegistrationSource source);
    private void EnforceDuringInitialization();
    public IRegistrationSource DequeueNextSource();
    public void CompleteInitialization();
    public bool ShouldRecalculateAdaptersOn(IComponentRegistration registration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ServiceRegistrationInfoResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NotDuringInitialization { get; }
    internal static string NotInitialized { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NotDuringInitialization();
    internal static string get_NotInitialized();
}
internal class Autofac.Core.RegistrationSourceAddedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IRegistrationSource <RegistrationSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    public IRegistrationSource RegistrationSource { get; }
    public IComponentRegistry ComponentRegistry { get; }
    public RegistrationSourceAddedEventArgs(IComponentRegistry componentRegistry, IRegistrationSource registrationSource);
    [CompilerGeneratedAttribute]
public IRegistrationSource get_RegistrationSource();
    [CompilerGeneratedAttribute]
public IComponentRegistry get_ComponentRegistry();
}
internal class Autofac.Core.ResolvedParameter : Parameter {
    private Func`3<ParameterInfo, IComponentContext, bool> _predicate;
    private Func`3<ParameterInfo, IComponentContext, object> _valueAccessor;
    public ResolvedParameter(Func`3<ParameterInfo, IComponentContext, bool> predicate, Func`3<ParameterInfo, IComponentContext, object> valueAccessor);
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
    public static ResolvedParameter ForNamed(string serviceName);
    public static ResolvedParameter ForKeyed(object serviceKey);
}
internal class Autofac.Core.Resolving.CircularDependencyDetector : object {
    private static int MaxResolveDepth;
    private static string CreateDependencyGraphTo(IComponentRegistration registration, IEnumerable`1<InstanceLookup> activationStack);
    private static string Display(IComponentRegistration registration);
    public static void CheckForCircularDependency(IComponentRegistration registration, Stack`1<InstanceLookup> activationStack, int callDepth);
    private static bool IsCircularDependency(IComponentRegistration registration, IEnumerable`1<InstanceLookup> activationStack);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.CircularDependencyDetectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CircularDependency { get; }
    internal static string MaxDepthExceeded { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CircularDependency();
    internal static string get_MaxDepthExceeded();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.ComponentActivationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string ActivationAlreadyExecuted { get; }
    public static string ErrorDuringActivation { get; }
    public static string UnableToLocateLifetimeScope { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_ActivationAlreadyExecuted();
    public static string get_ErrorDuringActivation();
    public static string get_UnableToLocateLifetimeScope();
}
internal interface Autofac.Core.Resolving.IInstanceLookup {
    public IComponentRegistration ComponentRegistration { get; }
    public ILifetimeScope ActivationScope { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public abstract virtual IComponentRegistration get_ComponentRegistration();
    public abstract virtual ILifetimeScope get_ActivationScope();
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public abstract virtual void add_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
}
internal class Autofac.Core.Resolving.InstanceLookup : object {
    private IResolveOperation _context;
    private ISharingLifetimeScope _activationScope;
    private object _newInstance;
    private bool _executed;
    [CompilerGeneratedAttribute]
private IComponentRegistration <ComponentRegistration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupEndingEventArgs> InstanceLookupEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupCompletionBeginningEventArgs> CompletionBeginning;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupCompletionEndingEventArgs> CompletionEnding;
    private bool NewInstanceActivated { get; }
    public IComponentRegistry ComponentRegistry { get; }
    public IComponentRegistration ComponentRegistration { get; }
    public ILifetimeScope ActivationScope { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public InstanceLookup(IComponentRegistration registration, IResolveOperation context, ISharingLifetimeScope mostNestedVisibleScope, IEnumerable`1<Parameter> parameters);
    public object Execute();
    private bool get_NewInstanceActivated();
    private object Activate(IEnumerable`1<Parameter> parameters);
    public void Complete();
    public sealed virtual IComponentRegistry get_ComponentRegistry();
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_ComponentRegistration();
    public sealed virtual ILifetimeScope get_ActivationScope();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void add_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
    [CompilerGeneratedAttribute]
private object <Execute>b__5_0();
}
internal class Autofac.Core.Resolving.InstanceLookupBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupBeginningEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
internal class Autofac.Core.Resolving.InstanceLookupCompletionBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupCompletionBeginningEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
internal class Autofac.Core.Resolving.InstanceLookupCompletionEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupCompletionEndingEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
internal class Autofac.Core.Resolving.InstanceLookupEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <NewInstanceActivated>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public bool NewInstanceActivated { get; }
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupEndingEventArgs(IInstanceLookup instanceLookup, bool newInstanceActivated);
    [CompilerGeneratedAttribute]
public bool get_NewInstanceActivated();
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
internal interface Autofac.Core.Resolving.IResolveOperation {
    public abstract virtual object GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
}
internal class Autofac.Core.Resolving.ResolveOperation : object {
    private Stack`1<InstanceLookup> _activationStack;
    private ICollection`1<InstanceLookup> _successfulActivations;
    private ISharingLifetimeScope _mostNestedLifetimeScope;
    private int _callDepth;
    private bool _ended;
    [CompilerGeneratedAttribute]
private EventHandler`1<ResolveOperationEndingEventArgs> CurrentOperationEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupBeginningEventArgs> InstanceLookupBeginning;
    public IComponentRegistry ComponentRegistry { get; }
    public ResolveOperation(ISharingLifetimeScope mostNestedLifetimeScope);
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    public object Execute(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    public sealed virtual object GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    private void CompleteActivations();
    private void ResetSuccessfulActivations();
    public sealed virtual IComponentRegistry get_ComponentRegistry();
    private void End(Exception exception);
}
internal class Autofac.Core.Resolving.ResolveOperationBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IResolveOperation <ResolveOperation>k__BackingField;
    public IResolveOperation ResolveOperation { get; }
    public ResolveOperationBeginningEventArgs(IResolveOperation resolveOperation);
    [CompilerGeneratedAttribute]
public IResolveOperation get_ResolveOperation();
}
internal class Autofac.Core.Resolving.ResolveOperationEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveOperation <ResolveOperation>k__BackingField;
    public Exception Exception { get; }
    public IResolveOperation ResolveOperation { get; }
    public ResolveOperationEndingEventArgs(IResolveOperation resolveOperation, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IResolveOperation get_ResolveOperation();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.ResolveOperationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExceptionDuringResolve { get; }
    internal static string MaxDepthExceeded { get; }
    internal static string TemporaryContextDisposed { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExceptionDuringResolve();
    internal static string get_MaxDepthExceeded();
    internal static string get_TemporaryContextDisposed();
}
internal abstract class Autofac.Core.Service : object {
    public string Description { get; }
    public abstract virtual string get_Description();
    public virtual string ToString();
    public static bool op_Equality(Service left, Service right);
    public static bool op_Inequality(Service left, Service right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.ServiceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MustOverrideEquals { get; }
    internal static string MustOverrideGetHashCode { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MustOverrideEquals();
    internal static string get_MustOverrideGetHashCode();
}
internal class Autofac.Core.TypedService : Service {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public Type ServiceType { get; }
    public string Description { get; }
    public TypedService(Type serviceType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    public virtual string get_Description();
    public sealed virtual bool Equals(TypedService other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Service ChangeType(Type newType);
}
internal class Autofac.Core.UniqueService : Service {
    private Guid _id;
    public string Description { get; }
    public UniqueService(Guid id);
    public virtual string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Autofac.Features.AttributeFilters.KeyFilterAttribute : ParameterFilterAttribute {
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public object Key { get; }
    public KeyFilterAttribute(object key);
    [CompilerGeneratedAttribute]
public object get_Key();
    public virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
}
internal class Autofac.Features.AttributeFilters.MetadataFilterAttribute : ParameterFilterAttribute {
    private static MethodInfo FilterOneMethod;
    private static MethodInfo FilterAllMethod;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Key { get; }
    public object Value { get; private set; }
    public MetadataFilterAttribute(string key, object value);
    private static MetadataFilterAttribute();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
    private static Type GetElementType(Type type);
    private static T FilterOne(IComponentContext context, string metadataKey, object metadataValue);
    private static IEnumerable`1<T> FilterAll(IComponentContext context, string metadataKey, object metadataValue);
}
[AttributeUsageAttribute("2048")]
internal abstract class Autofac.Features.AttributeFilters.ParameterFilterAttribute : Attribute {
    public abstract virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
}
[ExtensionAttribute]
internal static class Autofac.Features.AttributeFilters.RegistrationExtensions : object {
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TRegistrationStyle> WithAttributeFiltering(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TRegistrationStyle> builder);
}
internal class Autofac.Features.Collections.CollectionRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Collections.CollectionRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CollectionRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CollectionRegistrationSourceDescription();
}
internal class Autofac.Features.GeneratedFactories.FactoryGenerator : object {
    private Func`3<IComponentContext, IEnumerable`1<Parameter>, Delegate> _generator;
    public FactoryGenerator(Type delegateType, Service service, ParameterMapping parameterMapping);
    public FactoryGenerator(Type delegateType, IComponentRegistration productRegistration, ParameterMapping parameterMapping);
    private static ParameterMapping GetParameterMapping(Type delegateType, ParameterMapping configuredParameterMapping);
    private static bool DelegateTypeIsFunc(Type delegateType);
    private static Func`3<IComponentContext, IEnumerable`1<Parameter>, Delegate> CreateGenerator(Func`3<Expression, Expression[], Expression> makeResolveCall, Type delegateType, ParameterMapping pm);
    private static Expression[] MapParameters(IEnumerable`1<ParameterExpression> creatorParams, ParameterMapping pm);
    public Delegate GenerateFactory(IComponentContext context, IEnumerable`1<Parameter> parameters);
    public TDelegate GenerateFactory(IComponentContext context, IEnumerable`1<Parameter> parameters);
}
internal class Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData : object {
    private Type _delegateType;
    private Service _productService;
    [CompilerGeneratedAttribute]
private ParameterMapping <ParameterMapping>k__BackingField;
    public ParameterMapping ParameterMapping { get; public set; }
    public IInstanceActivator Activator { get; }
    public GeneratedFactoryActivatorData(Type delegateType, Service productService);
    [CompilerGeneratedAttribute]
public ParameterMapping get_ParameterMapping();
    [CompilerGeneratedAttribute]
public void set_ParameterMapping(ParameterMapping value);
    public sealed virtual IInstanceActivator get_Activator();
}
internal static class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationExtensions : object {
    internal static IRegistrationBuilder`3<TLimit, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType, Service service);
}
internal class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DuplicateTypesInTypeMappedFuncParameterList { get; }
    internal static string GeneratedFactoryRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DuplicateTypesInTypeMappedFuncParameterList();
    internal static string get_GeneratedFactoryRegistrationSourceDescription();
}
internal enum Autofac.Features.GeneratedFactories.ParameterMapping : Enum {
    public int value__;
    public static ParameterMapping Adaptive;
    public static ParameterMapping ByName;
    public static ParameterMapping ByType;
    public static ParameterMapping ByPosition;
}
[DefaultMemberAttribute("Item")]
internal interface Autofac.Features.Indexed.IIndex`2 {
    public TValue Item { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[DefaultMemberAttribute("Item")]
internal class Autofac.Features.Indexed.KeyedServiceIndex`2 : object {
    private IComponentContext _context;
    public TValue Item { get; }
    public KeyedServiceIndex`2(IComponentContext context);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private static KeyedService GetService(TKey key);
}
internal class Autofac.Features.LazyDependencies.LazyRegistrationSource : object {
    private static MethodInfo CreateLazyRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static LazyRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateLazyRegistration(Service providedService, IComponentRegistration valueRegistration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LazyDependencies.LazyRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string LazyRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_LazyRegistrationSourceDescription();
}
internal class Autofac.Features.LazyDependencies.LazyWithMetadataRegistrationSource : object {
    private static MethodInfo CreateLazyRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static LazyWithMetadataRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateLazyRegistration(Service providedService, IComponentRegistration valueRegistration);
    private static Type GetLazyType(IServiceWithType serviceWithType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LazyDependencies.LazyWithMetadataRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string LazyWithMetadataRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_LazyWithMetadataRegistrationSourceDescription();
}
internal class Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData : object {
    [CompilerGeneratedAttribute]
private Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> <Adapter>k__BackingField;
    [CompilerGeneratedAttribute]
private Service <FromService>k__BackingField;
    public Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> Adapter { get; }
    public Service FromService { get; }
    public LightweightAdapterActivatorData(Service fromService, Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> adapter);
    [CompilerGeneratedAttribute]
public Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> get_Adapter();
    [CompilerGeneratedAttribute]
public Service get_FromService();
}
internal static class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationExtensions : object {
    public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter);
    public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TService, TService> decorator, object fromKey, object toKey);
    private static Service ServiceWithKey(object key);
    private static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter, Service fromService, Service toService);
}
internal class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSource : object {
    private RegistrationData _registrationData;
    private LightweightAdapterActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public LightweightAdapterRegistrationSource(RegistrationData registrationData, LightweightAdapterActivatorData activatorData);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private IComponentRegistration <RegistrationsFor>b__3_0(IComponentRegistration r);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AdapterFromToDescription { get; }
    internal static string FromAndToMustDiffer { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AdapterFromToDescription();
    internal static string get_FromAndToMustDiffer();
}
internal class Autofac.Features.Metadata.Meta`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    public T Value { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public Meta`1(T value, IDictionary`2<string, object> metadata);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Metadata();
}
internal class Autofac.Features.Metadata.Meta`2 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TMetadata <Metadata>k__BackingField;
    public T Value { get; }
    public TMetadata Metadata { get; }
    public Meta`2(T value, TMetadata metadata);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public TMetadata get_Metadata();
}
internal static class Autofac.Features.Metadata.MetadataViewProvider : object {
    private static MethodInfo GetMetadataValueMethod;
    private static MetadataViewProvider();
    public static Func`2<IDictionary`2<string, object>, TMetadata> GetMetadataViewProvider();
    private static TValue GetMetadataValue(IDictionary`2<string, object> metadata, string name, DefaultValueAttribute defaultValue);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Metadata.MetadataViewProviderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidViewImplementation { get; }
    internal static string MissingMetadata { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidViewImplementation();
    internal static string get_MissingMetadata();
}
internal class Autofac.Features.Metadata.MetaRegistrationSource : object {
    private static MethodInfo CreateMetaRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static MetaRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateMetaRegistration(Service providedService, IComponentRegistration valueRegistration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Metadata.MetaRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MetaRegistrationSourceDescription { get; }
    internal static string StronglyTypedMetaRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MetaRegistrationSourceDescription();
    internal static string get_StronglyTypedMetaRegistrationSourceDescription();
}
internal class Autofac.Features.Metadata.StronglyTypedMetaRegistrationSource : object {
    private static MethodInfo CreateMetaRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static StronglyTypedMetaRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateMetaRegistration(Service providedService, IComponentRegistration valueRegistration);
}
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorData : ReflectionActivatorData {
    [CompilerGeneratedAttribute]
private IServiceWithType <FromService>k__BackingField;
    public IServiceWithType FromService { get; }
    public OpenGenericDecoratorActivatorData(Type implementer, IServiceWithType fromService);
    [CompilerGeneratedAttribute]
public IServiceWithType get_FromService();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorDataResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DecoratedServiceIsNotOpenGeneric { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DecoratedServiceIsNotOpenGeneric();
}
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorRegistrationSource : object {
    private RegistrationData _registrationData;
    private OpenGenericDecoratorActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public OpenGenericDecoratorRegistrationSource(RegistrationData registrationData, OpenGenericDecoratorActivatorData activatorData);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    private static IEnumerable`1<Parameter> AddDecoratedComponentParameter(Type decoratedParameterType, IComponentRegistration decoratedComponent, IEnumerable`1<Parameter> configuredParameters);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FromAndToMustDiffer { get; }
    internal static string OpenGenericDecoratorRegistrationSourceImplFromTo { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FromAndToMustDiffer();
    internal static string get_OpenGenericDecoratorRegistrationSourceImplFromTo();
}
internal static class Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensions : object {
    public static IRegistrationBuilder`3<object, ReflectionActivatorData, DynamicRegistrationStyle> RegisterGeneric(ContainerBuilder builder, Type implementor);
    public static IRegistrationBuilder`3<object, OpenGenericDecoratorActivatorData, DynamicRegistrationStyle> RegisterGenericDecorator(ContainerBuilder builder, Type decoratorType, Type decoratedServiceType, object fromKey, object toKey);
    private static IServiceWithType GetServiceWithKey(Type serviceType, object key);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ImplementorMustBeOpenGenericType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ImplementorMustBeOpenGenericType();
}
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationSource : object {
    private RegistrationData _registrationData;
    private ReflectionActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public OpenGenericRegistrationSource(RegistrationData registrationData, ReflectionActivatorData activatorData);
    [IteratorStateMachineAttribute("Autofac.Features.OpenGenerics.OpenGenericRegistrationSource/<RegistrationsFor>d__3")]
public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string OpenGenericRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_OpenGenericRegistrationSourceDescription();
}
internal static class Autofac.Features.OpenGenerics.OpenGenericServiceBinder : object {
    public static bool TryBindServiceType(Service service, IEnumerable`1<Service> configuredOpenGenericServices, Type openGenericImplementationType, Type& constructedImplementationType, IEnumerable`1& constructedServices);
    private static Type[] TryMapImplementationGenericArguments(Type implementationType, Type serviceType, Type serviceTypeDefinition, Type[] serviceGenericArguments);
    private static Type GetInterface(Type implementationType, Type serviceType);
    private static Type TryFindServiceArgumentForImplementationArgumentDefinition(Type implementationGenericArgumentDefinition, IEnumerable`1<KeyValuePair`2<Type, Type>> serviceArgumentDefinitionToArgument);
    public static void EnforceBindable(Type implementationType, IEnumerable`1<Service> services);
    private static bool IsCompatibleGenericClassDefinition(Type implementor, Type serviceType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericServiceBinderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ImplementorDoesntImplementService { get; }
    internal static string ImplementorMustBeOpenGenericTypeDefinition { get; }
    internal static string InterfaceIsNotImplemented { get; }
    internal static string ServiceTypeMustBeOpenGenericTypeDefinition { get; }
    internal static string TypesAreNotConvertible { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ImplementorDoesntImplementService();
    internal static string get_ImplementorMustBeOpenGenericTypeDefinition();
    internal static string get_InterfaceIsNotImplemented();
    internal static string get_ServiceTypeMustBeOpenGenericTypeDefinition();
    internal static string get_TypesAreNotConvertible();
}
internal class Autofac.Features.OwnedInstances.Owned`1 : Disposable {
    private IDisposable _lifetime;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public Owned`1(T value, IDisposable lifetime);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    protected virtual void Dispose(bool disposing);
}
internal class Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string OwnedInstanceRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_OwnedInstanceRegistrationSourceDescription();
}
internal class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource : object {
    private Func`2<Type, bool> _predicate;
    [CompilerGeneratedAttribute]
private Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> <RegistrationConfiguration>k__BackingField;
    public bool IsAdapterForIndividualComponents { get; }
    public Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> RegistrationConfiguration { get; public set; }
    public AnyConcreteTypeNotAlreadyRegisteredSource(Func`2<Type, bool> predicate);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    [CompilerGeneratedAttribute]
public Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> get_RegistrationConfiguration();
    [CompilerGeneratedAttribute]
public void set_RegistrationConfiguration(Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> value);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSourceExtensions : object {
    [ExtensionAttribute]
public static AnyConcreteTypeNotAlreadyRegisteredSource WithRegistrationsAs(AnyConcreteTypeNotAlreadyRegisteredSource source, Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> configurationAction);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AnyConcreteTypeNotAlreadyRegisteredSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AnyConcreteTypeNotAlreadyRegisteredSourceDescription();
}
internal class Autofac.Features.Scanning.ScanningActivatorData : ReflectionActivatorData {
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<Type, bool>> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> <ConfigurationActions>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Action`1<IComponentRegistry>> <PostScanningCallbacks>k__BackingField;
    public ICollection`1<Func`2<Type, bool>> Filters { get; }
    public ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> ConfigurationActions { get; }
    public ICollection`1<Action`1<IComponentRegistry>> PostScanningCallbacks { get; }
    [CompilerGeneratedAttribute]
public ICollection`1<Func`2<Type, bool>> get_Filters();
    [CompilerGeneratedAttribute]
public ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> get_ConfigurationActions();
    [CompilerGeneratedAttribute]
public ICollection`1<Action`1<IComponentRegistry>> get_PostScanningCallbacks();
}
[ExtensionAttribute]
internal static class Autofac.Features.Scanning.ScanningRegistrationExtensions : object {
    public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterAssemblyTypes(ContainerBuilder builder, Assembly[] assemblies);
    public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterTypes(ContainerBuilder builder, Type[] types);
    private static void ScanAssemblies(IEnumerable`1<Assembly> assemblies, IComponentRegistry cr, IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> rb);
    private static void ScanTypes(IEnumerable`1<Type> types, IComponentRegistry cr, IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> rb);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, object serviceKey);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AssignableTo(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type type);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Service>> serviceMapping);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration);
}
internal class Autofac.Features.Variance.ContravariantRegistrationSource : object {
    private static string IsContravariantAdapter;
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    private static Type[] SubstituteArrayElementAt(Type[] array, Type newElement, int index);
    private static IEnumerable`1<Type> GetTypesAssignableFrom(Type type);
    [IteratorStateMachineAttribute("Autofac.Features.Variance.ContravariantRegistrationSource/<GetBagOfTypesAssignableFrom>d__4")]
private static IEnumerable`1<Type> GetBagOfTypesAssignableFrom(Type type);
    private static bool IsCompatibleInterfaceType(Type type, Int32& contravariantParameterIndex);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
}
internal interface Autofac.IComponentContext {
    public IComponentRegistry ComponentRegistry { get; }
    public abstract virtual IComponentRegistry get_ComponentRegistry();
    public abstract virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
}
internal interface Autofac.IContainer {
}
internal interface Autofac.ILifetimeScope {
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public abstract virtual ILifetimeScope BeginLifetimeScope();
    public abstract virtual ILifetimeScope BeginLifetimeScope(object tag);
    public abstract virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public abstract virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    public abstract virtual IDisposer get_Disposer();
    public abstract virtual object get_Tag();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
}
internal interface Autofac.IStartable {
    public abstract virtual void Start();
}
internal abstract class Autofac.Module : object {
    protected Assembly ThisAssembly { get; }
    public sealed virtual void Configure(IComponentRegistry componentRegistry);
    protected virtual void Load(ContainerBuilder builder);
    protected virtual void AttachToComponentRegistration(IComponentRegistry componentRegistry, IComponentRegistration registration);
    protected virtual void AttachToRegistrationSource(IComponentRegistry componentRegistry, IRegistrationSource registrationSource);
    private void AttachToRegistrations(IComponentRegistry componentRegistry);
    private void AttachToSources(IComponentRegistry componentRegistry);
    protected virtual Assembly get_ThisAssembly();
    [CompilerGeneratedAttribute]
private void <AttachToRegistrations>b__4_0(object sender, ComponentRegisteredEventArgs e);
    [CompilerGeneratedAttribute]
private void <AttachToSources>b__5_0(object sender, RegistrationSourceAddedEventArgs e);
}
[ExtensionAttribute]
internal static class Autofac.ModuleRegistrationExtensions : object {
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Type moduleType, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Type moduleType, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(ContainerBuilder builder);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(IModuleRegistrar registrar);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(ContainerBuilder builder, IModule module);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.ModuleResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string ThisAssemblyUnavailable { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_ThisAssemblyUnavailable();
}
internal class Autofac.NamedParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public NamedParameter(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[ExtensionAttribute]
internal static class Autofac.ParameterExtensions : object {
    [ExtensionAttribute]
public static T Named(IEnumerable`1<Parameter> parameters, string name);
    [ExtensionAttribute]
public static T Positional(IEnumerable`1<Parameter> parameters, int position);
    [ExtensionAttribute]
public static T TypedAs(IEnumerable`1<Parameter> parameters);
    private static TValue ConstantValue(IEnumerable`1<Parameter> parameters, Func`2<TParameter, bool> predicate);
}
internal class Autofac.PositionalParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; private set; }
    public PositionalParameter(int position, object value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
}
[FlagsAttribute]
internal enum Autofac.PropertyWiringOptions : Enum {
    public int value__;
    public static PropertyWiringOptions None;
    public static PropertyWiringOptions AllowCircularDependencies;
    public static PropertyWiringOptions PreserveSetValues;
}
[ExtensionAttribute]
internal static class Autofac.RegistrationExtensions : object {
    [ExtensionAttribute]
public static void RegisterComponent(ContainerBuilder builder, IComponentRegistration registration);
    [ExtensionAttribute]
public static void RegisterSource(ContainerBuilder builder, IRegistrationSource registrationSource);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> RegisterInstance(ContainerBuilder builder, T instance);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TImplementer, ConcreteReflectionActivatorData, SingleRegistrationStyle> RegisterType(ContainerBuilder builder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle> RegisterType(ContainerBuilder builder, Type implementationType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> Register(ContainerBuilder builder, Func`2<IComponentContext, T> delegate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> Register(ContainerBuilder builder, Func`3<IComponentContext, IEnumerable`1<Parameter>, T> delegate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ReflectionActivatorData, DynamicRegistrationStyle> RegisterGeneric(ContainerBuilder builder, Type implementer);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterAssemblyTypes(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterTypes(ContainerBuilder builder, Type[] types);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Where(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, bool> predicate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Service>> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, Service> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, Type> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Type>> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> WithMetadata(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<KeyValuePair`2<string, object>>> metadataMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> WithMetadataFrom(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> WithMetadata(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, string metadataKey, Func`2<Type, object> metadataValueMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Named(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Func`2<Type, string> serviceNameMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Named(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, string> serviceNameMapping, Type serviceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Keyed(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Keyed(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, object> serviceKeyMapping, Type serviceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> registration);
    private static Type[] GetImplementedInterfaces(Type type);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> FindConstructorsWith(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IConstructorFinder constructorFinder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> FindConstructorsWith(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Func`2<Type, ConstructorInfo[]> finder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration, PropertyWiringOptions wiringFlags);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> PropertiesAutowired(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Func`3<PropertyInfo, object, bool> propertySelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Type[] signature);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IConstructorSelector constructorSelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Expression`1<Func`1<TLimit>> constructorSelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, string parameterName, object parameterValue);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Parameter parameter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Func`3<ParameterInfo, IComponentContext, bool> parameterSelector, Func`3<ParameterInfo, IComponentContext, object> valueProvider);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameters(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperty(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, string propertyName, object propertyValue);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperty(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Parameter property);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperties(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IEnumerable`1<Parameter> properties);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> Targeting(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, IComponentRegistration target);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> OnRegistered(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, Action`1<ComponentRegisteredEventArgs> handler);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> OnRegistered(IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> registration, Action`1<ComponentRegisteredEventArgs> handler);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, object serviceKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AssignableTo(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type type);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> AssignableTo(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Except(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Except(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Action`1<IRegistrationBuilder`3<T, ConcreteReflectionActivatorData, SingleRegistrationStyle>> customizedRegistration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> InNamespaceOf(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> InNamespace(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, string ns);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`3<IComponentContext, TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`2<TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, OpenGenericDecoratorActivatorData, DynamicRegistrationStyle> RegisterGenericDecorator(ContainerBuilder builder, Type decoratorType, Type decoratedServiceType, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`3<IComponentContext, TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`2<TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnRelease(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration, Action`1<TLimit> releaseAction);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> AutoActivate(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> InstancePerRequest(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Object[] lifetimeScopeTags);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> OnlyIf(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Predicate`1<IComponentRegistry> predicate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> IfNotRegistered(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Type serviceType);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.RegistrationExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string InstanceRegistrationsAreSingleInstanceOnly { get; }
    public static string MetadataAttributeNotFound { get; }
    public static string MultipleMetadataAttributesSameType { get; }
    public static string NoMatchingConstructorExists { get; }
    public static string OnlyIfRequiresCallbackContainer { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_InstanceRegistrationsAreSingleInstanceOnly();
    public static string get_MetadataAttributeNotFound();
    public static string get_MultipleMetadataAttributesSameType();
    public static string get_NoMatchingConstructorExists();
    public static string get_OnlyIfRequiresCallbackContainer();
}
[ExtensionAttribute]
internal static class Autofac.ResolutionExtensions : object {
    public static string PropertyInjectedInstanceTypeNamedParameter;
    private static IEnumerable`1<Parameter> NoParameters;
    private static ResolutionExtensions();
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, Parameter[] parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector, Parameter[] parameters);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance, Parameter[] parameters);
    [ExtensionAttribute]
public static bool IsRegistered(IComponentContext context);
    [ExtensionAttribute]
public static bool IsRegistered(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static bool IsRegisteredService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static bool IsRegisteredWithKey(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static bool IsRegisteredWithKey(IComponentContext context, object serviceKey, Type serviceType);
    [ExtensionAttribute]
public static bool IsRegisteredWithName(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static bool IsRegisteredWithName(IComponentContext context, string serviceName, Type serviceType);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context, Parameter[] parameters);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service, Parameter[] parameters);
    [ExtensionAttribute]
public static bool TryResolve(IComponentContext context, T& instance);
    [ExtensionAttribute]
public static bool TryResolve(IComponentContext context, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveNamed(IComponentContext context, string serviceName, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveService(IComponentContext context, Service service, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters, Object& instance);
}
internal class Autofac.TypedParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; private set; }
    public TypedParameter(Type type, object value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    public static TypedParameter From(T value);
}
[ExtensionAttribute]
internal static class Autofac.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsInNamespace(Type this, string namespace);
    [ExtensionAttribute]
public static bool IsInNamespaceOf(Type this);
    [ExtensionAttribute]
public static bool IsClosedTypeOf(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type this);
    [ExtensionAttribute]
public static ConstructorInfo GetMatchingConstructor(Type type, Type[] constructorParameterTypes);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.TypeExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string NotOpenGenericType { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_NotOpenGenericType();
}
[ExtensionAttribute]
internal static class Autofac.Util.AssemblyExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetLoadableTypes(Assembly assembly);
}
internal class Autofac.Util.Disposable : object {
    private static int DisposedFlag;
    private int _isDisposed;
    protected bool IsDisposed { get; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected bool get_IsDisposed();
}
internal static class Autofac.Util.Enforce : object {
    public static IEnumerable`1<T> ArgumentElementNotNull(IEnumerable`1<T> value, string name);
    public static T NotNull(T value);
    public static string ArgumentNotNullOrEmpty(string value, string description);
    public static void ArgumentTypeIsFunction(Type delegateType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Util.EnforceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotBeEmpty { get; }
    internal static string CannotBeNull { get; }
    internal static string DelegateReturnsVoid { get; }
    internal static string ElementCannotBeNull { get; }
    internal static string NotDelegate { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotBeEmpty();
    internal static string get_CannotBeNull();
    internal static string get_DelegateReturnsVoid();
    internal static string get_ElementCannotBeNull();
    internal static string get_NotDelegate();
}
[DefaultMemberAttribute("Item")]
internal class Autofac.Util.FallbackDictionary`2 : object {
    private IDictionary`2<TKey, TValue> _localValues;
    [CompilerGeneratedAttribute]
private IDictionary`2<TKey, TValue> <Parent>k__BackingField;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public IDictionary`2<TKey, TValue> Parent { get; private set; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public FallbackDictionary`2(IDictionary`2<TKey, TValue> parent);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    [CompilerGeneratedAttribute]
public IDictionary`2<TKey, TValue> get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(IDictionary`2<TKey, TValue> value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    [IteratorStateMachineAttribute("Autofac.Util.FallbackDictionary`2/<GetEnumerator>d__24")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IEnumerable`1<TKey> OrderedKeys();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Util.FallbackDictionaryResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string DuplicateItem { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_DuplicateItem();
}
[ExtensionAttribute]
internal static class Autofac.Util.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool TryGetDeclaringProperty(ParameterInfo pi, PropertyInfo& prop);
    public static PropertyInfo GetProperty(Expression`1<Func`2<TDeclaring, TProperty>> propertyAccessor);
    public static MethodInfo GetMethod(Expression`1<Action`1<TDeclaring>> methodCallExpression);
    public static ConstructorInfo GetConstructor(Expression`1<Func`1<TDeclaring>> constructorCallExpression);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Util.ReflectionExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExpressionNotConstructorCall { get; }
    internal static string ExpressionNotMethodCall { get; }
    internal static string ExpressionNotPropertyAccessor { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExpressionNotConstructorCall();
    internal static string get_ExpressionNotMethodCall();
    internal static string get_ExpressionNotPropertyAccessor();
}
internal class Autofac.Util.ReleaseAction`1 : Disposable {
    private Action`1<TLimit> _action;
    private Func`1<TLimit> _factory;
    public ReleaseAction`1(Action`1<TLimit> action, Func`1<TLimit> factory);
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Autofac.Util.SequenceExtensions : object {
    [ExtensionAttribute]
public static string JoinWith(IEnumerable`1<string> elements, string separator);
    [IteratorStateMachineAttribute("Autofac.Util.SequenceExtensions/<Append>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Append(IEnumerable`1<T> sequence, T trailingItem);
    [IteratorStateMachineAttribute("Autofac.Util.SequenceExtensions/<Prepend>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Prepend(IEnumerable`1<T> sequence, T leadingItem);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
internal static class Autofac.Util.SequenceGenerator : object {
    private static long _lastSequence;
    internal static long GetNextUniqueSequence();
}
internal static class Autofac.Util.Traverse : object {
    [IteratorStateMachineAttribute("Autofac.Util.Traverse/<Across>d__0`1")]
public static IEnumerable`1<T> Across(T first, Func`2<T, T> next);
}
[ExtensionAttribute]
internal static class Autofac.Util.TypeExtensions : object {
    private static ConcurrentDictionary`2<Type, bool> IsGenericEnumerableInterfaceCache;
    private static ConcurrentDictionary`2<Type, bool> IsGenericListOrCollectionInterfaceTypeCache;
    private static ConcurrentDictionary`2<Tuple`2<Type, Type>, bool> IsGenericTypeDefinedByCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static Type FunctionReturnType(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetTypesThatClose(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsClosedTypeOf(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsCompatibleWithGenericParameterConstraints(Type genericTypeDefinition, Type[] parameters);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(Type type);
    [ExtensionAttribute]
public static bool IsDelegate(Type type);
    [ExtensionAttribute]
public static bool IsGenericEnumerableInterfaceType(Type type);
    [ExtensionAttribute]
public static bool IsGenericListOrCollectionInterfaceType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinedBy(Type this, Type openGeneric);
    private static IEnumerable`1<Type> FindAssignableTypesThatClose(Type candidateType, Type openGenericServiceType);
    private static Type SubstituteGenericParameterConstraint(Type[] parameters, Type constraint);
    private static bool ParameterCompatibleWithTypeConstraint(Type parameter, Type constraint);
    private static bool ParameterEqualsConstraint(Type parameter, Type constraint);
    private static IEnumerable`1<Type> TypesAssignableFrom(Type candidateType);
}
[AttributeUsageAttribute("2048")]
internal class Autofac.Util.ValidatedNotNullAttribute : Attribute {
}
internal class Dongle.Cryptography.Digest : object {
    public UInt32 A;
    public UInt32 B;
    public UInt32 C;
    public UInt32 D;
    public virtual string ToString();
}
public class Dongle.Cryptography.Md5 : object {
    protected static UInt32[] T;
    protected UInt32[] X;
    internal Digest DgFingerPrint;
    protected Byte[] ByteInput;
    [CompilerGeneratedAttribute]
private ValueChanging OnValueChanging;
    [CompilerGeneratedAttribute]
private ValueChanged OnValueChanged;
    public string Value { get; public set; }
    public Byte[] ValueAsByte { get; public set; }
    public string Hash { get; }
    public Byte[] HashAsByteArray { get; }
    private static Md5();
    [CompilerGeneratedAttribute]
public void add_OnValueChanging(ValueChanging value);
    [CompilerGeneratedAttribute]
public void remove_OnValueChanging(ValueChanging value);
    [CompilerGeneratedAttribute]
public void add_OnValueChanged(ValueChanged value);
    [CompilerGeneratedAttribute]
public void remove_OnValueChanged(ValueChanged value);
    public string get_Value();
    public void set_Value(string value);
    public Byte[] get_ValueAsByte();
    public void set_ValueAsByte(Byte[] value);
    public void SetValueFromStream(Stream stream);
    public string get_Hash();
    public Byte[] get_HashAsByteArray();
    private static Byte[] HexStringToByteArray(string hex);
    private static Byte[] ReadAllBytes(Stream stream);
    private static Byte[] ReadAllBytes(BinaryReader reader);
    internal Digest CalculateMd5Value();
    protected void TransF(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 k, ushort s, UInt32 i);
    protected void TransG(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 k, ushort s, UInt32 i);
    protected void TransH(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 k, ushort s, UInt32 i);
    protected void TransI(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 k, ushort s, UInt32 i);
    protected void PerformTransformation(UInt32& a, UInt32& b, UInt32& c, UInt32& d);
    protected Byte[] CreatePaddedBuffer();
    protected void CopyBlock(Byte[] msg, UInt32 block);
    [CompilerGeneratedAttribute]
internal static int <HexStringToByteArray>g__ToInt|23_0(char c, <>c__DisplayClass23_0& );
}
public class Dongle.Cryptography.Md5ChangedEventArgs : EventArgs {
    public Byte[] NewData;
    public string FingerPrint;
    public Md5ChangedEventArgs(IList`1<byte> data, string hashedValue);
    public Md5ChangedEventArgs(string data, string hashedValue);
}
public class Dongle.Cryptography.Md5ChangingEventArgs : EventArgs {
    public Byte[] NewData;
    public Md5ChangingEventArgs(IList`1<byte> data);
    public Md5ChangingEventArgs(string data);
}
internal class Dongle.Cryptography.Md5Helper : object {
    public static UInt32 RotateLeft(UInt32 uiNumber, ushort shift);
    public static UInt32 ReverseByte(UInt32 uiNumber);
}
internal enum Dongle.Cryptography.Md5InitializerConstant : Enum {
    public UInt32 value__;
    public static Md5InitializerConstant A;
    public static Md5InitializerConstant B;
    public static Md5InitializerConstant C;
    public static Md5InitializerConstant D;
}
internal static class FxResources.System.Buffers.SR : object {
}
internal static class FxResources.System.Diagnostics.DiagnosticSource.SR : object {
}
internal static class FxResources.System.Memory.SR : object {
}
internal static class FxResources.System.Runtime.InteropServices.RuntimeInformation.SR : object {
}
internal static class FxResources.System.Threading.Channels.SR : object {
}
internal static class FxResources.System.ValueTuple.SR : object {
}
internal static class Google.Protobuf.ByteArray : object {
    private static int CopyThreshold;
    internal static void Copy(Byte[] src, int srcOffset, Byte[] dst, int dstOffset, int count);
    internal static void Reverse(Byte[] bytes);
}
[DefaultMemberAttribute("Item")]
[SecuritySafeCriticalAttribute]
[DebuggerDisplayAttribute("Length = {Length}")]
[DebuggerTypeProxyAttribute("Google.Protobuf.ByteString/ByteStringDebugView")]
public class Google.Protobuf.ByteString : object {
    private static ByteString empty;
    private ReadOnlyMemory`1<byte> bytes;
    public static ByteString Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public ReadOnlySpan`1<byte> Span { get; }
    public ReadOnlyMemory`1<byte> Memory { get; }
    public byte Item { get; }
    private ByteString(ReadOnlyMemory`1<byte> bytes);
    private static ByteString();
    internal static ByteString AttachBytes(ReadOnlyMemory`1<byte> bytes);
    internal static ByteString AttachBytes(Byte[] bytes);
    public static ByteString get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public ReadOnlySpan`1<byte> get_Span();
    public ReadOnlyMemory`1<byte> get_Memory();
    public Byte[] ToByteArray();
    public string ToBase64();
    public static ByteString FromBase64(string bytes);
    public static ByteString FromStream(Stream stream);
    public static Task`1<ByteString> FromStreamAsync(Stream stream, CancellationToken cancellationToken);
    public static ByteString CopyFrom(Byte[] bytes);
    public static ByteString CopyFrom(Byte[] bytes, int offset, int count);
    public static ByteString CopyFrom(ReadOnlySpan`1<byte> bytes);
    public static ByteString CopyFrom(string text, Encoding encoding);
    public static ByteString CopyFromUtf8(string text);
    public byte get_Item(int index);
    public string ToString(Encoding encoding);
    public string ToStringUtf8();
    [SecuritySafeCriticalAttribute]
public sealed virtual IEnumerator`1<byte> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public CodedInputStream CreateCodedInput();
    public static bool op_Equality(ByteString lhs, ByteString rhs);
    public static bool op_Inequality(ByteString lhs, ByteString rhs);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public sealed virtual bool Equals(ByteString other);
    public void CopyTo(Byte[] array, int position);
    public void WriteTo(Stream outputStream);
}
internal static class Google.Protobuf.ByteStringAsync : object {
    [AsyncStateMachineAttribute("Google.Protobuf.ByteStringAsync/<FromStreamAsyncCore>d__0")]
internal static Task`1<ByteString> FromStreamAsyncCore(Stream stream, CancellationToken cancellationToken);
}
[SecuritySafeCriticalAttribute]
public class Google.Protobuf.CodedInputStream : object {
    private bool leaveOpen;
    private Byte[] buffer;
    private Stream input;
    private ParserInternalState state;
    internal static int DefaultRecursionLimit;
    internal static int DefaultSizeLimit;
    internal static int BufferSize;
    public long Position { get; }
    internal UInt32 LastTag { get; }
    public int SizeLimit { get; }
    public int RecursionLimit { get; }
    internal bool DiscardUnknownFields { get; internal set; }
    internal ExtensionRegistry ExtensionRegistry { get; internal set; }
    internal Byte[] InternalBuffer { get; }
    internal Stream InternalInputStream { get; }
    internal ParserInternalState& InternalState { get; }
    internal bool ReachedLimit { get; }
    public bool IsAtEnd { get; }
    public CodedInputStream(Byte[] buffer);
    public CodedInputStream(Byte[] buffer, int offset, int length);
    public CodedInputStream(Stream input);
    public CodedInputStream(Stream input, bool leaveOpen);
    internal CodedInputStream(Stream input, Byte[] buffer, int bufferPos, int bufferSize, bool leaveOpen);
    internal CodedInputStream(Stream input, Byte[] buffer, int bufferPos, int bufferSize, int sizeLimit, int recursionLimit, bool leaveOpen);
    public static CodedInputStream CreateWithLimits(Stream input, int sizeLimit, int recursionLimit);
    public long get_Position();
    internal UInt32 get_LastTag();
    public int get_SizeLimit();
    public int get_RecursionLimit();
    internal bool get_DiscardUnknownFields();
    internal void set_DiscardUnknownFields(bool value);
    internal ExtensionRegistry get_ExtensionRegistry();
    internal void set_ExtensionRegistry(ExtensionRegistry value);
    internal Byte[] get_InternalBuffer();
    internal Stream get_InternalInputStream();
    internal ParserInternalState& get_InternalState();
    public sealed virtual void Dispose();
    internal void CheckReadEndOfStreamTag();
    public UInt32 PeekTag();
    public UInt32 ReadTag();
    public void SkipLastField();
    internal void SkipGroup(UInt32 startGroupTag);
    public double ReadDouble();
    public float ReadFloat();
    public ulong ReadUInt64();
    public long ReadInt64();
    public int ReadInt32();
    public ulong ReadFixed64();
    public UInt32 ReadFixed32();
    public bool ReadBool();
    public string ReadString();
    public void ReadMessage(IMessage builder);
    public void ReadGroup(IMessage builder);
    public ByteString ReadBytes();
    public UInt32 ReadUInt32();
    public int ReadEnum();
    public int ReadSFixed32();
    public long ReadSFixed64();
    public int ReadSInt32();
    public long ReadSInt64();
    public int ReadLength();
    public bool MaybeConsumeTag(UInt32 tag);
    internal UInt32 ReadRawVarint32();
    internal static UInt32 ReadRawVarint32(Stream input);
    internal ulong ReadRawVarint64();
    internal UInt32 ReadRawLittleEndian32();
    internal ulong ReadRawLittleEndian64();
    internal int PushLimit(int byteLimit);
    internal void PopLimit(int oldLimit);
    internal bool get_ReachedLimit();
    public bool get_IsAtEnd();
    internal Byte[] ReadRawBytes(int size);
    public void ReadRawMessage(IMessage message);
}
[SecuritySafeCriticalAttribute]
public class Google.Protobuf.CodedOutputStream : object {
    private static int LittleEndian64Size;
    private static int LittleEndian32Size;
    internal static int DoubleSize;
    internal static int FloatSize;
    internal static int BoolSize;
    public static int DefaultBufferSize;
    private bool leaveOpen;
    private Byte[] buffer;
    private WriterInternalState state;
    private Stream output;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    public long Position { get; }
    public bool Deterministic { get; public set; }
    public int SpaceLeft { get; }
    internal Byte[] InternalBuffer { get; }
    internal Stream InternalOutputStream { get; }
    internal WriterInternalState& InternalState { get; }
    public CodedOutputStream(Byte[] flatArray);
    private CodedOutputStream(Byte[] buffer, int offset, int length);
    private CodedOutputStream(Stream output, Byte[] buffer, bool leaveOpen);
    public CodedOutputStream(Stream output);
    public CodedOutputStream(Stream output, int bufferSize);
    public CodedOutputStream(Stream output, bool leaveOpen);
    public CodedOutputStream(Stream output, int bufferSize, bool leaveOpen);
    private static CodedOutputStream();
    public static int ComputeDoubleSize(double value);
    public static int ComputeFloatSize(float value);
    public static int ComputeUInt64Size(ulong value);
    public static int ComputeInt64Size(long value);
    public static int ComputeInt32Size(int value);
    public static int ComputeFixed64Size(ulong value);
    public static int ComputeFixed32Size(UInt32 value);
    public static int ComputeBoolSize(bool value);
    public static int ComputeStringSize(string value);
    public static int ComputeGroupSize(IMessage value);
    public static int ComputeMessageSize(IMessage value);
    public static int ComputeBytesSize(ByteString value);
    public static int ComputeUInt32Size(UInt32 value);
    public static int ComputeEnumSize(int value);
    public static int ComputeSFixed32Size(int value);
    public static int ComputeSFixed64Size(long value);
    public static int ComputeSInt32Size(int value);
    public static int ComputeSInt64Size(long value);
    public static int ComputeLengthSize(int length);
    public static int ComputeRawVarint32Size(UInt32 value);
    public static int ComputeRawVarint64Size(ulong value);
    public static int ComputeTagSize(int fieldNumber);
    public long get_Position();
    [CompilerGeneratedAttribute]
public bool get_Deterministic();
    [CompilerGeneratedAttribute]
public void set_Deterministic(bool value);
    public void WriteDouble(double value);
    public void WriteFloat(float value);
    public void WriteUInt64(ulong value);
    public void WriteInt64(long value);
    public void WriteInt32(int value);
    public void WriteFixed64(ulong value);
    public void WriteFixed32(UInt32 value);
    public void WriteBool(bool value);
    public void WriteString(string value);
    public void WriteMessage(IMessage value);
    public void WriteRawMessage(IMessage value);
    public void WriteGroup(IMessage value);
    public void WriteBytes(ByteString value);
    public void WriteUInt32(UInt32 value);
    public void WriteEnum(int value);
    public void WriteSFixed32(int value);
    public void WriteSFixed64(long value);
    public void WriteSInt32(int value);
    public void WriteSInt64(long value);
    public void WriteLength(int length);
    public void WriteTag(int fieldNumber, WireType type);
    public void WriteTag(UInt32 tag);
    public void WriteRawTag(byte b1);
    public void WriteRawTag(byte b1, byte b2);
    public void WriteRawTag(byte b1, byte b2, byte b3);
    public void WriteRawTag(byte b1, byte b2, byte b3, byte b4);
    public void WriteRawTag(byte b1, byte b2, byte b3, byte b4, byte b5);
    internal void WriteRawVarint32(UInt32 value);
    internal void WriteRawVarint64(ulong value);
    internal void WriteRawLittleEndian32(UInt32 value);
    internal void WriteRawLittleEndian64(ulong value);
    internal void WriteRawBytes(Byte[] value);
    internal void WriteRawBytes(Byte[] value, int offset, int length);
    public sealed virtual void Dispose();
    public void Flush();
    public void CheckNoSpaceLeft();
    public int get_SpaceLeft();
    internal Byte[] get_InternalBuffer();
    internal Stream get_InternalOutputStream();
    internal WriterInternalState& get_InternalState();
}
internal static class Google.Protobuf.Collections.Lists : object {
    public static bool Equals(List`1<T> left, List`1<T> right);
    public static int GetHashCode(List`1<T> list);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Google.Protobuf.Collections.MapField`2/MapFieldDebugView")]
public class Google.Protobuf.Collections.MapField`2 : object {
    private static EqualityComparer`1<TValue> ValueEqualityComparer;
    private static EqualityComparer`1<TKey> KeyEqualityComparer;
    private Dictionary`2<TKey, LinkedListNode`1<KeyValuePair`2<TKey, TValue>>> map;
    private LinkedList`1<KeyValuePair`2<TKey, TValue>> list;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private static MapField`2();
    public sealed virtual MapField`2<TKey, TValue> Clone();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    private bool ContainsValue(TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public void Add(IDictionary`2<TKey, TValue> entries);
    public void MergeFrom(IDictionary`2<TKey, TValue> entries);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MapField`2<TKey, TValue> other);
    public void AddEntriesFrom(CodedInputStream input, Codec<TKey, TValue> codec);
    [SecuritySafeCriticalAttribute]
public void AddEntriesFrom(ParseContext& ctx, Codec<TKey, TValue> codec);
    public void WriteTo(CodedOutputStream output, Codec<TKey, TValue> codec);
    internal IEnumerable`1<KeyValuePair`2<TKey, TValue>> GetSortedListCopy(IEnumerable`1<KeyValuePair`2<TKey, TValue>> listToSort);
    [SecuritySafeCriticalAttribute]
public void WriteTo(WriteContext& ctx, Codec<TKey, TValue> codec);
    [SecuritySafeCriticalAttribute]
private void WriteTo(WriteContext& ctx, Codec<TKey, TValue> codec, IEnumerable`1<KeyValuePair`2<TKey, TValue>> listKvp);
    public int CalculateSize(Codec<TKey, TValue> codec);
    private static int CalculateEntrySize(Codec<TKey, TValue> codec, KeyValuePair`2<TKey, TValue> entry);
    public virtual string ToString();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
}
internal static class Google.Protobuf.Collections.ProtobufEqualityComparers : object {
    [CompilerGeneratedAttribute]
private static EqualityComparer`1<double> <BitwiseDoubleEqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static EqualityComparer`1<float> <BitwiseSingleEqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static EqualityComparer`1<Nullable`1<double>> <BitwiseNullableDoubleEqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static EqualityComparer`1<Nullable`1<float>> <BitwiseNullableSingleEqualityComparer>k__BackingField;
    public static EqualityComparer`1<double> BitwiseDoubleEqualityComparer { get; }
    public static EqualityComparer`1<float> BitwiseSingleEqualityComparer { get; }
    public static EqualityComparer`1<Nullable`1<double>> BitwiseNullableDoubleEqualityComparer { get; }
    public static EqualityComparer`1<Nullable`1<float>> BitwiseNullableSingleEqualityComparer { get; }
    private static ProtobufEqualityComparers();
    public static EqualityComparer`1<T> GetEqualityComparer();
    [CompilerGeneratedAttribute]
public static EqualityComparer`1<double> get_BitwiseDoubleEqualityComparer();
    [CompilerGeneratedAttribute]
public static EqualityComparer`1<float> get_BitwiseSingleEqualityComparer();
    [CompilerGeneratedAttribute]
public static EqualityComparer`1<Nullable`1<double>> get_BitwiseNullableDoubleEqualityComparer();
    [CompilerGeneratedAttribute]
public static EqualityComparer`1<Nullable`1<float>> get_BitwiseNullableSingleEqualityComparer();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Google.Protobuf.Collections.RepeatedField`1/RepeatedFieldDebugView")]
public class Google.Protobuf.Collections.RepeatedField`1 : object {
    private static EqualityComparer`1<T> EqualityComparer;
    private static T[] EmptyArray;
    private static int MinArraySize;
    private T[] array;
    private int count;
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private static RepeatedField`1();
    public sealed virtual RepeatedField`1<T> Clone();
    public void AddEntriesFrom(CodedInputStream input, FieldCodec`1<T> codec);
    [SecuritySafeCriticalAttribute]
public void AddEntriesFrom(ParseContext& ctx, FieldCodec`1<T> codec);
    public int CalculateSize(FieldCodec`1<T> codec);
    private int CalculatePackedDataSize(FieldCodec`1<T> codec);
    public void WriteTo(CodedOutputStream output, FieldCodec`1<T> codec);
    [SecuritySafeCriticalAttribute]
public void WriteTo(WriteContext& ctx, FieldCodec`1<T> codec);
    public int get_Capacity();
    public void set_Capacity(int value);
    private void EnsureSize(int size);
    private void SetSize(int size);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public void AddRange(IEnumerable`1<T> values);
    public void Add(IEnumerable`1<T> values);
    [IteratorStateMachineAttribute("Google.Protobuf.Collections.RepeatedField`1/<GetEnumerator>d__28")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    public virtual bool Equals(object obj);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RepeatedField`1<T> other);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public virtual string ToString();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[ExtensionAttribute]
internal static class Google.Protobuf.Compatibility.PropertyInfoExtensions : object {
    [ExtensionAttribute]
internal static MethodInfo GetGetMethod(PropertyInfo target);
    [ExtensionAttribute]
internal static MethodInfo GetSetMethod(PropertyInfo target);
}
[ExtensionAttribute]
internal static class Google.Protobuf.Compatibility.TypeExtensions : object {
    [ExtensionAttribute]
internal static bool IsAssignableFrom(Type target, Type c);
    [ExtensionAttribute]
[<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute("Trimming", "IL2072")]
internal static PropertyInfo GetProperty(Type target, string name);
    [ExtensionAttribute]
[<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute("Trimming", "IL2072")]
internal static MethodInfo GetMethod(Type target, string name);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.Compiler.CodeGeneratorRequest : object {
    private static MessageParser`1<CodeGeneratorRequest> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FileToGenerateFieldNumber;
    private static FieldCodec`1<string> _repeated_fileToGenerate_codec;
    private RepeatedField`1<string> fileToGenerate_;
    public static int ParameterFieldNumber;
    private static string ParameterDefaultValue;
    private string parameter_;
    public static int ProtoFileFieldNumber;
    private static FieldCodec`1<FileDescriptorProto> _repeated_protoFile_codec;
    private RepeatedField`1<FileDescriptorProto> protoFile_;
    public static int SourceFileDescriptorsFieldNumber;
    private static FieldCodec`1<FileDescriptorProto> _repeated_sourceFileDescriptors_codec;
    private RepeatedField`1<FileDescriptorProto> sourceFileDescriptors_;
    public static int CompilerVersionFieldNumber;
    private Version compilerVersion_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<CodeGeneratorRequest> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<string> FileToGenerate { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Parameter { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasParameter { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<FileDescriptorProto> ProtoFile { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<FileDescriptorProto> SourceFileDescriptors { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Version CompilerVersion { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public CodeGeneratorRequest(CodeGeneratorRequest other);
    private static CodeGeneratorRequest();
    public static MessageParser`1<CodeGeneratorRequest> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual CodeGeneratorRequest Clone();
    public RepeatedField`1<string> get_FileToGenerate();
    public string get_Parameter();
    public void set_Parameter(string value);
    public bool get_HasParameter();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearParameter();
    public RepeatedField`1<FileDescriptorProto> get_ProtoFile();
    public RepeatedField`1<FileDescriptorProto> get_SourceFileDescriptors();
    public Version get_CompilerVersion();
    public void set_CompilerVersion(Version value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(CodeGeneratorRequest other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodeGeneratorRequest other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.Compiler.CodeGeneratorResponse : object {
    private static MessageParser`1<CodeGeneratorResponse> _parser;
    private UnknownFieldSet _unknownFields;
    private int _hasBits0;
    public static int ErrorFieldNumber;
    private static string ErrorDefaultValue;
    private string error_;
    public static int SupportedFeaturesFieldNumber;
    private static ulong SupportedFeaturesDefaultValue;
    private ulong supportedFeatures_;
    public static int MinimumEditionFieldNumber;
    private static int MinimumEditionDefaultValue;
    private int minimumEdition_;
    public static int MaximumEditionFieldNumber;
    private static int MaximumEditionDefaultValue;
    private int maximumEdition_;
    public static int FileFieldNumber;
    private static FieldCodec`1<File> _repeated_file_codec;
    private RepeatedField`1<File> file_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<CodeGeneratorResponse> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Error { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasError { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ulong SupportedFeatures { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasSupportedFeatures { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int MinimumEdition { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMinimumEdition { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int MaximumEdition { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMaximumEdition { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<File> File { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public CodeGeneratorResponse(CodeGeneratorResponse other);
    private static CodeGeneratorResponse();
    public static MessageParser`1<CodeGeneratorResponse> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual CodeGeneratorResponse Clone();
    public string get_Error();
    public void set_Error(string value);
    public bool get_HasError();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearError();
    public ulong get_SupportedFeatures();
    public void set_SupportedFeatures(ulong value);
    public bool get_HasSupportedFeatures();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearSupportedFeatures();
    public int get_MinimumEdition();
    public void set_MinimumEdition(int value);
    public bool get_HasMinimumEdition();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMinimumEdition();
    public int get_MaximumEdition();
    public void set_MaximumEdition(int value);
    public bool get_HasMaximumEdition();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMaximumEdition();
    public RepeatedField`1<File> get_File();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(CodeGeneratorResponse other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodeGeneratorResponse other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal static class Google.Protobuf.Compiler.PluginReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static PluginReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.Compiler.Version : object {
    private static MessageParser`1<Version> _parser;
    private UnknownFieldSet _unknownFields;
    private int _hasBits0;
    public static int MajorFieldNumber;
    private static int MajorDefaultValue;
    private int major_;
    public static int MinorFieldNumber;
    private static int MinorDefaultValue;
    private int minor_;
    public static int PatchFieldNumber;
    private static int PatchDefaultValue;
    private int patch_;
    public static int SuffixFieldNumber;
    private static string SuffixDefaultValue;
    private string suffix_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Version> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Major { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMajor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Minor { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMinor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Patch { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasPatch { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Suffix { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasSuffix { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Version(Version other);
    private static Version();
    public static MessageParser`1<Version> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Version Clone();
    public int get_Major();
    public void set_Major(int value);
    public bool get_HasMajor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMajor();
    public int get_Minor();
    public void set_Minor(int value);
    public bool get_HasMinor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMinor();
    public int get_Patch();
    public void set_Patch(int value);
    public bool get_HasPatch();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearPatch();
    public string get_Suffix();
    public void set_Suffix(string value);
    public bool get_HasSuffix();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearSuffix();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Version other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Version other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
public abstract class Google.Protobuf.Extension : object {
    [CompilerGeneratedAttribute]
private int <FieldNumber>k__BackingField;
    internal Type TargetType { get; }
    public int FieldNumber { get; }
    internal bool IsRepeated { get; }
    protected Extension(int fieldNumber);
    internal abstract virtual Type get_TargetType();
    internal abstract virtual IExtensionValue CreateValue();
    [CompilerGeneratedAttribute]
public int get_FieldNumber();
    internal abstract virtual bool get_IsRepeated();
}
public class Google.Protobuf.Extension`2 : Extension {
    private FieldCodec`1<TValue> codec;
    internal TValue DefaultValue { get; }
    internal Type TargetType { get; }
    internal bool IsRepeated { get; }
    public Extension`2(int fieldNumber, FieldCodec`1<TValue> codec);
    internal TValue get_DefaultValue();
    internal virtual Type get_TargetType();
    internal virtual bool get_IsRepeated();
    internal virtual IExtensionValue CreateValue();
}
public class Google.Protobuf.ExtensionRegistry : object {
    private IDictionary`2<ObjectIntPair`1<Type>, Extension> extensions;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<Google.Protobuf.Extension>.IsReadOnly { get; }
    private ExtensionRegistry(IDictionary`2<ObjectIntPair`1<Type>, Extension> collection);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<Google.Protobuf.Extension>.get_IsReadOnly();
    internal bool ContainsInputField(UInt32 lastTag, Type target, Extension& extension);
    public sealed virtual void Add(Extension extension);
    public void AddRange(IEnumerable`1<Extension> extensions);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Extension item);
    private sealed virtual override void System.Collections.Generic.ICollection<Google.Protobuf.Extension>.CopyTo(Extension[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<Extension> GetEnumerator();
    public sealed virtual bool Remove(Extension item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ExtensionRegistry Clone();
}
internal static class Google.Protobuf.ExtensionSet : object {
    private static bool TryGetValue(ExtensionSet`1& set, Extension extension, IExtensionValue& value);
    public static TValue Get(ExtensionSet`1& set, Extension`2<TTarget, TValue> extension);
    public static RepeatedField`1<TValue> Get(ExtensionSet`1& set, RepeatedExtension`2<TTarget, TValue> extension);
    public static RepeatedField`1<TValue> GetOrInitialize(ExtensionSet`1& set, RepeatedExtension`2<TTarget, TValue> extension);
    public static void Set(ExtensionSet`1& set, Extension`2<TTarget, TValue> extension, TValue value);
    public static bool Has(ExtensionSet`1& set, Extension`2<TTarget, TValue> extension);
    public static void Clear(ExtensionSet`1& set, Extension`2<TTarget, TValue> extension);
    public static void Clear(ExtensionSet`1& set, RepeatedExtension`2<TTarget, TValue> extension);
    public static bool TryMergeFieldFrom(ExtensionSet`1& set, CodedInputStream stream);
    public static bool TryMergeFieldFrom(ExtensionSet`1& set, ParseContext& ctx);
    public static void MergeFrom(ExtensionSet`1& first, ExtensionSet`1<TTarget> second);
    public static ExtensionSet`1<TTarget> Clone(ExtensionSet`1<TTarget> set);
}
internal class Google.Protobuf.ExtensionSet`1 : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<int, IExtensionValue> <ValuesByNumber>k__BackingField;
    internal Dictionary`2<int, IExtensionValue> ValuesByNumber { get; }
    [CompilerGeneratedAttribute]
internal Dictionary`2<int, IExtensionValue> get_ValuesByNumber();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public int CalculateSize();
    public void WriteTo(CodedOutputStream stream);
    [SecuritySafeCriticalAttribute]
public void WriteTo(WriteContext& ctx);
    internal bool IsInitialized();
}
internal class Google.Protobuf.ExtensionValue`1 : object {
    private T field;
    private FieldCodec`1<T> codec;
    internal ExtensionValue`1(FieldCodec`1<T> codec);
    public sealed virtual int CalculateSize();
    public sealed virtual IExtensionValue Clone();
    public sealed virtual bool Equals(IExtensionValue other);
    public virtual int GetHashCode();
    public sealed virtual void MergeFrom(ParseContext& ctx);
    public sealed virtual void MergeFrom(IExtensionValue value);
    public sealed virtual void WriteTo(WriteContext& ctx);
    public T GetValue();
    private sealed virtual override object Google.Protobuf.IExtensionValue.GetValue();
    public void SetValue(T value);
    public sealed virtual bool IsInitialized();
}
internal static class Google.Protobuf.FieldCodec : object {
    public static FieldCodec`1<string> ForString(UInt32 tag);
    public static FieldCodec`1<ByteString> ForBytes(UInt32 tag);
    public static FieldCodec`1<bool> ForBool(UInt32 tag);
    public static FieldCodec`1<int> ForInt32(UInt32 tag);
    public static FieldCodec`1<int> ForSInt32(UInt32 tag);
    public static FieldCodec`1<UInt32> ForFixed32(UInt32 tag);
    public static FieldCodec`1<int> ForSFixed32(UInt32 tag);
    public static FieldCodec`1<UInt32> ForUInt32(UInt32 tag);
    public static FieldCodec`1<long> ForInt64(UInt32 tag);
    public static FieldCodec`1<long> ForSInt64(UInt32 tag);
    public static FieldCodec`1<ulong> ForFixed64(UInt32 tag);
    public static FieldCodec`1<long> ForSFixed64(UInt32 tag);
    public static FieldCodec`1<ulong> ForUInt64(UInt32 tag);
    public static FieldCodec`1<float> ForFloat(UInt32 tag);
    public static FieldCodec`1<double> ForDouble(UInt32 tag);
    public static FieldCodec`1<T> ForEnum(UInt32 tag, Func`2<T, int> toInt32, Func`2<int, T> fromInt32);
    public static FieldCodec`1<string> ForString(UInt32 tag, string defaultValue);
    public static FieldCodec`1<ByteString> ForBytes(UInt32 tag, ByteString defaultValue);
    public static FieldCodec`1<bool> ForBool(UInt32 tag, bool defaultValue);
    public static FieldCodec`1<int> ForInt32(UInt32 tag, int defaultValue);
    public static FieldCodec`1<int> ForSInt32(UInt32 tag, int defaultValue);
    public static FieldCodec`1<UInt32> ForFixed32(UInt32 tag, UInt32 defaultValue);
    public static FieldCodec`1<int> ForSFixed32(UInt32 tag, int defaultValue);
    public static FieldCodec`1<UInt32> ForUInt32(UInt32 tag, UInt32 defaultValue);
    public static FieldCodec`1<long> ForInt64(UInt32 tag, long defaultValue);
    public static FieldCodec`1<long> ForSInt64(UInt32 tag, long defaultValue);
    public static FieldCodec`1<ulong> ForFixed64(UInt32 tag, ulong defaultValue);
    public static FieldCodec`1<long> ForSFixed64(UInt32 tag, long defaultValue);
    public static FieldCodec`1<ulong> ForUInt64(UInt32 tag, ulong defaultValue);
    public static FieldCodec`1<float> ForFloat(UInt32 tag, float defaultValue);
    public static FieldCodec`1<double> ForDouble(UInt32 tag, double defaultValue);
    public static FieldCodec`1<T> ForEnum(UInt32 tag, Func`2<T, int> toInt32, Func`2<int, T> fromInt32, T defaultValue);
    public static FieldCodec`1<T> ForMessage(UInt32 tag, MessageParser`1<T> parser);
    public static FieldCodec`1<T> ForGroup(UInt32 startTag, UInt32 endTag, MessageParser`1<T> parser);
    public static FieldCodec`1<T> ForClassWrapper(UInt32 tag);
    public static FieldCodec`1<Nullable`1<T>> ForStructWrapper(UInt32 tag);
}
public class Google.Protobuf.FieldCodec`1 : object {
    private static EqualityComparer`1<T> EqualityComparer;
    private static T DefaultDefault;
    private static bool TypeSupportsPacking;
    [CompilerGeneratedAttribute]
private bool <PackedRepeatedField>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueWriter`1<T> <ValueWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<T, int> <ValueSizeCalculator>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueReader`1<T> <ValueReader>k__BackingField;
    [CompilerGeneratedAttribute]
private InputMerger<T> <ValueMerger>k__BackingField;
    [CompilerGeneratedAttribute]
private ValuesMerger<T> <FieldMerger>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FixedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndTag>k__BackingField;
    [CompilerGeneratedAttribute]
private T <DefaultValue>k__BackingField;
    private int tagSize;
    internal bool PackedRepeatedField { get; }
    internal ValueWriter`1<T> ValueWriter { get; }
    internal Func`2<T, int> ValueSizeCalculator { get; }
    internal ValueReader`1<T> ValueReader { get; }
    internal InputMerger<T> ValueMerger { get; }
    internal ValuesMerger<T> FieldMerger { get; }
    internal int FixedSize { get; }
    internal UInt32 Tag { get; }
    internal UInt32 EndTag { get; }
    internal T DefaultValue { get; }
    private static FieldCodec`1();
    internal FieldCodec`1(ValueReader`1<T> reader, ValueWriter`1<T> writer, int fixedSize, UInt32 tag, T defaultValue);
    internal FieldCodec`1(ValueReader`1<T> reader, ValueWriter`1<T> writer, Func`2<T, int> sizeCalculator, UInt32 tag, T defaultValue);
    internal FieldCodec`1(ValueReader`1<T> reader, ValueWriter`1<T> writer, InputMerger<T> inputMerger, ValuesMerger<T> valuesMerger, Func`2<T, int> sizeCalculator, UInt32 tag, UInt32 endTag);
    internal FieldCodec`1(ValueReader`1<T> reader, ValueWriter`1<T> writer, InputMerger<T> inputMerger, ValuesMerger<T> valuesMerger, Func`2<T, int> sizeCalculator, UInt32 tag, UInt32 endTag, T defaultValue);
    internal static bool IsPackedRepeatedField(UInt32 tag);
    [CompilerGeneratedAttribute]
internal bool get_PackedRepeatedField();
    [CompilerGeneratedAttribute]
internal ValueWriter`1<T> get_ValueWriter();
    [CompilerGeneratedAttribute]
internal Func`2<T, int> get_ValueSizeCalculator();
    [CompilerGeneratedAttribute]
internal ValueReader`1<T> get_ValueReader();
    [CompilerGeneratedAttribute]
internal InputMerger<T> get_ValueMerger();
    [CompilerGeneratedAttribute]
internal ValuesMerger<T> get_FieldMerger();
    [CompilerGeneratedAttribute]
internal int get_FixedSize();
    [CompilerGeneratedAttribute]
internal UInt32 get_Tag();
    [CompilerGeneratedAttribute]
internal UInt32 get_EndTag();
    [CompilerGeneratedAttribute]
internal T get_DefaultValue();
    public void WriteTagAndValue(CodedOutputStream output, T value);
    public void WriteTagAndValue(WriteContext& ctx, T value);
    public T Read(CodedInputStream input);
    public T Read(ParseContext& ctx);
    public int CalculateSizeWithTag(T value);
    internal int CalculateUnconditionalSizeWithTag(T value);
    private bool IsDefault(T value);
}
internal class Google.Protobuf.FieldMaskTree : object {
    private static char FIELD_PATH_SEPARATOR;
    private Node root;
    public FieldMaskTree(FieldMask mask);
    public virtual string ToString();
    public FieldMaskTree AddFieldPath(string path);
    public FieldMaskTree MergeFromFieldMask(FieldMask mask);
    public FieldMask ToFieldMask();
    private void GetFieldPaths(Node node, string path, List`1<string> paths);
    public void IntersectFieldPath(string path, FieldMaskTree output);
    public void Merge(IMessage source, IMessage destination, MergeOptions options);
    private void Merge(Node node, string path, IMessage source, IMessage destination, MergeOptions options);
}
internal static class Google.Protobuf.FrameworkPortability : object {
    internal static RegexOptions CompiledRegexWhereAvailable;
    private static FrameworkPortability();
}
internal interface Google.Protobuf.IBufferMessage {
    public abstract virtual void InternalMergeFrom(ParseContext& ctx);
    public abstract virtual void InternalWriteTo(WriteContext& ctx);
}
internal interface Google.Protobuf.ICustomDiagnosticMessage {
    public abstract virtual string ToDiagnosticString();
}
internal interface Google.Protobuf.IDeepCloneable`1 {
    public abstract virtual T Clone();
}
internal interface Google.Protobuf.IExtendableMessage`1 {
    public abstract virtual TValue GetExtension(Extension`2<T, TValue> extension);
    public abstract virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<T, TValue> extension);
    public abstract virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<T, TValue> extension);
    public abstract virtual void SetExtension(Extension`2<T, TValue> extension, TValue value);
    public abstract virtual bool HasExtension(Extension`2<T, TValue> extension);
    public abstract virtual void ClearExtension(Extension`2<T, TValue> extension);
    public abstract virtual void ClearExtension(RepeatedExtension`2<T, TValue> extension);
}
internal interface Google.Protobuf.IExtensionValue {
    public abstract virtual void MergeFrom(ParseContext& ctx);
    public abstract virtual void MergeFrom(IExtensionValue value);
    public abstract virtual void WriteTo(WriteContext& ctx);
    public abstract virtual int CalculateSize();
    public abstract virtual bool IsInitialized();
    public abstract virtual object GetValue();
}
public interface Google.Protobuf.IMessage {
    public MessageDescriptor Descriptor { get; }
    public abstract virtual void MergeFrom(CodedInputStream input);
    public abstract virtual void WriteTo(CodedOutputStream output);
    public abstract virtual int CalculateSize();
    public abstract virtual MessageDescriptor get_Descriptor();
}
internal interface Google.Protobuf.IMessage`1 {
    public abstract virtual void MergeFrom(T message);
}
internal class Google.Protobuf.InvalidJsonException : IOException {
    internal InvalidJsonException(string message);
}
internal class Google.Protobuf.InvalidProtocolBufferException : IOException {
    internal InvalidProtocolBufferException(string message);
    internal InvalidProtocolBufferException(string message, Exception innerException);
    internal static InvalidProtocolBufferException MoreDataAvailable();
    internal static InvalidProtocolBufferException TruncatedMessage();
    internal static InvalidProtocolBufferException NegativeSize();
    internal static InvalidProtocolBufferException MalformedVarint();
    internal static InvalidProtocolBufferException InvalidTag();
    internal static InvalidProtocolBufferException InvalidWireType();
    internal static InvalidProtocolBufferException InvalidBase64(Exception innerException);
    internal static InvalidProtocolBufferException InvalidEndTag();
    internal static InvalidProtocolBufferException RecursionLimitExceeded();
    internal static InvalidProtocolBufferException JsonRecursionLimitExceeded();
    internal static InvalidProtocolBufferException SizeLimitExceeded();
    internal static InvalidProtocolBufferException InvalidMessageStreamTag();
    internal static InvalidProtocolBufferException MissingFields();
}
internal class Google.Protobuf.JsonFormatter : object {
    internal static string AnyTypeUrlField;
    internal static string AnyDiagnosticValueField;
    internal static string AnyWellKnownTypeValueField;
    private static string NameValueSeparator;
    private static string ValueSeparator;
    private static string MultilineValueSeparator;
    private static char ObjectOpenBracket;
    private static char ObjectCloseBracket;
    private static char ListBracketOpen;
    private static char ListBracketClose;
    [CompilerGeneratedAttribute]
private static JsonFormatter <Default>k__BackingField;
    private static JsonFormatter diagnosticFormatter;
    private static String[] CommonRepresentations;
    private Settings settings;
    private static string Hex;
    public static JsonFormatter Default { get; }
    private bool DiagnosticOnly { get; }
    private static JsonFormatter();
    public JsonFormatter(Settings settings);
    [CompilerGeneratedAttribute]
public static JsonFormatter get_Default();
    private bool get_DiagnosticOnly();
    public string Format(IMessage message);
    public string Format(IMessage message, int indentationLevel);
    public void Format(IMessage message, TextWriter writer);
    public void Format(IMessage message, TextWriter writer, int indentationLevel);
    public static string ToDiagnosticString(IMessage message);
    private void WriteMessage(TextWriter writer, IMessage message, int indentationLevel);
    private bool WriteMessageFields(TextWriter writer, IMessage message, bool assumeFirstFieldWritten, int indentationLevel);
    private void MaybeWriteValueSeparator(TextWriter writer, bool first);
    private bool ShouldFormatFieldValue(IMessage message, FieldDescriptor field, object value);
    internal static string ToJsonName(string name);
    internal static string FromJsonName(string name);
    private static void WriteNull(TextWriter writer);
    private static bool IsDefaultValue(FieldDescriptor descriptor, object value);
    public void WriteValue(TextWriter writer, object value);
    public void WriteValue(TextWriter writer, object value, int indentationLevel);
    private void WriteWellKnownTypeValue(TextWriter writer, MessageDescriptor descriptor, object value, int indentationLevel);
    private void WriteTimestamp(TextWriter writer, IMessage value);
    private void WriteDuration(TextWriter writer, IMessage value);
    private void WriteFieldMask(TextWriter writer, IMessage value);
    private void WriteAny(TextWriter writer, IMessage value, int indentationLevel);
    private void WriteDiagnosticOnlyAny(TextWriter writer, IMessage value);
    private void WriteStruct(TextWriter writer, IMessage message, int indentationLevel);
    private void WriteStructFieldValue(TextWriter writer, IMessage message, int indentationLevel);
    internal void WriteList(TextWriter writer, IList list, int indentationLevel);
    internal void WriteDictionary(TextWriter writer, IDictionary dictionary, int indentationLevel);
    internal static void WriteString(TextWriter writer, string text);
    private static void HexEncodeUtf16CodeUnit(TextWriter writer, char c);
    private void WriteBracketOpen(TextWriter writer, char openChar);
    private void WriteBracketClose(TextWriter writer, char closeChar, bool hasFields, int indentationLevel);
    private void MaybeWriteValueWhitespace(TextWriter writer, int indentationLevel);
    private void WriteIndentation(TextWriter writer, int indentationLevel);
}
internal class Google.Protobuf.JsonParser : object {
    private static Regex TimestampRegex;
    private static Regex DurationRegex;
    private static Int32[] SubsecondScalingFactors;
    private static Char[] FieldMaskPathSeparators;
    private static EnumDescriptor NullValueDescriptor;
    private static JsonParser defaultInstance;
    private static Dictionary`2<string, Action`3<JsonParser, IMessage, JsonTokenizer>> WellKnownTypeHandlers;
    private Settings settings;
    public static JsonParser Default { get; }
    public JsonParser(Settings settings);
    private static JsonParser();
    private static void MergeWrapperField(JsonParser parser, IMessage message, JsonTokenizer tokenizer);
    public static JsonParser get_Default();
    internal void Merge(IMessage message, string json);
    internal void Merge(IMessage message, TextReader jsonReader);
    private void Merge(IMessage message, JsonTokenizer tokenizer);
    private void MergeField(IMessage message, FieldDescriptor field, JsonTokenizer tokenizer);
    private void MergeRepeatedField(IMessage message, FieldDescriptor field, JsonTokenizer tokenizer);
    private void MergeMapField(IMessage message, FieldDescriptor field, JsonTokenizer tokenizer);
    private static bool IsGoogleProtobufValueField(FieldDescriptor field);
    private static bool IsGoogleProtobufNullValueField(FieldDescriptor field);
    private bool TryParseSingleValue(FieldDescriptor field, JsonTokenizer tokenizer, Object& value);
    public T Parse(string json);
    public T Parse(TextReader jsonReader);
    public IMessage Parse(string json, MessageDescriptor descriptor);
    public IMessage Parse(TextReader jsonReader, MessageDescriptor descriptor);
    private void MergeStructValue(IMessage message, JsonTokenizer tokenizer);
    private void MergeStruct(IMessage message, JsonTokenizer tokenizer);
    private void MergeAny(IMessage message, JsonTokenizer tokenizer);
    private void MergeWellKnownTypeAnyBody(IMessage body, JsonTokenizer tokenizer);
    private static object ParseMapKey(FieldDescriptor field, string keyText);
    private static object ParseSingleNumberValue(FieldDescriptor field, JsonToken token);
    private static void CheckInteger(double value);
    private static object ParseSingleStringValue(FieldDescriptor field, string text);
    private bool TryParseEnumStringValue(FieldDescriptor field, string text, Object& value);
    private static IMessage NewMessageForField(FieldDescriptor field);
    private static T ParseNumericString(string text, Func`4<string, NumberStyles, IFormatProvider, T> parser);
    private static void ValidateInfinityAndNan(string text, bool isPositiveInfinity, bool isNegativeInfinity, bool isNaN);
    private static void MergeTimestamp(IMessage message, JsonToken token);
    private static void MergeDuration(IMessage message, JsonToken token);
    private static void MergeFieldMask(IMessage message, JsonToken token);
    private static string ToSnakeCase(string text);
}
internal class Google.Protobuf.JsonToken : object {
    [CompilerGeneratedAttribute]
private static JsonToken <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonToken <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonToken <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonToken <StartObject>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonToken <EndObject>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonToken <StartArray>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonToken <EndArray>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonToken <EndDocument>k__BackingField;
    private TokenType type;
    private string stringValue;
    private double numberValue;
    internal static JsonToken Null { get; }
    internal static JsonToken False { get; }
    internal static JsonToken True { get; }
    internal static JsonToken StartObject { get; }
    internal static JsonToken EndObject { get; }
    internal static JsonToken StartArray { get; }
    internal static JsonToken EndArray { get; }
    internal static JsonToken EndDocument { get; }
    internal TokenType Type { get; }
    internal string StringValue { get; }
    internal double NumberValue { get; }
    private JsonToken(TokenType type, string stringValue, double numberValue);
    private static JsonToken();
    [CompilerGeneratedAttribute]
internal static JsonToken get_Null();
    [CompilerGeneratedAttribute]
internal static JsonToken get_False();
    [CompilerGeneratedAttribute]
internal static JsonToken get_True();
    [CompilerGeneratedAttribute]
internal static JsonToken get_StartObject();
    [CompilerGeneratedAttribute]
internal static JsonToken get_EndObject();
    [CompilerGeneratedAttribute]
internal static JsonToken get_StartArray();
    [CompilerGeneratedAttribute]
internal static JsonToken get_EndArray();
    [CompilerGeneratedAttribute]
internal static JsonToken get_EndDocument();
    internal static JsonToken Name(string name);
    internal static JsonToken Value(string value);
    internal static JsonToken Value(double value);
    internal TokenType get_Type();
    internal string get_StringValue();
    internal double get_NumberValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(JsonToken other);
}
internal abstract class Google.Protobuf.JsonTokenizer : object {
    private JsonToken bufferedToken;
    [CompilerGeneratedAttribute]
private int <ObjectDepth>k__BackingField;
    internal int ObjectDepth { get; private set; }
    internal static JsonTokenizer FromTextReader(TextReader reader);
    internal static JsonTokenizer FromReplayedTokens(IList`1<JsonToken> tokens, JsonTokenizer continuation);
    [CompilerGeneratedAttribute]
internal int get_ObjectDepth();
    [CompilerGeneratedAttribute]
private void set_ObjectDepth(int value);
    internal void PushBack(JsonToken token);
    internal JsonToken Next();
    protected abstract virtual JsonToken NextImpl();
    internal void SkipValue();
}
internal class Google.Protobuf.LimitedInputStream : Stream {
    private Stream proxied;
    private int bytesLeft;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal LimitedInputStream(Stream proxied, int size);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[ExtensionAttribute]
internal static class Google.Protobuf.MessageExtensions : object {
    [ExtensionAttribute]
public static void MergeFrom(IMessage message, Byte[] data);
    [ExtensionAttribute]
public static void MergeFrom(IMessage message, Byte[] data, int offset, int length);
    [ExtensionAttribute]
public static void MergeFrom(IMessage message, ByteString data);
    [ExtensionAttribute]
public static void MergeFrom(IMessage message, Stream input);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static void MergeFrom(IMessage message, ReadOnlySpan`1<byte> span);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static void MergeFrom(IMessage message, ReadOnlySequence`1<byte> sequence);
    [ExtensionAttribute]
public static void MergeDelimitedFrom(IMessage message, Stream input);
    [ExtensionAttribute]
public static Byte[] ToByteArray(IMessage message);
    [ExtensionAttribute]
public static void WriteTo(IMessage message, Stream output);
    [ExtensionAttribute]
public static void WriteDelimitedTo(IMessage message, Stream output);
    [ExtensionAttribute]
public static ByteString ToByteString(IMessage message);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static void WriteTo(IMessage message, IBufferWriter`1<byte> output);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static void WriteTo(IMessage message, Span`1<byte> output);
    [ExtensionAttribute]
public static bool IsInitialized(IMessage message);
    [ExtensionAttribute]
internal static void MergeFrom(IMessage message, Byte[] data, bool discardUnknownFields, ExtensionRegistry registry);
    [ExtensionAttribute]
internal static void MergeFrom(IMessage message, Byte[] data, int offset, int length, bool discardUnknownFields, ExtensionRegistry registry);
    [ExtensionAttribute]
internal static void MergeFrom(IMessage message, ByteString data, bool discardUnknownFields, ExtensionRegistry registry);
    [ExtensionAttribute]
internal static void MergeFrom(IMessage message, Stream input, bool discardUnknownFields, ExtensionRegistry registry);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
internal static void MergeFrom(IMessage message, ReadOnlySequence`1<byte> data, bool discardUnknownFields, ExtensionRegistry registry);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
internal static void MergeFrom(IMessage message, ReadOnlySpan`1<byte> data, bool discardUnknownFields, ExtensionRegistry registry);
    [ExtensionAttribute]
internal static void MergeDelimitedFrom(IMessage message, Stream input, bool discardUnknownFields, ExtensionRegistry registry);
}
public class Google.Protobuf.MessageParser : object {
    private Func`1<IMessage> factory;
    [CompilerGeneratedAttribute]
private bool <DiscardUnknownFields>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionRegistry <Extensions>k__BackingField;
    private protected bool DiscardUnknownFields { get; }
    internal ExtensionRegistry Extensions { get; }
    internal MessageParser(Func`1<IMessage> factory, bool discardUnknownFields, ExtensionRegistry extensions);
    [CompilerGeneratedAttribute]
private protected bool get_DiscardUnknownFields();
    [CompilerGeneratedAttribute]
internal ExtensionRegistry get_Extensions();
    internal IMessage CreateTemplate();
    public IMessage ParseFrom(Byte[] data);
    public IMessage ParseFrom(Byte[] data, int offset, int length);
    public IMessage ParseFrom(ByteString data);
    public IMessage ParseFrom(Stream input);
    [SecuritySafeCriticalAttribute]
public IMessage ParseFrom(ReadOnlySequence`1<byte> data);
    [SecuritySafeCriticalAttribute]
public IMessage ParseFrom(ReadOnlySpan`1<byte> data);
    public IMessage ParseDelimitedFrom(Stream input);
    public IMessage ParseFrom(CodedInputStream input);
    public IMessage ParseJson(string json);
    internal void MergeFrom(IMessage message, CodedInputStream codedInput);
    public MessageParser WithDiscardUnknownFields(bool discardUnknownFields);
    public MessageParser WithExtensionRegistry(ExtensionRegistry registry);
}
public class Google.Protobuf.MessageParser`1 : MessageParser {
    private Func`1<T> factory;
    public MessageParser`1(Func`1<T> factory);
    internal MessageParser`1(Func`1<T> factory, bool discardUnknownFields, ExtensionRegistry extensions);
    internal T CreateTemplate();
    public T ParseFrom(Byte[] data);
    public T ParseFrom(Byte[] data, int offset, int length);
    public T ParseFrom(ByteString data);
    public T ParseFrom(Stream input);
    [SecuritySafeCriticalAttribute]
public T ParseFrom(ReadOnlySequence`1<byte> data);
    [SecuritySafeCriticalAttribute]
public T ParseFrom(ReadOnlySpan`1<byte> data);
    public T ParseDelimitedFrom(Stream input);
    public T ParseFrom(CodedInputStream input);
    public T ParseJson(string json);
    public MessageParser`1<T> WithDiscardUnknownFields(bool discardUnknownFields);
    public MessageParser`1<T> WithExtensionRegistry(ExtensionRegistry registry);
}
internal class Google.Protobuf.ObjectIntPair`1 : ValueType {
    private int number;
    private T obj;
    internal ObjectIntPair`1(T obj, int number);
    public sealed virtual bool Equals(ObjectIntPair`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[SecuritySafeCriticalAttribute]
public class Google.Protobuf.ParseContext : ValueType {
    internal static int DefaultRecursionLimit;
    internal static int DefaultSizeLimit;
    internal ReadOnlySpan`1<byte> buffer;
    internal ParserInternalState state;
    internal UInt32 LastTag { get; }
    internal bool DiscardUnknownFields { get; internal set; }
    internal ExtensionRegistry ExtensionRegistry { get; internal set; }
    internal static void Initialize(ReadOnlySpan`1<byte> buffer, ParseContext& ctx);
    internal static void Initialize(ReadOnlySpan`1<byte> buffer, ParserInternalState& state, ParseContext& ctx);
    internal static void Initialize(CodedInputStream input, ParseContext& ctx);
    internal static void Initialize(ReadOnlySequence`1<byte> input, ParseContext& ctx);
    internal static void Initialize(ReadOnlySequence`1<byte> input, int recursionLimit, ParseContext& ctx);
    internal UInt32 get_LastTag();
    internal bool get_DiscardUnknownFields();
    internal void set_DiscardUnknownFields(bool value);
    internal ExtensionRegistry get_ExtensionRegistry();
    internal void set_ExtensionRegistry(ExtensionRegistry value);
    public UInt32 ReadTag();
    public double ReadDouble();
    public float ReadFloat();
    public ulong ReadUInt64();
    public long ReadInt64();
    public int ReadInt32();
    public ulong ReadFixed64();
    public UInt32 ReadFixed32();
    public bool ReadBool();
    public string ReadString();
    public void ReadMessage(IMessage message);
    public void ReadGroup(IMessage message);
    public ByteString ReadBytes();
    public UInt32 ReadUInt32();
    public int ReadEnum();
    public int ReadSFixed32();
    public long ReadSFixed64();
    public int ReadSInt32();
    public long ReadSInt64();
    public int ReadLength();
    internal void CopyStateTo(CodedInputStream input);
    internal void LoadStateFrom(CodedInputStream input);
}
internal class Google.Protobuf.ParserInternalState : ValueType {
    internal int bufferPos;
    internal int bufferSize;
    internal int bufferSizeAfterLimit;
    internal int currentLimit;
    internal int totalBytesRetired;
    internal int recursionDepth;
    internal SegmentedBufferHelper segmentedBufferHelper;
    internal UInt32 lastTag;
    internal UInt32 nextTag;
    internal bool hasNextTag;
    internal int sizeLimit;
    internal int recursionLimit;
    [CompilerGeneratedAttribute]
private bool <DiscardUnknownFields>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionRegistry <ExtensionRegistry>k__BackingField;
    internal CodedInputStream CodedInputStream { get; }
    internal bool DiscardUnknownFields { get; internal set; }
    internal ExtensionRegistry ExtensionRegistry { get; internal set; }
    internal CodedInputStream get_CodedInputStream();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_DiscardUnknownFields();
    [CompilerGeneratedAttribute]
internal void set_DiscardUnknownFields(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal ExtensionRegistry get_ExtensionRegistry();
    [CompilerGeneratedAttribute]
internal void set_ExtensionRegistry(ExtensionRegistry value);
}
[SecuritySafeCriticalAttribute]
internal static class Google.Protobuf.ParsingPrimitives : object {
    private static int StackallocThreshold;
    public static int ParseLength(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static UInt32 ParseTag(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static bool MaybeConsumeTag(ReadOnlySpan`1& buffer, ParserInternalState& state, UInt32 tag);
    public static UInt32 PeekTag(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static ulong ParseRawVarint64(ReadOnlySpan`1& buffer, ParserInternalState& state);
    private static ulong ParseRawVarint64SlowPath(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static UInt32 ParseRawVarint32(ReadOnlySpan`1& buffer, ParserInternalState& state);
    private static UInt32 ParseRawVarint32SlowPath(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static UInt32 ParseRawLittleEndian32(ReadOnlySpan`1& buffer, ParserInternalState& state);
    private static UInt32 ParseRawLittleEndian32SlowPath(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static ulong ParseRawLittleEndian64(ReadOnlySpan`1& buffer, ParserInternalState& state);
    private static ulong ParseRawLittleEndian64SlowPath(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static double ParseDouble(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static float ParseFloat(ReadOnlySpan`1& buffer, ParserInternalState& state);
    private static float ParseFloatSlow(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static Byte[] ReadRawBytes(ReadOnlySpan`1& buffer, ParserInternalState& state, int size);
    private static Byte[] ReadRawBytesSlow(ReadOnlySpan`1& buffer, ParserInternalState& state, int size);
    public static void SkipRawBytes(ReadOnlySpan`1& buffer, ParserInternalState& state, int size);
    public static string ReadString(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static ByteString ReadBytes(ReadOnlySpan`1& buffer, ParserInternalState& state);
    [SecuritySafeCriticalAttribute]
public static string ReadRawString(ReadOnlySpan`1& buffer, ParserInternalState& state, int length);
    private static string ReadStringSlow(ReadOnlySpan`1& buffer, ParserInternalState& state, int length);
    private static void ValidateCurrentLimit(ReadOnlySpan`1& buffer, ParserInternalState& state, int size);
    [SecuritySafeCriticalAttribute]
private static byte ReadRawByte(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static UInt32 ReadRawVarint32(Stream input);
    public static int DecodeZigZag32(UInt32 n);
    public static long DecodeZigZag64(ulong n);
    public static bool IsDataAvailable(ParserInternalState& state, int size);
    private static bool IsDataAvailableInSource(ParserInternalState& state, int size);
    private static void ReadRawBytesIntoSpan(ReadOnlySpan`1& buffer, ParserInternalState& state, int length, Span`1<byte> byteSpan);
}
[SecuritySafeCriticalAttribute]
internal static class Google.Protobuf.ParsingPrimitivesMessages : object {
    private static Byte[] ZeroLengthMessageStreamData;
    private static ParsingPrimitivesMessages();
    public static void SkipLastField(ReadOnlySpan`1& buffer, ParserInternalState& state);
    public static void SkipGroup(ReadOnlySpan`1& buffer, ParserInternalState& state, UInt32 startGroupTag);
    public static void ReadMessage(ParseContext& ctx, IMessage message);
    public static KeyValuePair`2<TKey, TValue> ReadMapEntry(ParseContext& ctx, Codec<TKey, TValue> codec);
    public static void ReadGroup(ParseContext& ctx, IMessage message);
    public static void ReadGroup(ParseContext& ctx, int fieldNumber, UnknownFieldSet set);
    public static void ReadRawMessage(ParseContext& ctx, IMessage message);
    public static void CheckReadEndOfStreamTag(ParserInternalState& state);
    private static void CheckLastTagWas(ParserInternalState& state, UInt32 expectedTag);
}
[SecuritySafeCriticalAttribute]
internal static class Google.Protobuf.ParsingPrimitivesWrappers : object {
    internal static Nullable`1<float> ReadFloatWrapperLittleEndian(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<float> ReadFloatWrapperSlow(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<double> ReadDoubleWrapperLittleEndian(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<double> ReadDoubleWrapperSlow(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<bool> ReadBoolWrapper(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<UInt32> ReadUInt32Wrapper(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<UInt32> ReadUInt32WrapperSlow(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<int> ReadInt32Wrapper(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<ulong> ReadUInt64Wrapper(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<ulong> ReadUInt64WrapperSlow(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<long> ReadInt64Wrapper(ReadOnlySpan`1& buffer, ParserInternalState& state);
    internal static Nullable`1<float> ReadFloatWrapperLittleEndian(ParseContext& ctx);
    internal static Nullable`1<float> ReadFloatWrapperSlow(ParseContext& ctx);
    internal static Nullable`1<double> ReadDoubleWrapperLittleEndian(ParseContext& ctx);
    internal static Nullable`1<double> ReadDoubleWrapperSlow(ParseContext& ctx);
    internal static Nullable`1<bool> ReadBoolWrapper(ParseContext& ctx);
    internal static Nullable`1<UInt32> ReadUInt32Wrapper(ParseContext& ctx);
    internal static Nullable`1<int> ReadInt32Wrapper(ParseContext& ctx);
    internal static Nullable`1<ulong> ReadUInt64Wrapper(ParseContext& ctx);
    internal static Nullable`1<ulong> ReadUInt64WrapperSlow(ParseContext& ctx);
    internal static Nullable`1<long> ReadInt64Wrapper(ParseContext& ctx);
}
internal static class Google.Protobuf.ProtoPreconditions : object {
    public static T CheckNotNull(T value, string name);
    internal static T CheckNotNullUnconstrained(T value, string name);
}
[DebuggerDisplayAttribute("Count = {DebugCount}")]
[DebuggerTypeProxyAttribute("Google.Protobuf.Reflection.CustomOptions/CustomOptionsDebugView")]
public class Google.Protobuf.Reflection.CustomOptions : object {
    private static string UnreferencedCodeMessage;
    private static Object[] EmptyParameters;
    private IDictionary`2<int, IExtensionValue> values;
    private int DebugCount { get; }
    internal CustomOptions(IDictionary`2<int, IExtensionValue> values);
    private static CustomOptions();
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetBool(int field, Boolean& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetInt32(int field, Int32& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetInt64(int field, Int64& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetFixed32(int field, UInt32& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetFixed64(int field, UInt64& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetSFixed32(int field, Int32& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetSFixed64(int field, Int64& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetSInt32(int field, Int32& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetSInt64(int field, Int64& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetUInt32(int field, UInt32& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetUInt64(int field, UInt64& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetFloat(int field, Single& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetDouble(int field, Double& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetString(int field, String& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetBytes(int field, ByteString& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
public bool TryGetMessage(int field, T& value);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute("CustomOptions is incompatible with trimming.")]
private bool TryGetPrimitiveValue(int field, T& value);
    private int get_DebugCount();
}
[DebuggerDisplayAttribute("Type = {GetType().Name,nq}, FullName = {FullName}")]
public abstract class Google.Protobuf.Reflection.DescriptorBase : object {
    [CompilerGeneratedAttribute]
private FeatureSetDescriptor <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private FileDescriptor <File>k__BackingField;
    internal FeatureSetDescriptor Features { get; }
    public int Index { get; }
    public string Name { get; }
    public string FullName { get; }
    public FileDescriptor File { get; }
    public DescriptorDeclaration Declaration { get; }
    internal DescriptorBase(FileDescriptor file, string fullName, int index, FeatureSetDescriptor features);
    [CompilerGeneratedAttribute]
internal FeatureSetDescriptor get_Features();
    [CompilerGeneratedAttribute]
public int get_Index();
    public abstract virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual FileDescriptor get_File();
    public DescriptorDeclaration get_Declaration();
    internal virtual IReadOnlyList`1<DescriptorBase> GetNestedDescriptorListForField(int fieldNumber);
}
public class Google.Protobuf.Reflection.DescriptorDeclaration : object {
    [CompilerGeneratedAttribute]
private IDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeadingComments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TrailingComments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <LeadingDetachedComments>k__BackingField;
    public IDescriptor Descriptor { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public string LeadingComments { get; }
    public string TrailingComments { get; }
    public IReadOnlyList`1<string> LeadingDetachedComments { get; }
    private DescriptorDeclaration(IDescriptor descriptor, Location location);
    [CompilerGeneratedAttribute]
public IDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public string get_LeadingComments();
    [CompilerGeneratedAttribute]
public string get_TrailingComments();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_LeadingDetachedComments();
    internal static DescriptorDeclaration FromProto(IDescriptor descriptor, Location location);
}
internal class Google.Protobuf.Reflection.DescriptorPool : object {
    private IDictionary`2<string, IDescriptor> descriptorsByName;
    private IDictionary`2<ObjectIntPair`1<IDescriptor>, FieldDescriptor> fieldsByNumber;
    private IDictionary`2<ObjectIntPair`1<IDescriptor>, EnumValueDescriptor> enumValuesByNumber;
    private IDictionary`2<EnumValueByNameDescriptorKey, EnumValueDescriptor> enumValuesByName;
    private HashSet`1<FileDescriptor> dependencies;
    internal DescriptorPool(IEnumerable`1<FileDescriptor> dependencyFiles);
    private void ImportPublicDependencies(FileDescriptor file);
    internal T FindSymbol(string fullName);
    internal void AddPackage(string fullName, FileDescriptor file);
    internal void AddSymbol(IDescriptor descriptor);
    private static string GetDescriptorAlreadyAddedExceptionMessage(IDescriptor descriptor, string fullName, IDescriptor old);
    private static void ValidateSymbolName(IDescriptor descriptor);
    internal FieldDescriptor FindFieldByNumber(MessageDescriptor messageDescriptor, int number);
    internal EnumValueDescriptor FindEnumValueByNumber(EnumDescriptor enumDescriptor, int number);
    internal EnumValueDescriptor FindEnumValueByName(EnumDescriptor enumDescriptor, string name);
    internal void AddFieldByNumber(FieldDescriptor field);
    internal void AddEnumValue(EnumValueDescriptor enumValue);
    internal IDescriptor LookupSymbol(string name, IDescriptor relativeTo);
    [CompilerGeneratedAttribute]
internal static bool <ValidateSymbolName>g__IsAsciiLetter|11_0(char c);
    [CompilerGeneratedAttribute]
internal static bool <ValidateSymbolName>g__IsAsciiDigit|11_1(char c);
    [CompilerGeneratedAttribute]
internal static void <ValidateSymbolName>g__ThrowInvalidSymbolNameException|11_2(IDescriptor descriptor);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.DescriptorProto : object {
    private static MessageParser`1<DescriptorProto> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private static string NameDefaultValue;
    private string name_;
    public static int FieldFieldNumber;
    private static FieldCodec`1<FieldDescriptorProto> _repeated_field_codec;
    private RepeatedField`1<FieldDescriptorProto> field_;
    public static int ExtensionFieldNumber;
    private static FieldCodec`1<FieldDescriptorProto> _repeated_extension_codec;
    private RepeatedField`1<FieldDescriptorProto> extension_;
    public static int NestedTypeFieldNumber;
    private static FieldCodec`1<DescriptorProto> _repeated_nestedType_codec;
    private RepeatedField`1<DescriptorProto> nestedType_;
    public static int EnumTypeFieldNumber;
    private static FieldCodec`1<EnumDescriptorProto> _repeated_enumType_codec;
    private RepeatedField`1<EnumDescriptorProto> enumType_;
    public static int ExtensionRangeFieldNumber;
    private static FieldCodec`1<ExtensionRange> _repeated_extensionRange_codec;
    private RepeatedField`1<ExtensionRange> extensionRange_;
    public static int OneofDeclFieldNumber;
    private static FieldCodec`1<OneofDescriptorProto> _repeated_oneofDecl_codec;
    private RepeatedField`1<OneofDescriptorProto> oneofDecl_;
    public static int OptionsFieldNumber;
    private MessageOptions options_;
    public static int ReservedRangeFieldNumber;
    private static FieldCodec`1<ReservedRange> _repeated_reservedRange_codec;
    private RepeatedField`1<ReservedRange> reservedRange_;
    public static int ReservedNameFieldNumber;
    private static FieldCodec`1<string> _repeated_reservedName_codec;
    private RepeatedField`1<string> reservedName_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<DescriptorProto> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<FieldDescriptorProto> Field { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<FieldDescriptorProto> Extension { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<DescriptorProto> NestedType { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<EnumDescriptorProto> EnumType { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<ExtensionRange> ExtensionRange { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<OneofDescriptorProto> OneofDecl { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MessageOptions Options { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<ReservedRange> ReservedRange { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<string> ReservedName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public DescriptorProto(DescriptorProto other);
    private static DescriptorProto();
    public static MessageParser`1<DescriptorProto> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual DescriptorProto Clone();
    public string get_Name();
    public void set_Name(string value);
    public bool get_HasName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearName();
    public RepeatedField`1<FieldDescriptorProto> get_Field();
    public RepeatedField`1<FieldDescriptorProto> get_Extension();
    public RepeatedField`1<DescriptorProto> get_NestedType();
    public RepeatedField`1<EnumDescriptorProto> get_EnumType();
    public RepeatedField`1<ExtensionRange> get_ExtensionRange();
    public RepeatedField`1<OneofDescriptorProto> get_OneofDecl();
    public MessageOptions get_Options();
    public void set_Options(MessageOptions value);
    public RepeatedField`1<ReservedRange> get_ReservedRange();
    public RepeatedField`1<string> get_ReservedName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(DescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(DescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal static class Google.Protobuf.Reflection.DescriptorReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static DescriptorReflection();
    public static FileDescriptor get_Descriptor();
}
internal static class Google.Protobuf.Reflection.DescriptorUtil : object {
    internal static IList`1<TOutput> ConvertAndMakeReadOnly(IList`1<TInput> input, IndexedConverter`2<TInput, TOutput> converter);
}
internal class Google.Protobuf.Reflection.DescriptorValidationException : Exception {
    [CompilerGeneratedAttribute]
private string <ProblemSymbolName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string ProblemSymbolName { get; }
    public string Description { get; }
    internal DescriptorValidationException(IDescriptor problemDescriptor, string description);
    internal DescriptorValidationException(IDescriptor problemDescriptor, string description, Exception cause);
    [CompilerGeneratedAttribute]
public string get_ProblemSymbolName();
    [CompilerGeneratedAttribute]
public string get_Description();
}
public enum Google.Protobuf.Reflection.Edition : Enum {
    public int value__;
    [OriginalNameAttribute("EDITION_UNKNOWN")]
public static Edition Unknown;
    [OriginalNameAttribute("EDITION_LEGACY")]
public static Edition Legacy;
    [OriginalNameAttribute("EDITION_PROTO2")]
public static Edition Proto2;
    [OriginalNameAttribute("EDITION_PROTO3")]
public static Edition Proto3;
    [OriginalNameAttribute("EDITION_2023")]
public static Edition _2023;
    [OriginalNameAttribute("EDITION_2024")]
public static Edition _2024;
    [OriginalNameAttribute("EDITION_1_TEST_ONLY")]
public static Edition _1TestOnly;
    [OriginalNameAttribute("EDITION_2_TEST_ONLY")]
public static Edition _2TestOnly;
    [OriginalNameAttribute("EDITION_99997_TEST_ONLY")]
public static Edition _99997TestOnly;
    [OriginalNameAttribute("EDITION_99998_TEST_ONLY")]
public static Edition _99998TestOnly;
    [OriginalNameAttribute("EDITION_99999_TEST_ONLY")]
public static Edition _99999TestOnly;
    [OriginalNameAttribute("EDITION_MAX")]
public static Edition Max;
}
public class Google.Protobuf.Reflection.EnumDescriptor : DescriptorBase {
    [CompilerGeneratedAttribute]
private EnumDescriptorProto <Proto>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ClrType>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDescriptor <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<EnumValueDescriptor> <Values>k__BackingField;
    internal EnumDescriptorProto Proto { get; }
    public string Name { get; }
    public Type ClrType { get; }
    public MessageDescriptor ContainingType { get; }
    public IList`1<EnumValueDescriptor> Values { get; }
    [ObsoleteAttribute("CustomOptions are obsolete. Use the GetOptions() method.")]
public CustomOptions CustomOptions { get; }
    internal EnumDescriptor(EnumDescriptorProto proto, FileDescriptor file, MessageDescriptor parent, int index, Type clrType);
    [CompilerGeneratedAttribute]
internal EnumDescriptorProto get_Proto();
    public EnumDescriptorProto ToProto();
    public virtual string get_Name();
    internal virtual IReadOnlyList`1<DescriptorBase> GetNestedDescriptorListForField(int fieldNumber);
    [CompilerGeneratedAttribute]
public Type get_ClrType();
    [CompilerGeneratedAttribute]
public MessageDescriptor get_ContainingType();
    [CompilerGeneratedAttribute]
public IList`1<EnumValueDescriptor> get_Values();
    public EnumValueDescriptor FindValueByNumber(int number);
    public EnumValueDescriptor FindValueByName(string name);
    public CustomOptions get_CustomOptions();
    public EnumOptions GetOptions();
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public T GetOption(Extension`2<EnumOptions, T> extension);
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public RepeatedField`1<T> GetOption(RepeatedExtension`2<EnumOptions, T> extension);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.EnumDescriptorProto : object {
    private static MessageParser`1<EnumDescriptorProto> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private static string NameDefaultValue;
    private string name_;
    public static int ValueFieldNumber;
    private static FieldCodec`1<EnumValueDescriptorProto> _repeated_value_codec;
    private RepeatedField`1<EnumValueDescriptorProto> value_;
    public static int OptionsFieldNumber;
    private EnumOptions options_;
    public static int ReservedRangeFieldNumber;
    private static FieldCodec`1<EnumReservedRange> _repeated_reservedRange_codec;
    private RepeatedField`1<EnumReservedRange> reservedRange_;
    public static int ReservedNameFieldNumber;
    private static FieldCodec`1<string> _repeated_reservedName_codec;
    private RepeatedField`1<string> reservedName_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<EnumDescriptorProto> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<EnumValueDescriptorProto> Value { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public EnumOptions Options { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<EnumReservedRange> ReservedRange { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<string> ReservedName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public EnumDescriptorProto(EnumDescriptorProto other);
    private static EnumDescriptorProto();
    public static MessageParser`1<EnumDescriptorProto> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual EnumDescriptorProto Clone();
    public string get_Name();
    public void set_Name(string value);
    public bool get_HasName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearName();
    public RepeatedField`1<EnumValueDescriptorProto> get_Value();
    public EnumOptions get_Options();
    public void set_Options(EnumOptions value);
    public RepeatedField`1<EnumReservedRange> get_ReservedRange();
    public RepeatedField`1<string> get_ReservedName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(EnumDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(EnumDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.EnumOptions : object {
    private static MessageParser`1<EnumOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<EnumOptions> _extensions;
    private int _hasBits0;
    public static int AllowAliasFieldNumber;
    private static bool AllowAliasDefaultValue;
    private bool allowAlias_;
    public static int DeprecatedFieldNumber;
    private static bool DeprecatedDefaultValue;
    private bool deprecated_;
    public static int DeprecatedLegacyJsonFieldConflictsFieldNumber;
    private static bool DeprecatedLegacyJsonFieldConflictsDefaultValue;
    private bool deprecatedLegacyJsonFieldConflicts_;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    private ExtensionSet`1<EnumOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<EnumOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool AllowAlias { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasAllowAlias { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Deprecated { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecated { get; }
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool DeprecatedLegacyJsonFieldConflicts { get; public set; }
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecatedLegacyJsonFieldConflicts { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public EnumOptions(EnumOptions other);
    private static EnumOptions();
    private ExtensionSet`1<EnumOptions> get__Extensions();
    public static MessageParser`1<EnumOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual EnumOptions Clone();
    public bool get_AllowAlias();
    public void set_AllowAlias(bool value);
    public bool get_HasAllowAlias();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearAllowAlias();
    public bool get_Deprecated();
    public void set_Deprecated(bool value);
    public bool get_HasDeprecated();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecated();
    public bool get_DeprecatedLegacyJsonFieldConflicts();
    public void set_DeprecatedLegacyJsonFieldConflicts(bool value);
    public bool get_HasDeprecatedLegacyJsonFieldConflicts();
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecatedLegacyJsonFieldConflicts();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(EnumOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(EnumOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<EnumOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<EnumOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<EnumOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<EnumOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<EnumOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<EnumOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<EnumOptions, TValue> extension);
}
public class Google.Protobuf.Reflection.EnumValueDescriptor : DescriptorBase {
    [CompilerGeneratedAttribute]
private EnumValueDescriptorProto <Proto>k__BackingField;
    [CompilerGeneratedAttribute]
private EnumDescriptor <EnumDescriptor>k__BackingField;
    internal EnumValueDescriptorProto Proto { get; }
    public string Name { get; }
    public int Number { get; }
    public EnumDescriptor EnumDescriptor { get; }
    [ObsoleteAttribute("CustomOptions are obsolete. Use the GetOptions() method.")]
public CustomOptions CustomOptions { get; }
    internal EnumValueDescriptor(EnumValueDescriptorProto proto, FileDescriptor file, EnumDescriptor parent, int index);
    [CompilerGeneratedAttribute]
internal EnumValueDescriptorProto get_Proto();
    public EnumValueDescriptorProto ToProto();
    public virtual string get_Name();
    public int get_Number();
    [CompilerGeneratedAttribute]
public EnumDescriptor get_EnumDescriptor();
    public CustomOptions get_CustomOptions();
    public EnumValueOptions GetOptions();
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public T GetOption(Extension`2<EnumValueOptions, T> extension);
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public RepeatedField`1<T> GetOption(RepeatedExtension`2<EnumValueOptions, T> extension);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.EnumValueDescriptorProto : object {
    private static MessageParser`1<EnumValueDescriptorProto> _parser;
    private UnknownFieldSet _unknownFields;
    private int _hasBits0;
    public static int NameFieldNumber;
    private static string NameDefaultValue;
    private string name_;
    public static int NumberFieldNumber;
    private static int NumberDefaultValue;
    private int number_;
    public static int OptionsFieldNumber;
    private EnumValueOptions options_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<EnumValueDescriptorProto> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Number { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasNumber { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public EnumValueOptions Options { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public EnumValueDescriptorProto(EnumValueDescriptorProto other);
    private static EnumValueDescriptorProto();
    public static MessageParser`1<EnumValueDescriptorProto> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual EnumValueDescriptorProto Clone();
    public string get_Name();
    public void set_Name(string value);
    public bool get_HasName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearName();
    public int get_Number();
    public void set_Number(int value);
    public bool get_HasNumber();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearNumber();
    public EnumValueOptions get_Options();
    public void set_Options(EnumValueOptions value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(EnumValueDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(EnumValueDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.EnumValueOptions : object {
    private static MessageParser`1<EnumValueOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<EnumValueOptions> _extensions;
    private int _hasBits0;
    public static int DeprecatedFieldNumber;
    private static bool DeprecatedDefaultValue;
    private bool deprecated_;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int DebugRedactFieldNumber;
    private static bool DebugRedactDefaultValue;
    private bool debugRedact_;
    public static int FeatureSupportFieldNumber;
    private FeatureSupport featureSupport_;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    private ExtensionSet`1<EnumValueOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<EnumValueOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Deprecated { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecated { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool DebugRedact { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDebugRedact { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSupport FeatureSupport { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public EnumValueOptions(EnumValueOptions other);
    private static EnumValueOptions();
    private ExtensionSet`1<EnumValueOptions> get__Extensions();
    public static MessageParser`1<EnumValueOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual EnumValueOptions Clone();
    public bool get_Deprecated();
    public void set_Deprecated(bool value);
    public bool get_HasDeprecated();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecated();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public bool get_DebugRedact();
    public void set_DebugRedact(bool value);
    public bool get_HasDebugRedact();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDebugRedact();
    public FeatureSupport get_FeatureSupport();
    public void set_FeatureSupport(FeatureSupport value);
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(EnumValueOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(EnumValueOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<EnumValueOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<EnumValueOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<EnumValueOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<EnumValueOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<EnumValueOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<EnumValueOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<EnumValueOptions, TValue> extension);
}
internal class Google.Protobuf.Reflection.ExtensionAccessor : object {
    private Extension extension;
    private IExtensionReflectionHelper helper;
    [CompilerGeneratedAttribute]
private FieldDescriptor <Descriptor>k__BackingField;
    public FieldDescriptor Descriptor { get; }
    internal ExtensionAccessor(FieldDescriptor descriptor);
    [CompilerGeneratedAttribute]
public sealed virtual FieldDescriptor get_Descriptor();
    public sealed virtual void Clear(IMessage message);
    public sealed virtual bool HasValue(IMessage message);
    public sealed virtual object GetValue(IMessage message);
    public sealed virtual void SetValue(IMessage message, object value);
}
[DebuggerDisplayAttribute("Count = {UnorderedExtensions.Count}")]
[DebuggerTypeProxyAttribute("Google.Protobuf.Reflection.ExtensionCollection/ExtensionCollectionDebugView")]
public class Google.Protobuf.Reflection.ExtensionCollection : object {
    private IDictionary`2<MessageDescriptor, IList`1<FieldDescriptor>> extensionsByTypeInDeclarationOrder;
    private IDictionary`2<MessageDescriptor, IList`1<FieldDescriptor>> extensionsByTypeInNumberOrder;
    [CompilerGeneratedAttribute]
private IList`1<FieldDescriptor> <UnorderedExtensions>k__BackingField;
    public IList`1<FieldDescriptor> UnorderedExtensions { get; }
    internal ExtensionCollection(FileDescriptor file, Extension[] extensions);
    internal ExtensionCollection(MessageDescriptor message, Extension[] extensions);
    [CompilerGeneratedAttribute]
public IList`1<FieldDescriptor> get_UnorderedExtensions();
    public IList`1<FieldDescriptor> GetExtensionsInDeclarationOrder(MessageDescriptor descriptor);
    public IList`1<FieldDescriptor> GetExtensionsInNumberOrder(MessageDescriptor descriptor);
    internal void CrossLink();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.ExtensionRangeOptions : object {
    private static MessageParser`1<ExtensionRangeOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<ExtensionRangeOptions> _extensions;
    private int _hasBits0;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    public static int DeclarationFieldNumber;
    private static FieldCodec`1<Declaration> _repeated_declaration_codec;
    private RepeatedField`1<Declaration> declaration_;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int VerificationFieldNumber;
    private static VerificationState VerificationDefaultValue;
    private VerificationState verification_;
    private ExtensionSet`1<ExtensionRangeOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<ExtensionRangeOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Declaration> Declaration { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public VerificationState Verification { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasVerification { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ExtensionRangeOptions(ExtensionRangeOptions other);
    private static ExtensionRangeOptions();
    private ExtensionSet`1<ExtensionRangeOptions> get__Extensions();
    public static MessageParser`1<ExtensionRangeOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual ExtensionRangeOptions Clone();
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    public RepeatedField`1<Declaration> get_Declaration();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public VerificationState get_Verification();
    public void set_Verification(VerificationState value);
    public bool get_HasVerification();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearVerification();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(ExtensionRangeOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(ExtensionRangeOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<ExtensionRangeOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<ExtensionRangeOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<ExtensionRangeOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<ExtensionRangeOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<ExtensionRangeOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<ExtensionRangeOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<ExtensionRangeOptions, TValue> extension);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.FeatureSet : object {
    private static MessageParser`1<FeatureSet> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<FeatureSet> _extensions;
    private int _hasBits0;
    public static int FieldPresenceFieldNumber;
    private static FieldPresence FieldPresenceDefaultValue;
    private FieldPresence fieldPresence_;
    public static int EnumTypeFieldNumber;
    private static EnumType EnumTypeDefaultValue;
    private EnumType enumType_;
    public static int RepeatedFieldEncodingFieldNumber;
    private static RepeatedFieldEncoding RepeatedFieldEncodingDefaultValue;
    private RepeatedFieldEncoding repeatedFieldEncoding_;
    public static int Utf8ValidationFieldNumber;
    private static Utf8Validation Utf8ValidationDefaultValue;
    private Utf8Validation utf8Validation_;
    public static int MessageEncodingFieldNumber;
    private static MessageEncoding MessageEncodingDefaultValue;
    private MessageEncoding messageEncoding_;
    public static int JsonFormatFieldNumber;
    private static JsonFormat JsonFormatDefaultValue;
    private JsonFormat jsonFormat_;
    private ExtensionSet`1<FeatureSet> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FeatureSet> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FieldPresence FieldPresence { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasFieldPresence { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public EnumType EnumType { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasEnumType { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedFieldEncoding RepeatedFieldEncoding { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasRepeatedFieldEncoding { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Utf8Validation Utf8Validation { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasUtf8Validation { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MessageEncoding MessageEncoding { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMessageEncoding { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public JsonFormat JsonFormat { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJsonFormat { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet(FeatureSet other);
    private static FeatureSet();
    private ExtensionSet`1<FeatureSet> get__Extensions();
    public static MessageParser`1<FeatureSet> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FeatureSet Clone();
    public FieldPresence get_FieldPresence();
    public void set_FieldPresence(FieldPresence value);
    public bool get_HasFieldPresence();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearFieldPresence();
    public EnumType get_EnumType();
    public void set_EnumType(EnumType value);
    public bool get_HasEnumType();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearEnumType();
    public RepeatedFieldEncoding get_RepeatedFieldEncoding();
    public void set_RepeatedFieldEncoding(RepeatedFieldEncoding value);
    public bool get_HasRepeatedFieldEncoding();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearRepeatedFieldEncoding();
    public Utf8Validation get_Utf8Validation();
    public void set_Utf8Validation(Utf8Validation value);
    public bool get_HasUtf8Validation();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearUtf8Validation();
    public MessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(MessageEncoding value);
    public bool get_HasMessageEncoding();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMessageEncoding();
    public JsonFormat get_JsonFormat();
    public void set_JsonFormat(JsonFormat value);
    public bool get_HasJsonFormat();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJsonFormat();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FeatureSet other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FeatureSet other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<FeatureSet, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<FeatureSet, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<FeatureSet, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<FeatureSet, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<FeatureSet, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<FeatureSet, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<FeatureSet, TValue> extension);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.Reflection.FeatureSetDefaults : object {
    private static MessageParser`1<FeatureSetDefaults> _parser;
    private UnknownFieldSet _unknownFields;
    private int _hasBits0;
    public static int DefaultsFieldNumber;
    private static FieldCodec`1<FeatureSetEditionDefault> _repeated_defaults_codec;
    private RepeatedField`1<FeatureSetEditionDefault> defaults_;
    public static int MinimumEditionFieldNumber;
    private static Edition MinimumEditionDefaultValue;
    private Edition minimumEdition_;
    public static int MaximumEditionFieldNumber;
    private static Edition MaximumEditionDefaultValue;
    private Edition maximumEdition_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FeatureSetDefaults> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<FeatureSetEditionDefault> Defaults { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Edition MinimumEdition { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMinimumEdition { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Edition MaximumEdition { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMaximumEdition { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSetDefaults(FeatureSetDefaults other);
    private static FeatureSetDefaults();
    public static MessageParser`1<FeatureSetDefaults> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FeatureSetDefaults Clone();
    public RepeatedField`1<FeatureSetEditionDefault> get_Defaults();
    public Edition get_MinimumEdition();
    public void set_MinimumEdition(Edition value);
    public bool get_HasMinimumEdition();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMinimumEdition();
    public Edition get_MaximumEdition();
    public void set_MaximumEdition(Edition value);
    public bool get_HasMaximumEdition();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMaximumEdition();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FeatureSetDefaults other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FeatureSetDefaults other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal class Google.Protobuf.Reflection.FeatureSetDescriptor : object {
    private static ConcurrentDictionary`2<FeatureSet, FeatureSetDescriptor> cache;
    private static FeatureSetDescriptor edition2023Defaults;
    private static FeatureSetDescriptor proto2Defaults;
    private static FeatureSetDescriptor proto3Defaults;
    [CompilerGeneratedAttribute]
private FeatureSet <Proto>k__BackingField;
    internal FeatureSet Proto { get; }
    internal FieldPresence FieldPresence { get; }
    internal RepeatedFieldEncoding RepeatedFieldEncoding { get; }
    internal MessageEncoding MessageEncoding { get; }
    private FeatureSetDescriptor(FeatureSet proto);
    private static FeatureSetDescriptor();
    internal static FeatureSetDescriptor GetEditionDefaults(Edition edition);
    [CompilerGeneratedAttribute]
internal FeatureSet get_Proto();
    internal FieldPresence get_FieldPresence();
    internal RepeatedFieldEncoding get_RepeatedFieldEncoding();
    internal MessageEncoding get_MessageEncoding();
    public FeatureSetDescriptor MergedWith(FeatureSet overrides);
}
internal abstract class Google.Protobuf.Reflection.FieldAccessorBase : object {
    private Func`2<IMessage, object> getValueDelegate;
    [CompilerGeneratedAttribute]
private FieldDescriptor <Descriptor>k__BackingField;
    public FieldDescriptor Descriptor { get; }
    internal FieldAccessorBase(PropertyInfo property, FieldDescriptor descriptor);
    [CompilerGeneratedAttribute]
public sealed virtual FieldDescriptor get_Descriptor();
    public sealed virtual object GetValue(IMessage message);
    public abstract virtual bool HasValue(IMessage message);
    public abstract virtual void Clear(IMessage message);
    public abstract virtual void SetValue(IMessage message, object value);
}
public class Google.Protobuf.Reflection.FieldDescriptor : DescriptorBase {
    private EnumDescriptor enumType;
    private MessageDescriptor extendeeType;
    private MessageDescriptor messageType;
    private IFieldAccessor accessor;
    [CompilerGeneratedAttribute]
private MessageDescriptor <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private OneofDescriptor <ContainingOneof>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JsonName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldDescriptorProto <Proto>k__BackingField;
    [CompilerGeneratedAttribute]
private Extension <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldType <FieldType>k__BackingField;
    public MessageDescriptor ContainingType { get; }
    public OneofDescriptor ContainingOneof { get; }
    public OneofDescriptor RealContainingOneof { get; }
    public string JsonName { get; }
    public string PropertyName { get; }
    public bool HasPresence { get; }
    internal FieldDescriptorProto Proto { get; }
    public Extension Extension { get; }
    public string Name { get; }
    public IFieldAccessor Accessor { get; }
    public bool IsRepeated { get; }
    public bool IsRequired { get; }
    public bool IsMap { get; }
    public bool IsPacked { get; }
    public bool IsExtension { get; }
    public FieldType FieldType { get; private set; }
    public int FieldNumber { get; }
    public EnumDescriptor EnumType { get; }
    public MessageDescriptor MessageType { get; }
    public MessageDescriptor ExtendeeType { get; }
    [ObsoleteAttribute("CustomOptions are obsolete. Use the GetOptions() method.")]
public CustomOptions CustomOptions { get; }
    internal FieldDescriptor(FieldDescriptorProto proto, FileDescriptor file, MessageDescriptor parent, int index, string propertyName, Extension extension);
    [CompilerGeneratedAttribute]
public MessageDescriptor get_ContainingType();
    [CompilerGeneratedAttribute]
public OneofDescriptor get_ContainingOneof();
    public OneofDescriptor get_RealContainingOneof();
    [CompilerGeneratedAttribute]
public string get_JsonName();
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    public bool get_HasPresence();
    [CompilerGeneratedAttribute]
internal FieldDescriptorProto get_Proto();
    public FieldDescriptorProto ToProto();
    [CompilerGeneratedAttribute]
public Extension get_Extension();
    private static FeatureSetDescriptor GetDirectParentFeatures(FieldDescriptorProto proto, FileDescriptor file, MessageDescriptor parent);
    private static FeatureSet InferFeatures(FileDescriptor file, FieldDescriptorProto proto);
    public virtual string get_Name();
    public IFieldAccessor get_Accessor();
    private static FieldType GetFieldTypeFromProtoType(Type type);
    public bool get_IsRepeated();
    public bool get_IsRequired();
    public bool get_IsMap();
    public bool get_IsPacked();
    public bool get_IsExtension();
    [CompilerGeneratedAttribute]
public FieldType get_FieldType();
    [CompilerGeneratedAttribute]
private void set_FieldType(FieldType value);
    public int get_FieldNumber();
    public sealed virtual int CompareTo(FieldDescriptor other);
    public EnumDescriptor get_EnumType();
    public MessageDescriptor get_MessageType();
    public MessageDescriptor get_ExtendeeType();
    public CustomOptions get_CustomOptions();
    public FieldOptions GetOptions();
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public T GetOption(Extension`2<FieldOptions, T> extension);
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public RepeatedField`1<T> GetOption(RepeatedExtension`2<FieldOptions, T> extension);
    internal void CrossLink();
    private IFieldAccessor CreateAccessor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.FieldDescriptorProto : object {
    private static MessageParser`1<FieldDescriptorProto> _parser;
    private UnknownFieldSet _unknownFields;
    private int _hasBits0;
    public static int NameFieldNumber;
    private static string NameDefaultValue;
    private string name_;
    public static int NumberFieldNumber;
    private static int NumberDefaultValue;
    private int number_;
    public static int LabelFieldNumber;
    private static Label LabelDefaultValue;
    private Label label_;
    public static int TypeFieldNumber;
    private static Type TypeDefaultValue;
    private Type type_;
    public static int TypeNameFieldNumber;
    private static string TypeNameDefaultValue;
    private string typeName_;
    public static int ExtendeeFieldNumber;
    private static string ExtendeeDefaultValue;
    private string extendee_;
    public static int DefaultValueFieldNumber;
    private static string DefaultValueDefaultValue;
    private string defaultValue_;
    public static int OneofIndexFieldNumber;
    private static int OneofIndexDefaultValue;
    private int oneofIndex_;
    public static int JsonNameFieldNumber;
    private static string JsonNameDefaultValue;
    private string jsonName_;
    public static int OptionsFieldNumber;
    private FieldOptions options_;
    public static int Proto3OptionalFieldNumber;
    private static bool Proto3OptionalDefaultValue;
    private bool proto3Optional_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FieldDescriptorProto> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Number { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasNumber { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Label Label { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasLabel { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Type Type { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasType { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string TypeName { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasTypeName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Extendee { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasExtendee { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string DefaultValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDefaultValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int OneofIndex { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasOneofIndex { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string JsonName { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJsonName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FieldOptions Options { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Proto3Optional { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasProto3Optional { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FieldDescriptorProto(FieldDescriptorProto other);
    private static FieldDescriptorProto();
    public static MessageParser`1<FieldDescriptorProto> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FieldDescriptorProto Clone();
    public string get_Name();
    public void set_Name(string value);
    public bool get_HasName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearName();
    public int get_Number();
    public void set_Number(int value);
    public bool get_HasNumber();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearNumber();
    public Label get_Label();
    public void set_Label(Label value);
    public bool get_HasLabel();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearLabel();
    public Type get_Type();
    public void set_Type(Type value);
    public bool get_HasType();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearType();
    public string get_TypeName();
    public void set_TypeName(string value);
    public bool get_HasTypeName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearTypeName();
    public string get_Extendee();
    public void set_Extendee(string value);
    public bool get_HasExtendee();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearExtendee();
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public bool get_HasDefaultValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDefaultValue();
    public int get_OneofIndex();
    public void set_OneofIndex(int value);
    public bool get_HasOneofIndex();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearOneofIndex();
    public string get_JsonName();
    public void set_JsonName(string value);
    public bool get_HasJsonName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJsonName();
    public FieldOptions get_Options();
    public void set_Options(FieldOptions value);
    public bool get_Proto3Optional();
    public void set_Proto3Optional(bool value);
    public bool get_HasProto3Optional();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearProto3Optional();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FieldDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FieldDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.FieldOptions : object {
    private static MessageParser`1<FieldOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<FieldOptions> _extensions;
    private int _hasBits0;
    public static int CtypeFieldNumber;
    private static CType CtypeDefaultValue;
    private CType ctype_;
    public static int PackedFieldNumber;
    private static bool PackedDefaultValue;
    private bool packed_;
    public static int JstypeFieldNumber;
    private static JSType JstypeDefaultValue;
    private JSType jstype_;
    public static int LazyFieldNumber;
    private static bool LazyDefaultValue;
    private bool lazy_;
    public static int UnverifiedLazyFieldNumber;
    private static bool UnverifiedLazyDefaultValue;
    private bool unverifiedLazy_;
    public static int DeprecatedFieldNumber;
    private static bool DeprecatedDefaultValue;
    private bool deprecated_;
    public static int WeakFieldNumber;
    private static bool WeakDefaultValue;
    private bool weak_;
    public static int DebugRedactFieldNumber;
    private static bool DebugRedactDefaultValue;
    private bool debugRedact_;
    public static int RetentionFieldNumber;
    private static OptionRetention RetentionDefaultValue;
    private OptionRetention retention_;
    public static int TargetsFieldNumber;
    private static FieldCodec`1<OptionTargetType> _repeated_targets_codec;
    private RepeatedField`1<OptionTargetType> targets_;
    public static int EditionDefaultsFieldNumber;
    private static FieldCodec`1<EditionDefault> _repeated_editionDefaults_codec;
    private RepeatedField`1<EditionDefault> editionDefaults_;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int FeatureSupportFieldNumber;
    private FeatureSupport featureSupport_;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    private ExtensionSet`1<FieldOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FieldOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public CType Ctype { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasCtype { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Packed { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasPacked { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public JSType Jstype { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJstype { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Lazy { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasLazy { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool UnverifiedLazy { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasUnverifiedLazy { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Deprecated { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecated { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Weak { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasWeak { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool DebugRedact { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDebugRedact { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public OptionRetention Retention { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasRetention { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<OptionTargetType> Targets { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<EditionDefault> EditionDefaults { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSupport FeatureSupport { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FieldOptions(FieldOptions other);
    private static FieldOptions();
    private ExtensionSet`1<FieldOptions> get__Extensions();
    public static MessageParser`1<FieldOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FieldOptions Clone();
    public CType get_Ctype();
    public void set_Ctype(CType value);
    public bool get_HasCtype();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearCtype();
    public bool get_Packed();
    public void set_Packed(bool value);
    public bool get_HasPacked();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearPacked();
    public JSType get_Jstype();
    public void set_Jstype(JSType value);
    public bool get_HasJstype();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJstype();
    public bool get_Lazy();
    public void set_Lazy(bool value);
    public bool get_HasLazy();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearLazy();
    public bool get_UnverifiedLazy();
    public void set_UnverifiedLazy(bool value);
    public bool get_HasUnverifiedLazy();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearUnverifiedLazy();
    public bool get_Deprecated();
    public void set_Deprecated(bool value);
    public bool get_HasDeprecated();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecated();
    public bool get_Weak();
    public void set_Weak(bool value);
    public bool get_HasWeak();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearWeak();
    public bool get_DebugRedact();
    public void set_DebugRedact(bool value);
    public bool get_HasDebugRedact();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDebugRedact();
    public OptionRetention get_Retention();
    public void set_Retention(OptionRetention value);
    public bool get_HasRetention();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearRetention();
    public RepeatedField`1<OptionTargetType> get_Targets();
    public RepeatedField`1<EditionDefault> get_EditionDefaults();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public FeatureSupport get_FeatureSupport();
    public void set_FeatureSupport(FeatureSupport value);
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FieldOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FieldOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<FieldOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<FieldOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<FieldOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<FieldOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<FieldOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<FieldOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<FieldOptions, TValue> extension);
}
public enum Google.Protobuf.Reflection.FieldType : Enum {
    public int value__;
    public static FieldType Double;
    public static FieldType Float;
    public static FieldType Int64;
    public static FieldType UInt64;
    public static FieldType Int32;
    public static FieldType Fixed64;
    public static FieldType Fixed32;
    public static FieldType Bool;
    public static FieldType String;
    public static FieldType Group;
    public static FieldType Message;
    public static FieldType Bytes;
    public static FieldType UInt32;
    public static FieldType SFixed32;
    public static FieldType SFixed64;
    public static FieldType SInt32;
    public static FieldType SInt64;
    public static FieldType Enum;
}
public class Google.Protobuf.Reflection.FileDescriptor : object {
    private Lazy`1<Dictionary`2<IDescriptor, DescriptorDeclaration>> declarations;
    [CompilerGeneratedAttribute]
private FileDescriptorProto <Proto>k__BackingField;
    [CompilerGeneratedAttribute]
private FeatureSetDescriptor <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MessageDescriptor> <MessageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<EnumDescriptor> <EnumTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ServiceDescriptor> <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionCollection <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FileDescriptor> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FileDescriptor> <PublicDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private ByteString <SerializedData>k__BackingField;
    [CompilerGeneratedAttribute]
private DescriptorPool <DescriptorPool>k__BackingField;
    internal FileDescriptorProto Proto { get; }
    internal FeatureSetDescriptor Features { get; }
    internal Edition Edition { get; }
    [ObsoleteAttribute("Use features instead of proto syntax.")]
public Syntax Syntax { get; }
    public string Name { get; }
    public string Package { get; }
    public IList`1<MessageDescriptor> MessageTypes { get; }
    public IList`1<EnumDescriptor> EnumTypes { get; }
    public IList`1<ServiceDescriptor> Services { get; }
    public ExtensionCollection Extensions { get; }
    public IList`1<FileDescriptor> Dependencies { get; }
    public IList`1<FileDescriptor> PublicDependencies { get; }
    public ByteString SerializedData { get; }
    private string Google.Protobuf.Reflection.IDescriptor.FullName { get; }
    private FileDescriptor Google.Protobuf.Reflection.IDescriptor.File { get; }
    internal DescriptorPool DescriptorPool { get; }
    public static FileDescriptor DescriptorProtoFileDescriptor { get; }
    [ObsoleteAttribute("CustomOptions are obsolete. Use the GetOptions() method.")]
public CustomOptions CustomOptions { get; }
    private static FileDescriptor();
    private FileDescriptor(ByteString descriptorData, FileDescriptorProto proto, IEnumerable`1<FileDescriptor> dependencies, DescriptorPool pool, bool allowUnknownDependencies, GeneratedClrTypeInfo generatedCodeInfo);
    private Dictionary`2<IDescriptor, DescriptorDeclaration> CreateDeclarationMap();
    private IDescriptor FindDescriptorForPath(IList`1<int> path);
    private DescriptorBase GetDescriptorFromList(IReadOnlyList`1<DescriptorBase> list, int index);
    private IReadOnlyList`1<DescriptorBase> GetNestedDescriptorListForField(int fieldNumber);
    internal DescriptorDeclaration GetDeclaration(IDescriptor descriptor);
    internal string ComputeFullName(MessageDescriptor parent, string name);
    private static IList`1<FileDescriptor> DeterminePublicDependencies(FileDescriptor this, FileDescriptorProto proto, IEnumerable`1<FileDescriptor> dependencies, bool allowUnknownDependencies);
    [CompilerGeneratedAttribute]
internal FileDescriptorProto get_Proto();
    public FileDescriptorProto ToProto();
    [CompilerGeneratedAttribute]
internal FeatureSetDescriptor get_Features();
    internal Edition get_Edition();
    public Syntax get_Syntax();
    public sealed virtual string get_Name();
    public string get_Package();
    [CompilerGeneratedAttribute]
public IList`1<MessageDescriptor> get_MessageTypes();
    [CompilerGeneratedAttribute]
public IList`1<EnumDescriptor> get_EnumTypes();
    [CompilerGeneratedAttribute]
public IList`1<ServiceDescriptor> get_Services();
    [CompilerGeneratedAttribute]
public ExtensionCollection get_Extensions();
    [CompilerGeneratedAttribute]
public IList`1<FileDescriptor> get_Dependencies();
    [CompilerGeneratedAttribute]
public IList`1<FileDescriptor> get_PublicDependencies();
    [CompilerGeneratedAttribute]
public ByteString get_SerializedData();
    private sealed virtual override string Google.Protobuf.Reflection.IDescriptor.get_FullName();
    private sealed virtual override FileDescriptor Google.Protobuf.Reflection.IDescriptor.get_File();
    [CompilerGeneratedAttribute]
internal DescriptorPool get_DescriptorPool();
    public T FindTypeByName(string name);
    private static FileDescriptor BuildFrom(ByteString descriptorData, FileDescriptorProto proto, FileDescriptor[] dependencies, bool allowUnknownDependencies, GeneratedClrTypeInfo generatedCodeInfo);
    private void CrossLink();
    public static FileDescriptor FromGeneratedCode(Byte[] descriptorData, FileDescriptor[] dependencies, GeneratedClrTypeInfo generatedCodeInfo);
    private static IEnumerable`1<Extension> GetAllExtensions(FileDescriptor[] dependencies, GeneratedClrTypeInfo generatedInfo);
    private static IEnumerable`1<Extension> GetAllGeneratedExtensions(GeneratedClrTypeInfo generated);
    private static IEnumerable`1<Extension> GetAllDependedExtensions(FileDescriptor descriptor);
    private static IEnumerable`1<Extension> GetAllDependedExtensionsFromMessage(MessageDescriptor descriptor);
    public static IReadOnlyList`1<FileDescriptor> BuildFromByteStrings(IEnumerable`1<ByteString> descriptorData, ExtensionRegistry registry);
    public static IReadOnlyList`1<FileDescriptor> BuildFromByteStrings(IEnumerable`1<ByteString> descriptorData);
    public virtual string ToString();
    public static FileDescriptor get_DescriptorProtoFileDescriptor();
    public CustomOptions get_CustomOptions();
    public FileOptions GetOptions();
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public T GetOption(Extension`2<FileOptions, T> extension);
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public RepeatedField`1<T> GetOption(RepeatedExtension`2<FileOptions, T> extension);
    public static void ForceReflectionInitialization();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.FileDescriptorProto : object {
    private static MessageParser`1<FileDescriptorProto> _parser;
    private UnknownFieldSet _unknownFields;
    private int _hasBits0;
    public static int NameFieldNumber;
    private static string NameDefaultValue;
    private string name_;
    public static int PackageFieldNumber;
    private static string PackageDefaultValue;
    private string package_;
    public static int DependencyFieldNumber;
    private static FieldCodec`1<string> _repeated_dependency_codec;
    private RepeatedField`1<string> dependency_;
    public static int PublicDependencyFieldNumber;
    private static FieldCodec`1<int> _repeated_publicDependency_codec;
    private RepeatedField`1<int> publicDependency_;
    public static int WeakDependencyFieldNumber;
    private static FieldCodec`1<int> _repeated_weakDependency_codec;
    private RepeatedField`1<int> weakDependency_;
    public static int MessageTypeFieldNumber;
    private static FieldCodec`1<DescriptorProto> _repeated_messageType_codec;
    private RepeatedField`1<DescriptorProto> messageType_;
    public static int EnumTypeFieldNumber;
    private static FieldCodec`1<EnumDescriptorProto> _repeated_enumType_codec;
    private RepeatedField`1<EnumDescriptorProto> enumType_;
    public static int ServiceFieldNumber;
    private static FieldCodec`1<ServiceDescriptorProto> _repeated_service_codec;
    private RepeatedField`1<ServiceDescriptorProto> service_;
    public static int ExtensionFieldNumber;
    private static FieldCodec`1<FieldDescriptorProto> _repeated_extension_codec;
    private RepeatedField`1<FieldDescriptorProto> extension_;
    public static int OptionsFieldNumber;
    private FileOptions options_;
    public static int SourceCodeInfoFieldNumber;
    private SourceCodeInfo sourceCodeInfo_;
    public static int SyntaxFieldNumber;
    private static string SyntaxDefaultValue;
    private string syntax_;
    public static int EditionFieldNumber;
    private static Edition EditionDefaultValue;
    private Edition edition_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FileDescriptorProto> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Package { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasPackage { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<string> Dependency { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<int> PublicDependency { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<int> WeakDependency { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<DescriptorProto> MessageType { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<EnumDescriptorProto> EnumType { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<ServiceDescriptorProto> Service { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<FieldDescriptorProto> Extension { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FileOptions Options { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public SourceCodeInfo SourceCodeInfo { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Syntax { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasSyntax { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Edition Edition { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasEdition { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FileDescriptorProto(FileDescriptorProto other);
    private static FileDescriptorProto();
    public static MessageParser`1<FileDescriptorProto> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FileDescriptorProto Clone();
    public string get_Name();
    public void set_Name(string value);
    public bool get_HasName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearName();
    public string get_Package();
    public void set_Package(string value);
    public bool get_HasPackage();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearPackage();
    public RepeatedField`1<string> get_Dependency();
    public RepeatedField`1<int> get_PublicDependency();
    public RepeatedField`1<int> get_WeakDependency();
    public RepeatedField`1<DescriptorProto> get_MessageType();
    public RepeatedField`1<EnumDescriptorProto> get_EnumType();
    public RepeatedField`1<ServiceDescriptorProto> get_Service();
    public RepeatedField`1<FieldDescriptorProto> get_Extension();
    public FileOptions get_Options();
    public void set_Options(FileOptions value);
    public SourceCodeInfo get_SourceCodeInfo();
    public void set_SourceCodeInfo(SourceCodeInfo value);
    public string get_Syntax();
    public void set_Syntax(string value);
    public bool get_HasSyntax();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearSyntax();
    public Edition get_Edition();
    public void set_Edition(Edition value);
    public bool get_HasEdition();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearEdition();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FileDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FileDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.Reflection.FileDescriptorSet : object {
    private static MessageParser`1<FileDescriptorSet> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FileFieldNumber;
    private static FieldCodec`1<FileDescriptorProto> _repeated_file_codec;
    private RepeatedField`1<FileDescriptorProto> file_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FileDescriptorSet> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<FileDescriptorProto> File { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FileDescriptorSet(FileDescriptorSet other);
    private static FileDescriptorSet();
    public static MessageParser`1<FileDescriptorSet> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FileDescriptorSet Clone();
    public RepeatedField`1<FileDescriptorProto> get_File();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FileDescriptorSet other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FileDescriptorSet other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.FileOptions : object {
    private static MessageParser`1<FileOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<FileOptions> _extensions;
    private int _hasBits0;
    public static int JavaPackageFieldNumber;
    private static string JavaPackageDefaultValue;
    private string javaPackage_;
    public static int JavaOuterClassnameFieldNumber;
    private static string JavaOuterClassnameDefaultValue;
    private string javaOuterClassname_;
    public static int JavaMultipleFilesFieldNumber;
    private static bool JavaMultipleFilesDefaultValue;
    private bool javaMultipleFiles_;
    public static int JavaGenerateEqualsAndHashFieldNumber;
    private static bool JavaGenerateEqualsAndHashDefaultValue;
    private bool javaGenerateEqualsAndHash_;
    public static int JavaStringCheckUtf8FieldNumber;
    private static bool JavaStringCheckUtf8DefaultValue;
    private bool javaStringCheckUtf8_;
    public static int OptimizeForFieldNumber;
    private static OptimizeMode OptimizeForDefaultValue;
    private OptimizeMode optimizeFor_;
    public static int GoPackageFieldNumber;
    private static string GoPackageDefaultValue;
    private string goPackage_;
    public static int CcGenericServicesFieldNumber;
    private static bool CcGenericServicesDefaultValue;
    private bool ccGenericServices_;
    public static int JavaGenericServicesFieldNumber;
    private static bool JavaGenericServicesDefaultValue;
    private bool javaGenericServices_;
    public static int PyGenericServicesFieldNumber;
    private static bool PyGenericServicesDefaultValue;
    private bool pyGenericServices_;
    public static int DeprecatedFieldNumber;
    private static bool DeprecatedDefaultValue;
    private bool deprecated_;
    public static int CcEnableArenasFieldNumber;
    private static bool CcEnableArenasDefaultValue;
    private bool ccEnableArenas_;
    public static int ObjcClassPrefixFieldNumber;
    private static string ObjcClassPrefixDefaultValue;
    private string objcClassPrefix_;
    public static int CsharpNamespaceFieldNumber;
    private static string CsharpNamespaceDefaultValue;
    private string csharpNamespace_;
    public static int SwiftPrefixFieldNumber;
    private static string SwiftPrefixDefaultValue;
    private string swiftPrefix_;
    public static int PhpClassPrefixFieldNumber;
    private static string PhpClassPrefixDefaultValue;
    private string phpClassPrefix_;
    public static int PhpNamespaceFieldNumber;
    private static string PhpNamespaceDefaultValue;
    private string phpNamespace_;
    public static int PhpMetadataNamespaceFieldNumber;
    private static string PhpMetadataNamespaceDefaultValue;
    private string phpMetadataNamespace_;
    public static int RubyPackageFieldNumber;
    private static string RubyPackageDefaultValue;
    private string rubyPackage_;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    private ExtensionSet`1<FileOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FileOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string JavaPackage { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJavaPackage { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string JavaOuterClassname { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJavaOuterClassname { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool JavaMultipleFiles { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJavaMultipleFiles { get; }
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool JavaGenerateEqualsAndHash { get; public set; }
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJavaGenerateEqualsAndHash { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool JavaStringCheckUtf8 { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJavaStringCheckUtf8 { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public OptimizeMode OptimizeFor { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasOptimizeFor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string GoPackage { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasGoPackage { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool CcGenericServices { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasCcGenericServices { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool JavaGenericServices { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasJavaGenericServices { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool PyGenericServices { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasPyGenericServices { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Deprecated { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecated { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool CcEnableArenas { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasCcEnableArenas { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string ObjcClassPrefix { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasObjcClassPrefix { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string CsharpNamespace { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasCsharpNamespace { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string SwiftPrefix { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasSwiftPrefix { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string PhpClassPrefix { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasPhpClassPrefix { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string PhpNamespace { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasPhpNamespace { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string PhpMetadataNamespace { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasPhpMetadataNamespace { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string RubyPackage { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasRubyPackage { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FileOptions(FileOptions other);
    private static FileOptions();
    private ExtensionSet`1<FileOptions> get__Extensions();
    public static MessageParser`1<FileOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FileOptions Clone();
    public string get_JavaPackage();
    public void set_JavaPackage(string value);
    public bool get_HasJavaPackage();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJavaPackage();
    public string get_JavaOuterClassname();
    public void set_JavaOuterClassname(string value);
    public bool get_HasJavaOuterClassname();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJavaOuterClassname();
    public bool get_JavaMultipleFiles();
    public void set_JavaMultipleFiles(bool value);
    public bool get_HasJavaMultipleFiles();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJavaMultipleFiles();
    public bool get_JavaGenerateEqualsAndHash();
    public void set_JavaGenerateEqualsAndHash(bool value);
    public bool get_HasJavaGenerateEqualsAndHash();
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJavaGenerateEqualsAndHash();
    public bool get_JavaStringCheckUtf8();
    public void set_JavaStringCheckUtf8(bool value);
    public bool get_HasJavaStringCheckUtf8();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJavaStringCheckUtf8();
    public OptimizeMode get_OptimizeFor();
    public void set_OptimizeFor(OptimizeMode value);
    public bool get_HasOptimizeFor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearOptimizeFor();
    public string get_GoPackage();
    public void set_GoPackage(string value);
    public bool get_HasGoPackage();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearGoPackage();
    public bool get_CcGenericServices();
    public void set_CcGenericServices(bool value);
    public bool get_HasCcGenericServices();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearCcGenericServices();
    public bool get_JavaGenericServices();
    public void set_JavaGenericServices(bool value);
    public bool get_HasJavaGenericServices();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearJavaGenericServices();
    public bool get_PyGenericServices();
    public void set_PyGenericServices(bool value);
    public bool get_HasPyGenericServices();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearPyGenericServices();
    public bool get_Deprecated();
    public void set_Deprecated(bool value);
    public bool get_HasDeprecated();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecated();
    public bool get_CcEnableArenas();
    public void set_CcEnableArenas(bool value);
    public bool get_HasCcEnableArenas();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearCcEnableArenas();
    public string get_ObjcClassPrefix();
    public void set_ObjcClassPrefix(string value);
    public bool get_HasObjcClassPrefix();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearObjcClassPrefix();
    public string get_CsharpNamespace();
    public void set_CsharpNamespace(string value);
    public bool get_HasCsharpNamespace();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearCsharpNamespace();
    public string get_SwiftPrefix();
    public void set_SwiftPrefix(string value);
    public bool get_HasSwiftPrefix();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearSwiftPrefix();
    public string get_PhpClassPrefix();
    public void set_PhpClassPrefix(string value);
    public bool get_HasPhpClassPrefix();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearPhpClassPrefix();
    public string get_PhpNamespace();
    public void set_PhpNamespace(string value);
    public bool get_HasPhpNamespace();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearPhpNamespace();
    public string get_PhpMetadataNamespace();
    public void set_PhpMetadataNamespace(string value);
    public bool get_HasPhpMetadataNamespace();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearPhpMetadataNamespace();
    public string get_RubyPackage();
    public void set_RubyPackage(string value);
    public bool get_HasRubyPackage();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearRubyPackage();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FileOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FileOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<FileOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<FileOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<FileOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<FileOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<FileOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<FileOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<FileOptions, TValue> extension);
}
[DebuggerDisplayAttribute("ClrType = {ClrType}")]
public class Google.Protobuf.Reflection.GeneratedClrTypeInfo : object {
    private static String[] EmptyNames;
    private static GeneratedClrTypeInfo[] EmptyCodeInfo;
    private static Extension[] EmptyExtensions;
    internal static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes MessageAccessibility;
    [CompilerGeneratedAttribute]
private Type <ClrType>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageParser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PropertyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Extension[] <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <OneofNames>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedClrTypeInfo[] <NestedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <NestedEnums>k__BackingField;
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMembersAttribute("1547")]
public Type ClrType { get; }
    public MessageParser Parser { get; }
    public String[] PropertyNames { get; }
    public Extension[] Extensions { get; }
    public String[] OneofNames { get; }
    public GeneratedClrTypeInfo[] NestedTypes { get; }
    public Type[] NestedEnums { get; }
    public GeneratedClrTypeInfo(Type clrType, MessageParser parser, String[] propertyNames, String[] oneofNames, Type[] nestedEnums, Extension[] extensions, GeneratedClrTypeInfo[] nestedTypes);
    public GeneratedClrTypeInfo(Type clrType, MessageParser parser, String[] propertyNames, String[] oneofNames, Type[] nestedEnums, GeneratedClrTypeInfo[] nestedTypes);
    public GeneratedClrTypeInfo(Type[] nestedEnums, Extension[] extensions, GeneratedClrTypeInfo[] nestedTypes);
    public GeneratedClrTypeInfo(Type[] nestedEnums, GeneratedClrTypeInfo[] nestedTypes);
    private static GeneratedClrTypeInfo();
    [CompilerGeneratedAttribute]
public Type get_ClrType();
    [CompilerGeneratedAttribute]
public MessageParser get_Parser();
    [CompilerGeneratedAttribute]
public String[] get_PropertyNames();
    [CompilerGeneratedAttribute]
public Extension[] get_Extensions();
    [CompilerGeneratedAttribute]
public String[] get_OneofNames();
    [CompilerGeneratedAttribute]
public GeneratedClrTypeInfo[] get_NestedTypes();
    [CompilerGeneratedAttribute]
public Type[] get_NestedEnums();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.Reflection.GeneratedCodeInfo : object {
    private static MessageParser`1<GeneratedCodeInfo> _parser;
    private UnknownFieldSet _unknownFields;
    public static int AnnotationFieldNumber;
    private static FieldCodec`1<Annotation> _repeated_annotation_codec;
    private RepeatedField`1<Annotation> annotation_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<GeneratedCodeInfo> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Annotation> Annotation { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public GeneratedCodeInfo(GeneratedCodeInfo other);
    private static GeneratedCodeInfo();
    public static MessageParser`1<GeneratedCodeInfo> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual GeneratedCodeInfo Clone();
    public RepeatedField`1<Annotation> get_Annotation();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(GeneratedCodeInfo other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(GeneratedCodeInfo other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
public interface Google.Protobuf.Reflection.IDescriptor {
    public string Name { get; }
    public string FullName { get; }
    public FileDescriptor File { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
    public abstract virtual FileDescriptor get_File();
}
public interface Google.Protobuf.Reflection.IFieldAccessor {
    public FieldDescriptor Descriptor { get; }
    public abstract virtual FieldDescriptor get_Descriptor();
    public abstract virtual void Clear(IMessage message);
    public abstract virtual object GetValue(IMessage message);
    public abstract virtual bool HasValue(IMessage message);
    public abstract virtual void SetValue(IMessage message, object value);
}
internal class Google.Protobuf.Reflection.MapFieldAccessor : FieldAccessorBase {
    internal MapFieldAccessor(PropertyInfo property, FieldDescriptor descriptor);
    public virtual void Clear(IMessage message);
    public virtual bool HasValue(IMessage message);
    public virtual void SetValue(IMessage message, object value);
}
public class Google.Protobuf.Reflection.MessageDescriptor : DescriptorBase {
    private static HashSet`1<string> WellKnownTypeNames;
    private IList`1<FieldDescriptor> fieldsInDeclarationOrder;
    private IList`1<FieldDescriptor> fieldsInNumberOrder;
    private IDictionary`2<string, FieldDescriptor> jsonFieldMap;
    private Func`2<IMessage, bool> extensionSetIsInitialized;
    [CompilerGeneratedAttribute]
private DescriptorProto <Proto>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ClrType>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageParser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDescriptor <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldCollection <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionCollection <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MessageDescriptor> <NestedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<EnumDescriptor> <EnumTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<OneofDescriptor> <Oneofs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RealOneofCount>k__BackingField;
    public string Name { get; }
    internal DescriptorProto Proto { get; }
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMembersAttribute("1547")]
public Type ClrType { get; }
    public MessageParser Parser { get; }
    internal bool IsWellKnownType { get; }
    internal bool IsWrapperType { get; }
    public bool IsMapEntry { get; }
    public MessageDescriptor ContainingType { get; }
    public FieldCollection Fields { get; }
    public ExtensionCollection Extensions { get; }
    public IList`1<MessageDescriptor> NestedTypes { get; }
    public IList`1<EnumDescriptor> EnumTypes { get; }
    public IList`1<OneofDescriptor> Oneofs { get; }
    public int RealOneofCount { get; }
    [ObsoleteAttribute("CustomOptions are obsolete. Use the GetOptions() method.")]
public CustomOptions CustomOptions { get; }
    internal MessageDescriptor(DescriptorProto proto, FileDescriptor file, MessageDescriptor parent, int typeIndex, GeneratedClrTypeInfo generatedCodeInfo);
    private static MessageDescriptor();
    private static ReadOnlyDictionary`2<string, FieldDescriptor> CreateJsonFieldMap(IList`1<FieldDescriptor> fields);
    public virtual string get_Name();
    internal virtual IReadOnlyList`1<DescriptorBase> GetNestedDescriptorListForField(int fieldNumber);
    [CompilerGeneratedAttribute]
internal DescriptorProto get_Proto();
    public DescriptorProto ToProto();
    internal bool IsExtensionsInitialized(IMessage message);
    [CompilerGeneratedAttribute]
public Type get_ClrType();
    [CompilerGeneratedAttribute]
public MessageParser get_Parser();
    internal bool get_IsWellKnownType();
    internal bool get_IsWrapperType();
    public bool get_IsMapEntry();
    [CompilerGeneratedAttribute]
public MessageDescriptor get_ContainingType();
    [CompilerGeneratedAttribute]
public FieldCollection get_Fields();
    [CompilerGeneratedAttribute]
public ExtensionCollection get_Extensions();
    [CompilerGeneratedAttribute]
public IList`1<MessageDescriptor> get_NestedTypes();
    [CompilerGeneratedAttribute]
public IList`1<EnumDescriptor> get_EnumTypes();
    [CompilerGeneratedAttribute]
public IList`1<OneofDescriptor> get_Oneofs();
    [CompilerGeneratedAttribute]
public int get_RealOneofCount();
    public FieldDescriptor FindFieldByName(string name);
    public FieldDescriptor FindFieldByNumber(int number);
    public T FindDescriptor(string name);
    public CustomOptions get_CustomOptions();
    public MessageOptions GetOptions();
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public T GetOption(Extension`2<MessageOptions, T> extension);
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public RepeatedField`1<T> GetOption(RepeatedExtension`2<MessageOptions, T> extension);
    internal void CrossLink();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.MessageOptions : object {
    private static MessageParser`1<MessageOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<MessageOptions> _extensions;
    private int _hasBits0;
    public static int MessageSetWireFormatFieldNumber;
    private static bool MessageSetWireFormatDefaultValue;
    private bool messageSetWireFormat_;
    public static int NoStandardDescriptorAccessorFieldNumber;
    private static bool NoStandardDescriptorAccessorDefaultValue;
    private bool noStandardDescriptorAccessor_;
    public static int DeprecatedFieldNumber;
    private static bool DeprecatedDefaultValue;
    private bool deprecated_;
    public static int MapEntryFieldNumber;
    private static bool MapEntryDefaultValue;
    private bool mapEntry_;
    public static int DeprecatedLegacyJsonFieldConflictsFieldNumber;
    private static bool DeprecatedLegacyJsonFieldConflictsDefaultValue;
    private bool deprecatedLegacyJsonFieldConflicts_;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    private ExtensionSet`1<MessageOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<MessageOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool MessageSetWireFormat { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMessageSetWireFormat { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool NoStandardDescriptorAccessor { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasNoStandardDescriptorAccessor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Deprecated { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecated { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool MapEntry { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasMapEntry { get; }
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool DeprecatedLegacyJsonFieldConflicts { get; public set; }
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecatedLegacyJsonFieldConflicts { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MessageOptions(MessageOptions other);
    private static MessageOptions();
    private ExtensionSet`1<MessageOptions> get__Extensions();
    public static MessageParser`1<MessageOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual MessageOptions Clone();
    public bool get_MessageSetWireFormat();
    public void set_MessageSetWireFormat(bool value);
    public bool get_HasMessageSetWireFormat();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMessageSetWireFormat();
    public bool get_NoStandardDescriptorAccessor();
    public void set_NoStandardDescriptorAccessor(bool value);
    public bool get_HasNoStandardDescriptorAccessor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearNoStandardDescriptorAccessor();
    public bool get_Deprecated();
    public void set_Deprecated(bool value);
    public bool get_HasDeprecated();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecated();
    public bool get_MapEntry();
    public void set_MapEntry(bool value);
    public bool get_HasMapEntry();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearMapEntry();
    public bool get_DeprecatedLegacyJsonFieldConflicts();
    public void set_DeprecatedLegacyJsonFieldConflicts(bool value);
    public bool get_HasDeprecatedLegacyJsonFieldConflicts();
    [ObsoleteAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecatedLegacyJsonFieldConflicts();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(MessageOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(MessageOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<MessageOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<MessageOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<MessageOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<MessageOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<MessageOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<MessageOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<MessageOptions, TValue> extension);
}
public class Google.Protobuf.Reflection.MethodDescriptor : DescriptorBase {
    [CompilerGeneratedAttribute]
private ServiceDescriptor <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDescriptor <InputType>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDescriptor <OutputType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDescriptorProto <Proto>k__BackingField;
    public ServiceDescriptor Service { get; }
    public MessageDescriptor InputType { get; private set; }
    public MessageDescriptor OutputType { get; private set; }
    public bool IsClientStreaming { get; }
    public bool IsServerStreaming { get; }
    [ObsoleteAttribute("CustomOptions are obsolete. Use the GetOptions() method.")]
public CustomOptions CustomOptions { get; }
    internal MethodDescriptorProto Proto { get; private set; }
    public string Name { get; }
    internal MethodDescriptor(MethodDescriptorProto proto, FileDescriptor file, ServiceDescriptor parent, int index);
    [CompilerGeneratedAttribute]
public ServiceDescriptor get_Service();
    [CompilerGeneratedAttribute]
public MessageDescriptor get_InputType();
    [CompilerGeneratedAttribute]
private void set_InputType(MessageDescriptor value);
    [CompilerGeneratedAttribute]
public MessageDescriptor get_OutputType();
    [CompilerGeneratedAttribute]
private void set_OutputType(MessageDescriptor value);
    public bool get_IsClientStreaming();
    public bool get_IsServerStreaming();
    public CustomOptions get_CustomOptions();
    public MethodOptions GetOptions();
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public T GetOption(Extension`2<MethodOptions, T> extension);
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public RepeatedField`1<T> GetOption(RepeatedExtension`2<MethodOptions, T> extension);
    [CompilerGeneratedAttribute]
internal MethodDescriptorProto get_Proto();
    [CompilerGeneratedAttribute]
private void set_Proto(MethodDescriptorProto value);
    public MethodDescriptorProto ToProto();
    public virtual string get_Name();
    internal void CrossLink();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.MethodDescriptorProto : object {
    private static MessageParser`1<MethodDescriptorProto> _parser;
    private UnknownFieldSet _unknownFields;
    private int _hasBits0;
    public static int NameFieldNumber;
    private static string NameDefaultValue;
    private string name_;
    public static int InputTypeFieldNumber;
    private static string InputTypeDefaultValue;
    private string inputType_;
    public static int OutputTypeFieldNumber;
    private static string OutputTypeDefaultValue;
    private string outputType_;
    public static int OptionsFieldNumber;
    private MethodOptions options_;
    public static int ClientStreamingFieldNumber;
    private static bool ClientStreamingDefaultValue;
    private bool clientStreaming_;
    public static int ServerStreamingFieldNumber;
    private static bool ServerStreamingDefaultValue;
    private bool serverStreaming_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<MethodDescriptorProto> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string InputType { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasInputType { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string OutputType { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasOutputType { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MethodOptions Options { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool ClientStreaming { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasClientStreaming { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool ServerStreaming { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasServerStreaming { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MethodDescriptorProto(MethodDescriptorProto other);
    private static MethodDescriptorProto();
    public static MessageParser`1<MethodDescriptorProto> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual MethodDescriptorProto Clone();
    public string get_Name();
    public void set_Name(string value);
    public bool get_HasName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearName();
    public string get_InputType();
    public void set_InputType(string value);
    public bool get_HasInputType();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearInputType();
    public string get_OutputType();
    public void set_OutputType(string value);
    public bool get_HasOutputType();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearOutputType();
    public MethodOptions get_Options();
    public void set_Options(MethodOptions value);
    public bool get_ClientStreaming();
    public void set_ClientStreaming(bool value);
    public bool get_HasClientStreaming();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearClientStreaming();
    public bool get_ServerStreaming();
    public void set_ServerStreaming(bool value);
    public bool get_HasServerStreaming();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearServerStreaming();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(MethodDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(MethodDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.MethodOptions : object {
    private static MessageParser`1<MethodOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<MethodOptions> _extensions;
    private int _hasBits0;
    public static int DeprecatedFieldNumber;
    private static bool DeprecatedDefaultValue;
    private bool deprecated_;
    public static int IdempotencyLevelFieldNumber;
    private static IdempotencyLevel IdempotencyLevelDefaultValue;
    private IdempotencyLevel idempotencyLevel_;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    private ExtensionSet`1<MethodOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<MethodOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Deprecated { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecated { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public IdempotencyLevel IdempotencyLevel { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasIdempotencyLevel { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MethodOptions(MethodOptions other);
    private static MethodOptions();
    private ExtensionSet`1<MethodOptions> get__Extensions();
    public static MessageParser`1<MethodOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual MethodOptions Clone();
    public bool get_Deprecated();
    public void set_Deprecated(bool value);
    public bool get_HasDeprecated();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecated();
    public IdempotencyLevel get_IdempotencyLevel();
    public void set_IdempotencyLevel(IdempotencyLevel value);
    public bool get_HasIdempotencyLevel();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearIdempotencyLevel();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(MethodOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(MethodOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<MethodOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<MethodOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<MethodOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<MethodOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<MethodOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<MethodOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<MethodOptions, TValue> extension);
}
public class Google.Protobuf.Reflection.OneofAccessor : object {
    private Func`2<IMessage, int> caseDelegate;
    private Action`1<IMessage> clearDelegate;
    [CompilerGeneratedAttribute]
private OneofDescriptor <Descriptor>k__BackingField;
    public OneofDescriptor Descriptor { get; }
    private OneofAccessor(OneofDescriptor descriptor, Func`2<IMessage, int> caseDelegate, Action`1<IMessage> clearDelegate);
    internal static OneofAccessor ForRegularOneof(OneofDescriptor descriptor, PropertyInfo caseProperty, MethodInfo clearMethod);
    internal static OneofAccessor ForSyntheticOneof(OneofDescriptor descriptor);
    [CompilerGeneratedAttribute]
public OneofDescriptor get_Descriptor();
    public void Clear(IMessage message);
    public FieldDescriptor GetCaseFieldDescriptor(IMessage message);
}
public class Google.Protobuf.Reflection.OneofDescriptor : DescriptorBase {
    private MessageDescriptor containingType;
    private IList`1<FieldDescriptor> fields;
    private OneofAccessor accessor;
    [CompilerGeneratedAttribute]
private OneofDescriptorProto <Proto>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSynthetic>k__BackingField;
    public string Name { get; }
    internal OneofDescriptorProto Proto { get; }
    public MessageDescriptor ContainingType { get; }
    public IList`1<FieldDescriptor> Fields { get; }
    public bool IsSynthetic { get; }
    public OneofAccessor Accessor { get; }
    [ObsoleteAttribute("CustomOptions are obsolete. Use the GetOptions method.")]
public CustomOptions CustomOptions { get; }
    internal OneofDescriptor(OneofDescriptorProto proto, FileDescriptor file, MessageDescriptor parent, int index, string clrName);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
internal OneofDescriptorProto get_Proto();
    public OneofDescriptorProto ToProto();
    public MessageDescriptor get_ContainingType();
    public IList`1<FieldDescriptor> get_Fields();
    [CompilerGeneratedAttribute]
public bool get_IsSynthetic();
    public OneofAccessor get_Accessor();
    public CustomOptions get_CustomOptions();
    public OneofOptions GetOptions();
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public T GetOption(Extension`2<OneofOptions, T> extension);
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public RepeatedField`1<T> GetOption(RepeatedExtension`2<OneofOptions, T> extension);
    internal void CrossLink();
    private OneofAccessor CreateAccessor(string clrName);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.OneofDescriptorProto : object {
    private static MessageParser`1<OneofDescriptorProto> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private static string NameDefaultValue;
    private string name_;
    public static int OptionsFieldNumber;
    private OneofOptions options_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<OneofDescriptorProto> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public OneofOptions Options { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public OneofDescriptorProto(OneofDescriptorProto other);
    private static OneofDescriptorProto();
    public static MessageParser`1<OneofDescriptorProto> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual OneofDescriptorProto Clone();
    public string get_Name();
    public void set_Name(string value);
    public bool get_HasName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearName();
    public OneofOptions get_Options();
    public void set_Options(OneofOptions value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(OneofDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(OneofDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.OneofOptions : object {
    private static MessageParser`1<OneofOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<OneofOptions> _extensions;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    private ExtensionSet`1<OneofOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<OneofOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public OneofOptions(OneofOptions other);
    private static OneofOptions();
    private ExtensionSet`1<OneofOptions> get__Extensions();
    public static MessageParser`1<OneofOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual OneofOptions Clone();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(OneofOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(OneofOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<OneofOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<OneofOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<OneofOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<OneofOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<OneofOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<OneofOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<OneofOptions, TValue> extension);
}
[AttributeUsageAttribute("256")]
internal class Google.Protobuf.Reflection.OriginalNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferredAlias>k__BackingField;
    public string Name { get; public set; }
    public bool PreferredAlias { get; public set; }
    public OriginalNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_PreferredAlias();
    [CompilerGeneratedAttribute]
public void set_PreferredAlias(bool value);
}
internal class Google.Protobuf.Reflection.PackageDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private FileDescriptor <File>k__BackingField;
    public string Name { get; }
    public string FullName { get; }
    public FileDescriptor File { get; }
    internal PackageDescriptor(string name, string fullName, FileDescriptor file);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual FileDescriptor get_File();
}
internal static class Google.Protobuf.Reflection.ReflectionUtil : object {
    internal static Type[] EmptyTypes;
    [CompilerGeneratedAttribute]
private static bool <CanConvertEnumFuncToInt32Func>k__BackingField;
    private static bool CanConvertEnumFuncToInt32Func { get; }
    private static ReflectionUtil();
    internal static void ForceInitialize();
    internal static Func`2<IMessage, object> CreateFuncIMessageObject(MethodInfo method);
    internal static Func`2<IMessage, int> CreateFuncIMessageInt32(MethodInfo method);
    internal static Action`2<IMessage, object> CreateActionIMessageObject(MethodInfo method);
    internal static Action`1<IMessage> CreateActionIMessage(MethodInfo method);
    internal static Func`2<IMessage, bool> CreateFuncIMessageBool(MethodInfo method);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
[<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
internal static Func`2<IMessage, bool> CreateIsInitializedCaller(Type msg);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
[<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute("AOT", "IL3050")]
internal static IExtensionReflectionHelper CreateExtensionHelper(Extension extension);
    [<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
[<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute("AOT", "IL3050")]
private static IReflectionHelper GetReflectionHelper(Type t1, Type t2);
    [CompilerGeneratedAttribute]
private static bool get_CanConvertEnumFuncToInt32Func();
    private static bool CheckCanConvertEnumFuncToInt32Func();
    public static SampleEnum SampleEnumMethod();
}
internal class Google.Protobuf.Reflection.RepeatedFieldAccessor : FieldAccessorBase {
    internal RepeatedFieldAccessor(PropertyInfo property, FieldDescriptor descriptor);
    public virtual void Clear(IMessage message);
    public virtual bool HasValue(IMessage message);
    public virtual void SetValue(IMessage message, object value);
}
public class Google.Protobuf.Reflection.ServiceDescriptor : DescriptorBase {
    [CompilerGeneratedAttribute]
private ServiceDescriptorProto <Proto>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MethodDescriptor> <Methods>k__BackingField;
    public string Name { get; }
    internal ServiceDescriptorProto Proto { get; }
    public IList`1<MethodDescriptor> Methods { get; }
    [ObsoleteAttribute("CustomOptions are obsolete. Use the GetOptions() method.")]
public CustomOptions CustomOptions { get; }
    internal ServiceDescriptor(ServiceDescriptorProto proto, FileDescriptor file, int index);
    public virtual string get_Name();
    internal virtual IReadOnlyList`1<DescriptorBase> GetNestedDescriptorListForField(int fieldNumber);
    [CompilerGeneratedAttribute]
internal ServiceDescriptorProto get_Proto();
    public ServiceDescriptorProto ToProto();
    [CompilerGeneratedAttribute]
public IList`1<MethodDescriptor> get_Methods();
    public MethodDescriptor FindMethodByName(string name);
    public CustomOptions get_CustomOptions();
    public ServiceOptions GetOptions();
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public T GetOption(Extension`2<ServiceOptions, T> extension);
    [ObsoleteAttribute("GetOption is obsolete. Use the GetOptions() method.")]
public RepeatedField`1<T> GetOption(RepeatedExtension`2<ServiceOptions, T> extension);
    internal void CrossLink();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.ServiceDescriptorProto : object {
    private static MessageParser`1<ServiceDescriptorProto> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private static string NameDefaultValue;
    private string name_;
    public static int MethodFieldNumber;
    private static FieldCodec`1<MethodDescriptorProto> _repeated_method_codec;
    private RepeatedField`1<MethodDescriptorProto> method_;
    public static int OptionsFieldNumber;
    private ServiceOptions options_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<ServiceDescriptorProto> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<MethodDescriptorProto> Method { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ServiceOptions Options { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ServiceDescriptorProto(ServiceDescriptorProto other);
    private static ServiceDescriptorProto();
    public static MessageParser`1<ServiceDescriptorProto> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual ServiceDescriptorProto Clone();
    public string get_Name();
    public void set_Name(string value);
    public bool get_HasName();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearName();
    public RepeatedField`1<MethodDescriptorProto> get_Method();
    public ServiceOptions get_Options();
    public void set_Options(ServiceOptions value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(ServiceDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(ServiceDescriptorProto other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.ServiceOptions : object {
    private static MessageParser`1<ServiceOptions> _parser;
    private UnknownFieldSet _unknownFields;
    internal ExtensionSet`1<ServiceOptions> _extensions;
    private int _hasBits0;
    public static int FeaturesFieldNumber;
    private FeatureSet features_;
    public static int DeprecatedFieldNumber;
    private static bool DeprecatedDefaultValue;
    private bool deprecated_;
    public static int UninterpretedOptionFieldNumber;
    private static FieldCodec`1<UninterpretedOption> _repeated_uninterpretedOption_codec;
    private RepeatedField`1<UninterpretedOption> uninterpretedOption_;
    private ExtensionSet`1<ServiceOptions> _Extensions { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<ServiceOptions> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FeatureSet Features { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Deprecated { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDeprecated { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<UninterpretedOption> UninterpretedOption { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ServiceOptions(ServiceOptions other);
    private static ServiceOptions();
    private ExtensionSet`1<ServiceOptions> get__Extensions();
    public static MessageParser`1<ServiceOptions> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual ServiceOptions Clone();
    public FeatureSet get_Features();
    public void set_Features(FeatureSet value);
    public bool get_Deprecated();
    public void set_Deprecated(bool value);
    public bool get_HasDeprecated();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDeprecated();
    public RepeatedField`1<UninterpretedOption> get_UninterpretedOption();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(ServiceOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(ServiceOptions other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public sealed virtual TValue GetExtension(Extension`2<ServiceOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetExtension(RepeatedExtension`2<ServiceOptions, TValue> extension);
    public sealed virtual RepeatedField`1<TValue> GetOrInitializeExtension(RepeatedExtension`2<ServiceOptions, TValue> extension);
    public sealed virtual void SetExtension(Extension`2<ServiceOptions, TValue> extension, TValue value);
    public sealed virtual bool HasExtension(Extension`2<ServiceOptions, TValue> extension);
    public sealed virtual void ClearExtension(Extension`2<ServiceOptions, TValue> extension);
    public sealed virtual void ClearExtension(RepeatedExtension`2<ServiceOptions, TValue> extension);
}
internal class Google.Protobuf.Reflection.SingleFieldAccessor : FieldAccessorBase {
    private Action`2<IMessage, object> setValueDelegate;
    private Action`1<IMessage> clearDelegate;
    private Func`2<IMessage, bool> hasDelegate;
    internal SingleFieldAccessor(Type messageType, PropertyInfo property, FieldDescriptor descriptor);
    private static object GetDefaultValue(FieldDescriptor descriptor);
    public virtual void Clear(IMessage message);
    public virtual bool HasValue(IMessage message);
    public virtual void SetValue(IMessage message, object value);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.SourceCodeInfo : object {
    private static MessageParser`1<SourceCodeInfo> _parser;
    private UnknownFieldSet _unknownFields;
    public static int LocationFieldNumber;
    private static FieldCodec`1<Location> _repeated_location_codec;
    private RepeatedField`1<Location> location_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<SourceCodeInfo> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Location> Location { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public SourceCodeInfo(SourceCodeInfo other);
    private static SourceCodeInfo();
    public static MessageParser`1<SourceCodeInfo> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual SourceCodeInfo Clone();
    public RepeatedField`1<Location> get_Location();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(SourceCodeInfo other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(SourceCodeInfo other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[ObsoleteAttribute("Use features instead")]
public enum Google.Protobuf.Reflection.Syntax : Enum {
    public int value__;
    public static Syntax Proto2;
    public static Syntax Proto3;
    public static Syntax Editions;
    public static Syntax Unknown;
}
[DebuggerDisplayAttribute("Count = {fullNameToMessageMap.Count}")]
[DebuggerTypeProxyAttribute("Google.Protobuf.Reflection.TypeRegistry/TypeRegistryDebugView")]
internal class Google.Protobuf.Reflection.TypeRegistry : object {
    [CompilerGeneratedAttribute]
private static TypeRegistry <Empty>k__BackingField;
    private Dictionary`2<string, MessageDescriptor> fullNameToMessageMap;
    public static TypeRegistry Empty { get; }
    private TypeRegistry(Dictionary`2<string, MessageDescriptor> fullNameToMessageMap);
    private static TypeRegistry();
    [CompilerGeneratedAttribute]
public static TypeRegistry get_Empty();
    public MessageDescriptor Find(string fullName);
    public static TypeRegistry FromFiles(FileDescriptor[] fileDescriptors);
    public static TypeRegistry FromFiles(IEnumerable`1<FileDescriptor> fileDescriptors);
    public static TypeRegistry FromMessages(MessageDescriptor[] messageDescriptors);
    public static TypeRegistry FromMessages(IEnumerable`1<MessageDescriptor> messageDescriptors);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Google.Protobuf.Reflection.UninterpretedOption : object {
    private static MessageParser`1<UninterpretedOption> _parser;
    private UnknownFieldSet _unknownFields;
    private int _hasBits0;
    public static int NameFieldNumber;
    private static FieldCodec`1<NamePart> _repeated_name_codec;
    private RepeatedField`1<NamePart> name_;
    public static int IdentifierValueFieldNumber;
    private static string IdentifierValueDefaultValue;
    private string identifierValue_;
    public static int PositiveIntValueFieldNumber;
    private static ulong PositiveIntValueDefaultValue;
    private ulong positiveIntValue_;
    public static int NegativeIntValueFieldNumber;
    private static long NegativeIntValueDefaultValue;
    private long negativeIntValue_;
    public static int DoubleValueFieldNumber;
    private static double DoubleValueDefaultValue;
    private double doubleValue_;
    public static int StringValueFieldNumber;
    private static ByteString StringValueDefaultValue;
    private ByteString stringValue_;
    public static int AggregateValueFieldNumber;
    private static string AggregateValueDefaultValue;
    private string aggregateValue_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<UninterpretedOption> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<NamePart> Name { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string IdentifierValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasIdentifierValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ulong PositiveIntValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasPositiveIntValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public long NegativeIntValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasNegativeIntValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public double DoubleValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDoubleValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ByteString StringValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasStringValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string AggregateValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasAggregateValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public UninterpretedOption(UninterpretedOption other);
    private static UninterpretedOption();
    public static MessageParser`1<UninterpretedOption> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual UninterpretedOption Clone();
    public RepeatedField`1<NamePart> get_Name();
    public string get_IdentifierValue();
    public void set_IdentifierValue(string value);
    public bool get_HasIdentifierValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearIdentifierValue();
    public ulong get_PositiveIntValue();
    public void set_PositiveIntValue(ulong value);
    public bool get_HasPositiveIntValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearPositiveIntValue();
    public long get_NegativeIntValue();
    public void set_NegativeIntValue(long value);
    public bool get_HasNegativeIntValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearNegativeIntValue();
    public double get_DoubleValue();
    public void set_DoubleValue(double value);
    public bool get_HasDoubleValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDoubleValue();
    public ByteString get_StringValue();
    public void set_StringValue(ByteString value);
    public bool get_HasStringValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearStringValue();
    public string get_AggregateValue();
    public void set_AggregateValue(string value);
    public bool get_HasAggregateValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearAggregateValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(UninterpretedOption other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(UninterpretedOption other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
public class Google.Protobuf.RepeatedExtension`2 : Extension {
    private FieldCodec`1<TValue> codec;
    internal Type TargetType { get; }
    internal bool IsRepeated { get; }
    public RepeatedExtension`2(int fieldNumber, FieldCodec`1<TValue> codec);
    internal virtual Type get_TargetType();
    internal virtual bool get_IsRepeated();
    internal virtual IExtensionValue CreateValue();
}
internal class Google.Protobuf.RepeatedExtensionValue`1 : object {
    private RepeatedField`1<T> field;
    private FieldCodec`1<T> codec;
    internal RepeatedExtensionValue`1(FieldCodec`1<T> codec);
    public sealed virtual int CalculateSize();
    public sealed virtual IExtensionValue Clone();
    public sealed virtual bool Equals(IExtensionValue other);
    public virtual int GetHashCode();
    public sealed virtual void MergeFrom(ParseContext& ctx);
    public sealed virtual void MergeFrom(IExtensionValue value);
    public sealed virtual void WriteTo(WriteContext& ctx);
    public RepeatedField`1<T> GetValue();
    private sealed virtual override object Google.Protobuf.IExtensionValue.GetValue();
    public sealed virtual bool IsInitialized();
}
[SecuritySafeCriticalAttribute]
internal class Google.Protobuf.SegmentedBufferHelper : ValueType {
    private Nullable`1<int> totalLength;
    private Enumerator<byte> readOnlySequenceEnumerator;
    private CodedInputStream codedInputStream;
    public Nullable`1<int> TotalLength { get; }
    public CodedInputStream CodedInputStream { get; }
    public static void Initialize(CodedInputStream codedInputStream, SegmentedBufferHelper& instance);
    public static void Initialize(ReadOnlySequence`1<byte> sequence, SegmentedBufferHelper& instance, ReadOnlySpan`1& firstSpan);
    public bool RefillBuffer(ReadOnlySpan`1& buffer, ParserInternalState& state, bool mustSucceed);
    public Nullable`1<int> get_TotalLength();
    public CodedInputStream get_CodedInputStream();
    public static int PushLimit(ParserInternalState& state, int byteLimit);
    public static void PopLimit(ParserInternalState& state, int oldLimit);
    public static bool IsReachedLimit(ParserInternalState& state);
    public static bool IsAtEnd(ReadOnlySpan`1& buffer, ParserInternalState& state);
    private bool RefillFromReadOnlySequence(ReadOnlySpan`1& buffer, ParserInternalState& state, bool mustSucceed);
    private bool RefillFromCodedInputStream(ReadOnlySpan`1& buffer, ParserInternalState& state, bool mustSucceed);
    private static void RecomputeBufferSizeAfterLimit(ParserInternalState& state);
    private static void CheckCurrentBufferIsEmpty(ParserInternalState& state);
}
internal class Google.Protobuf.UnknownField : object {
    private List`1<ulong> varintList;
    private List`1<UInt32> fixed32List;
    private List`1<ulong> fixed64List;
    private List`1<ByteString> lengthDelimitedList;
    private List`1<UnknownFieldSet> groupList;
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal void WriteTo(int fieldNumber, WriteContext& output);
    internal int GetSerializedSize(int fieldNumber);
    internal UnknownField MergeFrom(UnknownField other);
    private static List`1<T> AddAll(List`1<T> current, IList`1<T> extras);
    internal UnknownField AddVarint(ulong value);
    internal UnknownField AddFixed32(UInt32 value);
    internal UnknownField AddFixed64(ulong value);
    internal UnknownField AddLengthDelimited(ByteString value);
    internal UnknownField AddGroup(UnknownFieldSet value);
    private static List`1<T> Add(List`1<T> list, T value);
}
[DebuggerDisplayAttribute("Count = {fields.Count}")]
[DebuggerTypeProxyAttribute("Google.Protobuf.UnknownFieldSet/UnknownFieldSetDebugView")]
internal class Google.Protobuf.UnknownFieldSet : object {
    private IDictionary`2<int, UnknownField> fields;
    private int lastFieldNumber;
    private UnknownField lastField;
    internal bool HasField(int field);
    public void WriteTo(CodedOutputStream output);
    [SecuritySafeCriticalAttribute]
public void WriteTo(WriteContext& ctx);
    public int CalculateSize();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private UnknownField GetOrAddField(int number);
    internal UnknownFieldSet AddOrReplaceField(int number, UnknownField field);
    private bool MergeFieldFrom(ParseContext& ctx);
    internal void MergeGroupFrom(ParseContext& ctx);
    public static UnknownFieldSet MergeFieldFrom(UnknownFieldSet unknownFields, CodedInputStream input);
    [SecuritySafeCriticalAttribute]
public static UnknownFieldSet MergeFieldFrom(UnknownFieldSet unknownFields, ParseContext& ctx);
    private UnknownFieldSet MergeFrom(UnknownFieldSet other);
    public static UnknownFieldSet MergeFrom(UnknownFieldSet unknownFields, UnknownFieldSet other);
    private UnknownFieldSet MergeField(int number, UnknownField field);
    public static UnknownFieldSet Clone(UnknownFieldSet other);
}
[SecuritySafeCriticalAttribute]
internal static class Google.Protobuf.UnsafeByteOperations : object {
    public static ByteString UnsafeWrap(ReadOnlyMemory`1<byte> bytes);
}
internal class Google.Protobuf.ValueReader`1 : MulticastDelegate {
    public ValueReader`1(object object, IntPtr method);
    public virtual TValue Invoke(ParseContext& ctx);
    public virtual IAsyncResult BeginInvoke(ParseContext& ctx, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(ParseContext& ctx, IAsyncResult result);
}
internal class Google.Protobuf.ValueWriter`1 : MulticastDelegate {
    public ValueWriter`1(object object, IntPtr method);
    public virtual void Invoke(WriteContext& ctx, T value);
    public virtual IAsyncResult BeginInvoke(WriteContext& ctx, T value, AsyncCallback callback, object object);
    public virtual void EndInvoke(WriteContext& ctx, IAsyncResult result);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Any : object {
    private static MessageParser`1<Any> _parser;
    private UnknownFieldSet _unknownFields;
    public static int TypeUrlFieldNumber;
    private string typeUrl_;
    public static int ValueFieldNumber;
    private ByteString value_;
    private static string DefaultPrefix;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Any> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string TypeUrl { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ByteString Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Any(Any other);
    private static Any();
    public static MessageParser`1<Any> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Any Clone();
    public string get_TypeUrl();
    public void set_TypeUrl(string value);
    public ByteString get_Value();
    public void set_Value(ByteString value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Any other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Any other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    private static string GetTypeUrl(MessageDescriptor descriptor, string prefix);
    public static string GetTypeName(string typeUrl);
    public bool Is(MessageDescriptor descriptor);
    public T Unpack();
    public bool TryUnpack(T& result);
    public IMessage Unpack(TypeRegistry registry);
    public static Any Pack(IMessage message);
    public static Any Pack(IMessage message, string typeUrlPrefix);
}
internal static class Google.Protobuf.WellKnownTypes.AnyReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static AnyReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Api : object {
    private static MessageParser`1<Api> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private string name_;
    public static int MethodsFieldNumber;
    private static FieldCodec`1<Method> _repeated_methods_codec;
    private RepeatedField`1<Method> methods_;
    public static int OptionsFieldNumber;
    private static FieldCodec`1<Option> _repeated_options_codec;
    private RepeatedField`1<Option> options_;
    public static int VersionFieldNumber;
    private string version_;
    public static int SourceContextFieldNumber;
    private SourceContext sourceContext_;
    public static int MixinsFieldNumber;
    private static FieldCodec`1<Mixin> _repeated_mixins_codec;
    private RepeatedField`1<Mixin> mixins_;
    public static int SyntaxFieldNumber;
    private Syntax syntax_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Api> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Method> Methods { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Option> Options { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Version { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public SourceContext SourceContext { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Mixin> Mixins { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Syntax Syntax { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Api(Api other);
    private static Api();
    public static MessageParser`1<Api> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Api Clone();
    public string get_Name();
    public void set_Name(string value);
    public RepeatedField`1<Method> get_Methods();
    public RepeatedField`1<Option> get_Options();
    public string get_Version();
    public void set_Version(string value);
    public SourceContext get_SourceContext();
    public void set_SourceContext(SourceContext value);
    public RepeatedField`1<Mixin> get_Mixins();
    public Syntax get_Syntax();
    public void set_Syntax(Syntax value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Api other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Api other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal static class Google.Protobuf.WellKnownTypes.ApiReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static ApiReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.BoolValue : object {
    private static MessageParser`1<BoolValue> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private bool value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<BoolValue> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public BoolValue(BoolValue other);
    private static BoolValue();
    public static MessageParser`1<BoolValue> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual BoolValue Clone();
    public bool get_Value();
    public void set_Value(bool value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(BoolValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(BoolValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.BytesValue : object {
    private static MessageParser`1<BytesValue> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private ByteString value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<BytesValue> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ByteString Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public BytesValue(BytesValue other);
    private static BytesValue();
    public static MessageParser`1<BytesValue> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual BytesValue Clone();
    public ByteString get_Value();
    public void set_Value(ByteString value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(BytesValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(BytesValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.DoubleValue : object {
    private static MessageParser`1<DoubleValue> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private double value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<DoubleValue> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public double Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public DoubleValue(DoubleValue other);
    private static DoubleValue();
    public static MessageParser`1<DoubleValue> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual DoubleValue Clone();
    public double get_Value();
    public void set_Value(double value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(DoubleValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(DoubleValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Duration : object {
    private static MessageParser`1<Duration> _parser;
    private UnknownFieldSet _unknownFields;
    public static int SecondsFieldNumber;
    private long seconds_;
    public static int NanosFieldNumber;
    private int nanos_;
    public static int NanosecondsPerSecond;
    public static int NanosecondsPerTick;
    public static long MaxSeconds;
    public static long MinSeconds;
    internal static int MaxNanoseconds;
    internal static int MinNanoseconds;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Duration> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public long Seconds { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Nanos { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Duration(Duration other);
    private static Duration();
    public static MessageParser`1<Duration> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Duration Clone();
    public long get_Seconds();
    public void set_Seconds(long value);
    public int get_Nanos();
    public void set_Nanos(int value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Duration other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Duration other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    internal static bool IsNormalized(long seconds, int nanoseconds);
    public TimeSpan ToTimeSpan();
    public static Duration FromTimeSpan(TimeSpan timeSpan);
    public static Duration op_UnaryNegation(Duration value);
    public static Duration op_Addition(Duration lhs, Duration rhs);
    public static Duration op_Subtraction(Duration lhs, Duration rhs);
    internal static Duration Normalize(long seconds, int nanoseconds);
    internal static string ToJson(long seconds, int nanoseconds, bool diagnosticOnly);
    public sealed virtual string ToDiagnosticString();
    internal static void AppendNanoseconds(StringBuilder builder, int nanos);
    public sealed virtual int CompareTo(Duration other);
}
internal static class Google.Protobuf.WellKnownTypes.DurationReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static DurationReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Empty : object {
    private static MessageParser`1<Empty> _parser;
    private UnknownFieldSet _unknownFields;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Empty> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Empty(Empty other);
    private static Empty();
    public static MessageParser`1<Empty> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Empty Clone();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Empty other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Empty other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal static class Google.Protobuf.WellKnownTypes.EmptyReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static EmptyReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Enum : object {
    private static MessageParser`1<Enum> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private string name_;
    public static int EnumvalueFieldNumber;
    private static FieldCodec`1<EnumValue> _repeated_enumvalue_codec;
    private RepeatedField`1<EnumValue> enumvalue_;
    public static int OptionsFieldNumber;
    private static FieldCodec`1<Option> _repeated_options_codec;
    private RepeatedField`1<Option> options_;
    public static int SourceContextFieldNumber;
    private SourceContext sourceContext_;
    public static int SyntaxFieldNumber;
    private Syntax syntax_;
    public static int EditionFieldNumber;
    private string edition_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Enum> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<EnumValue> Enumvalue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Option> Options { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public SourceContext SourceContext { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Syntax Syntax { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Edition { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Enum(Enum other);
    private static Enum();
    public static MessageParser`1<Enum> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Enum Clone();
    public string get_Name();
    public void set_Name(string value);
    public RepeatedField`1<EnumValue> get_Enumvalue();
    public RepeatedField`1<Option> get_Options();
    public SourceContext get_SourceContext();
    public void set_SourceContext(SourceContext value);
    public Syntax get_Syntax();
    public void set_Syntax(Syntax value);
    public string get_Edition();
    public void set_Edition(string value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Enum other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Enum other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.EnumValue : object {
    private static MessageParser`1<EnumValue> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private string name_;
    public static int NumberFieldNumber;
    private int number_;
    public static int OptionsFieldNumber;
    private static FieldCodec`1<Option> _repeated_options_codec;
    private RepeatedField`1<Option> options_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<EnumValue> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Number { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Option> Options { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public EnumValue(EnumValue other);
    private static EnumValue();
    public static MessageParser`1<EnumValue> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual EnumValue Clone();
    public string get_Name();
    public void set_Name(string value);
    public int get_Number();
    public void set_Number(int value);
    public RepeatedField`1<Option> get_Options();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(EnumValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(EnumValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Field : object {
    private static MessageParser`1<Field> _parser;
    private UnknownFieldSet _unknownFields;
    public static int KindFieldNumber;
    private Kind kind_;
    public static int CardinalityFieldNumber;
    private Cardinality cardinality_;
    public static int NumberFieldNumber;
    private int number_;
    public static int NameFieldNumber;
    private string name_;
    public static int TypeUrlFieldNumber;
    private string typeUrl_;
    public static int OneofIndexFieldNumber;
    private int oneofIndex_;
    public static int PackedFieldNumber;
    private bool packed_;
    public static int OptionsFieldNumber;
    private static FieldCodec`1<Option> _repeated_options_codec;
    private RepeatedField`1<Option> options_;
    public static int JsonNameFieldNumber;
    private string jsonName_;
    public static int DefaultValueFieldNumber;
    private string defaultValue_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Field> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Kind Kind { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Cardinality Cardinality { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Number { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string TypeUrl { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int OneofIndex { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool Packed { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Option> Options { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string JsonName { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string DefaultValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Field(Field other);
    private static Field();
    public static MessageParser`1<Field> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Field Clone();
    public Kind get_Kind();
    public void set_Kind(Kind value);
    public Cardinality get_Cardinality();
    public void set_Cardinality(Cardinality value);
    public int get_Number();
    public void set_Number(int value);
    public string get_Name();
    public void set_Name(string value);
    public string get_TypeUrl();
    public void set_TypeUrl(string value);
    public int get_OneofIndex();
    public void set_OneofIndex(int value);
    public bool get_Packed();
    public void set_Packed(bool value);
    public RepeatedField`1<Option> get_Options();
    public string get_JsonName();
    public void set_JsonName(string value);
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Field other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Field other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.FieldMask : object {
    private static MessageParser`1<FieldMask> _parser;
    private UnknownFieldSet _unknownFields;
    public static int PathsFieldNumber;
    private static FieldCodec`1<string> _repeated_paths_codec;
    private RepeatedField`1<string> paths_;
    private static char FIELD_PATH_SEPARATOR;
    private static char FIELD_SEPARATOR_REGEX;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FieldMask> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<string> Paths { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FieldMask(FieldMask other);
    private static FieldMask();
    public static MessageParser`1<FieldMask> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FieldMask Clone();
    public RepeatedField`1<string> get_Paths();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FieldMask other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FieldMask other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    internal static string ToJson(IList`1<string> paths, bool diagnosticOnly);
    public sealed virtual string ToDiagnosticString();
    public static FieldMask FromString(string value);
    public static FieldMask FromString(string value);
    public static FieldMask FromStringEnumerable(IEnumerable`1<string> paths);
    public static FieldMask FromFieldNumbers(Int32[] fieldNumbers);
    public static FieldMask FromFieldNumbers(IEnumerable`1<int> fieldNumbers);
    private static bool IsPathValid(string input);
    public static bool IsValid(FieldMask fieldMask);
    public static bool IsValid(MessageDescriptor descriptor, FieldMask fieldMask);
    public static bool IsValid(string path);
    public static bool IsValid(MessageDescriptor descriptor, string path);
    public FieldMask Normalize();
    public FieldMask Union(FieldMask[] otherMasks);
    public FieldMask Intersection(FieldMask additionalMask);
    public void Merge(IMessage source, IMessage destination, MergeOptions options);
    public void Merge(IMessage source, IMessage destination);
}
internal static class Google.Protobuf.WellKnownTypes.FieldMaskReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static FieldMaskReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.FloatValue : object {
    private static MessageParser`1<FloatValue> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private float value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<FloatValue> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public float Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public FloatValue(FloatValue other);
    private static FloatValue();
    public static MessageParser`1<FloatValue> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual FloatValue Clone();
    public float get_Value();
    public void set_Value(float value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(FloatValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(FloatValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Int32Value : object {
    private static MessageParser`1<Int32Value> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private int value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Int32Value> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Int32Value(Int32Value other);
    private static Int32Value();
    public static MessageParser`1<Int32Value> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Int32Value Clone();
    public int get_Value();
    public void set_Value(int value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Int32Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Int32Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Int64Value : object {
    private static MessageParser`1<Int64Value> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private long value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Int64Value> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public long Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Int64Value(Int64Value other);
    private static Int64Value();
    public static MessageParser`1<Int64Value> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Int64Value Clone();
    public long get_Value();
    public void set_Value(long value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Int64Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Int64Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.ListValue : object {
    private static MessageParser`1<ListValue> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValuesFieldNumber;
    private static FieldCodec`1<Value> _repeated_values_codec;
    private RepeatedField`1<Value> values_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<ListValue> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Value> Values { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ListValue(ListValue other);
    private static ListValue();
    public static MessageParser`1<ListValue> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual ListValue Clone();
    public RepeatedField`1<Value> get_Values();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(ListValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(ListValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Method : object {
    private static MessageParser`1<Method> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private string name_;
    public static int RequestTypeUrlFieldNumber;
    private string requestTypeUrl_;
    public static int RequestStreamingFieldNumber;
    private bool requestStreaming_;
    public static int ResponseTypeUrlFieldNumber;
    private string responseTypeUrl_;
    public static int ResponseStreamingFieldNumber;
    private bool responseStreaming_;
    public static int OptionsFieldNumber;
    private static FieldCodec`1<Option> _repeated_options_codec;
    private RepeatedField`1<Option> options_;
    public static int SyntaxFieldNumber;
    private Syntax syntax_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Method> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string RequestTypeUrl { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool RequestStreaming { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string ResponseTypeUrl { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool ResponseStreaming { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Option> Options { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Syntax Syntax { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Method(Method other);
    private static Method();
    public static MessageParser`1<Method> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Method Clone();
    public string get_Name();
    public void set_Name(string value);
    public string get_RequestTypeUrl();
    public void set_RequestTypeUrl(string value);
    public bool get_RequestStreaming();
    public void set_RequestStreaming(bool value);
    public string get_ResponseTypeUrl();
    public void set_ResponseTypeUrl(string value);
    public bool get_ResponseStreaming();
    public void set_ResponseStreaming(bool value);
    public RepeatedField`1<Option> get_Options();
    public Syntax get_Syntax();
    public void set_Syntax(Syntax value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Method other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Method other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Mixin : object {
    private static MessageParser`1<Mixin> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private string name_;
    public static int RootFieldNumber;
    private string root_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Mixin> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Root { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Mixin(Mixin other);
    private static Mixin();
    public static MessageParser`1<Mixin> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Mixin Clone();
    public string get_Name();
    public void set_Name(string value);
    public string get_Root();
    public void set_Root(string value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Mixin other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Mixin other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal enum Google.Protobuf.WellKnownTypes.NullValue : Enum {
    public int value__;
    [OriginalNameAttribute("NULL_VALUE")]
public static NullValue NullValue;
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Option : object {
    private static MessageParser`1<Option> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private string name_;
    public static int ValueFieldNumber;
    private Any value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Option> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Any Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Option(Option other);
    private static Option();
    public static MessageParser`1<Option> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Option Clone();
    public string get_Name();
    public void set_Name(string value);
    public Any get_Value();
    public void set_Value(Any value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Option other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Option other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.SourceContext : object {
    private static MessageParser`1<SourceContext> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FileNameFieldNumber;
    private string fileName_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<SourceContext> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string FileName { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public SourceContext(SourceContext other);
    private static SourceContext();
    public static MessageParser`1<SourceContext> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual SourceContext Clone();
    public string get_FileName();
    public void set_FileName(string value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(SourceContext other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(SourceContext other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal static class Google.Protobuf.WellKnownTypes.SourceContextReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static SourceContextReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.StringValue : object {
    private static MessageParser`1<StringValue> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private string value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<StringValue> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public StringValue(StringValue other);
    private static StringValue();
    public static MessageParser`1<StringValue> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual StringValue Clone();
    public string get_Value();
    public void set_Value(string value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(StringValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(StringValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Struct : object {
    private static MessageParser`1<Struct> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FieldsFieldNumber;
    private static Codec<string, Value> _map_fields_codec;
    private MapField`2<string, Value> fields_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Struct> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MapField`2<string, Value> Fields { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Struct(Struct other);
    private static Struct();
    public static MessageParser`1<Struct> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Struct Clone();
    public MapField`2<string, Value> get_Fields();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Struct other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Struct other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal static class Google.Protobuf.WellKnownTypes.StructReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static StructReflection();
    public static FileDescriptor get_Descriptor();
}
internal enum Google.Protobuf.WellKnownTypes.Syntax : Enum {
    public int value__;
    [OriginalNameAttribute("SYNTAX_PROTO2")]
public static Syntax Proto2;
    [OriginalNameAttribute("SYNTAX_PROTO3")]
public static Syntax Proto3;
    [OriginalNameAttribute("SYNTAX_EDITIONS")]
public static Syntax Editions;
}
[ExtensionAttribute]
internal static class Google.Protobuf.WellKnownTypes.TimeExtensions : object {
    [ExtensionAttribute]
public static Timestamp ToTimestamp(DateTime dateTime);
    [ExtensionAttribute]
public static Timestamp ToTimestamp(DateTimeOffset dateTimeOffset);
    [ExtensionAttribute]
public static Duration ToDuration(TimeSpan timeSpan);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Timestamp : object {
    private static MessageParser`1<Timestamp> _parser;
    private UnknownFieldSet _unknownFields;
    public static int SecondsFieldNumber;
    private long seconds_;
    public static int NanosFieldNumber;
    private int nanos_;
    private static DateTime UnixEpoch;
    private static long BclSecondsAtUnixEpoch;
    internal static long UnixSecondsAtBclMaxValue;
    internal static long UnixSecondsAtBclMinValue;
    internal static int MaxNanos;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Timestamp> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public long Seconds { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public int Nanos { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Timestamp(Timestamp other);
    private static Timestamp();
    public static MessageParser`1<Timestamp> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Timestamp Clone();
    public long get_Seconds();
    public void set_Seconds(long value);
    public int get_Nanos();
    public void set_Nanos(int value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Timestamp other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Timestamp other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    private static bool IsNormalized(long seconds, int nanoseconds);
    public static Duration op_Subtraction(Timestamp lhs, Timestamp rhs);
    public static Timestamp op_Addition(Timestamp lhs, Duration rhs);
    public static Timestamp op_Subtraction(Timestamp lhs, Duration rhs);
    public DateTime ToDateTime();
    public DateTimeOffset ToDateTimeOffset();
    public static Timestamp FromDateTime(DateTime dateTime);
    public static Timestamp FromDateTimeOffset(DateTimeOffset dateTimeOffset);
    internal static Timestamp Normalize(long seconds, int nanoseconds);
    internal static string ToJson(long seconds, int nanoseconds, bool diagnosticOnly);
    public sealed virtual int CompareTo(Timestamp other);
    public static bool op_LessThan(Timestamp a, Timestamp b);
    public static bool op_GreaterThan(Timestamp a, Timestamp b);
    public static bool op_LessThanOrEqual(Timestamp a, Timestamp b);
    public static bool op_GreaterThanOrEqual(Timestamp a, Timestamp b);
    public static bool op_Equality(Timestamp a, Timestamp b);
    public static bool op_Inequality(Timestamp a, Timestamp b);
    public sealed virtual string ToDiagnosticString();
}
internal static class Google.Protobuf.WellKnownTypes.TimestampReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static TimestampReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Type : object {
    private static MessageParser`1<Type> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NameFieldNumber;
    private string name_;
    public static int FieldsFieldNumber;
    private static FieldCodec`1<Field> _repeated_fields_codec;
    private RepeatedField`1<Field> fields_;
    public static int OneofsFieldNumber;
    private static FieldCodec`1<string> _repeated_oneofs_codec;
    private RepeatedField`1<string> oneofs_;
    public static int OptionsFieldNumber;
    private static FieldCodec`1<Option> _repeated_options_codec;
    private RepeatedField`1<Option> options_;
    public static int SourceContextFieldNumber;
    private SourceContext sourceContext_;
    public static int SyntaxFieldNumber;
    private Syntax syntax_;
    public static int EditionFieldNumber;
    private string edition_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Type> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Name { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Field> Fields { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<string> Oneofs { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Option> Options { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public SourceContext SourceContext { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Syntax Syntax { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string Edition { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Type(Type other);
    private static Type();
    public static MessageParser`1<Type> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Type Clone();
    public string get_Name();
    public void set_Name(string value);
    public RepeatedField`1<Field> get_Fields();
    public RepeatedField`1<string> get_Oneofs();
    public RepeatedField`1<Option> get_Options();
    public SourceContext get_SourceContext();
    public void set_SourceContext(SourceContext value);
    public Syntax get_Syntax();
    public void set_Syntax(Syntax value);
    public string get_Edition();
    public void set_Edition(string value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Type other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Type other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
internal static class Google.Protobuf.WellKnownTypes.TypeReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static TypeReflection();
    public static FileDescriptor get_Descriptor();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.UInt32Value : object {
    private static MessageParser`1<UInt32Value> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private UInt32 value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<UInt32Value> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public UInt32 Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public UInt32Value(UInt32Value other);
    private static UInt32Value();
    public static MessageParser`1<UInt32Value> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual UInt32Value Clone();
    public UInt32 get_Value();
    public void set_Value(UInt32 value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(UInt32Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(UInt32Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.UInt64Value : object {
    private static MessageParser`1<UInt64Value> _parser;
    private UnknownFieldSet _unknownFields;
    public static int ValueFieldNumber;
    private ulong value_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<UInt64Value> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ulong Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public UInt64Value(UInt64Value other);
    private static UInt64Value();
    public static MessageParser`1<UInt64Value> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual UInt64Value Clone();
    public ulong get_Value();
    public void set_Value(ulong value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(UInt64Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(UInt64Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal class Google.Protobuf.WellKnownTypes.Value : object {
    private static MessageParser`1<Value> _parser;
    private UnknownFieldSet _unknownFields;
    public static int NullValueFieldNumber;
    public static int NumberValueFieldNumber;
    public static int StringValueFieldNumber;
    public static int BoolValueFieldNumber;
    public static int StructValueFieldNumber;
    public static int ListValueFieldNumber;
    private object kind_;
    private KindOneofCase kindCase_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Value> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public NullValue NullValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasNullValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public double NumberValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasNumberValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string StringValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasStringValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool BoolValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasBoolValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Struct StructValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ListValue ListValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public KindOneofCase KindCase { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Value(Value other);
    private static Value();
    public static MessageParser`1<Value> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Value Clone();
    public NullValue get_NullValue();
    public void set_NullValue(NullValue value);
    public bool get_HasNullValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearNullValue();
    public double get_NumberValue();
    public void set_NumberValue(double value);
    public bool get_HasNumberValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearNumberValue();
    public string get_StringValue();
    public void set_StringValue(string value);
    public bool get_HasStringValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearStringValue();
    public bool get_BoolValue();
    public void set_BoolValue(bool value);
    public bool get_HasBoolValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearBoolValue();
    public Struct get_StructValue();
    public void set_StructValue(Struct value);
    public ListValue get_ListValue();
    public void set_ListValue(ListValue value);
    public KindOneofCase get_KindCase();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearKind();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Value other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
    public static Value ForString(string value);
    public static Value ForNumber(double value);
    public static Value ForBool(bool value);
    public static Value ForNull();
    public static Value ForList(Value[] values);
    public static Value ForStruct(Struct value);
}
internal static class Google.Protobuf.WellKnownTypes.WrappersReflection : object {
    private static FileDescriptor descriptor;
    internal static int WrapperValueFieldNumber;
    public static FileDescriptor Descriptor { get; }
    private static WrappersReflection();
    public static FileDescriptor get_Descriptor();
}
public static class Google.Protobuf.WireFormat : object {
    private static int TagTypeBits;
    private static UInt32 TagTypeMask;
    public static WireType GetTagWireType(UInt32 tag);
    public static int GetTagFieldNumber(UInt32 tag);
    public static UInt32 MakeTag(int fieldNumber, WireType wireType);
}
[SecuritySafeCriticalAttribute]
internal class Google.Protobuf.WriteBufferHelper : ValueType {
    private IBufferWriter`1<byte> bufferWriter;
    private CodedOutputStream codedOutputStream;
    public CodedOutputStream CodedOutputStream { get; }
    public CodedOutputStream get_CodedOutputStream();
    public static void Initialize(CodedOutputStream codedOutputStream, WriteBufferHelper& instance);
    public static void Initialize(IBufferWriter`1<byte> bufferWriter, WriteBufferHelper& instance, Span`1& buffer);
    public static void InitializeNonRefreshable(WriteBufferHelper& instance);
    public static void CheckNoSpaceLeft(WriterInternalState& state);
    public static int GetSpaceLeft(WriterInternalState& state);
    public static void RefreshBuffer(Span`1& buffer, WriterInternalState& state);
    public static void Flush(Span`1& buffer, WriterInternalState& state);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[SecuritySafeCriticalAttribute]
public class Google.Protobuf.WriteContext : ValueType {
    internal Span`1<byte> buffer;
    internal WriterInternalState state;
    internal static void Initialize(Span`1& buffer, WriterInternalState& state, WriteContext& ctx);
    internal static void Initialize(CodedOutputStream output, WriteContext& ctx);
    internal static void Initialize(IBufferWriter`1<byte> output, WriteContext& ctx);
    internal static void Initialize(Span`1& buffer, WriteContext& ctx);
    public void WriteDouble(double value);
    public void WriteFloat(float value);
    public void WriteUInt64(ulong value);
    public void WriteInt64(long value);
    public void WriteInt32(int value);
    public void WriteFixed64(ulong value);
    public void WriteFixed32(UInt32 value);
    public void WriteBool(bool value);
    public void WriteString(string value);
    public void WriteMessage(IMessage value);
    public void WriteGroup(IMessage value);
    public void WriteBytes(ByteString value);
    public void WriteUInt32(UInt32 value);
    public void WriteEnum(int value);
    public void WriteSFixed32(int value);
    public void WriteSFixed64(long value);
    public void WriteSInt32(int value);
    public void WriteSInt64(long value);
    public void WriteLength(int length);
    public void WriteTag(int fieldNumber, WireType type);
    public void WriteTag(UInt32 tag);
    public void WriteRawTag(byte b1);
    public void WriteRawTag(byte b1, byte b2);
    public void WriteRawTag(byte b1, byte b2, byte b3);
    public void WriteRawTag(byte b1, byte b2, byte b3, byte b4);
    public void WriteRawTag(byte b1, byte b2, byte b3, byte b4, byte b5);
    internal void Flush();
    internal void CheckNoSpaceLeft();
    internal void CopyStateTo(CodedOutputStream output);
    internal void LoadStateFrom(CodedOutputStream output);
}
internal class Google.Protobuf.WriterInternalState : ValueType {
    internal int limit;
    internal int position;
    internal WriteBufferHelper writeBufferHelper;
    internal CodedOutputStream CodedOutputStream { get; }
    internal CodedOutputStream get_CodedOutputStream();
}
[SecuritySafeCriticalAttribute]
internal static class Google.Protobuf.WritingPrimitives : object {
    internal static Encoding Utf8Encoding;
    private static WritingPrimitives();
    public static void WriteDouble(Span`1& buffer, WriterInternalState& state, double value);
    public static void WriteFloat(Span`1& buffer, WriterInternalState& state, float value);
    private static void WriteFloatSlowPath(Span`1& buffer, WriterInternalState& state, float value);
    public static void WriteUInt64(Span`1& buffer, WriterInternalState& state, ulong value);
    public static void WriteInt64(Span`1& buffer, WriterInternalState& state, long value);
    public static void WriteInt32(Span`1& buffer, WriterInternalState& state, int value);
    public static void WriteFixed64(Span`1& buffer, WriterInternalState& state, ulong value);
    public static void WriteFixed32(Span`1& buffer, WriterInternalState& state, UInt32 value);
    public static void WriteBool(Span`1& buffer, WriterInternalState& state, bool value);
    public static void WriteString(Span`1& buffer, WriterInternalState& state, string value);
    private static void WriteAsciiStringToBuffer(Span`1<byte> buffer, WriterInternalState& state, string value, int length);
    private static void NarrowFourUtf16CharsToAsciiAndWriteToBuffer(Byte& outputBuffer, ulong value);
    private static int WriteStringToBuffer(Span`1<byte> buffer, WriterInternalState& state, string value);
    public static void WriteBytes(Span`1& buffer, WriterInternalState& state, ByteString value);
    public static void WriteUInt32(Span`1& buffer, WriterInternalState& state, UInt32 value);
    public static void WriteEnum(Span`1& buffer, WriterInternalState& state, int value);
    public static void WriteSFixed32(Span`1& buffer, WriterInternalState& state, int value);
    public static void WriteSFixed64(Span`1& buffer, WriterInternalState& state, long value);
    public static void WriteSInt32(Span`1& buffer, WriterInternalState& state, int value);
    public static void WriteSInt64(Span`1& buffer, WriterInternalState& state, long value);
    public static void WriteLength(Span`1& buffer, WriterInternalState& state, int length);
    public static void WriteRawVarint32(Span`1& buffer, WriterInternalState& state, UInt32 value);
    public static void WriteRawVarint64(Span`1& buffer, WriterInternalState& state, ulong value);
    public static void WriteRawLittleEndian32(Span`1& buffer, WriterInternalState& state, UInt32 value);
    private static void WriteRawLittleEndian32SlowPath(Span`1& buffer, WriterInternalState& state, UInt32 value);
    public static void WriteRawLittleEndian64(Span`1& buffer, WriterInternalState& state, ulong value);
    public static void WriteRawLittleEndian64SlowPath(Span`1& buffer, WriterInternalState& state, ulong value);
    private static void WriteRawByte(Span`1& buffer, WriterInternalState& state, byte value);
    public static void WriteRawBytes(Span`1& buffer, WriterInternalState& state, Byte[] value);
    public static void WriteRawBytes(Span`1& buffer, WriterInternalState& state, Byte[] value, int offset, int length);
    public static void WriteRawBytes(Span`1& buffer, WriterInternalState& state, ReadOnlySpan`1<byte> value);
    public static void WriteTag(Span`1& buffer, WriterInternalState& state, int fieldNumber, WireType type);
    public static void WriteTag(Span`1& buffer, WriterInternalState& state, UInt32 tag);
    public static void WriteRawTag(Span`1& buffer, WriterInternalState& state, byte b1);
    public static void WriteRawTag(Span`1& buffer, WriterInternalState& state, byte b1, byte b2);
    private static void WriteRawTagSlowPath(Span`1& buffer, WriterInternalState& state, byte b1, byte b2);
    public static void WriteRawTag(Span`1& buffer, WriterInternalState& state, byte b1, byte b2, byte b3);
    private static void WriteRawTagSlowPath(Span`1& buffer, WriterInternalState& state, byte b1, byte b2, byte b3);
    public static void WriteRawTag(Span`1& buffer, WriterInternalState& state, byte b1, byte b2, byte b3, byte b4);
    private static void WriteRawTagSlowPath(Span`1& buffer, WriterInternalState& state, byte b1, byte b2, byte b3, byte b4);
    public static void WriteRawTag(Span`1& buffer, WriterInternalState& state, byte b1, byte b2, byte b3, byte b4, byte b5);
    private static void WriteRawTagSlowPath(Span`1& buffer, WriterInternalState& state, byte b1, byte b2, byte b3, byte b4, byte b5);
    public static UInt32 EncodeZigZag32(int n);
    public static ulong EncodeZigZag64(long n);
}
[SecuritySafeCriticalAttribute]
internal static class Google.Protobuf.WritingPrimitivesMessages : object {
    public static void WriteMessage(WriteContext& ctx, IMessage value);
    public static void WriteGroup(WriteContext& ctx, IMessage value);
    public static void WriteRawMessage(WriteContext& ctx, IMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Grpc.Core.Api.Utils.EncodingExtensions : object {
    [ExtensionAttribute]
public static string GetString(Encoding encoding, Byte* source, int byteCount);
    [ExtensionAttribute]
public static string GetString(Encoding encoding, IntPtr ptr, int len);
}
internal class Grpc.Core.AsyncAuthInterceptor : MulticastDelegate {
    public AsyncAuthInterceptor(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(AuthInterceptorContext context, Metadata metadata);
    public virtual IAsyncResult BeginInvoke(AuthInterceptorContext context, Metadata metadata, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.AsyncCallState : ValueType {
    private object responseHeadersAsync;
    private object getStatusFunc;
    private object getTrailersFunc;
    private object disposeAction;
    [NullableAttribute("2")]
private object callbackState;
    internal AsyncCallState(Func`2<object, Task`1<Metadata>> responseHeadersAsync, Func`2<object, Status> getStatusFunc, Func`2<object, Metadata> getTrailersFunc, Action`1<object> disposeAction, object callbackState);
    internal AsyncCallState(Task`1<Metadata> responseHeadersAsync, Func`1<Status> getStatusFunc, Func`1<Metadata> getTrailersFunc, Action disposeAction);
    internal Task`1<Metadata> ResponseHeadersAsync();
    internal Status GetStatus();
    internal Metadata GetTrailers();
    internal void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.AsyncClientStreamingCall`2 : object {
    private IClientStreamWriter`1<TRequest> requestStream;
    private Task`1<TResponse> responseAsync;
    private AsyncCallState callState;
    public Task`1<TResponse> ResponseAsync { get; }
    public Task`1<Metadata> ResponseHeadersAsync { get; }
    public IClientStreamWriter`1<TRequest> RequestStream { get; }
    public AsyncClientStreamingCall`2(IClientStreamWriter`1<TRequest> requestStream, Task`1<TResponse> responseAsync, Task`1<Metadata> responseHeadersAsync, Func`1<Status> getStatusFunc, Func`1<Metadata> getTrailersFunc, Action disposeAction);
    public AsyncClientStreamingCall`2(IClientStreamWriter`1<TRequest> requestStream, Task`1<TResponse> responseAsync, Func`2<object, Task`1<Metadata>> responseHeadersAsync, Func`2<object, Status> getStatusFunc, Func`2<object, Metadata> getTrailersFunc, Action`1<object> disposeAction, object state);
    public Task`1<TResponse> get_ResponseAsync();
    public Task`1<Metadata> get_ResponseHeadersAsync();
    public IClientStreamWriter`1<TRequest> get_RequestStream();
    public TaskAwaiter`1<TResponse> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResponse> ConfigureAwait(bool continueOnCapturedContext);
    public Status GetStatus();
    public Metadata GetTrailers();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.AsyncDuplexStreamingCall`2 : object {
    private IClientStreamWriter`1<TRequest> requestStream;
    private IAsyncStreamReader`1<TResponse> responseStream;
    private AsyncCallState callState;
    public IAsyncStreamReader`1<TResponse> ResponseStream { get; }
    public IClientStreamWriter`1<TRequest> RequestStream { get; }
    public Task`1<Metadata> ResponseHeadersAsync { get; }
    public AsyncDuplexStreamingCall`2(IClientStreamWriter`1<TRequest> requestStream, IAsyncStreamReader`1<TResponse> responseStream, Task`1<Metadata> responseHeadersAsync, Func`1<Status> getStatusFunc, Func`1<Metadata> getTrailersFunc, Action disposeAction);
    public AsyncDuplexStreamingCall`2(IClientStreamWriter`1<TRequest> requestStream, IAsyncStreamReader`1<TResponse> responseStream, Func`2<object, Task`1<Metadata>> responseHeadersAsync, Func`2<object, Status> getStatusFunc, Func`2<object, Metadata> getTrailersFunc, Action`1<object> disposeAction, object state);
    public IAsyncStreamReader`1<TResponse> get_ResponseStream();
    public IClientStreamWriter`1<TRequest> get_RequestStream();
    public Task`1<Metadata> get_ResponseHeadersAsync();
    public Status GetStatus();
    public Metadata GetTrailers();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.AsyncServerStreamingCall`1 : object {
    private IAsyncStreamReader`1<TResponse> responseStream;
    private AsyncCallState callState;
    public IAsyncStreamReader`1<TResponse> ResponseStream { get; }
    public Task`1<Metadata> ResponseHeadersAsync { get; }
    public AsyncServerStreamingCall`1(IAsyncStreamReader`1<TResponse> responseStream, Task`1<Metadata> responseHeadersAsync, Func`1<Status> getStatusFunc, Func`1<Metadata> getTrailersFunc, Action disposeAction);
    public AsyncServerStreamingCall`1(IAsyncStreamReader`1<TResponse> responseStream, Func`2<object, Task`1<Metadata>> responseHeadersAsync, Func`2<object, Status> getStatusFunc, Func`2<object, Metadata> getTrailersFunc, Action`1<object> disposeAction, object state);
    public IAsyncStreamReader`1<TResponse> get_ResponseStream();
    public Task`1<Metadata> get_ResponseHeadersAsync();
    public Status GetStatus();
    public Metadata GetTrailers();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Grpc.Core.AsyncStreamReaderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task`1<bool> MoveNext(IAsyncStreamReader`1<T> streamReader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.AsyncUnaryCall`1 : object {
    private Task`1<TResponse> responseAsync;
    private AsyncCallState callState;
    public Task`1<TResponse> ResponseAsync { get; }
    public Task`1<Metadata> ResponseHeadersAsync { get; }
    public AsyncUnaryCall`1(Task`1<TResponse> responseAsync, Task`1<Metadata> responseHeadersAsync, Func`1<Status> getStatusFunc, Func`1<Metadata> getTrailersFunc, Action disposeAction);
    public AsyncUnaryCall`1(Task`1<TResponse> responseAsync, Func`2<object, Task`1<Metadata>> responseHeadersAsync, Func`2<object, Status> getStatusFunc, Func`2<object, Metadata> getTrailersFunc, Action`1<object> disposeAction, object state);
    public Task`1<TResponse> get_ResponseAsync();
    public Task`1<Metadata> get_ResponseHeadersAsync();
    public TaskAwaiter`1<TResponse> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResponse> ConfigureAwait(bool continueOnCapturedContext);
    public Status GetStatus();
    public Metadata GetTrailers();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.AuthContext : object {
    [NullableAttribute("2")]
private string peerIdentityPropertyName;
    private Dictionary`2<string, List`1<AuthProperty>> properties;
    public bool IsPeerAuthenticated { get; }
    [NullableAttribute("2")]
public string PeerIdentityPropertyName { get; }
    public IEnumerable`1<AuthProperty> PeerIdentity { get; }
    public IEnumerable`1<AuthProperty> Properties { get; }
    public AuthContext(string peerIdentityPropertyName, Dictionary`2<string, List`1<AuthProperty>> properties);
    public bool get_IsPeerAuthenticated();
    [NullableContextAttribute("2")]
public string get_PeerIdentityPropertyName();
    public IEnumerable`1<AuthProperty> get_PeerIdentity();
    public IEnumerable`1<AuthProperty> get_Properties();
    public IEnumerable`1<AuthProperty> FindPropertiesByName(string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.AuthInterceptorContext : object {
    private string serviceUrl;
    private string methodName;
    public string ServiceUrl { get; }
    public string MethodName { get; }
    public AuthInterceptorContext(string serviceUrl, string methodName);
    public string get_ServiceUrl();
    public string get_MethodName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.AuthProperty : object {
    private static Encoding EncodingUTF8;
    private string name;
    private Byte[] valueBytes;
    [NullableAttribute("2")]
private string lazyValue;
    public string Name { get; }
    public string Value { get; }
    public Byte[] ValueBytes { get; }
    internal Byte[] ValueBytesUnsafe { get; }
    private AuthProperty(string name, Byte[] valueBytes);
    private static AuthProperty();
    public string get_Name();
    public string get_Value();
    public Byte[] get_ValueBytes();
    public static AuthProperty Create(string name, Byte[] valueBytes);
    internal Byte[] get_ValueBytesUnsafe();
    internal static AuthProperty CreateUnsafe(string name, Byte[] valueBytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Grpc.Core.BindServiceMethodAttribute : Attribute {
    private static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes ServiceBinderAccessibility;
    [CompilerGeneratedAttribute]
private Type <BindType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BindMethodName>k__BackingField;
    [<b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMembersAttribute("24")]
public Type BindType { get; }
    public string BindMethodName { get; }
    public BindServiceMethodAttribute(Type bindType, string bindMethodName);
    [CompilerGeneratedAttribute]
public Type get_BindType();
    [CompilerGeneratedAttribute]
public string get_BindMethodName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.CallCredentials : object {
    public static CallCredentials Compose(CallCredentials[] credentials);
    public static CallCredentials FromInterceptor(AsyncAuthInterceptor interceptor);
    public abstract virtual void InternalPopulateConfiguration(CallCredentialsConfiguratorBase configurator, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.CallCredentialsConfiguratorBase : object {
    public abstract virtual void SetCompositeCredentials(object state, IReadOnlyList`1<CallCredentials> credentials);
    public abstract virtual void SetAsyncAuthInterceptorCredentials(object state, AsyncAuthInterceptor interceptor);
}
internal class Grpc.Core.CallInvocationDetails`2 : ValueType {
    private Channel channel;
    private string method;
    private string host;
    private Marshaller`1<TRequest> requestMarshaller;
    private Marshaller`1<TResponse> responseMarshaller;
    private CallOptions options;
    public Channel Channel { get; }
    public string Method { get; }
    public string Host { get; }
    public Marshaller`1<TRequest> RequestMarshaller { get; }
    public Marshaller`1<TResponse> ResponseMarshaller { get; }
    public CallOptions Options { get; }
    public CallInvocationDetails`2(Channel channel, Method`2<TRequest, TResponse> method, CallOptions options);
    public CallInvocationDetails`2(Channel channel, Method`2<TRequest, TResponse> method, string host, CallOptions options);
    public CallInvocationDetails`2(Channel channel, string method, string host, Marshaller`1<TRequest> requestMarshaller, Marshaller`1<TResponse> responseMarshaller, CallOptions options);
    public Channel get_Channel();
    public string get_Method();
    public string get_Host();
    public Marshaller`1<TRequest> get_RequestMarshaller();
    public Marshaller`1<TResponse> get_ResponseMarshaller();
    public CallOptions get_Options();
    public CallInvocationDetails`2<TRequest, TResponse> WithOptions(CallOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.CallInvoker : object {
    public abstract virtual TResponse BlockingUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public abstract virtual AsyncUnaryCall`1<TResponse> AsyncUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public abstract virtual AsyncServerStreamingCall`1<TResponse> AsyncServerStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public abstract virtual AsyncClientStreamingCall`2<TRequest, TResponse> AsyncClientStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
    public abstract virtual AsyncDuplexStreamingCall`2<TRequest, TResponse> AsyncDuplexStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Grpc.Core.CallOptions : ValueType {
    private Metadata headers;
    private Nullable`1<DateTime> deadline;
    private CancellationToken cancellationToken;
    private WriteOptions writeOptions;
    private ContextPropagationToken propagationToken;
    private CallCredentials credentials;
    private CallFlags flags;
    public Metadata Headers { get; }
    public Nullable`1<DateTime> Deadline { get; }
    public CancellationToken CancellationToken { get; }
    public WriteOptions WriteOptions { get; }
    public ContextPropagationToken PropagationToken { get; }
    public CallCredentials Credentials { get; }
    public bool IsWaitForReady { get; }
    internal CallFlags Flags { get; }
    public CallOptions(Metadata headers, Nullable`1<DateTime> deadline, CancellationToken cancellationToken, WriteOptions writeOptions, ContextPropagationToken propagationToken, CallCredentials credentials);
    public Metadata get_Headers();
    public Nullable`1<DateTime> get_Deadline();
    public CancellationToken get_CancellationToken();
    public WriteOptions get_WriteOptions();
    public ContextPropagationToken get_PropagationToken();
    public CallCredentials get_Credentials();
    public bool get_IsWaitForReady();
    internal CallFlags get_Flags();
    [NullableContextAttribute("1")]
public CallOptions WithHeaders(Metadata headers);
    public CallOptions WithDeadline(DateTime deadline);
    public CallOptions WithCancellationToken(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public CallOptions WithWriteOptions(WriteOptions writeOptions);
    [NullableContextAttribute("1")]
public CallOptions WithPropagationToken(ContextPropagationToken propagationToken);
    [NullableContextAttribute("1")]
public CallOptions WithCredentials(CallCredentials credentials);
    public CallOptions WithWaitForReady(bool waitForReady);
    internal CallOptions WithFlags(CallFlags flags);
}
internal static class Grpc.Core.Calls : object {
    public static TResponse BlockingUnaryCall(CallInvocationDetails`2<TRequest, TResponse> call, TRequest req);
    public static AsyncUnaryCall`1<TResponse> AsyncUnaryCall(CallInvocationDetails`2<TRequest, TResponse> call, TRequest req);
    public static AsyncServerStreamingCall`1<TResponse> AsyncServerStreamingCall(CallInvocationDetails`2<TRequest, TResponse> call, TRequest req);
    public static AsyncClientStreamingCall`2<TRequest, TResponse> AsyncClientStreamingCall(CallInvocationDetails`2<TRequest, TResponse> call);
    public static AsyncDuplexStreamingCall`2<TRequest, TResponse> AsyncDuplexStreamingCall(CallInvocationDetails`2<TRequest, TResponse> call);
}
internal class Grpc.Core.Channel : ChannelBase {
    private static ILogger Logger;
    private object myLock;
    private AtomicCounter activeCallCounter;
    private CancellationTokenSource shutdownTokenSource;
    private GrpcEnvironment environment;
    private CompletionQueueSafeHandle completionQueue;
    private ChannelSafeHandle handle;
    private Dictionary`2<string, ChannelOption> options;
    private bool shutdownRequested;
    private static BatchCompletionDelegate WatchConnectivityStateHandler;
    public ChannelState State { get; }
    public string ResolvedTarget { get; }
    public CancellationToken ShutdownToken { get; }
    internal ChannelSafeHandle Handle { get; }
    internal GrpcEnvironment Environment { get; }
    internal CompletionQueueSafeHandle CompletionQueue { get; }
    public Channel(string target, ChannelCredentials credentials);
    public Channel(string target, ChannelCredentials credentials, IEnumerable`1<ChannelOption> options);
    public Channel(string host, int port, ChannelCredentials credentials);
    public Channel(string host, int port, ChannelCredentials credentials, IEnumerable`1<ChannelOption> options);
    private static Channel();
    public ChannelState get_State();
    [AsyncStateMachineAttribute("Grpc.Core.Channel/<WaitForStateChangedAsync>d__16")]
public Task WaitForStateChangedAsync(ChannelState lastObservedState, Nullable`1<DateTime> deadline);
    public Task`1<bool> TryWaitForStateChangedAsync(ChannelState lastObservedState, Nullable`1<DateTime> deadline);
    public string get_ResolvedTarget();
    public CancellationToken get_ShutdownToken();
    [AsyncStateMachineAttribute("Grpc.Core.Channel/<ConnectAsync>d__22")]
public Task ConnectAsync(Nullable`1<DateTime> deadline);
    [AsyncStateMachineAttribute("Grpc.Core.Channel/<ShutdownAsyncCore>d__23")]
protected virtual Task ShutdownAsyncCore();
    public virtual CallInvoker CreateCallInvoker();
    internal ChannelSafeHandle get_Handle();
    internal GrpcEnvironment get_Environment();
    internal CompletionQueueSafeHandle get_CompletionQueue();
    internal void AddCallReference(object call);
    internal void RemoveCallReference(object call);
    internal long GetCallReferenceCount();
    private ChannelState GetConnectivityState(bool tryToConnect);
    private static void EnsureUserAgentChannelOption(Dictionary`2<string, ChannelOption> options);
    private static Dictionary`2<string, ChannelOption> CreateOptionsDictionary(IEnumerable`1<ChannelOption> options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.ChannelBase : object {
    private string target;
    public string Target { get; }
    protected ChannelBase(string target);
    public string get_Target();
    public abstract virtual CallInvoker CreateCallInvoker();
    public Task ShutdownAsync();
    [AsyncStateMachineAttribute("Grpc.Core.ChannelBase/<ShutdownAsyncCore>d__6")]
protected virtual Task ShutdownAsyncCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.ChannelCredentials : object {
    private static ChannelCredentials InsecureInstance;
    private static ChannelCredentials SecureSslInstance;
    public static ChannelCredentials Insecure { get; }
    public static ChannelCredentials SecureSsl { get; }
    internal bool IsComposable { get; }
    private static ChannelCredentials();
    public static ChannelCredentials get_Insecure();
    public static ChannelCredentials get_SecureSsl();
    public static ChannelCredentials Create(ChannelCredentials channelCredentials, CallCredentials callCredentials);
    public abstract virtual void InternalPopulateConfiguration(ChannelCredentialsConfiguratorBase configurator, object state);
    internal virtual bool get_IsComposable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.ChannelCredentialsConfiguratorBase : object {
    public abstract virtual void SetInsecureCredentials(object state);
    [NullableContextAttribute("2")]
public abstract virtual void SetSslCredentials(object state, string rootCertificates, KeyCertificatePair keyCertificatePair, VerifyPeerCallback verifyPeerCallback);
    public abstract virtual void SetCompositeCredentials(object state, ChannelCredentials channelCredentials, CallCredentials callCredentials);
}
internal class Grpc.Core.ChannelOption : object {
    private OptionType type;
    private string name;
    private int intValue;
    private string stringValue;
    public OptionType Type { get; }
    public string Name { get; }
    public int IntValue { get; }
    public string StringValue { get; }
    public ChannelOption(string name, string stringValue);
    public ChannelOption(string name, int intValue);
    public OptionType get_Type();
    public string get_Name();
    public int get_IntValue();
    public string get_StringValue();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ChannelOption other);
    public virtual int GetHashCode();
    public static bool op_Equality(ChannelOption option1, ChannelOption option2);
    public static bool op_Inequality(ChannelOption option1, ChannelOption option2);
}
internal static class Grpc.Core.ChannelOptions : object {
    public static string SslTargetNameOverride;
    public static string Census;
    public static string MaxConcurrentStreams;
    public static string MaxReceiveMessageLength;
    public static string MaxSendMessageLength;
    [ObsoleteAttribute("Use MaxReceiveMessageLength instead.")]
public static string MaxMessageLength;
    public static string Http2InitialSequenceNumber;
    public static string DefaultAuthority;
    public static string PrimaryUserAgentString;
    public static string SecondaryUserAgentString;
    public static string SoReuseport;
    internal static ChannelArgsSafeHandle CreateChannelArgs(ICollection`1<ChannelOption> options);
}
internal enum Grpc.Core.ChannelState : Enum {
    public int value__;
    public static ChannelState Idle;
    public static ChannelState Connecting;
    public static ChannelState Ready;
    public static ChannelState TransientFailure;
    public static ChannelState Shutdown;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.ClientBase : object {
    private ClientBaseConfiguration configuration;
    private CallInvoker callInvoker;
    protected CallInvoker CallInvoker { get; }
    internal ClientBaseConfiguration Configuration { get; }
    protected ClientBase(ClientBaseConfiguration configuration);
    public ClientBase(ChannelBase channel);
    public ClientBase(CallInvoker callInvoker);
    protected CallInvoker get_CallInvoker();
    internal ClientBaseConfiguration get_Configuration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.ClientBase`1 : ClientBase {
    protected ClientBase`1(ClientBaseConfiguration configuration);
    public ClientBase`1(ChannelBase channel);
    public ClientBase`1(CallInvoker callInvoker);
    public T WithHost(string host);
    protected abstract virtual T NewInstance(ClientBaseConfiguration configuration);
}
internal class Grpc.Core.ClientStreamingServerMethod`2 : MulticastDelegate {
    public ClientStreamingServerMethod`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<TResponse> Invoke(IAsyncStreamReader`1<TRequest> requestStream, ServerCallContext context);
    public virtual IAsyncResult BeginInvoke(IAsyncStreamReader`1<TRequest> requestStream, ServerCallContext context, AsyncCallback callback, object object);
    public virtual Task`1<TResponse> EndInvoke(IAsyncResult result);
}
internal enum Grpc.Core.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel None;
    public static CompressionLevel Low;
    public static CompressionLevel Medium;
    public static CompressionLevel High;
}
internal class Grpc.Core.ContextPropagationOptions : object {
    [NullableAttribute("1")]
public static ContextPropagationOptions Default;
    private bool propagateDeadline;
    private bool propagateCancellation;
    public bool IsPropagateDeadline { get; }
    public bool IsPropagateCancellation { get; }
    public ContextPropagationOptions(bool propagateDeadline, bool propagateCancellation);
    private static ContextPropagationOptions();
    public bool get_IsPropagateDeadline();
    public bool get_IsPropagateCancellation();
}
internal abstract class Grpc.Core.ContextPropagationToken : object {
}
internal class Grpc.Core.DefaultCallInvoker : CallInvoker {
    private Channel channel;
    public DefaultCallInvoker(Channel channel);
    public virtual TResponse BlockingUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncUnaryCall`1<TResponse> AsyncUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncServerStreamingCall`1<TResponse> AsyncServerStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncClientStreamingCall`2<TRequest, TResponse> AsyncClientStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
    public virtual AsyncDuplexStreamingCall`2<TRequest, TResponse> AsyncDuplexStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
    protected virtual CallInvocationDetails`2<TRequest, TResponse> CreateCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
}
internal class Grpc.Core.DefaultServerCallContext : ServerCallContext {
    private CallSafeHandle callHandle;
    private string method;
    private string host;
    private DateTime deadline;
    private Metadata requestHeaders;
    private CancellationToken cancellationToken;
    private Metadata responseTrailers;
    private Status status;
    private IServerResponseStream serverResponseStream;
    private AuthContext lazyAuthContext;
    protected string MethodCore { get; }
    protected string HostCore { get; }
    protected string PeerCore { get; }
    protected DateTime DeadlineCore { get; }
    protected Metadata RequestHeadersCore { get; }
    protected CancellationToken CancellationTokenCore { get; }
    protected Metadata ResponseTrailersCore { get; }
    protected Status StatusCore { get; protected set; }
    protected WriteOptions WriteOptionsCore { get; protected set; }
    protected AuthContext AuthContextCore { get; }
    internal DefaultServerCallContext(CallSafeHandle callHandle, string method, string host, DateTime deadline, Metadata requestHeaders, CancellationToken cancellationToken, IServerResponseStream serverResponseStream);
    protected virtual ContextPropagationToken CreatePropagationTokenCore(ContextPropagationOptions options);
    protected virtual Task WriteResponseHeadersAsyncCore(Metadata responseHeaders);
    protected virtual string get_MethodCore();
    protected virtual string get_HostCore();
    protected virtual string get_PeerCore();
    protected virtual DateTime get_DeadlineCore();
    protected virtual Metadata get_RequestHeadersCore();
    protected virtual CancellationToken get_CancellationTokenCore();
    protected virtual Metadata get_ResponseTrailersCore();
    protected virtual Status get_StatusCore();
    protected virtual void set_StatusCore(Status value);
    protected virtual WriteOptions get_WriteOptionsCore();
    protected virtual void set_WriteOptionsCore(WriteOptions value);
    protected virtual AuthContext get_AuthContextCore();
    private AuthContext GetAuthContextEager();
}
internal abstract class Grpc.Core.DeserializationContext : object {
    public int PayloadLength { get; }
    public abstract virtual int get_PayloadLength();
    [NullableContextAttribute("1")]
public virtual Byte[] PayloadAsNewBuffer();
    public virtual ReadOnlySequence`1<byte> PayloadAsReadOnlySequence();
}
internal class Grpc.Core.DuplexStreamingServerMethod`2 : MulticastDelegate {
    public DuplexStreamingServerMethod`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(IAsyncStreamReader`1<TRequest> requestStream, IServerStreamWriter`1<TResponse> responseStream, ServerCallContext context);
    public virtual IAsyncResult BeginInvoke(IAsyncStreamReader`1<TRequest> requestStream, IServerStreamWriter`1<TResponse> responseStream, ServerCallContext context, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class Grpc.Core.GrpcEnvironment : object {
    private static int MinDefaultThreadPoolSize;
    private static int DefaultBatchContextPoolSharedCapacity;
    private static int DefaultBatchContextPoolThreadLocalCapacity;
    private static int DefaultRequestCallContextPoolSharedCapacity;
    private static int DefaultRequestCallContextPoolThreadLocalCapacity;
    private static object staticLock;
    private static GrpcEnvironment instance;
    private static int refCount;
    private static Nullable`1<int> customThreadPoolSize;
    private static Nullable`1<int> customCompletionQueueCount;
    private static bool inlineHandlers;
    private static int batchContextPoolSharedCapacity;
    private static int batchContextPoolThreadLocalCapacity;
    private static int requestCallContextPoolSharedCapacity;
    private static int requestCallContextPoolThreadLocalCapacity;
    private static HashSet`1<Channel> registeredChannels;
    private static HashSet`1<Server> registeredServers;
    private static AtomicCounter nativeInitCounter;
    private static ILogger logger;
    private IObjectPool`1<BatchContextSafeHandle> batchContextPool;
    private IObjectPool`1<RequestCallContextSafeHandle> requestCallContextPool;
    private GrpcThreadPool threadPool;
    private DebugStats debugStats;
    private AtomicCounter cqPickerCounter;
    private bool isShutdown;
    [CompilerGeneratedAttribute]
private static EventHandler ShuttingDown;
    public static ILogger Logger { get; }
    internal IReadOnlyCollection`1<CompletionQueueSafeHandle> CompletionQueues { get; }
    internal IObjectPool`1<BatchContextSafeHandle> BatchContextPool { get; }
    internal IObjectPool`1<RequestCallContextSafeHandle> RequestCallContextPool { get; }
    internal bool IsAlive { get; }
    internal DebugStats DebugStats { get; }
    private static bool IsNativeShutdownAllowed { get; }
    private static GrpcEnvironment();
    internal static GrpcEnvironment AddRef();
    [AsyncStateMachineAttribute("Grpc.Core.GrpcEnvironment/<ReleaseAsync>d__26")]
internal static Task ReleaseAsync();
    internal static int GetRefCount();
    internal static void RegisterChannel(Channel channel);
    internal static void UnregisterChannel(Channel channel);
    internal static void RegisterServer(Server server);
    internal static void UnregisterServer(Server server);
    public static Task ShutdownChannelsAsync();
    public static Task KillServersAsync();
    public static ILogger get_Logger();
    public static void SetLogger(ILogger customLogger);
    public static void SetThreadPoolSize(int threadCount);
    public static void SetCompletionQueueCount(int completionQueueCount);
    public static void SetHandlerInlining(bool inlineHandlers);
    public static void SetBatchContextPoolParams(int sharedCapacity, int threadLocalCapacity);
    public static void SetRequestCallContextPoolParams(int sharedCapacity, int threadLocalCapacity);
    [CompilerGeneratedAttribute]
public static void add_ShuttingDown(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ShuttingDown(EventHandler value);
    internal IReadOnlyCollection`1<CompletionQueueSafeHandle> get_CompletionQueues();
    internal IObjectPool`1<BatchContextSafeHandle> get_BatchContextPool();
    internal IObjectPool`1<RequestCallContextSafeHandle> get_RequestCallContextPool();
    internal bool get_IsAlive();
    internal CompletionQueueSafeHandle PickCompletionQueue();
    internal DebugStats get_DebugStats();
    internal static string GetCoreVersionString();
    internal static void GrpcNativeInit();
    internal static void GrpcNativeShutdown();
    [AsyncStateMachineAttribute("Grpc.Core.GrpcEnvironment/<ShutdownAsync>d__60")]
private Task ShutdownAsync();
    private int GetThreadPoolSizeOrDefault();
    private int GetCompletionQueueCountOrDefault();
    private static bool get_IsNativeShutdownAllowed();
    [CompilerGeneratedAttribute]
private void <ShutdownAsync>b__60_0();
}
[NullableContextAttribute("1")]
public interface Grpc.Core.IAsyncStreamReader`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
    public abstract virtual Task`1<bool> MoveNext(CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Grpc.Core.IAsyncStreamWriter`1 {
    public WriteOptions WriteOptions { get; public set; }
    [NullableContextAttribute("1")]
public abstract virtual Task WriteAsync(T message);
    public abstract virtual WriteOptions get_WriteOptions();
    public abstract virtual void set_WriteOptions(WriteOptions value);
}
[NullableContextAttribute("1")]
public interface Grpc.Core.IClientStreamWriter`1 {
    public abstract virtual Task CompleteAsync();
}
[NullableContextAttribute("1")]
internal interface Grpc.Core.IMethod {
    public MethodType Type { get; }
    public string ServiceName { get; }
    public string Name { get; }
    public string FullName { get; }
    public abstract virtual MethodType get_Type();
    public abstract virtual string get_ServiceName();
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Grpc.Core.Interceptors.CallInvokerExtensions : object {
    [ExtensionAttribute]
public static CallInvoker Intercept(CallInvoker invoker, Interceptor interceptor);
    [ExtensionAttribute]
public static CallInvoker Intercept(CallInvoker invoker, Interceptor[] interceptors);
    [ExtensionAttribute]
public static CallInvoker Intercept(CallInvoker invoker, Func`2<Metadata, Metadata> interceptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Grpc.Core.Interceptors.ChannelExtensions : object {
    [ExtensionAttribute]
public static CallInvoker Intercept(ChannelBase channel, Interceptor interceptor);
    [ExtensionAttribute]
public static CallInvoker Intercept(ChannelBase channel, Interceptor[] interceptors);
    [ExtensionAttribute]
public static CallInvoker Intercept(ChannelBase channel, Func`2<Metadata, Metadata> interceptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.Interceptors.ClientInterceptorContext`2 : ValueType {
    [CompilerGeneratedAttribute]
private Method`2<TRequest, TResponse> <Method>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private CallOptions <Options>k__BackingField;
    public Method`2<TRequest, TResponse> Method { get; }
    [NullableAttribute("2")]
public string Host { get; }
    public CallOptions Options { get; }
    public ClientInterceptorContext`2(Method`2<TRequest, TResponse> method, string host, CallOptions options);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Method`2<TRequest, TResponse> get_Method();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Host();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CallOptions get_Options();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.Interceptors.InterceptingCallInvoker : CallInvoker {
    private CallInvoker invoker;
    private Interceptor interceptor;
    public InterceptingCallInvoker(CallInvoker invoker, Interceptor interceptor);
    public virtual TResponse BlockingUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncUnaryCall`1<TResponse> AsyncUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncServerStreamingCall`1<TResponse> AsyncServerStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncClientStreamingCall`2<TRequest, TResponse> AsyncClientStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
    public virtual AsyncDuplexStreamingCall`2<TRequest, TResponse> AsyncDuplexStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
    [CompilerGeneratedAttribute]
private TResponse <BlockingUnaryCall>b__3_0(TRequest req, ClientInterceptorContext`2<TRequest, TResponse> ctx);
    [CompilerGeneratedAttribute]
private AsyncUnaryCall`1<TResponse> <AsyncUnaryCall>b__4_0(TRequest req, ClientInterceptorContext`2<TRequest, TResponse> ctx);
    [CompilerGeneratedAttribute]
private AsyncServerStreamingCall`1<TResponse> <AsyncServerStreamingCall>b__5_0(TRequest req, ClientInterceptorContext`2<TRequest, TResponse> ctx);
    [CompilerGeneratedAttribute]
private AsyncClientStreamingCall`2<TRequest, TResponse> <AsyncClientStreamingCall>b__6_0(ClientInterceptorContext`2<TRequest, TResponse> ctx);
    [CompilerGeneratedAttribute]
private AsyncDuplexStreamingCall`2<TRequest, TResponse> <AsyncDuplexStreamingCall>b__7_0(ClientInterceptorContext`2<TRequest, TResponse> ctx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.Interceptors.Interceptor : object {
    public virtual TResponse BlockingUnaryCall(TRequest request, ClientInterceptorContext`2<TRequest, TResponse> context, BlockingUnaryCallContinuation`2<TRequest, TResponse> continuation);
    public virtual AsyncUnaryCall`1<TResponse> AsyncUnaryCall(TRequest request, ClientInterceptorContext`2<TRequest, TResponse> context, AsyncUnaryCallContinuation`2<TRequest, TResponse> continuation);
    public virtual AsyncServerStreamingCall`1<TResponse> AsyncServerStreamingCall(TRequest request, ClientInterceptorContext`2<TRequest, TResponse> context, AsyncServerStreamingCallContinuation`2<TRequest, TResponse> continuation);
    public virtual AsyncClientStreamingCall`2<TRequest, TResponse> AsyncClientStreamingCall(ClientInterceptorContext`2<TRequest, TResponse> context, AsyncClientStreamingCallContinuation`2<TRequest, TResponse> continuation);
    public virtual AsyncDuplexStreamingCall`2<TRequest, TResponse> AsyncDuplexStreamingCall(ClientInterceptorContext`2<TRequest, TResponse> context, AsyncDuplexStreamingCallContinuation`2<TRequest, TResponse> continuation);
    public virtual Task`1<TResponse> UnaryServerHandler(TRequest request, ServerCallContext context, UnaryServerMethod`2<TRequest, TResponse> continuation);
    public virtual Task`1<TResponse> ClientStreamingServerHandler(IAsyncStreamReader`1<TRequest> requestStream, ServerCallContext context, ClientStreamingServerMethod`2<TRequest, TResponse> continuation);
    public virtual Task ServerStreamingServerHandler(TRequest request, IServerStreamWriter`1<TResponse> responseStream, ServerCallContext context, ServerStreamingServerMethod`2<TRequest, TResponse> continuation);
    public virtual Task DuplexStreamingServerHandler(IAsyncStreamReader`1<TRequest> requestStream, IServerStreamWriter`1<TResponse> responseStream, ServerCallContext context, DuplexStreamingServerMethod`2<TRequest, TResponse> continuation);
}
[ExtensionAttribute]
internal static class Grpc.Core.Interceptors.ServerServiceDefinitionExtensions : object {
    [ExtensionAttribute]
public static ServerServiceDefinition Intercept(ServerServiceDefinition serverServiceDefinition, Interceptor interceptor);
    [ExtensionAttribute]
public static ServerServiceDefinition Intercept(ServerServiceDefinition serverServiceDefinition, Interceptor[] interceptors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.Internal.<b1ce5518-75a7-49e1-b5f3-55f64e317762>UnimplementedCallInvoker : CallInvoker {
    public virtual TResponse BlockingUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncUnaryCall`1<TResponse> AsyncUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncServerStreamingCall`1<TResponse> AsyncServerStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncClientStreamingCall`2<TRequest, TResponse> AsyncClientStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
    public virtual AsyncDuplexStreamingCall`2<TRequest, TResponse> AsyncDuplexStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
}
internal class Grpc.Core.Internal.AsyncCall`2 : AsyncCallBase`2<TRequest, TResponse> {
    private static ILogger Logger;
    private CallInvocationDetails`2<TRequest, TResponse> details;
    private INativeCall injectedNativeCall;
    private bool registeredWithChannel;
    private CancellationTokenRegistration cancellationTokenRegistration;
    private TaskCompletionSource`1<TResponse> unaryResponseTcs;
    private TaskCompletionSource`1<object> streamingResponseCallFinishedTcs;
    private TaskCompletionSource`1<Metadata> responseHeadersTcs;
    private Nullable`1<ClientSideStatus> finishedStatus;
    public Task StreamingResponseCallFinishedTask { get; }
    public Task`1<Metadata> ResponseHeadersAsync { get; }
    public CallInvocationDetails`2<TRequest, TResponse> Details { get; }
    protected bool IsClient { get; }
    protected bool IsFinishedWithNonOkStatusClientOnly { get; }
    private IUnaryResponseClientCallback UnaryResponseClientCallback { get; }
    private IReceivedStatusOnClientCallback ReceivedStatusOnClientCallback { get; }
    private IReceivedResponseHeadersCallback ReceivedResponseHeadersCallback { get; }
    public AsyncCall`2(CallInvocationDetails`2<TRequest, TResponse> callDetails);
    public AsyncCall`2(CallInvocationDetails`2<TRequest, TResponse> callDetails, INativeCall injectedNativeCall);
    private static AsyncCall`2();
    public TResponse UnaryCall(TRequest msg);
    public Task`1<TResponse> UnaryCallAsync(TRequest msg);
    public Task`1<TResponse> ClientStreamingCallAsync();
    public void StartServerStreamingCall(TRequest msg);
    public void StartDuplexStreamingCall();
    public Task SendMessageAsync(TRequest msg, WriteFlags writeFlags);
    public Task`1<TResponse> ReadMessageAsync();
    public Task SendCloseFromClientAsync();
    public Task get_StreamingResponseCallFinishedTask();
    public Task`1<Metadata> get_ResponseHeadersAsync();
    public Status GetStatus();
    public Metadata GetTrailers();
    public CallInvocationDetails`2<TRequest, TResponse> get_Details();
    protected virtual void OnAfterReleaseResourcesLocked();
    protected virtual void OnAfterReleaseResourcesUnlocked();
    protected virtual bool get_IsClient();
    protected virtual Exception GetRpcExceptionClientOnly();
    protected virtual bool get_IsFinishedWithNonOkStatusClientOnly();
    protected virtual Task CheckSendAllowedOrEarlyResult();
    private Task CheckSendPreconditionsClientSide();
    private void Initialize(CompletionQueueSafeHandle cq);
    private void OnFailedToStartCallLocked();
    private INativeCall CreateNativeCall(CompletionQueueSafeHandle cq);
    private void RegisterCancellationCallback();
    private WriteFlags GetWriteFlagsForCall();
    private void HandleReceivedResponseHeaders(bool success, Metadata responseHeaders);
    private void HandleUnaryResponse(bool success, ClientSideStatus receivedStatus, IBufferReader receivedMessageReader, Metadata responseHeaders);
    private void HandleFinished(bool success, ClientSideStatus receivedStatus);
    private IUnaryResponseClientCallback get_UnaryResponseClientCallback();
    private sealed virtual override void Grpc.Core.Internal.IUnaryResponseClientCallback.OnUnaryResponseClient(bool success, ClientSideStatus receivedStatus, IBufferReader receivedMessageReader, Metadata responseHeaders);
    private IReceivedStatusOnClientCallback get_ReceivedStatusOnClientCallback();
    private sealed virtual override void Grpc.Core.Internal.IReceivedStatusOnClientCallback.OnReceivedStatusOnClient(bool success, ClientSideStatus receivedStatus);
    private IReceivedResponseHeadersCallback get_ReceivedResponseHeadersCallback();
    private sealed virtual override void Grpc.Core.Internal.IReceivedResponseHeadersCallback.OnReceivedResponseHeaders(bool success, Metadata responseHeaders);
    [CompilerGeneratedAttribute]
private void <OnFailedToStartCallLocked>b__37_0(object state);
}
internal abstract class Grpc.Core.Internal.AsyncCallBase`2 : object {
    private static ILogger Logger;
    protected static Status DeserializeResponseFailureStatus;
    private Action`2<TWrite, SerializationContext> serializer;
    private Func`2<DeserializationContext, TRead> deserializer;
    protected object myLock;
    protected INativeCall call;
    protected bool disposed;
    protected bool started;
    protected bool cancelRequested;
    protected TaskCompletionSource`1<TRead> streamingReadTcs;
    protected TaskCompletionSource`1<object> streamingWriteTcs;
    protected TaskCompletionSource`1<object> sendStatusFromServerTcs;
    protected bool isStreamingWriteCompletionDelayed;
    protected bool readingDone;
    protected bool halfcloseRequested;
    protected bool finished;
    protected bool initialMetadataSent;
    protected long streamingWritesCounter;
    protected bool receiveResponseHeadersPending;
    private static Action`1<object> CancelCallFromToken;
    protected bool IsClient { get; }
    protected bool IsFinishedWithNonOkStatusClientOnly { get; }
    protected ISendCompletionCallback SendCompletionCallback { get; }
    private IReceivedMessageCallback ReceivedMessageCallback { get; }
    public AsyncCallBase`2(Action`2<TWrite, SerializationContext> serializer, Func`2<DeserializationContext, TRead> deserializer);
    private static AsyncCallBase`2();
    public void Cancel();
    protected void CancelWithStatus(Status status);
    protected void InitializeInternal(INativeCall call);
    protected Task SendMessageInternalAsync(TWrite msg, WriteFlags writeFlags);
    protected Task`1<TRead> ReadMessageInternalAsync();
    protected bool ReleaseResourcesIfPossible();
    protected abstract virtual bool get_IsClient();
    protected abstract virtual Exception GetRpcExceptionClientOnly();
    protected abstract virtual bool get_IsFinishedWithNonOkStatusClientOnly();
    protected void ReleaseResources();
    protected virtual void OnAfterReleaseResourcesLocked();
    protected virtual void OnAfterReleaseResourcesUnlocked();
    protected abstract virtual Task CheckSendAllowedOrEarlyResult();
    protected SliceBufferSafeHandle UnsafeSerialize(TWrite msg, DefaultSerializationContext context);
    protected Exception TryDeserialize(IBufferReader reader, TRead& msg);
    protected void HandleSendFinished(bool success);
    protected void HandleSendStatusFromServerFinished(bool success);
    protected void HandleReadFinished(bool success, IBufferReader receivedMessageReader);
    protected ISendCompletionCallback get_SendCompletionCallback();
    private sealed virtual override void Grpc.Core.Internal.ISendCompletionCallback.OnSendCompletion(bool success);
    private IReceivedMessageCallback get_ReceivedMessageCallback();
    private sealed virtual override void Grpc.Core.Internal.IReceivedMessageCallback.OnReceivedMessage(bool success, IBufferReader receivedMessageReader);
    internal CancellationTokenRegistration RegisterCancellationCallbackForToken(CancellationToken cancellationToken);
}
internal class Grpc.Core.Internal.AsyncCallServer`2 : AsyncCallBase`2<TResponse, TRequest> {
    private TaskCompletionSource`1<object> finishedServersideTcs;
    private CancellationTokenSource cancellationTokenSource;
    private Server server;
    public CancellationToken CancellationToken { get; }
    public string Peer { get; }
    protected bool IsClient { get; }
    protected bool IsFinishedWithNonOkStatusClientOnly { get; }
    private IReceivedCloseOnServerCallback ReceiveCloseOnServerCallback { get; }
    private ISendStatusFromServerCompletionCallback SendStatusFromServerCompletionCallback { get; }
    public AsyncCallServer`2(Action`2<TResponse, SerializationContext> serializer, Func`2<DeserializationContext, TRequest> deserializer, Server server);
    public void Initialize(CallSafeHandle call, CompletionQueueSafeHandle completionQueue);
    public void InitializeForTesting(INativeCall call);
    public Task ServerSideCallAsync();
    public Task SendMessageAsync(TResponse msg, WriteFlags writeFlags);
    public Task`1<TRequest> ReadMessageAsync();
    public Task SendInitialMetadataAsync(Metadata headers);
    public Task SendStatusFromServerAsync(Status status, Metadata trailers, Nullable`1<ResponseWithFlags<TRequest, TResponse>> optionalWrite);
    public CancellationToken get_CancellationToken();
    public string get_Peer();
    protected virtual bool get_IsClient();
    protected virtual Exception GetRpcExceptionClientOnly();
    protected virtual bool get_IsFinishedWithNonOkStatusClientOnly();
    protected virtual void OnAfterReleaseResourcesLocked();
    protected virtual Task CheckSendAllowedOrEarlyResult();
    private void HandleFinishedServerside(bool success, bool cancelled);
    private IReceivedCloseOnServerCallback get_ReceiveCloseOnServerCallback();
    private sealed virtual override void Grpc.Core.Internal.IReceivedCloseOnServerCallback.OnReceivedCloseOnServer(bool success, bool cancelled);
    private ISendStatusFromServerCompletionCallback get_SendStatusFromServerCompletionCallback();
    private sealed virtual override void Grpc.Core.Internal.ISendStatusFromServerCompletionCallback.OnSendStatusFromServerCompletion(bool success);
}
internal class Grpc.Core.Internal.AtomicCounter : object {
    private long counter;
    public long Count { get; }
    public AtomicCounter(long initialCount);
    public long Increment();
    public void IncrementIfNonzero(Boolean& success);
    public long Decrement();
    public long get_Count();
}
internal class Grpc.Core.Internal.AuthContextSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static AuthContextSafeHandle();
    public AuthContext ToAuthContext();
    protected virtual bool ReleaseHandle();
    private AuthProperty PtrToAuthProperty(IntPtr authPropertyPtr);
}
internal class Grpc.Core.Internal.BatchCompletionDelegate : MulticastDelegate {
    public BatchCompletionDelegate(object object, IntPtr method);
    public virtual void Invoke(bool success, BatchContextSafeHandle ctx, object state);
    public virtual IAsyncResult BeginInvoke(bool success, BatchContextSafeHandle ctx, object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Grpc.Core.Internal.BatchContextSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static ILogger Logger;
    private Action`1<BatchContextSafeHandle> returnToPoolAction;
    private CompletionCallbackData completionCallbackData;
    public IntPtr Handle { get; }
    private Nullable`1<int> Grpc.Core.Internal.IBufferReader.TotalLength { get; }
    private static BatchContextSafeHandle();
    public static BatchContextSafeHandle Create();
    public IntPtr get_Handle();
    public sealed virtual void SetReturnToPoolAction(Action`1<BatchContextSafeHandle> returnAction);
    public void SetCompletionCallback(BatchCompletionDelegate callback, object state);
    public Metadata GetReceivedInitialMetadata();
    public ClientSideStatus GetReceivedStatusOnClient();
    public IBufferReader GetReceivedMessageReader();
    public bool GetReceivedCloseOnServerCancelled();
    public void Recycle();
    protected virtual bool ReleaseHandle();
    private string StatusDetailsPtrToStringUTF8(IntPtr ptr, int len);
    private sealed virtual override void Grpc.Core.Internal.IOpCompletionCallback.OnComplete(bool success);
    private sealed virtual override Nullable`1<int> Grpc.Core.Internal.IBufferReader.get_TotalLength();
    private sealed virtual override bool Grpc.Core.Internal.IBufferReader.TryGetNextSlice(Slice& slice);
}
[ExtensionAttribute]
internal static class Grpc.Core.Internal.CallCredentialsExtensions : object {
    [ExtensionAttribute]
public static CallCredentialsSafeHandle ToNativeCredentials(CallCredentials credentials);
}
internal class Grpc.Core.Internal.CallCredentialsSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static CallCredentialsSafeHandle();
    public static CallCredentialsSafeHandle CreateComposite(CallCredentialsSafeHandle creds1, CallCredentialsSafeHandle creds2);
    protected virtual bool ReleaseHandle();
}
internal enum Grpc.Core.Internal.CallError : Enum {
    public int value__;
    public static CallError OK;
    public static CallError Error;
    public static CallError NotOnServer;
    public static CallError NotOnClient;
    public static CallError AlreadyAccepted;
    public static CallError AlreadyInvoked;
    public static CallError NotInvoked;
    public static CallError AlreadyFinished;
    public static CallError TooManyOperations;
    public static CallError InvalidFlags;
    public static CallError InvalidMetadata;
    public static CallError InvalidMessage;
    public static CallError NotServerCompletionQueue;
    public static CallError BatchTooBig;
    public static CallError PayloadTypeMismatch;
    public static CallError CompletionQueueShutdown;
}
[ExtensionAttribute]
internal static class Grpc.Core.Internal.CallErrorExtensions : object {
    [ExtensionAttribute]
public static void CheckOk(CallError callError);
}
[FlagsAttribute]
internal enum Grpc.Core.Internal.CallFlags : Enum {
    public int value__;
    public static CallFlags IdempotentRequest;
    public static CallFlags WaitForReady;
    public static CallFlags CacheableRequest;
}
[ExtensionAttribute]
internal static class Grpc.Core.Internal.CallOptionsExtensions : object {
    [ExtensionAttribute]
internal static CallOptions Normalize(CallOptions options);
}
internal class Grpc.Core.Internal.CallSafeHandle : SafeHandleZeroIsInvalid {
    public static CallSafeHandle NullInstance;
    private static NativeMethods Native;
    private static BatchCompletionDelegate CompletionHandler_IUnaryResponseClientCallback;
    private static BatchCompletionDelegate CompletionHandler_IReceivedStatusOnClientCallback;
    private static BatchCompletionDelegate CompletionHandler_IReceivedMessageCallback;
    private static BatchCompletionDelegate CompletionHandler_IReceivedResponseHeadersCallback;
    private static BatchCompletionDelegate CompletionHandler_ISendCompletionCallback;
    private static BatchCompletionDelegate CompletionHandler_ISendStatusFromServerCompletionCallback;
    private static BatchCompletionDelegate CompletionHandler_IReceivedCloseOnServerCallback;
    private static UInt32 GRPC_WRITE_BUFFER_HINT;
    private CompletionQueueSafeHandle completionQueue;
    private static CallSafeHandle();
    public void Initialize(CompletionQueueSafeHandle completionQueue);
    public void SetCredentials(CallCredentialsSafeHandle credentials);
    public sealed virtual void StartUnary(IUnaryResponseClientCallback callback, SliceBufferSafeHandle payload, WriteFlags writeFlags, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public sealed virtual void StartUnary(BatchContextSafeHandle ctx, SliceBufferSafeHandle payload, WriteFlags writeFlags, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public sealed virtual void StartClientStreaming(IUnaryResponseClientCallback callback, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public sealed virtual void StartServerStreaming(IReceivedStatusOnClientCallback callback, SliceBufferSafeHandle payload, WriteFlags writeFlags, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public sealed virtual void StartDuplexStreaming(IReceivedStatusOnClientCallback callback, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public sealed virtual void StartSendMessage(ISendCompletionCallback callback, SliceBufferSafeHandle payload, WriteFlags writeFlags, bool sendEmptyInitialMetadata);
    public sealed virtual void StartSendCloseFromClient(ISendCompletionCallback callback);
    public sealed virtual void StartSendStatusFromServer(ISendStatusFromServerCompletionCallback callback, Status status, MetadataArraySafeHandle metadataArray, bool sendEmptyInitialMetadata, SliceBufferSafeHandle optionalPayload, WriteFlags writeFlags);
    public sealed virtual void StartReceiveMessage(IReceivedMessageCallback callback);
    public sealed virtual void StartReceiveInitialMetadata(IReceivedResponseHeadersCallback callback);
    public sealed virtual void StartServerSide(IReceivedCloseOnServerCallback callback);
    public sealed virtual void StartSendInitialMetadata(ISendCompletionCallback callback, MetadataArraySafeHandle metadataArray);
    public sealed virtual void Cancel();
    public sealed virtual void CancelWithStatus(Status status);
    public sealed virtual string GetPeer();
    public AuthContextSafeHandle GetAuthContext();
    protected virtual bool ReleaseHandle();
    private static UInt32 GetFlags(bool buffered);
    public static CallSafeHandle CreateFake(IntPtr ptr, CompletionQueueSafeHandle cq);
}
internal class Grpc.Core.Internal.ChannelArgsSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static ChannelArgsSafeHandle();
    public static ChannelArgsSafeHandle CreateNull();
    public static ChannelArgsSafeHandle Create(int size);
    public void SetString(int index, string key, string value);
    public void SetInteger(int index, string key, int value);
    protected virtual bool ReleaseHandle();
}
[ExtensionAttribute]
internal static class Grpc.Core.Internal.ChannelCredentialsExtensions : object {
    [ExtensionAttribute]
public static ChannelCredentialsSafeHandle ToNativeCredentials(ChannelCredentials credentials);
}
internal class Grpc.Core.Internal.ChannelCredentialsSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static ChannelCredentialsSafeHandle();
    public static ChannelCredentialsSafeHandle CreateNullCredentials();
    public static ChannelCredentialsSafeHandle CreateSslCredentials(string pemRootCerts, KeyCertificatePair keyCertPair, IntPtr verifyPeerCallbackTag);
    public static ChannelCredentialsSafeHandle CreateComposite(ChannelCredentialsSafeHandle channelCreds, CallCredentialsSafeHandle callCreds);
    protected virtual bool ReleaseHandle();
}
internal class Grpc.Core.Internal.ChannelSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static ChannelSafeHandle();
    public static ChannelSafeHandle CreateInsecure(string target, ChannelArgsSafeHandle channelArgs);
    public static ChannelSafeHandle CreateSecure(ChannelCredentialsSafeHandle credentials, string target, ChannelArgsSafeHandle channelArgs);
    public CallSafeHandle CreateCall(CallSafeHandle parentCall, ContextPropagationFlags propagationMask, CompletionQueueSafeHandle cq, string method, string host, Timespec deadline, CallCredentialsSafeHandle credentials);
    public ChannelState CheckConnectivityState(bool tryToConnect);
    public void WatchConnectivityState(ChannelState lastObservedState, Timespec deadline, CompletionQueueSafeHandle cq, BatchCompletionDelegate callback, object callbackState);
    public string GetTarget();
    protected virtual bool ReleaseHandle();
}
internal class Grpc.Core.Internal.ClientRequestStream`2 : object {
    private AsyncCall`2<TRequest, TResponse> call;
    private WriteOptions writeOptions;
    public WriteOptions WriteOptions { get; public set; }
    public ClientRequestStream`2(AsyncCall`2<TRequest, TResponse> call);
    public sealed virtual Task WriteAsync(TRequest message);
    public sealed virtual Task CompleteAsync();
    public sealed virtual WriteOptions get_WriteOptions();
    public sealed virtual void set_WriteOptions(WriteOptions value);
    private WriteFlags GetWriteFlags();
}
internal class Grpc.Core.Internal.ClientResponseStream`2 : object {
    private AsyncCall`2<TRequest, TResponse> call;
    private TResponse current;
    public TResponse Current { get; }
    public ClientResponseStream`2(AsyncCall`2<TRequest, TResponse> call);
    public sealed virtual TResponse get_Current();
    [AsyncStateMachineAttribute("Grpc.Core.Internal.ClientResponseStream`2/<MoveNext>d__5")]
public sealed virtual Task`1<bool> MoveNext(CancellationToken token);
    public void Dispose();
}
internal class Grpc.Core.Internal.ClientSideStatus : ValueType {
    private Status status;
    private Metadata trailers;
    public Status Status { get; }
    public Metadata Trailers { get; }
    public ClientSideStatus(Status status, Metadata trailers);
    public Status get_Status();
    public Metadata get_Trailers();
}
internal class Grpc.Core.Internal.ClientStreamingServerCallHandler`2 : object {
    private static ILogger Logger;
    private Method`2<TRequest, TResponse> method;
    private ClientStreamingServerMethod`2<TRequest, TResponse> handler;
    public ClientStreamingServerCallHandler`2(Method`2<TRequest, TResponse> method, ClientStreamingServerMethod`2<TRequest, TResponse> handler);
    private static ClientStreamingServerCallHandler`2();
    [AsyncStateMachineAttribute("Grpc.Core.Internal.ClientStreamingServerCallHandler`2/<HandleCall>d__4")]
public sealed virtual Task HandleCall(ServerRpcNew newRpc, CompletionQueueSafeHandle cq);
}
internal enum Grpc.Core.Internal.ClockType : Enum {
    public int value__;
    public static ClockType Monotonic;
    public static ClockType Realtime;
    public static ClockType Precise;
    public static ClockType Timespan;
}
internal static class Grpc.Core.Internal.CommonPlatformDetection : object {
    public static OSKind GetOSKind();
    public static CpuArchitecture GetProcessArchitecture();
    private static int uname(IntPtr buf);
    private static string GetUname();
}
internal class Grpc.Core.Internal.CompletionQueueEvent : ValueType {
    private static NativeMethods Native;
    public CompletionType type;
    public int success;
    public IntPtr tag;
    internal static int NativeSize { get; }
    private static CompletionQueueEvent();
    internal static int get_NativeSize();
}
internal class Grpc.Core.Internal.CompletionQueueSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private AtomicCounter shutdownRefcount;
    private CompletionRegistry completionRegistry;
    public CompletionRegistry CompletionRegistry { get; }
    private static CompletionQueueSafeHandle();
    public static CompletionQueueSafeHandle CreateSync();
    public static CompletionQueueSafeHandle CreateAsync(CompletionRegistry completionRegistry);
    public CompletionQueueEvent Next();
    public CompletionQueueEvent Pluck(IntPtr tag);
    public UsageScope NewScope();
    public void Shutdown();
    public CompletionRegistry get_CompletionRegistry();
    protected virtual bool ReleaseHandle();
    private void DecrementShutdownRefcount();
    private void BeginOp();
    private void EndOp();
}
internal class Grpc.Core.Internal.CompletionRegistry : object {
    private static ILogger Logger;
    private GrpcEnvironment environment;
    private Func`1<BatchContextSafeHandle> batchContextFactory;
    private Func`1<RequestCallContextSafeHandle> requestCallContextFactory;
    private Dictionary`2<IntPtr, IOpCompletionCallback> dict;
    private SpinLock spinLock;
    private IntPtr lastRegisteredKey;
    public IntPtr LastRegisteredKey { get; }
    public CompletionRegistry(GrpcEnvironment environment, Func`1<BatchContextSafeHandle> batchContextFactory, Func`1<RequestCallContextSafeHandle> requestCallContextFactory);
    private static CompletionRegistry();
    public void Register(IntPtr key, IOpCompletionCallback callback);
    public BatchContextSafeHandle RegisterBatchCompletion(BatchCompletionDelegate callback, object state);
    public RequestCallContextSafeHandle RegisterRequestCallCompletion(RequestCallCompletionDelegate callback);
    public IOpCompletionCallback Extract(IntPtr key);
    public IntPtr get_LastRegisteredKey();
}
[FlagsAttribute]
internal enum Grpc.Core.Internal.ContextPropagationFlags : Enum {
    public int value__;
    public static ContextPropagationFlags Deadline;
    public static ContextPropagationFlags CensusStatsContext;
    public static ContextPropagationFlags CensusTracingContext;
    public static ContextPropagationFlags Cancellation;
}
[ExtensionAttribute]
internal static class Grpc.Core.Internal.ContextPropagationTokenExtensions : object {
    [ExtensionAttribute]
public static ContextPropagationTokenImpl AsImplOrNull(ContextPropagationToken instanceOrNull);
}
internal class Grpc.Core.Internal.ContextPropagationTokenImpl : ContextPropagationToken {
    private static ContextPropagationFlags DefaultCoreMask;
    internal static ContextPropagationFlags DefaultMask;
    private CallSafeHandle parentCall;
    private DateTime deadline;
    private CancellationToken cancellationToken;
    private ContextPropagationOptions options;
    internal CallSafeHandle ParentCall { get; }
    internal DateTime ParentDeadline { get; }
    internal CancellationToken ParentCancellationToken { get; }
    internal ContextPropagationOptions Options { get; }
    internal ContextPropagationTokenImpl(CallSafeHandle parentCall, DateTime deadline, CancellationToken cancellationToken, ContextPropagationOptions options);
    internal CallSafeHandle get_ParentCall();
    internal DateTime get_ParentDeadline();
    internal CancellationToken get_ParentCancellationToken();
    internal ContextPropagationOptions get_Options();
}
internal class Grpc.Core.Internal.CoreErrorDetailException : Exception {
    public CoreErrorDetailException(string message);
}
internal class Grpc.Core.Internal.CStringSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static CStringSafeHandle();
    public string GetValue();
    protected virtual bool ReleaseHandle();
}
internal class Grpc.Core.Internal.DebugStats : object {
    public AtomicCounter PendingBatchCompletions;
    public void CheckOK();
    private void DebugWarning(string message);
}
internal class Grpc.Core.Internal.DefaultCallCredentialsConfigurator : CallCredentialsConfiguratorBase {
    private CallCredentialsSafeHandle nativeCredentials;
    public CallCredentialsSafeHandle NativeCredentials { get; }
    public CallCredentialsSafeHandle get_NativeCredentials();
    public virtual void SetAsyncAuthInterceptorCredentials(object state, AsyncAuthInterceptor interceptor);
    public virtual void SetCompositeCredentials(object state, IReadOnlyList`1<CallCredentials> credentials);
    private CallCredentialsSafeHandle CompositeToNativeRecursive(IReadOnlyList`1<CallCredentials> credentials, int startIndex);
}
internal class Grpc.Core.Internal.DefaultChannelCredentialsConfigurator : ChannelCredentialsConfiguratorBase {
    private static ILogger Logger;
    private static ConditionalWeakTable`2<ChannelCredentials, Lazy`1<ChannelCredentialsSafeHandle>> CachedNativeCredentials;
    private static object StaticLock;
    private bool configured;
    private ChannelCredentialsSafeHandle nativeCredentials;
    public ChannelCredentialsSafeHandle NativeCredentials { get; }
    private static DefaultChannelCredentialsConfigurator();
    public ChannelCredentialsSafeHandle get_NativeCredentials();
    public virtual void SetInsecureCredentials(object state);
    public virtual void SetSslCredentials(object state, string rootCertificates, KeyCertificatePair keyCertificatePair, VerifyPeerCallback verifyPeerCallback);
    public virtual void SetCompositeCredentials(object state, ChannelCredentials channelCredentials, CallCredentials callCredentials);
    private ChannelCredentialsSafeHandle CreateNativeSslCredentials(string rootCertificates, KeyCertificatePair keyCertificatePair, VerifyPeerCallback verifyPeerCallback);
    private ChannelCredentialsSafeHandle CreateNativeCompositeCredentials(ChannelCredentials channelCredentials, CallCredentials callCredentials);
    private ChannelCredentialsSafeHandle GetOrCreateNativeCredentials(ChannelCredentials key, Func`1<ChannelCredentialsSafeHandle> nativeCredentialsFactory);
}
internal class Grpc.Core.Internal.DefaultDeserializationContext : DeserializationContext {
    private static ThreadLocal`1<DefaultDeserializationContext> threadLocalInstance;
    private IBufferReader bufferReader;
    private int payloadLength;
    private ReusableSliceBuffer cachedSliceBuffer;
    public int PayloadLength { get; }
    private static DefaultDeserializationContext();
    public virtual int get_PayloadLength();
    public virtual Byte[] PayloadAsNewBuffer();
    public virtual ReadOnlySequence`1<byte> PayloadAsReadOnlySequence();
    public void Initialize(IBufferReader bufferReader);
    public void Reset();
    public static DefaultDeserializationContext GetInitializedThreadLocal(IBufferReader bufferReader);
}
internal class Grpc.Core.Internal.DefaultObjectPool`1 : object {
    private object myLock;
    private Action`1<T> returnAction;
    private Func`1<T> itemFactory;
    private Queue`1<T> sharedQueue;
    private int sharedCapacity;
    private ThreadLocal`1<ThreadLocalData<T>> threadLocalData;
    private int threadLocalCapacity;
    private int rentLimit;
    private bool disposed;
    public DefaultObjectPool`1(Func`1<T> itemFactory, int sharedCapacity, int threadLocalCapacity);
    public sealed virtual T Lease();
    private T LeaseInternal();
    public sealed virtual void Return(T item);
    public sealed virtual void Dispose();
}
internal class Grpc.Core.Internal.DefaultSerializationContext : SerializationContext {
    private static ThreadLocal`1<DefaultSerializationContext> threadLocalInstance;
    private bool isComplete;
    private SliceBufferSafeHandle sliceBuffer;
    private static DefaultSerializationContext();
    public virtual void Complete(Byte[] payload);
    public virtual IBufferWriter`1<byte> GetBufferWriter();
    public virtual void SetPayloadLength(int payloadLength);
    public virtual void Complete();
    internal SliceBufferSafeHandle GetPayload();
    public void Reset();
    public static UsageScope GetInitializedThreadLocalScope();
}
internal static class Grpc.Core.Internal.DefaultSslRootsOverride : object {
    private static string RootsPemResourceName;
    private static object staticLock;
    private static DefaultSslRootsOverride();
    public static void Override(NativeMethods native);
}
internal class Grpc.Core.Internal.DuplexStreamingServerCallHandler`2 : object {
    private static ILogger Logger;
    private Method`2<TRequest, TResponse> method;
    private DuplexStreamingServerMethod`2<TRequest, TResponse> handler;
    public DuplexStreamingServerCallHandler`2(Method`2<TRequest, TResponse> method, DuplexStreamingServerMethod`2<TRequest, TResponse> handler);
    private static DuplexStreamingServerCallHandler`2();
    [AsyncStateMachineAttribute("Grpc.Core.Internal.DuplexStreamingServerCallHandler`2/<HandleCall>d__4")]
public sealed virtual Task HandleCall(ServerRpcNew newRpc, CompletionQueueSafeHandle cq);
}
internal class Grpc.Core.Internal.GprLogDelegate : MulticastDelegate {
    public GprLogDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr fileStringPtr, int line, ulong threadId, IntPtr severityStringPtr, IntPtr msgPtr);
    public virtual IAsyncResult BeginInvoke(IntPtr fileStringPtr, int line, ulong threadId, IntPtr severityStringPtr, IntPtr msgPtr, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Grpc.Core.Internal.GrpcThreadPool : object {
    private static ILogger Logger;
    private static int FinishContinuationsSleepMillis;
    private static int MaxFinishContinuationsSleepTotalMillis;
    private GrpcEnvironment environment;
    private object myLock;
    private List`1<Thread> threads;
    private int poolSize;
    private int completionQueueCount;
    private bool inlineHandlers;
    private WaitCallback runCompletionQueueEventCallbackSuccess;
    private WaitCallback runCompletionQueueEventCallbackFailure;
    private AtomicCounter queuedContinuationCounter;
    private List`1<BasicProfiler> threadProfilers;
    private bool stopRequested;
    private IReadOnlyCollection`1<CompletionQueueSafeHandle> completionQueues;
    internal bool IsAlive { get; }
    internal IReadOnlyCollection`1<CompletionQueueSafeHandle> CompletionQueues { get; }
    public GrpcThreadPool(GrpcEnvironment environment, int poolSize, int completionQueueCount, bool inlineHandlers);
    private static GrpcThreadPool();
    public void Start();
    public Task StopAsync();
    internal bool get_IsAlive();
    internal IReadOnlyCollection`1<CompletionQueueSafeHandle> get_CompletionQueues();
    private Thread CreateAndStartThread(int threadIndex, IProfiler optionalProfiler);
    private void RunHandlerLoop(CompletionQueueSafeHandle cq, IProfiler optionalProfiler);
    private static IReadOnlyCollection`1<CompletionQueueSafeHandle> CreateCompletionQueueList(GrpcEnvironment environment, int completionQueueCount);
    private void RunCompletionQueueEventCallback(IOpCompletionCallback callback, bool success);
    [CompilerGeneratedAttribute]
private void <.ctor>b__15_0(object callback);
    [CompilerGeneratedAttribute]
private void <.ctor>b__15_1(object callback);
    [CompilerGeneratedAttribute]
private void <StopAsync>b__17_0();
}
internal static class Grpc.Core.Internal.HandlerUtils : object {
    public static Status GetStatusFromExceptionAndMergeTrailers(Exception e, Metadata callContextResponseTrailers);
    public static WriteFlags GetWriteFlags(WriteOptions writeOptions);
    public static ServerCallContext NewContext(ServerRpcNew newRpc, IServerResponseStream serverResponseStream, CancellationToken cancellationToken);
}
internal interface Grpc.Core.Internal.IBufferReader {
    public Nullable`1<int> TotalLength { get; }
    public abstract virtual Nullable`1<int> get_TotalLength();
    public abstract virtual bool TryGetNextSlice(Slice& slice);
}
internal interface Grpc.Core.Internal.INativeCall {
    public abstract virtual void Cancel();
    public abstract virtual void CancelWithStatus(Status status);
    public abstract virtual string GetPeer();
    public abstract virtual void StartUnary(IUnaryResponseClientCallback callback, SliceBufferSafeHandle payload, WriteFlags writeFlags, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public abstract virtual void StartUnary(BatchContextSafeHandle ctx, SliceBufferSafeHandle payload, WriteFlags writeFlags, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public abstract virtual void StartClientStreaming(IUnaryResponseClientCallback callback, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public abstract virtual void StartServerStreaming(IReceivedStatusOnClientCallback callback, SliceBufferSafeHandle payload, WriteFlags writeFlags, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public abstract virtual void StartDuplexStreaming(IReceivedStatusOnClientCallback callback, MetadataArraySafeHandle metadataArray, CallFlags callFlags);
    public abstract virtual void StartReceiveMessage(IReceivedMessageCallback callback);
    public abstract virtual void StartReceiveInitialMetadata(IReceivedResponseHeadersCallback callback);
    public abstract virtual void StartSendInitialMetadata(ISendCompletionCallback callback, MetadataArraySafeHandle metadataArray);
    public abstract virtual void StartSendMessage(ISendCompletionCallback callback, SliceBufferSafeHandle payload, WriteFlags writeFlags, bool sendEmptyInitialMetadata);
    public abstract virtual void StartSendCloseFromClient(ISendCompletionCallback callback);
    public abstract virtual void StartSendStatusFromServer(ISendStatusFromServerCompletionCallback callback, Status status, MetadataArraySafeHandle metadataArray, bool sendEmptyInitialMetadata, SliceBufferSafeHandle optionalPayload, WriteFlags writeFlags);
    public abstract virtual void StartServerSide(IReceivedCloseOnServerCallback callback);
}
internal interface Grpc.Core.Internal.IObjectPool`1 {
    public abstract virtual T Lease();
    public abstract virtual void Return(T item);
}
internal interface Grpc.Core.Internal.IOpCompletionCallback {
    public abstract virtual void OnComplete(bool success);
}
internal interface Grpc.Core.Internal.IPooledObject`1 {
    public abstract virtual void SetReturnToPoolAction(Action`1<T> returnAction);
}
internal interface Grpc.Core.Internal.IReceivedCloseOnServerCallback {
    public abstract virtual void OnReceivedCloseOnServer(bool success, bool cancelled);
}
internal interface Grpc.Core.Internal.IReceivedMessageCallback {
    public abstract virtual void OnReceivedMessage(bool success, IBufferReader receivedMessageReader);
}
internal interface Grpc.Core.Internal.IReceivedResponseHeadersCallback {
    public abstract virtual void OnReceivedResponseHeaders(bool success, Metadata responseHeaders);
}
internal interface Grpc.Core.Internal.IReceivedStatusOnClientCallback {
    public abstract virtual void OnReceivedStatusOnClient(bool success, ClientSideStatus receivedStatus);
}
internal interface Grpc.Core.Internal.ISendCompletionCallback {
    public abstract virtual void OnSendCompletion(bool success);
}
internal interface Grpc.Core.Internal.ISendStatusFromServerCompletionCallback {
    public abstract virtual void OnSendStatusFromServerCompletion(bool success);
}
internal interface Grpc.Core.Internal.IServerCallHandler {
    public abstract virtual Task HandleCall(ServerRpcNew newRpc, CompletionQueueSafeHandle cq);
}
internal interface Grpc.Core.Internal.IServerResponseStream {
    public WriteOptions WriteOptions { get; public set; }
    public abstract virtual Task WriteResponseHeadersAsync(Metadata responseHeaders);
    public abstract virtual WriteOptions get_WriteOptions();
    public abstract virtual void set_WriteOptions(WriteOptions value);
}
internal interface Grpc.Core.Internal.IUnaryResponseClientCallback {
    public abstract virtual void OnUnaryResponseClient(bool success, ClientSideStatus receivedStatus, IBufferReader receivedMessageReader, Metadata responseHeaders);
}
internal static class Grpc.Core.Internal.MarshalUtils : object {
    private static Encoding EncodingUTF8;
    private static MarshalUtils();
    public static string PtrToStringUTF8(IntPtr ptr, int len);
    public static int GetBytesUTF8(string str, Byte* destination, int destinationLength);
    public static int GetMaxByteCountUTF8(string str);
    public static int GetByteCountUTF8(string str);
}
internal class Grpc.Core.Internal.MetadataArraySafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    internal IntPtr Handle { get; }
    private static MetadataArraySafeHandle();
    public static MetadataArraySafeHandle Create(Metadata metadata);
    public static Metadata ReadMetadataFromPtrUnsafe(IntPtr metadataArray);
    internal IntPtr get_Handle();
    protected virtual bool ReleaseHandle();
}
[AttributeUsageAttribute("64")]
internal class Grpc.Core.Internal.MonoPInvokeCallbackAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; private set; }
    public MonoPInvokeCallbackAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
}
internal class Grpc.Core.Internal.NativeCallbackDispatcher : object {
    private static ILogger Logger;
    private static NativeCallbackDispatcherCallback dispatcherCallback;
    private static NativeCallbackDispatcher();
    public static void Init(NativeMethods native);
    public static NativeCallbackRegistration RegisterCallback(UniversalNativeCallback callback);
    [MonoPInvokeCallbackAttribute("Grpc.Core.Internal.NativeCallbackDispatcherCallback")]
private static int HandleDispatcherCallback(IntPtr tag, IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4, IntPtr arg5);
}
internal class Grpc.Core.Internal.NativeCallbackDispatcherCallback : MulticastDelegate {
    public NativeCallbackDispatcherCallback(object object, IntPtr method);
    public virtual int Invoke(IntPtr tag, IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4, IntPtr arg5);
    public virtual IAsyncResult BeginInvoke(IntPtr tag, IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4, IntPtr arg5, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class Grpc.Core.Internal.NativeCallbackRegistration : object {
    private GCHandle handle;
    public IntPtr Tag { get; }
    public NativeCallbackRegistration(GCHandle handle);
    public IntPtr get_Tag();
    public sealed virtual void Dispose();
}
internal class Grpc.Core.Internal.NativeCallbackTestDelegate : MulticastDelegate {
    public NativeCallbackTestDelegate(object object, IntPtr method);
    public virtual void Invoke(bool success);
    public virtual IAsyncResult BeginInvoke(bool success, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Grpc.Core.Internal.NativeExtension : object {
    private static string CsharpExtOverrideLocationEnvVarName;
    private static ILogger Logger;
    private static object staticLock;
    private static NativeExtension modreq(System.Runtime.CompilerServices.IsVolatile) instance;
    private NativeMethods nativeMethods;
    public NativeMethods NativeMethods { get; }
    private static NativeExtension();
    public static NativeExtension Get();
    public NativeMethods get_NativeMethods();
    private static NativeMethods LoadNativeMethodsUsingExplicitLoad();
    private static NativeMethods LoadNativeMethodsUsingDllImports();
    private static NativeMethods LoadNativeMethods();
    private static NativeMethods LoadNativeMethodsUnity();
    private static NativeMethods LoadNativeMethodsXamarin();
    private static string GetAssemblyDirectory();
    private static bool IsNet5SingleFileApp();
    private static bool IsFileUri(string uri);
    private static string GetRuntimeIdString();
    private static string GetArchitectureString();
    private static string GetNativeLibraryFilename();
}
internal static class Grpc.Core.Internal.NativeLogRedirector : object {
    private static object staticLock;
    private static GprLogDelegate writeCallback;
    private static NativeLogRedirector();
    public static void Redirect(NativeMethods native);
    [MonoPInvokeCallbackAttribute("Grpc.Core.Internal.GprLogDelegate")]
private static void HandleWrite(IntPtr fileStringPtr, int line, ulong threadId, IntPtr severityStringPtr, IntPtr msgPtr);
}
internal class Grpc.Core.Internal.NativeMetadataCredentialsPlugin : object {
    private static string GetMetadataExceptionStatusMsg;
    private static string GetMetadataExceptionLogMsg;
    private static ILogger Logger;
    private static NativeMethods Native;
    private AsyncAuthInterceptor interceptor;
    private CallCredentialsSafeHandle credentials;
    private NativeCallbackRegistration callbackRegistration;
    public CallCredentialsSafeHandle Credentials { get; }
    public NativeMetadataCredentialsPlugin(AsyncAuthInterceptor interceptor);
    private static NativeMetadataCredentialsPlugin();
    public CallCredentialsSafeHandle get_Credentials();
    private int HandleUniversalCallback(IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4, IntPtr arg5);
    private void NativeMetadataInterceptorHandler(IntPtr serviceUrlPtr, IntPtr methodNamePtr, IntPtr callbackPtr, IntPtr userDataPtr, bool isDestroy);
    [AsyncStateMachineAttribute("Grpc.Core.Internal.NativeMetadataCredentialsPlugin/<GetMetadataAsync>d__12")]
private Task GetMetadataAsync(AuthInterceptorContext context, IntPtr callbackPtr, IntPtr userDataPtr);
}
internal class Grpc.Core.Internal.NativeMethods : object {
    public grpcsharp_init_delegate grpcsharp_init;
    public grpcsharp_shutdown_delegate grpcsharp_shutdown;
    public grpcsharp_version_string_delegate grpcsharp_version_string;
    public grpcsharp_batch_context_create_delegate grpcsharp_batch_context_create;
    public grpcsharp_batch_context_recv_initial_metadata_delegate grpcsharp_batch_context_recv_initial_metadata;
    public grpcsharp_batch_context_recv_message_length_delegate grpcsharp_batch_context_recv_message_length;
    public grpcsharp_batch_context_recv_message_next_slice_peek_delegate grpcsharp_batch_context_recv_message_next_slice_peek;
    public grpcsharp_batch_context_recv_status_on_client_status_delegate grpcsharp_batch_context_recv_status_on_client_status;
    public grpcsharp_batch_context_recv_status_on_client_details_delegate grpcsharp_batch_context_recv_status_on_client_details;
    public grpcsharp_batch_context_recv_status_on_client_error_string_delegate grpcsharp_batch_context_recv_status_on_client_error_string;
    public grpcsharp_batch_context_recv_status_on_client_trailing_metadata_delegate grpcsharp_batch_context_recv_status_on_client_trailing_metadata;
    public grpcsharp_batch_context_recv_close_on_server_cancelled_delegate grpcsharp_batch_context_recv_close_on_server_cancelled;
    public grpcsharp_batch_context_reset_delegate grpcsharp_batch_context_reset;
    public grpcsharp_batch_context_destroy_delegate grpcsharp_batch_context_destroy;
    public grpcsharp_request_call_context_create_delegate grpcsharp_request_call_context_create;
    public grpcsharp_request_call_context_call_delegate grpcsharp_request_call_context_call;
    public grpcsharp_request_call_context_method_delegate grpcsharp_request_call_context_method;
    public grpcsharp_request_call_context_host_delegate grpcsharp_request_call_context_host;
    public grpcsharp_request_call_context_deadline_delegate grpcsharp_request_call_context_deadline;
    public grpcsharp_request_call_context_request_metadata_delegate grpcsharp_request_call_context_request_metadata;
    public grpcsharp_request_call_context_reset_delegate grpcsharp_request_call_context_reset;
    public grpcsharp_request_call_context_destroy_delegate grpcsharp_request_call_context_destroy;
    public grpcsharp_composite_call_credentials_create_delegate grpcsharp_composite_call_credentials_create;
    public grpcsharp_call_credentials_release_delegate grpcsharp_call_credentials_release;
    public grpcsharp_call_cancel_delegate grpcsharp_call_cancel;
    public grpcsharp_call_cancel_with_status_delegate grpcsharp_call_cancel_with_status;
    public grpcsharp_call_start_unary_delegate grpcsharp_call_start_unary;
    public grpcsharp_call_start_client_streaming_delegate grpcsharp_call_start_client_streaming;
    public grpcsharp_call_start_server_streaming_delegate grpcsharp_call_start_server_streaming;
    public grpcsharp_call_start_duplex_streaming_delegate grpcsharp_call_start_duplex_streaming;
    public grpcsharp_call_send_message_delegate grpcsharp_call_send_message;
    public grpcsharp_call_send_close_from_client_delegate grpcsharp_call_send_close_from_client;
    public grpcsharp_call_send_status_from_server_delegate grpcsharp_call_send_status_from_server;
    public grpcsharp_call_recv_message_delegate grpcsharp_call_recv_message;
    public grpcsharp_call_recv_initial_metadata_delegate grpcsharp_call_recv_initial_metadata;
    public grpcsharp_call_start_serverside_delegate grpcsharp_call_start_serverside;
    public grpcsharp_call_send_initial_metadata_delegate grpcsharp_call_send_initial_metadata;
    public grpcsharp_call_set_credentials_delegate grpcsharp_call_set_credentials;
    public grpcsharp_call_get_peer_delegate grpcsharp_call_get_peer;
    public grpcsharp_call_destroy_delegate grpcsharp_call_destroy;
    public grpcsharp_channel_args_create_delegate grpcsharp_channel_args_create;
    public grpcsharp_channel_args_set_string_delegate grpcsharp_channel_args_set_string;
    public grpcsharp_channel_args_set_integer_delegate grpcsharp_channel_args_set_integer;
    public grpcsharp_channel_args_destroy_delegate grpcsharp_channel_args_destroy;
    public grpcsharp_override_default_ssl_roots_delegate grpcsharp_override_default_ssl_roots;
    public grpcsharp_ssl_credentials_create_delegate grpcsharp_ssl_credentials_create;
    public grpcsharp_composite_channel_credentials_create_delegate grpcsharp_composite_channel_credentials_create;
    public grpcsharp_channel_credentials_release_delegate grpcsharp_channel_credentials_release;
    public grpcsharp_insecure_channel_create_delegate grpcsharp_insecure_channel_create;
    public grpcsharp_secure_channel_create_delegate grpcsharp_secure_channel_create;
    public grpcsharp_channel_create_call_delegate grpcsharp_channel_create_call;
    public grpcsharp_channel_check_connectivity_state_delegate grpcsharp_channel_check_connectivity_state;
    public grpcsharp_channel_watch_connectivity_state_delegate grpcsharp_channel_watch_connectivity_state;
    public grpcsharp_channel_get_target_delegate grpcsharp_channel_get_target;
    public grpcsharp_channel_destroy_delegate grpcsharp_channel_destroy;
    public grpcsharp_sizeof_grpc_event_delegate grpcsharp_sizeof_grpc_event;
    public grpcsharp_completion_queue_create_async_delegate grpcsharp_completion_queue_create_async;
    public grpcsharp_completion_queue_create_sync_delegate grpcsharp_completion_queue_create_sync;
    public grpcsharp_completion_queue_shutdown_delegate grpcsharp_completion_queue_shutdown;
    public grpcsharp_completion_queue_next_delegate grpcsharp_completion_queue_next;
    public grpcsharp_completion_queue_pluck_delegate grpcsharp_completion_queue_pluck;
    public grpcsharp_completion_queue_destroy_delegate grpcsharp_completion_queue_destroy;
    public gprsharp_free_delegate gprsharp_free;
    public grpcsharp_metadata_array_create_delegate grpcsharp_metadata_array_create;
    public grpcsharp_metadata_array_add_delegate grpcsharp_metadata_array_add;
    public grpcsharp_metadata_array_count_delegate grpcsharp_metadata_array_count;
    public grpcsharp_metadata_array_get_key_delegate grpcsharp_metadata_array_get_key;
    public grpcsharp_metadata_array_get_value_delegate grpcsharp_metadata_array_get_value;
    public grpcsharp_metadata_array_destroy_full_delegate grpcsharp_metadata_array_destroy_full;
    public grpcsharp_redirect_log_delegate grpcsharp_redirect_log;
    public grpcsharp_native_callback_dispatcher_init_delegate grpcsharp_native_callback_dispatcher_init;
    public grpcsharp_metadata_credentials_create_from_plugin_delegate grpcsharp_metadata_credentials_create_from_plugin;
    public grpcsharp_metadata_credentials_notify_from_plugin_delegate grpcsharp_metadata_credentials_notify_from_plugin;
    public grpcsharp_ssl_server_credentials_create_delegate grpcsharp_ssl_server_credentials_create;
    public grpcsharp_server_credentials_release_delegate grpcsharp_server_credentials_release;
    public grpcsharp_server_create_delegate grpcsharp_server_create;
    public grpcsharp_server_register_completion_queue_delegate grpcsharp_server_register_completion_queue;
    public grpcsharp_server_add_insecure_http2_port_delegate grpcsharp_server_add_insecure_http2_port;
    public grpcsharp_server_add_secure_http2_port_delegate grpcsharp_server_add_secure_http2_port;
    public grpcsharp_server_start_delegate grpcsharp_server_start;
    public grpcsharp_server_request_call_delegate grpcsharp_server_request_call;
    public grpcsharp_server_cancel_all_calls_delegate grpcsharp_server_cancel_all_calls;
    public grpcsharp_server_shutdown_and_notify_callback_delegate grpcsharp_server_shutdown_and_notify_callback;
    public grpcsharp_server_destroy_delegate grpcsharp_server_destroy;
    public grpcsharp_call_auth_context_delegate grpcsharp_call_auth_context;
    public grpcsharp_auth_context_peer_identity_property_name_delegate grpcsharp_auth_context_peer_identity_property_name;
    public grpcsharp_auth_context_property_iterator_delegate grpcsharp_auth_context_property_iterator;
    public grpcsharp_auth_property_iterator_next_delegate grpcsharp_auth_property_iterator_next;
    public grpcsharp_auth_context_release_delegate grpcsharp_auth_context_release;
    public grpcsharp_slice_buffer_create_delegate grpcsharp_slice_buffer_create;
    public grpcsharp_slice_buffer_adjust_tail_space_delegate grpcsharp_slice_buffer_adjust_tail_space;
    public grpcsharp_slice_buffer_slice_count_delegate grpcsharp_slice_buffer_slice_count;
    public grpcsharp_slice_buffer_slice_peek_delegate grpcsharp_slice_buffer_slice_peek;
    public grpcsharp_slice_buffer_reset_and_unref_delegate grpcsharp_slice_buffer_reset_and_unref;
    public grpcsharp_slice_buffer_destroy_delegate grpcsharp_slice_buffer_destroy;
    public gprsharp_now_delegate gprsharp_now;
    public gprsharp_inf_future_delegate gprsharp_inf_future;
    public gprsharp_inf_past_delegate gprsharp_inf_past;
    public gprsharp_convert_clock_type_delegate gprsharp_convert_clock_type;
    public gprsharp_sizeof_timespec_delegate gprsharp_sizeof_timespec;
    public grpcsharp_test_callback_delegate grpcsharp_test_callback;
    public grpcsharp_test_nop_delegate grpcsharp_test_nop;
    public grpcsharp_test_override_method_delegate grpcsharp_test_override_method;
    public grpcsharp_test_call_start_unary_echo_delegate grpcsharp_test_call_start_unary_echo;
    public NativeMethods(UnmanagedLibrary library);
    public NativeMethods(DllImportsFromStaticLib unusedInstance);
    public NativeMethods(DllImportsFromSharedLib unusedInstance);
    public NativeMethods(DllImportsFromSharedLib_x86 unusedInstance);
    public NativeMethods(DllImportsFromSharedLib_x64 unusedInstance);
    public NativeMethods(DllImportsFromSharedLib_arm64 unusedInstance);
    public NativeMethods(DllImportsFromSharedLib_x86_dll unusedInstance);
    public NativeMethods(DllImportsFromSharedLib_x64_dll unusedInstance);
    public static NativeMethods Get();
    private static T GetMethodDelegate(UnmanagedLibrary library);
    private static string RemoveStringSuffix(string str, string toRemove);
}
internal static class Grpc.Core.Internal.PlatformApis : object {
    private static string UnityEngineAssemblyName;
    private static string UnityEngineApplicationClassName;
    private static string UnityIPhonePlayer;
    private static string XamarinAndroidObjectClassName;
    private static string XamarinIOSObjectClassName;
    private static bool isLinux;
    private static bool isMacOSX;
    private static bool isWindows;
    private static bool isMono;
    private static bool isNet5OrHigher;
    private static bool isNetCore;
    private static string frameworkDescription;
    private static string clrVersion;
    private static string unityApplicationPlatform;
    private static bool isXamarin;
    private static bool isXamarinIOS;
    private static bool isXamarinAndroid;
    public static bool IsLinux { get; }
    public static bool IsMacOSX { get; }
    public static bool IsWindows { get; }
    public static bool IsMono { get; }
    public static bool IsUnity { get; }
    public static bool IsUnityIOS { get; }
    public static bool IsXamarin { get; }
    public static bool IsXamarinIOS { get; }
    public static bool IsXamarinAndroid { get; }
    public static bool IsNet5OrHigher { get; }
    public static string FrameworkDescription { get; }
    public static string ClrVersion { get; }
    public static bool IsNetCore { get; }
    public static bool Is64Bit { get; }
    public static CpuArchitecture ProcessArchitecture { get; }
    private static PlatformApis();
    public static bool get_IsLinux();
    public static bool get_IsMacOSX();
    public static bool get_IsWindows();
    public static bool get_IsMono();
    public static bool get_IsUnity();
    public static bool get_IsUnityIOS();
    public static bool get_IsXamarin();
    public static bool get_IsXamarinIOS();
    public static bool get_IsXamarinAndroid();
    public static bool get_IsNet5OrHigher();
    public static string get_FrameworkDescription();
    public static string get_ClrVersion();
    public static bool get_IsNetCore();
    public static bool get_Is64Bit();
    public static CpuArchitecture get_ProcessArchitecture();
    public static string GetUnityApplicationPlatform();
    private static string TryGetUnityApplicationPlatform();
    private static string TryGetFrameworkDescription();
    private static string TryGetClrVersion();
    public static string GetGrpcCoreTargetFrameworkMoniker();
}
internal class Grpc.Core.Internal.RequestCallCompletionDelegate : MulticastDelegate {
    public RequestCallCompletionDelegate(object object, IntPtr method);
    public virtual void Invoke(bool success, RequestCallContextSafeHandle ctx);
    public virtual IAsyncResult BeginInvoke(bool success, RequestCallContextSafeHandle ctx, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Grpc.Core.Internal.RequestCallContextSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static ILogger Logger;
    private Action`1<RequestCallContextSafeHandle> returnToPoolAction;
    [CompilerGeneratedAttribute]
private RequestCallCompletionDelegate <CompletionCallback>k__BackingField;
    public IntPtr Handle { get; }
    public RequestCallCompletionDelegate CompletionCallback { get; public set; }
    private static RequestCallContextSafeHandle();
    public static RequestCallContextSafeHandle Create();
    public IntPtr get_Handle();
    public sealed virtual void SetReturnToPoolAction(Action`1<RequestCallContextSafeHandle> returnAction);
    [CompilerGeneratedAttribute]
public RequestCallCompletionDelegate get_CompletionCallback();
    [CompilerGeneratedAttribute]
public void set_CompletionCallback(RequestCallCompletionDelegate value);
    public ServerRpcNew GetServerRpcNew(Server server);
    public void Recycle();
    protected virtual bool ReleaseHandle();
    private sealed virtual override void Grpc.Core.Internal.IOpCompletionCallback.OnComplete(bool success);
}
internal class Grpc.Core.Internal.ReusableSliceBuffer : object {
    public static int MaxCachedSegments;
    private SliceSegment[] cachedSegments;
    private int populatedSegmentCount;
    public ReadOnlySequence`1<byte> PopulateFrom(IBufferReader bufferReader);
    public void Invalidate();
}
internal abstract class Grpc.Core.Internal.SafeHandleZeroIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
internal static class Grpc.Core.Internal.ServerCalls : object {
    public static IServerCallHandler UnaryCall(Method`2<TRequest, TResponse> method, UnaryServerMethod`2<TRequest, TResponse> handler);
    public static IServerCallHandler ClientStreamingCall(Method`2<TRequest, TResponse> method, ClientStreamingServerMethod`2<TRequest, TResponse> handler);
    public static IServerCallHandler ServerStreamingCall(Method`2<TRequest, TResponse> method, ServerStreamingServerMethod`2<TRequest, TResponse> handler);
    public static IServerCallHandler DuplexStreamingCall(Method`2<TRequest, TResponse> method, DuplexStreamingServerMethod`2<TRequest, TResponse> handler);
}
internal class Grpc.Core.Internal.ServerCredentialsSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static ServerCredentialsSafeHandle();
    public static ServerCredentialsSafeHandle CreateSslCredentials(string pemRootCerts, String[] keyCertPairCertChainArray, String[] keyCertPairPrivateKeyArray, SslClientCertificateRequestType clientCertificateRequest);
    protected virtual bool ReleaseHandle();
}
internal class Grpc.Core.Internal.ServerRequestStream`2 : object {
    private AsyncCallServer`2<TRequest, TResponse> call;
    private TRequest current;
    public TRequest Current { get; }
    public ServerRequestStream`2(AsyncCallServer`2<TRequest, TResponse> call);
    public sealed virtual TRequest get_Current();
    [AsyncStateMachineAttribute("Grpc.Core.Internal.ServerRequestStream`2/<MoveNext>d__5")]
public sealed virtual Task`1<bool> MoveNext(CancellationToken token);
    public void Dispose();
}
internal class Grpc.Core.Internal.ServerResponseStream`2 : object {
    private AsyncCallServer`2<TRequest, TResponse> call;
    private WriteOptions writeOptions;
    public WriteOptions WriteOptions { get; public set; }
    public ServerResponseStream`2(AsyncCallServer`2<TRequest, TResponse> call);
    public sealed virtual Task WriteAsync(TResponse message);
    public sealed virtual Task WriteResponseHeadersAsync(Metadata responseHeaders);
    public sealed virtual WriteOptions get_WriteOptions();
    public sealed virtual void set_WriteOptions(WriteOptions value);
    private WriteFlags GetWriteFlags();
}
internal class Grpc.Core.Internal.ServerRpcNew : ValueType {
    private Server server;
    private CallSafeHandle call;
    private string method;
    private string host;
    private Timespec deadline;
    private Metadata requestMetadata;
    public Server Server { get; }
    public CallSafeHandle Call { get; }
    public string Method { get; }
    public string Host { get; }
    public Timespec Deadline { get; }
    public Metadata RequestMetadata { get; }
    public ServerRpcNew(Server server, CallSafeHandle call, string method, string host, Timespec deadline, Metadata requestMetadata);
    public Server get_Server();
    public CallSafeHandle get_Call();
    public string get_Method();
    public string get_Host();
    public Timespec get_Deadline();
    public Metadata get_RequestMetadata();
}
internal class Grpc.Core.Internal.ServerSafeHandle : SafeHandleZeroIsInvalid {
    private static NativeMethods Native;
    private static ServerSafeHandle();
    public static ServerSafeHandle NewServer(ChannelArgsSafeHandle args);
    public void RegisterCompletionQueue(CompletionQueueSafeHandle cq);
    public int AddInsecurePort(string addr);
    public int AddSecurePort(string addr, ServerCredentialsSafeHandle credentials);
    public void Start();
    public void ShutdownAndNotify(BatchCompletionDelegate callback, CompletionQueueSafeHandle completionQueue);
    public void RequestCall(RequestCallCompletionDelegate callback, CompletionQueueSafeHandle completionQueue);
    protected virtual bool ReleaseHandle();
    public void CancelAllCalls();
}
[ExtensionAttribute]
internal static class Grpc.Core.Internal.ServerServiceDefinitionExtensions : object {
    [ExtensionAttribute]
internal static ReadOnlyDictionary`2<string, IServerCallHandler> GetCallHandlers(ServerServiceDefinition serviceDefinition);
}
internal class Grpc.Core.Internal.ServerStreamingServerCallHandler`2 : object {
    private static ILogger Logger;
    private Method`2<TRequest, TResponse> method;
    private ServerStreamingServerMethod`2<TRequest, TResponse> handler;
    public ServerStreamingServerCallHandler`2(Method`2<TRequest, TResponse> method, ServerStreamingServerMethod`2<TRequest, TResponse> handler);
    private static ServerStreamingServerCallHandler`2();
    [AsyncStateMachineAttribute("Grpc.Core.Internal.ServerStreamingServerCallHandler`2/<HandleCall>d__4")]
public sealed virtual Task HandleCall(ServerRpcNew newRpc, CompletionQueueSafeHandle cq);
}
internal class Grpc.Core.Internal.Slice : ValueType {
    private IntPtr dataPtr;
    private int length;
    public int Length { get; }
    public Slice(IntPtr dataPtr, int length);
    public int get_Length();
    public Span`1<byte> ToSpanUnsafe();
    public virtual string ToString();
}
internal class Grpc.Core.Internal.SliceBufferSafeHandle : SafeHandleZeroIsInvalid {
    private static int DefaultTailSpaceSize;
    private static NativeMethods Native;
    private static ILogger Logger;
    public static SliceBufferSafeHandle NullInstance;
    private IntPtr tailSpacePtr;
    private int tailSpaceLen;
    private SliceMemoryManager memoryManagerLazy;
    public IntPtr Handle { get; }
    private static SliceBufferSafeHandle();
    public static SliceBufferSafeHandle Create();
    public IntPtr get_Handle();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public void Complete();
    public void Reset();
    public Byte[] ToByteArray();
    private void EnsureBufferSpace(int sizeHint);
    private void AdjustTailSpace(int requestedSize);
    protected virtual bool ReleaseHandle();
}
internal class Grpc.Core.Internal.SliceMemoryManager : MemoryManager`1<byte> {
    private Slice slice;
    public void Reset(Slice slice);
    public void Reset();
    public virtual Span`1<byte> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    protected virtual void Dispose(bool disposing);
}
internal class Grpc.Core.Internal.Timespec : ValueType {
    private static long NanosPerSecond;
    private static long NanosPerTick;
    private static long TicksPerSecond;
    private static NativeMethods Native;
    private static DateTime UnixEpoch;
    private long tv_sec;
    private int tv_nsec;
    private ClockType clock_type;
    public static Timespec InfFuture { get; }
    public static Timespec InfPast { get; }
    public static Timespec Now { get; }
    public long TimevalSeconds { get; }
    public int TimevalNanos { get; }
    internal static Timespec PreciseNow { get; }
    internal static int NativeSize { get; }
    internal static Timespec NativeInfFuture { get; }
    public static Timespec NativeInfPast { get; }
    public Timespec(long tv_sec, int tv_nsec);
    public Timespec(long tv_sec, int tv_nsec, ClockType clock_type);
    private static Timespec();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(Timespec other);
    public static Timespec get_InfFuture();
    public static Timespec get_InfPast();
    public static Timespec get_Now();
    public long get_TimevalSeconds();
    public int get_TimevalNanos();
    public Timespec ToClockType(ClockType targetClock);
    public DateTime ToDateTime();
    public static Timespec FromDateTime(DateTime dateTime);
    internal static Timespec get_PreciseNow();
    internal static int get_NativeSize();
    internal static Timespec get_NativeInfFuture();
    public static Timespec get_NativeInfPast();
}
internal class Grpc.Core.Internal.UnaryServerCallHandler`2 : object {
    private static ILogger Logger;
    private Method`2<TRequest, TResponse> method;
    private UnaryServerMethod`2<TRequest, TResponse> handler;
    public UnaryServerCallHandler`2(Method`2<TRequest, TResponse> method, UnaryServerMethod`2<TRequest, TResponse> handler);
    private static UnaryServerCallHandler`2();
    [AsyncStateMachineAttribute("Grpc.Core.Internal.UnaryServerCallHandler`2/<HandleCall>d__4")]
public sealed virtual Task HandleCall(ServerRpcNew newRpc, CompletionQueueSafeHandle cq);
}
internal class Grpc.Core.Internal.UnimplementedCallInvoker : CallInvoker {
    public virtual TResponse BlockingUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncUnaryCall`1<TResponse> AsyncUnaryCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncServerStreamingCall`1<TResponse> AsyncServerStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options, TRequest request);
    public virtual AsyncClientStreamingCall`2<TRequest, TResponse> AsyncClientStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
    public virtual AsyncDuplexStreamingCall`2<TRequest, TResponse> AsyncDuplexStreamingCall(Method`2<TRequest, TResponse> method, string host, CallOptions options);
}
internal class Grpc.Core.Internal.UnimplementedMethodCallHandler : object {
    public static UnimplementedMethodCallHandler Instance;
    private DuplexStreamingServerCallHandler`2<Byte[], Byte[]> callHandlerImpl;
    private static UnimplementedMethodCallHandler();
    private Task UnimplementedMethod(IAsyncStreamReader`1<Byte[]> requestStream, IServerStreamWriter`1<Byte[]> responseStream, ServerCallContext ctx);
    public sealed virtual Task HandleCall(ServerRpcNew newRpc, CompletionQueueSafeHandle cq);
}
internal class Grpc.Core.Internal.UniversalNativeCallback : MulticastDelegate {
    public UniversalNativeCallback(object object, IntPtr method);
    public virtual int Invoke(IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4, IntPtr arg5);
    public virtual IAsyncResult BeginInvoke(IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4, IntPtr arg5, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class Grpc.Core.Internal.UnmanagedLibrary : object {
    private static ILogger Logger;
    private static int RTLD_LAZY;
    private static int RTLD_GLOBAL;
    private string libraryPath;
    private IntPtr handle;
    public UnmanagedLibrary(String[] libraryPathAlternatives);
    private static UnmanagedLibrary();
    private IntPtr LoadSymbol(string symbolName);
    public T GetNativeMethodDelegate(string methodName);
    private static IntPtr PlatformSpecificLoadLibrary(string libraryPath, String& errorMsg);
    private static IntPtr LoadLibraryPosix(Func`3<string, int, IntPtr> dlopenFunc, Func`1<IntPtr> dlerrorFunc, string libraryPath, String& errorMsg);
    private static string FirstValidLibraryPath(String[] libraryPathAlternatives);
}
internal class Grpc.Core.Internal.UserAgentStringProvider : object {
    private static UserAgentStringProvider defaultInstance;
    private string userAgentString;
    public static UserAgentStringProvider DefaultInstance { get; }
    public string GrpcCsharpUserAgentString { get; }
    private static UserAgentStringProvider();
    public UserAgentStringProvider(string grpcCsharpVersion, string frameworkDescription, string clrVersion, string tfm, CpuArchitecture arch);
    public static UserAgentStringProvider get_DefaultInstance();
    public string get_GrpcCsharpUserAgentString();
    private static string TryGetArchitectureString(CpuArchitecture arch);
    private static string SanitizeFrameworkDescription(string frameworkDescription);
}
internal static class Grpc.Core.Internal.WellKnownStrings : object {
    private static ulong Coerce64(Byte* value);
    private static UInt32 Coerce32(Byte* value);
    private static ushort Coerce16(Byte* value);
    public static string TryIdentify(IntPtr source, int length);
    public static string TryIdentify(Byte* source, int length);
}
[NullableContextAttribute("2")]
internal interface Grpc.Core.IServerStreamWriter`1 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.KeyCertificatePair : object {
    private string certificateChain;
    private string privateKey;
    public string CertificateChain { get; }
    public string PrivateKey { get; }
    public KeyCertificatePair(string certificateChain, string privateKey);
    public string get_CertificateChain();
    public string get_PrivateKey();
}
internal class Grpc.Core.Logging.ConsoleLogger : TextWriterLogger {
    private ConsoleLogger(Type forType);
    public virtual ILogger ForType();
}
internal interface Grpc.Core.Logging.ILogger {
    public abstract virtual ILogger ForType();
    public abstract virtual void Debug(string message);
    public abstract virtual void Debug(string format, Object[] formatArgs);
    public abstract virtual void Info(string message);
    public abstract virtual void Info(string format, Object[] formatArgs);
    public abstract virtual void Warning(string message);
    public abstract virtual void Warning(string format, Object[] formatArgs);
    public abstract virtual void Warning(Exception exception, string message);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(string format, Object[] formatArgs);
    public abstract virtual void Error(Exception exception, string message);
}
internal enum Grpc.Core.Logging.LogLevel : Enum {
    public int value__;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Off;
}
internal class Grpc.Core.Logging.LogLevelFilterLogger : object {
    private static string CoreVerbosityEnvVarName;
    private ILogger innerLogger;
    private LogLevel logLevel;
    public LogLevelFilterLogger(ILogger logger, LogLevel logLevel);
    public LogLevelFilterLogger(ILogger logger, LogLevel defaultLogLevel, bool fromEnvironmentVariable);
    public virtual ILogger ForType();
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(string format, Object[] formatArgs);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(string format, Object[] formatArgs);
    public sealed virtual void Warning(string message);
    public sealed virtual void Warning(string format, Object[] formatArgs);
    public sealed virtual void Warning(Exception exception, string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(string format, Object[] formatArgs);
    public sealed virtual void Error(Exception exception, string message);
    private static LogLevel GetLogLevelFromEnvironment(LogLevel defaultLogLevel, bool fromEnvironmentVariable);
}
internal class Grpc.Core.Logging.NullLogger : object {
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(string format, Object[] formatArgs);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(Exception exception, string message);
    public sealed virtual void Error(string format, Object[] formatArgs);
    public sealed virtual ILogger ForType();
    public sealed virtual void Info(string message);
    public sealed virtual void Info(string format, Object[] formatArgs);
    public sealed virtual void Warning(string message);
    public sealed virtual void Warning(Exception exception, string message);
    public sealed virtual void Warning(string format, Object[] formatArgs);
}
internal class Grpc.Core.Logging.TextWriterLogger : object {
    private static string DateTimeFormatString;
    private Func`1<TextWriter> textWriterProvider;
    private Type forType;
    private string forTypeString;
    protected Type AssociatedType { get; }
    public TextWriterLogger(TextWriter textWriter);
    public TextWriterLogger(Func`1<TextWriter> textWriterProvider);
    protected TextWriterLogger(Func`1<TextWriter> textWriterProvider, Type forType);
    public virtual ILogger ForType();
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(string format, Object[] formatArgs);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(string format, Object[] formatArgs);
    public sealed virtual void Warning(string message);
    public sealed virtual void Warning(string format, Object[] formatArgs);
    public sealed virtual void Warning(Exception exception, string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(string format, Object[] formatArgs);
    public sealed virtual void Error(Exception exception, string message);
    protected Type get_AssociatedType();
    private void Log(string severityString, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.Marshaller`1 : object {
    private Func`2<T, Byte[]> serializer;
    private Func`2<Byte[], T> deserializer;
    private Action`2<T, SerializationContext> contextualSerializer;
    private Func`2<DeserializationContext, T> contextualDeserializer;
    public Func`2<T, Byte[]> Serializer { get; }
    public Func`2<Byte[], T> Deserializer { get; }
    public Action`2<T, SerializationContext> ContextualSerializer { get; }
    public Func`2<DeserializationContext, T> ContextualDeserializer { get; }
    public Marshaller`1(Func`2<T, Byte[]> serializer, Func`2<Byte[], T> deserializer);
    public Marshaller`1(Action`2<T, SerializationContext> serializer, Func`2<DeserializationContext, T> deserializer);
    public Func`2<T, Byte[]> get_Serializer();
    public Func`2<Byte[], T> get_Deserializer();
    public Action`2<T, SerializationContext> get_ContextualSerializer();
    public Func`2<DeserializationContext, T> get_ContextualDeserializer();
    private void EmulateContextualSerializer(T message, SerializationContext context);
    private T EmulateContextualDeserializer(DeserializationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Grpc.Core.Marshallers : object {
    public static Marshaller`1<string> StringMarshaller { get; }
    public static Marshaller`1<T> Create(Func`2<T, Byte[]> serializer, Func`2<Byte[], T> deserializer);
    public static Marshaller`1<T> Create(Action`2<T, SerializationContext> serializer, Func`2<DeserializationContext, T> deserializer);
    public static Marshaller`1<string> get_StringMarshaller();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Grpc.Core.Metadata : object {
    public static string BinaryHeaderSuffix;
    public static Metadata Empty;
    internal static string CompressionRequestAlgorithmMetadataKey;
    private static Encoding EncodingASCII;
    private List`1<Entry> entries;
    private bool readOnly;
    public Entry Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private static Metadata();
    internal Metadata Freeze();
    public Entry Get(string key);
    public string GetValue(string key);
    public Byte[] GetValueBytes(string key);
    [IteratorStateMachineAttribute("Grpc.Core.Metadata/<GetAll>d__11")]
public IEnumerable`1<Entry> GetAll(string key);
    public void Add(string key, string value);
    public void Add(string key, Byte[] valueBytes);
    public sealed virtual int IndexOf(Entry item);
    public sealed virtual void Insert(int index, Entry item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual Entry get_Item(int index);
    public sealed virtual void set_Item(int index, Entry value);
    public sealed virtual void Add(Entry item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Entry item);
    public sealed virtual void CopyTo(Entry[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(Entry item);
    public sealed virtual IEnumerator`1<Entry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void CheckWriteable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.Method`2 : object {
    private MethodType type;
    private string serviceName;
    private string name;
    private Marshaller`1<TRequest> requestMarshaller;
    private Marshaller`1<TResponse> responseMarshaller;
    private string fullName;
    public MethodType Type { get; }
    public string ServiceName { get; }
    public string Name { get; }
    public Marshaller`1<TRequest> RequestMarshaller { get; }
    public Marshaller`1<TResponse> ResponseMarshaller { get; }
    public string FullName { get; }
    public Method`2(MethodType type, string serviceName, string name, Marshaller`1<TRequest> requestMarshaller, Marshaller`1<TResponse> responseMarshaller);
    public sealed virtual MethodType get_Type();
    public sealed virtual string get_ServiceName();
    public sealed virtual string get_Name();
    public Marshaller`1<TRequest> get_RequestMarshaller();
    public Marshaller`1<TResponse> get_ResponseMarshaller();
    public sealed virtual string get_FullName();
    internal static string GetFullName(string serviceName, string methodName);
}
internal enum Grpc.Core.MethodType : Enum {
    public int value__;
    public static MethodType Unary;
    public static MethodType ClientStreaming;
    public static MethodType ServerStreaming;
    public static MethodType DuplexStreaming;
}
internal class Grpc.Core.Profiling.BasicProfiler : object {
    private ProfilerEntry[] entries;
    private int count;
    public BasicProfiler(int capacity);
    public sealed virtual void Begin(string tag);
    public sealed virtual void End(string tag);
    public sealed virtual void Mark(string tag);
    public void Reset();
    public void Dump(string filepath);
    public void Dump(TextWriter stream);
    private void AddEntry(ProfilerEntry entry);
}
internal interface Grpc.Core.Profiling.IProfiler {
    public abstract virtual void Begin(string tag);
    public abstract virtual void End(string tag);
    public abstract virtual void Mark(string tag);
}
internal class Grpc.Core.Profiling.NopProfiler : object {
    public sealed virtual void Begin(string tag);
    public sealed virtual void End(string tag);
    public sealed virtual void Mark(string tag);
}
internal class Grpc.Core.Profiling.ProfilerEntry : ValueType {
    public Timespec timespec;
    public Type type;
    public string tag;
    public ProfilerEntry(Timespec timespec, Type type, string tag);
    public virtual string ToString();
    internal static string GetTypeAbbreviation(Type type);
}
[ExtensionAttribute]
internal static class Grpc.Core.Profiling.Profilers : object {
    private static NopProfiler DefaultProfiler;
    private static ThreadLocal`1<IProfiler> profilers;
    private static Profilers();
    public static IProfiler ForCurrentThread();
    public static void SetForCurrentThread(IProfiler profiler);
    [ExtensionAttribute]
public static ProfilerScope NewScope(IProfiler profiler, string tag);
}
internal class Grpc.Core.Profiling.ProfilerScope : ValueType {
    private IProfiler profiler;
    private string tag;
    public ProfilerScope(IProfiler profiler, string tag);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Grpc.Core.RpcException : Exception {
    private Status status;
    private Metadata trailers;
    public Status Status { get; }
    public StatusCode StatusCode { get; }
    public Metadata Trailers { get; }
    public RpcException(Status status);
    public RpcException(Status status, string message);
    public RpcException(Status status, Metadata trailers);
    public RpcException(Status status, Metadata trailers, string message);
    public Status get_Status();
    public StatusCode get_StatusCode();
    public Metadata get_Trailers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.SerializationContext : object {
    public virtual void Complete(Byte[] payload);
    public virtual IBufferWriter`1<byte> GetBufferWriter();
    public virtual void SetPayloadLength(int payloadLength);
    public virtual void Complete();
}
internal class Grpc.Core.Server : object {
    private static int DefaultRequestCallTokensPerCq;
    private static ILogger Logger;
    private AtomicCounter activeCallCounter;
    private ServiceDefinitionCollection serviceDefinitions;
    private ServerPortCollection ports;
    private GrpcEnvironment environment;
    private List`1<ChannelOption> options;
    private ServerSafeHandle handle;
    private object myLock;
    private List`1<ServerServiceDefinition> serviceDefinitionsList;
    private List`1<ServerPort> serverPortList;
    private Dictionary`2<string, IServerCallHandler> callHandlers;
    private TaskCompletionSource`1<object> shutdownTcs;
    private bool startRequested;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) shutdownRequested;
    private int requestCallTokensPerCq;
    public ServiceDefinitionCollection Services { get; }
    public ServerPortCollection Ports { get; }
    public Task ShutdownTask { get; }
    public int RequestCallTokensPerCompletionQueue { get; public set; }
    public Server(IEnumerable`1<ChannelOption> options);
    private static Server();
    public ServiceDefinitionCollection get_Services();
    public ServerPortCollection get_Ports();
    public Task get_ShutdownTask();
    public int get_RequestCallTokensPerCompletionQueue();
    public void set_RequestCallTokensPerCompletionQueue(int value);
    public void Start();
    public Task ShutdownAsync();
    public Task KillAsync();
    internal void AddCallReference(object call);
    internal void RemoveCallReference(object call);
    [AsyncStateMachineAttribute("Grpc.Core.Server/<ShutdownInternalAsync>d__32")]
private Task ShutdownInternalAsync(bool kill);
    [AsyncStateMachineAttribute("Grpc.Core.Server/<ShutdownCompleteOrEnvironmentDeadAsync>d__33")]
private Task ShutdownCompleteOrEnvironmentDeadAsync();
    private void AddServiceDefinitionInternal(ServerServiceDefinition serviceDefinition);
    private int AddPortInternal(ServerPort serverPort);
    private void AllowOneRpc(CompletionQueueSafeHandle cq);
    private void CheckPortsBoundSuccessfully();
    private void DisposeHandle();
    [AsyncStateMachineAttribute("Grpc.Core.Server/<HandleCallAsync>d__39")]
private Task HandleCallAsync(ServerRpcNew newRpc, CompletionQueueSafeHandle cq, Action`2<Server, CompletionQueueSafeHandle> continuation);
    private void HandleNewServerRpc(bool success, RequestCallContextSafeHandle ctx, CompletionQueueSafeHandle cq);
    private void HandleServerShutdown(bool success, BatchContextSafeHandle ctx, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Grpc.Core.ServerCallContext : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<object, object> userState;
    public string Method { get; }
    public string Host { get; }
    public string Peer { get; }
    public DateTime Deadline { get; }
    public Metadata RequestHeaders { get; }
    public CancellationToken CancellationToken { get; }
    public Metadata ResponseTrailers { get; }
    public Status Status { get; public set; }
    [NullableAttribute("2")]
public WriteOptions WriteOptions { get; public set; }
    public AuthContext AuthContext { get; }
    public IDictionary`2<object, object> UserState { get; }
    protected string MethodCore { get; }
    protected string HostCore { get; }
    protected string PeerCore { get; }
    protected DateTime DeadlineCore { get; }
    protected Metadata RequestHeadersCore { get; }
    protected CancellationToken CancellationTokenCore { get; }
    protected Metadata ResponseTrailersCore { get; }
    protected Status StatusCore { get; protected set; }
    [NullableAttribute("2")]
protected WriteOptions WriteOptionsCore { get; protected set; }
    protected AuthContext AuthContextCore { get; }
    protected IDictionary`2<object, object> UserStateCore { get; }
    public Task WriteResponseHeadersAsync(Metadata responseHeaders);
    public ContextPropagationToken CreatePropagationToken(ContextPropagationOptions options);
    public string get_Method();
    public string get_Host();
    public string get_Peer();
    public DateTime get_Deadline();
    public Metadata get_RequestHeaders();
    public CancellationToken get_CancellationToken();
    public Metadata get_ResponseTrailers();
    public Status get_Status();
    public void set_Status(Status value);
    [NullableContextAttribute("2")]
public WriteOptions get_WriteOptions();
    [NullableContextAttribute("2")]
public void set_WriteOptions(WriteOptions value);
    public AuthContext get_AuthContext();
    public IDictionary`2<object, object> get_UserState();
    protected abstract virtual Task WriteResponseHeadersAsyncCore(Metadata responseHeaders);
    protected abstract virtual ContextPropagationToken CreatePropagationTokenCore(ContextPropagationOptions options);
    protected abstract virtual string get_MethodCore();
    protected abstract virtual string get_HostCore();
    protected abstract virtual string get_PeerCore();
    protected abstract virtual DateTime get_DeadlineCore();
    protected abstract virtual Metadata get_RequestHeadersCore();
    protected abstract virtual CancellationToken get_CancellationTokenCore();
    protected abstract virtual Metadata get_ResponseTrailersCore();
    protected abstract virtual Status get_StatusCore();
    protected abstract virtual void set_StatusCore(Status value);
    [NullableContextAttribute("2")]
protected abstract virtual WriteOptions get_WriteOptionsCore();
    [NullableContextAttribute("2")]
protected abstract virtual void set_WriteOptionsCore(WriteOptions value);
    protected abstract virtual AuthContext get_AuthContextCore();
    protected virtual IDictionary`2<object, object> get_UserStateCore();
}
internal abstract class Grpc.Core.ServerCredentials : object {
    private static ServerCredentials InsecureInstance;
    public static ServerCredentials Insecure { get; }
    private static ServerCredentials();
    public static ServerCredentials get_Insecure();
    internal abstract virtual ServerCredentialsSafeHandle ToNativeCredentials();
}
internal class Grpc.Core.ServerPort : object {
    public static int PickUnused;
    private string host;
    private int port;
    private ServerCredentials credentials;
    private int boundPort;
    public string Host { get; }
    public int Port { get; }
    public ServerCredentials Credentials { get; }
    public int BoundPort { get; }
    public ServerPort(string host, int port, ServerCredentials credentials);
    internal ServerPort(ServerPort serverPort, int boundPort);
    public string get_Host();
    public int get_Port();
    public ServerCredentials get_Credentials();
    public int get_BoundPort();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.ServerServiceDefinition : object {
    private IReadOnlyList`1<Action`1<ServiceBinderBase>> addMethodActions;
    internal ServerServiceDefinition(List`1<Action`1<ServiceBinderBase>> addMethodActions);
    internal void BindService(ServiceBinderBase serviceBinder);
    public static Builder CreateBuilder();
}
internal class Grpc.Core.ServerStreamingServerMethod`2 : MulticastDelegate {
    public ServerStreamingServerMethod`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(TRequest request, IServerStreamWriter`1<TResponse> responseStream, ServerCallContext context);
    public virtual IAsyncResult BeginInvoke(TRequest request, IServerStreamWriter`1<TResponse> responseStream, ServerCallContext context, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.ServiceBinderBase : object {
    public virtual void AddMethod(Method`2<TRequest, TResponse> method, UnaryServerMethod`2<TRequest, TResponse> handler);
    public virtual void AddMethod(Method`2<TRequest, TResponse> method, ClientStreamingServerMethod`2<TRequest, TResponse> handler);
    public virtual void AddMethod(Method`2<TRequest, TResponse> method, ServerStreamingServerMethod`2<TRequest, TResponse> handler);
    public virtual void AddMethod(Method`2<TRequest, TResponse> method, DuplexStreamingServerMethod`2<TRequest, TResponse> handler);
}
internal enum Grpc.Core.SslClientCertificateRequestType : Enum {
    public int value__;
    public static SslClientCertificateRequestType DontRequest;
    public static SslClientCertificateRequestType RequestButDontVerify;
    public static SslClientCertificateRequestType RequestAndVerify;
    public static SslClientCertificateRequestType RequestAndRequireButDontVerify;
    public static SslClientCertificateRequestType RequestAndRequireAndVerify;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Grpc.Core.SslCredentials : ChannelCredentials {
    private string rootCertificates;
    private KeyCertificatePair keyCertificatePair;
    private VerifyPeerCallback verifyPeerCallback;
    public string RootCertificates { get; }
    public KeyCertificatePair KeyCertificatePair { get; }
    internal bool IsComposable { get; }
    [NullableContextAttribute("1")]
public SslCredentials(string rootCertificates);
    [NullableContextAttribute("1")]
public SslCredentials(string rootCertificates, KeyCertificatePair keyCertificatePair);
    public SslCredentials(string rootCertificates, KeyCertificatePair keyCertificatePair, VerifyPeerCallback verifyPeerCallback);
    public string get_RootCertificates();
    public KeyCertificatePair get_KeyCertificatePair();
    [NullableContextAttribute("1")]
public virtual void InternalPopulateConfiguration(ChannelCredentialsConfiguratorBase configurator, object state);
    internal virtual bool get_IsComposable();
}
internal class Grpc.Core.SslServerCredentials : ServerCredentials {
    private IList`1<KeyCertificatePair> keyCertificatePairs;
    private string rootCertificates;
    private SslClientCertificateRequestType clientCertificateRequest;
    public IList`1<KeyCertificatePair> KeyCertificatePairs { get; }
    public string RootCertificates { get; }
    public bool ForceClientAuthentication { get; }
    public SslClientCertificateRequestType ClientCertificateRequest { get; }
    public SslServerCredentials(IEnumerable`1<KeyCertificatePair> keyCertificatePairs, string rootCertificates, bool forceClientAuth);
    public SslServerCredentials(IEnumerable`1<KeyCertificatePair> keyCertificatePairs, string rootCertificates, SslClientCertificateRequestType clientCertificateRequest);
    public SslServerCredentials(IEnumerable`1<KeyCertificatePair> keyCertificatePairs);
    public IList`1<KeyCertificatePair> get_KeyCertificatePairs();
    public string get_RootCertificates();
    public bool get_ForceClientAuthentication();
    public SslClientCertificateRequestType get_ClientCertificateRequest();
    internal virtual ServerCredentialsSafeHandle ToNativeCredentials();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Grpc.Core.Status : ValueType {
    public static Status DefaultSuccess;
    public static Status DefaultCancelled;
    [CompilerGeneratedAttribute]
private StatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Detail>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <DebugException>k__BackingField;
    public StatusCode StatusCode { get; }
    public string Detail { get; }
    [NullableAttribute("2")]
public Exception DebugException { get; }
    public Status(StatusCode statusCode, string detail);
    public Status(StatusCode statusCode, string detail, Exception debugException);
    private static Status();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public StatusCode get_StatusCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Detail();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_DebugException();
    public virtual string ToString();
}
public enum Grpc.Core.StatusCode : Enum {
    public int value__;
    public static StatusCode OK;
    public static StatusCode Cancelled;
    public static StatusCode Unknown;
    public static StatusCode InvalidArgument;
    public static StatusCode DeadlineExceeded;
    public static StatusCode NotFound;
    public static StatusCode AlreadyExists;
    public static StatusCode PermissionDenied;
    public static StatusCode Unauthenticated;
    public static StatusCode ResourceExhausted;
    public static StatusCode FailedPrecondition;
    public static StatusCode Aborted;
    public static StatusCode OutOfRange;
    public static StatusCode Unimplemented;
    public static StatusCode Internal;
    public static StatusCode Unavailable;
    public static StatusCode DataLoss;
}
internal class Grpc.Core.UnaryServerMethod`2 : MulticastDelegate {
    public UnaryServerMethod`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<TResponse> Invoke(TRequest request, ServerCallContext context);
    public virtual IAsyncResult BeginInvoke(TRequest request, ServerCallContext context, AsyncCallback callback, object object);
    public virtual Task`1<TResponse> EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Grpc.Core.Utils.AsyncStreamExtensions : object {
    [AsyncStateMachineAttribute("Grpc.Core.Utils.AsyncStreamExtensions/<ForEachAsync>d__0`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IAsyncStreamReader`1<T> streamReader, Func`2<T, Task> asyncAction);
    [AsyncStateMachineAttribute("Grpc.Core.Utils.AsyncStreamExtensions/<ToListAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<List`1<T>> ToListAsync(IAsyncStreamReader`1<T> streamReader);
    [AsyncStateMachineAttribute("Grpc.Core.Utils.AsyncStreamExtensions/<WriteAllAsync>d__2`1")]
[ExtensionAttribute]
public static Task WriteAllAsync(IClientStreamWriter`1<T> streamWriter, IEnumerable`1<T> elements, bool complete);
    [AsyncStateMachineAttribute("Grpc.Core.Utils.AsyncStreamExtensions/<WriteAllAsync>d__3`1")]
[ExtensionAttribute]
public static Task WriteAllAsync(IServerStreamWriter`1<T> streamWriter, IEnumerable`1<T> elements);
}
internal static class Grpc.Core.Utils.BenchmarkUtil : object {
    public static void RunBenchmark(int warmupIterations, int benchmarkIterations, Action action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Grpc.Core.Utils.GrpcPreconditions : object {
    public static void CheckArgument(bool condition);
    public static void CheckArgument(bool condition, string errorMessage);
    public static T CheckNotNull(T reference);
    public static T CheckNotNull(T reference, string paramName);
    public static void CheckState(bool condition);
    public static void CheckState(bool condition, string errorMessage);
}
internal static class Grpc.Core.Utils.TaskUtils : object {
    public static Task CompletedTask { get; }
    public static Task get_CompletedTask();
}
internal class Grpc.Core.VerifyPeerCallback : MulticastDelegate {
    public VerifyPeerCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(VerifyPeerContext context);
    public virtual IAsyncResult BeginInvoke(VerifyPeerContext context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Grpc.Core.VerifyPeerContext : object {
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PeerPem>k__BackingField;
    public string TargetName { get; }
    public string PeerPem { get; }
    internal VerifyPeerContext(string targetName, string peerPem);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public string get_PeerPem();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Grpc.Core.VersionInfo : object {
    public static string CurrentAssemblyVersion;
    public static string CurrentAssemblyFileVersion;
    public static string CurrentVersion;
}
[FlagsAttribute]
internal enum Grpc.Core.WriteFlags : Enum {
    public int value__;
    public static WriteFlags BufferHint;
    public static WriteFlags NoCompress;
}
internal class Grpc.Core.WriteOptions : object {
    [NullableAttribute("1")]
public static WriteOptions Default;
    private WriteFlags flags;
    public WriteFlags Flags { get; }
    public WriteOptions(WriteFlags flags);
    private static WriteOptions();
    public WriteFlags get_Flags();
}
internal static class Guard : object {
    [NullableContextAttribute("1")]
public static T AgainstNull(T argument, string paramName);
}
internal static class ICSharpCode.SharpZipLib.BZip2.BZip2 : object {
    public static void Decompress(Stream inStream, Stream outStream, bool isStreamOwner);
    public static void Compress(Stream inStream, Stream outStream, bool isStreamOwner, int level);
}
internal static class ICSharpCode.SharpZipLib.BZip2.BZip2Constants : object {
    public static Int32[] RandomNumbers;
    public static int BaseBlockSize;
    public static int MaximumAlphaSize;
    public static int MaximumCodeLength;
    public static int RunA;
    public static int RunB;
    public static int GroupCount;
    public static int GroupSize;
    public static int NumberOfIterations;
    public static int MaximumSelectors;
    public static int OvershootBytes;
    private static BZip2Constants();
}
internal class ICSharpCode.SharpZipLib.BZip2.BZip2Exception : SharpZipBaseException {
    public BZip2Exception(string message);
    public BZip2Exception(string message, Exception innerException);
    protected BZip2Exception(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.BZip2.BZip2InputStream : Stream {
    private static int START_BLOCK_STATE;
    private static int RAND_PART_A_STATE;
    private static int RAND_PART_B_STATE;
    private static int RAND_PART_C_STATE;
    private static int NO_RAND_PART_A_STATE;
    private static int NO_RAND_PART_B_STATE;
    private static int NO_RAND_PART_C_STATE;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bsBuff;
    private int bsLive;
    private IChecksum mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Byte[] seqToUnseq;
    private Byte[] unseqToSeq;
    private Byte[] selector;
    private Byte[] selectorMtf;
    private Int32[] tt;
    private Byte[] ll8;
    private Int32[] unzftab;
    private Int32[][] limit;
    private Int32[][] baseArray;
    private Int32[][] perm;
    private Int32[] minLens;
    private Stream baseStream;
    private bool streamEnd;
    private int currentChar;
    private int currentState;
    private int storedBlockCRC;
    private int storedCombinedCRC;
    private int computedBlockCRC;
    private UInt32 computedCombinedCRC;
    private int count;
    private int chPrev;
    private int ch2;
    private int tPos;
    private int rNToGo;
    private int rTPos;
    private int i2;
    private int j2;
    private byte z;
    [CompilerGeneratedAttribute]
private bool <IsStreamOwner>k__BackingField;
    public bool IsStreamOwner { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BZip2InputStream(Stream stream);
    [CompilerGeneratedAttribute]
public bool get_IsStreamOwner();
    [CompilerGeneratedAttribute]
public void set_IsStreamOwner(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    public virtual int ReadByte();
    private void MakeMaps();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void Complete();
    private void FillBuffer();
    private int BsR(int n);
    private char BsGetUChar();
    private int BsGetIntVS(int numBits);
    private int BsGetInt32();
    private void RecvDecodingTables();
    private void GetAndMoveToFrontDecode();
    private void SetupBlock();
    private void SetupRandPartA();
    private void SetupNoRandPartA();
    private void SetupRandPartB();
    private void SetupRandPartC();
    private void SetupNoRandPartB();
    private void SetupNoRandPartC();
    private void SetDecompressStructureSizes(int newSize100k);
    private static void CompressedStreamEOF();
    private static void BlockOverrun();
    private static void BadBlockHeader();
    private static void CrcError();
    private static void HbCreateDecodeTables(Int32[] limit, Int32[] baseArray, Int32[] perm, Char[] length, int minLen, int maxLen, int alphaSize);
}
internal class ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream : Stream {
    private static int SETMASK;
    private static int CLEARMASK;
    private static int GREATER_ICOST;
    private static int LESSER_ICOST;
    private static int SMALL_THRESH;
    private static int DEPTH_THRESH;
    private static int QSORT_STACK_SIZE;
    private Int32[] increments;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bytesOut;
    private int bsBuff;
    private int bsLive;
    private IChecksum mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Byte[] block;
    private Int32[] quadrant;
    private Int32[] zptr;
    private Int16[] szptr;
    private Int32[] ftab;
    private int nMTF;
    private Int32[] mtfFreq;
    private int workFactor;
    private int workDone;
    private int workLimit;
    private bool firstAttempt;
    private int nBlocksRandomised;
    private int currentChar;
    private int runLength;
    private UInt32 blockCRC;
    private UInt32 combinedCRC;
    private int allowableBlockSize;
    private Stream baseStream;
    private bool disposed_;
    [CompilerGeneratedAttribute]
private bool <IsStreamOwner>k__BackingField;
    public bool IsStreamOwner { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int BytesWritten { get; }
    public BZip2OutputStream(Stream stream);
    public BZip2OutputStream(Stream stream, int blockSize);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsStreamOwner();
    [CompilerGeneratedAttribute]
public void set_IsStreamOwner(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    private void MakeMaps();
    private void WriteRun();
    public int get_BytesWritten();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void EndCompression();
    private void BsFinishedWithStream();
    private void BsW(int n, int v);
    private void BsPutUChar(int c);
    private void BsPutint(int u);
    private void BsPutIntVS(int numBits, int c);
    private void SendMTFValues();
    private void MoveToFrontCodeAndSend();
    private void SimpleSort(int lo, int hi, int d);
    private void Vswap(int p1, int p2, int n);
    private void QSort3(int loSt, int hiSt, int dSt);
    private void MainSort();
    private void RandomiseBlock();
    private void DoReversibleTransformation();
    private bool FullGtU(int i1, int i2);
    private void AllocateCompressStructures();
    private void GenerateMTFValues();
    private static void Panic();
    private static void HbMakeCodeLengths(Char[] len, Int32[] freq, int alphaSize, int maxLen);
    private static void HbAssignCodes(Int32[] code, Char[] length, int minLen, int maxLen, int alphaSize);
    private static byte Med3(byte a, byte b, byte c);
}
internal class ICSharpCode.SharpZipLib.Checksum.Adler32 : object {
    private static UInt32 BASE;
    private UInt32 checkValue;
    public long Value { get; }
    private static Adler32();
    public sealed virtual void Reset();
    public sealed virtual long get_Value();
    public sealed virtual void Update(int bval);
    public sealed virtual void Update(Byte[] buffer);
    public sealed virtual void Update(ArraySegment`1<byte> segment);
}
internal class ICSharpCode.SharpZipLib.Checksum.BZip2Crc : object {
    private static UInt32 crcInit;
    private static UInt32[] crcTable;
    private UInt32 checkValue;
    public long Value { get; }
    private static BZip2Crc();
    public sealed virtual void Reset();
    public sealed virtual long get_Value();
    public sealed virtual void Update(int bval);
    public sealed virtual void Update(Byte[] buffer);
    public sealed virtual void Update(ArraySegment`1<byte> segment);
    private void Update(Byte[] data, int offset, int count);
    private void SlowUpdateLoop(Byte[] data, int offset, int end);
}
internal class ICSharpCode.SharpZipLib.Checksum.Crc32 : object {
    private static UInt32 crcInit;
    private static UInt32 crcXor;
    private static UInt32[] crcTable;
    private UInt32 checkValue;
    public long Value { get; }
    private static Crc32();
    internal static UInt32 ComputeCrc32(UInt32 oldCrc, byte bval);
    public sealed virtual void Reset();
    public sealed virtual long get_Value();
    public sealed virtual void Update(int bval);
    public sealed virtual void Update(Byte[] buffer);
    public sealed virtual void Update(ArraySegment`1<byte> segment);
    private void Update(Byte[] data, int offset, int count);
    private void SlowUpdateLoop(Byte[] data, int offset, int end);
}
internal static class ICSharpCode.SharpZipLib.Checksum.CrcUtilities : object {
    internal static int SlicingDegree;
    internal static UInt32[] GenerateSlicingLookupTable(UInt32 polynomial, bool isReversed);
    internal static UInt32 UpdateDataForNormalPoly(Byte[] input, int offset, UInt32[] crcTable, UInt32 checkValue);
    internal static UInt32 UpdateDataForReversedPoly(Byte[] input, int offset, UInt32[] crcTable, UInt32 checkValue);
    private static UInt32 UpdateDataCommon(Byte[] input, int offset, UInt32[] crcTable, byte x1, byte x2, byte x3, byte x4);
}
internal interface ICSharpCode.SharpZipLib.Checksum.IChecksum {
    public long Value { get; }
    public abstract virtual void Reset();
    public abstract virtual long get_Value();
    public abstract virtual void Update(int bval);
    public abstract virtual void Update(Byte[] buffer);
    public abstract virtual void Update(ArraySegment`1<byte> segment);
}
[ExtensionAttribute]
internal static class ICSharpCode.SharpZipLib.Core.ByteOrderStreamExtensions : object {
    internal static Byte[] SwappedBytes(ushort value);
    internal static Byte[] SwappedBytes(short value);
    internal static Byte[] SwappedBytes(UInt32 value);
    internal static Byte[] SwappedBytes(int value);
    internal static Byte[] SwappedBytes(long value);
    internal static Byte[] SwappedBytes(ulong value);
    internal static long SwappedS64(Byte[] bytes);
    internal static ulong SwappedU64(Byte[] bytes);
    internal static int SwappedS32(Byte[] bytes);
    internal static UInt32 SwappedU32(Byte[] bytes);
    internal static short SwappedS16(Byte[] bytes);
    internal static ushort SwappedU16(Byte[] bytes);
    [ExtensionAttribute]
internal static Byte[] ReadBytes(Stream stream, int count);
    [ExtensionAttribute]
public static int ReadLEShort(Stream stream);
    [ExtensionAttribute]
public static int ReadLEInt(Stream stream);
    [ExtensionAttribute]
public static long ReadLELong(Stream stream);
    [ExtensionAttribute]
public static void WriteLEShort(Stream stream, int value);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Core.ByteOrderStreamExtensions/<WriteLEShortAsync>d__17")]
[ExtensionAttribute]
public static Task WriteLEShortAsync(Stream stream, int value, CancellationToken ct);
    [ExtensionAttribute]
public static void WriteLEUshort(Stream stream, ushort value);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Core.ByteOrderStreamExtensions/<WriteLEUshortAsync>d__19")]
[ExtensionAttribute]
public static Task WriteLEUshortAsync(Stream stream, ushort value, CancellationToken ct);
    [ExtensionAttribute]
public static void WriteLEInt(Stream stream, int value);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Core.ByteOrderStreamExtensions/<WriteLEIntAsync>d__21")]
[ExtensionAttribute]
public static Task WriteLEIntAsync(Stream stream, int value, CancellationToken ct);
    [ExtensionAttribute]
public static void WriteLEUint(Stream stream, UInt32 value);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Core.ByteOrderStreamExtensions/<WriteLEUintAsync>d__23")]
[ExtensionAttribute]
public static Task WriteLEUintAsync(Stream stream, UInt32 value, CancellationToken ct);
    [ExtensionAttribute]
public static void WriteLELong(Stream stream, long value);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Core.ByteOrderStreamExtensions/<WriteLELongAsync>d__25")]
[ExtensionAttribute]
public static Task WriteLELongAsync(Stream stream, long value, CancellationToken ct);
    [ExtensionAttribute]
public static void WriteLEUlong(Stream stream, ulong value);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Core.ByteOrderStreamExtensions/<WriteLEUlongAsync>d__27")]
[ExtensionAttribute]
public static Task WriteLEUlongAsync(Stream stream, ulong value, CancellationToken ct);
}
internal class ICSharpCode.SharpZipLib.Core.CompletedFileHandler : MulticastDelegate {
    public CompletedFileHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ScanEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ScanEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class ICSharpCode.SharpZipLib.Core.DirectoryEventArgs : ScanEventArgs {
    private bool hasMatchingFiles_;
    public bool HasMatchingFiles { get; }
    public DirectoryEventArgs(string name, bool hasMatchingFiles);
    public bool get_HasMatchingFiles();
}
internal class ICSharpCode.SharpZipLib.Core.DirectoryFailureHandler : MulticastDelegate {
    public DirectoryFailureHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ScanFailureEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ScanFailureEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class ICSharpCode.SharpZipLib.Core.Empty : object {
    public static T[] Array();
}
internal class ICSharpCode.SharpZipLib.Core.ExactMemoryPool`1 : MemoryPool`1<T> {
    public static MemoryPool`1<T> Shared;
    public int MaxBufferSize { get; }
    private static ExactMemoryPool`1();
    public virtual IMemoryOwner`1<T> Rent(int bufferSize);
    protected virtual void Dispose(bool disposing);
    public virtual int get_MaxBufferSize();
}
internal class ICSharpCode.SharpZipLib.Core.ExtendedPathFilter : PathFilter {
    private long minSize_;
    private long maxSize_;
    private DateTime minDate_;
    private DateTime maxDate_;
    public long MinSize { get; public set; }
    public long MaxSize { get; public set; }
    public DateTime MinDate { get; public set; }
    public DateTime MaxDate { get; public set; }
    public ExtendedPathFilter(string filter, long minSize, long maxSize);
    public ExtendedPathFilter(string filter, DateTime minDate, DateTime maxDate);
    public ExtendedPathFilter(string filter, long minSize, long maxSize, DateTime minDate, DateTime maxDate);
    public virtual bool IsMatch(string name);
    public long get_MinSize();
    public void set_MinSize(long value);
    public long get_MaxSize();
    public void set_MaxSize(long value);
    public DateTime get_MinDate();
    public void set_MinDate(DateTime value);
    public DateTime get_MaxDate();
    public void set_MaxDate(DateTime value);
}
internal class ICSharpCode.SharpZipLib.Core.FileFailureHandler : MulticastDelegate {
    public FileFailureHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ScanFailureEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ScanFailureEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class ICSharpCode.SharpZipLib.Core.FileSystemScanner : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<DirectoryEventArgs> ProcessDirectory;
    public ProcessFileHandler ProcessFile;
    public CompletedFileHandler CompletedFile;
    public DirectoryFailureHandler DirectoryFailure;
    public FileFailureHandler FileFailure;
    private IScanFilter fileFilter_;
    private IScanFilter directoryFilter_;
    private bool alive_;
    public FileSystemScanner(string filter);
    public FileSystemScanner(string fileFilter, string directoryFilter);
    public FileSystemScanner(IScanFilter fileFilter);
    public FileSystemScanner(IScanFilter fileFilter, IScanFilter directoryFilter);
    [CompilerGeneratedAttribute]
public void add_ProcessDirectory(EventHandler`1<DirectoryEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessDirectory(EventHandler`1<DirectoryEventArgs> value);
    private bool OnDirectoryFailure(string directory, Exception e);
    private bool OnFileFailure(string file, Exception e);
    private void OnProcessFile(string file);
    private void OnCompleteFile(string file);
    private void OnProcessDirectory(string directory, bool hasMatchingFiles);
    public void Scan(string directory, bool recurse);
    private void ScanDir(string directory, bool recurse);
}
internal interface ICSharpCode.SharpZipLib.Core.INameTransform {
    public abstract virtual string TransformFile(string name);
    public abstract virtual string TransformDirectory(string name);
}
internal class ICSharpCode.SharpZipLib.Core.InvalidNameException : SharpZipBaseException {
    public InvalidNameException(string message);
    public InvalidNameException(string message, Exception innerException);
    protected InvalidNameException(SerializationInfo info, StreamingContext context);
}
internal interface ICSharpCode.SharpZipLib.Core.IScanFilter {
    public abstract virtual bool IsMatch(string name);
}
[ObsoleteAttribute("Use ExtendedPathFilter instead")]
internal class ICSharpCode.SharpZipLib.Core.NameAndSizeFilter : PathFilter {
    private long minSize_;
    private long maxSize_;
    public long MinSize { get; public set; }
    public long MaxSize { get; public set; }
    public NameAndSizeFilter(string filter, long minSize, long maxSize);
    public virtual bool IsMatch(string name);
    public long get_MinSize();
    public void set_MinSize(long value);
    public long get_MaxSize();
    public void set_MaxSize(long value);
}
internal class ICSharpCode.SharpZipLib.Core.NameFilter : object {
    private string filter_;
    private List`1<Regex> inclusions_;
    private List`1<Regex> exclusions_;
    public NameFilter(string filter);
    public static bool IsValidExpression(string expression);
    public static bool IsValidFilterExpression(string toTest);
    public static String[] SplitQuoted(string original);
    public virtual string ToString();
    public bool IsIncluded(string name);
    public bool IsExcluded(string name);
    public sealed virtual bool IsMatch(string name);
    private void Compile();
}
internal class ICSharpCode.SharpZipLib.Core.PathFilter : object {
    private NameFilter nameFilter_;
    public PathFilter(string filter);
    public virtual bool IsMatch(string name);
}
internal static class ICSharpCode.SharpZipLib.Core.PathUtils : object {
    public static string DropPathRoot(string path);
    public static string GetTempFileName(string original);
}
internal class ICSharpCode.SharpZipLib.Core.ProcessFileHandler : MulticastDelegate {
    public ProcessFileHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ScanEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ScanEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class ICSharpCode.SharpZipLib.Core.ProgressEventArgs : EventArgs {
    private string name_;
    private long processed_;
    private long target_;
    private bool continueRunning_;
    public string Name { get; }
    public bool ContinueRunning { get; public set; }
    public float PercentComplete { get; }
    public long Processed { get; }
    public long Target { get; }
    public ProgressEventArgs(string name, long processed, long target);
    public string get_Name();
    public bool get_ContinueRunning();
    public void set_ContinueRunning(bool value);
    public float get_PercentComplete();
    public long get_Processed();
    public long get_Target();
}
internal class ICSharpCode.SharpZipLib.Core.ProgressHandler : MulticastDelegate {
    public ProgressHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class ICSharpCode.SharpZipLib.Core.ScanEventArgs : EventArgs {
    private string name_;
    private bool continueRunning_;
    public string Name { get; }
    public bool ContinueRunning { get; public set; }
    public ScanEventArgs(string name);
    public string get_Name();
    public bool get_ContinueRunning();
    public void set_ContinueRunning(bool value);
}
internal class ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs : EventArgs {
    private string name_;
    private Exception exception_;
    private bool continueRunning_;
    public string Name { get; }
    public Exception Exception { get; }
    public bool ContinueRunning { get; public set; }
    public ScanFailureEventArgs(string name, Exception e);
    public string get_Name();
    public Exception get_Exception();
    public bool get_ContinueRunning();
    public void set_ContinueRunning(bool value);
}
[ExtensionAttribute]
internal static class ICSharpCode.SharpZipLib.Core.StreamUtils : object {
    public static void ReadFully(Stream stream, Byte[] buffer);
    public static void ReadFully(Stream stream, Byte[] buffer, int offset, int count);
    public static int ReadRequestedBytes(Stream stream, Byte[] buffer, int offset, int count);
    public static void Copy(Stream source, Stream destination, Byte[] buffer);
    public static void Copy(Stream source, Stream destination, Byte[] buffer, ProgressHandler progressHandler, TimeSpan updateInterval, object sender, string name);
    public static void Copy(Stream source, Stream destination, Byte[] buffer, ProgressHandler progressHandler, TimeSpan updateInterval, object sender, string name, long fixedTarget);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Core.StreamUtils/<WriteProcToStreamAsync>d__6")]
[ExtensionAttribute]
internal static Task WriteProcToStreamAsync(Stream targetStream, MemoryStream bufferStream, Action`1<Stream> writeProc, CancellationToken ct);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Core.StreamUtils/<WriteProcToStreamAsync>d__7")]
[ExtensionAttribute]
internal static Task WriteProcToStreamAsync(Stream targetStream, Action`1<Stream> writeProc, CancellationToken ct);
}
internal class ICSharpCode.SharpZipLib.Core.StringBuilderPool : object {
    [CompilerGeneratedAttribute]
private static StringBuilderPool <Instance>k__BackingField;
    private ConcurrentQueue`1<StringBuilder> pool;
    public static StringBuilderPool Instance { get; }
    private static StringBuilderPool();
    [CompilerGeneratedAttribute]
public static StringBuilderPool get_Instance();
    public StringBuilder Rent();
    public void Return(StringBuilder builder);
}
internal abstract class ICSharpCode.SharpZipLib.Encryption.PkzipClassic : SymmetricAlgorithm {
    public static Byte[] GenerateKeys(Byte[] seed);
}
internal class ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase : object {
    private UInt32[] keys;
    protected byte TransformByte();
    protected void SetKeys(Byte[] keyData);
    protected void UpdateKeys(byte ch);
    protected void Reset();
}
internal class ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform : PkzipClassicCryptoBase {
    public bool CanReuseTransform { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    internal PkzipClassicDecryptCryptoTransform(Byte[] keyBlock);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual void Dispose();
}
internal class ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform : PkzipClassicCryptoBase {
    public bool CanReuseTransform { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    internal PkzipClassicEncryptCryptoTransform(Byte[] keyBlock);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual void Dispose();
}
internal class ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged : PkzipClassic {
    private Byte[] key_;
    public int BlockSize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public KeySizes[] LegalBlockSizes { get; }
    public Byte[] Key { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual void GenerateIV();
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual void GenerateKey();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
}
internal class ICSharpCode.SharpZipLib.Encryption.ZipAESStream : CryptoStream {
    public static int AUTH_CODE_LENGTH;
    private static int CRYPTO_BLOCK_SIZE;
    private static int BLOCK_AND_AUTH;
    private Stream _stream;
    private ZipAESTransform _transform;
    private Byte[] _slideBuffer;
    private int _slideBufStartPos;
    private int _slideBufFreePos;
    private Byte[] _transformBuffer;
    private int _transformBufferFreePos;
    private int _transformBufferStartPos;
    private bool HasBufferedData { get; }
    public ZipAESStream(Stream stream, ZipAESTransform transform, CryptoStreamMode mode);
    private bool get_HasBufferedData();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private int ReadAndTransform(Byte[] buffer, int offset, int count);
    private int ReadBufferedData(Byte[] buffer, int offset, int count);
    private int TransformAndBufferBlock(Byte[] buffer, int offset, int count, int blockSize);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class ICSharpCode.SharpZipLib.Encryption.ZipAESTransform : object {
    private static int PWD_VER_LENGTH;
    private static int KEY_ROUNDS;
    private static int ENCRYPT_BLOCK;
    private int _blockSize;
    private ICryptoTransform _encryptor;
    private Byte[] _counterNonce;
    private Byte[] _encryptBuffer;
    private int _encrPos;
    private Byte[] _pwdVerifier;
    private IncrementalHash _hmacsha1;
    private Byte[] _authCode;
    private bool _writeMode;
    public Byte[] PwdVerifier { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public ZipAESTransform(string key, Byte[] saltBytes, int blockSize, bool writeMode);
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public Byte[] get_PwdVerifier();
    public Byte[] GetAuthCode();
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual void Dispose();
}
internal static class ICSharpCode.SharpZipLib.GZip.GZip : object {
    public static void Decompress(Stream inStream, Stream outStream, bool isStreamOwner);
    public static void Compress(Stream inStream, Stream outStream, bool isStreamOwner, int bufferSize, int level);
}
internal class ICSharpCode.SharpZipLib.GZip.GZipConstants : object {
    public static byte ID1;
    public static byte ID2;
    public static byte CompressionMethodDeflate;
    public static Encoding Encoding { get; }
    public static Encoding get_Encoding();
}
internal class ICSharpCode.SharpZipLib.GZip.GZipException : SharpZipBaseException {
    public GZipException(string message);
    public GZipException(string message, Exception innerException);
    protected GZipException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum ICSharpCode.SharpZipLib.GZip.GZipFlags : Enum {
    public byte value__;
    public static GZipFlags FTEXT;
    public static GZipFlags FHCRC;
    public static GZipFlags FEXTRA;
    public static GZipFlags FNAME;
    public static GZipFlags FCOMMENT;
}
internal class ICSharpCode.SharpZipLib.GZip.GZipInputStream : InflaterInputStream {
    protected Crc32 crc;
    private bool readGZIPHeader;
    private bool completedLastBlock;
    private string fileName;
    public GZipInputStream(Stream baseInputStream);
    public GZipInputStream(Stream baseInputStream, int size);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public string GetFilename();
    private bool ReadHeader();
    private void ReadFooter();
}
internal class ICSharpCode.SharpZipLib.GZip.GZipOutputStream : DeflaterOutputStream {
    protected Crc32 crc;
    private OutputState state_;
    private string fileName;
    private GZipFlags flags;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ModifiedTime>k__BackingField;
    public string FileName { get; public set; }
    public Nullable`1<DateTime> ModifiedTime { get; public set; }
    public GZipOutputStream(Stream baseOutputStream);
    public GZipOutputStream(Stream baseOutputStream, int size);
    public void SetLevel(int level);
    public int GetLevel();
    public string get_FileName();
    public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ModifiedTime();
    [CompilerGeneratedAttribute]
public void set_ModifiedTime(Nullable`1<DateTime> value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.GZip.GZipOutputStream/<WriteSyncOrAsync>d__17")]
private Task WriteSyncOrAsync(Byte[] buffer, int offset, int count, Nullable`1<CancellationToken> ct);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.GZip.GZipOutputStream/<WriteAsync>d__18")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken ct);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.GZip.GZipOutputStream/<FlushAsync>d__21")]
public virtual Task FlushAsync(CancellationToken ct);
    public virtual void Finish();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.GZip.GZipOutputStream/<FinishAsync>d__23")]
public virtual Task FinishAsync(CancellationToken ct);
    private Byte[] GetFooter();
    private Byte[] GetHeader();
    private static string CleanFilename(string path);
    private void WriteHeader();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.GZip.GZipOutputStream/<WriteHeaderAsync>d__28")]
private Task WriteHeaderAsync(CancellationToken ct);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(Byte[] buffer, int offset, int count, CancellationToken ct);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__1(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__2(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__3(CancellationToken ct);
}
internal class ICSharpCode.SharpZipLib.Lzw.LzwConstants : object {
    public static int MAGIC;
    public static int MAX_BITS;
    public static int BIT_MASK;
    public static int EXTENDED_MASK;
    public static int RESERVED_MASK;
    public static int BLOCK_MODE_MASK;
    public static int HDR_SIZE;
    public static int INIT_BITS;
}
internal class ICSharpCode.SharpZipLib.Lzw.LzwException : SharpZipBaseException {
    public LzwException(string message);
    public LzwException(string message, Exception innerException);
    protected LzwException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.Lzw.LzwInputStream : Stream {
    [CompilerGeneratedAttribute]
private bool <IsStreamOwner>k__BackingField;
    private Stream baseInputStream;
    private bool isClosed;
    private Byte[] one;
    private bool headerParsed;
    private static int TBL_CLEAR;
    private static int TBL_FIRST;
    private Int32[] tabPrefix;
    private Byte[] tabSuffix;
    private Int32[] zeros;
    private Byte[] stack;
    private bool blockMode;
    private int nBits;
    private int maxBits;
    private int maxMaxCode;
    private int maxCode;
    private int bitMask;
    private int oldCode;
    private byte finChar;
    private int stackP;
    private int freeEnt;
    private Byte[] data;
    private int bitPos;
    private int end;
    private int got;
    private bool eof;
    private static int EXTRA;
    public bool IsStreamOwner { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LzwInputStream(Stream baseInputStream);
    [CompilerGeneratedAttribute]
public bool get_IsStreamOwner();
    [CompilerGeneratedAttribute]
public void set_IsStreamOwner(bool value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private int ResetBuf(int bitPosition);
    private void Fill();
    private void ParseHeader();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
}
internal class ICSharpCode.SharpZipLib.SharpZipBaseException : Exception {
    public SharpZipBaseException(string message);
    public SharpZipBaseException(string message, Exception innerException);
    protected SharpZipBaseException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.StreamDecodingException : SharpZipBaseException {
    private static string GenericMessage;
    public StreamDecodingException(string message);
    public StreamDecodingException(string message, Exception innerException);
    protected StreamDecodingException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.StreamUnsupportedException : StreamDecodingException {
    private static string GenericMessage;
    public StreamUnsupportedException(string message);
    public StreamUnsupportedException(string message, Exception innerException);
    protected StreamUnsupportedException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.Tar.InvalidHeaderException : TarException {
    public InvalidHeaderException(string message);
    public InvalidHeaderException(string message, Exception exception);
    protected InvalidHeaderException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.Tar.ProgressMessageHandler : MulticastDelegate {
    public ProgressMessageHandler(object object, IntPtr method);
    public virtual void Invoke(TarArchive archive, TarEntry entry, string message);
    public virtual IAsyncResult BeginInvoke(TarArchive archive, TarEntry entry, string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class ICSharpCode.SharpZipLib.Tar.TarArchive : object {
    [CompilerGeneratedAttribute]
private ProgressMessageHandler ProgressMessageEvent;
    private bool keepOldFiles;
    private bool asciiTranslate;
    private int userId;
    private string userName;
    private int groupId;
    private string groupName;
    private string rootPath;
    private string pathPrefix;
    private bool applyUserInfoOverrides;
    private TarInputStream tarIn;
    private TarOutputStream tarOut;
    private bool isDisposed;
    public bool AsciiTranslate { get; public set; }
    public string PathPrefix { get; public set; }
    public string RootPath { get; public set; }
    public bool ApplyUserInfoOverrides { get; public set; }
    public int UserId { get; }
    public string UserName { get; }
    public int GroupId { get; }
    public string GroupName { get; }
    public int RecordSize { get; }
    unknown bool IsStreamOwner {public set; }
    protected TarArchive(TarInputStream stream);
    protected TarArchive(TarOutputStream stream);
    [CompilerGeneratedAttribute]
public void add_ProgressMessageEvent(ProgressMessageHandler value);
    [CompilerGeneratedAttribute]
public void remove_ProgressMessageEvent(ProgressMessageHandler value);
    protected virtual void OnProgressMessageEvent(TarEntry entry, string message);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public static TarArchive CreateInputTarArchive(Stream inputStream);
    public static TarArchive CreateInputTarArchive(Stream inputStream, Encoding nameEncoding);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public static TarArchive CreateInputTarArchive(Stream inputStream, int blockFactor);
    public static TarArchive CreateInputTarArchive(Stream inputStream, int blockFactor, Encoding nameEncoding);
    public static TarArchive CreateOutputTarArchive(Stream outputStream, Encoding nameEncoding);
    public static TarArchive CreateOutputTarArchive(Stream outputStream);
    public static TarArchive CreateOutputTarArchive(Stream outputStream, int blockFactor);
    public static TarArchive CreateOutputTarArchive(Stream outputStream, int blockFactor, Encoding nameEncoding);
    public void SetKeepOldFiles(bool keepExistingFiles);
    public bool get_AsciiTranslate();
    public void set_AsciiTranslate(bool value);
    [ObsoleteAttribute("Use the AsciiTranslate property")]
public void SetAsciiTranslation(bool translateAsciiFiles);
    public string get_PathPrefix();
    public void set_PathPrefix(string value);
    public string get_RootPath();
    public void set_RootPath(string value);
    public void SetUserInfo(int userId, string userName, int groupId, string groupName);
    public bool get_ApplyUserInfoOverrides();
    public void set_ApplyUserInfoOverrides(bool value);
    public int get_UserId();
    public string get_UserName();
    public int get_GroupId();
    public string get_GroupName();
    public int get_RecordSize();
    public void set_IsStreamOwner(bool value);
    [ObsoleteAttribute("Use Close instead")]
public void CloseArchive();
    public void ListContents();
    public void ExtractContents(string destinationDirectory);
    public void ExtractContents(string destinationDirectory, bool allowParentTraversal);
    private void ExtractEntry(string destDir, TarEntry entry, bool allowParentTraversal);
    private void ExtractAndTranslateEntry(string destFile, Stream outputStream);
    public void WriteEntry(TarEntry sourceEntry, bool recurse);
    private void WriteEntryCore(TarEntry sourceEntry, bool recurse);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual override void Finalize();
    private static void EnsureDirectoryExists(string directoryName);
    private static bool IsBinary(string filename);
}
internal class ICSharpCode.SharpZipLib.Tar.TarBuffer : object {
    public static int BlockSize;
    public static int DefaultBlockFactor;
    public static int DefaultRecordSize;
    [CompilerGeneratedAttribute]
private bool <IsStreamOwner>k__BackingField;
    private Stream inputStream;
    private Stream outputStream;
    private Byte[] recordBuffer;
    private int currentBlockIndex;
    private int currentRecordIndex;
    private int recordSize;
    private int blockFactor;
    public int RecordSize { get; }
    public int BlockFactor { get; }
    public int CurrentBlock { get; }
    public bool IsStreamOwner { get; public set; }
    public int CurrentRecord { get; }
    public int get_RecordSize();
    [ObsoleteAttribute("Use RecordSize property instead")]
public int GetRecordSize();
    public int get_BlockFactor();
    [ObsoleteAttribute("Use BlockFactor property instead")]
public int GetBlockFactor();
    public static TarBuffer CreateInputTarBuffer(Stream inputStream);
    public static TarBuffer CreateInputTarBuffer(Stream inputStream, int blockFactor);
    public static TarBuffer CreateOutputTarBuffer(Stream outputStream);
    public static TarBuffer CreateOutputTarBuffer(Stream outputStream, int blockFactor);
    private void Initialize(int archiveBlockFactor);
    [ObsoleteAttribute("Use IsEndOfArchiveBlock instead")]
public bool IsEOFBlock(Byte[] block);
    public static bool IsEndOfArchiveBlock(Byte[] block);
    public void SkipBlock();
    public Task SkipBlockAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarBuffer/<SkipBlockAsync>d__19")]
private ValueTask SkipBlockAsync(CancellationToken ct, bool isAsync);
    public Byte[] ReadBlock();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarBuffer/<ReadBlockIntAsync>d__21")]
internal ValueTask ReadBlockIntAsync(Byte[] buffer, CancellationToken ct, bool isAsync);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarBuffer/<ReadRecordAsync>d__22")]
private ValueTask`1<bool> ReadRecordAsync(CancellationToken ct, bool isAsync);
    public int get_CurrentBlock();
    [CompilerGeneratedAttribute]
public bool get_IsStreamOwner();
    [CompilerGeneratedAttribute]
public void set_IsStreamOwner(bool value);
    [ObsoleteAttribute("Use CurrentBlock property instead")]
public int GetCurrentBlockNum();
    public int get_CurrentRecord();
    [ObsoleteAttribute("Use CurrentRecord property instead")]
public int GetCurrentRecordNum();
    public ValueTask WriteBlockAsync(Byte[] block, CancellationToken ct);
    public void WriteBlock(Byte[] block);
    public ValueTask WriteBlockAsync(Byte[] buffer, int offset, CancellationToken ct);
    public void WriteBlock(Byte[] buffer, int offset);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarBuffer/<WriteBlockAsync>d__37")]
internal ValueTask WriteBlockAsync(Byte[] buffer, int offset, CancellationToken ct, bool isAsync);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarBuffer/<WriteRecordAsync>d__38")]
private ValueTask WriteRecordAsync(CancellationToken ct, bool isAsync);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarBuffer/<WriteFinalRecordAsync>d__39")]
private ValueTask WriteFinalRecordAsync(CancellationToken ct, bool isAsync);
    public void Close();
    public Task CloseAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarBuffer/<CloseAsync>d__42")]
private ValueTask CloseAsync(CancellationToken ct, bool isAsync);
}
internal class ICSharpCode.SharpZipLib.Tar.TarEntry : object {
    private string file;
    private TarHeader header;
    public TarHeader TarHeader { get; }
    public string Name { get; public set; }
    public int UserId { get; public set; }
    public int GroupId { get; public set; }
    public string UserName { get; public set; }
    public string GroupName { get; public set; }
    public DateTime ModTime { get; public set; }
    public string File { get; }
    public long Size { get; public set; }
    public bool IsDirectory { get; }
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public TarEntry(Byte[] headerBuffer);
    public TarEntry(Byte[] headerBuffer, Encoding nameEncoding);
    public TarEntry(TarHeader header);
    public object Clone();
    public static TarEntry CreateTarEntry(string name);
    public static TarEntry CreateEntryFromFile(string fileName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsDescendent(TarEntry toTest);
    public TarHeader get_TarHeader();
    public string get_Name();
    public void set_Name(string value);
    public int get_UserId();
    public void set_UserId(int value);
    public int get_GroupId();
    public void set_GroupId(int value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_GroupName();
    public void set_GroupName(string value);
    public void SetIds(int userId, int groupId);
    public void SetNames(string userName, string groupName);
    public DateTime get_ModTime();
    public void set_ModTime(DateTime value);
    public string get_File();
    public long get_Size();
    public void set_Size(long value);
    public bool get_IsDirectory();
    public void GetFileTarHeader(TarHeader header, string file);
    public TarEntry[] GetDirectoryEntries();
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public void WriteEntryHeader(Byte[] outBuffer);
    public void WriteEntryHeader(Byte[] outBuffer, Encoding nameEncoding);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public static void AdjustEntryName(Byte[] buffer, string newName);
    public static void AdjustEntryName(Byte[] buffer, string newName, Encoding nameEncoding);
    public void NameTarHeader(string name);
}
internal class ICSharpCode.SharpZipLib.Tar.TarException : SharpZipBaseException {
    public TarException(string message);
    public TarException(string message, Exception innerException);
    protected TarException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.Tar.TarExtendedHeaderReader : object {
    private static byte LENGTH;
    private static byte KEY;
    private static byte VALUE;
    private static byte END;
    private Dictionary`2<string, string> headers;
    private String[] headerParts;
    private int bbIndex;
    private Byte[] byteBuffer;
    private Char[] charBuffer;
    private StringBuilder sb;
    private Decoder decoder;
    private int state;
    private int currHeaderLength;
    private int currHeaderRead;
    private static Byte[] StateNext;
    public Dictionary`2<string, string> Headers { get; }
    private static TarExtendedHeaderReader();
    public void Read(Byte[] buffer, int length);
    private void Flush();
    private void ResetBuffers();
    public Dictionary`2<string, string> get_Headers();
}
internal class ICSharpCode.SharpZipLib.Tar.TarHeader : object {
    public static int NAMELEN;
    public static int MODELEN;
    public static int UIDLEN;
    public static int GIDLEN;
    public static int CHKSUMLEN;
    public static int CHKSUMOFS;
    public static int SIZELEN;
    public static int MAGICLEN;
    public static int VERSIONLEN;
    public static int MODTIMELEN;
    public static int UNAMELEN;
    public static int GNAMELEN;
    public static int DEVLEN;
    public static int PREFIXLEN;
    public static byte LF_OLDNORM;
    public static byte LF_NORMAL;
    public static byte LF_LINK;
    public static byte LF_SYMLINK;
    public static byte LF_CHR;
    public static byte LF_BLK;
    public static byte LF_DIR;
    public static byte LF_FIFO;
    public static byte LF_CONTIG;
    public static byte LF_GHDR;
    public static byte LF_XHDR;
    public static byte LF_ACL;
    public static byte LF_GNU_DUMPDIR;
    public static byte LF_EXTATTR;
    public static byte LF_META;
    public static byte LF_GNU_LONGLINK;
    public static byte LF_GNU_LONGNAME;
    public static byte LF_GNU_MULTIVOL;
    public static byte LF_GNU_NAMES;
    public static byte LF_GNU_SPARSE;
    public static byte LF_GNU_VOLHDR;
    public static string TMAGIC;
    public static string GNU_TMAGIC;
    private static long timeConversionFactor;
    private static DateTime dateTime1970;
    private string name;
    private int mode;
    private int userId;
    private int groupId;
    private long size;
    private DateTime modTime;
    private int checksum;
    private bool isChecksumValid;
    private byte typeFlag;
    private string linkName;
    private string magic;
    private string version;
    private string userName;
    private string groupName;
    private int devMajor;
    private int devMinor;
    internal static int userIdAsSet;
    internal static int groupIdAsSet;
    internal static string userNameAsSet;
    internal static string groupNameAsSet;
    internal static int defaultUserId;
    internal static int defaultGroupId;
    internal static string defaultGroupName;
    internal static string defaultUser;
    public string Name { get; public set; }
    public int Mode { get; public set; }
    public int UserId { get; public set; }
    public int GroupId { get; public set; }
    public long Size { get; public set; }
    public DateTime ModTime { get; public set; }
    public int Checksum { get; }
    public bool IsChecksumValid { get; }
    public byte TypeFlag { get; public set; }
    public string LinkName { get; public set; }
    public string Magic { get; public set; }
    public string Version { get; public set; }
    public string UserName { get; public set; }
    public string GroupName { get; public set; }
    public int DevMajor { get; public set; }
    public int DevMinor { get; public set; }
    private static TarHeader();
    public string get_Name();
    public void set_Name(string value);
    [ObsoleteAttribute("Use the Name property instead", "True")]
public string GetName();
    public int get_Mode();
    public void set_Mode(int value);
    public int get_UserId();
    public void set_UserId(int value);
    public int get_GroupId();
    public void set_GroupId(int value);
    public long get_Size();
    public void set_Size(long value);
    public DateTime get_ModTime();
    public void set_ModTime(DateTime value);
    public int get_Checksum();
    public bool get_IsChecksumValid();
    public byte get_TypeFlag();
    public void set_TypeFlag(byte value);
    public string get_LinkName();
    public void set_LinkName(string value);
    public string get_Magic();
    public void set_Magic(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_GroupName();
    public void set_GroupName(string value);
    public int get_DevMajor();
    public void set_DevMajor(int value);
    public int get_DevMinor();
    public void set_DevMinor(int value);
    public object Clone();
    public void ParseBuffer(Byte[] header, Encoding nameEncoding);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public void ParseBuffer(Byte[] header);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public void WriteHeader(Byte[] outBuffer);
    public void WriteHeader(Byte[] outBuffer, Encoding nameEncoding);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal static void SetValueDefaults(int userId, string userName, int groupId, string groupName);
    internal static void RestoreSetValues();
    private static long ParseBinaryOrOctal(Byte[] header, int offset, int length);
    public static long ParseOctal(Byte[] header, int offset, int length);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public static string ParseName(Byte[] header, int offset, int length);
    public static string ParseName(ReadOnlySpan`1<byte> header, Encoding encoding);
    public static int GetNameBytes(StringBuilder name, int nameOffset, Byte[] buffer, int bufferOffset, int length);
    public static int GetNameBytes(string name, int nameOffset, Byte[] buffer, int bufferOffset, int length);
    public static int GetNameBytes(string name, int nameOffset, Byte[] buffer, int bufferOffset, int length, Encoding encoding);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public static int GetNameBytes(StringBuilder name, Byte[] buffer, int offset, int length);
    public static int GetNameBytes(StringBuilder name, Byte[] buffer, int offset, int length, Encoding encoding);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public static int GetNameBytes(string name, Byte[] buffer, int offset, int length);
    public static int GetNameBytes(string name, Byte[] buffer, int offset, int length, Encoding encoding);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public static int GetAsciiBytes(string toAdd, int nameOffset, Byte[] buffer, int bufferOffset, int length);
    public static int GetAsciiBytes(string toAdd, int nameOffset, Byte[] buffer, int bufferOffset, int length, Encoding encoding);
    public static int GetOctalBytes(long value, Byte[] buffer, int offset, int length);
    private static int GetBinaryOrOctalBytes(long value, Byte[] buffer, int offset, int length);
    private static void GetCheckSumOctalBytes(long value, Byte[] buffer, int offset, int length);
    private static int ComputeCheckSum(Byte[] buffer);
    private static int MakeCheckSum(Byte[] buffer);
    private static int GetCTime(DateTime dateTime);
    private static DateTime GetDateTimeFromCTime(long ticks);
}
internal class ICSharpCode.SharpZipLib.Tar.TarInputStream : Stream {
    protected bool hasHitEOF;
    protected long entrySize;
    protected long entryOffset;
    protected IMemoryOwner`1<byte> readBuffer;
    protected TarBuffer tarBuffer;
    private TarEntry currentEntry;
    protected IEntryFactory entryFactory;
    private Stream inputStream;
    private Encoding encoding;
    public bool IsStreamOwner { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int RecordSize { get; }
    public long Available { get; }
    public bool IsMarkSupported { get; }
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public TarInputStream(Stream inputStream);
    public TarInputStream(Stream inputStream, Encoding nameEncoding);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public TarInputStream(Stream inputStream, int blockFactor);
    public TarInputStream(Stream inputStream, int blockFactor, Encoding nameEncoding);
    public bool get_IsStreamOwner();
    public void set_IsStreamOwner(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarInputStream/<FlushAsync>d__19")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual int ReadByte();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarInputStream/<ReadAsync>d__27")]
private ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken ct, bool isAsync);
    protected virtual void Dispose(bool disposing);
    public void SetEntryFactory(IEntryFactory factory);
    public int get_RecordSize();
    [ObsoleteAttribute("Use RecordSize property instead")]
public int GetRecordSize();
    public long get_Available();
    private Task SkipAsync(long skipCount, CancellationToken ct);
    private void Skip(long skipCount);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarInputStream/<SkipAsync>d__37")]
private ValueTask SkipAsync(long skipCount, CancellationToken ct, bool isAsync);
    public bool get_IsMarkSupported();
    public void Mark(int markLimit);
    public void Reset();
    public Task`1<TarEntry> GetNextEntryAsync(CancellationToken ct);
    public TarEntry GetNextEntry();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarInputStream/<GetNextEntryAsync>d__44")]
private ValueTask`1<TarEntry> GetNextEntryAsync(CancellationToken ct, bool isAsync);
    public Task CopyEntryContentsAsync(Stream outputStream, CancellationToken ct);
    public void CopyEntryContents(Stream outputStream);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarInputStream/<CopyEntryContentsAsync>d__47")]
private ValueTask CopyEntryContentsAsync(Stream outputStream, CancellationToken ct, bool isAsync);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarInputStream/<SkipToNextEntryAsync>d__48")]
private ValueTask SkipToNextEntryAsync(CancellationToken ct, bool isAsync);
}
internal class ICSharpCode.SharpZipLib.Tar.TarOutputStream : Stream {
    private long currBytes;
    private int assemblyBufferLength;
    private bool isClosed;
    protected long currSize;
    protected Byte[] blockBuffer;
    protected Byte[] assemblyBuffer;
    protected TarBuffer buffer;
    protected Stream outputStream;
    protected Encoding nameEncoding;
    public bool IsStreamOwner { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int RecordSize { get; }
    private bool IsEntryOpen { get; }
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public TarOutputStream(Stream outputStream);
    public TarOutputStream(Stream outputStream, Encoding nameEncoding);
    [ObsoleteAttribute("No Encoding for Name field is specified, any non-ASCII bytes will be discarded")]
public TarOutputStream(Stream outputStream, int blockFactor);
    public TarOutputStream(Stream outputStream, int blockFactor, Encoding nameEncoding);
    public bool get_IsStreamOwner();
    public void set_IsStreamOwner(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarOutputStream/<ReadAsync>d__22")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarOutputStream/<FlushAsync>d__24")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public void Finish();
    public Task FinishAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarOutputStream/<FinishAsync>d__27")]
private Task FinishAsync(CancellationToken cancellationToken, bool isAsync);
    protected virtual void Dispose(bool disposing);
    public int get_RecordSize();
    [ObsoleteAttribute("Use RecordSize property instead")]
public int GetRecordSize();
    private bool get_IsEntryOpen();
    public Task PutNextEntryAsync(TarEntry entry, CancellationToken cancellationToken);
    public void PutNextEntry(TarEntry entry);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarOutputStream/<PutNextEntryAsync>d__36")]
private Task PutNextEntryAsync(TarEntry entry, CancellationToken cancellationToken, bool isAsync);
    public Task CloseEntryAsync(CancellationToken cancellationToken);
    public void CloseEntry();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarOutputStream/<CloseEntryAsync>d__39")]
private Task CloseEntryAsync(CancellationToken cancellationToken, bool isAsync);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarOutputStream/<WriteAsync>d__43")]
private Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, bool isAsync);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Tar.TarOutputStream/<WriteEofBlockAsync>d__44")]
private Task WriteEofBlockAsync(CancellationToken cancellationToken, bool isAsync);
}
[ExtensionAttribute]
internal static class ICSharpCode.SharpZipLib.Tar.TarStringExtension : object {
    [ExtensionAttribute]
public static string ToTarArchivePath(string s);
}
internal class ICSharpCode.SharpZipLib.UnexpectedEndOfStreamException : StreamDecodingException {
    private static string GenericMessage;
    public UnexpectedEndOfStreamException(string message);
    public UnexpectedEndOfStreamException(string message, Exception innerException);
    protected UnexpectedEndOfStreamException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.ValueOutOfRangeException : StreamDecodingException {
    public ValueOutOfRangeException(string nameOfValue);
    public ValueOutOfRangeException(string nameOfValue, long value, long maxValue, long minValue);
    public ValueOutOfRangeException(string nameOfValue, string value, string maxValue, string minValue);
    private ValueOutOfRangeException(string message, Exception innerException);
    protected ValueOutOfRangeException(SerializationInfo info, StreamingContext context);
}
internal abstract class ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage : object {
    private FileUpdateMode updateMode_;
    public FileUpdateMode UpdateMode { get; }
    protected BaseArchiveStorage(FileUpdateMode updateMode);
    public abstract virtual Stream GetTemporaryOutput();
    public abstract virtual Stream ConvertTemporaryToFinal();
    public abstract virtual Stream MakeTemporaryCopy(Stream stream);
    public abstract virtual Stream OpenForDirectUpdate(Stream stream);
    public abstract virtual void Dispose();
    public sealed virtual FileUpdateMode get_UpdateMode();
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.Deflater : object {
    public static int BEST_COMPRESSION;
    public static int BEST_SPEED;
    public static int DEFAULT_COMPRESSION;
    public static int NO_COMPRESSION;
    public static int DEFLATED;
    private static int IS_SETDICT;
    private static int IS_FLUSHING;
    private static int IS_FINISHING;
    private static int INIT_STATE;
    private static int SETDICT_STATE;
    private static int BUSY_STATE;
    private static int FLUSHING_STATE;
    private static int FINISHING_STATE;
    private static int FINISHED_STATE;
    private static int CLOSED_STATE;
    private int level;
    private bool noZlibHeaderOrFooter;
    private int state;
    private long totalOut;
    private DeflaterPending pending;
    private DeflaterEngine engine;
    public int Adler { get; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool IsFinished { get; }
    public bool IsNeedingInput { get; }
    public Deflater(int level);
    public Deflater(int level, bool noZlibHeaderOrFooter);
    public void Reset();
    public int get_Adler();
    public long get_TotalIn();
    public long get_TotalOut();
    public void Flush();
    public void Finish();
    public bool get_IsFinished();
    public bool get_IsNeedingInput();
    public void SetInput(Byte[] input);
    public void SetInput(Byte[] input, int offset, int count);
    public void SetLevel(int level);
    public int GetLevel();
    public void SetStrategy(DeflateStrategy strategy);
    public int Deflate(Byte[] output);
    public int Deflate(Byte[] output, int offset, int length);
    public void SetDictionary(Byte[] dictionary);
    public void SetDictionary(Byte[] dictionary, int index, int count);
}
internal static class ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants : object {
    public static bool DEBUGGING;
    public static int STORED_BLOCK;
    public static int STATIC_TREES;
    public static int DYN_TREES;
    public static int PRESET_DICT;
    public static int DEFAULT_MEM_LEVEL;
    public static int MAX_MATCH;
    public static int MIN_MATCH;
    public static int MAX_WBITS;
    public static int WSIZE;
    public static int WMASK;
    public static int HASH_BITS;
    public static int HASH_SIZE;
    public static int HASH_MASK;
    public static int HASH_SHIFT;
    public static int MIN_LOOKAHEAD;
    public static int MAX_DIST;
    public static int PENDING_BUF_SIZE;
    public static int MAX_BLOCK_SIZE;
    public static int DEFLATE_STORED;
    public static int DEFLATE_FAST;
    public static int DEFLATE_SLOW;
    public static Int32[] GOOD_LENGTH;
    public static Int32[] MAX_LAZY;
    public static Int32[] NICE_LENGTH;
    public static Int32[] MAX_CHAIN;
    public static Int32[] COMPR_FUNC;
    private static DeflaterConstants();
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine : object {
    private static int TooFar;
    private int ins_h;
    private Int16[] head;
    private Int16[] prev;
    private int matchStart;
    private int matchLen;
    private bool prevAvailable;
    private int blockStart;
    private int strstart;
    private int lookahead;
    private Byte[] window;
    private DeflateStrategy strategy;
    private int max_chain;
    private int max_lazy;
    private int niceLength;
    private int goodLength;
    private int compressionFunction;
    private Byte[] inputBuf;
    private long totalIn;
    private int inputOff;
    private int inputEnd;
    private DeflaterPending pending;
    private DeflaterHuffman huffman;
    private Adler32 adler;
    public int Adler { get; }
    public long TotalIn { get; }
    public DeflateStrategy Strategy { get; public set; }
    public DeflaterEngine(DeflaterPending pending);
    public DeflaterEngine(DeflaterPending pending, bool noAdlerCalculation);
    public bool Deflate(bool flush, bool finish);
    public void SetInput(Byte[] buffer, int offset, int count);
    public bool NeedsInput();
    public void SetDictionary(Byte[] buffer, int offset, int length);
    public void Reset();
    public void ResetAdler();
    public int get_Adler();
    public long get_TotalIn();
    public DeflateStrategy get_Strategy();
    public void set_Strategy(DeflateStrategy value);
    public void SetLevel(int level);
    public void FillWindow();
    private void UpdateHash();
    private int InsertString();
    private void SlideWindow();
    private bool FindLongestMatch(int curMatch);
    private bool DeflateStored(bool flush, bool finish);
    private bool DeflateFast(bool flush, bool finish);
    private bool DeflateSlow(bool flush, bool finish);
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman : object {
    private static int BUFSIZE;
    private static int LITERAL_NUM;
    private static int DIST_NUM;
    private static int BITLEN_NUM;
    private static int REP_3_6;
    private static int REP_3_10;
    private static int REP_11_138;
    private static int EOF_SYMBOL;
    private static Int32[] BL_ORDER;
    private static Byte[] bit4Reverse;
    private static Int16[] staticLCodes;
    private static Byte[] staticLLength;
    private static Int16[] staticDCodes;
    private static Byte[] staticDLength;
    public DeflaterPending pending;
    private Tree literalTree;
    private Tree distTree;
    private Tree blTree;
    private Int16[] d_buf;
    private Byte[] l_buf;
    private int last_lit;
    private int extra_bits;
    private static DeflaterHuffman();
    public DeflaterHuffman(DeflaterPending pending);
    public void Reset();
    public void SendAllTrees(int blTreeCodes);
    public void CompressBlock();
    public void FlushStoredBlock(Byte[] stored, int storedOffset, int storedLength, bool lastBlock);
    public void FlushBlock(Byte[] stored, int storedOffset, int storedLength, bool lastBlock);
    public bool IsFull();
    public bool TallyLit(int literal);
    public bool TallyDist(int distance, int length);
    public static short BitReverse(int toReverse);
    private static int Lcode(int length);
    private static int Dcode(int distance);
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending : PendingBuffer {
}
internal enum ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy : Enum {
    public int value__;
    public static DeflateStrategy Default;
    public static DeflateStrategy Filtered;
    public static DeflateStrategy HuffmanOnly;
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.Inflater : object {
    private static Int32[] CPLENS;
    private static Int32[] CPLEXT;
    private static Int32[] CPDIST;
    private static Int32[] CPDEXT;
    private static int DECODE_HEADER;
    private static int DECODE_DICT;
    private static int DECODE_BLOCKS;
    private static int DECODE_STORED_LEN1;
    private static int DECODE_STORED_LEN2;
    private static int DECODE_STORED;
    private static int DECODE_DYN_HEADER;
    private static int DECODE_HUFFMAN;
    private static int DECODE_HUFFMAN_LENBITS;
    private static int DECODE_HUFFMAN_DIST;
    private static int DECODE_HUFFMAN_DISTBITS;
    private static int DECODE_CHKSUM;
    private static int FINISHED;
    private int mode;
    private int readAdler;
    private int neededBits;
    private int repLength;
    private int repDist;
    private int uncomprLen;
    private bool isLastBlock;
    private long totalOut;
    private long totalIn;
    private bool noHeader;
    private StreamManipulator input;
    private OutputWindow outputWindow;
    private InflaterDynHeader dynHeader;
    private InflaterHuffmanTree litlenTree;
    private InflaterHuffmanTree distTree;
    private Adler32 adler;
    public bool IsNeedingInput { get; }
    public bool IsNeedingDictionary { get; }
    public bool IsFinished { get; }
    public int Adler { get; }
    public long TotalOut { get; }
    public long TotalIn { get; }
    public int RemainingInput { get; }
    public Inflater(bool noHeader);
    private static Inflater();
    public void Reset();
    private bool DecodeHeader();
    private bool DecodeDict();
    private bool DecodeHuffman();
    private bool DecodeChksum();
    private bool Decode();
    public void SetDictionary(Byte[] buffer);
    public void SetDictionary(Byte[] buffer, int index, int count);
    public void SetInput(Byte[] buffer);
    public void SetInput(Byte[] buffer, int index, int count);
    public int Inflate(Byte[] buffer);
    public int Inflate(Byte[] buffer, int offset, int count);
    public bool get_IsNeedingInput();
    public bool get_IsNeedingDictionary();
    public bool get_IsFinished();
    public int get_Adler();
    public long get_TotalOut();
    public long get_TotalIn();
    public int get_RemainingInput();
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.InflaterDynHeader : object {
    private static int LITLEN_MAX;
    private static int DIST_MAX;
    private static int CODELEN_MAX;
    private static int META_MAX;
    private static Int32[] MetaCodeLengthIndex;
    private StreamManipulator input;
    private IEnumerator`1<bool> state;
    private IEnumerable`1<bool> stateMachine;
    private Byte[] codeLengths;
    private InflaterHuffmanTree litLenTree;
    private InflaterHuffmanTree distTree;
    private int litLenCodeCount;
    private int distanceCodeCount;
    private int metaCodeCount;
    public InflaterHuffmanTree LiteralLengthTree { get; }
    public InflaterHuffmanTree DistanceTree { get; }
    public InflaterDynHeader(StreamManipulator input);
    private static InflaterDynHeader();
    public bool AttemptRead();
    [IteratorStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.Compression.InflaterDynHeader/<CreateStateMachine>d__7")]
private IEnumerable`1<bool> CreateStateMachine();
    public InflaterHuffmanTree get_LiteralLengthTree();
    public InflaterHuffmanTree get_DistanceTree();
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree : object {
    private static int MAX_BITLEN;
    private Int16[] tree;
    public static InflaterHuffmanTree defLitLenTree;
    public static InflaterHuffmanTree defDistTree;
    private static InflaterHuffmanTree();
    public InflaterHuffmanTree(IList`1<byte> codeLengths);
    private void BuildTree(IList`1<byte> codeLengths);
    public int GetSymbol(StreamManipulator input);
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer : object {
    private Byte[] buffer;
    private int start;
    private int end;
    private UInt32 bits;
    private int bitCount;
    public int BitCount { get; }
    public bool IsFlushed { get; }
    public PendingBuffer(int bufferSize);
    public void Reset();
    public void WriteByte(int value);
    public void WriteShort(int value);
    public void WriteInt(int value);
    public void WriteBlock(Byte[] block, int offset, int length);
    public int get_BitCount();
    public void AlignToByte();
    public void WriteBits(int b, int count);
    public void WriteShortMSB(int s);
    public bool get_IsFlushed();
    public int Flush(Byte[] output, int offset, int length);
    public Byte[] ToByteArray();
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream : Stream {
    [CompilerGeneratedAttribute]
private bool <IsStreamOwner>k__BackingField;
    protected ICryptoTransform cryptoTransform_;
    protected Byte[] AESAuthCode;
    private Byte[] buffer_;
    protected Deflater deflater_;
    protected Stream baseOutputStream_;
    private bool isClosed_;
    protected StringCodec _stringCodec;
    public bool IsStreamOwner { get; public set; }
    public bool CanPatchEntries { get; }
    public Encoding ZipCryptoEncoding { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DeflaterOutputStream(Stream baseOutputStream);
    public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater);
    public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater, int bufferSize);
    public virtual void Finish();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream/<FinishAsync>d__4")]
public virtual Task FinishAsync(CancellationToken ct);
    [CompilerGeneratedAttribute]
public bool get_IsStreamOwner();
    [CompilerGeneratedAttribute]
public void set_IsStreamOwner(bool value);
    public bool get_CanPatchEntries();
    public Encoding get_ZipCryptoEncoding();
    public void set_ZipCryptoEncoding(Encoding value);
    protected void EncryptBlock(Byte[] buffer, int offset, int length);
    protected void Deflate();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream/<DeflateSyncOrAsync>d__18")]
private Task DeflateSyncOrAsync(bool flushing, Nullable`1<CancellationToken> ct);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream/<FlushAsync>d__35")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    protected void GetAuthCodeIfAES();
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream/<WriteAsync>d__40")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken ct);
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer : object {
    private int rawLength;
    private Byte[] rawData;
    private int clearTextLength;
    private Byte[] clearText;
    private Byte[] internalClearText;
    private int available;
    private ICryptoTransform cryptoTransform;
    private Stream inputStream;
    public int RawLength { get; }
    public Byte[] RawData { get; }
    public int ClearTextLength { get; }
    public Byte[] ClearText { get; }
    public int Available { get; public set; }
    unknown ICryptoTransform CryptoTransform {public set; }
    public InflaterInputBuffer(Stream stream);
    public InflaterInputBuffer(Stream stream, int bufferSize);
    public int get_RawLength();
    public Byte[] get_RawData();
    public int get_ClearTextLength();
    public Byte[] get_ClearText();
    public int get_Available();
    public void set_Available(int value);
    public void SetInflaterInput(Inflater inflater);
    public void Fill();
    public int ReadRawBuffer(Byte[] buffer);
    public int ReadRawBuffer(Byte[] outBuffer, int offset, int length);
    public int ReadClearTextBuffer(Byte[] outBuffer, int offset, int length);
    public byte ReadLeByte();
    public int ReadLeShort();
    public int ReadLeInt();
    public long ReadLeLong();
    public void set_CryptoTransform(ICryptoTransform value);
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream : Stream {
    [CompilerGeneratedAttribute]
private bool <IsStreamOwner>k__BackingField;
    protected Inflater inf;
    protected InflaterInputBuffer inputBuffer;
    private Stream baseInputStream;
    protected long csize;
    private bool isClosed;
    public bool IsStreamOwner { get; public set; }
    public int Available { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public InflaterInputStream(Stream baseInputStream);
    public InflaterInputStream(Stream baseInputStream, Inflater inf);
    public InflaterInputStream(Stream baseInputStream, Inflater inflater, int bufferSize);
    [CompilerGeneratedAttribute]
public bool get_IsStreamOwner();
    [CompilerGeneratedAttribute]
public void set_IsStreamOwner(bool value);
    public long Skip(long count);
    protected void StopDecrypting();
    public virtual int get_Available();
    protected void Fill();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow : object {
    private static int WindowSize;
    private static int WindowMask;
    private Byte[] window;
    private int windowEnd;
    private int windowFilled;
    public void Write(int value);
    private void SlowRepeat(int repStart, int length, int distance);
    public void Repeat(int length, int distance);
    public int CopyStored(StreamManipulator input, int length);
    public void CopyDict(Byte[] dictionary, int offset, int length);
    public int GetFreeSpace();
    public int GetAvailable();
    public int CopyOutput(Byte[] output, int offset, int len);
    public void Reset();
}
internal class ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator : object {
    private Byte[] window_;
    private int windowStart_;
    private int windowEnd_;
    private UInt32 buffer_;
    private int bitsInBuffer_;
    public int AvailableBits { get; }
    public int AvailableBytes { get; }
    public bool IsNeedingInput { get; }
    public int PeekBits(int bitCount);
    public bool TryGetBits(int bitCount, Int32& output, int outputOffset);
    public bool TryGetBits(int bitCount, Byte[]& array, int index);
    public void DropBits(int bitCount);
    public int GetBits(int bitCount);
    public int get_AvailableBits();
    public int get_AvailableBytes();
    public void SkipToByteBoundary();
    public bool get_IsNeedingInput();
    public int CopyBytes(Byte[] output, int offset, int length);
    public void Reset();
    public void SetInput(Byte[] buffer, int offset, int count);
}
internal enum ICSharpCode.SharpZipLib.Zip.CompressionMethod : Enum {
    public int value__;
    public static CompressionMethod Stored;
    public static CompressionMethod Deflated;
    public static CompressionMethod Deflate64;
    public static CompressionMethod BZip2;
    public static CompressionMethod LZMA;
    public static CompressionMethod PPMd;
    public static CompressionMethod WinZipAES;
}
internal class ICSharpCode.SharpZipLib.Zip.DescriptorData : object {
    private long _crc;
    [CompilerGeneratedAttribute]
private long <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    public long CompressedSize { get; public set; }
    public long Size { get; public set; }
    public long Crc { get; public set; }
    [CompilerGeneratedAttribute]
public long get_CompressedSize();
    [CompilerGeneratedAttribute]
public void set_CompressedSize(long value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
    public long get_Crc();
    public void set_Crc(long value);
}
internal class ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage : BaseArchiveStorage {
    private Stream temporaryStream_;
    private string fileName_;
    private string temporaryName_;
    public DiskArchiveStorage(ZipFile file, FileUpdateMode updateMode);
    public DiskArchiveStorage(ZipFile file);
    public virtual Stream GetTemporaryOutput();
    public virtual Stream ConvertTemporaryToFinal();
    public virtual Stream MakeTemporaryCopy(Stream stream);
    public virtual Stream OpenForDirectUpdate(Stream stream);
    public virtual void Dispose();
}
internal class ICSharpCode.SharpZipLib.Zip.DynamicDiskDataSource : object {
    public sealed virtual Stream GetSource(ZipEntry entry, string name);
}
[ExtensionAttribute]
internal static class ICSharpCode.SharpZipLib.Zip.EncodingExtensions : object {
    [ExtensionAttribute]
public static bool IsZipUnicode(Encoding e);
}
internal enum ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm None;
    public static EncryptionAlgorithm PkzipClassic;
    public static EncryptionAlgorithm Des;
    public static EncryptionAlgorithm RC2;
    public static EncryptionAlgorithm TripleDes168;
    public static EncryptionAlgorithm TripleDes112;
    public static EncryptionAlgorithm Aes128;
    public static EncryptionAlgorithm Aes192;
    public static EncryptionAlgorithm Aes256;
    public static EncryptionAlgorithm RC2Corrected;
    public static EncryptionAlgorithm Blowfish;
    public static EncryptionAlgorithm Twofish;
    public static EncryptionAlgorithm RC4;
    public static EncryptionAlgorithm Unknown;
}
internal class ICSharpCode.SharpZipLib.Zip.EntryPatchData : ValueType {
    [CompilerGeneratedAttribute]
private long <SizePatchOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CrcPatchOffset>k__BackingField;
    public long SizePatchOffset { get; public set; }
    public long CrcPatchOffset { get; public set; }
    [CompilerGeneratedAttribute]
public long get_SizePatchOffset();
    [CompilerGeneratedAttribute]
public void set_SizePatchOffset(long value);
    [CompilerGeneratedAttribute]
public long get_CrcPatchOffset();
    [CompilerGeneratedAttribute]
public void set_CrcPatchOffset(long value);
}
internal class ICSharpCode.SharpZipLib.Zip.ExtendedUnixData : object {
    private Flags _flags;
    private DateTime _modificationTime;
    private DateTime _lastAccessTime;
    private DateTime _createTime;
    public ushort TagID { get; }
    public DateTime ModificationTime { get; public set; }
    public DateTime AccessTime { get; public set; }
    public DateTime CreateTime { get; public set; }
    public Flags Include { get; public set; }
    public sealed virtual ushort get_TagID();
    public sealed virtual void SetData(Byte[] data, int index, int count);
    public sealed virtual Byte[] GetData();
    public static bool IsValidValue(DateTime value);
    public DateTime get_ModificationTime();
    public void set_ModificationTime(DateTime value);
    public DateTime get_AccessTime();
    public void set_AccessTime(DateTime value);
    public DateTime get_CreateTime();
    public void set_CreateTime(DateTime value);
    public Flags get_Include();
    public void set_Include(Flags value);
}
internal class ICSharpCode.SharpZipLib.Zip.FastZip : object {
    [CompilerGeneratedAttribute]
private ZipEncryptionMethod <EntryEncryptionMethod>k__BackingField;
    private bool continueRunning_;
    private Byte[] buffer_;
    private ZipOutputStream outputStream_;
    private ZipFile zipFile_;
    private string sourceDirectory_;
    private NameFilter fileFilter_;
    private NameFilter directoryFilter_;
    private Overwrite overwrite_;
    private ConfirmOverwriteDelegate confirmDelegate_;
    private bool restoreDateTimeOnExtract_;
    private bool restoreAttributesOnExtract_;
    private bool createEmptyDirectories_;
    private FastZipEvents events_;
    private IEntryFactory entryFactory_;
    private INameTransform extractNameTransform_;
    private UseZip64 useZip64_;
    private CompressionLevel compressionLevel_;
    private StringCodec _stringCodec;
    private string password_;
    public bool CreateEmptyDirectories { get; public set; }
    public string Password { get; public set; }
    public ZipEncryptionMethod EntryEncryptionMethod { get; public set; }
    public INameTransform NameTransform { get; public set; }
    public IEntryFactory EntryFactory { get; public set; }
    public UseZip64 UseZip64 { get; public set; }
    public bool RestoreDateTimeOnExtract { get; public set; }
    public bool RestoreAttributesOnExtract { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public bool UseUnicode { get; public set; }
    public int LegacyCodePage { get; public set; }
    public StringCodec StringCodec { get; public set; }
    public FastZip(TimeSetting timeSetting);
    public FastZip(DateTime time);
    public FastZip(FastZipEvents events);
    public bool get_CreateEmptyDirectories();
    public void set_CreateEmptyDirectories(bool value);
    public string get_Password();
    public void set_Password(string value);
    [CompilerGeneratedAttribute]
public ZipEncryptionMethod get_EntryEncryptionMethod();
    [CompilerGeneratedAttribute]
public void set_EntryEncryptionMethod(ZipEncryptionMethod value);
    public INameTransform get_NameTransform();
    public void set_NameTransform(INameTransform value);
    public IEntryFactory get_EntryFactory();
    public void set_EntryFactory(IEntryFactory value);
    public UseZip64 get_UseZip64();
    public void set_UseZip64(UseZip64 value);
    public bool get_RestoreDateTimeOnExtract();
    public void set_RestoreDateTimeOnExtract(bool value);
    public bool get_RestoreAttributesOnExtract();
    public void set_RestoreAttributesOnExtract(bool value);
    public CompressionLevel get_CompressionLevel();
    public void set_CompressionLevel(CompressionLevel value);
    public bool get_UseUnicode();
    public void set_UseUnicode(bool value);
    public int get_LegacyCodePage();
    public void set_LegacyCodePage(int value);
    public StringCodec get_StringCodec();
    public void set_StringCodec(StringCodec value);
    public void CreateZip(string zipFileName, string sourceDirectory, bool recurse, string fileFilter, string directoryFilter);
    public void CreateZip(string zipFileName, string sourceDirectory, bool recurse, string fileFilter);
    public void CreateZip(Stream outputStream, string sourceDirectory, bool recurse, string fileFilter, string directoryFilter);
    public void CreateZip(Stream outputStream, string sourceDirectory, bool recurse, string fileFilter, string directoryFilter, bool leaveOpen);
    public void CreateZip(string zipFileName, string sourceDirectory, bool recurse, IScanFilter fileFilter, IScanFilter directoryFilter);
    public void CreateZip(Stream outputStream, string sourceDirectory, bool recurse, IScanFilter fileFilter, IScanFilter directoryFilter, bool leaveOpen);
    private void CreateZip(Stream outputStream, string sourceDirectory, bool recurse, FileSystemScanner scanner, bool leaveOpen);
    public void ExtractZip(string zipFileName, string targetDirectory, string fileFilter);
    public void ExtractZip(string zipFileName, string targetDirectory, Overwrite overwrite, ConfirmOverwriteDelegate confirmDelegate, string fileFilter, string directoryFilter, bool restoreDateTime, bool allowParentTraversal);
    public void ExtractZip(Stream inputStream, string targetDirectory, Overwrite overwrite, ConfirmOverwriteDelegate confirmDelegate, string fileFilter, string directoryFilter, bool restoreDateTime, bool isStreamOwner, bool allowParentTraversal);
    private void ProcessDirectory(object sender, DirectoryEventArgs e);
    private void ProcessFile(object sender, ScanEventArgs e);
    private void ConfigureEntryEncryption(ZipEntry entry);
    private void AddFileContents(string name, Stream stream);
    private void ExtractFileEntry(ZipEntry entry, string targetName);
    private void ExtractEntry(ZipEntry entry);
    private static int MakeExternalAttributes(FileInfo info);
    private static bool NameIsValid(string name);
}
internal class ICSharpCode.SharpZipLib.Zip.FastZipEvents : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<DirectoryEventArgs> ProcessDirectory;
    public ProcessFileHandler ProcessFile;
    public ProgressHandler Progress;
    public CompletedFileHandler CompletedFile;
    public DirectoryFailureHandler DirectoryFailure;
    public FileFailureHandler FileFailure;
    private TimeSpan progressInterval_;
    public TimeSpan ProgressInterval { get; public set; }
    [CompilerGeneratedAttribute]
public void add_ProcessDirectory(EventHandler`1<DirectoryEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessDirectory(EventHandler`1<DirectoryEventArgs> value);
    public bool OnDirectoryFailure(string directory, Exception e);
    public bool OnFileFailure(string file, Exception e);
    public bool OnProcessFile(string file);
    public bool OnCompletedFile(string file);
    public bool OnProcessDirectory(string directory, bool hasMatchingFiles);
    public TimeSpan get_ProgressInterval();
    public void set_ProgressInterval(TimeSpan value);
}
internal enum ICSharpCode.SharpZipLib.Zip.FileUpdateMode : Enum {
    public int value__;
    public static FileUpdateMode Safe;
    public static FileUpdateMode Direct;
}
[FlagsAttribute]
internal enum ICSharpCode.SharpZipLib.Zip.GeneralBitFlags : Enum {
    public int value__;
    public static GeneralBitFlags Encrypted;
    public static GeneralBitFlags Method;
    public static GeneralBitFlags Descriptor;
    public static GeneralBitFlags ReservedPKware4;
    public static GeneralBitFlags Patched;
    public static GeneralBitFlags StrongEncryption;
    public static GeneralBitFlags Unused7;
    public static GeneralBitFlags Unused8;
    public static GeneralBitFlags Unused9;
    public static GeneralBitFlags Unused10;
    public static GeneralBitFlags UnicodeText;
    public static GeneralBitFlags EnhancedCompress;
    public static GeneralBitFlags HeaderMasked;
    public static GeneralBitFlags ReservedPkware14;
    public static GeneralBitFlags ReservedPkware15;
}
[ExtensionAttribute]
internal static class ICSharpCode.SharpZipLib.Zip.GeneralBitFlagsExtensions : object {
    [ExtensionAttribute]
public static bool Includes(GeneralBitFlags flagData, GeneralBitFlags flag);
}
[ExtensionAttribute]
internal static class ICSharpCode.SharpZipLib.Zip.GenericBitFlagsExtensions : object {
    [ExtensionAttribute]
public static bool HasAny(GeneralBitFlags target, GeneralBitFlags flags);
    [ExtensionAttribute]
public static bool HasAll(GeneralBitFlags target, GeneralBitFlags flags);
}
internal enum ICSharpCode.SharpZipLib.Zip.HostSystemID : Enum {
    public int value__;
    public static HostSystemID Msdos;
    public static HostSystemID Amiga;
    public static HostSystemID OpenVms;
    public static HostSystemID Unix;
    public static HostSystemID VMCms;
    public static HostSystemID AtariST;
    public static HostSystemID OS2;
    public static HostSystemID Macintosh;
    public static HostSystemID ZSystem;
    public static HostSystemID Cpm;
    public static HostSystemID WindowsNT;
    public static HostSystemID MVS;
    public static HostSystemID Vse;
    public static HostSystemID AcornRisc;
    public static HostSystemID Vfat;
    public static HostSystemID AlternateMvs;
    public static HostSystemID BeOS;
    public static HostSystemID Tandem;
    public static HostSystemID OS400;
    public static HostSystemID OSX;
    public static HostSystemID WinZipAES;
}
internal interface ICSharpCode.SharpZipLib.Zip.IArchiveStorage {
    public FileUpdateMode UpdateMode { get; }
    public abstract virtual FileUpdateMode get_UpdateMode();
    public abstract virtual Stream GetTemporaryOutput();
    public abstract virtual Stream ConvertTemporaryToFinal();
    public abstract virtual Stream MakeTemporaryCopy(Stream stream);
    public abstract virtual Stream OpenForDirectUpdate(Stream stream);
    public abstract virtual void Dispose();
}
internal interface ICSharpCode.SharpZipLib.Zip.IDynamicDataSource {
    public abstract virtual Stream GetSource(ZipEntry entry, string name);
}
internal interface ICSharpCode.SharpZipLib.Zip.IEntryFactory {
    public INameTransform NameTransform { get; public set; }
    public TimeSetting Setting { get; }
    public DateTime FixedDateTime { get; }
    public abstract virtual ZipEntry MakeFileEntry(string fileName);
    public abstract virtual ZipEntry MakeFileEntry(string fileName, bool useFileSystem);
    public abstract virtual ZipEntry MakeFileEntry(string fileName, string entryName, bool useFileSystem);
    public abstract virtual ZipEntry MakeDirectoryEntry(string directoryName);
    public abstract virtual ZipEntry MakeDirectoryEntry(string directoryName, bool useFileSystem);
    public abstract virtual INameTransform get_NameTransform();
    public abstract virtual void set_NameTransform(INameTransform value);
    public abstract virtual TimeSetting get_Setting();
    public abstract virtual DateTime get_FixedDateTime();
}
internal interface ICSharpCode.SharpZipLib.Zip.IStaticDataSource {
    public abstract virtual Stream GetSource();
}
internal interface ICSharpCode.SharpZipLib.Zip.ITaggedData {
    public ushort TagID { get; }
    public abstract virtual ushort get_TagID();
    public abstract virtual void SetData(Byte[] data, int offset, int count);
    public abstract virtual Byte[] GetData();
}
internal interface ICSharpCode.SharpZipLib.Zip.ITaggedDataFactory {
    public abstract virtual ITaggedData Create(short tag, Byte[] data, int offset, int count);
}
internal class ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs : EventArgs {
    private string fileName;
    private Byte[] key;
    public string FileName { get; }
    public Byte[] Key { get; public set; }
    public KeysRequiredEventArgs(string name);
    public KeysRequiredEventArgs(string name, Byte[] keyValue);
    public string get_FileName();
    public Byte[] get_Key();
    public void set_Key(Byte[] value);
}
internal class ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage : BaseArchiveStorage {
    private MemoryStream temporaryStream_;
    private MemoryStream finalStream_;
    public MemoryStream FinalStream { get; }
    public MemoryArchiveStorage(FileUpdateMode updateMode);
    public MemoryStream get_FinalStream();
    public virtual Stream GetTemporaryOutput();
    public virtual Stream ConvertTemporaryToFinal();
    public virtual Stream MakeTemporaryCopy(Stream stream);
    public virtual Stream OpenForDirectUpdate(Stream stream);
    public virtual void Dispose();
}
internal class ICSharpCode.SharpZipLib.Zip.NTTaggedData : object {
    private DateTime _lastAccessTime;
    private DateTime _lastModificationTime;
    private DateTime _createTime;
    public ushort TagID { get; }
    public DateTime LastModificationTime { get; public set; }
    public DateTime CreateTime { get; public set; }
    public DateTime LastAccessTime { get; public set; }
    public sealed virtual ushort get_TagID();
    public sealed virtual void SetData(Byte[] data, int index, int count);
    public sealed virtual Byte[] GetData();
    public static bool IsValidValue(DateTime value);
    public DateTime get_LastModificationTime();
    public void set_LastModificationTime(DateTime value);
    public DateTime get_CreateTime();
    public void set_CreateTime(DateTime value);
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
}
internal class ICSharpCode.SharpZipLib.Zip.PathTransformer : object {
    public sealed virtual string TransformDirectory(string name);
    public sealed virtual string TransformFile(string name);
}
internal class ICSharpCode.SharpZipLib.Zip.RawTaggedData : object {
    private ushort _tag;
    private Byte[] _data;
    public ushort TagID { get; public set; }
    public Byte[] Data { get; public set; }
    public RawTaggedData(ushort tag);
    public sealed virtual ushort get_TagID();
    public void set_TagID(ushort value);
    public sealed virtual void SetData(Byte[] data, int offset, int count);
    public sealed virtual Byte[] GetData();
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
}
internal class ICSharpCode.SharpZipLib.Zip.StaticDiskDataSource : object {
    private string fileName_;
    public StaticDiskDataSource(string fileName);
    public sealed virtual Stream GetSource();
}
internal class ICSharpCode.SharpZipLib.Zip.StringCodec : object {
    [CompilerGeneratedAttribute]
private bool <ForceZipLegacyEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <LegacyEncoding>k__BackingField;
    public static Encoding UnicodeZipEncoding;
    public static int ZipSpecCodePage;
    [CompilerGeneratedAttribute]
private Encoding <ZipArchiveCommentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <ZipCryptoEncoding>k__BackingField;
    public static StringCodec Default { get; }
    public bool ForceZipLegacyEncoding { get; internal set; }
    public static Encoding DefaultZipCryptoEncoding { get; }
    public Encoding ZipOutputEncoding { get; }
    public Encoding LegacyEncoding { get; internal set; }
    public int CodePage { get; }
    public static int SystemDefaultCodePage { get; }
    public static Encoding SystemDefaultEncoding { get; }
    public Encoding ZipArchiveCommentEncoding { get; internal set; }
    public Encoding ZipCryptoEncoding { get; internal set; }
    internal StringCodec(bool forceLegacyEncoding, Encoding legacyEncoding);
    private static StringCodec();
    public static StringCodec get_Default();
    public static StringCodec FromCodePage(int codePage);
    public static StringCodec FromEncoding(Encoding encoding);
    public static StringCodec WithStrictSpecEncoding();
    [CompilerGeneratedAttribute]
public bool get_ForceZipLegacyEncoding();
    [CompilerGeneratedAttribute]
internal void set_ForceZipLegacyEncoding(bool value);
    public static Encoding get_DefaultZipCryptoEncoding();
    public Encoding get_ZipOutputEncoding();
    public Encoding ZipEncoding(bool unicode);
    public Encoding ZipInputEncoding(GeneralBitFlags flags);
    public Encoding ZipInputEncoding(int flags);
    [CompilerGeneratedAttribute]
public Encoding get_LegacyEncoding();
    [CompilerGeneratedAttribute]
internal void set_LegacyEncoding(Encoding value);
    public int get_CodePage();
    public static int get_SystemDefaultCodePage();
    public static Encoding get_SystemDefaultEncoding();
    [CompilerGeneratedAttribute]
public Encoding get_ZipArchiveCommentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ZipArchiveCommentEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_ZipCryptoEncoding();
    [CompilerGeneratedAttribute]
internal void set_ZipCryptoEncoding(Encoding value);
    public StringCodec WithZipArchiveCommentEncoding(Encoding commentEncoding);
    public StringCodec WithZipCryptoEncoding(Encoding cryptoEncoding);
    public StringCodec WithForcedLegacyEncoding();
}
internal enum ICSharpCode.SharpZipLib.Zip.TestOperation : Enum {
    public int value__;
    public static TestOperation Initialising;
    public static TestOperation EntryHeader;
    public static TestOperation EntryData;
    public static TestOperation EntryComplete;
    public static TestOperation MiscellaneousTests;
    public static TestOperation Complete;
}
internal class ICSharpCode.SharpZipLib.Zip.TestStatus : object {
    private ZipFile file_;
    private ZipEntry entry_;
    private bool entryValid_;
    private int errorCount_;
    private long bytesTested_;
    private TestOperation operation_;
    public TestOperation Operation { get; }
    public ZipFile File { get; }
    public ZipEntry Entry { get; }
    public int ErrorCount { get; }
    public long BytesTested { get; }
    public bool EntryValid { get; }
    public TestStatus(ZipFile file);
    public TestOperation get_Operation();
    public ZipFile get_File();
    public ZipEntry get_Entry();
    public int get_ErrorCount();
    public long get_BytesTested();
    public bool get_EntryValid();
    internal void AddError();
    internal void SetOperation(TestOperation operation);
    internal void SetEntry(ZipEntry entry);
    internal void SetBytesTested(long value);
}
internal enum ICSharpCode.SharpZipLib.Zip.TestStrategy : Enum {
    public int value__;
    public static TestStrategy FindFirstError;
    public static TestStrategy FindAllErrors;
}
internal enum ICSharpCode.SharpZipLib.Zip.UseZip64 : Enum {
    public int value__;
    public static UseZip64 Off;
    public static UseZip64 On;
    public static UseZip64 Dynamic;
}
internal class ICSharpCode.SharpZipLib.Zip.WindowsNameTransform : object {
    private static int MaxPath;
    private string _baseDirectory;
    private bool _trimIncomingPaths;
    private char _replacementChar;
    private bool _allowParentTraversal;
    private static Char[] InvalidEntryChars;
    public string BaseDirectory { get; public set; }
    public bool AllowParentTraversal { get; public set; }
    public bool TrimIncomingPaths { get; public set; }
    public char Replacement { get; public set; }
    public WindowsNameTransform(string baseDirectory, bool allowParentTraversal);
    private static WindowsNameTransform();
    public string get_BaseDirectory();
    public void set_BaseDirectory(string value);
    public bool get_AllowParentTraversal();
    public void set_AllowParentTraversal(bool value);
    public bool get_TrimIncomingPaths();
    public void set_TrimIncomingPaths(bool value);
    public sealed virtual string TransformDirectory(string name);
    public sealed virtual string TransformFile(string name);
    public static bool IsValidName(string name);
    public static string MakeValidName(string name, char replacement);
    public char get_Replacement();
    public void set_Replacement(char value);
}
internal static class ICSharpCode.SharpZipLib.Zip.ZipConstants : object {
    public static int VersionMadeBy;
    [ObsoleteAttribute("Use VersionMadeBy instead")]
public static int VERSION_MADE_BY;
    public static int VersionStrongEncryption;
    [ObsoleteAttribute("Use VersionStrongEncryption instead")]
public static int VERSION_STRONG_ENCRYPTION;
    public static int VERSION_AES;
    public static int VersionZip64;
    public static int VersionBZip2;
    public static int LocalHeaderBaseSize;
    [ObsoleteAttribute("Use LocalHeaderBaseSize instead")]
public static int LOCHDR;
    public static int Zip64DataDescriptorSize;
    public static int DataDescriptorSize;
    [ObsoleteAttribute("Use DataDescriptorSize instead")]
public static int EXTHDR;
    public static int CentralHeaderBaseSize;
    [ObsoleteAttribute("Use CentralHeaderBaseSize instead")]
public static int CENHDR;
    public static int EndOfCentralRecordBaseSize;
    [ObsoleteAttribute("Use EndOfCentralRecordBaseSize instead")]
public static int ENDHDR;
    public static int CryptoHeaderSize;
    [ObsoleteAttribute("Use CryptoHeaderSize instead")]
public static int CRYPTO_HEADER_SIZE;
    public static int Zip64EndOfCentralDirectoryLocatorSize;
    public static int LocalHeaderSignature;
    [ObsoleteAttribute("Use LocalHeaderSignature instead")]
public static int LOCSIG;
    public static int SpanningSignature;
    [ObsoleteAttribute("Use SpanningSignature instead")]
public static int SPANNINGSIG;
    public static int SpanningTempSignature;
    [ObsoleteAttribute("Use SpanningTempSignature instead")]
public static int SPANTEMPSIG;
    public static int DataDescriptorSignature;
    [ObsoleteAttribute("Use DataDescriptorSignature instead")]
public static int EXTSIG;
    [ObsoleteAttribute("Use CentralHeaderSignature instead")]
public static int CENSIG;
    public static int CentralHeaderSignature;
    public static int Zip64CentralFileHeaderSignature;
    [ObsoleteAttribute("Use Zip64CentralFileHeaderSignature instead")]
public static int CENSIG64;
    public static int Zip64CentralDirLocatorSignature;
    public static int ArchiveExtraDataSignature;
    public static int CentralHeaderDigitalSignature;
    [ObsoleteAttribute("Use CentralHeaderDigitalSignaure instead")]
public static int CENDIGITALSIG;
    public static int EndOfCentralDirectorySignature;
    [ObsoleteAttribute("Use EndOfCentralDirectorySignature instead")]
public static int ENDSIG;
}
internal enum ICSharpCode.SharpZipLib.Zip.ZipEncryptionMethod : Enum {
    public int value__;
    public static ZipEncryptionMethod None;
    public static ZipEncryptionMethod ZipCrypto;
    public static ZipEncryptionMethod AES128;
    public static ZipEncryptionMethod AES256;
}
internal class ICSharpCode.SharpZipLib.Zip.ZipEntry : object {
    private Known known;
    private int externalFileAttributes;
    private ushort versionMadeBy;
    private string name;
    private ulong size;
    private ulong compressedSize;
    private ushort versionToExtract;
    private UInt32 crc;
    private DateTime dateTime;
    private CompressionMethod method;
    private Byte[] extra;
    private string comment;
    private int flags;
    private long zipFileIndex;
    private long offset;
    private bool forceZip64_;
    private byte cryptoCheckValue_;
    private int _aesVer;
    private int _aesEncryptionStrength;
    public bool HasCrc { get; }
    public bool IsCrypted { get; public set; }
    public bool IsUnicodeText { get; public set; }
    internal byte CryptoCheckValue { get; internal set; }
    public int Flags { get; public set; }
    public long ZipFileIndex { get; public set; }
    public long Offset { get; public set; }
    public int ExternalFileAttributes { get; public set; }
    public int VersionMadeBy { get; }
    public bool IsDOSEntry { get; }
    public int HostSystem { get; public set; }
    public int Version { get; }
    public bool CanDecompress { get; }
    public bool LocalHeaderRequiresZip64 { get; }
    public bool CentralHeaderRequiresZip64 { get; }
    public long DosTime { get; public set; }
    public DateTime DateTime { get; public set; }
    public string Name { get; internal set; }
    public long Size { get; public set; }
    public long CompressedSize { get; public set; }
    public long Crc { get; public set; }
    public CompressionMethod CompressionMethod { get; public set; }
    internal CompressionMethod CompressionMethodForHeader { get; }
    public Byte[] ExtraData { get; public set; }
    public int AESKeySize { get; public set; }
    internal byte AESEncryptionStrength { get; }
    internal int AESSaltLen { get; }
    internal int AESOverheadSize { get; }
    internal int EncryptionOverheadSize { get; }
    public string Comment { get; public set; }
    public bool IsDirectory { get; }
    public bool IsFile { get; }
    public ZipEntry(string name);
    internal ZipEntry(string name, int versionRequiredToExtract);
    internal ZipEntry(string name, int versionRequiredToExtract, int madeByInfo, CompressionMethod method, bool unicode);
    [ObsoleteAttribute("Use Clone instead")]
public ZipEntry(ZipEntry entry);
    public bool get_HasCrc();
    public bool get_IsCrypted();
    public void set_IsCrypted(bool value);
    public bool get_IsUnicodeText();
    public void set_IsUnicodeText(bool value);
    internal byte get_CryptoCheckValue();
    internal void set_CryptoCheckValue(byte value);
    public int get_Flags();
    public void set_Flags(int value);
    public long get_ZipFileIndex();
    public void set_ZipFileIndex(long value);
    public long get_Offset();
    public void set_Offset(long value);
    public int get_ExternalFileAttributes();
    public void set_ExternalFileAttributes(int value);
    public int get_VersionMadeBy();
    public bool get_IsDOSEntry();
    private bool HasDosAttributes(int attributes);
    public int get_HostSystem();
    public void set_HostSystem(int value);
    public int get_Version();
    public bool get_CanDecompress();
    public void ForceZip64();
    public bool IsZip64Forced();
    public bool get_LocalHeaderRequiresZip64();
    public bool get_CentralHeaderRequiresZip64();
    public long get_DosTime();
    public void set_DosTime(long value);
    public DateTime get_DateTime();
    public void set_DateTime(DateTime value);
    public string get_Name();
    internal void set_Name(string value);
    public long get_Size();
    public void set_Size(long value);
    public long get_CompressedSize();
    public void set_CompressedSize(long value);
    public long get_Crc();
    public void set_Crc(long value);
    public CompressionMethod get_CompressionMethod();
    public void set_CompressionMethod(CompressionMethod value);
    internal CompressionMethod get_CompressionMethodForHeader();
    public Byte[] get_ExtraData();
    public void set_ExtraData(Byte[] value);
    public int get_AESKeySize();
    public void set_AESKeySize(int value);
    internal byte get_AESEncryptionStrength();
    internal int get_AESSaltLen();
    internal int get_AESOverheadSize();
    internal int get_EncryptionOverheadSize();
    internal void ProcessExtraData(bool localHeader);
    private static Nullable`1<DateTime> GetDateTime(ZipExtraData extraData);
    private void ProcessAESExtraData(ZipExtraData extraData);
    public string get_Comment();
    public void set_Comment(string value);
    public bool get_IsDirectory();
    public bool get_IsFile();
    public bool IsCompressionMethodSupported();
    public object Clone();
    public virtual string ToString();
    public static bool IsCompressionMethodSupported(CompressionMethod method);
    public static string CleanName(string name);
}
[ExtensionAttribute]
internal static class ICSharpCode.SharpZipLib.Zip.ZipEntryExtensions : object {
    [ExtensionAttribute]
public static bool HasFlag(ZipEntry entry, GeneralBitFlags flag);
    [ExtensionAttribute]
public static void SetFlag(ZipEntry entry, GeneralBitFlags flag, bool enabled);
}
internal class ICSharpCode.SharpZipLib.Zip.ZipEntryFactory : object {
    private INameTransform nameTransform_;
    private DateTime fixedDateTime_;
    private TimeSetting timeSetting_;
    private bool isUnicodeText_;
    private int getAttributes_;
    private int setAttributes_;
    public INameTransform NameTransform { get; public set; }
    public TimeSetting Setting { get; public set; }
    public DateTime FixedDateTime { get; public set; }
    public int GetAttributes { get; public set; }
    public int SetAttributes { get; public set; }
    public bool IsUnicodeText { get; public set; }
    public ZipEntryFactory(TimeSetting timeSetting);
    public ZipEntryFactory(DateTime time);
    public sealed virtual INameTransform get_NameTransform();
    public sealed virtual void set_NameTransform(INameTransform value);
    public sealed virtual TimeSetting get_Setting();
    public void set_Setting(TimeSetting value);
    public sealed virtual DateTime get_FixedDateTime();
    public void set_FixedDateTime(DateTime value);
    public int get_GetAttributes();
    public void set_GetAttributes(int value);
    public int get_SetAttributes();
    public void set_SetAttributes(int value);
    public bool get_IsUnicodeText();
    public void set_IsUnicodeText(bool value);
    public sealed virtual ZipEntry MakeFileEntry(string fileName);
    public sealed virtual ZipEntry MakeFileEntry(string fileName, bool useFileSystem);
    public sealed virtual ZipEntry MakeFileEntry(string fileName, string entryName, bool useFileSystem);
    public sealed virtual ZipEntry MakeDirectoryEntry(string directoryName);
    public sealed virtual ZipEntry MakeDirectoryEntry(string directoryName, bool useFileSystem);
}
internal class ICSharpCode.SharpZipLib.Zip.ZipException : SharpZipBaseException {
    public ZipException(string message);
    public ZipException(string message, Exception innerException);
    protected ZipException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.SharpZipLib.Zip.ZipExtraData : object {
    private int _index;
    private int _readValueStart;
    private int _readValueLength;
    private MemoryStream _newEntry;
    private Byte[] _data;
    public int Length { get; }
    public int ValueLength { get; }
    public int CurrentReadIndex { get; }
    public int UnreadCount { get; }
    public ZipExtraData(Byte[] data);
    public Byte[] GetEntryData();
    public void Clear();
    public int get_Length();
    public Stream GetStreamForTag(int tag);
    public T GetData();
    public int get_ValueLength();
    public int get_CurrentReadIndex();
    public int get_UnreadCount();
    public bool Find(int headerID);
    public void AddEntry(ITaggedData taggedData);
    public void AddEntry(int headerID, Byte[] fieldData);
    public void StartNewEntry();
    public void AddNewEntry(int headerID);
    public void AddData(byte data);
    public void AddData(Byte[] data);
    public void AddLeShort(int toAdd);
    public void AddLeInt(int toAdd);
    public void AddLeLong(long toAdd);
    public bool Delete(int headerID);
    public long ReadLong();
    public int ReadInt();
    public int ReadShort();
    public int ReadByte();
    public void Skip(int amount);
    private void ReadCheck(int length);
    private int ReadShortInternal();
    private void SetShort(Int32& index, int source);
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("EntryByIndex")]
internal class ICSharpCode.SharpZipLib.Zip.ZipFile : object {
    public KeysRequiredEventHandler KeysRequired;
    private static int DefaultBufferSize;
    [CompilerGeneratedAttribute]
private bool <SkipLocalEntryTestsOnLocate>k__BackingField;
    private bool isDisposed_;
    private string name_;
    private string comment_;
    private string rawPassword_;
    private Stream baseStream_;
    private bool isStreamOwner;
    private long offsetOfFirstEntry;
    private ZipEntry[] entries_;
    private Byte[] key;
    private bool isNewArchive_;
    private StringCodec _stringCodec;
    private UseZip64 useZip64_;
    private List`1<ZipUpdate> updates_;
    private long updateCount_;
    private Dictionary`2<string, int> updateIndex_;
    private IArchiveStorage archiveStorage_;
    private IDynamicDataSource updateDataSource_;
    private bool contentsEdited_;
    private int bufferSize_;
    private Byte[] copyBuffer_;
    private ZipString newComment_;
    private bool commentEdited_;
    private IEntryFactory updateEntryFactory_;
    private Byte[] Key { get; private set; }
    unknown string Password {public set; }
    private bool HaveKeys { get; }
    public bool IsStreamOwner { get; public set; }
    public bool IsEmbeddedArchive { get; }
    public bool IsNewArchive { get; }
    public string ZipFileComment { get; }
    public string Name { get; }
    [ObsoleteAttribute("Use the Count property instead")]
public int Size { get; }
    public long Count { get; }
    public ZipEntry EntryByIndex { get; }
    public Encoding ZipCryptoEncoding { get; public set; }
    unknown StringCodec StringCodec {public set; }
    public INameTransform NameTransform { get; public set; }
    public IEntryFactory EntryFactory { get; public set; }
    public int BufferSize { get; public set; }
    public bool IsUpdating { get; }
    public UseZip64 UseZip64 { get; public set; }
    public bool SkipLocalEntryTestsOnLocate { get; public set; }
    public ZipFile(string name, StringCodec stringCodec);
    public ZipFile(FileStream file);
    public ZipFile(FileStream file, bool leaveOpen);
    public ZipFile(Stream stream);
    public ZipFile(Stream stream, bool leaveOpen, StringCodec stringCodec);
    private void OnKeysRequired(string fileName);
    private Byte[] get_Key();
    private void set_Key(Byte[] value);
    public void set_Password(string value);
    private bool get_HaveKeys();
    protected virtual override void Finalize();
    public void Close();
    public static ZipFile Create(string fileName);
    public static ZipFile Create(Stream outStream);
    public bool get_IsStreamOwner();
    public void set_IsStreamOwner(bool value);
    public bool get_IsEmbeddedArchive();
    public bool get_IsNewArchive();
    public string get_ZipFileComment();
    public string get_Name();
    public int get_Size();
    public long get_Count();
    public ZipEntry get_EntryByIndex(int index);
    public Encoding get_ZipCryptoEncoding();
    public void set_ZipCryptoEncoding(Encoding value);
    public void set_StringCodec(StringCodec value);
    public sealed virtual IEnumerator GetEnumerator();
    public int FindEntry(string name, bool ignoreCase);
    public ZipEntry GetEntry(string name);
    public Stream GetInputStream(ZipEntry entry);
    public Stream GetInputStream(long entryIndex);
    public bool TestArchive(bool testData);
    public bool TestArchive(bool testData, TestStrategy strategy, ZipTestResultHandler resultHandler);
    private long TestLocalHeader(ZipEntry entry, HeaderTest tests);
    public INameTransform get_NameTransform();
    public void set_NameTransform(INameTransform value);
    public IEntryFactory get_EntryFactory();
    public void set_EntryFactory(IEntryFactory value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public bool get_IsUpdating();
    public UseZip64 get_UseZip64();
    public void set_UseZip64(UseZip64 value);
    public void BeginUpdate(IArchiveStorage archiveStorage, IDynamicDataSource dataSource);
    public void BeginUpdate(IArchiveStorage archiveStorage);
    public void BeginUpdate();
    public void CommitUpdate();
    public void AbortUpdate();
    public void SetComment(string comment);
    private void AddUpdate(ZipUpdate update);
    public void Add(string fileName, CompressionMethod compressionMethod, bool useUnicodeText);
    public void Add(string fileName, CompressionMethod compressionMethod);
    public void Add(string fileName);
    public void Add(string fileName, string entryName);
    public void Add(IStaticDataSource dataSource, string entryName);
    public void Add(IStaticDataSource dataSource, string entryName, CompressionMethod compressionMethod);
    public void Add(IStaticDataSource dataSource, string entryName, CompressionMethod compressionMethod, bool useUnicodeText);
    public void Add(ZipEntry entry);
    public void Add(IStaticDataSource dataSource, ZipEntry entry);
    public void AddDirectory(string directoryName);
    private static void CheckSupportedCompressionMethod(CompressionMethod compressionMethod);
    public bool Delete(string fileName);
    public void Delete(ZipEntry entry);
    private void WriteLEShort(int value);
    private void WriteLEUshort(ushort value);
    private void WriteLEInt(int value);
    private void WriteLEUint(UInt32 value);
    private void WriteLeLong(long value);
    private void WriteLEUlong(ulong value);
    private void WriteLocalEntryHeader(ZipUpdate update);
    private int WriteCentralDirectoryHeader(ZipEntry entry);
    private void PostUpdateCleanup();
    private string GetTransformedFileName(string name);
    private string GetTransformedDirectoryName(string name);
    private Byte[] GetBuffer();
    private void CopyDescriptorBytes(ZipUpdate update, Stream dest, Stream source);
    private void CopyBytes(ZipUpdate update, Stream destination, Stream source, long bytesToCopy, bool updateCrc);
    private static int GetDescriptorSize(ZipUpdate update, bool includingSignature);
    private void CopyDescriptorBytesDirect(ZipUpdate update, Stream stream, Int64& destinationPosition, long sourcePosition);
    private void CopyEntryDataDirect(ZipUpdate update, Stream stream, bool updateCrc, Int64& destinationPosition, Int64& sourcePosition);
    private int FindExistingUpdate(ZipEntry entry);
    private int FindExistingUpdate(string fileName, bool isEntryName);
    private Stream GetOutputStream(ZipEntry entry);
    private void AddEntry(ZipFile workFile, ZipUpdate update);
    private void ModifyEntry(ZipFile workFile, ZipUpdate update);
    private void CopyEntryDirect(ZipFile workFile, ZipUpdate update, Int64& destinationPosition);
    private void CopyEntry(ZipFile workFile, ZipUpdate update);
    private void Reopen(Stream source);
    private void Reopen();
    private void UpdateCommentOnly();
    private void RunUpdates();
    private void CheckUpdating();
    private sealed virtual override void System.IDisposable.Dispose();
    private void DisposeInternal(bool disposing);
    protected virtual void Dispose(bool disposing);
    private ushort ReadLEUshort();
    private UInt32 ReadLEUint();
    private ulong ReadLEUlong();
    private long LocateBlockWithSignature(int signature, long endLocation, int minimumBlockSize, int maximumVariableData);
    private void ReadEntries();
    private long LocateEntry(ZipEntry entry);
    [CompilerGeneratedAttribute]
public bool get_SkipLocalEntryTestsOnLocate();
    [CompilerGeneratedAttribute]
public void set_SkipLocalEntryTestsOnLocate(bool value);
    private Stream CreateAndInitDecryptionStream(Stream baseStream, ZipEntry entry);
    private Stream CreateAndInitEncryptionStream(Stream baseStream, ZipEntry entry);
    private static void CheckClassicPassword(CryptoStream classicCryptoStream, ZipEntry entry);
    private static void WriteEncryptionHeader(Stream stream, long crcValue);
}
internal static class ICSharpCode.SharpZipLib.Zip.ZipFormat : object {
    internal static int WriteLocalHeader(Stream stream, ZipEntry entry, EntryPatchData& patchData, bool headerInfoAvailable, bool patchEntryHeader, long streamOffset, StringCodec stringCodec);
    internal static long LocateBlockWithSignature(Stream stream, int signature, long endLocation, int minimumBlockSize, int maximumVariableData);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipFormat/<WriteZip64EndOfCentralDirectoryAsync>d__2")]
public static Task WriteZip64EndOfCentralDirectoryAsync(Stream stream, long noOfEntries, long sizeEntries, long centralDirOffset, CancellationToken cancellationToken);
    internal static void WriteZip64EndOfCentralDirectory(Stream stream, long noOfEntries, long sizeEntries, long centralDirOffset);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipFormat/<WriteEndOfCentralDirectoryAsync>d__4")]
public static Task WriteEndOfCentralDirectoryAsync(Stream stream, long noOfEntries, long sizeEntries, long start, Byte[] comment, CancellationToken cancellationToken);
    internal static void WriteEndOfCentralDirectory(Stream stream, long noOfEntries, long sizeEntries, long start, Byte[] comment);
    internal static int WriteDataDescriptor(Stream stream, ZipEntry entry);
    internal static void ReadDataDescriptor(Stream stream, bool zip64, DescriptorData data);
    internal static int WriteEndEntry(Stream stream, ZipEntry entry, StringCodec stringCodec);
    internal static void AddExtraDataAES(ZipEntry entry, ZipExtraData extraData);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipFormat/<PatchLocalHeaderAsync>d__10")]
internal static Task PatchLocalHeaderAsync(Stream stream, ZipEntry entry, EntryPatchData patchData, CancellationToken ct);
    internal static void PatchLocalHeaderSync(Stream stream, ZipEntry entry, EntryPatchData patchData);
}
internal class ICSharpCode.SharpZipLib.Zip.ZipInputStream : InflaterInputStream {
    private ReadDataHandler internalReader;
    private Crc32 crc;
    private ZipEntry entry;
    private long size;
    private CompressionMethod method;
    private int flags;
    private string password;
    private StringCodec _stringCodec;
    public string Password { get; public set; }
    public bool CanDecompressEntry { get; }
    public int Available { get; }
    public long Length { get; }
    public ZipInputStream(Stream baseInputStream);
    public ZipInputStream(Stream baseInputStream, int bufferSize);
    public ZipInputStream(Stream baseInputStream, StringCodec stringCodec);
    public string get_Password();
    public void set_Password(string value);
    public bool get_CanDecompressEntry();
    private static bool IsEntryCompressionMethodSupported(ZipEntry entry);
    public ZipEntry GetNextEntry();
    private bool SkipUntilNextEntry();
    private void ReadDataDescriptor();
    private void CompleteCloseEntry(bool testCrc);
    public void CloseEntry();
    public virtual int get_Available();
    public virtual long get_Length();
    public virtual int ReadByte();
    private int ReadingNotAvailable(Byte[] destination, int offset, int count);
    private int ReadingNotSupported(Byte[] destination, int offset, int count);
    private int StoredDescriptorEntry(Byte[] destination, int offset, int count);
    private int InitialRead(Byte[] destination, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private int BodyRead(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
internal class ICSharpCode.SharpZipLib.Zip.ZipNameTransform : object {
    private string trimPrefix_;
    private static Char[] InvalidEntryChars;
    private static Char[] InvalidEntryCharsRelaxed;
    public string TrimPrefix { get; public set; }
    public ZipNameTransform(string trimPrefix);
    private static ZipNameTransform();
    public sealed virtual string TransformDirectory(string name);
    public sealed virtual string TransformFile(string name);
    public string get_TrimPrefix();
    public void set_TrimPrefix(string value);
    private static string MakeValidName(string name, char replacement);
    public static bool IsValidName(string name, bool relaxed);
    public static bool IsValidName(string name);
}
internal class ICSharpCode.SharpZipLib.Zip.ZipOutputStream : DeflaterOutputStream {
    [CompilerGeneratedAttribute]
private INameTransform <NameTransform>k__BackingField;
    private List`1<ZipEntry> entries;
    private Crc32 crc;
    private ZipEntry curEntry;
    private bool entryIsPassthrough;
    private int defaultCompressionLevel;
    private CompressionMethod curMethod;
    private long size;
    private long offset;
    private Byte[] zipComment;
    private bool patchEntryHeader;
    private EntryPatchData patchData;
    private UseZip64 useZip64_;
    private string password;
    private static RandomNumberGenerator _aesRnd;
    public bool IsFinished { get; }
    public UseZip64 UseZip64 { get; public set; }
    public INameTransform NameTransform { get; public set; }
    public string Password { get; public set; }
    public ZipOutputStream(Stream baseOutputStream);
    public ZipOutputStream(Stream baseOutputStream, int bufferSize);
    public ZipOutputStream(Stream baseOutputStream, StringCodec stringCodec);
    private static ZipOutputStream();
    public bool get_IsFinished();
    public void SetComment(string comment);
    public void SetLevel(int level);
    public int GetLevel();
    public UseZip64 get_UseZip64();
    public void set_UseZip64(UseZip64 value);
    [CompilerGeneratedAttribute]
public INameTransform get_NameTransform();
    [CompilerGeneratedAttribute]
public void set_NameTransform(INameTransform value);
    public string get_Password();
    public void set_Password(string value);
    private void WriteLeShort(int value);
    private void WriteLeInt(int value);
    private void WriteLeLong(long value);
    private void TransformEntryName(ZipEntry entry);
    public void PutNextEntry(ZipEntry entry);
    public void PutNextPassthroughEntry(ZipEntry entry);
    private void WriteOutput(Byte[] bytes);
    private Task WriteOutputAsync(Byte[] bytes);
    private Byte[] GetEntryEncryptionHeader(ZipEntry entry);
    internal void PutNextEntry(Stream stream, ZipEntry entry, long streamOffset, bool passthroughEntry);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipOutputStream/<PutNextEntryAsync>d__28")]
public Task PutNextEntryAsync(ZipEntry entry, CancellationToken ct);
    public void CloseEntry();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipOutputStream/<FinishCompressionSyncOrAsync>d__30")]
private Task FinishCompressionSyncOrAsync(Nullable`1<CancellationToken> ct);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipOutputStream/<CloseEntryAsync>d__31")]
public Task CloseEntryAsync(CancellationToken ct);
    internal void WriteEntryFooter(Stream stream);
    protected Byte[] InitializeAESPassword(ZipEntry entry, string rawPassword);
    private Byte[] CreateZipCryptoHeader(long crcValue);
    private void InitializeZipCryptoPassword(string password);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipOutputStream/<WriteAsync>d__37")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken ct);
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipOutputStream/<WriteSyncOrAsync>d__38")]
private Task WriteSyncOrAsync(Byte[] buffer, int offset, int count, Nullable`1<CancellationToken> ct);
    private void CopyAndEncrypt(Byte[] buffer, int offset, int count);
    public virtual void Finish();
    [AsyncStateMachineAttribute("ICSharpCode.SharpZipLib.Zip.ZipOutputStream/<FinishAsync>d__41")]
public virtual Task FinishAsync(CancellationToken ct);
    public virtual void Flush();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken ct);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__1();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__2(Byte[] buffer, int offset, int count, CancellationToken ct);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__3(Byte[] buffer, int offset, int count);
}
internal static class ICSharpCode.SharpZipLib.Zip.ZipStrings : object {
    private static StringCodec CompatCodec;
    private static bool compatibilityMode;
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static int CodePage { get; public set; }
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static int SystemDefaultCodePage { get; }
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static bool UseUnicode { get; public set; }
    private static ZipStrings();
    public static StringCodec GetStringCodec();
    public static int get_CodePage();
    public static void set_CodePage(int value);
    public static int get_SystemDefaultCodePage();
    public static bool get_UseUnicode();
    public static void set_UseUnicode(bool value);
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
private static bool HasUnicodeFlag(int flags);
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static string ConvertToString(Byte[] data, int count);
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static string ConvertToString(Byte[] data);
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static string ConvertToStringExt(int flags, Byte[] data, int count);
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static string ConvertToStringExt(int flags, Byte[] data);
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static Byte[] ConvertToArray(string str);
    [ObsoleteAttribute("Use ZipFile/Zip*Stream StringCodec instead")]
public static Byte[] ConvertToArray(int flags, string str);
}
internal class ICSharpCode.SharpZipLib.Zip.ZipTestResultHandler : MulticastDelegate {
    public ZipTestResultHandler(object object, IntPtr method);
    public virtual void Invoke(TestStatus status, string message);
    public virtual IAsyncResult BeginInvoke(TestStatus status, string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Internal.PaddingFor32 : ValueType {
}
internal static class Internal.PaddingHelpers : object {
    internal static int CACHE_LINE_SIZE;
}
internal static class Interop : object {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class NewRelic.Agent.Core.Agent : object {
    public static int QueryParameterMaxStringLength;
    private static int LogExceptionStackLimit;
    internal static Agent Instance;
    private static ITransaction _noOpTransaction;
    public static bool IsAgentShuttingDown;
    internal ITransactionService _transactionService;
    internal ITransactionTransformer _transactionTransformer;
    internal IThreadPoolStatic _threadPoolStatic;
    internal ITransactionMetricNameMaker _transactionMetricNameMaker;
    internal IPathHashMaker _pathHashMaker;
    internal ICatHeaderHandler _catHeaderHandler;
    internal IDistributedTracePayloadHandler _distributedTracePayloadHandler;
    internal ISyntheticsHeaderHandler _syntheticsHeaderHandler;
    internal ITransactionFinalizer _transactionFinalizer;
    private IBrowserMonitoringPrereqChecker _browserMonitoringPrereqChecker;
    private IBrowserMonitoringScriptMaker _browserMonitoringScriptMaker;
    private IConfigurationService _configurationService;
    internal IAgentHealthReporter _agentHealthReporter;
    internal IAgentTimerService _agentTimerService;
    internal IMetricNameService _metricNameService;
    private ICATSupportabilityMetricCounters _catMetricCounters;
    private ITraceMetadataFactory _traceMetadataFactory;
    private ILogEventAggregator _logEventAggregator;
    private ILogContextDataFilter _logContextDataFilter;
    private ILogger _logger;
    private ISimpleSchedulingService _simpleSchedulingService;
    private ICustomEventTransformer _customEventTransformer;
    [CompilerGeneratedAttribute]
private IStackExchangeRedisCache <StackExchangeRedisCache>k__BackingField;
    public IConfiguration Configuration { get; }
    public ILogger Logger { get; }
    public ITransaction CurrentTransaction { get; }
    public ITraceMetadata TraceMetadata { get; }
    public ISimpleSchedulingService SimpleSchedulingService { get; }
    public IStackExchangeRedisCache StackExchangeRedisCache { get; public set; }
    public Agent(ITransactionService transactionService, ITransactionTransformer transactionTransformer, IThreadPoolStatic threadPoolStatic, ITransactionMetricNameMaker transactionMetricNameMaker, IPathHashMaker pathHashMaker, ICatHeaderHandler catHeaderHandler, IDistributedTracePayloadHandler distributedTracePayloadHandler, ISyntheticsHeaderHandler syntheticsHeaderHandler, ITransactionFinalizer transactionFinalizer, IBrowserMonitoringPrereqChecker browserMonitoringPrereqChecker, IBrowserMonitoringScriptMaker browserMonitoringScriptMaker, IConfigurationService configurationService, IAgentHealthReporter agentHealthReporter, IAgentTimerService agentTimerService, IMetricNameService metricNameService, ITraceMetadataFactory traceMetadataFactory, ICATSupportabilityMetricCounters catMetricCounters, ILogEventAggregator logEventAggregator, ILogContextDataFilter logContextDataFilter, ISimpleSchedulingService simpleSchedulingService, ICustomEventTransformer customEventTransformer);
    private static Agent();
    public sealed virtual IConfiguration get_Configuration();
    public sealed virtual ILogger get_Logger();
    private static void NoOpWrapperOnCreate();
    private ITransaction CreateTransaction(TransactionName transactionName, bool doNotTrackAsUnitOfWork, Action wrapperOnCreate);
    public sealed virtual ITransaction CreateTransaction(MessageBrokerDestinationType destinationType, string brokerVendorName, string destination, Action wrapperOnCreate);
    public sealed virtual ITransaction CreateKafkaTransaction(MessageBrokerDestinationType destinationType, string brokerVendorName, string destination, Action wrapperOnCreate);
    public sealed virtual ITransaction CreateTransaction(bool isWeb, string category, string transactionDisplayName, bool doNotTrackAsUnitOfWork, Action wrapperOnCreate);
    public sealed virtual ITransaction get_CurrentTransaction();
    public sealed virtual ITraceMetadata get_TraceMetadata();
    public sealed virtual bool TryTrackAsyncWorkOnNewTransaction();
    public sealed virtual ISegment CastAsSegment(object segment);
    public sealed virtual void EnableExplainPlans(ISegment segment, Func`1<object> allocateExplainPlanResources, Func`2<object, ExplainPlan> generateExplainPlan, Func`1<VendorExplainValidationResult> vendorValidateShouldExplain);
    internal void TryProcessCatRequestData(IInternalTransaction transaction, T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
    internal void TryProcessSyntheticsData(IInternalTransaction transaction, T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
    public sealed virtual void HandleWrapperException(Exception exception);
    public sealed virtual Stream TryGetStreamInjector(Stream stream, Encoding encoding, string contentType, string requestPath);
    [AsyncStateMachineAttribute("NewRelic.Agent.Core.Agent/<TryInjectBrowserScriptAsync>d__48")]
public sealed virtual Task TryInjectBrowserScriptAsync(string contentType, string requestPath, Byte[] buffer, Stream baseStream);
    private string TryGetRUMScriptInternal(string contentType, string requestPath);
    public sealed virtual Dictionary`2<string, string> GetLinkingMetadata();
    public sealed virtual void SetServerlessParameters(string lambdaFunctionVersion, string lambdaFunctionArn);
    public sealed virtual void RecordLlmEvent(string eventType, IDictionary`2<string, object> attributes);
    public sealed virtual List`1<string> GetConfiguredDTHeaders();
    public sealed virtual ISimpleSchedulingService get_SimpleSchedulingService();
    [CompilerGeneratedAttribute]
public sealed virtual IStackExchangeRedisCache get_StackExchangeRedisCache();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StackExchangeRedisCache(IStackExchangeRedisCache value);
    public sealed virtual void RecordSupportabilityMetric(string metricName, long count);
    public sealed virtual void RecordCountMetric(string metricName, long count);
    public sealed virtual void RecordByteMetric(string metricName, long totalBytes, Nullable`1<long> exclusiveBytes);
    public sealed virtual void RecordLogMessage(string frameworkName, object logEvent, Func`2<object, DateTime> getTimestamp, Func`2<object, object> getLevel, Func`2<object, string> getLogMessage, Func`2<object, Exception> getLogException, Func`2<object, Dictionary`2<string, object>> getContextData, string spanId, string traceId);
    private string GetReferrerCrossApplicationProcessId(IInternalTransaction transaction, T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
    private void UpdateReferrerCrossApplicationProcessId(IInternalTransaction transaction, string referrerCrossApplicationProcessId);
    private void UpdateTransactionMetadata(IInternalTransaction transaction, CrossApplicationRequestData crossApplicationRequestData, Nullable`1<long> contentLength);
    private long GetContentLength(T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
    private void UpdateTransactionMetaData(IInternalTransaction transaction, SyntheticsHeader syntheticsHeader);
    internal void Detach(bool removeAsync, bool removePrimary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NewRelic.Agent.Core.AgentApi : object {
    [NullableAttribute("2")]
private static IApiSupportabilityMetricCounters _apiSupportabilityMetricCounters;
    private static AgentApi();
    public static void SetSupportabilityMetricCounters(IApiSupportabilityMetricCounters apiSupportabilityMetricCounters);
    public static void InitializePublicAgent(object publicAgent);
    private static void LogApiError(string methodName, Exception ex);
    private static void RecordSupportabilityMetric(ApiMethod apiMethod);
    private static void TryInvoke(Action action, string methodName, ApiMethod apiMethod);
    public static T TryInvoke(Func`1<T> action, string methodName, ApiMethod apiMethod);
    public static void RecordCustomEvent(string eventType, IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    public static void RecordMetric(string name, float value);
    public static void RecordResponseTimeMetric(string name, long millis);
    public static void IncrementCounter(string name);
    public static void NoticeError(Exception exception, IDictionary`2<string, string> customAttributes);
    public static void NoticeError(Exception exception, IDictionary`2<string, object> customAttributes);
    public static void NoticeError(Exception exception);
    public static void NoticeError(string message, IDictionary`2<string, string> customAttributes);
    public static void NoticeError(string message, IDictionary`2<string, string> customAttributes, bool isExpected);
    public static void NoticeError(string message, IDictionary`2<string, object> customAttributes);
    public static void NoticeError(string message, IDictionary`2<string, object> customAttributes, bool isExpected);
    [ObsoleteAttribute("This method does nothing in version 9.x+ of the Agent.  Use Transaction.AddCustomAttribute instead")]
public static void AddCustomParameter(string key, IConvertible value);
    [ObsoleteAttribute("This method does nothing in version 9.x+ of the Agent. Use Transaction.AddCustomAttribute instead")]
public static void AddCustomParameter(string key, string value);
    public static void SetTransactionName(string category, string name);
    public static void SetTransactionUri(Uri uri);
    [NullableContextAttribute("2")]
public static void SetUserParameters(string userName, string accountName, string productName);
    public static void IgnoreTransaction();
    public static void IgnoreApdex();
    public static string GetBrowserTimingHeader();
    public static string GetBrowserTimingHeader(string nonce);
    [ObsoleteAttribute("This method does nothing in version 9.x+ of the Agent.")]
public static string GetBrowserTimingFooter();
    public static void DisableBrowserMonitoring(bool overrideManual);
    public static void StartAgent();
    [NullableContextAttribute("2")]
public static void SetApplicationName(string applicationName, string applicationName2, string applicationName3);
    public static IEnumerable`1<KeyValuePair`2<string, string>> GetRequestMetadata();
    public static IEnumerable`1<KeyValuePair`2<string, string>> GetResponseMetadata();
    public static void SetErrorGroupCallback(Func`2<IReadOnlyDictionary`2<string, object>, string> callback);
    public static void SetLlmTokenCountingCallback(Func`3<string, string, int> callback);
    public static void RecordLlmFeedbackEvent(string traceId, object rating, string category, string message, IDictionary`2<string, object> metadata);
}
public enum NewRelic.Agent.Core.AgentHealth.AgentHealthEvent : Enum {
    public int value__;
    public static AgentHealthEvent TransactionGarbageCollected;
    public static AgentHealthEvent WrapperShutdown;
    public static AgentHealthEvent Transaction;
    public static AgentHealthEvent Log;
    public static AgentHealthEvent Custom;
    public static AgentHealthEvent Error;
    public static AgentHealthEvent Span;
    public static AgentHealthEvent InfiniteTracingSpan;
}
public class NewRelic.Agent.Core.AgentHealth.AgentHealthReporter : ConfigurationBasedService {
    private static TimeSpan _timeBetweenExecutions;
    private IMetricBuilder _metricBuilder;
    private IScheduler _scheduler;
    private IList`1<string> _recurringLogData;
    private IDictionary`2<AgentHealthEvent, InterlockedCounter> _agentHealthEventCounters;
    private ConcurrentDictionary`2<string, InterlockedCounter> _logLinesCountByLevel;
    private ConcurrentDictionary`2<string, InterlockedCounter> _logDeniedCountByLevel;
    private PublishMetricDelegate _publishMetricDelegate;
    private InterlockedCounter _payloadCreateSuccessCounter;
    private InterlockedCounter _payloadAcceptSuccessCounter;
    private InterlockedCounter _traceContextCreateSuccessCounter;
    private InterlockedCounter _traceContextAcceptSuccessCounter;
    private InterlockedLongCounter _infiniteTracingSpanResponseError;
    private InterlockedLongCounter _infiniteTracingSpanEventsDropped;
    private InterlockedLongCounter _infiniteTracingSpanEventsSeen;
    private InterlockedLongCounter _infiniteTracingSpanEventsSent;
    private InterlockedCounter _infiniteTracingSpanBatchCount;
    private long _infiniteTracingSpanBatchSizeMin;
    private long _infiniteTracingSpanBatchSizeMax;
    private object _syncRootMetrics;
    private InterlockedLongCounter _infiniteTracingSpanEventsReceived;
    private ConcurrentDictionary`2<string, InterlockedLongCounter> _infiniteTracingSpanGrpcErrorCounters;
    private InterlockedCounter _infiniteTracingSpanGrpcTimeout;
    private ConcurrentDictionary`2<string, bool> _loggingFrameworksReported;
    private ConcurrentDictionary`2<string, bool> _loggingForwardingEnabledWithFrameworksReported;
    private bool _oneTimeMetricsCollected;
    private ConcurrentBag`1<DestinationInteractionSample> _externalApiDataUsageSamples;
    public AgentHealthReporter(IMetricBuilder metricBuilder, IScheduler scheduler);
    private static AgentHealthReporter();
    public virtual void Dispose();
    private void LogPeriodicReport();
    public sealed virtual void ReportSupportabilityCountMetric(string metricName, long count);
    public void ReportSupportabilityDataUsageMetric(string metricName, long callCount, float bytesSent, float bytesReceived);
    private void ReportSupportabilitySummaryMetric(string metricName, float totalSize, int countSamples, float minValue, float maxValue);
    private void ReportSupportabilityGaugeMetric(string metricName, float value);
    public sealed virtual void ReportCountMetric(string metricName, long count);
    public sealed virtual void ReportByteMetric(string metricName, long totalBytes, Nullable`1<long> exclusiveBytes);
    public sealed virtual void ReportDotnetVersion();
    public sealed virtual void ReportAgentVersion(string agentVersion);
    public sealed virtual void ReportLibraryVersion(string assemblyName, string assemblyVersion);
    public sealed virtual void ReportTransactionEventReservoirResized(int newSize);
    public sealed virtual void ReportTransactionEventCollected();
    public sealed virtual void ReportTransactionEventsRecollected(int count);
    public sealed virtual void ReportTransactionEventsSent(int count);
    public sealed virtual void ReportCustomEventReservoirResized(int newSize);
    public sealed virtual void ReportCustomEventCollected();
    public sealed virtual void ReportCustomEventsRecollected(int count);
    public sealed virtual void ReportCustomEventsSent(int count);
    public sealed virtual void ReportErrorTraceCollected();
    public sealed virtual void ReportErrorTracesRecollected(int count);
    public sealed virtual void ReportErrorTracesSent(int count);
    public sealed virtual void ReportErrorEventSeen();
    public sealed virtual void ReportErrorEventsSent(int count);
    public sealed virtual void ReportSqlTracesRecollected(int count);
    public sealed virtual void ReportSqlTracesSent(int count);
    public sealed virtual void ReportAgentInfo();
    public sealed virtual void ReportTransactionGarbageCollected(TransactionMetricName transactionMetricName, string lastStartedSegmentName, string lastFinishedSegmentName);
    public sealed virtual void ReportWrapperShutdown(IWrapper wrapper, Method method);
    public sealed virtual void ReportIfHostIsLinuxOs();
    public sealed virtual void ReportBootIdError();
    public sealed virtual void ReportKubernetesUtilizationError();
    public sealed virtual void ReportAwsUtilizationError();
    public sealed virtual void ReportAzureUtilizationError();
    public sealed virtual void ReportPcfUtilizationError();
    public sealed virtual void ReportGcpUtilizationError();
    public sealed virtual void ReportSupportabilityDistributedTraceAcceptPayloadSuccess();
    public sealed virtual void ReportSupportabilityDistributedTraceAcceptPayloadException();
    public sealed virtual void ReportSupportabilityDistributedTraceAcceptPayloadParseException();
    public sealed virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredCreateBeforeAccept();
    public sealed virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredMultiple();
    public sealed virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredMajorVersion();
    public sealed virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredNull();
    public sealed virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredUntrustedAccount();
    public sealed virtual void ReportSupportabilityDistributedTraceCreatePayloadSuccess();
    public sealed virtual void ReportSupportabilityDistributedTraceCreatePayloadException();
    public sealed virtual void CollectDistributedTraceSuccessMetrics();
    public sealed virtual void ReportSupportabilityTraceContextAcceptSuccess();
    public sealed virtual void ReportSupportabilityTraceContextCreateSuccess();
    public sealed virtual void ReportSupportabilityTraceContextAcceptException();
    public sealed virtual void ReportSupportabilityTraceContextTraceParentParseException();
    public sealed virtual void ReportSupportabilityTraceContextTraceStateParseException();
    public sealed virtual void ReportSupportabilityTraceContextCreateException();
    public sealed virtual void ReportSupportabilityTraceContextTraceStateInvalidNrEntry();
    public sealed virtual void ReportSupportabilityTraceContextTraceStateNoNrEntry();
    public void CollectTraceContextSuccessMetrics();
    public sealed virtual void ReportSpanEventCollected(int count);
    public sealed virtual void ReportSpanEventsSent(int count);
    public sealed virtual void ReportInfiniteTracingSpanResponseError();
    public sealed virtual void ReportInfiniteTracingSpanQueueSize(int queueSize);
    public sealed virtual void ReportInfiniteTracingSpanEventsDropped(long countSpans);
    public sealed virtual void ReportInfiniteTracingSpanEventsSeen(long countSpans);
    public sealed virtual void ReportInfiniteTracingSpanEventsSent(long countSpans);
    public sealed virtual void ReportInfiniteTracingSpanEventsReceived(ulong countSpans);
    public sealed virtual void ReportInfiniteTracingSpanGrpcError(string error);
    public sealed virtual void ReportInfiniteTracingSpanGrpcTimeout();
    private static InterlockedLongCounter CreateNewGrpcErrorInterlockedCounter(string _);
    private void CollectInfiniteTracingMetrics();
    private void ReportInfiniteTracingOneTimeMetrics();
    public sealed virtual void ReportAgentTimingMetric(string suffix, TimeSpan time);
    public sealed virtual void ReportSupportabilityCollectorErrorException(string endpointMethod, TimeSpan responseDuration, Nullable`1<HttpStatusCode> statusCode);
    public sealed virtual void ReportLogForwardingFramework(string logFramework);
    public sealed virtual void ReportLogForwardingEnabledWithFramework(string logFramework);
    public sealed virtual void ReportLoggingEventsEmpty(int count);
    public void CollectLoggingMetrics();
    public sealed virtual void IncrementLogLinesCount(string level);
    public sealed virtual void IncrementLogDeniedCount(string level);
    public sealed virtual void ReportLoggingEventCollected();
    public sealed virtual void ReportLoggingEventsSent(int count);
    public sealed virtual void ReportLoggingEventsDropped(int droppedCount);
    public void ReportIfAppDomainCachingDisabled();
    public void ReportLogForwardingConfiguredValues();
    public sealed virtual void ReportSupportabilityPayloadsDroppeDueToMaxPayloadSizeLimit(string endpoint);
    private void CollectOneTimeMetrics();
    public sealed virtual void CollectMetrics();
    public sealed virtual void RegisterPublishMetricHandler(PublishMetricDelegate publishMetricDelegate);
    private void TrySend(MetricWireModel metric);
    private bool TryGetCount(InterlockedCounter counter, Int32& metricCount);
    private bool TryGetCount(InterlockedLongCounter counter, Int64& metricCount);
    public sealed virtual void ReportSupportabilityDataUsage(string api, string apiArea, long dataSent, long dataReceived);
    private void CollectSupportabilityDataUsageMetrics();
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void ReportIfLoggingDisabled();
    private void ReportIfInstrumentationIsDisabled();
}
public class NewRelic.Agent.Core.AgentHealth.AgentInfo : object {
    [CompilerGeneratedAttribute]
private string <InstallType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AzureSiteExtension>k__BackingField;
    [JsonPropertyAttribute]
public string InstallType { get; public set; }
    [JsonPropertyAttribute]
public bool AzureSiteExtension { get; public set; }
    [CompilerGeneratedAttribute]
public string get_InstallType();
    [CompilerGeneratedAttribute]
public void set_InstallType(string value);
    [CompilerGeneratedAttribute]
public bool get_AzureSiteExtension();
    [CompilerGeneratedAttribute]
public void set_AzureSiteExtension(bool value);
    public virtual string ToString();
}
public class NewRelic.Agent.Core.AgentHealth.DestinationInteractionSample : object {
    public string Api;
    public string ApiArea;
    public long BytesSent;
    public long BytesReceived;
    public DestinationInteractionSample(string api, string apiArea, long dataSent, long dataReceived);
}
public interface NewRelic.Agent.Core.AgentHealth.IAgentHealthReporter {
    public abstract virtual void ReportDotnetVersion();
    public abstract virtual void ReportAgentVersion(string agentVersion);
    public abstract virtual void ReportLibraryVersion(string assemblyName, string assemblyVersion);
    public abstract virtual void ReportTransactionEventReservoirResized(int newSize);
    public abstract virtual void ReportTransactionEventCollected();
    public abstract virtual void ReportTransactionEventsRecollected(int count);
    public abstract virtual void ReportTransactionEventsSent(int count);
    public abstract virtual void ReportCustomEventReservoirResized(int newSize);
    public abstract virtual void ReportCustomEventCollected();
    public abstract virtual void ReportCustomEventsRecollected(int count);
    public abstract virtual void ReportCustomEventsSent(int count);
    public abstract virtual void ReportErrorTraceCollected();
    public abstract virtual void ReportErrorTracesRecollected(int count);
    public abstract virtual void ReportErrorTracesSent(int count);
    public abstract virtual void ReportErrorEventSeen();
    public abstract virtual void ReportErrorEventsSent(int count);
    public abstract virtual void ReportSqlTracesRecollected(int count);
    public abstract virtual void ReportSqlTracesSent(int count);
    public abstract virtual void ReportTransactionGarbageCollected(TransactionMetricName transactionMetricName, string lastStartedSegmentName, string lastFinishedSegmentName);
    public abstract virtual void ReportWrapperShutdown(IWrapper wrapper, Method method);
    public abstract virtual void ReportIfHostIsLinuxOs();
    public abstract virtual void ReportBootIdError();
    public abstract virtual void ReportKubernetesUtilizationError();
    public abstract virtual void ReportAwsUtilizationError();
    public abstract virtual void ReportAzureUtilizationError();
    public abstract virtual void ReportPcfUtilizationError();
    public abstract virtual void ReportGcpUtilizationError();
    public abstract virtual void ReportAgentTimingMetric(string timerName, TimeSpan stopWatchElapsedMilliseconds);
    public abstract virtual void ReportSupportabilityDistributedTraceAcceptPayloadSuccess();
    public abstract virtual void ReportSupportabilityDistributedTraceAcceptPayloadException();
    public abstract virtual void ReportSupportabilityDistributedTraceAcceptPayloadParseException();
    public abstract virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredCreateBeforeAccept();
    public abstract virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredMultiple();
    public abstract virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredMajorVersion();
    public abstract virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredNull();
    public abstract virtual void ReportSupportabilityDistributedTraceAcceptPayloadIgnoredUntrustedAccount();
    public abstract virtual void ReportSupportabilityDistributedTraceCreatePayloadSuccess();
    public abstract virtual void ReportSupportabilityDistributedTraceCreatePayloadException();
    public abstract virtual void ReportSupportabilityTraceContextAcceptSuccess();
    public abstract virtual void ReportSupportabilityTraceContextCreateSuccess();
    public abstract virtual void ReportSupportabilityTraceContextAcceptException();
    public abstract virtual void ReportSupportabilityTraceContextTraceParentParseException();
    public abstract virtual void ReportSupportabilityTraceContextTraceStateParseException();
    public abstract virtual void ReportSupportabilityTraceContextCreateException();
    public abstract virtual void ReportSupportabilityTraceContextTraceStateInvalidNrEntry();
    public abstract virtual void ReportSupportabilityTraceContextTraceStateNoNrEntry();
    public abstract virtual void ReportSupportabilityCollectorErrorException(string endpointMethod, TimeSpan responseDuration, Nullable`1<HttpStatusCode> statusCode);
    public abstract virtual void ReportSpanEventCollected(int count);
    public abstract virtual void ReportSpanEventsSent(int count);
    public abstract virtual void CollectDistributedTraceSuccessMetrics();
    public abstract virtual void ReportSupportabilityPayloadsDroppeDueToMaxPayloadSizeLimit(string endpoint);
    public abstract virtual void ReportAgentInfo();
    public abstract virtual void ReportSupportabilityCountMetric(string metricName, long count);
    public abstract virtual void ReportCountMetric(string metricName, long count);
    public abstract virtual void ReportInfiniteTracingSpanResponseError();
    public abstract virtual void ReportInfiniteTracingSpanEventsSeen(long count);
    public abstract virtual void ReportInfiniteTracingSpanEventsSent(long count);
    public abstract virtual void ReportInfiniteTracingSpanEventsReceived(ulong count);
    public abstract virtual void ReportInfiniteTracingSpanEventsDropped(long count);
    public abstract virtual void ReportInfiniteTracingSpanGrpcError(string status);
    public abstract virtual void ReportInfiniteTracingSpanGrpcTimeout();
    public abstract virtual void ReportInfiniteTracingSpanQueueSize(int queueSize);
    public abstract virtual void ReportSupportabilityDataUsage(string api, string apiArea, long dataSent, long dataReceived);
    public abstract virtual void IncrementLogLinesCount(string logLevel);
    public abstract virtual void IncrementLogDeniedCount(string logLevel);
    public abstract virtual void ReportLoggingEventCollected();
    public abstract virtual void ReportLoggingEventsSent(int count);
    public abstract virtual void ReportLoggingEventsDropped(int droppedCount);
    public abstract virtual void ReportLogForwardingFramework(string logFramework);
    public abstract virtual void ReportLogForwardingEnabledWithFramework(string logFramework);
    public abstract virtual void ReportByteMetric(string metricName, long totalBytes, Nullable`1<long> exclusiveBytes);
    public abstract virtual void ReportLoggingEventsEmpty(int count);
}
public static class NewRelic.Agent.Core.AgentInitializer : object {
    [CompilerGeneratedAttribute]
private static EventHandler OnExit;
    [CompilerGeneratedAttribute]
private static Action <InitializeAgent>k__BackingField;
    public static Action InitializeAgent { get; private set; }
    private static AgentInitializer();
    [CompilerGeneratedAttribute]
public static void add_OnExit(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_OnExit(EventHandler value);
    [CompilerGeneratedAttribute]
public static Action get_InitializeAgent();
    [CompilerGeneratedAttribute]
private static void set_InitializeAgent(Action value);
}
public static class NewRelic.Agent.Core.AgentInstallConfiguration : object {
    private static string NewRelicHomeEnvironmentVariable;
    private static string RuntimeDirectoryName;
    private static string NewRelicInstallPathEnvironmentVariable;
    [CompilerGeneratedAttribute]
private static bool <IsWindows>k__BackingField;
    [CompilerGeneratedAttribute]
private static DotnetFrameworkVersion <DotnetFrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetstandardPresent>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNet46OrAbove>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetCore30OrAbove>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NewRelicHome>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NewRelicInstallPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NewRelicLogDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <HomeExtensionsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <RuntimeHomeExtensionsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <InstallPathExtensionsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AppDomainName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AppDomainAppVirtualPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static AgentInfo <AgentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AgentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static long <AgentVersionTimestamp>k__BackingField;
    public static bool IsWindows { get; }
    public static DotnetFrameworkVersion DotnetFrameworkVersion { get; }
    public static bool IsNetstandardPresent { get; }
    public static bool IsNet46OrAbove { get; }
    public static bool IsNetCore30OrAbove { get; }
    public static string NewRelicHome { get; }
    public static string NewRelicInstallPath { get; }
    public static string NewRelicLogDirectory { get; }
    public static string HomeExtensionsDirectory { get; }
    public static string RuntimeHomeExtensionsDirectory { get; }
    public static string InstallPathExtensionsDirectory { get; }
    public static int ProcessId { get; }
    public static string AppDomainName { get; }
    public static string AppDomainAppVirtualPath { get; }
    public static AgentInfo AgentInfo { get; }
    public static string AgentVersion { get; }
    public static long AgentVersionTimestamp { get; }
    private static AgentInstallConfiguration();
    [CompilerGeneratedAttribute]
public static bool get_IsWindows();
    [CompilerGeneratedAttribute]
public static DotnetFrameworkVersion get_DotnetFrameworkVersion();
    [CompilerGeneratedAttribute]
public static bool get_IsNetstandardPresent();
    [CompilerGeneratedAttribute]
public static bool get_IsNet46OrAbove();
    [CompilerGeneratedAttribute]
public static bool get_IsNetCore30OrAbove();
    [CompilerGeneratedAttribute]
public static string get_NewRelicHome();
    [CompilerGeneratedAttribute]
public static string get_NewRelicInstallPath();
    [CompilerGeneratedAttribute]
public static string get_NewRelicLogDirectory();
    [CompilerGeneratedAttribute]
public static string get_HomeExtensionsDirectory();
    [CompilerGeneratedAttribute]
public static string get_RuntimeHomeExtensionsDirectory();
    [CompilerGeneratedAttribute]
public static string get_InstallPathExtensionsDirectory();
    [CompilerGeneratedAttribute]
public static int get_ProcessId();
    [CompilerGeneratedAttribute]
public static string get_AppDomainName();
    [CompilerGeneratedAttribute]
public static string get_AppDomainAppVirtualPath();
    [CompilerGeneratedAttribute]
public static AgentInfo get_AgentInfo();
    [CompilerGeneratedAttribute]
public static string get_AgentVersion();
    [CompilerGeneratedAttribute]
public static long get_AgentVersionTimestamp();
    public static bool GetIsWindows();
    private static string GetAgentVersion();
    private static long GetAgentVersionTimestamp();
    private static bool GetIsNetstandardPresent();
    private static bool GetIsNet46OrAbove();
    private static bool GetIsNetCore30OrAbove();
    private static string GetNewRelicHome();
    private static string GetNewRelicInstallPath();
    public static AgentInfo GetAgentInfo();
}
public class NewRelic.Agent.Core.AgentManager : object {
    private IContainer _container;
    private ConfigurationSubscriber _configurationSubscription;
    private static IAgentManager DisabledAgentManager;
    private static AgentSingleton Singleton;
    private ThreadProfilingService _threadProfilingService;
    private IWrapperService _wrapperService;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _shutdownEventReceived;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isInitialized;
    public static IAgentManager Instance { get; }
    private IConfiguration Configuration { get; }
    private static AgentManager();
    public static IAgentManager get_Instance();
    private IConfiguration get_Configuration();
    private void AssertAgentEnabled();
    private void Initialize(bool serverlessModeEnabled);
    private void LogInitialized();
    private void StartServices();
    private void StopServices();
    public sealed virtual ITracer GetTracerImpl(string tracerFactoryName, UInt32 tracerArguments, string metricName, string assemblyName, Type type, string typeName, string methodName, string argumentSignature, object invocationTarget, Object[] arguments, ulong functionId);
    private void ProcessExit(object sender, EventArgs e);
    private void Shutdown(bool cleanShutdown);
    public sealed virtual void Dispose();
    private void OnShutdownAgent(KillAgentEvent eventData);
}
public class NewRelic.Agent.Core.AgentShim : object {
    private static bool _initialized;
    private static object _initLock;
    private static HashSet`1<string> _deferInitializationOnTheseMethods;
    private static bool _deferAgentInitMethodListInitialized;
    private static object _methodListInitLock;
    private static HashSet`1<string> DeferInitializationOnTheseMethods { get; }
    private static AgentShim();
    private static void Initialize();
    private static bool TryInitialize(string method);
    private static HashSet`1<string> get_DeferInitializationOnTheseMethods();
    private static void InitializeDeferAgentInitMethodList();
    private static bool DeferInitialization(string method);
    public static Action`2<object, Exception> GetFinishTracerDelegate(string tracerFactoryName, UInt32 tracerArguments, string metricName, string assemblyName, Type type, string typeName, string methodName, string argumentSignature, object invocationTarget, Object[] args, ulong functionId);
    public static ITracer GetTracer(string tracerFactoryName, UInt32 tracerArguments, string metricName, string assemblyName, Type type, string typeName, string methodName, string argumentSignature, object invocationTarget, Object[] args, ulong functionId);
    public static void FinishTracer(object tracerObject, object returnValue, object exceptionObject);
    private static void NoOpFinishTracer(object value, Exception exception);
}
public abstract class NewRelic.Agent.Core.Aggregators.AbstractAggregator`1 : ConfigurationBasedService {
    protected IDataTransportService DataTransportService;
    protected IServerlessModeDataTransportService ServerlessModeDataTransportService;
    private IScheduler _scheduler;
    private IProcessStatic _processStatic;
    protected bool IsEnabled { get; }
    protected TimeSpan HarvestCycle { get; }
    protected AbstractAggregator`1(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic);
    private void OnManualHarvest(ManualHarvestEvent manualHarvestEvent);
    private void OnStopHarvestEvent(StopHarvestEvent obj);
    public abstract virtual void Collect(T wireModel);
    protected abstract virtual void Harvest();
    protected abstract virtual void ManualHarvest(string transactionId);
    protected abstract virtual bool get_IsEnabled();
    protected virtual TimeSpan get_HarvestCycle();
    private void OnAgentConnected(AgentConnectedEvent _);
    private void OnPreCleanShutdown(PreCleanShutdownEvent obj);
    public virtual void Dispose();
}
public class NewRelic.Agent.Core.Aggregators.CustomEventAggregator : AbstractAggregator`1<CustomEventWireModel> {
    private static double ReservoirReductionSizeMultiplier;
    private IAgentHealthReporter _agentHealthReporter;
    private ReaderWriterLockSlim _readerWriterLockSlim;
    private ConcurrentPriorityQueue`1<PrioritizedNode`1<CustomEventWireModel>> _customEvents;
    protected TimeSpan HarvestCycle { get; }
    protected bool IsEnabled { get; }
    public CustomEventAggregator(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic, IAgentHealthReporter agentHealthReporter);
    public virtual void Dispose();
    protected virtual TimeSpan get_HarvestCycle();
    protected virtual bool get_IsEnabled();
    public virtual void Collect(CustomEventWireModel customEventWireModel);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private ConcurrentPriorityQueue`1<PrioritizedNode`1<CustomEventWireModel>> GetAndResetCollection(int customEventCollectionCapacity);
    private void HandleResponse(DataTransportResponseStatus responseStatus, ICollection`1<CustomEventWireModel> customEvents);
    private void RetainEvents(IEnumerable`1<CustomEventWireModel> customEvents);
    private void ReduceReservoirSize(int newSize);
}
public class NewRelic.Agent.Core.Aggregators.ErrorEventAggregator : AbstractAggregator`1<ErrorEventWireModel> {
    private IAgentHealthReporter _agentHealthReporter;
    private ReaderWriterLockSlim _readerWriterLock;
    private ConcurrentPriorityQueue`1<PrioritizedNode`1<ErrorEventWireModel>> _errorEvents;
    private ConcurrentList`1<ErrorEventWireModel> _syntheticsErrorEvents;
    private static double ReservoirReductionSizeMultiplier;
    protected TimeSpan HarvestCycle { get; }
    protected bool IsEnabled { get; }
    public ErrorEventAggregator(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic, IAgentHealthReporter agentHealthReporter);
    protected virtual TimeSpan get_HarvestCycle();
    protected virtual bool get_IsEnabled();
    public virtual void Dispose();
    public virtual void Collect(ErrorEventWireModel errorEventWireModel);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void ResetCollections(int errorEventCollectionCapacity);
    private ConcurrentPriorityQueue`1<PrioritizedNode`1<ErrorEventWireModel>> GetAndResetErrorEvents(int errorEventCollectionCapacity);
    private ConcurrentList`1<ErrorEventWireModel> GetAndResetSyntheticsErrorEvents();
    private void AddEventToCollection(ErrorEventWireModel errorEvent);
    private int GetReservoirSize();
    private void ReduceReservoirSize(int newSize);
    private void HandleResponse(DataTransportResponseStatus responseStatus, ICollection`1<ErrorEventWireModel> errorEvents);
    private void RetainEvents(IEnumerable`1<ErrorEventWireModel> errorEvents);
}
public class NewRelic.Agent.Core.Aggregators.ErrorTraceAggregator : AbstractAggregator`1<ErrorTraceWireModel> {
    private ReaderWriterLockSlim _readerWriterLock;
    private ICollection`1<ErrorTraceWireModel> _errorTraceWireModels;
    private UInt32 _errorTraceCollectionMaximum;
    private IAgentHealthReporter _agentHealthReporter;
    protected TimeSpan HarvestCycle { get; }
    protected bool IsEnabled { get; }
    public ErrorTraceAggregator(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic, IAgentHealthReporter agentHealthReporter);
    public virtual void Dispose();
    protected virtual TimeSpan get_HarvestCycle();
    protected virtual bool get_IsEnabled();
    public virtual void Collect(ErrorTraceWireModel errorTraceWireModel);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private ICollection`1<ErrorTraceWireModel> GetAndResetCollection();
    private void AddToCollection(ErrorTraceWireModel errorTraceWireModel);
    private void Retain(IEnumerable`1<ErrorTraceWireModel> errorTraceWireModels);
    private void HandleResponse(DataTransportResponseStatus responseStatus, ICollection`1<ErrorTraceWireModel> errorTraceWireModels);
}
public class NewRelic.Agent.Core.Aggregators.EventHarvestData : ValueType {
    [CompilerGeneratedAttribute]
private int <ReservoirSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventsSeen>k__BackingField;
    [JsonPropertyAttribute("reservoir_size")]
public int ReservoirSize { get; private set; }
    [JsonPropertyAttribute("events_seen")]
public int EventsSeen { get; private set; }
    public EventHarvestData(int reservoirSize, int eventsSeen);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ReservoirSize();
    [CompilerGeneratedAttribute]
private void set_ReservoirSize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_EventsSeen();
    [CompilerGeneratedAttribute]
private void set_EventsSeen(int value);
}
public interface NewRelic.Agent.Core.Aggregators.IAllMetricStatsCollection {
    public abstract virtual void AddMetricsToCollection(MetricStatsCollection collection);
}
public interface NewRelic.Agent.Core.Aggregators.ICustomEventAggregator {
    public abstract virtual void Collect(CustomEventWireModel customEventWireModel);
}
public interface NewRelic.Agent.Core.Aggregators.IErrorEventAggregator {
    public abstract virtual void Collect(ErrorEventWireModel errorEventWireModel);
}
public interface NewRelic.Agent.Core.Aggregators.IErrorTraceAggregator {
    public abstract virtual void Collect(ErrorTraceWireModel errorTraceWireModel);
}
public interface NewRelic.Agent.Core.Aggregators.ILogEventAggregator {
    public abstract virtual void Collect(LogEventWireModel loggingEventWireModel);
    public abstract virtual void CollectWithPriority(IList`1<LogEventWireModel> logEventWireModels, float priority);
}
public interface NewRelic.Agent.Core.Aggregators.IMetricAggregator {
    public abstract virtual void Collect(IAllMetricStatsCollection metric);
}
public interface NewRelic.Agent.Core.Aggregators.ISpanEventAggregator {
    public bool IsServiceEnabled { get; }
    public bool IsServiceAvailable { get; }
    public abstract virtual void Collect(ISpanEventWireModel wireModel);
    public abstract virtual void Collect(IEnumerable`1<ISpanEventWireModel> wireModels);
    public abstract virtual bool get_IsServiceEnabled();
    public abstract virtual bool get_IsServiceAvailable();
}
public interface NewRelic.Agent.Core.Aggregators.ISpanEventAggregatorInfiniteTracing {
    public bool IsServiceEnabled { get; }
    public bool IsServiceAvailable { get; }
    public int Capacity { get; }
    public abstract virtual void Collect(ISpanEventWireModel wireModel);
    public abstract virtual void Collect(IEnumerable`1<ISpanEventWireModel> wireModels);
    public abstract virtual bool get_IsServiceEnabled();
    public abstract virtual bool get_IsServiceAvailable();
    public abstract virtual bool HasCapacity(int proposedItems);
    public abstract virtual void RecordDroppedSpans(int countDroppedSpans);
    public abstract virtual void RecordSeenSpans(int countSeenSpans);
    public abstract virtual void ReportSupportabilityMetrics();
    public abstract virtual int get_Capacity();
}
public interface NewRelic.Agent.Core.Aggregators.ISqlTraceAggregator {
    public abstract virtual void Collect(SqlTraceStatsCollection sqlTrStats);
}
public interface NewRelic.Agent.Core.Aggregators.ITransactionEventAggregator {
    public abstract virtual void Collect(TransactionEventWireModel transactionEventWireModel);
}
public interface NewRelic.Agent.Core.Aggregators.ITransactionTraceAggregator {
    public abstract virtual void Collect(TransactionTraceWireModelComponents transactionTraceWireModel);
}
public class NewRelic.Agent.Core.Aggregators.LogEventAggregator : AbstractAggregator`1<LogEventWireModel> {
    private static double ReservoirReductionSizeMultiplier;
    private IAgentHealthReporter _agentHealthReporter;
    private ConcurrentPriorityQueue`1<PrioritizedNode`1<LogEventWireModel>> _logEvents;
    private int _logsDroppedCount;
    protected TimeSpan HarvestCycle { get; }
    protected bool IsEnabled { get; }
    public LogEventAggregator(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic, IAgentHealthReporter agentHealthReporter);
    protected virtual TimeSpan get_HarvestCycle();
    protected virtual bool get_IsEnabled();
    public virtual void Dispose();
    public virtual void Collect(LogEventWireModel loggingEventWireModel);
    public sealed virtual void CollectWithPriority(IList`1<LogEventWireModel> logEventWireModels, float priority);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void ResetCollections(int logEventCollectionCapacity);
    private ConcurrentPriorityQueue`1<PrioritizedNode`1<LogEventWireModel>> GetAndResetLogEvents(int logEventCollectionCapacity);
    private void AddEventToCollection(LogEventWireModel logEventWireModel);
    private int GetReservoirSize();
    private void ReduceReservoirSize(int newSize);
    private void HandleResponse(DataTransportResponseStatus responseStatus, ICollection`1<LogEventWireModel> logEvents);
    private void ReportDroppedLogCount();
    private void RetainEvents(IEnumerable`1<LogEventWireModel> logEvents);
}
public class NewRelic.Agent.Core.Aggregators.MetricAggregator : AbstractAggregator`1<IAllMetricStatsCollection> {
    private MetricStatsCollectionQueue _metricStatsCollectionQueue;
    private IMetricBuilder _metricBuilder;
    private IMetricNameService _metricNameService;
    private IEnumerable`1<IOutOfBandMetricSource> _outOfBandMetricSources;
    protected TimeSpan HarvestCycle { get; }
    public MetricStatsCollectionQueue StatsCollectionQueue { get; }
    protected bool IsEnabled { get; }
    public MetricAggregator(IDataTransportService dataTransportService, IMetricBuilder metricBuilder, IMetricNameService metricNameService, IEnumerable`1<IOutOfBandMetricSource> outOfBandMetricSources, IProcessStatic processStatic, IScheduler scheduler);
    protected virtual TimeSpan get_HarvestCycle();
    public MetricStatsCollectionQueue get_StatsCollectionQueue();
    protected virtual bool get_IsEnabled();
    public virtual void Collect(IAllMetricStatsCollection metric);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void HandleResponse(DataTransportResponseStatus responseStatus, IEnumerable`1<MetricWireModel> unsuccessfulSendMetrics);
    private void RetainMetricData(IEnumerable`1<MetricWireModel> unsuccessfulSendMetrics);
    private MetricStatsCollection GetStatsCollectionForHarvest();
    private MetricStatsCollectionQueue ReplaceStatsCollectionQueue();
    private MetricStatsCollectionQueue CreateMetricStatsCollectionQueue();
}
public class NewRelic.Agent.Core.Aggregators.MetricStatsCollection : object {
    private MetricStatsDictionary`2<string, MetricDataWireModel> _unscopedStats;
    private Dictionary`2<string, MetricStatsDictionary`2<string, MetricDataWireModel>> _scopedStats;
    private Func`3<MetricDataWireModel, MetricDataWireModel, MetricDataWireModel> _mergeFunction;
    public void Merge(MetricStatsCollection engine);
    public void MergeUnscopedStats(IEnumerable`1<KeyValuePair`2<string, MetricDataWireModel>> unscoped);
    public void MergeUnscopedStats(string name, MetricDataWireModel metric);
    public void MergeScopedStats(string scope, string name, MetricDataWireModel metric);
    public void MergeScopedStats(string scope, IEnumerable`1<KeyValuePair`2<string, MetricDataWireModel>> metrics);
    [IteratorStateMachineAttribute("NewRelic.Agent.Core.Aggregators.MetricStatsCollection/<ConvertToJsonForSending>d__8")]
public IEnumerable`1<MetricWireModel> ConvertToJsonForSending(IMetricNameService nameService);
}
public class NewRelic.Agent.Core.Aggregators.MetricStatsCollectionQueue : object {
    private ConcurrentQueue`1<MetricStatsCollection> _statsCollectionQueue;
    public bool MergeMetrics(IAllMetricStatsCollection metrics);
    private void AddMetricsToCollection(ConcurrentQueue`1<MetricStatsCollection> statsCollectionQueue, IAllMetricStatsCollection metrics);
    public MetricStatsCollection GetStatsCollectionForHarvest();
}
public class NewRelic.Agent.Core.Aggregators.MetricStatsDictionary`2 : Dictionary`2<TKey, TValue> {
    public MetricStatsDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> keyValuesPairs);
    public void Merge(TKey key, TValue value, Func`3<TValue, TValue, TValue> mergeFunction);
    public void Merge(IEnumerable`1<KeyValuePair`2<TKey, TValue>> metricsToMerge, Func`3<TValue, TValue, TValue> mergeFunction);
}
public class NewRelic.Agent.Core.Aggregators.SpanEventAggregator : AbstractAggregator`1<ISpanEventWireModel> {
    private static double ReservoirReductionSizeMultiplier;
    private IAgentHealthReporter _agentHealthReporter;
    private ReaderWriterLockSlim _readerWriterLockSlim;
    private ConcurrentPriorityQueue`1<PrioritizedNode`1<ISpanEventWireModel>> _spanEvents;
    protected TimeSpan HarvestCycle { get; }
    protected bool IsEnabled { get; }
    public bool IsServiceEnabled { get; }
    public bool IsServiceAvailable { get; }
    public SpanEventAggregator(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic, IAgentHealthReporter agentHealthReporter);
    protected virtual TimeSpan get_HarvestCycle();
    protected virtual bool get_IsEnabled();
    public sealed virtual bool get_IsServiceEnabled();
    public sealed virtual bool get_IsServiceAvailable();
    private ConcurrentPriorityQueue`1<PrioritizedNode`1<ISpanEventWireModel>> GetAndResetCollection();
    private int AddWireModels(IEnumerable`1<ISpanEventWireModel> wireModels);
    public virtual void Dispose();
    public virtual void Collect(ISpanEventWireModel wireModel);
    public sealed virtual void Collect(IEnumerable`1<ISpanEventWireModel> wireModels);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    private void ReduceReservoirSize(int newSize);
    private void RetainEvents(IEnumerable`1<ISpanEventWireModel> wireModels);
    private void HandleResponse(DataTransportResponseStatus responseStatus, ICollection`1<ISpanEventWireModel> spanEvents);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
public class NewRelic.Agent.Core.Aggregators.SpanEventAggregatorInfiniteTracing : DisposableService {
    private PartitionedBlockingCollection`1<Span> _spanEvents;
    private IDataStreamingService`3<Span, SpanBatch, RecordStatus> _spanStreamingService;
    private IAgentHealthReporter _agentHealthReporter;
    private IConfigurationService _configSvc;
    private IScheduler _schedulerSvc;
    private IConfiguration _configuration { get; }
    public int Capacity { get; }
    public bool IsServiceEnabled { get; }
    public bool IsServiceAvailable { get; }
    public SpanEventAggregatorInfiniteTracing(IDataStreamingService`3<Span, SpanBatch, RecordStatus> spanStreamingService, IConfigurationService configSvc, IAgentHealthReporter agentHealthReporter, IScheduler scheduler);
    private IConfiguration get__configuration();
    public sealed virtual int get_Capacity();
    private void AgentConnected(AgentConnectedEvent _);
    private void OnPreCleanShutdown(PreCleanShutdownEvent obj);
    public sealed virtual void ReportSupportabilityMetrics();
    public sealed virtual bool HasCapacity(int proposedItems);
    private void LogConfiguration();
    public sealed virtual bool get_IsServiceEnabled();
    public sealed virtual bool get_IsServiceAvailable();
    public sealed virtual void RecordDroppedSpans(int countDroppedSpans);
    public sealed virtual void RecordSeenSpans(int countSeenSpans);
    public sealed virtual void Collect(ISpanEventWireModel wireModel);
    public sealed virtual void Collect(IEnumerable`1<ISpanEventWireModel> wireModels);
}
public class NewRelic.Agent.Core.Aggregators.SqlTraceAggregator : AbstractAggregator`1<SqlTraceStatsCollection> {
    private SqlTraceStatsCollection _sqlTraceStats;
    private object _sqlTraceLock;
    private IAgentHealthReporter _agentHealthReporter;
    protected TimeSpan HarvestCycle { get; }
    protected bool IsEnabled { get; }
    public SqlTraceAggregator(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic, IAgentHealthReporter agentHealthReporter);
    protected virtual TimeSpan get_HarvestCycle();
    protected virtual bool get_IsEnabled();
    public virtual void Collect(SqlTraceStatsCollection sqlTraceStats);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    private void HandleResponse(DataTransportResponseStatus responseStatus, ICollection`1<SqlTraceWireModel> traces);
    private void Retain(ICollection`1<SqlTraceWireModel> traces);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
public class NewRelic.Agent.Core.Aggregators.SqlTraceStatsCollection : object {
    private IDictionary`2<long, SqlTraceWireModel> _sqlTraceWireModels;
    private int _maxTraces;
    private int _tracesCollected;
    private SqlTraceWireModel _shortestMax;
    public IDictionary`2<long, SqlTraceWireModel> Collection { get; }
    public int TracesCollected { get; }
    public SqlTraceStatsCollection(int maxTraces);
    public IDictionary`2<long, SqlTraceWireModel> get_Collection();
    public int get_TracesCollected();
    public void Merge(SqlTraceStatsCollection newTraces);
    public void Insert(SqlTraceWireModel newSqlTrace);
    private void TryAdd(SqlTraceWireModel newSqlTrace);
}
public class NewRelic.Agent.Core.Aggregators.TransactionEventAggregator : AbstractAggregator`1<TransactionEventWireModel> {
    private IAgentHealthReporter _agentHealthReporter;
    private ReaderWriterLockSlim _readerWriterLock;
    private IResizableCappedCollection`1<PrioritizedNode`1<TransactionEventWireModel>> _transactionEvents;
    private ConcurrentList`1<TransactionEventWireModel> _syntheticsTransactionEvents;
    private static double ReservoirReductionSizeMultiplier;
    protected TimeSpan HarvestCycle { get; }
    protected bool IsEnabled { get; }
    public TransactionEventAggregator(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic, IAgentHealthReporter agentHealthReporter);
    protected virtual TimeSpan get_HarvestCycle();
    protected virtual bool get_IsEnabled();
    public virtual void Dispose();
    public virtual void Collect(TransactionEventWireModel transactionEventWireModel);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void ResetCollections(int transactionEventCollectionCapacity);
    private IResizableCappedCollection`1<PrioritizedNode`1<TransactionEventWireModel>> GetAndResetRegularTransactionEvents(int transactionEventCollectionCapacity);
    private ConcurrentList`1<TransactionEventWireModel> GetAndResetSyntheticsTransactionEvents();
    private void AddEventToCollection(TransactionEventWireModel transactionEvent);
    private void HandleResponse(DataTransportResponseStatus responseStatus, ICollection`1<TransactionEventWireModel> transactionEvents);
    private void RetainEvents(IEnumerable`1<TransactionEventWireModel> transactionEvents);
    private int GetReservoirSize();
    private void ReduceReservoirSize(int newSize);
}
public class NewRelic.Agent.Core.Aggregators.TransactionMetricStatsCollection : object {
    private MetricStatsDictionary`2<MetricName, MetricDataWireModel> unscopedStats;
    private MetricStatsDictionary`2<MetricName, MetricDataWireModel> scopedStats;
    private TransactionMetricName transactionName;
    private Func`3<MetricDataWireModel, MetricDataWireModel, MetricDataWireModel> mergeFunction;
    public TransactionMetricStatsCollection(TransactionMetricName txName);
    public TransactionMetricName GetTransactionName();
    public MetricDataWireModel GetUnscopedStat(MetricName name);
    public void MergeUnscopedStats(MetricName name, MetricDataWireModel metric);
    public void MergeScopedStats(MetricName name, MetricDataWireModel metric);
    public sealed virtual void AddMetricsToCollection(MetricStatsCollection collection);
    [IteratorStateMachineAttribute("NewRelic.Agent.Core.Aggregators.TransactionMetricStatsCollection/<ConvertMetricNames>d__10")]
private IEnumerable`1<KeyValuePair`2<string, MetricDataWireModel>> ConvertMetricNames(IEnumerable`1<KeyValuePair`2<MetricName, MetricDataWireModel>> metricData);
    public MetricStatsDictionary`2<string, MetricDataWireModel> GetUnscopedForTesting();
    public MetricStatsDictionary`2<string, MetricDataWireModel> GetScopedForTesting();
}
public class NewRelic.Agent.Core.Aggregators.TransactionTraceAggregator : AbstractAggregator`1<TransactionTraceWireModelComponents> {
    private IEnumerable`1<ITransactionCollector> _transactionCollectors;
    protected bool IsEnabled { get; }
    protected TimeSpan HarvestCycle { get; }
    public TransactionTraceAggregator(IDataTransportService dataTransportService, IScheduler scheduler, IProcessStatic processStatic, IEnumerable`1<ITransactionCollector> transactionCollectors);
    protected virtual bool get_IsEnabled();
    protected virtual TimeSpan get_HarvestCycle();
    public virtual void Collect(TransactionTraceWireModelComponents transactionTraceWireModel);
    protected virtual void ManualHarvest(string transactionId);
    protected virtual void Harvest();
    protected void InternalHarvest(string transactionId);
    private void HandleResponse(DataTransportResponseStatus responseStatus, ICollection`1<TransactionTraceWireModelComponents> traceSamples);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void LogUnencodedTraceData(IEnumerable`1<TransactionTraceWireModel> samples);
    private static string SerializeTransactionTraceData(TransactionTraceWireModel transactionTraceWireModel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NewRelic.Agent.Core.Api.AgentApiImplementation : object {
    private static Char[] TrimPathChar;
    private static string CustomMetricNamePrefixAndSeparator;
    private static string DistributedTracingIsEnabledIgnoringCall;
    private static string NoticeErrorPath;
    private ITransactionService _transactionService;
    private ICustomEventTransformer _customEventTransformer;
    private IMetricBuilder _metricBuilder;
    private IMetricAggregator _metricAggregator;
    private ICustomErrorDataTransformer _customErrorDataTransformer;
    private IBrowserMonitoringPrereqChecker _browserMonitoringPrereqChecker;
    private IBrowserMonitoringScriptMaker _browserMonitoringScriptMaker;
    private IConfigurationService _configurationService;
    private IAgent _agent;
    private AgentBridgeApi _agentBridgeApi;
    private ITracePriorityManager _tracePriorityManager;
    private IErrorService _errorService;
    public AgentApiImplementation(ITransactionService transactionService, ICustomEventTransformer customEventTransformer, IMetricBuilder metricBuilder, IMetricAggregator metricAggregator, ICustomErrorDataTransformer customErrorDataTransformer, IBrowserMonitoringPrereqChecker browserMonitoringPrereqChecker, IBrowserMonitoringScriptMaker browserMonitoringScriptMaker, IConfigurationService configurationService, IAgent agent, ITracePriorityManager tracePriorityManager, IApiSupportabilityMetricCounters apiSupportabilityMetricCounters, IErrorService errorService);
    private static AgentApiImplementation();
    public sealed virtual void InitializePublicAgent(object publicAgent);
    public sealed virtual void RecordCustomEvent(string eventType, IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    public sealed virtual void RecordMetric(string name, float value);
    public sealed virtual void RecordResponseTimeMetric(string name, long millis);
    public sealed virtual void IncrementCounter(string name);
    public sealed virtual void NoticeError(Exception exception, IDictionary`2<string, string> customAttributes);
    public sealed virtual void NoticeError(Exception exception, IDictionary`2<string, object> customAttributes);
    public sealed virtual void NoticeError(Exception exception);
    public sealed virtual void NoticeError(string message, IDictionary`2<string, string> customAttributes);
    public sealed virtual void NoticeError(string message, IDictionary`2<string, string> customAttributes, bool isExpected);
    public sealed virtual void NoticeError(string message, IDictionary`2<string, object> customAttributes);
    public sealed virtual void NoticeError(string message, IDictionary`2<string, object> customAttributes, bool isExpected);
    private void ProcessNoticedError(ErrorData errorData, IInternalTransaction transaction);
    private bool IsCustomExceptionIgnored(Exception exception, IInternalTransaction transaction);
    private bool IsErrorMessageIgnored(string message);
    [ToBeRemovedInFutureReleaseAttribute("Use TransactionBridgeApi.AddCustomAttribute(string, object) instead")]
public void AddCustomParameter(string key, IConvertible value);
    [ToBeRemovedInFutureReleaseAttribute("Use TransactionBridgeApi.AddCustomAttribute(string, object) instead")]
public void AddCustomParameter(string key, string value);
    [ToBeRemovedInFutureReleaseAttribute("Use TransactionBridgeApi.AddCustomAttribute(string, object) instead")]
private void AddUserAttributeToCurrentTransaction(string key, object value);
    public sealed virtual void SetTransactionName(string category, string name);
    public sealed virtual void SetTransactionUri(Uri uri);
    [NullableContextAttribute("2")]
public sealed virtual void SetUserParameters(string userName, string accountName, string productName);
    public sealed virtual void IgnoreTransaction();
    public sealed virtual void IgnoreApdex();
    public sealed virtual string GetBrowserTimingHeader();
    public sealed virtual string GetBrowserTimingHeader(string nonce);
    public sealed virtual void DisableBrowserMonitoring(bool overrideManual);
    public sealed virtual void StartAgent();
    [NullableContextAttribute("2")]
public sealed virtual void SetApplicationName(string applicationName, string applicationName2, string applicationName3);
    private IInternalTransaction TryGetCurrentInternalTransaction();
    private IInternalTransaction GetCurrentInternalTransaction();
    private static string GetCustomMetricSuffix(string name);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> GetRequestMetadata();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> GetResponseMetadata();
    public sealed virtual void SetErrorGroupCallback(Func`2<IReadOnlyDictionary`2<string, object>, string> callback);
    public sealed virtual void SetLlmTokenCountingCallback(Func`3<string, string, int> callback);
    public sealed virtual void RecordLlmFeedbackEvent(string traceId, object rating, string category, string message, IDictionary`2<string, object> metadata);
}
public class NewRelic.Agent.Core.Api.AgentBridgeApi : object {
    private IAgent _agent;
    private IApiSupportabilityMetricCounters _apiSupportabilityMetricCounters;
    private IConfigurationService _configSvc;
    public TransactionBridgeApi CurrentTransaction { get; }
    public object TraceMetadata { get; }
    public AgentBridgeApi(IAgent agent, IApiSupportabilityMetricCounters apiSupportabilityMetricCounters, IConfigurationService configSvc);
    public TransactionBridgeApi get_CurrentTransaction();
    public object get_TraceMetadata();
    public Dictionary`2<string, string> GetLinkingMetadata();
}
public class NewRelic.Agent.Core.Api.DistributedTraceApiModel : object {
    public static DistributedTraceApiModel EmptyModel;
    private Lazy`1<string> _text;
    private bool _isEmpty;
    private string _httpSafe;
    public DistributedTraceApiModel(string encodedPayload);
    private static DistributedTraceApiModel();
    public sealed virtual string HttpSafe();
    public sealed virtual string Text();
    public sealed virtual bool IsEmpty();
}
public interface NewRelic.Agent.Core.Api.ITraceMetadataFactory {
    public abstract virtual ITraceMetadata CreateTraceMetadata(IInternalTransaction transaction);
}
public class NewRelic.Agent.Core.Api.SpanBridgeApi : object {
    private ISpan _span;
    private IApiSupportabilityMetricCounters _apiSupportabilityMetricCounters;
    private IConfigurationService _configSvc;
    public SpanBridgeApi(ISpan span, IApiSupportabilityMetricCounters apiSupportabilityMetricCounters, IConfigurationService configSvc);
    public object AddCustomAttribute(string key, object value);
    public object SetName(string name);
}
public class NewRelic.Agent.Core.Api.TraceMetadata : object {
    public static ITraceMetadata EmptyModel;
    [CompilerGeneratedAttribute]
private string <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpanId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSampled>k__BackingField;
    public string TraceId { get; private set; }
    public string SpanId { get; private set; }
    public bool IsSampled { get; private set; }
    public TraceMetadata(string traceId, string spanId, bool isSampled);
    private static TraceMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TraceId();
    [CompilerGeneratedAttribute]
private void set_TraceId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SpanId();
    [CompilerGeneratedAttribute]
private void set_SpanId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSampled();
    [CompilerGeneratedAttribute]
private void set_IsSampled(bool value);
}
public class NewRelic.Agent.Core.Api.TraceMetadataFactory : object {
    private IAdaptiveSampler _adaptiveSampler;
    public TraceMetadataFactory(IAdaptiveSampler adaptiveSampler);
    public sealed virtual ITraceMetadata CreateTraceMetadata(IInternalTransaction transaction);
    private bool SetIsSampled(IInternalTransaction transaction);
}
public class NewRelic.Agent.Core.Api.TransactionBridgeApi : object {
    public static TransportType[] TransportTypeMapping;
    private ITransaction _transaction;
    private IApiSupportabilityMetricCounters _apiSupportabilityMetricCounters;
    private IConfigurationService _configSvc;
    public SpanBridgeApi CurrentSpan { get; }
    public TransactionBridgeApi(ITransaction transaction, IApiSupportabilityMetricCounters apiSupportabilityMetricCounters, IConfigurationService configSvc);
    private static TransactionBridgeApi();
    [ObsoleteAttribute("This method does nothing in version 9.x+ of the Agent.")]
public object CreateDistributedTracePayload();
    [ObsoleteAttribute("This method does nothing in version 9.x+ of the Agent")]
public void AcceptDistributedTracePayload(string payload, int transportType);
    public void InsertDistributedTraceHeaders(T carrier, Action`3<T, string, string> setter);
    public void AcceptDistributedTraceHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, int transportType);
    private static TransportType GetTransportTypeValue(int transportType);
    public object AddCustomAttribute(string key, object value);
    public SpanBridgeApi get_CurrentSpan();
    public void SetUserId(string userid);
    public ISegment StartDatastoreSegment(string vendor, string model, string operation, string commandText, string host, string portPathOrID, string databaseName);
}
public class NewRelic.Agent.Core.AssemblyLoading.AssemblyResolutionService : object {
    public sealed virtual void Dispose();
    private static Assembly OnAssemblyResolutionFailure(object sender, ResolveEventArgs args);
    private static Assembly TryGetAlreadyLoadedAssemblyFromFullName(string fullAssemblyName);
    private static Assembly TryGetAlreadyLoadedAssemblyBySimpleName(string simpleAssemblyName);
    private static bool IsWrapperServiceOrTracerInStack();
    private static Type GetFrameType(StackFrame stackFrame);
    private static bool IsNewRelicType(Type type);
}
public enum NewRelic.Agent.Core.Attributes.AttributeClassification : Enum {
    public int value__;
    public static AttributeClassification AgentAttributes;
    public static AttributeClassification UserAttributes;
    public static AttributeClassification Intrinsics;
}
[DebuggerDisplayAttribute("{Name}-{Classification}")]
public class NewRelic.Agent.Core.Attributes.AttributeDefinition : object {
    public static string KeyName_Guid;
    public static string KeyName_TraceId;
    private static int _attribNameMaxLengthBytes;
    public Guid Guid;
    public string Name;
    public AttributeClassification Classification;
    public AttributeDestinations AttributeDestinations;
    protected Dictionary`2<AttributeDestinations, bool> _availability;
    private Nullable`1<bool> _isDefinitionValid;
    public bool IsDefinitionValid { get; }
    public AttributeDefinition(string name, AttributeClassification classification, Dictionary`2<AttributeDestinations, bool> availability);
    public bool IsAvailableForAny(AttributeDestinations[] targetModels);
    public bool get_IsDefinitionValid();
    private bool ValidateDefinition();
    protected void HandleNullValue();
}
public class NewRelic.Agent.Core.Attributes.AttributeDefinition`2 : AttributeDefinition {
    private Func`2<TInput, TOutput> _conversionImpl;
    private TOutput _defaultOutput;
    private Func`2<TOutput, TOutput> _postProcessingImpl;
    public AttributeDefinition`2(string name, AttributeClassification classification, Dictionary`2<AttributeDestinations, bool> availability, Func`2<TInput, TOutput> conversionImpl, TOutput defaultOutputVal, Func`2<TOutput, TOutput> postProcessingImpl);
    public bool TrySetValue(IAttributeValueCollection collection, Func`1<TInput> getInputValFx);
    public bool TrySetValue(IAttributeValueCollection collection, TInput sourceVal);
    public bool TrySetDefault(IAttributeValueCollection collection);
    private object ResolveLazyValue(Func`1<TInput> getInputValFx);
}
public static class NewRelic.Agent.Core.Attributes.AttributeDefinitionBuilder : object {
    private static int StringValueMaxLengthBytes;
    private static int ErrorMessageMaxLengthBytes;
    public static AttributeDefinitionBuilder`2<TInput, TOutput> Create(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<TValue, TValue> Create(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<TInput, string> CreateString(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<string, string> CreateString(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<string, string> CreateErrorMessage(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<TInput, double> CreateDouble(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<double, double> CreateDouble(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<TInput, bool> CreateBool(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<bool, bool> CreateBool(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<TInput, long> CreateLong(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<long, long> CreateLong(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<int, int> CreateInt(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<string, string> CreateDBStatement(string name, AttributeClassification classification);
    public static AttributeDefinitionBuilder`2<object, object> CreateCustomAttribute(string name, AttributeDestinations destination);
    private static string TruncateDatastoreStatement(string statement, int maxSizeBytes);
}
public class NewRelic.Agent.Core.Attributes.AttributeDefinitionBuilder`2 : object {
    private static AttributeDestinations[] AttribDestinationValues;
    private string _name;
    private AttributeClassification _classification;
    private TOutput _defaultOutputVal;
    private TInput _defaultInputVal;
    private Dictionary`2<AttributeDestinations, bool> _availability;
    private Func`2<TInput, TOutput> _conversionImpl;
    private Func`2<TOutput, TOutput> _postProcessingImpl;
    private AttributeDestinations _destinations;
    public AttributeDefinitionBuilder`2(string name, AttributeClassification classification);
    private static AttributeDefinitionBuilder`2();
    public AttributeDefinitionBuilder`2<TInput, TOutput> WithDefaultOutputValue(TOutput defaultOutputVal);
    public AttributeDefinitionBuilder`2<TInput, TOutput> WithDefaultInputValue(TInput defaultInputVal);
    public AttributeDefinitionBuilder`2<TInput, TOutput> AppliesTo(AttributeDestinations[] destinations);
    public AttributeDefinitionBuilder`2<TInput, TOutput> AppliesTo(AttributeDestinations destination, bool isAvailable);
    private void UpdateDestinationsFlags();
    public AttributeDefinitionBuilder`2<TInput, TOutput> WithConvert(Func`2<TInput, TOutput> convertValueImpl);
    public AttributeDefinitionBuilder`2<TInput, TOutput> WithPostProcessing(Func`2<TOutput, TOutput> postProcessingImpl);
    public AttributeDefinition`2<TInput, TOutput> Build(IAttributeFilter filter);
}
public class NewRelic.Agent.Core.Attributes.AttributeDefinitions : object {
    private IAttributeFilter _attribFilter;
    private ConcurrentDictionary`2<string, AttributeDefinition`2<object, object>> _trxCustomAttributes;
    private ConcurrentDictionary`2<string, AttributeDefinition`2<object, object>> _spanCustomAttributes;
    private ConcurrentDictionary`2<string, AttributeDefinition`2<object, object>> _errorCustomAttributes;
    private ConcurrentDictionary`2<string, AttributeDefinition`2<object, object>> _customEventCustomAttributes;
    private ConcurrentDictionary`2<string, AttributeDefinition`2<string, string>> _requestParameterAttributes;
    private ConcurrentDictionary`2<string, AttributeDefinition`2<string, string>> _requestHeadersAttributes;
    private ConcurrentDictionary`2<string, AttributeDefinition`2<object, object>> _lambdaAttributes;
    private ConcurrentDictionary`2<string, AttributeDefinition`2<object, object>> _faasAttributes;
    private ConcurrentDictionary`2<TypeAttributeValue, AttributeDefinition`2<TypeAttributeValue, string>> _typeAttributes;
    private AttributeDefinition`2<Nullable`1<TimeSpan>, string> _queueWaitTime;
    private AttributeDefinition`2<Nullable`1<TimeSpan>, double> _queueDuration;
    private AttributeDefinition`2<string, string> _originalUrl;
    private AttributeDefinition`2<string, string> _requestMethod;
    private AttributeDefinition`2<string, string> _requestUri;
    private AttributeDefinition`2<string, string> _requestReferrer;
    [ToBeRemovedInFutureReleaseAttribute("To be removed v9+. Use BuildHttpStatusCodeAttribute instead.")]
private AttributeDefinition`2<Nullable`1<int>, string> _responseStatus;
    private AttributeDefinition`2<Nullable`1<long>, long> _httpStatusCode;
    private AttributeDefinition`2<string, string> _clientCrossProcessId;
    private AttributeDefinition`2<string, string> _tripId;
    private AttributeDefinition`2<string, string> _catNrTripId;
    private AttributeDefinition`2<string, string> _browserTripId;
    private AttributeDefinition`2<string, string> _catPathHash;
    private AttributeDefinition`2<string, string> _catNrPathHash;
    private AttributeDefinition`2<string, string> _catReferringPathHash;
    private AttributeDefinition`2<string, string> _catReferringTransactionGuidForTraces;
    private AttributeDefinition`2<string, string> _catReferringTransactionGuidForEvents;
    private AttributeDefinition`2<IEnumerable`1<string>, string> _catAlternativePathHashes;
    private AttributeDefinition`2<string, string> _transactionId;
    private AttributeDefinition`2<string, string> _nameForSpan;
    private AttributeDefinition`2<SpanCategory, string> _spanCategory;
    private AttributeDefinition`2<bool, bool> _nrEntryPoint;
    private AttributeDefinition`2<long, long> _threadId;
    private AttributeDefinition`2<string, string> _component;
    private AttributeDefinition`2<string, string> _spanKind;
    private AttributeDefinition`2<string, string> _spanErrorClass;
    private AttributeDefinition`2<string, string> _spanErrorMessage;
    private AttributeDefinition`2<string, string> _spanId;
    private AttributeDefinition`2<string, string> _dbStatement;
    private AttributeDefinition`2<string, string> _dbSystem;
    private AttributeDefinition`2<string, string> _dbOperation;
    private AttributeDefinition`2<string, string> _dbCollection;
    private AttributeDefinition`2<string, string> _dbInstance;
    private AttributeDefinition`2<string, string> _peerAddress;
    private AttributeDefinition`2<string, string> _peerHostname;
    private AttributeDefinition`2<Uri, string> _httpUrl;
    private AttributeDefinition`2<string, string> _httpMethod;
    private AttributeDefinition`2<string, string> _serverAddress;
    private AttributeDefinition`2<long, long> _serverPort;
    private AttributeDefinition`2<string, string> _dbServerAddress;
    private AttributeDefinition`2<long, long> _dbServerPort;
    private AttributeDefinition`2<string, string> _errorEventSpanId;
    private AttributeDefinition`2<string, string> _errorType;
    private AttributeDefinition`2<string, string> _errorMessage;
    private AttributeDefinition`2<bool, bool> _isError;
    private AttributeDefinition`2<bool, bool> _isErrorExpected;
    private AttributeDefinition`2<bool, bool> _spanIsErrorExpected;
    private AttributeDefinition`2<string, string> _errorGroup;
    private AttributeDefinition`2<string, string> _endUserId;
    private AttributeDefinition`2<DateTime, long> _timestamp;
    private AttributeDefinition`2<DateTime, long> _timestampForError;
    private AttributeDefinition`2<string, string> _transactionName;
    private AttributeDefinition`2<string, string> _transactionNameForSpan;
    private AttributeDefinition`2<string, string> _transactionNameForError;
    private AttributeDefinition`2<string, string> _nrGuid;
    private AttributeDefinition`2<string, string> _guid;
    private AttributeDefinition`2<string, string> _syntheticsResourceId;
    private AttributeDefinition`2<string, string> _syntheticsResourceIdForTraces;
    private AttributeDefinition`2<string, string> _syntheticsJobId;
    private AttributeDefinition`2<string, string> _syntheticsJobIdForTraces;
    private AttributeDefinition`2<string, string> _syntheticsMonitorId;
    private AttributeDefinition`2<string, string> _syntheticsMonitorIdForTraces;
    private AttributeDefinition`2<TimeSpan, double> _duration;
    private AttributeDefinition`2<TimeSpan, double> _webDuration;
    private AttributeDefinition`2<TimeSpan, double> _totalTime;
    private AttributeDefinition`2<TimeSpan, double> _cpuTime;
    private AttributeDefinition`2<string, string> _apdexPerfZone;
    private AttributeDefinition`2<float, double> _externalDuration;
    private AttributeDefinition`2<float, double> _externalCallCount;
    private AttributeDefinition`2<float, double> _databaseDuration;
    private AttributeDefinition`2<long, double> _databaseCallCount;
    private AttributeDefinition`2<string, string> _errorClass;
    private AttributeDefinition`2<TypeAttributeValue, string> _type;
    private AttributeDefinition`2<string, string> _errorDotMessage;
    private AttributeDefinition`2<TypeAttributeValue, string> _parentType;
    private AttributeDefinition`2<TypeAttributeValue, string> _parentTypeForSpan;
    private AttributeDefinition`2<DistributedTracingParentType, string> _parentTypeForDistributedTracing;
    private AttributeDefinition`2<DistributedTracingParentType, string> _parentTypeForDistributedTracingForSpan;
    private AttributeDefinition`2<string, string> _parentAccount;
    private AttributeDefinition`2<string, string> _parentAccountForSpan;
    private AttributeDefinition`2<string, string> _parentApp;
    private AttributeDefinition`2<string, string> _parentAppForSpan;
    private AttributeDefinition`2<TransportType, string> _parentTransportType;
    private AttributeDefinition`2<TransportType, string> _parentTransportTypeForSpan;
    private AttributeDefinition`2<TimeSpan, double> _parentTransportDuration;
    private AttributeDefinition`2<TimeSpan, double> _parentTransportDurationForSpan;
    private AttributeDefinition`2<string, string> _parentSpanId;
    private AttributeDefinition`2<string, string> _parentId;
    private AttributeDefinition`2<string, string> _trustedParentId;
    private AttributeDefinition`2<IEnumerable`1<string>, string> _tracingVendors;
    private AttributeDefinition`2<string, string> _distributedTraceId;
    private AttributeDefinition`2<float, double> _priority;
    private AttributeDefinition`2<bool, bool> _sampled;
    private AttributeDefinition`2<string, string> _hostDisplayName;
    private AttributeDefinition`2<string, string> _customEventType;
    private AttributeDefinition`2<string, string> _codeFunction;
    private AttributeDefinition`2<string, string> _codeNamespace;
    private AttributeDefinition`2<bool, bool> _llmTransaction;
    private AttributeDefinition`2<string, string> _cloudAccountId;
    private AttributeDefinition`2<string, string> _cloudRegion;
    private AttributeDefinition`2<string, string> _messagingSystem;
    private AttributeDefinition`2<string, string> _messagingDestinationName;
    private AttributeDefinition`2<string, string> _brokerServerAddress;
    private AttributeDefinition`2<int, int> _brokerServerPort;
    private AttributeDefinition`2<string, string> _messageQueueName;
    private AttributeDefinition`2<string, string> _messageRoutingKey;
    private AttributeDefinition`2<string, string> _messagingRabbitMqDestinationRoutingKey;
    private AttributeDefinition`2<string, string> _messagingDestinationPublishName;
    public AttributeDefinition`2<Nullable`1<TimeSpan>, string> QueueWaitTime { get; }
    public AttributeDefinition`2<Nullable`1<TimeSpan>, double> QueueDuration { get; }
    public AttributeDefinition`2<string, string> OriginalUrl { get; }
    public AttributeDefinition`2<string, string> RequestMethod { get; }
    public AttributeDefinition`2<string, string> RequestUri { get; }
    public AttributeDefinition`2<string, string> RequestReferrer { get; }
    public AttributeDefinition`2<Nullable`1<int>, string> ResponseStatus { get; }
    public AttributeDefinition`2<Nullable`1<long>, long> HttpStatusCode { get; }
    public AttributeDefinition`2<string, string> ClientCrossProcessId { get; }
    public AttributeDefinition`2<string, string> TripId { get; }
    public AttributeDefinition`2<string, string> CatNrTripId { get; }
    public AttributeDefinition`2<string, string> BrowserTripId { get; }
    public AttributeDefinition`2<string, string> CatPathHash { get; }
    public AttributeDefinition`2<string, string> CatNrPathHash { get; }
    public AttributeDefinition`2<string, string> CatReferringPathHash { get; }
    public AttributeDefinition`2<string, string> CatReferringTransactionGuidForTraces { get; }
    public AttributeDefinition`2<string, string> CatReferringTransactionGuidForEvents { get; }
    public AttributeDefinition`2<IEnumerable`1<string>, string> CatAlternativePathHashes { get; }
    public AttributeDefinition`2<string, string> TransactionId { get; }
    public AttributeDefinition`2<string, string> NameForSpan { get; }
    public AttributeDefinition`2<SpanCategory, string> SpanCategory { get; }
    public AttributeDefinition`2<bool, bool> NrEntryPoint { get; }
    public AttributeDefinition`2<long, long> ThreadId { get; }
    public AttributeDefinition`2<string, string> Component { get; }
    public AttributeDefinition`2<string, string> SpanKind { get; }
    public AttributeDefinition`2<string, string> SpanErrorClass { get; }
    public AttributeDefinition`2<string, string> SpanErrorMessage { get; }
    public AttributeDefinition`2<string, string> SpanId { get; }
    public AttributeDefinition`2<string, string> DbStatement { get; }
    public AttributeDefinition`2<string, string> DbSystem { get; }
    public AttributeDefinition`2<string, string> DbOperation { get; }
    public AttributeDefinition`2<string, string> DbCollection { get; }
    public AttributeDefinition`2<string, string> DbInstance { get; }
    public AttributeDefinition`2<string, string> PeerAddress { get; }
    public AttributeDefinition`2<string, string> PeerHostname { get; }
    public AttributeDefinition`2<Uri, string> HttpUrl { get; }
    public AttributeDefinition`2<string, string> HttpMethod { get; }
    public AttributeDefinition`2<string, string> ServerAddress { get; }
    public AttributeDefinition`2<long, long> ServerPort { get; }
    public AttributeDefinition`2<string, string> DbServerAddress { get; }
    public AttributeDefinition`2<long, long> DbServerPort { get; }
    public AttributeDefinition`2<string, string> ErrorEventSpanId { get; }
    public AttributeDefinition`2<string, string> ErrorType { get; }
    public AttributeDefinition`2<string, string> ErrorMessage { get; }
    public AttributeDefinition`2<bool, bool> IsError { get; }
    public AttributeDefinition`2<bool, bool> IsErrorExpected { get; }
    public AttributeDefinition`2<bool, bool> SpanIsErrorExpected { get; }
    public AttributeDefinition`2<string, string> ErrorGroup { get; }
    public AttributeDefinition`2<string, string> EndUserId { get; }
    public AttributeDefinition`2<DateTime, long> Timestamp { get; }
    public AttributeDefinition`2<DateTime, long> TimestampForError { get; }
    public AttributeDefinition`2<string, string> TransactionName { get; }
    public AttributeDefinition`2<string, string> TransactionNameForSpan { get; }
    public AttributeDefinition`2<string, string> TransactionNameForError { get; }
    public AttributeDefinition`2<string, string> NrGuid { get; }
    public AttributeDefinition`2<string, string> Guid { get; }
    public AttributeDefinition`2<string, string> SyntheticsResourceId { get; }
    public AttributeDefinition`2<string, string> SyntheticsResourceIdForTraces { get; }
    public AttributeDefinition`2<string, string> SyntheticsJobId { get; }
    public AttributeDefinition`2<string, string> SyntheticsJobIdForTraces { get; }
    public AttributeDefinition`2<string, string> SyntheticsMonitorId { get; }
    public AttributeDefinition`2<string, string> SyntheticsMonitorIdForTraces { get; }
    public AttributeDefinition`2<TimeSpan, double> Duration { get; }
    public AttributeDefinition`2<TimeSpan, double> WebDuration { get; }
    public AttributeDefinition`2<TimeSpan, double> TotalTime { get; }
    public AttributeDefinition`2<TimeSpan, double> CpuTime { get; }
    public AttributeDefinition`2<string, string> ApdexPerfZone { get; }
    public AttributeDefinition`2<float, double> ExternalDuration { get; }
    public AttributeDefinition`2<float, double> ExternalCallCount { get; }
    public AttributeDefinition`2<float, double> DatabaseDuration { get; }
    public AttributeDefinition`2<long, double> DatabaseCallCount { get; }
    public AttributeDefinition`2<string, string> ErrorClass { get; }
    public AttributeDefinition`2<TypeAttributeValue, string> Type { get; }
    public AttributeDefinition`2<string, string> ErrorDotMessage { get; }
    public AttributeDefinition`2<TypeAttributeValue, string> ParentType { get; }
    public AttributeDefinition`2<TypeAttributeValue, string> ParentTypeForSpan { get; }
    public AttributeDefinition`2<DistributedTracingParentType, string> ParentTypeForDistributedTracing { get; }
    public AttributeDefinition`2<DistributedTracingParentType, string> ParentTypeForDistributedTracingForSpan { get; }
    public AttributeDefinition`2<string, string> ParentAccount { get; }
    public AttributeDefinition`2<string, string> ParentAccountForSpan { get; }
    public AttributeDefinition`2<string, string> ParentApp { get; }
    public AttributeDefinition`2<string, string> ParentAppForSpan { get; }
    public AttributeDefinition`2<TransportType, string> ParentTransportType { get; }
    public AttributeDefinition`2<TransportType, string> ParentTransportTypeForSpan { get; }
    public AttributeDefinition`2<TimeSpan, double> ParentTransportDuration { get; }
    public AttributeDefinition`2<TimeSpan, double> ParentTransportDurationForSpan { get; }
    public AttributeDefinition`2<string, string> ParentSpanId { get; }
    public AttributeDefinition`2<string, string> ParentId { get; }
    public AttributeDefinition`2<string, string> TrustedParentId { get; }
    public AttributeDefinition`2<IEnumerable`1<string>, string> TracingVendors { get; }
    public AttributeDefinition`2<string, string> DistributedTraceId { get; }
    public AttributeDefinition`2<float, double> Priority { get; }
    public AttributeDefinition`2<bool, bool> Sampled { get; }
    public AttributeDefinition`2<string, string> HostDisplayName { get; }
    public AttributeDefinition`2<string, string> CustomEventType { get; }
    public AttributeDefinition`2<string, string> CodeFunction { get; }
    public AttributeDefinition`2<string, string> CodeNamespace { get; }
    public AttributeDefinition`2<bool, bool> LlmTransaction { get; }
    public AttributeDefinition`2<string, string> CloudAccountId { get; }
    public AttributeDefinition`2<string, string> CloudRegion { get; }
    public AttributeDefinition`2<string, string> MessagingSystemName { get; }
    public AttributeDefinition`2<string, string> MessagingDestinationName { get; }
    public AttributeDefinition`2<string, string> BrokerServerAddress { get; }
    public AttributeDefinition`2<int, int> BrokerServerPort { get; }
    public AttributeDefinition`2<string, string> MessageQueueName { get; }
    public AttributeDefinition`2<string, string> MessageRoutingKey { get; }
    public AttributeDefinition`2<string, string> MessagingRabbitMqDestinationRoutingKey { get; }
    public AttributeDefinition`2<string, string> MessagingDestinationPublishName { get; }
    public AttributeDefinitions(IAttributeFilter attribFilter);
    private AttributeDefinition`2<object, object> CreateCustomAttributeForTransaction(string name);
    private AttributeDefinition`2<object, object> CreateCustomAttributeForCustomEvent(string name);
    private AttributeDefinition`2<object, object> CreateCustomAttributeForError(string name);
    private AttributeDefinition`2<object, object> CreateCustomAttributeForSpan(string name);
    private AttributeDefinition`2<string, string> CreateRequestParameterAttribute(string paramName);
    private AttributeDefinition`2<string, string> CreateRequestHeadersAttribute(string paramName);
    private AttributeDefinition`2<object, object> CreateLambdaAttribute(string attribName);
    public sealed virtual AttributeDefinition`2<object, object> GetLambdaAttribute(string name);
    private AttributeDefinition`2<object, object> CreateFaasAttribute(string attribName);
    public sealed virtual AttributeDefinition`2<object, object> GetFaasAttribute(string name);
    public sealed virtual AttributeDefinition`2<object, object> GetCustomAttributeForTransaction(string name);
    public sealed virtual AttributeDefinition`2<object, object> GetCustomAttributeForCustomEvent(string name);
    public sealed virtual AttributeDefinition`2<object, object> GetCustomAttributeForError(string name);
    public sealed virtual AttributeDefinition`2<object, object> GetCustomAttributeForSpan(string name);
    public sealed virtual AttributeDefinition`2<string, string> GetRequestParameterAttribute(string paramName);
    public sealed virtual AttributeDefinition`2<string, string> GetRequestHeadersAttribute(string paramName);
    private AttributeDefinition`2<TypeAttributeValue, string> CreateTypeAttribute(TypeAttributeValue tm);
    public sealed virtual AttributeDefinition`2<TypeAttributeValue, string> GetTypeAttribute(TypeAttributeValue targetModel);
    public sealed virtual AttributeDefinition`2<Nullable`1<TimeSpan>, string> get_QueueWaitTime();
    public sealed virtual AttributeDefinition`2<Nullable`1<TimeSpan>, double> get_QueueDuration();
    public sealed virtual AttributeDefinition`2<string, string> get_OriginalUrl();
    public sealed virtual AttributeDefinition`2<string, string> get_RequestMethod();
    public sealed virtual AttributeDefinition`2<string, string> get_RequestUri();
    public sealed virtual AttributeDefinition`2<string, string> get_RequestReferrer();
    public sealed virtual AttributeDefinition`2<Nullable`1<int>, string> get_ResponseStatus();
    public sealed virtual AttributeDefinition`2<Nullable`1<long>, long> get_HttpStatusCode();
    public sealed virtual AttributeDefinition`2<string, string> get_ClientCrossProcessId();
    public sealed virtual AttributeDefinition`2<string, string> get_TripId();
    public sealed virtual AttributeDefinition`2<string, string> get_CatNrTripId();
    public sealed virtual AttributeDefinition`2<string, string> get_BrowserTripId();
    public sealed virtual AttributeDefinition`2<string, string> get_CatPathHash();
    public sealed virtual AttributeDefinition`2<string, string> get_CatNrPathHash();
    public sealed virtual AttributeDefinition`2<string, string> get_CatReferringPathHash();
    public sealed virtual AttributeDefinition`2<string, string> get_CatReferringTransactionGuidForTraces();
    public sealed virtual AttributeDefinition`2<string, string> get_CatReferringTransactionGuidForEvents();
    public sealed virtual AttributeDefinition`2<IEnumerable`1<string>, string> get_CatAlternativePathHashes();
    public sealed virtual AttributeDefinition`2<string, string> get_TransactionId();
    public sealed virtual AttributeDefinition`2<string, string> get_NameForSpan();
    public sealed virtual AttributeDefinition`2<SpanCategory, string> get_SpanCategory();
    public sealed virtual AttributeDefinition`2<bool, bool> get_NrEntryPoint();
    public sealed virtual AttributeDefinition`2<long, long> get_ThreadId();
    public sealed virtual AttributeDefinition`2<string, string> get_Component();
    public sealed virtual AttributeDefinition`2<string, string> get_SpanKind();
    public sealed virtual AttributeDefinition`2<string, string> get_SpanErrorClass();
    public sealed virtual AttributeDefinition`2<string, string> get_SpanErrorMessage();
    public sealed virtual AttributeDefinition`2<string, string> get_SpanId();
    public sealed virtual AttributeDefinition`2<string, string> get_DbStatement();
    public sealed virtual AttributeDefinition`2<string, string> get_DbSystem();
    public sealed virtual AttributeDefinition`2<string, string> get_DbOperation();
    public sealed virtual AttributeDefinition`2<string, string> get_DbCollection();
    public sealed virtual AttributeDefinition`2<string, string> get_DbInstance();
    public sealed virtual AttributeDefinition`2<string, string> get_PeerAddress();
    public sealed virtual AttributeDefinition`2<string, string> get_PeerHostname();
    public sealed virtual AttributeDefinition`2<Uri, string> get_HttpUrl();
    public sealed virtual AttributeDefinition`2<string, string> get_HttpMethod();
    public sealed virtual AttributeDefinition`2<string, string> get_ServerAddress();
    public sealed virtual AttributeDefinition`2<long, long> get_ServerPort();
    public sealed virtual AttributeDefinition`2<string, string> get_DbServerAddress();
    public sealed virtual AttributeDefinition`2<long, long> get_DbServerPort();
    public sealed virtual AttributeDefinition`2<string, string> get_ErrorEventSpanId();
    public sealed virtual AttributeDefinition`2<string, string> get_ErrorType();
    public sealed virtual AttributeDefinition`2<string, string> get_ErrorMessage();
    public sealed virtual AttributeDefinition`2<bool, bool> get_IsError();
    public sealed virtual AttributeDefinition`2<bool, bool> get_IsErrorExpected();
    public sealed virtual AttributeDefinition`2<bool, bool> get_SpanIsErrorExpected();
    public sealed virtual AttributeDefinition`2<string, string> get_ErrorGroup();
    private static string IgnoreEmptyAndWhitespaceErrorGroupValues(string errorGroupValue);
    public sealed virtual AttributeDefinition`2<string, string> get_EndUserId();
    public sealed virtual AttributeDefinition`2<DateTime, long> get_Timestamp();
    public sealed virtual AttributeDefinition`2<DateTime, long> get_TimestampForError();
    public sealed virtual AttributeDefinition`2<string, string> get_TransactionName();
    public sealed virtual AttributeDefinition`2<string, string> get_TransactionNameForSpan();
    public sealed virtual AttributeDefinition`2<string, string> get_TransactionNameForError();
    public sealed virtual AttributeDefinition`2<string, string> get_NrGuid();
    public sealed virtual AttributeDefinition`2<string, string> get_Guid();
    public sealed virtual AttributeDefinition`2<string, string> get_SyntheticsResourceId();
    public sealed virtual AttributeDefinition`2<string, string> get_SyntheticsResourceIdForTraces();
    public sealed virtual AttributeDefinition`2<string, string> get_SyntheticsJobId();
    public sealed virtual AttributeDefinition`2<string, string> get_SyntheticsJobIdForTraces();
    public sealed virtual AttributeDefinition`2<string, string> get_SyntheticsMonitorId();
    public sealed virtual AttributeDefinition`2<string, string> get_SyntheticsMonitorIdForTraces();
    public sealed virtual AttributeDefinition`2<TimeSpan, double> get_Duration();
    public sealed virtual AttributeDefinition`2<TimeSpan, double> get_WebDuration();
    public sealed virtual AttributeDefinition`2<TimeSpan, double> get_TotalTime();
    public sealed virtual AttributeDefinition`2<TimeSpan, double> get_CpuTime();
    public sealed virtual AttributeDefinition`2<string, string> get_ApdexPerfZone();
    public sealed virtual AttributeDefinition`2<float, double> get_ExternalDuration();
    public sealed virtual AttributeDefinition`2<float, double> get_ExternalCallCount();
    public sealed virtual AttributeDefinition`2<float, double> get_DatabaseDuration();
    public sealed virtual AttributeDefinition`2<long, double> get_DatabaseCallCount();
    public sealed virtual AttributeDefinition`2<string, string> get_ErrorClass();
    public AttributeDefinition`2<TypeAttributeValue, string> get_Type();
    public sealed virtual AttributeDefinition`2<string, string> get_ErrorDotMessage();
    public sealed virtual AttributeDefinition`2<TypeAttributeValue, string> get_ParentType();
    public sealed virtual AttributeDefinition`2<TypeAttributeValue, string> get_ParentTypeForSpan();
    public sealed virtual AttributeDefinition`2<DistributedTracingParentType, string> get_ParentTypeForDistributedTracing();
    public sealed virtual AttributeDefinition`2<DistributedTracingParentType, string> get_ParentTypeForDistributedTracingForSpan();
    public sealed virtual AttributeDefinition`2<string, string> get_ParentAccount();
    public sealed virtual AttributeDefinition`2<string, string> get_ParentAccountForSpan();
    public sealed virtual AttributeDefinition`2<string, string> get_ParentApp();
    public sealed virtual AttributeDefinition`2<string, string> get_ParentAppForSpan();
    public sealed virtual AttributeDefinition`2<TransportType, string> get_ParentTransportType();
    public sealed virtual AttributeDefinition`2<TransportType, string> get_ParentTransportTypeForSpan();
    public sealed virtual AttributeDefinition`2<TimeSpan, double> get_ParentTransportDuration();
    public sealed virtual AttributeDefinition`2<TimeSpan, double> get_ParentTransportDurationForSpan();
    public sealed virtual AttributeDefinition`2<string, string> get_ParentSpanId();
    public sealed virtual AttributeDefinition`2<string, string> get_ParentId();
    public sealed virtual AttributeDefinition`2<string, string> get_TrustedParentId();
    public sealed virtual AttributeDefinition`2<IEnumerable`1<string>, string> get_TracingVendors();
    public sealed virtual AttributeDefinition`2<string, string> get_DistributedTraceId();
    public sealed virtual AttributeDefinition`2<float, double> get_Priority();
    public sealed virtual AttributeDefinition`2<bool, bool> get_Sampled();
    public sealed virtual AttributeDefinition`2<string, string> get_HostDisplayName();
    public sealed virtual AttributeDefinition`2<string, string> get_CustomEventType();
    public sealed virtual AttributeDefinition`2<string, string> get_CodeFunction();
    public sealed virtual AttributeDefinition`2<string, string> get_CodeNamespace();
    public sealed virtual AttributeDefinition`2<bool, bool> get_LlmTransaction();
    public sealed virtual AttributeDefinition`2<string, string> get_CloudAccountId();
    public sealed virtual AttributeDefinition`2<string, string> get_CloudRegion();
    public sealed virtual AttributeDefinition`2<string, string> get_MessagingSystemName();
    public sealed virtual AttributeDefinition`2<string, string> get_MessagingDestinationName();
    public sealed virtual AttributeDefinition`2<string, string> get_BrokerServerAddress();
    public sealed virtual AttributeDefinition`2<int, int> get_BrokerServerPort();
    public sealed virtual AttributeDefinition`2<string, string> get_MessageQueueName();
    public sealed virtual AttributeDefinition`2<string, string> get_MessageRoutingKey();
    public sealed virtual AttributeDefinition`2<string, string> get_MessagingRabbitMqDestinationRoutingKey();
    public sealed virtual AttributeDefinition`2<string, string> get_MessagingDestinationPublishName();
}
public class NewRelic.Agent.Core.Attributes.AttributeDefinitionService : ConfigurationBasedService {
    [CompilerGeneratedAttribute]
private IAttributeDefinitions <AttributeDefs>k__BackingField;
    private Func`2<IAttributeFilter, IAttributeDefinitions> _attribDefinitionsFactory;
    public IAttributeDefinitions AttributeDefs { get; private set; }
    public AttributeDefinitionService(Func`2<IAttributeFilter, IAttributeDefinitions> attribDefinitionFactory);
    [CompilerGeneratedAttribute]
public sealed virtual IAttributeDefinitions get_AttributeDefs();
    [CompilerGeneratedAttribute]
private void set_AttributeDefs(IAttributeDefinitions value);
    private void ResetAttributeDefinitions();
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
[FlagsAttribute]
public enum NewRelic.Agent.Core.Attributes.AttributeDestinations : Enum {
    public byte value__;
    public static AttributeDestinations None;
    public static AttributeDestinations TransactionTrace;
    public static AttributeDestinations TransactionEvent;
    public static AttributeDestinations ErrorTrace;
    public static AttributeDestinations JavaScriptAgent;
    public static AttributeDestinations ErrorEvent;
    public static AttributeDestinations SqlTrace;
    public static AttributeDestinations SpanEvent;
    public static AttributeDestinations CustomEvent;
    public static AttributeDestinations All;
}
public class NewRelic.Agent.Core.Attributes.AttributeFilter : object {
    private static UInt32 MaxCacheSize;
    private TrieNode`1<AttributeFilterNode> _explicitAttributeTrie;
    private TrieNode`1<AttributeFilterNode> _implicitAttributeTrie;
    private Settings _settings;
    private ConcurrentDictionary`2<string, bool> _cachedClusions;
    public AttributeFilter(Settings settings);
    public sealed virtual bool ShouldFilterAttribute(AttributeDestinations targetObjectType);
    public sealed virtual bool CheckOrAddAttributeClusionCache(string name, AttributeDestinations defaultDestinations, AttributeDestinations destination);
    private static string GetAttributeClusionKey(string name, AttributeDestinations defaultDestinations, AttributeDestinations destination);
    public sealed virtual bool ShouldExcludeAttribute(string name, AttributeDestinations defaultDestinations, AttributeDestinations destination);
    private Clude CheckForExplicitClusion(string name, AttributeDestinations destination);
    private Clude CheckForImplicitClusion(string name, AttributeDestinations defaultDestinations, AttributeDestinations destination);
    private static bool KnownCludeToBoolean(Clude clude);
    private static TrieNode`1<AttributeFilterNode> CreateAttributeNodeTrie(IEnumerable`1<AttributeFilterNode> nodes);
    private static IEnumerable`1<AttributeFilterNode> CreateExplicitAttributeNodes(Settings settings);
    private static IEnumerable`1<AttributeFilterNode> CreateImplicitAttributeNodes(Settings settings);
    private static IEnumerable`1<AttributeFilterNode> CreateAttributeNodes(IEnumerable`1<string> keys, AttributeDestinations destinations, bool include);
    private static AttributeFilterNode CreateAttributeNode(string key, AttributeDestinations destinations, bool include);
    private static AttributeFilterNode MergeAttributeNodes(IEnumerable`1<AttributeFilterNode> nodeBuilders);
    private static AttributeFilterNode MergeAttributeNodes(AttributeFilterNode left, AttributeFilterNode right);
    private static int CompareAttributeNodes(AttributeFilterNode left, AttributeFilterNode right);
    private static int HashAttributeNode(AttributeFilterNode nodeBuilder);
    private static bool CanParentAcceptChild(AttributeFilterNode parent, AttributeFilterNode orphan);
    private static bool CanNodeHaveChildren(AttributeFilterNode node);
}
internal class NewRelic.Agent.Core.Attributes.AttributeFilterNode : object {
    public string Key;
    public bool Wildcard;
    public AttributeDestinations DestinationIncludes;
    public AttributeDestinations DestinationExcludes;
    public AttributeFilterNode(string key, AttributeDestinations includes, AttributeDestinations excludes);
}
[ExtensionAttribute]
internal static class NewRelic.Agent.Core.Attributes.AttributeFilterTrieNode : object {
    [ExtensionAttribute]
public static Clude GetClusion(TrieNode`1<AttributeFilterNode> nodeBuilder, string name, AttributeDestinations destination);
    [ExtensionAttribute]
private static Clude GetClusionFromChildren(TrieNode`1<AttributeFilterNode> nodeBuilder, string name, AttributeDestinations destination);
    [ExtensionAttribute]
private static Clude GetChildClusion(TrieNode`1<AttributeFilterNode> child, string name, AttributeDestinations destination);
    [ExtensionAttribute]
private static bool NodeAppliesToAttribute(TrieNode`1<AttributeFilterNode> nodeBuilder, string name);
    [ExtensionAttribute]
private static TrieNode`1<AttributeFilterNode> ApplicableChild(TrieNode`1<AttributeFilterNode> nodeBuilder, string name);
}
[DebuggerDisplayAttribute("{_value ?? _lazyValue}")]
public class NewRelic.Agent.Core.Attributes.AttributeValue : object {
    [CompilerGeneratedAttribute]
private AttributeDefinition <AttributeDefinition>k__BackingField;
    private object _value;
    private Lazy`1<object> _lazyValue;
    [CompilerGeneratedAttribute]
private bool <IsImmutable>k__BackingField;
    public AttributeDefinition AttributeDefinition { get; private set; }
    public object Value { get; public set; }
    public Lazy`1<object> LazyValue { get; public set; }
    public bool IsImmutable { get; private set; }
    public AttributeValue(AttributeDefinition attribDef);
    [CompilerGeneratedAttribute]
public sealed virtual AttributeDefinition get_AttributeDefinition();
    [CompilerGeneratedAttribute]
private void set_AttributeDefinition(AttributeDefinition value);
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    public sealed virtual Lazy`1<object> get_LazyValue();
    public sealed virtual void set_LazyValue(Lazy`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_IsImmutable();
    [CompilerGeneratedAttribute]
private void set_IsImmutable(bool value);
    public sealed virtual void MakeImmutable();
}
public class NewRelic.Agent.Core.Attributes.AttributeValueCollection : AttributeValueCollectionBase`1<AttributeValue> {
    private Dictionary`2<AttributeClassification, object> _lockObjects;
    private Dictionary`2<Guid, AttributeValue> _intrinsicAttributes;
    private Dictionary`2<Guid, AttributeValue> _agentAttributes;
    private Dictionary`2<Guid, AttributeValue> _userAttributes;
    public AttributeValueCollection(IAttributeValueCollection fromCollection, AttributeDestinations[] targetModelTypes);
    public AttributeValueCollection(AttributeDestinations[] targetModelTypes);
    public AttributeValueCollection(string transactionGuid, AttributeDestinations[] targetModelTypes);
    private Dictionary`2<Guid, AttributeValue> GetAttribValuesInternal(AttributeClassification classification, bool withCreate);
    protected virtual IEnumerable`1<AttributeValue> GetAttribValuesImpl(AttributeClassification classification);
    protected virtual void RemoveItemsImpl(IEnumerable`1<AttributeValue> itemsToRemove);
    public virtual bool CollectionContainsAttribute(AttributeDefinition attrDef);
    protected virtual bool SetValueImpl(IAttributeValue attribVal);
    protected virtual bool SetValueImpl(AttributeDefinition attribDef, object value);
    protected virtual bool SetValueImpl(AttributeDefinition attribDef, Lazy`1<object> lazyValue);
    private bool SetValueImplInternal(AttributeValue attribVal);
}
public abstract class NewRelic.Agent.Core.Attributes.AttributeValueCollectionBase`1 : object {
    private static AttributeDestinations[] _allTargetModelTypes;
    public static int MaxCountUserAttrib;
    public static int MaxCountAllAttrib;
    protected static AttributeClassification[] _allClassifications;
    private int _intrinsicAttributeCount;
    private int _agentAttributeCount;
    private int _userAttributeCount;
    private string _transactionGuid;
    [CompilerGeneratedAttribute]
private AttributeDestinations[] <TargetModelTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeDestinations <TargetModelTypesAsFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImmutable>k__BackingField;
    public static AttributeDestinations[] AllTargetModelTypes { get; }
    public int Count { get; }
    public AttributeDestinations[] TargetModelTypes { get; private set; }
    public AttributeDestinations TargetModelTypesAsFlags { get; private set; }
    public bool IsImmutable { get; private set; }
    protected AttributeValueCollectionBase`1(IAttributeValueCollection fromCollection, AttributeDestinations[] targetModelTypes);
    protected AttributeValueCollectionBase`1(AttributeDestinations[] targetModelTypes);
    protected AttributeValueCollectionBase`1(string transactionGuid, AttributeDestinations[] targetModelTypes);
    private static AttributeValueCollectionBase`1();
    public static AttributeDestinations[] get_AllTargetModelTypes();
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual AttributeDestinations[] get_TargetModelTypes();
    [CompilerGeneratedAttribute]
private void set_TargetModelTypes(AttributeDestinations[] value);
    [CompilerGeneratedAttribute]
public sealed virtual AttributeDestinations get_TargetModelTypesAsFlags();
    [CompilerGeneratedAttribute]
private void set_TargetModelTypesAsFlags(AttributeDestinations value);
    public abstract virtual bool CollectionContainsAttribute(AttributeDefinition attrDef);
    private bool ValidateCollectionLimits(AttributeDefinition attrDef);
    public sealed virtual IEnumerable`1<IAttributeValue> GetAttributeValues(AttributeClassification classification);
    public sealed virtual IDictionary`2<string, object> GetAttributeValuesDic(AttributeClassification classification);
    public sealed virtual IDictionary`2<string, object> GetAllAttributeValuesDic();
    public void AddRange(IEnumerable`1<IAttributeValue> attribValues);
    public sealed virtual void AddRange(IAttributeValueCollection fromCollection);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsImmutable();
    [CompilerGeneratedAttribute]
private void set_IsImmutable(bool value);
    private void IncrementAttribCount(AttributeClassification classification);
    public sealed virtual bool TrySetValue(AttributeDefinition`2<TInput, TOutput> attribDef, TOutput val);
    public sealed virtual bool TrySetValue(IAttributeValue attribValue);
    public sealed virtual bool TrySetValue(AttributeDefinition`2<TInput, TOutput> attribDef, Lazy`1<object> lazyValueImpl);
    protected abstract virtual bool SetValueImpl(IAttributeValue attribVal);
    protected abstract virtual bool SetValueImpl(AttributeDefinition attribDef, object value);
    protected abstract virtual bool SetValueImpl(AttributeDefinition attribDef, Lazy`1<object> lazyValue);
    protected abstract virtual void RemoveItemsImpl(IEnumerable`1<TAttrib> itemsToRemove);
    protected abstract virtual IEnumerable`1<TAttrib> GetAttribValuesImpl(AttributeClassification classification);
    public sealed virtual void MakeImmutable();
    private void LogTransactionIfFinest(string message);
}
internal enum NewRelic.Agent.Core.Attributes.Clude : Enum {
    public int value__;
    public static Clude Unknown;
    public static Clude Exclude;
    public static Clude Include;
}
public interface NewRelic.Agent.Core.Attributes.IAttributeDefinitions {
    public AttributeDefinition`2<string, string> ApdexPerfZone { get; }
    public AttributeDefinition`2<string, string> BrowserTripId { get; }
    public AttributeDefinition`2<IEnumerable`1<string>, string> CatAlternativePathHashes { get; }
    public AttributeDefinition`2<string, string> CatNrPathHash { get; }
    public AttributeDefinition`2<string, string> CatNrTripId { get; }
    public AttributeDefinition`2<string, string> CatPathHash { get; }
    public AttributeDefinition`2<string, string> CatReferringPathHash { get; }
    public AttributeDefinition`2<string, string> CatReferringTransactionGuidForEvents { get; }
    public AttributeDefinition`2<string, string> CatReferringTransactionGuidForTraces { get; }
    public AttributeDefinition`2<string, string> ClientCrossProcessId { get; }
    public AttributeDefinition`2<string, string> CodeFunction { get; }
    public AttributeDefinition`2<string, string> CodeNamespace { get; }
    public AttributeDefinition`2<string, string> Component { get; }
    public AttributeDefinition`2<TimeSpan, double> CpuTime { get; }
    public AttributeDefinition`2<string, string> CustomEventType { get; }
    public AttributeDefinition`2<long, double> DatabaseCallCount { get; }
    public AttributeDefinition`2<float, double> DatabaseDuration { get; }
    public AttributeDefinition`2<string, string> DbCollection { get; }
    public AttributeDefinition`2<string, string> DbInstance { get; }
    public AttributeDefinition`2<string, string> DbOperation { get; }
    public AttributeDefinition`2<string, string> DbServerAddress { get; }
    public AttributeDefinition`2<long, long> DbServerPort { get; }
    public AttributeDefinition`2<string, string> DbStatement { get; }
    public AttributeDefinition`2<string, string> DbSystem { get; }
    public AttributeDefinition`2<string, string> DistributedTraceId { get; }
    public AttributeDefinition`2<TimeSpan, double> Duration { get; }
    public AttributeDefinition`2<bool, bool> IsErrorExpected { get; }
    public AttributeDefinition`2<bool, bool> SpanIsErrorExpected { get; }
    public AttributeDefinition`2<string, string> ErrorClass { get; }
    public AttributeDefinition`2<string, string> ErrorDotMessage { get; }
    public AttributeDefinition`2<string, string> ErrorMessage { get; }
    public AttributeDefinition`2<string, string> ErrorType { get; }
    public AttributeDefinition`2<string, string> ErrorEventSpanId { get; }
    public AttributeDefinition`2<string, string> ErrorGroup { get; }
    public AttributeDefinition`2<string, string> EndUserId { get; }
    public AttributeDefinition`2<float, double> ExternalCallCount { get; }
    public AttributeDefinition`2<float, double> ExternalDuration { get; }
    public AttributeDefinition`2<string, string> Guid { get; }
    public AttributeDefinition`2<string, string> HostDisplayName { get; }
    public AttributeDefinition`2<string, string> HttpMethod { get; }
    public AttributeDefinition`2<Nullable`1<long>, long> HttpStatusCode { get; }
    public AttributeDefinition`2<Uri, string> HttpUrl { get; }
    public AttributeDefinition`2<bool, bool> IsError { get; }
    public AttributeDefinition`2<string, string> NameForSpan { get; }
    public AttributeDefinition`2<bool, bool> NrEntryPoint { get; }
    public AttributeDefinition`2<string, string> NrGuid { get; }
    public AttributeDefinition`2<string, string> OriginalUrl { get; }
    public AttributeDefinition`2<string, string> ParentAccount { get; }
    public AttributeDefinition`2<string, string> ParentAccountForSpan { get; }
    public AttributeDefinition`2<string, string> ParentApp { get; }
    public AttributeDefinition`2<string, string> ParentAppForSpan { get; }
    public AttributeDefinition`2<string, string> ParentId { get; }
    public AttributeDefinition`2<string, string> ParentSpanId { get; }
    public AttributeDefinition`2<TimeSpan, double> ParentTransportDuration { get; }
    public AttributeDefinition`2<TimeSpan, double> ParentTransportDurationForSpan { get; }
    public AttributeDefinition`2<TransportType, string> ParentTransportType { get; }
    public AttributeDefinition`2<TransportType, string> ParentTransportTypeForSpan { get; }
    public AttributeDefinition`2<TypeAttributeValue, string> ParentType { get; }
    public AttributeDefinition`2<TypeAttributeValue, string> ParentTypeForSpan { get; }
    public AttributeDefinition`2<DistributedTracingParentType, string> ParentTypeForDistributedTracing { get; }
    public AttributeDefinition`2<DistributedTracingParentType, string> ParentTypeForDistributedTracingForSpan { get; }
    public AttributeDefinition`2<string, string> PeerAddress { get; }
    public AttributeDefinition`2<string, string> PeerHostname { get; }
    public AttributeDefinition`2<float, double> Priority { get; }
    public AttributeDefinition`2<Nullable`1<TimeSpan>, double> QueueDuration { get; }
    public AttributeDefinition`2<Nullable`1<TimeSpan>, string> QueueWaitTime { get; }
    public AttributeDefinition`2<string, string> RequestReferrer { get; }
    public AttributeDefinition`2<string, string> RequestMethod { get; }
    public AttributeDefinition`2<string, string> RequestUri { get; }
    public AttributeDefinition`2<Nullable`1<int>, string> ResponseStatus { get; }
    public AttributeDefinition`2<bool, bool> Sampled { get; }
    public AttributeDefinition`2<string, string> ServerAddress { get; }
    public AttributeDefinition`2<long, long> ServerPort { get; }
    public AttributeDefinition`2<SpanCategory, string> SpanCategory { get; }
    public AttributeDefinition`2<string, string> SpanErrorClass { get; }
    public AttributeDefinition`2<string, string> SpanErrorMessage { get; }
    public AttributeDefinition`2<string, string> SpanId { get; }
    public AttributeDefinition`2<string, string> SpanKind { get; }
    public AttributeDefinition`2<string, string> SyntheticsJobId { get; }
    public AttributeDefinition`2<string, string> SyntheticsJobIdForTraces { get; }
    public AttributeDefinition`2<string, string> SyntheticsMonitorId { get; }
    public AttributeDefinition`2<string, string> SyntheticsMonitorIdForTraces { get; }
    public AttributeDefinition`2<string, string> SyntheticsResourceId { get; }
    public AttributeDefinition`2<string, string> SyntheticsResourceIdForTraces { get; }
    public AttributeDefinition`2<long, long> ThreadId { get; }
    public AttributeDefinition`2<DateTime, long> Timestamp { get; }
    public AttributeDefinition`2<DateTime, long> TimestampForError { get; }
    public AttributeDefinition`2<TimeSpan, double> TotalTime { get; }
    public AttributeDefinition`2<string, string> TransactionId { get; }
    public AttributeDefinition`2<IEnumerable`1<string>, string> TracingVendors { get; }
    public AttributeDefinition`2<string, string> TransactionName { get; }
    public AttributeDefinition`2<string, string> TransactionNameForSpan { get; }
    public AttributeDefinition`2<string, string> TransactionNameForError { get; }
    public AttributeDefinition`2<string, string> TripId { get; }
    public AttributeDefinition`2<string, string> TrustedParentId { get; }
    public AttributeDefinition`2<TimeSpan, double> WebDuration { get; }
    public AttributeDefinition`2<bool, bool> LlmTransaction { get; }
    public AttributeDefinition`2<string, string> CloudAccountId { get; }
    public AttributeDefinition`2<string, string> CloudRegion { get; }
    public AttributeDefinition`2<string, string> MessagingSystemName { get; }
    public AttributeDefinition`2<string, string> MessagingDestinationName { get; }
    public AttributeDefinition`2<string, string> BrokerServerAddress { get; }
    public AttributeDefinition`2<int, int> BrokerServerPort { get; }
    public AttributeDefinition`2<string, string> MessageQueueName { get; }
    public AttributeDefinition`2<string, string> MessageRoutingKey { get; }
    public AttributeDefinition`2<string, string> MessagingRabbitMqDestinationRoutingKey { get; }
    public AttributeDefinition`2<string, string> MessagingDestinationPublishName { get; }
    public abstract virtual AttributeDefinition`2<string, string> get_ApdexPerfZone();
    public abstract virtual AttributeDefinition`2<string, string> get_BrowserTripId();
    public abstract virtual AttributeDefinition`2<IEnumerable`1<string>, string> get_CatAlternativePathHashes();
    public abstract virtual AttributeDefinition`2<string, string> get_CatNrPathHash();
    public abstract virtual AttributeDefinition`2<string, string> get_CatNrTripId();
    public abstract virtual AttributeDefinition`2<string, string> get_CatPathHash();
    public abstract virtual AttributeDefinition`2<string, string> get_CatReferringPathHash();
    public abstract virtual AttributeDefinition`2<string, string> get_CatReferringTransactionGuidForEvents();
    public abstract virtual AttributeDefinition`2<string, string> get_CatReferringTransactionGuidForTraces();
    public abstract virtual AttributeDefinition`2<string, string> get_ClientCrossProcessId();
    public abstract virtual AttributeDefinition`2<string, string> get_CodeFunction();
    public abstract virtual AttributeDefinition`2<string, string> get_CodeNamespace();
    public abstract virtual AttributeDefinition`2<string, string> get_Component();
    public abstract virtual AttributeDefinition`2<TimeSpan, double> get_CpuTime();
    public abstract virtual AttributeDefinition`2<string, string> get_CustomEventType();
    public abstract virtual AttributeDefinition`2<long, double> get_DatabaseCallCount();
    public abstract virtual AttributeDefinition`2<float, double> get_DatabaseDuration();
    public abstract virtual AttributeDefinition`2<string, string> get_DbCollection();
    public abstract virtual AttributeDefinition`2<string, string> get_DbInstance();
    public abstract virtual AttributeDefinition`2<string, string> get_DbOperation();
    public abstract virtual AttributeDefinition`2<string, string> get_DbServerAddress();
    public abstract virtual AttributeDefinition`2<long, long> get_DbServerPort();
    public abstract virtual AttributeDefinition`2<string, string> get_DbStatement();
    public abstract virtual AttributeDefinition`2<string, string> get_DbSystem();
    public abstract virtual AttributeDefinition`2<string, string> get_DistributedTraceId();
    public abstract virtual AttributeDefinition`2<TimeSpan, double> get_Duration();
    public abstract virtual AttributeDefinition`2<bool, bool> get_IsErrorExpected();
    public abstract virtual AttributeDefinition`2<bool, bool> get_SpanIsErrorExpected();
    public abstract virtual AttributeDefinition`2<string, string> get_ErrorClass();
    public abstract virtual AttributeDefinition`2<string, string> get_ErrorDotMessage();
    public abstract virtual AttributeDefinition`2<string, string> get_ErrorMessage();
    public abstract virtual AttributeDefinition`2<string, string> get_ErrorType();
    public abstract virtual AttributeDefinition`2<string, string> get_ErrorEventSpanId();
    public abstract virtual AttributeDefinition`2<string, string> get_ErrorGroup();
    public abstract virtual AttributeDefinition`2<string, string> get_EndUserId();
    public abstract virtual AttributeDefinition`2<float, double> get_ExternalCallCount();
    public abstract virtual AttributeDefinition`2<float, double> get_ExternalDuration();
    public abstract virtual AttributeDefinition`2<string, string> get_Guid();
    public abstract virtual AttributeDefinition`2<string, string> get_HostDisplayName();
    public abstract virtual AttributeDefinition`2<string, string> get_HttpMethod();
    public abstract virtual AttributeDefinition`2<Nullable`1<long>, long> get_HttpStatusCode();
    public abstract virtual AttributeDefinition`2<Uri, string> get_HttpUrl();
    public abstract virtual AttributeDefinition`2<bool, bool> get_IsError();
    public abstract virtual AttributeDefinition`2<string, string> get_NameForSpan();
    public abstract virtual AttributeDefinition`2<bool, bool> get_NrEntryPoint();
    public abstract virtual AttributeDefinition`2<string, string> get_NrGuid();
    public abstract virtual AttributeDefinition`2<string, string> get_OriginalUrl();
    public abstract virtual AttributeDefinition`2<string, string> get_ParentAccount();
    public abstract virtual AttributeDefinition`2<string, string> get_ParentAccountForSpan();
    public abstract virtual AttributeDefinition`2<string, string> get_ParentApp();
    public abstract virtual AttributeDefinition`2<string, string> get_ParentAppForSpan();
    public abstract virtual AttributeDefinition`2<string, string> get_ParentId();
    public abstract virtual AttributeDefinition`2<string, string> get_ParentSpanId();
    public abstract virtual AttributeDefinition`2<TimeSpan, double> get_ParentTransportDuration();
    public abstract virtual AttributeDefinition`2<TimeSpan, double> get_ParentTransportDurationForSpan();
    public abstract virtual AttributeDefinition`2<TransportType, string> get_ParentTransportType();
    public abstract virtual AttributeDefinition`2<TransportType, string> get_ParentTransportTypeForSpan();
    public abstract virtual AttributeDefinition`2<TypeAttributeValue, string> get_ParentType();
    public abstract virtual AttributeDefinition`2<TypeAttributeValue, string> get_ParentTypeForSpan();
    public abstract virtual AttributeDefinition`2<DistributedTracingParentType, string> get_ParentTypeForDistributedTracing();
    public abstract virtual AttributeDefinition`2<DistributedTracingParentType, string> get_ParentTypeForDistributedTracingForSpan();
    public abstract virtual AttributeDefinition`2<string, string> get_PeerAddress();
    public abstract virtual AttributeDefinition`2<string, string> get_PeerHostname();
    public abstract virtual AttributeDefinition`2<float, double> get_Priority();
    public abstract virtual AttributeDefinition`2<Nullable`1<TimeSpan>, double> get_QueueDuration();
    public abstract virtual AttributeDefinition`2<Nullable`1<TimeSpan>, string> get_QueueWaitTime();
    public abstract virtual AttributeDefinition`2<string, string> get_RequestReferrer();
    public abstract virtual AttributeDefinition`2<string, string> get_RequestMethod();
    public abstract virtual AttributeDefinition`2<string, string> get_RequestUri();
    public abstract virtual AttributeDefinition`2<Nullable`1<int>, string> get_ResponseStatus();
    public abstract virtual AttributeDefinition`2<bool, bool> get_Sampled();
    public abstract virtual AttributeDefinition`2<string, string> get_ServerAddress();
    public abstract virtual AttributeDefinition`2<long, long> get_ServerPort();
    public abstract virtual AttributeDefinition`2<SpanCategory, string> get_SpanCategory();
    public abstract virtual AttributeDefinition`2<string, string> get_SpanErrorClass();
    public abstract virtual AttributeDefinition`2<string, string> get_SpanErrorMessage();
    public abstract virtual AttributeDefinition`2<string, string> get_SpanId();
    public abstract virtual AttributeDefinition`2<string, string> get_SpanKind();
    public abstract virtual AttributeDefinition`2<string, string> get_SyntheticsJobId();
    public abstract virtual AttributeDefinition`2<string, string> get_SyntheticsJobIdForTraces();
    public abstract virtual AttributeDefinition`2<string, string> get_SyntheticsMonitorId();
    public abstract virtual AttributeDefinition`2<string, string> get_SyntheticsMonitorIdForTraces();
    public abstract virtual AttributeDefinition`2<string, string> get_SyntheticsResourceId();
    public abstract virtual AttributeDefinition`2<string, string> get_SyntheticsResourceIdForTraces();
    public abstract virtual AttributeDefinition`2<long, long> get_ThreadId();
    public abstract virtual AttributeDefinition`2<DateTime, long> get_Timestamp();
    public abstract virtual AttributeDefinition`2<DateTime, long> get_TimestampForError();
    public abstract virtual AttributeDefinition`2<TimeSpan, double> get_TotalTime();
    public abstract virtual AttributeDefinition`2<string, string> get_TransactionId();
    public abstract virtual AttributeDefinition`2<IEnumerable`1<string>, string> get_TracingVendors();
    public abstract virtual AttributeDefinition`2<string, string> get_TransactionName();
    public abstract virtual AttributeDefinition`2<string, string> get_TransactionNameForSpan();
    public abstract virtual AttributeDefinition`2<string, string> get_TransactionNameForError();
    public abstract virtual AttributeDefinition`2<string, string> get_TripId();
    public abstract virtual AttributeDefinition`2<string, string> get_TrustedParentId();
    public abstract virtual AttributeDefinition`2<TimeSpan, double> get_WebDuration();
    public abstract virtual AttributeDefinition`2<object, object> GetCustomAttributeForCustomEvent(string name);
    public abstract virtual AttributeDefinition`2<object, object> GetCustomAttributeForError(string name);
    public abstract virtual AttributeDefinition`2<object, object> GetCustomAttributeForSpan(string name);
    public abstract virtual AttributeDefinition`2<object, object> GetCustomAttributeForTransaction(string name);
    public abstract virtual AttributeDefinition`2<object, object> GetLambdaAttribute(string name);
    public abstract virtual AttributeDefinition`2<object, object> GetFaasAttribute(string name);
    public abstract virtual AttributeDefinition`2<string, string> GetRequestParameterAttribute(string paramName);
    public abstract virtual AttributeDefinition`2<string, string> GetRequestHeadersAttribute(string paramName);
    public abstract virtual AttributeDefinition`2<TypeAttributeValue, string> GetTypeAttribute(TypeAttributeValue destination);
    public abstract virtual AttributeDefinition`2<bool, bool> get_LlmTransaction();
    public abstract virtual AttributeDefinition`2<string, string> get_CloudAccountId();
    public abstract virtual AttributeDefinition`2<string, string> get_CloudRegion();
    public abstract virtual AttributeDefinition`2<string, string> get_MessagingSystemName();
    public abstract virtual AttributeDefinition`2<string, string> get_MessagingDestinationName();
    public abstract virtual AttributeDefinition`2<string, string> get_BrokerServerAddress();
    public abstract virtual AttributeDefinition`2<int, int> get_BrokerServerPort();
    public abstract virtual AttributeDefinition`2<string, string> get_MessageQueueName();
    public abstract virtual AttributeDefinition`2<string, string> get_MessageRoutingKey();
    public abstract virtual AttributeDefinition`2<string, string> get_MessagingRabbitMqDestinationRoutingKey();
    public abstract virtual AttributeDefinition`2<string, string> get_MessagingDestinationPublishName();
}
public interface NewRelic.Agent.Core.Attributes.IAttributeDefinitionService {
    public IAttributeDefinitions AttributeDefs { get; }
    public abstract virtual IAttributeDefinitions get_AttributeDefs();
}
public interface NewRelic.Agent.Core.Attributes.IAttributeFilter {
    public abstract virtual bool ShouldExcludeAttribute(string name, AttributeDestinations defaultDestinations, AttributeDestinations destination);
    public abstract virtual bool ShouldFilterAttribute(AttributeDestinations targetObjectType);
    public abstract virtual bool CheckOrAddAttributeClusionCache(string name, AttributeDestinations defaultDestinations, AttributeDestinations destination);
}
public interface NewRelic.Agent.Core.Attributes.IAttributeValue {
    public AttributeDefinition AttributeDefinition { get; }
    public object Value { get; public set; }
    public Lazy`1<object> LazyValue { get; public set; }
    public abstract virtual AttributeDefinition get_AttributeDefinition();
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    public abstract virtual Lazy`1<object> get_LazyValue();
    public abstract virtual void set_LazyValue(Lazy`1<object> value);
    public abstract virtual void MakeImmutable();
}
public interface NewRelic.Agent.Core.Attributes.IAttributeValueCollection {
    public AttributeDestinations[] TargetModelTypes { get; }
    public AttributeDestinations TargetModelTypesAsFlags { get; }
    public int Count { get; }
    public bool IsImmutable { get; }
    public abstract virtual AttributeDestinations[] get_TargetModelTypes();
    public abstract virtual AttributeDestinations get_TargetModelTypesAsFlags();
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsImmutable();
    public abstract virtual void AddRange(IAttributeValueCollection fromCollection);
    public abstract virtual void MakeImmutable();
    public abstract virtual bool TrySetValue(AttributeDefinition`2<TInput, TOutput> attribDef, TOutput value);
    public abstract virtual bool TrySetValue(AttributeDefinition`2<TInput, TOutput> attribDef, Lazy`1<object> lazyImpl);
    public abstract virtual bool TrySetValue(IAttributeValue attrib);
    public abstract virtual IEnumerable`1<IAttributeValue> GetAttributeValues(AttributeClassification classification);
    public abstract virtual IDictionary`2<string, object> GetAttributeValuesDic(AttributeClassification classification);
    public abstract virtual IDictionary`2<string, object> GetAllAttributeValuesDic();
}
public interface NewRelic.Agent.Core.Attributes.ILogContextDataFilter {
    public abstract virtual Dictionary`2<string, object> FilterLogContextData(Dictionary`2<string, object> contextData);
}
public class NewRelic.Agent.Core.Attributes.LogContextDataFilter : ConfigurationBasedService {
    private IConfigurationService _configurationService;
    private List`1<LogContextDataFilterRule> _includeRuleList;
    private List`1<LogContextDataFilterRule> _excludeRuleList;
    private List`1<LogContextDataFilterRule> _orderedCludeRuleList;
    private ConcurrentDictionary`2<string, bool> _clusionCache;
    private static int MaxCacheSize;
    private bool _clusionCacheSizeExceededWarningLogged;
    public LogContextDataFilter(IConfigurationService configurationService);
    public sealed virtual Dictionary`2<string, object> FilterLogContextData(Dictionary`2<string, object> unfilteredContextData);
    private bool GetClusionResult(string key);
    private bool RuleMatches(LogContextDataFilterRule rule, string text);
    private List`1<LogContextDataFilterRule> GetCludeRulesFromConfig(bool isIncludeRules);
    private List`1<LogContextDataFilterRule> GetOrderedCludeRuleList();
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
public class NewRelic.Agent.Core.Attributes.LogContextDataFilterRule : object {
    private string _text;
    private bool _include;
    private int _specificity;
    private bool _isWildCard;
    public string Text { get; }
    public bool Include { get; }
    public int Specificity { get; }
    public bool IsWildCard { get; }
    public LogContextDataFilterRule(string text, bool include);
    public string get_Text();
    public bool get_Include();
    public int get_Specificity();
    public bool get_IsWildCard();
}
public class NewRelic.Agent.Core.Attributes.TrieBuilder`1 : object {
    private Func`1<T> _rootNodeMetaDataFactory;
    private Func`2<IEnumerable`1<T>, T> _nodeMerger;
    private Func`2<T, bool> _canNodeHaveChildrenChecker;
    private TrieNodeComparor`1<T> _nodeComparor;
    public TrieBuilder`1(Func`1<T> rootNodeDataFactory, Func`2<IEnumerable`1<T>, T> nodeDataMerger, Func`3<T, T, int> nodeDataComparor, Func`2<T, int> nodeDataHasher, Func`3<T, T, bool> canParentAcceptChildChecker, Func`2<T, bool> canNodeHaveChildrenChecker);
    public TrieNode`1<T> CreateTrie(IEnumerable`1<T> nodeMetaDatas);
    private static TrieNode`1<T> TrieNodeFromData(T metaData);
    private static bool NodeDataGroupingIsNotEmpty(IGrouping`2<T, T> nodes);
    private T MergeNodeDatas(IGrouping`2<T, T> nodes);
    private bool TryAddNodeAsChild(TrieNode`1<T> parent, TrieNode`1<T> orphan);
}
public class NewRelic.Agent.Core.Attributes.TrieNode`1 : object {
    public T Data;
    public ICollection`1<TrieNode`1<T>> Children;
    public TrieNode`1(T metaData);
}
internal class NewRelic.Agent.Core.Attributes.TrieNodeComparor`1 : object {
    private Func`3<T, T, int> _nodeComparor;
    private Func`2<T, int> _nodeHasher;
    private Func`3<T, T, bool> _potentialChildChecker;
    public TrieNodeComparor`1(Func`3<T, T, int> nodeComparor, Func`2<T, int> nodeHasher, Func`3<T, T, bool> potentialChildChecker);
    public sealed virtual int Compare(T left, T right);
    public sealed virtual bool Equals(T left, T right);
    public sealed virtual int GetHashCode(T node);
    public bool PotentialChild(T parent, T child);
}
public enum NewRelic.Agent.Core.Attributes.TypeAttributeValue : Enum {
    public int value__;
    public static TypeAttributeValue Transaction;
    public static TypeAttributeValue TransactionError;
    public static TypeAttributeValue Span;
}
public class NewRelic.Agent.Core.BrowserMonitoring.BrowserMonitoringConfigurationData : object {
    private static JsonSerializerSettings _jsonSettings;
    [CompilerGeneratedAttribute]
private string <Beacon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorBeacon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BrowserLicenseKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObfuscatedTransactionName>k__BackingField;
    private TimeSpan _queueTime;
    private TimeSpan _applicationTime;
    [CompilerGeneratedAttribute]
private string <Agent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObfuscatedUserAttributes>k__BackingField;
    private bool _sslForHttp;
    [JsonPropertyAttribute("beacon")]
public string Beacon { get; }
    [JsonPropertyAttribute("errorBeacon")]
public string ErrorBeacon { get; }
    [JsonPropertyAttribute("licenseKey")]
public string BrowserLicenseKey { get; }
    [JsonPropertyAttribute("applicationID")]
public string ApplicationId { get; }
    [JsonPropertyAttribute("transactionName")]
public string ObfuscatedTransactionName { get; }
    [JsonPropertyAttribute("queueTime")]
public int QueueTimeMilliseconds { get; }
    [JsonPropertyAttribute("applicationTime")]
public int ApplicationTimeMilliseconds { get; }
    [JsonPropertyAttribute("agent")]
public string Agent { get; }
    [JsonPropertyAttribute("atts")]
public string ObfuscatedUserAttributes { get; }
    [JsonPropertyAttribute("sslForHttp")]
public string SslForHttp { get; }
    public BrowserMonitoringConfigurationData(string licenseKey, string beacon, string errorBeacon, string browserMonitoringKey, string applicationId, string obfuscatedTransactionName, TimeSpan queueTime, TimeSpan applicationTime, string jsAgentPayloadFile, string obfuscatedFormattedAttributes, bool sslForHttp);
    private static BrowserMonitoringConfigurationData();
    [CompilerGeneratedAttribute]
public string get_Beacon();
    [CompilerGeneratedAttribute]
public string get_ErrorBeacon();
    [CompilerGeneratedAttribute]
public string get_BrowserLicenseKey();
    [CompilerGeneratedAttribute]
public string get_ApplicationId();
    [CompilerGeneratedAttribute]
public string get_ObfuscatedTransactionName();
    public int get_QueueTimeMilliseconds();
    public int get_ApplicationTimeMilliseconds();
    [CompilerGeneratedAttribute]
public string get_Agent();
    [CompilerGeneratedAttribute]
public string get_ObfuscatedUserAttributes();
    public string get_SslForHttp();
    public string ToJsonString();
}
public class NewRelic.Agent.Core.BrowserMonitoring.BrowserMonitoringPrereqChecker : object {
    private IConfigurationService _configurationService;
    public BrowserMonitoringPrereqChecker(IConfigurationService configurationService);
    public sealed virtual bool ShouldManuallyInject(IInternalTransaction transaction);
    public sealed virtual bool ShouldAutomaticallyInject(IInternalTransaction transaction, string requestPath, string contentType);
    private bool IsValidBrowserMonitoringJavaScriptAgentLoaderType();
    private static bool IsHtmlContent(string contentType);
    private static bool BrowserInstrumentationAllowedForUrlPath(string requestPath, IEnumerable`1<Regex> requestPathExclusionList);
    private static bool IsMatch(string path, Regex regex);
}
public class NewRelic.Agent.Core.BrowserMonitoring.BrowserMonitoringScriptMaker : object {
    private BrowserEventWireModelSerializer _jsonConverter;
    private IConfigurationService _configurationService;
    private ITransactionMetricNameMaker _transactionMetricNameMaker;
    private ITransactionAttributeMaker _transactionAttributeMaker;
    private IAttributeDefinitionService _attribDefSvc;
    private static TimeSpan _zeroTimespan;
    public BrowserMonitoringScriptMaker(IConfigurationService configurationService, ITransactionMetricNameMaker transactionMetricNameMaker, ITransactionAttributeMaker transactionAttributeMaker, IAttributeDefinitionService attribDefSvc);
    private static BrowserMonitoringScriptMaker();
    public sealed virtual string GetScript(IInternalTransaction transaction, string nonce);
    private BrowserMonitoringConfigurationData GetBrowserConfigurationData(IInternalTransaction transaction, TransactionMetricName transactionMetricName, string licenseKey);
    private string GetObfuscatedFormattedAttributes(AttributeValueCollection attribValues, string licenseKey);
}
public class NewRelic.Agent.Core.BrowserMonitoring.BrowserMonitoringStreamInjector : Stream {
    private BrowserMonitoringWriter _jsWriter;
    private Encoding _contentEncoding;
    private Action`3<Byte[], int, int> _streamWriter;
    [CompilerGeneratedAttribute]
private Stream <OutputStream>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private Stream OutputStream { get; }
    public BrowserMonitoringStreamInjector(Func`1<string> getJavascriptAgentScript, Stream output, Encoding contentEncoding, BrowserMonitoringWriter browserMonitoringWriter);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    [CompilerGeneratedAttribute]
private Stream get_OutputStream();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void PassThroughStreamWriter(Byte[] buffer, int offset, int count);
    private Action`3<Byte[], int, int> GetInjectingStreamWriter(Encoding contentEncoding);
    private Byte[] TryGetInjectedBytes(Encoding contentEncoding, Byte[] buffer, int offset, int count);
    private Byte[] TryGetBrowserMonitoringHeaders(Encoding contentEncoding, string content);
}
public class NewRelic.Agent.Core.BrowserMonitoring.BrowserMonitoringWriter : object {
    private Func`1<string> _getJsScript;
    private static Regex XUaCompatibleFilter;
    private static Regex CharsetFilter;
    public BrowserMonitoringWriter(Func`1<string> getJsScript);
    private static BrowserMonitoringWriter();
    private Nullable`1<int> FindFirstOpeningHeadTag(string content);
    private string AttemptInsertionPriorToBodyTag(string content);
    public virtual string WriteScriptHeaders(string content);
}
public static class NewRelic.Agent.Core.BrowserMonitoring.BrowserScriptInjectionHelper : object {
    [AsyncStateMachineAttribute("NewRelic.Agent.Core.BrowserMonitoring.BrowserScriptInjectionHelper/<InjectBrowserScriptAsync>d__0")]
public static Task InjectBrowserScriptAsync(Byte[] buffer, Stream baseStream, Byte[] rumBytes, ITransaction transaction);
}
internal static class NewRelic.Agent.Core.BrowserMonitoring.BrowserScriptInjectionIndexHelper : object {
    private static Regex XUaCompatibleFilter;
    private static Regex CharsetFilter;
    private static BrowserScriptInjectionIndexHelper();
    public static int TryFindInjectionIndex(Byte[] content);
    private static int FindIndexBeforeBodyTag(Byte[] content, string contentAsString);
    private static int FindFirstOpeningHeadTag(string content);
    private static int IndexOfByteArray(Byte[] buffer, string stringToFind, Int32& stringToFindBytesLength, Encoding encoding);
}
public interface NewRelic.Agent.Core.BrowserMonitoring.IBrowserMonitoringPrereqChecker {
    public abstract virtual bool ShouldManuallyInject(IInternalTransaction transaction);
    public abstract virtual bool ShouldAutomaticallyInject(IInternalTransaction transaction, string requestPath, string contentType);
}
public interface NewRelic.Agent.Core.BrowserMonitoring.IBrowserMonitoringScriptMaker {
    public abstract virtual string GetScript(IInternalTransaction transaction, string nonce);
}
public class NewRelic.Agent.Core.CallStack.AsyncCallStackManagerFactory : object {
    private IContextStorage`1<Nullable`1<int>> _storageContext;
    public AsyncCallStackManagerFactory(IContextStorageFactory factory);
    public sealed virtual ICallStackManager CreateCallStackManager();
}
public abstract class NewRelic.Agent.Core.CallStack.BaseCallStackManager : object {
    protected IContextStorage`1<Nullable`1<int>> CurrentStorage { get; }
    protected abstract virtual IContextStorage`1<Nullable`1<int>> get_CurrentStorage();
    public sealed virtual void Push(int id);
    public sealed virtual void TryPop(int uniqueId, Nullable`1<int> parentId);
    public sealed virtual Nullable`1<int> TryPeek();
    public sealed virtual void Clear();
    public virtual bool AttachToAsync();
}
public class NewRelic.Agent.Core.CallStack.CallStackManager : BaseCallStackManager {
    private IEnumerable`1<IContextStorage`1<Nullable`1<int>>> _parentTrackers;
    protected IContextStorage`1<Nullable`1<int>> CurrentStorage { get; }
    public CallStackManager(List`1<IContextStorage`1<Nullable`1<int>>> parentTrackers);
    protected virtual IContextStorage`1<Nullable`1<int>> get_CurrentStorage();
}
public class NewRelic.Agent.Core.CallStack.CallStackManagerFactory : object {
    private IEnumerable`1<IContextStorageFactory> _storageFactories;
    public CallStackManagerFactory(IEnumerable`1<IContextStorageFactory> storageFactories);
    public sealed virtual ICallStackManager CreateCallStackManager();
}
public class NewRelic.Agent.Core.CallStack.CallStackPop : MulticastDelegate {
    public CallStackPop(object object, IntPtr method);
    public virtual void Invoke(object uniqueObject, object uniqueParent);
    public virtual IAsyncResult BeginInvoke(object uniqueObject, object uniqueParent, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface NewRelic.Agent.Core.CallStack.ICallStackManager {
    public abstract virtual void Push(int uniqueId);
    public abstract virtual void TryPop(int uniqueId, Nullable`1<int> parentId);
    public abstract virtual Nullable`1<int> TryPeek();
    public abstract virtual void Clear();
    public abstract virtual bool AttachToAsync();
}
public interface NewRelic.Agent.Core.CallStack.ICallStackManagerFactory {
    public abstract virtual ICallStackManager CreateCallStackManager();
}
public class NewRelic.Agent.Core.CallStack.ResolvedCallStackManagerFactory : object {
    private ICallStackManagerFactory _callStackManagerFactory;
    public ResolvedCallStackManagerFactory(IEnumerable`1<IContextStorageFactory> storageFactories);
    private static ICallStackManagerFactory CreateFactory(IEnumerable`1<IContextStorageFactory> storageFactories);
    public sealed virtual ICallStackManager CreateCallStackManager();
    private static IContextStorageFactory GetThreadLocalContextStorageFactory();
}
public class NewRelic.Agent.Core.CallStack.SyncToAsyncCallStackManager : BaseCallStackManager {
    private IContextStorage`1<Nullable`1<int>> _asyncContextStorage;
    private IContextStorage`1 modreq(System.Runtime.CompilerServices.IsVolatile) _currentContextStorage;
    protected IContextStorage`1<Nullable`1<int>> CurrentStorage { get; }
    public SyncToAsyncCallStackManager(IContextStorage`1<Nullable`1<int>> asyncContextStorage);
    public virtual bool AttachToAsync();
    protected virtual IContextStorage`1<Nullable`1<int>> get_CurrentStorage();
}
public abstract class NewRelic.Agent.Core.Commands.AbstractCommand : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public abstract virtual object Process(IDictionary`2<string, object> arguments);
}
public class NewRelic.Agent.Core.Commands.CommandDetails : object {
    [JsonPropertyAttribute("name")]
public string Name;
    [JsonPropertyAttribute("arguments")]
public IDictionary`2<string, object> Arguments;
    public CommandDetails(string name, IDictionary`2<string, object> arguments);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.Commands.CommandModel : object {
    [JsonArrayIndexAttribute]
public int CommandId;
    [JsonArrayIndexAttribute]
public CommandDetails Details;
    public CommandModel(int commandId, CommandDetails details);
}
public class NewRelic.Agent.Core.Commands.CommandService : DisposableService {
    private IDictionary`2<string, ICommand> _knownCommands;
    private IDataTransportService _dataTransportService;
    private IScheduler _scheduler;
    private IConfigurationService _configurationService;
    public CommandService(IDataTransportService dataTransportService, IScheduler scheduler, IConfigurationService configurationService);
    public virtual void Dispose();
    public void AddCommands(ICommand[] commands);
    private void GetAndExecuteAgentCommands();
    public IDictionary`2<string, object> ProcessCommands(IEnumerable`1<CommandModel> commandModels);
}
public interface NewRelic.Agent.Core.Commands.ICommand {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual object Process(IDictionary`2<string, object> arguments);
}
public class NewRelic.Agent.Core.Commands.InstrumentationUpdateCommand : AbstractCommand {
    private IInstrumentationService _instrumentationService;
    public InstrumentationUpdateCommand(IInstrumentationService instrumentationService);
    public virtual object Process(IDictionary`2<string, object> arguments);
    private string InstrumentationUpdate(IDictionary`2<string, object> arguments);
}
public class NewRelic.Agent.Core.Commands.RestartCommand : AbstractCommand {
    public virtual object Process(IDictionary`2<string, object> arguments);
}
public class NewRelic.Agent.Core.Commands.ShutdownCommand : AbstractCommand {
    public virtual object Process(IDictionary`2<string, object> arguments);
}
public class NewRelic.Agent.Core.Commands.StartThreadProfilerCommand : AbstractCommand {
    [CompilerGeneratedAttribute]
private IThreadProfilingSessionControl <ThreadProfilingService>k__BackingField;
    public IThreadProfilingSessionControl ThreadProfilingService { get; public set; }
    public StartThreadProfilerCommand(IThreadProfilingSessionControl threadProfilingService);
    [CompilerGeneratedAttribute]
public IThreadProfilingSessionControl get_ThreadProfilingService();
    [CompilerGeneratedAttribute]
public void set_ThreadProfilingService(IThreadProfilingSessionControl value);
    public virtual object Process(IDictionary`2<string, object> arguments);
    private string StartThreadProfilingSessions(IDictionary`2<string, object> arguments);
}
public class NewRelic.Agent.Core.Commands.StopThreadProfilerCommand : AbstractCommand {
    [CompilerGeneratedAttribute]
private IThreadProfilingSessionControl <ThreadProfilingService>k__BackingField;
    public IThreadProfilingSessionControl ThreadProfilingService { get; public set; }
    public StopThreadProfilerCommand(IThreadProfilingSessionControl threadProfilingService);
    [CompilerGeneratedAttribute]
public IThreadProfilingSessionControl get_ThreadProfilingService();
    [CompilerGeneratedAttribute]
public void set_ThreadProfilingService(IThreadProfilingSessionControl value);
    public virtual object Process(IDictionary`2<string, object> arguments);
    private string StopThreadProfilingSessions(IDictionary`2<string, object> arguments);
}
public class NewRelic.Agent.Core.Commands.ThreadProfilerCommandArgs : object {
    private bool _ignoreMinMinimumSamplingDuration;
    public static float MinimumSamplingFrequencySeconds;
    public static float MinimumSamplingDurationSeconds;
    public static float MaximumSamplingFrequencySeconds;
    public static float MaximumSamplingDurationSeconds;
    public static float DefaultSamplingFrequencySeconds;
    public static float DefaultSamplingDurationSeconds;
    public int ProfileId;
    public UInt32 Frequency;
    public UInt32 Duration;
    public bool ReportData;
    public ThreadProfilerCommandArgs(IDictionary`2<string, object> arguments, bool ignoreMinMinimumSamplingDuration);
    private UInt32 ParseFloatArgument(IDictionary`2<string, object> arguments, string argumentName, float defaultValue, float minValue, float maxValue);
    private bool ParseBooleanArgument(IDictionary`2<string, object> arguments, string argumentName, bool defaultValue);
}
public class NewRelic.Agent.Core.Config.BootstrapConfiguration : object {
    private IConfigurationManagerStatic _configurationManagerStatic;
    private Func`2<string, ValueWithProvenance`1<string>> _getWebConfigSettingWithProvenance;
    private ValueWithProvenance`1<bool> _agentEnabledWithProvenance;
    private bool _agentEnabledValueFromLocalConfig;
    [CompilerGeneratedAttribute]
private bool <ServerlessModeEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerlessFunctionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerlessFunctionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DebugStartupDelaySeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogConfig <LogConfig>k__BackingField;
    public bool ServerlessModeEnabled { get; private set; }
    public string ServerlessFunctionName { get; private set; }
    public string ServerlessFunctionVersion { get; private set; }
    public int DebugStartupDelaySeconds { get; private set; }
    public string ConfigurationFileName { get; private set; }
    public bool AgentEnabled { get; }
    public string AgentEnabledAt { get; }
    public ILogConfig LogConfig { get; private set; }
    public bool AzureFunctionModeDetected { get; }
    public BootstrapConfiguration(configuration localConfiguration, string configurationFileName);
    public BootstrapConfiguration(configuration localConfiguration, string configurationFileName, Func`2<string, ValueWithProvenance`1<string>> getWebConfigSettingWithProvenance, IConfigurationManagerStatic configurationManagerStatic, IProcessStatic processStatic, Predicate`1<string> checkDirectoryExists, Func`2<string, string> getFullPath);
    public static IBootstrapConfiguration GetDefault();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ServerlessModeEnabled();
    [CompilerGeneratedAttribute]
private void set_ServerlessModeEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServerlessFunctionName();
    [CompilerGeneratedAttribute]
private void set_ServerlessFunctionName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServerlessFunctionVersion();
    [CompilerGeneratedAttribute]
private void set_ServerlessFunctionVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DebugStartupDelaySeconds();
    [CompilerGeneratedAttribute]
private void set_DebugStartupDelaySeconds(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConfigurationFileName();
    [CompilerGeneratedAttribute]
private void set_ConfigurationFileName(string value);
    public sealed virtual bool get_AgentEnabled();
    public sealed virtual string get_AgentEnabledAt();
    [CompilerGeneratedAttribute]
public sealed virtual ILogConfig get_LogConfig();
    [CompilerGeneratedAttribute]
private void set_LogConfig(ILogConfig value);
    public sealed virtual bool get_AzureFunctionModeDetected();
    private bool CheckServerlessModeEnabled(configuration localConfiguration);
    private void SetAgentEnabledValues();
    private ValueWithProvenance`1<bool> TryGetAgentEnabledFromWebConfig();
    private ValueWithProvenance`1<bool> TryGetAgentEnabledFromAppSettings();
    private ValueWithProvenance`1<bool> TryGetAgentEnabledSetting(Func`2<string, ValueWithProvenance`1<string>> getStringValueWithProvenance);
    [CompilerGeneratedAttribute]
private ValueWithProvenance`1<string> <TryGetAgentEnabledFromAppSettings>g__getStringValueWithProvenance|41_0(string key);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Config.ConfigLoaderHelpers : object {
    public static IEnvironment EnvironmentVariableProxy;
    private static ConfigLoaderHelpers();
    public static string GetEnvironmentVar(string name);
    public static string GetOverride(string name, string fallback);
    public static int GetOverride(string name, int fallback);
    public static bool GetOverride(string name, bool fallback);
    [ExtensionAttribute]
public static bool TryToBoolean(string val, Boolean& boolVal);
    public static bool GetLoggingEnabledValue(configurationLog localLogConfiguration);
    public static string GetLoggingLevelValue(configurationLog localLogConfiguration, bool isLoggingEnabled);
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute]
public class NewRelic.Agent.Core.Config.configuration : object {
    private configurationService serviceField;
    private configurationDiagnostics diagnosticsField;
    private configurationApplication applicationField;
    private string securityPoliciesTokenField;
    private configurationLog logField;
    private configurationInstrumentation instrumentationField;
    private configurationAllowAllHeaders allowAllHeadersField;
    private configurationAttributes attributesField;
    private configurationParameterGroups parameterGroupsField;
    private configurationRequestParameters requestParametersField;
    private configurationCustomParameters customParametersField;
    private configurationAnalyticsEvents analyticsEventsField;
    private configurationCustomEvents customEventsField;
    private configurationTransactionEvents transactionEventsField;
    private configurationDataTransmission dataTransmissionField;
    private configurationTransactionTracer transactionTracerField;
    private configurationDatastoreTracer datastoreTracerField;
    private configurationCrossApplicationTracer crossApplicationTracerField;
    private configurationInfiniteTracing infiniteTracingField;
    private configurationDistributedTracing distributedTracingField;
    private configurationSpanEvents spanEventsField;
    private configurationHighSecurity highSecurityField;
    private configurationCustomInstrumentationEditor customInstrumentationEditorField;
    private configurationStripExceptionMessages stripExceptionMessagesField;
    private configurationSlowSql slowSqlField;
    private configurationErrorCollector errorCollectorField;
    private configurationBrowserMonitoring browserMonitoringField;
    private configurationApplicationPools applicationPoolsField;
    private configurationAiMonitoring aiMonitoringField;
    private configurationApplicationLogging applicationLoggingField;
    private List`1<string> threadProfilingField;
    private string labelsField;
    private List`1<configurationAdd> appSettingsField;
    private configurationUtilization utilizationField;
    private configurationProcessHost processHostField;
    private configurationCodeLevelMetrics codeLevelMetricsField;
    private bool agentEnabledField;
    private bool rootAgentEnabledField;
    private int maxStackTraceLinesField;
    private bool debugAgentField;
    private int debugStartupDelaySecondsField;
    private bool threadProfilingEnabledField;
    private bool crossApplicationTracingEnabledField;
    private configurationTimingPrecision timingPrecisionField;
    private bool serverlessModeEnabledField;
    public configurationService service { get; public set; }
    public configurationDiagnostics diagnostics { get; public set; }
    public configurationApplication application { get; public set; }
    public string securityPoliciesToken { get; public set; }
    public configurationLog log { get; public set; }
    public configurationInstrumentation instrumentation { get; public set; }
    public configurationAllowAllHeaders allowAllHeaders { get; public set; }
    public configurationAttributes attributes { get; public set; }
    public configurationParameterGroups parameterGroups { get; public set; }
    public configurationRequestParameters requestParameters { get; public set; }
    public configurationCustomParameters customParameters { get; public set; }
    public configurationAnalyticsEvents analyticsEvents { get; public set; }
    public configurationCustomEvents customEvents { get; public set; }
    public configurationTransactionEvents transactionEvents { get; public set; }
    public configurationDataTransmission dataTransmission { get; public set; }
    public configurationTransactionTracer transactionTracer { get; public set; }
    public configurationDatastoreTracer datastoreTracer { get; public set; }
    public configurationCrossApplicationTracer crossApplicationTracer { get; public set; }
    public configurationInfiniteTracing infiniteTracing { get; public set; }
    public configurationDistributedTracing distributedTracing { get; public set; }
    public configurationSpanEvents spanEvents { get; public set; }
    public configurationHighSecurity highSecurity { get; public set; }
    public configurationCustomInstrumentationEditor customInstrumentationEditor { get; public set; }
    public configurationStripExceptionMessages stripExceptionMessages { get; public set; }
    public configurationSlowSql slowSql { get; public set; }
    public configurationErrorCollector errorCollector { get; public set; }
    public configurationBrowserMonitoring browserMonitoring { get; public set; }
    public configurationApplicationPools applicationPools { get; public set; }
    public configurationAiMonitoring aiMonitoring { get; public set; }
    public configurationApplicationLogging applicationLogging { get; public set; }
    [XmlArrayItemAttribute("ignoreMethod")]
public List`1<string> threadProfiling { get; public set; }
    public string labels { get; public set; }
    [XmlArrayItemAttribute("add")]
public List`1<configurationAdd> appSettings { get; public set; }
    public configurationUtilization utilization { get; public set; }
    public configurationProcessHost processHost { get; public set; }
    public configurationCodeLevelMetrics codeLevelMetrics { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool agentEnabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool rootAgentEnabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("80")]
public int maxStackTraceLines { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool debugAgent { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("0")]
public int debugStartupDelaySeconds { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool threadProfilingEnabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool crossApplicationTracingEnabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public configurationTimingPrecision timingPrecision { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool serverlessModeEnabled { get; public set; }
    public configurationService get_service();
    public void set_service(configurationService value);
    public configurationDiagnostics get_diagnostics();
    public void set_diagnostics(configurationDiagnostics value);
    public configurationApplication get_application();
    public void set_application(configurationApplication value);
    public string get_securityPoliciesToken();
    public void set_securityPoliciesToken(string value);
    public configurationLog get_log();
    public void set_log(configurationLog value);
    public configurationInstrumentation get_instrumentation();
    public void set_instrumentation(configurationInstrumentation value);
    public configurationAllowAllHeaders get_allowAllHeaders();
    public void set_allowAllHeaders(configurationAllowAllHeaders value);
    public configurationAttributes get_attributes();
    public void set_attributes(configurationAttributes value);
    public configurationParameterGroups get_parameterGroups();
    public void set_parameterGroups(configurationParameterGroups value);
    public configurationRequestParameters get_requestParameters();
    public void set_requestParameters(configurationRequestParameters value);
    public configurationCustomParameters get_customParameters();
    public void set_customParameters(configurationCustomParameters value);
    public configurationAnalyticsEvents get_analyticsEvents();
    public void set_analyticsEvents(configurationAnalyticsEvents value);
    public configurationCustomEvents get_customEvents();
    public void set_customEvents(configurationCustomEvents value);
    public configurationTransactionEvents get_transactionEvents();
    public void set_transactionEvents(configurationTransactionEvents value);
    public configurationDataTransmission get_dataTransmission();
    public void set_dataTransmission(configurationDataTransmission value);
    public configurationTransactionTracer get_transactionTracer();
    public void set_transactionTracer(configurationTransactionTracer value);
    public configurationDatastoreTracer get_datastoreTracer();
    public void set_datastoreTracer(configurationDatastoreTracer value);
    public configurationCrossApplicationTracer get_crossApplicationTracer();
    public void set_crossApplicationTracer(configurationCrossApplicationTracer value);
    public configurationInfiniteTracing get_infiniteTracing();
    public void set_infiniteTracing(configurationInfiniteTracing value);
    public configurationDistributedTracing get_distributedTracing();
    public void set_distributedTracing(configurationDistributedTracing value);
    public configurationSpanEvents get_spanEvents();
    public void set_spanEvents(configurationSpanEvents value);
    public configurationHighSecurity get_highSecurity();
    public void set_highSecurity(configurationHighSecurity value);
    public configurationCustomInstrumentationEditor get_customInstrumentationEditor();
    public void set_customInstrumentationEditor(configurationCustomInstrumentationEditor value);
    public configurationStripExceptionMessages get_stripExceptionMessages();
    public void set_stripExceptionMessages(configurationStripExceptionMessages value);
    public configurationSlowSql get_slowSql();
    public void set_slowSql(configurationSlowSql value);
    public configurationErrorCollector get_errorCollector();
    public void set_errorCollector(configurationErrorCollector value);
    public configurationBrowserMonitoring get_browserMonitoring();
    public void set_browserMonitoring(configurationBrowserMonitoring value);
    public configurationApplicationPools get_applicationPools();
    public void set_applicationPools(configurationApplicationPools value);
    public configurationAiMonitoring get_aiMonitoring();
    public void set_aiMonitoring(configurationAiMonitoring value);
    public configurationApplicationLogging get_applicationLogging();
    public void set_applicationLogging(configurationApplicationLogging value);
    public List`1<string> get_threadProfiling();
    public void set_threadProfiling(List`1<string> value);
    public string get_labels();
    public void set_labels(string value);
    public List`1<configurationAdd> get_appSettings();
    public void set_appSettings(List`1<configurationAdd> value);
    public configurationUtilization get_utilization();
    public void set_utilization(configurationUtilization value);
    public configurationProcessHost get_processHost();
    public void set_processHost(configurationProcessHost value);
    public configurationCodeLevelMetrics get_codeLevelMetrics();
    public void set_codeLevelMetrics(configurationCodeLevelMetrics value);
    public bool get_agentEnabled();
    public void set_agentEnabled(bool value);
    public bool get_rootAgentEnabled();
    public void set_rootAgentEnabled(bool value);
    public int get_maxStackTraceLines();
    public void set_maxStackTraceLines(int value);
    public bool get_debugAgent();
    public void set_debugAgent(bool value);
    public int get_debugStartupDelaySeconds();
    public void set_debugStartupDelaySeconds(int value);
    public bool get_threadProfilingEnabled();
    public void set_threadProfilingEnabled(bool value);
    public bool get_crossApplicationTracingEnabled();
    public void set_crossApplicationTracingEnabled(bool value);
    public configurationTimingPrecision get_timingPrecision();
    public void set_timingPrecision(configurationTimingPrecision value);
    public bool get_serverlessModeEnabled();
    public void set_serverlessModeEnabled(bool value);
    public virtual configuration Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationAdd : object {
    private string keyField;
    private string valueField;
    [XmlAttributeAttribute]
public string key { get; public set; }
    [XmlAttributeAttribute]
public string value { get; public set; }
    public string get_key();
    public void set_key(string value);
    public string get_value();
    public void set_value(string value);
    public virtual configurationAdd Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationAiMonitoring : object {
    private configurationAiMonitoringStreaming streamingField;
    private configurationAiMonitoringRecordContent recordContentField;
    private bool enabledField;
    public configurationAiMonitoringStreaming streaming { get; public set; }
    public configurationAiMonitoringRecordContent recordContent { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool enabled { get; public set; }
    public configurationAiMonitoringStreaming get_streaming();
    public void set_streaming(configurationAiMonitoringStreaming value);
    public configurationAiMonitoringRecordContent get_recordContent();
    public void set_recordContent(configurationAiMonitoringRecordContent value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationAiMonitoring Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationAiMonitoringRecordContent : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationAiMonitoringRecordContent Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationAiMonitoringStreaming : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationAiMonitoringStreaming Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationAllowAllHeaders : object {
    private Nullable`1<bool> enabledField;
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationAllowAllHeaders Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationAnalyticsEvents : object {
    private configurationAnalyticsEventsTransactions transactionsField;
    private Nullable`1<bool> enabledField;
    private Nullable`1<UInt32> maximumSamplesPerMinuteField;
    private Nullable`1<int> maximumSamplesStoredField;
    private Nullable`1<bool> captureAttributesField;
    public configurationAnalyticsEventsTransactions transactions { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    [XmlAttributeAttribute]
public UInt32 maximumSamplesPerMinute { get; public set; }
    [XmlIgnoreAttribute]
public bool maximumSamplesPerMinuteSpecified { get; public set; }
    [XmlAttributeAttribute]
public int maximumSamplesStored { get; public set; }
    [XmlIgnoreAttribute]
public bool maximumSamplesStoredSpecified { get; public set; }
    [XmlAttributeAttribute]
public bool captureAttributes { get; public set; }
    [XmlIgnoreAttribute]
public bool captureAttributesSpecified { get; public set; }
    public configurationAnalyticsEventsTransactions get_transactions();
    public void set_transactions(configurationAnalyticsEventsTransactions value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public UInt32 get_maximumSamplesPerMinute();
    public void set_maximumSamplesPerMinute(UInt32 value);
    public bool get_maximumSamplesPerMinuteSpecified();
    public void set_maximumSamplesPerMinuteSpecified(bool value);
    public int get_maximumSamplesStored();
    public void set_maximumSamplesStored(int value);
    public bool get_maximumSamplesStoredSpecified();
    public void set_maximumSamplesStoredSpecified(bool value);
    public bool get_captureAttributes();
    public void set_captureAttributes(bool value);
    public bool get_captureAttributesSpecified();
    public void set_captureAttributesSpecified(bool value);
    public virtual configurationAnalyticsEvents Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationAnalyticsEventsTransactions : object {
    private Nullable`1<bool> enabledField;
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationAnalyticsEventsTransactions Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplication : object {
    private List`1<string> nameField;
    private bool disableSamplersField;
    [XmlElementAttribute("name")]
public List`1<string> name { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool disableSamplers { get; public set; }
    public List`1<string> get_name();
    public void set_name(List`1<string> value);
    public bool get_disableSamplers();
    public void set_disableSamplers(bool value);
    public virtual configurationApplication Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplicationLogging : object {
    private configurationApplicationLoggingMetrics metricsField;
    private configurationApplicationLoggingForwarding forwardingField;
    private configurationApplicationLoggingLocalDecorating localDecoratingField;
    private bool enabledField;
    public configurationApplicationLoggingMetrics metrics { get; public set; }
    public configurationApplicationLoggingForwarding forwarding { get; public set; }
    public configurationApplicationLoggingLocalDecorating localDecorating { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public configurationApplicationLoggingMetrics get_metrics();
    public void set_metrics(configurationApplicationLoggingMetrics value);
    public configurationApplicationLoggingForwarding get_forwarding();
    public void set_forwarding(configurationApplicationLoggingForwarding value);
    public configurationApplicationLoggingLocalDecorating get_localDecorating();
    public void set_localDecorating(configurationApplicationLoggingLocalDecorating value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationApplicationLogging Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplicationLoggingForwarding : object {
    private configurationApplicationLoggingForwardingContextData contextDataField;
    private bool enabledField;
    private int maxSamplesStoredField;
    private string logLevelDenyListField;
    public configurationApplicationLoggingForwardingContextData contextData { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("10000")]
public int maxSamplesStored { get; public set; }
    [XmlAttributeAttribute]
public string logLevelDenyList { get; public set; }
    public configurationApplicationLoggingForwardingContextData get_contextData();
    public void set_contextData(configurationApplicationLoggingForwardingContextData value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public int get_maxSamplesStored();
    public void set_maxSamplesStored(int value);
    public string get_logLevelDenyList();
    public void set_logLevelDenyList(string value);
    public virtual configurationApplicationLoggingForwarding Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplicationLoggingForwardingContextData : object {
    private bool enabledField;
    private string includeField;
    private string excludeField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string include { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("SpanId,TraceId,ParentId")]
public string exclude { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public string get_include();
    public void set_include(string value);
    public string get_exclude();
    public void set_exclude(string value);
    public virtual configurationApplicationLoggingForwardingContextData Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplicationLoggingLocalDecorating : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationApplicationLoggingLocalDecorating Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplicationLoggingMetrics : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationApplicationLoggingMetrics Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplicationPools : object {
    private configurationApplicationPoolsDefaultBehavior defaultBehaviorField;
    private List`1<configurationApplicationPoolsApplicationPool> applicationPoolField;
    public configurationApplicationPoolsDefaultBehavior defaultBehavior { get; public set; }
    [XmlElementAttribute("applicationPool")]
public List`1<configurationApplicationPoolsApplicationPool> applicationPool { get; public set; }
    public configurationApplicationPoolsDefaultBehavior get_defaultBehavior();
    public void set_defaultBehavior(configurationApplicationPoolsDefaultBehavior value);
    public List`1<configurationApplicationPoolsApplicationPool> get_applicationPool();
    public void set_applicationPool(List`1<configurationApplicationPoolsApplicationPool> value);
    public virtual configurationApplicationPools Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplicationPoolsApplicationPool : object {
    private string nameField;
    private bool instrumentField;
    [XmlAttributeAttribute]
public string name { get; public set; }
    [XmlAttributeAttribute]
public bool instrument { get; public set; }
    public string get_name();
    public void set_name(string value);
    public bool get_instrument();
    public void set_instrument(bool value);
    public virtual configurationApplicationPoolsApplicationPool Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationApplicationPoolsDefaultBehavior : object {
    private bool instrumentField;
    [XmlAttributeAttribute]
public bool instrument { get; public set; }
    public bool get_instrument();
    public void set_instrument(bool value);
    public virtual configurationApplicationPoolsDefaultBehavior Clone();
}
[AttributeUsageAttribute("128")]
public class NewRelic.Agent.Core.Config.ConfigurationAttribute : Attribute {
    private string key;
    private bool convertToString;
    public string Key { get; }
    public bool ConvertToString { get; }
    public ConfigurationAttribute(string key, bool convertToString);
    public string get_Key();
    public bool get_ConvertToString();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationAttributes : object {
    private List`1<string> includeField;
    private List`1<string> excludeField;
    private bool enabledField;
    [XmlElementAttribute("include")]
public List`1<string> include { get; public set; }
    [XmlElementAttribute("exclude")]
public List`1<string> exclude { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public List`1<string> get_include();
    public void set_include(List`1<string> value);
    public List`1<string> get_exclude();
    public void set_exclude(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationAttributes Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationBrowserMonitoring : object {
    private List`1<configurationBrowserMonitoringPath> requestPathsExcludedField;
    private configurationBrowserMonitoringAttributes attributesField;
    private bool autoInstrumentField;
    private string loaderField;
    private bool sslForHttpField;
    private Nullable`1<bool> captureAttributesField;
    [XmlArrayItemAttribute("path")]
public List`1<configurationBrowserMonitoringPath> requestPathsExcluded { get; public set; }
    public configurationBrowserMonitoringAttributes attributes { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool autoInstrument { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("rum")]
public string loader { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool sslForHttp { get; public set; }
    [XmlAttributeAttribute]
public bool captureAttributes { get; public set; }
    [XmlIgnoreAttribute]
public bool captureAttributesSpecified { get; public set; }
    public List`1<configurationBrowserMonitoringPath> get_requestPathsExcluded();
    public void set_requestPathsExcluded(List`1<configurationBrowserMonitoringPath> value);
    public configurationBrowserMonitoringAttributes get_attributes();
    public void set_attributes(configurationBrowserMonitoringAttributes value);
    public bool get_autoInstrument();
    public void set_autoInstrument(bool value);
    public string get_loader();
    public void set_loader(string value);
    public bool get_sslForHttp();
    public void set_sslForHttp(bool value);
    public bool get_captureAttributes();
    public void set_captureAttributes(bool value);
    public bool get_captureAttributesSpecified();
    public void set_captureAttributesSpecified(bool value);
    public virtual configurationBrowserMonitoring Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationBrowserMonitoringAttributes : object {
    private List`1<string> includeField;
    private List`1<string> excludeField;
    private Nullable`1<bool> enabledField;
    [XmlElementAttribute("include")]
public List`1<string> include { get; public set; }
    [XmlElementAttribute("exclude")]
public List`1<string> exclude { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public List`1<string> get_include();
    public void set_include(List`1<string> value);
    public List`1<string> get_exclude();
    public void set_exclude(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationBrowserMonitoringAttributes Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationBrowserMonitoringPath : object {
    private string regexField;
    [XmlAttributeAttribute]
public string regex { get; public set; }
    public string get_regex();
    public void set_regex(string value);
    public virtual configurationBrowserMonitoringPath Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationCodeLevelMetrics : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationCodeLevelMetrics Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationCrossApplicationTracer : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationCrossApplicationTracer Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationCustomEvents : object {
    private configurationCustomEventsAttributes attributesField;
    private bool enabledField;
    private int maximumSamplesStoredField;
    public configurationCustomEventsAttributes attributes { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("30000")]
public int maximumSamplesStored { get; public set; }
    public configurationCustomEventsAttributes get_attributes();
    public void set_attributes(configurationCustomEventsAttributes value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public int get_maximumSamplesStored();
    public void set_maximumSamplesStored(int value);
    public virtual configurationCustomEvents Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationCustomEventsAttributes : object {
    private List`1<string> includeField;
    private List`1<string> excludeField;
    private bool enabledField;
    [XmlElementAttribute("include")]
public List`1<string> include { get; public set; }
    [XmlElementAttribute("exclude")]
public List`1<string> exclude { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public List`1<string> get_include();
    public void set_include(List`1<string> value);
    public List`1<string> get_exclude();
    public void set_exclude(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationCustomEventsAttributes Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationCustomInstrumentationEditor : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationCustomInstrumentationEditor Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationCustomParameters : object {
    private Nullable`1<bool> enabledField;
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationCustomParameters Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationDatastoreTracer : object {
    private configurationDatastoreTracerInstanceReporting instanceReportingField;
    private configurationDatastoreTracerDatabaseNameReporting databaseNameReportingField;
    private configurationDatastoreTracerQueryParameters queryParametersField;
    public configurationDatastoreTracerInstanceReporting instanceReporting { get; public set; }
    public configurationDatastoreTracerDatabaseNameReporting databaseNameReporting { get; public set; }
    public configurationDatastoreTracerQueryParameters queryParameters { get; public set; }
    public configurationDatastoreTracerInstanceReporting get_instanceReporting();
    public void set_instanceReporting(configurationDatastoreTracerInstanceReporting value);
    public configurationDatastoreTracerDatabaseNameReporting get_databaseNameReporting();
    public void set_databaseNameReporting(configurationDatastoreTracerDatabaseNameReporting value);
    public configurationDatastoreTracerQueryParameters get_queryParameters();
    public void set_queryParameters(configurationDatastoreTracerQueryParameters value);
    public virtual configurationDatastoreTracer Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationDatastoreTracerDatabaseNameReporting : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationDatastoreTracerDatabaseNameReporting Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationDatastoreTracerInstanceReporting : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationDatastoreTracerInstanceReporting Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationDatastoreTracerQueryParameters : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationDatastoreTracerQueryParameters Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationDataTransmission : object {
    private bool putForDataSendField;
    private configurationDataTransmissionCompressedContentEncoding compressedContentEncodingField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool putForDataSend { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public configurationDataTransmissionCompressedContentEncoding compressedContentEncoding { get; public set; }
    public bool get_putForDataSend();
    public void set_putForDataSend(bool value);
    public configurationDataTransmissionCompressedContentEncoding get_compressedContentEncoding();
    public void set_compressedContentEncoding(configurationDataTransmissionCompressedContentEncoding value);
    public virtual configurationDataTransmission Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[XmlTypeAttribute]
public enum NewRelic.Agent.Core.Config.configurationDataTransmissionCompressedContentEncoding : Enum {
    public int value__;
    public static configurationDataTransmissionCompressedContentEncoding deflate;
    public static configurationDataTransmissionCompressedContentEncoding gzip;
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationDiagnostics : object {
    private bool captureAgentTimingField;
    private int captureAgentTimingFrequencyField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool captureAgentTiming { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("1")]
public int captureAgentTimingFrequency { get; public set; }
    public bool get_captureAgentTiming();
    public void set_captureAgentTiming(bool value);
    public int get_captureAgentTimingFrequency();
    public void set_captureAgentTimingFrequency(int value);
    public virtual configurationDiagnostics Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationDistributedTracing : object {
    private bool enabledField;
    private bool excludeNewrelicHeaderField;
    private bool enableSuccessMetricsField;
    private string account_idField;
    private string trusted_account_keyField;
    private string primary_application_idField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool excludeNewrelicHeader { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enableSuccessMetrics { get; public set; }
    [XmlAttributeAttribute]
public string account_id { get; public set; }
    [XmlAttributeAttribute]
public string trusted_account_key { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("Unknown")]
public string primary_application_id { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_excludeNewrelicHeader();
    public void set_excludeNewrelicHeader(bool value);
    public bool get_enableSuccessMetrics();
    public void set_enableSuccessMetrics(bool value);
    public string get_account_id();
    public void set_account_id(string value);
    public string get_trusted_account_key();
    public void set_trusted_account_key(string value);
    public string get_primary_application_id();
    public void set_primary_application_id(string value);
    public virtual configurationDistributedTracing Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationErrorCollector : object {
    private configurationErrorCollectorIgnoreErrors ignoreErrorsField;
    private ErrorClassCollection ignoreClassesField;
    private List`1<ErrorMessagesCollectionErrorClass> ignoreMessagesField;
    private configurationErrorCollectorIgnoreStatusCodes ignoreStatusCodesField;
    private ErrorClassCollection expectedClassesField;
    private List`1<ErrorMessagesCollectionErrorClass> expectedMessagesField;
    private string expectedStatusCodesField;
    private configurationErrorCollectorAttributes attributesField;
    private bool enabledField;
    private Nullable`1<bool> captureAttributesField;
    private bool captureEventsField;
    private int maxEventSamplesStoredField;
    public configurationErrorCollectorIgnoreErrors ignoreErrors { get; public set; }
    public ErrorClassCollection ignoreClasses { get; public set; }
    [XmlArrayItemAttribute("errorClass")]
public List`1<ErrorMessagesCollectionErrorClass> ignoreMessages { get; public set; }
    public configurationErrorCollectorIgnoreStatusCodes ignoreStatusCodes { get; public set; }
    public ErrorClassCollection expectedClasses { get; public set; }
    [XmlArrayItemAttribute("errorClass")]
public List`1<ErrorMessagesCollectionErrorClass> expectedMessages { get; public set; }
    public string expectedStatusCodes { get; public set; }
    public configurationErrorCollectorAttributes attributes { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
public bool captureAttributes { get; public set; }
    [XmlIgnoreAttribute]
public bool captureAttributesSpecified { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool captureEvents { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("100")]
public int maxEventSamplesStored { get; public set; }
    public configurationErrorCollectorIgnoreErrors get_ignoreErrors();
    public void set_ignoreErrors(configurationErrorCollectorIgnoreErrors value);
    public ErrorClassCollection get_ignoreClasses();
    public void set_ignoreClasses(ErrorClassCollection value);
    public List`1<ErrorMessagesCollectionErrorClass> get_ignoreMessages();
    public void set_ignoreMessages(List`1<ErrorMessagesCollectionErrorClass> value);
    public configurationErrorCollectorIgnoreStatusCodes get_ignoreStatusCodes();
    public void set_ignoreStatusCodes(configurationErrorCollectorIgnoreStatusCodes value);
    public ErrorClassCollection get_expectedClasses();
    public void set_expectedClasses(ErrorClassCollection value);
    public List`1<ErrorMessagesCollectionErrorClass> get_expectedMessages();
    public void set_expectedMessages(List`1<ErrorMessagesCollectionErrorClass> value);
    public string get_expectedStatusCodes();
    public void set_expectedStatusCodes(string value);
    public configurationErrorCollectorAttributes get_attributes();
    public void set_attributes(configurationErrorCollectorAttributes value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_captureAttributes();
    public void set_captureAttributes(bool value);
    public bool get_captureAttributesSpecified();
    public void set_captureAttributesSpecified(bool value);
    public bool get_captureEvents();
    public void set_captureEvents(bool value);
    public int get_maxEventSamplesStored();
    public void set_maxEventSamplesStored(int value);
    public virtual configurationErrorCollector Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationErrorCollectorAttributes : object {
    private List`1<string> includeField;
    private List`1<string> excludeField;
    private Nullable`1<bool> enabledField;
    [XmlElementAttribute("include")]
public List`1<string> include { get; public set; }
    [XmlElementAttribute("exclude")]
public List`1<string> exclude { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public List`1<string> get_include();
    public void set_include(List`1<string> value);
    public List`1<string> get_exclude();
    public void set_exclude(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationErrorCollectorAttributes Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationErrorCollectorIgnoreErrors : object {
    private List`1<string> exceptionField;
    [XmlElementAttribute("exception")]
public List`1<string> exception { get; public set; }
    public List`1<string> get_exception();
    public void set_exception(List`1<string> value);
    public virtual configurationErrorCollectorIgnoreErrors Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationErrorCollectorIgnoreStatusCodes : object {
    private List`1<float> codeField;
    [XmlElementAttribute("code")]
public List`1<float> code { get; public set; }
    public List`1<float> get_code();
    public void set_code(List`1<float> value);
    public virtual configurationErrorCollectorIgnoreStatusCodes Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationHighSecurity : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationHighSecurity Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationInfiniteTracing : object {
    private configurationInfiniteTracingTrace_observer trace_observerField;
    private configurationInfiniteTracingSpan_events span_eventsField;
    private bool compressionField;
    public configurationInfiniteTracingTrace_observer trace_observer { get; public set; }
    public configurationInfiniteTracingSpan_events span_events { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool compression { get; public set; }
    public configurationInfiniteTracingTrace_observer get_trace_observer();
    public void set_trace_observer(configurationInfiniteTracingTrace_observer value);
    public configurationInfiniteTracingSpan_events get_span_events();
    public void set_span_events(configurationInfiniteTracingSpan_events value);
    public bool get_compression();
    public void set_compression(bool value);
    public virtual configurationInfiniteTracing Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationInfiniteTracingSpan_events : object {
    private int queue_sizeField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("100000")]
public int queue_size { get; public set; }
    public int get_queue_size();
    public void set_queue_size(int value);
    public virtual configurationInfiniteTracingSpan_events Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationInfiniteTracingTrace_observer : object {
    private string hostField;
    private string portField;
    [XmlAttributeAttribute]
public string host { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("443")]
public string port { get; public set; }
    public string get_host();
    public void set_host(string value);
    public string get_port();
    public void set_port(string value);
    public virtual configurationInfiniteTracingTrace_observer Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationInstrumentation : object {
    private List`1<configurationInstrumentationIgnore> rulesField;
    private List`1<configurationInstrumentationApplication> applicationsField;
    private bool logField;
    [XmlArrayItemAttribute("ignore")]
public List`1<configurationInstrumentationIgnore> rules { get; public set; }
    [XmlArrayItemAttribute("application")]
public List`1<configurationInstrumentationApplication> applications { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool log { get; public set; }
    public List`1<configurationInstrumentationIgnore> get_rules();
    public void set_rules(List`1<configurationInstrumentationIgnore> value);
    public List`1<configurationInstrumentationApplication> get_applications();
    public void set_applications(List`1<configurationInstrumentationApplication> value);
    public bool get_log();
    public void set_log(bool value);
    public virtual configurationInstrumentation Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationInstrumentationApplication : object {
    private string nameField;
    [XmlAttributeAttribute]
public string name { get; public set; }
    public string get_name();
    public void set_name(string value);
    public virtual configurationInstrumentationApplication Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationInstrumentationIgnore : object {
    private string assemblyNameField;
    private string classNameField;
    [XmlAttributeAttribute]
public string assemblyName { get; public set; }
    [XmlAttributeAttribute]
public string className { get; public set; }
    public string get_assemblyName();
    public void set_assemblyName(string value);
    public string get_className();
    public void set_className(string value);
    public virtual configurationInstrumentationIgnore Clone();
}
public static class NewRelic.Agent.Core.Config.ConfigurationLoader : object {
    private static string NewRelicConfigFileName;
    private static ProcessStatic _processStatic;
    public static Func`1<string> GetAppDomainAppId;
    public static Func`1<string> GetAppDomainAppVirtualPath;
    public static Func`1<string> GetAppDomainAppPath;
    public static Func`2<string, Configuration> OpenWebConfiguration;
    public static Func`2<string, bool> FileExists;
    public static Func`2<string, string> PathGetDirectoryName;
    public static Func`2<string, string> GetEnvironmentVar;
    public static Func`1<string> GetNewRelicHome;
    [CompilerGeneratedAttribute]
private static IBootstrapConfiguration <BootstrapConfig>k__BackingField;
    public static IBootstrapConfiguration BootstrapConfig { get; private set; }
    private static ConfigurationLoader();
    private static string InternalGetAppDomainAppId();
    private static string InternalGetAppDomainAppVirtualPath();
    private static string InternalGetAppDomainAppPath();
    private static string InternalGetNewRelicHome();
    [CompilerGeneratedAttribute]
public static IBootstrapConfiguration get_BootstrapConfig();
    [CompilerGeneratedAttribute]
private static void set_BootstrapConfig(IBootstrapConfiguration value);
    public static ValueWithProvenance`1<string> GetWebConfigAppSetting(string key);
    public static ValueWithProvenance`1<string> GetConfigSetting(string key);
    public static string GetAgentConfigFileName();
    private static string TryGetAgentConfigFileFromAppConfig();
    private static string TryGetAgentConfigFileFromAppRoot();
    private static string TryGetAgentConfigFileFromExecutionPath();
    private static string TryGetAgentConfigFileFromNewRelicHome();
    private static string TryGetAgentConfigFileFromCurrentDirectory();
    public static string GetConfigurationFilePath(string homeDirectory);
    public static configuration Initialize(bool publishDeserializedEvent);
    private static Exception HandleConfigError(string message, Exception originalException);
    public static configuration Initialize(string fileName, bool publishDeserializedEvent);
    private static void ValidationEventHandler(object sender, ValidationEventArgs e);
    public static configuration InitializeFromXml(string configXml, Func`1<string> configSchemaSource, string provenance, bool publishDeserializedEvent);
    public static void PublishDeserializedEvent(configuration config);
    public static void UseBootstrapConfigurationForTesting(IBootstrapConfiguration bootstrapConfiguration);
    private static void ValidateConfigXmlWithSchema(string configXml, string schemaXml);
    private static string GetConfigSchemaContents();
    private static void RemoveApdexAttribute(XmlDocument document);
    private static void RemoveSslAttribute(XmlDocument document);
}
public class NewRelic.Agent.Core.Config.ConfigurationLoaderException : Exception {
    public ConfigurationLoaderException(string message);
    public ConfigurationLoaderException(string message, Exception original);
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationLog : object {
    private string levelField;
    private bool enabledField;
    private string directoryField;
    private string fileNameField;
    private bool consoleField;
    private bool auditLogField;
    private configurationLogLogRollingStrategy logRollingStrategyField;
    private int maxLogFileSizeMBField;
    private int maxLogFilesField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("info")]
public string level { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
public string directory { get; public set; }
    [XmlAttributeAttribute]
public string fileName { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool console { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool auditLog { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public configurationLogLogRollingStrategy logRollingStrategy { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("50")]
public int maxLogFileSizeMB { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("4")]
public int maxLogFiles { get; public set; }
    public string get_level();
    public void set_level(string value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public string get_directory();
    public void set_directory(string value);
    public string get_fileName();
    public void set_fileName(string value);
    public bool get_console();
    public void set_console(bool value);
    public bool get_auditLog();
    public void set_auditLog(bool value);
    public configurationLogLogRollingStrategy get_logRollingStrategy();
    public void set_logRollingStrategy(configurationLogLogRollingStrategy value);
    public int get_maxLogFileSizeMB();
    public void set_maxLogFileSizeMB(int value);
    public int get_maxLogFiles();
    public void set_maxLogFiles(int value);
    public virtual configurationLog Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[XmlTypeAttribute]
public enum NewRelic.Agent.Core.Config.configurationLogLogRollingStrategy : Enum {
    public int value__;
    public static configurationLogLogRollingStrategy size;
    public static configurationLogLogRollingStrategy day;
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationParameterGroups : object {
    private configurationParameterGroupsIdentityParameters identityParametersField;
    private configurationParameterGroupsResponseHeaderParameters responseHeaderParametersField;
    private configurationParameterGroupsCustomParameters customParametersField;
    private configurationParameterGroupsRequestHeaderParameters requestHeaderParametersField;
    public configurationParameterGroupsIdentityParameters identityParameters { get; public set; }
    public configurationParameterGroupsResponseHeaderParameters responseHeaderParameters { get; public set; }
    public configurationParameterGroupsCustomParameters customParameters { get; public set; }
    public configurationParameterGroupsRequestHeaderParameters requestHeaderParameters { get; public set; }
    public configurationParameterGroupsIdentityParameters get_identityParameters();
    public void set_identityParameters(configurationParameterGroupsIdentityParameters value);
    public configurationParameterGroupsResponseHeaderParameters get_responseHeaderParameters();
    public void set_responseHeaderParameters(configurationParameterGroupsResponseHeaderParameters value);
    public configurationParameterGroupsCustomParameters get_customParameters();
    public void set_customParameters(configurationParameterGroupsCustomParameters value);
    public configurationParameterGroupsRequestHeaderParameters get_requestHeaderParameters();
    public void set_requestHeaderParameters(configurationParameterGroupsRequestHeaderParameters value);
    public virtual configurationParameterGroups Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationParameterGroupsCustomParameters : object {
    private List`1<string> ignoreField;
    private Nullable`1<bool> enabledField;
    [XmlElementAttribute("ignore")]
public List`1<string> ignore { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public List`1<string> get_ignore();
    public void set_ignore(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationParameterGroupsCustomParameters Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationParameterGroupsIdentityParameters : object {
    private List`1<string> ignoreField;
    private Nullable`1<bool> enabledField;
    [XmlElementAttribute("ignore")]
public List`1<string> ignore { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public List`1<string> get_ignore();
    public void set_ignore(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationParameterGroupsIdentityParameters Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationParameterGroupsRequestHeaderParameters : object {
    private List`1<string> ignoreField;
    private Nullable`1<bool> enabledField;
    [XmlElementAttribute("ignore")]
public List`1<string> ignore { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public List`1<string> get_ignore();
    public void set_ignore(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationParameterGroupsRequestHeaderParameters Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationParameterGroupsResponseHeaderParameters : object {
    private List`1<string> ignoreField;
    private Nullable`1<bool> enabledField;
    [XmlElementAttribute("ignore")]
public List`1<string> ignore { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public List`1<string> get_ignore();
    public void set_ignore(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationParameterGroupsResponseHeaderParameters Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationProcessHost : object {
    private string displayNameField;
    [XmlAttributeAttribute]
public string displayName { get; public set; }
    public string get_displayName();
    public void set_displayName(string value);
    public virtual configurationProcessHost Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationRequestParameters : object {
    private List`1<string> ignoreField;
    private Nullable`1<bool> enabledField;
    [XmlElementAttribute("ignore")]
public List`1<string> ignore { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public List`1<string> get_ignore();
    public void set_ignore(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationRequestParameters Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationService : object {
    private string obscuringKeyField;
    private configurationServiceProxy proxyField;
    private bool sendEnvironmentInfoField;
    private string licenseKeyField;
    private string hostField;
    private Nullable`1<int> portField;
    private bool syncStartupField;
    private bool autoStartField;
    private bool sendDataOnExitField;
    private float sendDataOnExitThresholdField;
    private Nullable`1<int> requestTimeoutField;
    private bool completeTransactionsOnThreadField;
    private bool forceNewTransactionOnNewThreadField;
    private bool disableFileSystemWatcherField;
    public string obscuringKey { get; public set; }
    public configurationServiceProxy proxy { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool sendEnvironmentInfo { get; public set; }
    [XmlAttributeAttribute]
public string licenseKey { get; public set; }
    [XmlAttributeAttribute]
public string host { get; public set; }
    [XmlAttributeAttribute]
public int port { get; public set; }
    [XmlIgnoreAttribute]
public bool portSpecified { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool syncStartup { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool autoStart { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool sendDataOnExit { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("System.Single", "60000")]
public float sendDataOnExitThreshold { get; public set; }
    [XmlAttributeAttribute]
public int requestTimeout { get; public set; }
    [XmlIgnoreAttribute]
public bool requestTimeoutSpecified { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool completeTransactionsOnThread { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool forceNewTransactionOnNewThread { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool disableFileSystemWatcher { get; public set; }
    public string get_obscuringKey();
    public void set_obscuringKey(string value);
    public configurationServiceProxy get_proxy();
    public void set_proxy(configurationServiceProxy value);
    public bool get_sendEnvironmentInfo();
    public void set_sendEnvironmentInfo(bool value);
    public string get_licenseKey();
    public void set_licenseKey(string value);
    public string get_host();
    public void set_host(string value);
    public int get_port();
    public void set_port(int value);
    public bool get_portSpecified();
    public void set_portSpecified(bool value);
    public bool get_syncStartup();
    public void set_syncStartup(bool value);
    public bool get_autoStart();
    public void set_autoStart(bool value);
    public bool get_sendDataOnExit();
    public void set_sendDataOnExit(bool value);
    public float get_sendDataOnExitThreshold();
    public void set_sendDataOnExitThreshold(float value);
    public int get_requestTimeout();
    public void set_requestTimeout(int value);
    public bool get_requestTimeoutSpecified();
    public void set_requestTimeoutSpecified(bool value);
    public bool get_completeTransactionsOnThread();
    public void set_completeTransactionsOnThread(bool value);
    public bool get_forceNewTransactionOnNewThread();
    public void set_forceNewTransactionOnNewThread(bool value);
    public bool get_disableFileSystemWatcher();
    public void set_disableFileSystemWatcher(bool value);
    public virtual configurationService Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationServiceProxy : object {
    private string hostField;
    private string uriPathField;
    private int portField;
    private string userField;
    private string passwordField;
    private string passwordObfuscatedField;
    private string domainField;
    [XmlAttributeAttribute]
public string host { get; public set; }
    [XmlAttributeAttribute]
public string uriPath { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("8080")]
public int port { get; public set; }
    [XmlAttributeAttribute]
public string user { get; public set; }
    [XmlAttributeAttribute]
public string password { get; public set; }
    [XmlAttributeAttribute]
public string passwordObfuscated { get; public set; }
    [XmlAttributeAttribute]
public string domain { get; public set; }
    public string get_host();
    public void set_host(string value);
    public string get_uriPath();
    public void set_uriPath(string value);
    public int get_port();
    public void set_port(int value);
    public string get_user();
    public void set_user(string value);
    public string get_password();
    public void set_password(string value);
    public string get_passwordObfuscated();
    public void set_passwordObfuscated(string value);
    public string get_domain();
    public void set_domain(string value);
    public virtual configurationServiceProxy Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationSlowSql : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationSlowSql Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationSpanEvents : object {
    private configurationSpanEventsAttributes attributesField;
    private bool enabledField;
    private int maximumSamplesStoredField;
    public configurationSpanEventsAttributes attributes { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("2000")]
public int maximumSamplesStored { get; public set; }
    public configurationSpanEventsAttributes get_attributes();
    public void set_attributes(configurationSpanEventsAttributes value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public int get_maximumSamplesStored();
    public void set_maximumSamplesStored(int value);
    public virtual configurationSpanEvents Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationSpanEventsAttributes : object {
    private List`1<string> includeField;
    private List`1<string> excludeField;
    private bool enabledField;
    [XmlElementAttribute("include")]
public List`1<string> include { get; public set; }
    [XmlElementAttribute("exclude")]
public List`1<string> exclude { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public List`1<string> get_include();
    public void set_include(List`1<string> value);
    public List`1<string> get_exclude();
    public void set_exclude(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationSpanEventsAttributes Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationStripExceptionMessages : object {
    private bool enabledField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool enabled { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationStripExceptionMessages Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[XmlTypeAttribute]
public enum NewRelic.Agent.Core.Config.configurationTimingPrecision : Enum {
    public int value__;
    public static configurationTimingPrecision high;
    public static configurationTimingPrecision low;
}
public class NewRelic.Agent.Core.Config.ConfigurationTracker : object {
    private Timer _timer;
    private DateTime _lastWriteTime;
    private INativeMethods _nativeMethods;
    public ConfigurationTracker(IConfigurationService configurationService, INativeMethods nativeMethods);
    public sealed virtual void Dispose();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationTransactionEvents : object {
    private configurationTransactionEventsTransactions transactionsField;
    private configurationTransactionEventsAttributes attributesField;
    private bool enabledField;
    private Nullable`1<UInt32> maximumSamplesPerMinuteField;
    private int maximumSamplesStoredField;
    public configurationTransactionEventsTransactions transactions { get; public set; }
    public configurationTransactionEventsAttributes attributes { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
public UInt32 maximumSamplesPerMinute { get; public set; }
    [XmlIgnoreAttribute]
public bool maximumSamplesPerMinuteSpecified { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("10000")]
public int maximumSamplesStored { get; public set; }
    public configurationTransactionEventsTransactions get_transactions();
    public void set_transactions(configurationTransactionEventsTransactions value);
    public configurationTransactionEventsAttributes get_attributes();
    public void set_attributes(configurationTransactionEventsAttributes value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public UInt32 get_maximumSamplesPerMinute();
    public void set_maximumSamplesPerMinute(UInt32 value);
    public bool get_maximumSamplesPerMinuteSpecified();
    public void set_maximumSamplesPerMinuteSpecified(bool value);
    public int get_maximumSamplesStored();
    public void set_maximumSamplesStored(int value);
    public virtual configurationTransactionEvents Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationTransactionEventsAttributes : object {
    private List`1<string> includeField;
    private List`1<string> excludeField;
    private bool enabledField;
    [XmlElementAttribute("include")]
public List`1<string> include { get; public set; }
    [XmlElementAttribute("exclude")]
public List`1<string> exclude { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public List`1<string> get_include();
    public void set_include(List`1<string> value);
    public List`1<string> get_exclude();
    public void set_exclude(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual configurationTransactionEventsAttributes Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationTransactionEventsTransactions : object {
    private Nullable`1<bool> enabledField;
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationTransactionEventsTransactions Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationTransactionTracer : object {
    private configurationTransactionTracerAttributes attributesField;
    private string transactionThresholdField;
    private configurationTransactionTracerRecordSql recordSqlField;
    private int stackTraceThresholdField;
    private bool explainEnabledField;
    private float explainThresholdField;
    private bool enabledField;
    private int maxSegmentsField;
    private int maxStackTraceField;
    private int maxExplainPlansField;
    private Nullable`1<bool> captureAttributesField;
    public configurationTransactionTracerAttributes attributes { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("apdex_f")]
public string transactionThreshold { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public configurationTransactionTracerRecordSql recordSql { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("500")]
public int stackTraceThreshold { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool explainEnabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("System.Single", "500")]
public float explainThreshold { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("3000")]
public int maxSegments { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("0")]
public int maxStackTrace { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("20")]
public int maxExplainPlans { get; public set; }
    [XmlAttributeAttribute]
public bool captureAttributes { get; public set; }
    [XmlIgnoreAttribute]
public bool captureAttributesSpecified { get; public set; }
    public configurationTransactionTracerAttributes get_attributes();
    public void set_attributes(configurationTransactionTracerAttributes value);
    public string get_transactionThreshold();
    public void set_transactionThreshold(string value);
    public configurationTransactionTracerRecordSql get_recordSql();
    public void set_recordSql(configurationTransactionTracerRecordSql value);
    public int get_stackTraceThreshold();
    public void set_stackTraceThreshold(int value);
    public bool get_explainEnabled();
    public void set_explainEnabled(bool value);
    public float get_explainThreshold();
    public void set_explainThreshold(float value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public int get_maxSegments();
    public void set_maxSegments(int value);
    public int get_maxStackTrace();
    public void set_maxStackTrace(int value);
    public int get_maxExplainPlans();
    public void set_maxExplainPlans(int value);
    public bool get_captureAttributes();
    public void set_captureAttributes(bool value);
    public bool get_captureAttributesSpecified();
    public void set_captureAttributesSpecified(bool value);
    public virtual configurationTransactionTracer Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationTransactionTracerAttributes : object {
    private List`1<string> includeField;
    private List`1<string> excludeField;
    private Nullable`1<bool> enabledField;
    [XmlElementAttribute("include")]
public List`1<string> include { get; public set; }
    [XmlElementAttribute("exclude")]
public List`1<string> exclude { get; public set; }
    [XmlAttributeAttribute]
public bool enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool enabledSpecified { get; public set; }
    public List`1<string> get_include();
    public void set_include(List`1<string> value);
    public List`1<string> get_exclude();
    public void set_exclude(List`1<string> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public bool get_enabledSpecified();
    public void set_enabledSpecified(bool value);
    public virtual configurationTransactionTracerAttributes Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[XmlTypeAttribute]
public enum NewRelic.Agent.Core.Config.configurationTransactionTracerRecordSql : Enum {
    public int value__;
    public static configurationTransactionTracerRecordSql obfuscated;
    public static configurationTransactionTracerRecordSql raw;
    public static configurationTransactionTracerRecordSql off;
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.configurationUtilization : object {
    private bool detectAwsField;
    private bool detectAzureField;
    private bool detectGcpField;
    private bool detectPcfField;
    private bool detectDockerField;
    private bool detectKubernetesField;
    private bool detectAzureFunctionField;
    private Nullable`1<int> logicalProcessorsField;
    private Nullable`1<int> totalRamMibField;
    private string billingHostField;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool detectAws { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool detectAzure { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool detectGcp { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool detectPcf { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool detectDocker { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool detectKubernetes { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool detectAzureFunction { get; public set; }
    [XmlAttributeAttribute]
public int logicalProcessors { get; public set; }
    [XmlIgnoreAttribute]
public bool logicalProcessorsSpecified { get; public set; }
    [XmlAttributeAttribute]
public int totalRamMib { get; public set; }
    [XmlIgnoreAttribute]
public bool totalRamMibSpecified { get; public set; }
    [XmlAttributeAttribute]
public string billingHost { get; public set; }
    public bool get_detectAws();
    public void set_detectAws(bool value);
    public bool get_detectAzure();
    public void set_detectAzure(bool value);
    public bool get_detectGcp();
    public void set_detectGcp(bool value);
    public bool get_detectPcf();
    public void set_detectPcf(bool value);
    public bool get_detectDocker();
    public void set_detectDocker(bool value);
    public bool get_detectKubernetes();
    public void set_detectKubernetes(bool value);
    public bool get_detectAzureFunction();
    public void set_detectAzureFunction(bool value);
    public int get_logicalProcessors();
    public void set_logicalProcessors(int value);
    public bool get_logicalProcessorsSpecified();
    public void set_logicalProcessorsSpecified(bool value);
    public int get_totalRamMib();
    public void set_totalRamMib(int value);
    public bool get_totalRamMibSpecified();
    public void set_totalRamMibSpecified(bool value);
    public string get_billingHost();
    public void set_billingHost(string value);
    public virtual configurationUtilization Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.ErrorClassCollection : object {
    private List`1<string> errorClassField;
    [XmlElementAttribute("errorClass")]
public List`1<string> errorClass { get; public set; }
    public List`1<string> get_errorClass();
    public void set_errorClass(List`1<string> value);
    public virtual ErrorClassCollection Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute]
public class NewRelic.Agent.Core.Config.ErrorMessagesCollection : object {
    private List`1<ErrorMessagesCollectionErrorClass> errorClassField;
    [XmlElementAttribute("errorClass")]
public List`1<ErrorMessagesCollectionErrorClass> errorClass { get; public set; }
    public List`1<ErrorMessagesCollectionErrorClass> get_errorClass();
    public void set_errorClass(List`1<ErrorMessagesCollectionErrorClass> value);
    public virtual ErrorMessagesCollection Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Config.ErrorMessagesCollectionErrorClass : object {
    private List`1<string> messageField;
    private string nameField;
    [XmlElementAttribute("message")]
public List`1<string> message { get; public set; }
    [XmlAttributeAttribute]
public string name { get; public set; }
    public List`1<string> get_message();
    public void set_message(List`1<string> value);
    public string get_name();
    public void set_name(string value);
    public virtual ErrorMessagesCollectionErrorClass Clone();
}
public interface NewRelic.Agent.Core.Config.IBootstrapConfiguration {
    public bool ServerlessModeEnabled { get; }
    public int DebugStartupDelaySeconds { get; }
    public string ConfigurationFileName { get; }
    public bool AgentEnabled { get; }
    public string AgentEnabledAt { get; }
    public ILogConfig LogConfig { get; }
    public string ServerlessFunctionName { get; }
    public string ServerlessFunctionVersion { get; }
    public bool AzureFunctionModeDetected { get; }
    public abstract virtual bool get_ServerlessModeEnabled();
    public abstract virtual int get_DebugStartupDelaySeconds();
    public abstract virtual string get_ConfigurationFileName();
    public abstract virtual bool get_AgentEnabled();
    public abstract virtual string get_AgentEnabledAt();
    public abstract virtual ILogConfig get_LogConfig();
    public abstract virtual string get_ServerlessFunctionName();
    public abstract virtual string get_ServerlessFunctionVersion();
    public abstract virtual bool get_AzureFunctionModeDetected();
}
public interface NewRelic.Agent.Core.Config.ILogConfig {
    public bool Enabled { get; }
    public string LogLevel { get; }
    public bool Console { get; }
    public bool IsAuditLogEnabled { get; }
    public int MaxLogFileSizeMB { get; }
    public int MaxLogFiles { get; }
    public LogRollingStrategy LogRollingStrategy { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual string get_LogLevel();
    public abstract virtual string GetFullLogFileName();
    public abstract virtual bool get_Console();
    public abstract virtual bool get_IsAuditLogEnabled();
    public abstract virtual int get_MaxLogFileSizeMB();
    public abstract virtual int get_MaxLogFiles();
    public abstract virtual LogRollingStrategy get_LogRollingStrategy();
}
public enum NewRelic.Agent.Core.Config.LogRollingStrategy : Enum {
    public int value__;
    public static LogRollingStrategy Size;
    public static LogRollingStrategy Day;
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Config.LogRollingStrategyExtensions : object {
    [ExtensionAttribute]
public static LogRollingStrategy ToLogRollingStrategy(configurationLogLogRollingStrategy value);
}
public class NewRelic.Agent.Core.Config.ValueWithProvenance`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Provenance>k__BackingField;
    public T Value { get; private set; }
    public string Provenance { get; private set; }
    public ValueWithProvenance`1(T Value, string Provenance);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    [CompilerGeneratedAttribute]
public string get_Provenance();
    [CompilerGeneratedAttribute]
private void set_Provenance(string value);
}
public class NewRelic.Agent.Core.Configuration.BoolConfigurationItem : object {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public bool Value { get; }
    public string Source { get; }
    public BoolConfigurationItem(bool value, string source);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
public string get_Source();
}
public class NewRelic.Agent.Core.Configuration.ConfigurationManagerStatic : object {
    private bool localConfigChecksDisabled;
    public string AppSettingsFilePath { get; }
    public sealed virtual string get_AppSettingsFilePath();
    public sealed virtual string GetAppSetting(string key);
}
public class NewRelic.Agent.Core.Configuration.ConfigurationManagerStaticMock : object {
    private Func`2<string, string> _getAppSetting;
    public string AppSettingsFilePath { get; }
    public ConfigurationManagerStaticMock(Func`2<string, string> getAppSetting);
    public sealed virtual string get_AppSettingsFilePath();
    public sealed virtual string GetAppSetting(string variable);
}
public class NewRelic.Agent.Core.Configuration.ConfigurationService : object {
    private IEnvironment _environment;
    private configuration _localConfiguration;
    private ServerConfiguration _serverConfiguration;
    private SecurityPoliciesConfiguration _securityPoliciesConfiguration;
    private RunTimeConfiguration _runTimeConfiguration;
    private IBootstrapConfiguration _bootstrapConfiguration;
    private Subscriptions _subscriptions;
    private IProcessStatic _processStatic;
    private IHttpRuntimeStatic _httpRuntimeStatic;
    private IConfigurationManagerStatic _configurationManagerStatic;
    private IDnsStatic _dnsStatic;
    public Action`1<string> ChangeLogLevelAction;
    [CompilerGeneratedAttribute]
private IConfiguration <Configuration>k__BackingField;
    public IConfiguration Configuration { get; private set; }
    public ConfigurationService(IEnvironment environment, IProcessStatic processStatic, IHttpRuntimeStatic httpRuntimeStatic, IConfigurationManagerStatic configurationManagerStatic, IDnsStatic dnsStatic);
    [CompilerGeneratedAttribute]
public sealed virtual IConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(IConfiguration value);
    private void OnSecurityPoliciesUpdated(SecurityPoliciesConfigurationUpdatedEvent securityPoliciesConfigurationUpdatedEvent);
    private void OnConfigurationDeserialized(ConfigurationDeserializedEvent configurationDeserializedEvent);
    private void UpdateLogLevel(string previousLogLevel);
    private void OnServerConfigurationUpdated(ServerConfigurationUpdatedEvent serverConfigurationUpdatedEvent);
    private void OnAppNameUpdate(AppNameUpdateEvent appNameUpdateEvent);
    private void OnErrorGroupCallbackUpdate(ErrorGroupCallbackUpdateEvent errorGroupCallbackUpdateEvent);
    private void OnLlmTokenCountingCallbackUpdate(LlmTokenCountingCallbackUpdateEvent llmTokenCountingCallbackUpdateEvent);
    private void UpdateAndPublishConfiguration(ConfigurationUpdateSource configurationUpdateSource);
    private void OnGetCurrentConfiguration(GetCurrentConfigurationRequest eventData, ResponseCallback<GetCurrentConfigurationRequest, IConfiguration> callback);
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Configuration.ConfigurationSubscriber : object {
    [CompilerGeneratedAttribute]
private IConfiguration <Configuration>k__BackingField;
    private EventSubscription`1<ConfigurationUpdatedEvent> _configurationSubscription;
    public IConfiguration Configuration { get; private set; }
    [CompilerGeneratedAttribute]
public IConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(IConfiguration value);
    private void OnConfigurationUpdated(ConfigurationUpdatedEvent eventData);
    public sealed virtual void Dispose();
}
public static class NewRelic.Agent.Core.Configuration.Constants : object {
    public static string AppSettingsLicenseKey;
    public static string AppSettingsAgentEnabled;
    public static string AppSettingsAppName;
    public static string AppSettingsLabels;
    public static string AppSettingsConfigFile;
}
public class NewRelic.Agent.Core.Configuration.DefaultConfiguration : object {
    private static int DefaultSslPort;
    private static int DefaultSqlStatementCacheCapacity;
    public static string RawStringValue;
    public static string ObfuscatedStringValue;
    public static string OffStringValue;
    private static char HyphenChar;
    private static string HighSecurityConfigSource;
    private static string SecurityPolicyConfigSource;
    private static string LocalConfigSource;
    private static string ServerConfigSource;
    private static int MaxExptectedErrorConfigEntries;
    private static int MaxIgnoreErrorConfigEntries;
    private static long _currentConfigurationVersion;
    private IEnvironment _environment;
    private IProcessStatic _processStatic;
    private IHttpRuntimeStatic _httpRuntimeStatic;
    private IConfigurationManagerStatic _configurationManagerStatic;
    private IDnsStatic _dnsStatic;
    public static DefaultConfiguration Instance;
    private configuration _localConfiguration;
    private ServerConfiguration _serverConfiguration;
    private RunTimeConfiguration _runTimeConfiguration;
    private SecurityPoliciesConfiguration _securityPoliciesConfiguration;
    private IBootstrapConfiguration _bootstrapConfiguration;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <_newRelicAppSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResourceBasedNamingForWCFEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EventListenerSamplersEnabled>k__BackingField;
    protected static Nullable`1<bool> _agentEnabledAppSettingParsed;
    protected static bool _appSettingAgentEnabled;
    private static object _lockObj;
    private string _agentLicenseKey;
    private IEnumerable`1<string> _applicationNames;
    private string _applicationNamesSource;
    private string _securityPoliciesToken;
    private string _processHostDisplayName;
    private Nullable`1<bool> _ignoreServerSideConfiguration;
    private BoolConfigurationItem _canUseAttributesIncludes;
    private IEnumerable`1<string> _captureAttributesIncludes;
    private IEnumerable`1<string> _captureAttributesExcludes;
    private IEnumerable`1<string> _captureAttributesDefaultExcludes;
    private HashSet`1<string> _transactionEventsAttributesInclude;
    private HashSet`1<string> _transactionEventsAttributesExclude;
    private IEnumerable`1<string> _captureTransactionTraceAttributesIncludes;
    private IEnumerable`1<string> _captureTransactionTraceAttributesExcludes;
    private IEnumerable`1<string> _captureErrorCollectorAttributesIncludes;
    private IEnumerable`1<string> _captureErrorCollectorAttributesExcludes;
    private IEnumerable`1<string> _captureBrowserMonitoringAttributesIncludes;
    private IEnumerable`1<string> _captureBrowserMonitoringAttributesExcludes;
    private BoolConfigurationItem _shouldCaptureCustomParameters;
    [CompilerGeneratedAttribute]
private long <ConfigurationVersion>k__BackingField;
    private Nullable`1<bool> _crossApplicationTracingEnabled;
    private Nullable`1<bool> _spanEventsEnabled;
    private Nullable`1<TimeSpan> _spanEventsHarvestCycleOverride;
    private HashSet`1<string> _spanEventsAttributesInclude;
    private HashSet`1<string> _spanEventsAttributesExclude;
    private Nullable`1<bool> _distributedTracingEnabled;
    private Nullable`1<int> _infiniteTracingTimeoutMsConnect;
    private Nullable`1<int> _infiniteTracingTimeoutMsSendData;
    private Nullable`1<int> _infiniteTracingExitTimeoutMs;
    private Nullable`1<int> _infiniteTracingCountWorkers;
    private bool _infiniteTracingObserverObtained;
    private string _infiniteTracingTraceObserverHost;
    private string _infiniteTracingTraceObserverPort;
    private string _infiniteTracingTraceObserverSsl;
    private Nullable`1<int> _infiniteTracingQueueSizeSpans;
    private Nullable`1<int> _infiniteTracingPartitionCountSpans;
    private Nullable`1<int> _infiniteTracingBatchSizeSpans;
    private bool _infiniteTracingObtainedSettingsForTest;
    private Nullable`1<float> _infiniteTracingObserverTestFlaky;
    private Nullable`1<int> _infiniteTracingObserverTestFlakyCode;
    private Nullable`1<int> _infiniteTracingObserverTestDelayMs;
    private Nullable`1<bool> _infiniteTracingCompression;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <IgnoreErrorsConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <IgnoreErrorClassesForAgentSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <IgnoreErrorMessagesForAgentSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <ExpectedErrorsConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MatchRule> <ExpectedStatusCodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExpectedErrorClassesForAgentSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <ExpectedErrorMessagesForAgentSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExpectedErrorStatusCodesForAgentSettings>k__BackingField;
    private Nullable`1<bool> _highSecurityModeEnabled;
    private BoolConfigurationItem _customInstrumentationEditorIsEnabled;
    private BoolConfigurationItem _shouldStripExceptionMessages;
    private string _labels;
    private bool _labelsChecked;
    private bool _obscuringKeyEvaluated;
    private string _obscuringKey;
    private bool _proxyPasswordEvaluated;
    private string _proxyPassword;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <HttpStatusCodesToIgnore>k__BackingField;
    private BoolConfigurationItem _customEventsAreEnabled;
    private HashSet`1<string> _customEventsAttributesInclude;
    private HashSet`1<string> _customEventsAttributesExclude;
    private RecordSqlConfigurationItem _recordSqlConfiguration;
    private IList`1<Regex> _requestPathExclusionList;
    private IEnumerable`1<RegexRule> _metricNameRegexRules;
    private IEnumerable`1<RegexRule> _transactionNameRegexRules;
    private IEnumerable`1<RegexRule> _rrlRegexRules;
    private IDictionary`2<string, IEnumerable`1<string>> _transactionNameWhitelistRules;
    private IDictionary`2<string, double> _webTransactionsApdex;
    private Lazy`1<string> _utilizationFullHostName;
    private Lazy`1<string> _utilizationHostName;
    private HashSet`1<string> _logLevelDenyList;
    private IEnumerable`1<IDictionary`2<string, string>> _ignoredInstrumentation;
    private Nullable`1<bool> _azureFunctionModeEnabled;
    private Nullable`1<bool> _diagnosticsCaptureAgentTiming;
    private Nullable`1<int> _diagnosticsCaptureAgentTimingFrequency;
    private Nullable`1<bool> _forceSynchronousTimingCalculationHttpClient;
    private Nullable`1<bool> _enableAspNetCore6PlusBrowserInjection;
    private Nullable`1<TimeSpan> _metricsHarvestCycleOverride;
    private Nullable`1<TimeSpan> _transactionTraceHarvestCycleOverride;
    private Nullable`1<TimeSpan> _errorTracesHarvestCycleOverride;
    private Nullable`1<TimeSpan> _getAgentCommandsCycleOverride;
    private Nullable`1<TimeSpan> _sqlTracesHarvestCycleOverride;
    private Nullable`1<TimeSpan> _updateLoadedModulesCycleOverride;
    private Nullable`1<TimeSpan> _stackExchangeRedisCleanupCycleOverride;
    private Nullable`1<int> _databaseStatementCacheCapacity;
    private Nullable`1<bool> _codeLevelMetricsEnabled;
    private Nullable`1<bool> _loggingEnabled;
    private string _loggingLevel;
    private static bool CaptureTransactionTraceAttributesDefault;
    private static bool CaptureErrorCollectorAttributesDefault;
    private static bool CaptureBrowserMonitoringAttributesDefault;
    private static bool CaptureCustomParametersAttributesDefault;
    private static bool TransactionEventsTransactionsEnabledDefault;
    private static int MaxPayloadSizeInBytes;
    private Dictionary`2<string, string> _newRelicAppSettings { get; }
    public bool UseResourceBasedNamingForWCFEnabled { get; }
    public bool EventListenerSamplersEnabled { get; public set; }
    public TimeSpan DefaultHarvestCycle { get; }
    public bool SecurityPoliciesTokenExists { get; }
    public object AgentRunId { get; }
    public bool AgentEnabled { get; }
    public string AgentEnabledAt { get; }
    public bool ServerlessModeEnabled { get; }
    public string ServerlessFunctionName { get; }
    public string ServerlessFunctionVersion { get; }
    public string AgentLicenseKey { get; }
    public IEnumerable`1<string> ApplicationNames { get; }
    public string ApplicationNamesSource { get; }
    public bool AutoStartAgent { get; }
    public int WrapperExceptionLimit { get; }
    public string BrowserMonitoringApplicationId { get; }
    public bool BrowserMonitoringAutoInstrument { get; }
    public string BrowserMonitoringBeaconAddress { get; }
    public string BrowserMonitoringErrorBeaconAddress { get; }
    public string BrowserMonitoringJavaScriptAgent { get; }
    public string BrowserMonitoringJavaScriptAgentFile { get; }
    public string BrowserMonitoringJavaScriptAgentLoaderType { get; }
    public string BrowserMonitoringKey { get; }
    public bool BrowserMonitoringUseSsl { get; }
    public string SecurityPoliciesToken { get; }
    public string ProcessHostDisplayName { get; }
    public bool IgnoreServerSideConfiguration { get; }
    public bool AllowAllRequestHeaders { get; }
    public bool CaptureAttributes { get; }
    public string CanUseAttributesIncludesSource { get; }
    public bool CanUseAttributesIncludes { get; }
    public IEnumerable`1<string> CaptureAttributesIncludes { get; }
    public IEnumerable`1<string> CaptureAttributesExcludes { get; }
    public IEnumerable`1<string> CaptureAttributesDefaultExcludes { get; }
    private bool IsAttributesAllowedByConfigurableSecurityPolicy { get; }
    public bool TransactionEventsAttributesEnabled { get; }
    public HashSet`1<string> TransactionEventsAttributesInclude { get; }
    public HashSet`1<string> TransactionEventsAttributesExclude { get; }
    public bool CaptureTransactionTraceAttributes { get; }
    public IEnumerable`1<string> CaptureTransactionTraceAttributesIncludes { get; }
    public IEnumerable`1<string> CaptureTransactionTraceAttributesExcludes { get; }
    public bool CaptureErrorCollectorAttributes { get; }
    public IEnumerable`1<string> CaptureErrorCollectorAttributesIncludes { get; }
    public IEnumerable`1<string> CaptureErrorCollectorAttributesExcludes { get; }
    public bool CaptureBrowserMonitoringAttributes { get; }
    public IEnumerable`1<string> CaptureBrowserMonitoringAttributesIncludes { get; }
    public IEnumerable`1<string> CaptureBrowserMonitoringAttributesExcludes { get; }
    public string CaptureCustomParametersSource { get; }
    public bool CaptureCustomParameters { get; }
    public string CollectorHost { get; }
    public int CollectorPort { get; }
    public bool CollectorSendDataOnExit { get; }
    public float CollectorSendDataOnExitThreshold { get; }
    public bool CollectorSendEnvironmentInfo { get; }
    public bool CollectorSyncStartup { get; }
    public UInt32 CollectorTimeout { get; }
    public int CollectorMaxPayloadSizeInBytes { get; }
    public bool CompleteTransactionsOnThread { get; }
    public long ConfigurationVersion { get; private set; }
    public string CrossApplicationTracingCrossProcessId { get; }
    public bool CrossApplicationTracingEnabled { get; }
    public bool SpanEventsEnabled { get; }
    public TimeSpan SpanEventsHarvestCycle { get; }
    public bool SpanEventsAttributesEnabled { get; }
    public HashSet`1<string> SpanEventsAttributesInclude { get; }
    public HashSet`1<string> SpanEventsAttributesExclude { get; }
    public bool DistributedTracingEnabled { get; }
    public string PrimaryApplicationId { get; }
    public string TrustedAccountKey { get; }
    public string AccountId { get; }
    public Nullable`1<int> SamplingTarget { get; }
    public int SpanEventsMaxSamplesStored { get; }
    public Nullable`1<int> SamplingTargetPeriodInSeconds { get; }
    public bool PayloadSuccessMetricsEnabled { get; }
    public bool ExcludeNewrelicHeader { get; }
    public int InfiniteTracingTraceTimeoutMsConnect { get; }
    public int InfiniteTracingTraceTimeoutMsSendData { get; }
    public int InfiniteTracingExitTimeoutMs { get; }
    public int InfiniteTracingTraceCountConsumers { get; }
    public string InfiniteTracingTraceObserverHost { get; }
    public string InfiniteTracingTraceObserverPort { get; }
    public string InfiniteTracingTraceObserverSsl { get; }
    public int InfiniteTracingQueueSizeSpans { get; }
    public int InfiniteTracingPartitionCountSpans { get; }
    public int InfiniteTracingBatchSizeSpans { get; }
    public Nullable`1<float> InfiniteTracingTraceObserverTestFlaky { get; }
    public Nullable`1<int> InfiniteTracingTraceObserverTestFlakyCode { get; }
    public Nullable`1<int> InfiniteTracingTraceObserverTestDelayMs { get; }
    public bool InfiniteTracingCompression { get; }
    public bool ErrorCollectorEnabled { get; }
    public bool ErrorCollectorCaptureEvents { get; }
    public int ErrorCollectorMaxEventSamplesStored { get; }
    public TimeSpan ErrorEventsHarvestCycle { get; }
    public UInt32 ErrorsMaximumPerPeriod { get; }
    public IDictionary`2<string, IEnumerable`1<string>> IgnoreErrorsConfiguration { get; private set; }
    public IEnumerable`1<string> IgnoreErrorClassesForAgentSettings { get; private set; }
    public IDictionary`2<string, IEnumerable`1<string>> IgnoreErrorMessagesForAgentSettings { get; private set; }
    public IDictionary`2<string, IEnumerable`1<string>> ExpectedErrorsConfiguration { get; private set; }
    public IEnumerable`1<MatchRule> ExpectedStatusCodes { get; private set; }
    public IEnumerable`1<string> ExpectedErrorClassesForAgentSettings { get; private set; }
    public IDictionary`2<string, IEnumerable`1<string>> ExpectedErrorMessagesForAgentSettings { get; private set; }
    public IEnumerable`1<string> ExpectedErrorStatusCodesForAgentSettings { get; private set; }
    public Func`2<IReadOnlyDictionary`2<string, object>, string> ErrorGroupCallback { get; }
    public Dictionary`2<string, string> RequestHeadersMap { get; }
    public string EncodingKey { get; }
    public string EntityGuid { get; }
    public bool HighSecurityModeEnabled { get; }
    public string CustomInstrumentationEditorEnabledSource { get; }
    public bool CustomInstrumentationEditorEnabled { get; }
    public string StripExceptionMessagesSource { get; }
    public bool StripExceptionMessages { get; }
    public bool InstrumentationLoggingEnabled { get; }
    public string Labels { get; }
    public string ProxyHost { get; }
    public string ProxyUriPath { get; }
    public int ProxyPort { get; }
    public string ProxyUsername { get; }
    public string ObscuringKey { get; }
    public string ProxyPassword { get; }
    public string ProxyDomain { get; }
    public bool PutForDataSend { get; }
    public string CompressedContentEncoding { get; }
    public bool InstanceReportingEnabled { get; }
    public bool DatabaseNameReportingEnabled { get; }
    public bool DatastoreTracerQueryParametersEnabled { get; }
    public bool SlowSqlEnabled { get; }
    public TimeSpan SqlExplainPlanThreshold { get; }
    public bool SqlExplainPlansEnabled { get; }
    public int SqlExplainPlansMax { get; }
    public UInt32 SqlStatementsPerTransaction { get; }
    public int SqlTracesPerPeriod { get; }
    public int StackTraceMaximumFrames { get; }
    public IEnumerable`1<string> HttpStatusCodesToIgnore { get; private set; }
    public IEnumerable`1<string> ThreadProfilingIgnoreMethods { get; }
    public string CustomEventsEnabledSource { get; }
    public bool CustomEventsEnabled { get; }
    public int CustomEventsMaximumSamplesStored { get; }
    public TimeSpan CustomEventsHarvestCycle { get; }
    public bool CustomEventsAttributesEnabled { get; }
    public HashSet`1<string> CustomEventsAttributesInclude { get; }
    public HashSet`1<string> CustomEventsAttributesExclude { get; }
    public bool DisableSamplers { get; }
    public bool ThreadProfilingEnabled { get; }
    public bool TransactionEventsEnabled { get; }
    public int TransactionEventsMaximumSamplesStored { get; }
    public TimeSpan TransactionEventsHarvestCycle { get; }
    public bool TransactionEventsTransactionsEnabled { get; }
    public TimeSpan TransactionTraceApdexF { get; }
    public TimeSpan TransactionTraceApdexT { get; }
    public TimeSpan TransactionTraceThreshold { get; }
    public bool TransactionTracerEnabled { get; }
    public int TransactionTracerMaxSegments { get; }
    public string TransactionTracerRecordSqlSource { get; }
    public string TransactionTracerRecordSql { get; }
    public int TransactionTracerMaxStackTraces { get; }
    public IEnumerable`1<Regex> RequestPathExclusionList { get; }
    public IEnumerable`1<long> TrustedAccountIds { get; }
    public bool ServerSideConfigurationEnabled { get; }
    public IEnumerable`1<RegexRule> MetricNameRegexRules { get; }
    public IEnumerable`1<RegexRule> TransactionNameRegexRules { get; }
    public IEnumerable`1<RegexRule> UrlRegexRules { get; }
    public IDictionary`2<string, IEnumerable`1<string>> TransactionNameWhitelistRules { get; }
    public IDictionary`2<string, double> WebTransactionsApdex { get; }
    public string NewRelicConfigFilePath { get; }
    public string AppSettingsConfigFilePath { get; }
    public bool UtilizationDetectAws { get; }
    public bool UtilizationDetectAzure { get; }
    public bool UtilizationDetectGcp { get; }
    public bool UtilizationDetectPcf { get; }
    public bool UtilizationDetectDocker { get; }
    public bool UtilizationDetectKubernetes { get; }
    public bool UtilizationDetectAzureFunction { get; }
    public Nullable`1<int> UtilizationLogicalProcessors { get; }
    public Nullable`1<int> UtilizationTotalRamMib { get; }
    public string UtilizationBillingHost { get; }
    public string UtilizationFullHostName { get; }
    public string UtilizationHostName { get; }
    public bool ApplicationLoggingEnabled { get; }
    public bool LogMetricsCollectorEnabled { get; }
    public bool LogEventCollectorEnabled { get; }
    public bool ContextDataEnabled { get; }
    public IEnumerable`1<string> ContextDataInclude { get; }
    public IEnumerable`1<string> ContextDataExclude { get; }
    public TimeSpan LogEventsHarvestCycle { get; }
    public int LogEventsMaxSamplesStored { get; }
    public bool LogDecoratorEnabled { get; }
    public HashSet`1<string> LogLevelDenyList { get; }
    public IEnumerable`1<IDictionary`2<string, string>> IgnoredInstrumentation { get; }
    public bool DisableFileSystemWatcher { get; }
    public bool AiMonitoringEnabled { get; }
    public bool AiMonitoringStreamingEnabled { get; }
    public bool AiMonitoringRecordContentEnabled { get; }
    public Func`3<string, string, int> LlmTokenCountingCallback { get; }
    public bool AzureFunctionModeDetected { get; }
    public bool AzureFunctionModeEnabled { get; }
    public string AzureFunctionResourceId { get; }
    public string AzureFunctionResourceGroupName { get; }
    public string AzureFunctionRegion { get; }
    public string AzureFunctionSubscriptionId { get; }
    public string AzureFunctionServiceName { get; }
    public bool AppDomainCachingDisabled { get; }
    public bool ForceNewTransactionOnNewThread { get; }
    public bool DiagnosticsCaptureAgentTiming { get; }
    public int DiagnosticsCaptureAgentTimingFrequency { get; }
    public bool ForceSynchronousTimingCalculationHttpClient { get; }
    public bool EnableAspNetCore6PlusBrowserInjection { get; }
    public TimeSpan MetricsHarvestCycle { get; }
    public TimeSpan TransactionTracesHarvestCycle { get; }
    public TimeSpan ErrorTracesHarvestCycle { get; }
    public TimeSpan GetAgentCommandsCycle { get; }
    public TimeSpan SqlTracesHarvestCycle { get; }
    public TimeSpan UpdateLoadedModulesCycle { get; }
    public TimeSpan StackExchangeRedisCleanupCycle { get; }
    public int DatabaseStatementCacheCapacity { get; }
    public bool CodeLevelMetricsEnabled { get; }
    public bool LoggingEnabled { get; }
    public string LoggingLevel { get; }
    protected DefaultConfiguration(IEnvironment environment, configuration localConfiguration, ServerConfiguration serverConfiguration, RunTimeConfiguration runTimeConfiguration, SecurityPoliciesConfiguration securityPoliciesConfiguration, IBootstrapConfiguration bootstrapConfiguration, IProcessStatic processStatic, IHttpRuntimeStatic httpRuntimeStatic, IConfigurationManagerStatic configurationManagerStatic, IDnsStatic dnsStatic);
    private static DefaultConfiguration();
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> get__newRelicAppSettings();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseResourceBasedNamingForWCFEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EventListenerSamplersEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EventListenerSamplersEnabled(bool value);
    public sealed virtual TimeSpan get_DefaultHarvestCycle();
    public sealed virtual IReadOnlyDictionary`2<string, string> GetAppSettings();
    private Dictionary`2<string, string> TransformAppSettings();
    private bool TryGetAppSettingAsBoolWithDefault(string key, bool defaultValue);
    private string TryGetAppSettingAsString(string key);
    private Nullable`1<float> TryGetAppSettingAsFloat(string key);
    private int TryGetAppSettingAsIntWithDefault(string key, int defaultValue);
    private Nullable`1<int> TryGetAppSettingAsInt(string key);
    public sealed virtual bool get_SecurityPoliciesTokenExists();
    public sealed virtual object get_AgentRunId();
    public virtual bool get_AgentEnabled();
    public sealed virtual string get_AgentEnabledAt();
    public sealed virtual bool get_ServerlessModeEnabled();
    public sealed virtual string get_ServerlessFunctionName();
    public sealed virtual string get_ServerlessFunctionVersion();
    public virtual string get_AgentLicenseKey();
    public virtual IEnumerable`1<string> get_ApplicationNames();
    public virtual string get_ApplicationNamesSource();
    private IEnumerable`1<string> GetApplicationNames();
    private string GetAppPoolId();
    public sealed virtual bool get_AutoStartAgent();
    public sealed virtual int get_WrapperExceptionLimit();
    public virtual string get_BrowserMonitoringApplicationId();
    public virtual bool get_BrowserMonitoringAutoInstrument();
    public virtual string get_BrowserMonitoringBeaconAddress();
    public virtual string get_BrowserMonitoringErrorBeaconAddress();
    public virtual string get_BrowserMonitoringJavaScriptAgent();
    public virtual string get_BrowserMonitoringJavaScriptAgentFile();
    public virtual string get_BrowserMonitoringJavaScriptAgentLoaderType();
    public virtual string get_BrowserMonitoringKey();
    public virtual bool get_BrowserMonitoringUseSsl();
    public virtual string get_SecurityPoliciesToken();
    public sealed virtual string get_ProcessHostDisplayName();
    public sealed virtual bool get_IgnoreServerSideConfiguration();
    public sealed virtual bool get_AllowAllRequestHeaders();
    public virtual bool get_CaptureAttributes();
    public sealed virtual string get_CanUseAttributesIncludesSource();
    public virtual bool get_CanUseAttributesIncludes();
    private BoolConfigurationItem GetCanUseAttributesIncludesConfiguration();
    public virtual IEnumerable`1<string> get_CaptureAttributesIncludes();
    public virtual IEnumerable`1<string> get_CaptureAttributesExcludes();
    public virtual IEnumerable`1<string> get_CaptureAttributesDefaultExcludes();
    private bool get_IsAttributesAllowedByConfigurableSecurityPolicy();
    public virtual bool get_TransactionEventsAttributesEnabled();
    public sealed virtual HashSet`1<string> get_TransactionEventsAttributesInclude();
    public sealed virtual HashSet`1<string> get_TransactionEventsAttributesExclude();
    public virtual bool get_CaptureTransactionTraceAttributes();
    private bool ShouldCaptureTransactionTraceAttributes();
    public virtual IEnumerable`1<string> get_CaptureTransactionTraceAttributesIncludes();
    private bool ShouldCaptureTransactionTraceAttributesIncludes();
    public virtual IEnumerable`1<string> get_CaptureTransactionTraceAttributesExcludes();
    public virtual bool get_CaptureErrorCollectorAttributes();
    private bool ShouldCaptureErrorCollectorAttributes();
    public virtual IEnumerable`1<string> get_CaptureErrorCollectorAttributesIncludes();
    private bool ShouldCaptureErrorCollectorAttributesIncludes();
    public virtual IEnumerable`1<string> get_CaptureErrorCollectorAttributesExcludes();
    public virtual bool get_CaptureBrowserMonitoringAttributes();
    private bool ShouldCaptureBrowserMonitorAttributes();
    public virtual IEnumerable`1<string> get_CaptureBrowserMonitoringAttributesIncludes();
    private bool ShouldCaptureBrowserMonitoringAttributesIncludes();
    public virtual IEnumerable`1<string> get_CaptureBrowserMonitoringAttributesExcludes();
    public sealed virtual string get_CaptureCustomParametersSource();
    public virtual bool get_CaptureCustomParameters();
    private BoolConfigurationItem GetShouldCaptureCustomParametersConfiguration();
    private bool GetLocalShouldCaptureCustomParameters();
    public virtual string get_CollectorHost();
    public virtual int get_CollectorPort();
    public virtual bool get_CollectorSendDataOnExit();
    public virtual float get_CollectorSendDataOnExitThreshold();
    public virtual bool get_CollectorSendEnvironmentInfo();
    public virtual bool get_CollectorSyncStartup();
    public virtual UInt32 get_CollectorTimeout();
    public virtual int get_CollectorMaxPayloadSizeInBytes();
    public virtual bool get_CompleteTransactionsOnThread();
    [CompilerGeneratedAttribute]
public sealed virtual long get_ConfigurationVersion();
    [CompilerGeneratedAttribute]
private void set_ConfigurationVersion(long value);
    public virtual string get_CrossApplicationTracingCrossProcessId();
    public virtual bool get_CrossApplicationTracingEnabled();
    private bool IsCatEnabled();
    public virtual bool get_SpanEventsEnabled();
    public sealed virtual TimeSpan get_SpanEventsHarvestCycle();
    public sealed virtual bool get_SpanEventsAttributesEnabled();
    public sealed virtual HashSet`1<string> get_SpanEventsAttributesInclude();
    public virtual HashSet`1<string> get_SpanEventsAttributesExclude();
    public virtual bool get_DistributedTracingEnabled();
    private bool IsDistributedTracingEnabled();
    public sealed virtual string get_PrimaryApplicationId();
    public sealed virtual string get_TrustedAccountKey();
    public sealed virtual string get_AccountId();
    public sealed virtual Nullable`1<int> get_SamplingTarget();
    public sealed virtual int get_SpanEventsMaxSamplesStored();
    public sealed virtual Nullable`1<int> get_SamplingTargetPeriodInSeconds();
    public sealed virtual bool get_PayloadSuccessMetricsEnabled();
    public sealed virtual bool get_ExcludeNewrelicHeader();
    public sealed virtual int get_InfiniteTracingTraceTimeoutMsConnect();
    public sealed virtual int get_InfiniteTracingTraceTimeoutMsSendData();
    public sealed virtual int get_InfiniteTracingExitTimeoutMs();
    private int GetInfiniteTracingExitTimeoutMs();
    public sealed virtual int get_InfiniteTracingTraceCountConsumers();
    private int GetInfiniteTracingCountWorkers();
    private void GetInfiniteTracingObserver();
    public sealed virtual string get_InfiniteTracingTraceObserverHost();
    public sealed virtual string get_InfiniteTracingTraceObserverPort();
    public sealed virtual string get_InfiniteTracingTraceObserverSsl();
    public sealed virtual int get_InfiniteTracingQueueSizeSpans();
    private int GetInfiniteTracingQueueSizeSpans();
    public sealed virtual int get_InfiniteTracingPartitionCountSpans();
    public sealed virtual int get_InfiniteTracingBatchSizeSpans();
    private void GetInfiniteTracingFlakyAndDelayTestSettings();
    public sealed virtual Nullable`1<float> get_InfiniteTracingTraceObserverTestFlaky();
    public sealed virtual Nullable`1<int> get_InfiniteTracingTraceObserverTestFlakyCode();
    public sealed virtual Nullable`1<int> get_InfiniteTracingTraceObserverTestDelayMs();
    public sealed virtual bool get_InfiniteTracingCompression();
    public virtual bool get_ErrorCollectorEnabled();
    public virtual bool get_ErrorCollectorCaptureEvents();
    public virtual int get_ErrorCollectorMaxEventSamplesStored();
    public sealed virtual TimeSpan get_ErrorEventsHarvestCycle();
    public virtual UInt32 get_ErrorsMaximumPerPeriod();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_IgnoreErrorsConfiguration();
    [CompilerGeneratedAttribute]
private void set_IgnoreErrorsConfiguration(IDictionary`2<string, IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_IgnoreErrorClassesForAgentSettings();
    [CompilerGeneratedAttribute]
private void set_IgnoreErrorClassesForAgentSettings(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_IgnoreErrorMessagesForAgentSettings();
    [CompilerGeneratedAttribute]
private void set_IgnoreErrorMessagesForAgentSettings(IDictionary`2<string, IEnumerable`1<string>> value);
    private IEnumerable`1<MatchRule> ParseExpectedStatusCodesArray(IEnumerable`1<string> expectedStatusCodeArray);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_ExpectedErrorsConfiguration();
    [CompilerGeneratedAttribute]
private void set_ExpectedErrorsConfiguration(IDictionary`2<string, IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<MatchRule> get_ExpectedStatusCodes();
    [CompilerGeneratedAttribute]
private void set_ExpectedStatusCodes(IEnumerable`1<MatchRule> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_ExpectedErrorClassesForAgentSettings();
    [CompilerGeneratedAttribute]
private void set_ExpectedErrorClassesForAgentSettings(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_ExpectedErrorMessagesForAgentSettings();
    [CompilerGeneratedAttribute]
private void set_ExpectedErrorMessagesForAgentSettings(IDictionary`2<string, IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_ExpectedErrorStatusCodesForAgentSettings();
    [CompilerGeneratedAttribute]
private void set_ExpectedErrorStatusCodesForAgentSettings(IEnumerable`1<string> value);
    public sealed virtual Func`2<IReadOnlyDictionary`2<string, object>, string> get_ErrorGroupCallback();
    public sealed virtual Dictionary`2<string, string> get_RequestHeadersMap();
    public virtual string get_EncodingKey();
    public virtual string get_EntityGuid();
    public virtual bool get_HighSecurityModeEnabled();
    public sealed virtual string get_CustomInstrumentationEditorEnabledSource();
    public virtual bool get_CustomInstrumentationEditorEnabled();
    private BoolConfigurationItem GetCustomInstrumentationEditorConfiguration();
    public sealed virtual string get_StripExceptionMessagesSource();
    public virtual bool get_StripExceptionMessages();
    private BoolConfigurationItem GetShouldStripExceptionMessagesConfiguration();
    public virtual bool get_InstrumentationLoggingEnabled();
    public virtual string get_Labels();
    public virtual string get_ProxyHost();
    public virtual string get_ProxyUriPath();
    public virtual int get_ProxyPort();
    public virtual string get_ProxyUsername();
    public string get_ObscuringKey();
    public virtual string get_ProxyPassword();
    public virtual string get_ProxyDomain();
    public sealed virtual bool get_PutForDataSend();
    public sealed virtual string get_CompressedContentEncoding();
    public sealed virtual bool get_InstanceReportingEnabled();
    public sealed virtual bool get_DatabaseNameReportingEnabled();
    public sealed virtual bool get_DatastoreTracerQueryParametersEnabled();
    public sealed virtual bool get_SlowSqlEnabled();
    public virtual TimeSpan get_SqlExplainPlanThreshold();
    public virtual bool get_SqlExplainPlansEnabled();
    public virtual int get_SqlExplainPlansMax();
    public virtual UInt32 get_SqlStatementsPerTransaction();
    public virtual int get_SqlTracesPerPeriod();
    public virtual int get_StackTraceMaximumFrames();
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<string> get_HttpStatusCodesToIgnore();
    [CompilerGeneratedAttribute]
private void set_HttpStatusCodesToIgnore(IEnumerable`1<string> value);
    public virtual IEnumerable`1<string> get_ThreadProfilingIgnoreMethods();
    public sealed virtual string get_CustomEventsEnabledSource();
    public virtual bool get_CustomEventsEnabled();
    private BoolConfigurationItem GetCustomEventsAreEnabledConfiguration();
    public virtual int get_CustomEventsMaximumSamplesStored();
    public sealed virtual TimeSpan get_CustomEventsHarvestCycle();
    public sealed virtual bool get_CustomEventsAttributesEnabled();
    public sealed virtual HashSet`1<string> get_CustomEventsAttributesInclude();
    public sealed virtual HashSet`1<string> get_CustomEventsAttributesExclude();
    public sealed virtual bool get_DisableSamplers();
    public sealed virtual bool get_ThreadProfilingEnabled();
    public virtual bool get_TransactionEventsEnabled();
    public virtual int get_TransactionEventsMaximumSamplesStored();
    public sealed virtual TimeSpan get_TransactionEventsHarvestCycle();
    public virtual bool get_TransactionEventsTransactionsEnabled();
    public virtual TimeSpan get_TransactionTraceApdexF();
    public virtual TimeSpan get_TransactionTraceApdexT();
    public virtual TimeSpan get_TransactionTraceThreshold();
    public virtual bool get_TransactionTracerEnabled();
    public virtual int get_TransactionTracerMaxSegments();
    public sealed virtual string get_TransactionTracerRecordSqlSource();
    public virtual string get_TransactionTracerRecordSql();
    private RecordSqlConfigurationItem GetRecordSqlConfiguration();
    private RecordSqlConfigurationItem GetServerOverrideOrLocalRecordSqlConfiguration();
    public virtual int get_TransactionTracerMaxStackTraces();
    public virtual IEnumerable`1<Regex> get_RequestPathExclusionList();
    public virtual IEnumerable`1<long> get_TrustedAccountIds();
    public sealed virtual bool get_ServerSideConfigurationEnabled();
    public sealed virtual IEnumerable`1<RegexRule> get_MetricNameRegexRules();
    public sealed virtual IEnumerable`1<RegexRule> get_TransactionNameRegexRules();
    public sealed virtual IEnumerable`1<RegexRule> get_UrlRegexRules();
    public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_TransactionNameWhitelistRules();
    public sealed virtual IDictionary`2<string, double> get_WebTransactionsApdex();
    public sealed virtual string get_NewRelicConfigFilePath();
    public sealed virtual string get_AppSettingsConfigFilePath();
    public sealed virtual bool get_UtilizationDetectAws();
    public sealed virtual bool get_UtilizationDetectAzure();
    public sealed virtual bool get_UtilizationDetectGcp();
    public sealed virtual bool get_UtilizationDetectPcf();
    public sealed virtual bool get_UtilizationDetectDocker();
    public sealed virtual bool get_UtilizationDetectKubernetes();
    public sealed virtual bool get_UtilizationDetectAzureFunction();
    public sealed virtual Nullable`1<int> get_UtilizationLogicalProcessors();
    public sealed virtual Nullable`1<int> get_UtilizationTotalRamMib();
    public sealed virtual string get_UtilizationBillingHost();
    public sealed virtual string get_UtilizationFullHostName();
    public sealed virtual string get_UtilizationHostName();
    public virtual bool get_ApplicationLoggingEnabled();
    public virtual bool get_LogMetricsCollectorEnabled();
    public virtual bool get_LogEventCollectorEnabled();
    public sealed virtual bool get_ContextDataEnabled();
    public sealed virtual IEnumerable`1<string> get_ContextDataInclude();
    public sealed virtual IEnumerable`1<string> get_ContextDataExclude();
    public sealed virtual TimeSpan get_LogEventsHarvestCycle();
    public virtual int get_LogEventsMaxSamplesStored();
    public virtual bool get_LogDecoratorEnabled();
    public virtual HashSet`1<string> get_LogLevelDenyList();
    public sealed virtual IEnumerable`1<IDictionary`2<string, string>> get_IgnoredInstrumentation();
    public sealed virtual bool get_DisableFileSystemWatcher();
    public sealed virtual bool get_AiMonitoringEnabled();
    public sealed virtual bool get_AiMonitoringStreamingEnabled();
    public sealed virtual bool get_AiMonitoringRecordContentEnabled();
    public sealed virtual Func`3<string, string, int> get_LlmTokenCountingCallback();
    public sealed virtual bool get_AzureFunctionModeDetected();
    public sealed virtual bool get_AzureFunctionModeEnabled();
    public sealed virtual string get_AzureFunctionResourceId();
    public sealed virtual string AzureFunctionResourceIdWithFunctionName(string functionName);
    public sealed virtual string get_AzureFunctionResourceGroupName();
    public sealed virtual string get_AzureFunctionRegion();
    public sealed virtual string get_AzureFunctionSubscriptionId();
    public sealed virtual string get_AzureFunctionServiceName();
    public virtual bool get_AppDomainCachingDisabled();
    public virtual bool get_ForceNewTransactionOnNewThread();
    public sealed virtual bool get_DiagnosticsCaptureAgentTiming();
    public sealed virtual int get_DiagnosticsCaptureAgentTimingFrequency();
    private void UpdateDiagnosticsAgentTimingSettings();
    public sealed virtual bool get_ForceSynchronousTimingCalculationHttpClient();
    public sealed virtual bool get_EnableAspNetCore6PlusBrowserInjection();
    public sealed virtual TimeSpan get_MetricsHarvestCycle();
    public sealed virtual TimeSpan get_TransactionTracesHarvestCycle();
    public sealed virtual TimeSpan get_ErrorTracesHarvestCycle();
    public sealed virtual TimeSpan get_GetAgentCommandsCycle();
    public sealed virtual TimeSpan get_SqlTracesHarvestCycle();
    public sealed virtual TimeSpan get_UpdateLoadedModulesCycle();
    public sealed virtual TimeSpan get_StackExchangeRedisCleanupCycle();
    private TimeSpan ParseTransactionThreshold(string threshold, Func`2<double, TimeSpan> numberToTimeSpanConverter);
    private static bool ServerCanDisable(Nullable`1<bool> server, bool local);
    private static string ServerOverrides(string server, string local);
    private static T ServerOverrides(Nullable`1<T> server, T local);
    private T HighSecurityModeOverrides(T overriddenValue, T originalValue);
    private static T ServerOverrides(T server, T local);
    private IEnumerable`1<string> EnvironmentOverrides(IEnumerable`1<string> local, String[] environmentVariableNames);
    private string EnvironmentOverrides(string local, String[] environmentVariableNames);
    public static string EnvironmentOverrides(IEnvironment environment, string local, String[] environmentVariableNames);
    private Nullable`1<UInt32> EnvironmentOverrides(Nullable`1<UInt32> local, String[] environmentVariableNames);
    private Nullable`1<int> EnvironmentOverrides(Nullable`1<int> local, String[] environmentVariableNames);
    public static Nullable`1<int> EnvironmentOverrides(IEnvironment environment, Nullable`1<int> local, String[] environmentVariableNames);
    private Nullable`1<double> EnvironmentOverrides(Nullable`1<double> local, String[] environmentVariableNames);
    private bool EnvironmentOverrides(bool local, String[] environmentVariableNames);
    public static bool EnvironmentOverrides(IEnvironment environment, bool local, String[] environmentVariableNames);
    private IList`1<Regex> ReadUrlBlacklist(configuration config);
    public static IEnumerable`1<RegexRule> GetRegexRules(IEnumerable`1<RegexRule> rules);
    private static Nullable`1<RegexRule> TryGetRegexRule(RegexRule rule);
    private static string UpdateRegexForDotNet(string replacement);
    public static IDictionary`2<string, IEnumerable`1<string>> GetWhitelistRules(IEnumerable`1<WhitelistRule> whitelistRules);
    private static Nullable`1<KeyValuePair`2<string, IEnumerable`1<string>>> TryGetValidPrefixAndTerms(WhitelistRule rule);
    private void ParseExpectedErrorConfigurations();
    private void ParseIgnoreErrorConfigurations();
    private static string TryGetValidPrefix(string prefix);
    private static Nullable`1<int> GetNullableIntValue(bool specified, int value);
    private void LogDisabledWarnings();
    private void LogDisabledPropertyUse(string disabledPropertyName, string newPropertyName);
    public sealed virtual int get_DatabaseStatementCacheCapacity();
    public sealed virtual bool get_CodeLevelMetricsEnabled();
    public static bool GetLoggingEnabledValue(IEnvironment environment, configurationLog localLogConfiguration);
    public sealed virtual bool get_LoggingEnabled();
    public static string GetLoggingLevelValue(IEnvironment environment, configurationLog localLogConfiguration, bool isLoggingEnabled);
    public sealed virtual string get_LoggingLevel();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <get_CaptureAttributesIncludes>b__116_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <get_CaptureAttributesExcludes>b__119_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <get_CaptureTransactionTraceAttributesIncludes>b__138_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <get_CaptureTransactionTraceAttributesExcludes>b__141_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <get_CaptureErrorCollectorAttributesIncludes>b__148_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <get_CaptureErrorCollectorAttributesExcludes>b__152_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <get_CaptureBrowserMonitoringAttributesIncludes>b__158_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <get_CaptureBrowserMonitoringAttributesExcludes>b__161_0();
}
public class NewRelic.Agent.Core.Configuration.EventHarvestConfig : object {
    public static string ErrorEventHarvestLimitKey;
    public static string CustomEventHarvestLimitKey;
    public static string TransactionEventHarvestLimitKey;
    public static string LogEventHarvestLimitKey;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReportPeriodMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> <HarvestLimits>k__BackingField;
    [JsonPropertyAttribute("report_period_ms")]
public Nullable`1<int> ReportPeriodMs { get; public set; }
    [JsonPropertyAttribute("harvest_limits")]
public Dictionary`2<string, int> HarvestLimits { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReportPeriodMs();
    [CompilerGeneratedAttribute]
public void set_ReportPeriodMs(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, int> get_HarvestLimits();
    [CompilerGeneratedAttribute]
public void set_HarvestLimits(Dictionary`2<string, int> value);
    public Nullable`1<int> ErrorEventHarvestLimit();
    public Nullable`1<TimeSpan> ErrorEventHarvestCycle();
    public Nullable`1<int> CustomEventHarvestLimit();
    public Nullable`1<TimeSpan> CustomEventHarvestCycle();
    public Nullable`1<int> TransactionEventHarvestLimit();
    public Nullable`1<TimeSpan> TransactionEventHarvestCycle();
    public Nullable`1<int> LogEventHarvestLimit();
    public Nullable`1<TimeSpan> LogEventHarvestCycle();
    private Nullable`1<int> GetEventHarvestLimitFor(string eventType);
    private Nullable`1<TimeSpan> GetEventHarvestCycleFor(string eventType);
}
public interface NewRelic.Agent.Core.Configuration.IConfigurationManagerStatic {
    public string AppSettingsFilePath { get; }
    public abstract virtual string get_AppSettingsFilePath();
    public abstract virtual string GetAppSetting(string key);
}
internal class NewRelic.Agent.Core.Configuration.InternalConfiguration : DefaultConfiguration {
    public InternalConfiguration(IEnvironment environment, configuration localConfiguration, ServerConfiguration serverConfiguration, RunTimeConfiguration runTimeConfiguration, SecurityPoliciesConfiguration securityPoliciesConfiguration, IBootstrapConfiguration bootstrapConfiguration, IProcessStatic processStatic, IHttpRuntimeStatic httpRuntimeStatic, IConfigurationManagerStatic configurationManagerStatic, IDnsStatic dnsStatic);
}
public class NewRelic.Agent.Core.Configuration.RecordSqlConfigurationItem : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Value { get; private set; }
    public string Source { get; private set; }
    public RecordSqlConfigurationItem(string value, string source);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    public RecordSqlConfigurationItem ApplyIfMoreRestrictive(RecordSqlConfigurationItem newConfiguration);
    public RecordSqlConfigurationItem ApplyIfMoreRestrictive(string newValue, string newSource);
    public RecordSqlConfigurationItem ApplyIfMoreRestrictive(configurationTransactionTracerRecordSql newValue, string newSource);
}
[JsonObjectAttribute]
public class NewRelic.Agent.Core.Configuration.ReportedConfiguration : object {
    private IConfiguration _configuration;
    [JsonPropertyAttribute("agent.name")]
public static string Agent;
    [JsonPropertyAttribute("agent.run_id")]
public object AgentRunId { get; }
    [JsonPropertyAttribute("agent.enabled")]
public bool AgentEnabled { get; }
    [JsonIgnoreAttribute]
public string AgentEnabledAt { get; }
    [JsonIgnoreAttribute]
public bool ServerlessModeEnabled { get; }
    [JsonIgnoreAttribute]
public string ServerlessFunctionName { get; }
    [JsonIgnoreAttribute]
public string ServerlessFunctionVersion { get; }
    [JsonIgnoreAttribute]
public string AgentLicenseKey { get; }
    [JsonPropertyAttribute("agent.license_key.configured")]
public bool AgentLicenseKeyConfigured { get; }
    [JsonPropertyAttribute("agent.application_names")]
public IEnumerable`1<string> ApplicationNames { get; }
    [JsonPropertyAttribute("agent.application_names_source")]
public string ApplicationNamesSource { get; }
    [JsonPropertyAttribute("agent.auto_start")]
public bool AutoStartAgent { get; }
    [JsonPropertyAttribute("browser_monitoring.application_id")]
public string BrowserMonitoringApplicationId { get; }
    [JsonPropertyAttribute("browser_monitoring.auto_instrument")]
public bool BrowserMonitoringAutoInstrument { get; }
    [JsonPropertyAttribute("browser_monitoring.beacon_address")]
public string BrowserMonitoringBeaconAddress { get; }
    [JsonPropertyAttribute("browser_monitoring.error_beacon_address")]
public string BrowserMonitoringErrorBeaconAddress { get; }
    [JsonIgnoreAttribute]
public string BrowserMonitoringJavaScriptAgent { get; }
    [JsonPropertyAttribute("browser_monitoring.javascript_agent.populated")]
public bool BrowserMonitoringJavaScriptAgentPopulated { get; }
    [JsonPropertyAttribute("browser_monitoring.javascript_agent_file")]
public string BrowserMonitoringJavaScriptAgentFile { get; }
    [JsonPropertyAttribute("browser_monitoring.loader")]
public string BrowserMonitoringJavaScriptAgentLoaderType { get; }
    [JsonPropertyAttribute("browser_monitoring.loader_debug")]
public bool LoaderDebug { get; }
    [JsonIgnoreAttribute]
public string BrowserMonitoringKey { get; }
    [JsonPropertyAttribute("browser_monitoring.monitoring_key.populated")]
public bool BrowserMonitoringKeyPopulated { get; }
    [JsonPropertyAttribute("browser_monitoring.use_ssl")]
public bool BrowserMonitoringUseSsl { get; }
    [JsonPropertyAttribute("security.policies_token")]
public string SecurityPoliciesToken { get; }
    [JsonPropertyAttribute("security.policies_token_exists")]
public bool SecurityPoliciesTokenExists { get; }
    [JsonPropertyAttribute("agent.allow_all_request_headers")]
public bool AllowAllRequestHeaders { get; }
    [JsonPropertyAttribute("agent.attributes_enabled")]
public bool CaptureAttributes { get; }
    [JsonPropertyAttribute("agent.can_use_attributes_includes")]
public bool CanUseAttributesIncludes { get; }
    [JsonPropertyAttribute("agent.can_use_attributes_includes_source")]
public string CanUseAttributesIncludesSource { get; }
    [JsonPropertyAttribute("agent.attributes_include")]
public IEnumerable`1<string> CaptureAttributesIncludes { get; }
    [JsonPropertyAttribute("agent.attributes_exclude")]
public IEnumerable`1<string> CaptureAttributesExcludes { get; }
    [JsonPropertyAttribute("agent.attributes_default_excludes")]
public IEnumerable`1<string> CaptureAttributesDefaultExcludes { get; }
    [JsonPropertyAttribute("transaction_events.attributes_enabled")]
public bool TransactionEventsAttributesEnabled { get; }
    [JsonPropertyAttribute("transaction_events.attributes_include")]
public HashSet`1<string> TransactionEventsAttributesInclude { get; }
    [JsonPropertyAttribute("transaction_events.attributes_exclude")]
public HashSet`1<string> TransactionEventsAttributesExclude { get; }
    [JsonPropertyAttribute("transaction_trace.attributes_enabled")]
public bool CaptureTransactionTraceAttributes { get; }
    [JsonPropertyAttribute("transaction_trace.attributes_include")]
public IEnumerable`1<string> CaptureTransactionTraceAttributesIncludes { get; }
    [JsonPropertyAttribute("transaction_trace.attributes_exclude")]
public IEnumerable`1<string> CaptureTransactionTraceAttributesExcludes { get; }
    [JsonPropertyAttribute("error_collector.attributes_enabled")]
public bool CaptureErrorCollectorAttributes { get; }
    [JsonPropertyAttribute("error_collector.attributes_include")]
public IEnumerable`1<string> CaptureErrorCollectorAttributesIncludes { get; }
    [JsonPropertyAttribute("error_collector.attributes_exclude")]
public IEnumerable`1<string> CaptureErrorCollectorAttributesExcludes { get; }
    [JsonPropertyAttribute("browser_monitoring.attributes_enabled")]
public bool CaptureBrowserMonitoringAttributes { get; }
    [JsonPropertyAttribute("browser_monitoring.attributes_include")]
public IEnumerable`1<string> CaptureBrowserMonitoringAttributesIncludes { get; }
    [JsonPropertyAttribute("browser_monitoring.attributes_exclude")]
public IEnumerable`1<string> CaptureBrowserMonitoringAttributesExcludes { get; }
    [JsonPropertyAttribute("custom_parameters.enabled")]
public bool CaptureCustomParameters { get; }
    [JsonPropertyAttribute("custom_parameters.source")]
public string CaptureCustomParametersSource { get; }
    [JsonPropertyAttribute("collector.host")]
public string CollectorHost { get; }
    [JsonPropertyAttribute("collector.port")]
public int CollectorPort { get; }
    [JsonPropertyAttribute("collector.send_data_on_exit")]
public bool CollectorSendDataOnExit { get; }
    [JsonPropertyAttribute("collector.send_data_on_exit_threshold")]
public float CollectorSendDataOnExitThreshold { get; }
    [JsonPropertyAttribute("collector.send_environment_info")]
public bool CollectorSendEnvironmentInfo { get; }
    [JsonPropertyAttribute("collector.sync_startup")]
public bool CollectorSyncStartup { get; }
    [JsonPropertyAttribute("collector.timeout")]
public UInt32 CollectorTimeout { get; }
    [JsonPropertyAttribute("collector.max_payload_size_in_bytes")]
public int CollectorMaxPayloadSizeInBytes { get; }
    [JsonPropertyAttribute("agent.complete_transactions_on_thread")]
public bool CompleteTransactionsOnThread { get; }
    [JsonPropertyAttribute("agent.compressed_content_encoding")]
public string CompressedContentEncoding { get; }
    [JsonPropertyAttribute("agent.configuration_version")]
public long ConfigurationVersion { get; }
    [JsonPropertyAttribute("cross_application_tracer.cross_process_id")]
public string CrossApplicationTracingCrossProcessId { get; }
    [JsonPropertyAttribute("cross_application_tracer.enabled")]
public bool CrossApplicationTracingEnabled { get; }
    [JsonPropertyAttribute("distributed_tracing.enabled")]
public bool DistributedTracingEnabled { get; }
    [JsonPropertyAttribute("span_events.enabled")]
public bool SpanEventsEnabled { get; }
    [JsonPropertyAttribute("span_events.harvest_cycle")]
public TimeSpan SpanEventsHarvestCycle { get; }
    [JsonPropertyAttribute("span_events.attributes_enabled")]
public bool SpanEventsAttributesEnabled { get; }
    [JsonPropertyAttribute("span_events.attributes_include")]
public HashSet`1<string> SpanEventsAttributesInclude { get; }
    [JsonPropertyAttribute("span_events.attributes_exclude")]
public HashSet`1<string> SpanEventsAttributesExclude { get; }
    [JsonPropertyAttribute("infinite_tracing.trace_count_consumers")]
public int InfiniteTracingTraceCountConsumers { get; }
    [JsonPropertyAttribute("infinite_tracing.trace_observer_host")]
public string InfiniteTracingTraceObserverHost { get; }
    [JsonPropertyAttribute("infinite_tracing.trace_observer_port")]
public string InfiniteTracingTraceObserverPort { get; }
    [JsonPropertyAttribute("infinite_tracing.trace_observer_ssl")]
public string InfiniteTracingTraceObserverSsl { get; }
    [JsonPropertyAttribute("infinite_tracing.dev.test_flaky")]
public Nullable`1<float> InfiniteTracingTraceObserverTestFlaky { get; }
    [JsonPropertyAttribute("infinite_tracing.dev.test_flaky_code")]
public Nullable`1<int> InfiniteTracingTraceObserverTestFlakyCode { get; }
    [JsonPropertyAttribute("infinite_tracing.dev.test_delay_ms")]
public Nullable`1<int> InfiniteTracingTraceObserverTestDelayMs { get; }
    [JsonPropertyAttribute("infinite_tracing.spans_queue_size")]
public int InfiniteTracingQueueSizeSpans { get; }
    [JsonPropertyAttribute("infinite_tracing.spans_partition_count")]
public int InfiniteTracingPartitionCountSpans { get; }
    [JsonPropertyAttribute("infinite_tracing.spans_batch_size")]
public int InfiniteTracingBatchSizeSpans { get; }
    [JsonPropertyAttribute("infinite_tracing.connect_timeout_ms")]
public int InfiniteTracingTraceTimeoutMsConnect { get; }
    [JsonPropertyAttribute("infinite_tracing.send_data_timeout_ms")]
public int InfiniteTracingTraceTimeoutMsSendData { get; }
    [JsonPropertyAttribute("infinite_tracing.exit_timeout_ms")]
public int InfiniteTracingExitTimeoutMs { get; }
    [JsonPropertyAttribute("infinite_tracing.compression")]
public bool InfiniteTracingCompression { get; }
    [JsonPropertyAttribute("agent.primary_application_id")]
public string PrimaryApplicationId { get; }
    [JsonPropertyAttribute("agent.trusted_account_key")]
public string TrustedAccountKey { get; }
    [JsonPropertyAttribute("agent.account_id")]
public string AccountId { get; }
    [JsonPropertyAttribute("datastore_tracer.name_reporting_enabled")]
public bool DatabaseNameReportingEnabled { get; }
    [JsonPropertyAttribute("datastore_tracer.query_parameters_enabled")]
public bool DatastoreTracerQueryParametersEnabled { get; }
    [JsonPropertyAttribute("error_collector.enabled")]
public bool ErrorCollectorEnabled { get; }
    [JsonPropertyAttribute("error_collector.capture_events_enabled")]
public bool ErrorCollectorCaptureEvents { get; }
    [JsonPropertyAttribute("error_collector.max_samples_stored")]
public int ErrorCollectorMaxEventSamplesStored { get; }
    [JsonPropertyAttribute("error_collector.harvest_cycle")]
public TimeSpan ErrorEventsHarvestCycle { get; }
    [JsonPropertyAttribute("error_collector.max_per_period")]
public UInt32 ErrorsMaximumPerPeriod { get; }
    [JsonPropertyAttribute("error_collector.expected_classes")]
public IEnumerable`1<string> ExpectedErrorClassesForAgentSettings { get; }
    [JsonPropertyAttribute("error_collector.expected_messages")]
public IDictionary`2<string, IEnumerable`1<string>> ExpectedErrorMessagesForAgentSettings { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<MatchRule> ExpectedStatusCodes { get; }
    [JsonPropertyAttribute("error_collector.expected_status_codes")]
public IEnumerable`1<string> ExpectedErrorStatusCodesForAgentSettings { get; }
    [JsonPropertyAttribute("error_collector.expected_errors_config")]
public IDictionary`2<string, IEnumerable`1<string>> ExpectedErrorsConfiguration { get; }
    [JsonPropertyAttribute("error_collector.ignore_errors_config")]
public IDictionary`2<string, IEnumerable`1<string>> IgnoreErrorsConfiguration { get; }
    [JsonPropertyAttribute("error_collector.ignore_classes")]
public IEnumerable`1<string> IgnoreErrorClassesForAgentSettings { get; }
    [JsonPropertyAttribute("error_collector.ignore_messages")]
public IDictionary`2<string, IEnumerable`1<string>> IgnoreErrorMessagesForAgentSettings { get; }
    [JsonIgnoreAttribute]
public Func`2<IReadOnlyDictionary`2<string, object>, string> ErrorGroupCallback { get; }
    [JsonPropertyAttribute("agent.request_headers_map")]
public Dictionary`2<string, string> RequestHeadersMap { get; }
    [JsonPropertyAttribute("cross_application_tracer.encoding_key")]
public string EncodingKey { get; }
    [JsonPropertyAttribute("agent.entity_guid")]
public string EntityGuid { get; }
    [JsonPropertyAttribute("agent.high_security_mode_enabled")]
public bool HighSecurityModeEnabled { get; }
    [JsonPropertyAttribute("agent.custom_instrumentation_editor_enabled")]
public bool CustomInstrumentationEditorEnabled { get; }
    [JsonPropertyAttribute("agent.custom_instrumentation_editor_enabled_source")]
public string CustomInstrumentationEditorEnabledSource { get; }
    [JsonPropertyAttribute("agent.strip_exception_messages")]
public bool StripExceptionMessages { get; }
    [JsonPropertyAttribute("agent.strip_exception_messages_source")]
public string StripExceptionMessagesSource { get; }
    [JsonPropertyAttribute("agent.instance_reporting_enabled")]
public bool InstanceReportingEnabled { get; }
    [JsonPropertyAttribute("agent.instrumentation_logging_enabled")]
public bool InstrumentationLoggingEnabled { get; }
    [JsonPropertyAttribute("agent.labels")]
public string Labels { get; }
    [JsonPropertyAttribute("agent.metric_name_regex_rules")]
public IEnumerable`1<RegexRule> MetricNameRegexRules { get; }
    [JsonPropertyAttribute("agent.new_relic_config_file_path")]
public string NewRelicConfigFilePath { get; }
    [JsonPropertyAttribute("agent.app_settings_config_file_path")]
public string AppSettingsConfigFilePath { get; }
    [JsonIgnoreAttribute]
public string ProxyHost { get; }
    [JsonPropertyAttribute("proxy.host.configured")]
public bool ProxyHostConfigured { get; }
    [JsonIgnoreAttribute]
public string ProxyUriPath { get; }
    [JsonPropertyAttribute("proxy.uri_path.configured")]
public bool ProxyUriPathConfigured { get; }
    [JsonIgnoreAttribute]
public int ProxyPort { get; }
    [JsonPropertyAttribute("proxy.port.configured")]
public bool ProxyPortConfigured { get; }
    [JsonIgnoreAttribute]
public string ProxyUsername { get; }
    [JsonPropertyAttribute("proxy.username.configured")]
public bool ProxyUsernameConfigured { get; }
    [JsonIgnoreAttribute]
public string ProxyPassword { get; }
    [JsonPropertyAttribute("proxy.password.configured")]
public bool ProxyPasswordConfigured { get; }
    [JsonIgnoreAttribute]
public string ProxyDomain { get; }
    [JsonPropertyAttribute("proxy.domain.configured")]
public bool ProxyDomainConfigured { get; }
    [JsonPropertyAttribute("agent.put_for_data_sent")]
public bool PutForDataSend { get; }
    [JsonPropertyAttribute("slow_sql.enabled")]
public bool SlowSqlEnabled { get; }
    [JsonPropertyAttribute("transaction_tracer.explain_threshold")]
public TimeSpan SqlExplainPlanThreshold { get; }
    [JsonPropertyAttribute("transaction_tracer.explain_enabled")]
public bool SqlExplainPlansEnabled { get; }
    [JsonPropertyAttribute("transaction_tracer.max_explain_plans")]
public int SqlExplainPlansMax { get; }
    [JsonPropertyAttribute("transaction_tracer.max_sql_statements")]
public UInt32 SqlStatementsPerTransaction { get; }
    [JsonPropertyAttribute("transaction_tracer.sql_traces_per_period")]
public int SqlTracesPerPeriod { get; }
    [JsonPropertyAttribute("transaction_tracer.max_stack_trace_lines")]
public int StackTraceMaximumFrames { get; }
    [JsonPropertyAttribute("error_collector.ignore_status_codes")]
public IEnumerable`1<string> HttpStatusCodesToIgnore { get; }
    [JsonPropertyAttribute("agent.thread_profiling_methods_to_ignore")]
public IEnumerable`1<string> ThreadProfilingIgnoreMethods { get; }
    [JsonPropertyAttribute("custom_events.enabled")]
public bool CustomEventsEnabled { get; }
    [JsonPropertyAttribute("custom_events.enabled_source")]
public string CustomEventsEnabledSource { get; }
    [JsonPropertyAttribute("custom_events.attributes_enabled")]
public bool CustomEventsAttributesEnabled { get; }
    [JsonPropertyAttribute("custom_events.attributes_include")]
public HashSet`1<string> CustomEventsAttributesInclude { get; }
    [JsonPropertyAttribute("custom_events.attributes_exclude")]
public HashSet`1<string> CustomEventsAttributesExclude { get; }
    [JsonPropertyAttribute("custom_events.max_samples_stored")]
public int CustomEventsMaximumSamplesStored { get; }
    [JsonPropertyAttribute("custom_events.harvest_cycle")]
public TimeSpan CustomEventsHarvestCycle { get; }
    [JsonPropertyAttribute("agent.disable_samplers")]
public bool DisableSamplers { get; }
    [JsonPropertyAttribute("thread_profiler.enabled")]
public bool ThreadProfilingEnabled { get; }
    [JsonPropertyAttribute("transaction_events.enabled")]
public bool TransactionEventsEnabled { get; }
    [JsonPropertyAttribute("transaction_events.max_samples_stored")]
public int TransactionEventsMaximumSamplesStored { get; }
    [JsonPropertyAttribute("transaction_events.harvest_cycle")]
public TimeSpan TransactionEventsHarvestCycle { get; }
    [JsonPropertyAttribute("transaction_events.transactions_enabled")]
public bool TransactionEventsTransactionsEnabled { get; }
    [JsonPropertyAttribute("transaction_name.regex_rules")]
public IEnumerable`1<RegexRule> TransactionNameRegexRules { get; }
    [JsonPropertyAttribute("transaction_name.whitelist_rules")]
public IDictionary`2<string, IEnumerable`1<string>> TransactionNameWhitelistRules { get; }
    [JsonPropertyAttribute("transaction_tracer.apdex_f")]
public TimeSpan TransactionTraceApdexF { get; }
    [JsonPropertyAttribute("transaction_tracer.apdex_t")]
public TimeSpan TransactionTraceApdexT { get; }
    [JsonPropertyAttribute("transaction_tracer.transaction_threshold")]
public TimeSpan TransactionTraceThreshold { get; }
    [JsonPropertyAttribute("transaction_tracer.enabled")]
public bool TransactionTracerEnabled { get; }
    [JsonPropertyAttribute("transaction_tracer.max_segments")]
public int TransactionTracerMaxSegments { get; }
    [JsonPropertyAttribute("transaction_tracer.record_sql")]
public string TransactionTracerRecordSql { get; }
    [JsonPropertyAttribute("transaction_tracer.record_sql_source")]
public string TransactionTracerRecordSqlSource { get; }
    [JsonPropertyAttribute("transaction_tracer.max_stack_traces")]
public int TransactionTracerMaxStackTraces { get; }
    [JsonPropertyAttribute("agent.trusted_account_ids")]
public IEnumerable`1<long> TrustedAccountIds { get; }
    [JsonPropertyAttribute("agent.server_side_config_enabled")]
public bool ServerSideConfigurationEnabled { get; }
    [JsonPropertyAttribute("agent.ignore_server_side_config")]
public bool IgnoreServerSideConfiguration { get; }
    [JsonPropertyAttribute("agent.url_regex_rules")]
public IEnumerable`1<RegexRule> UrlRegexRules { get; }
    [JsonPropertyAttribute("agent.request_path_exclusion_list")]
public IEnumerable`1<Regex> RequestPathExclusionList { get; }
    [JsonPropertyAttribute("agent.web_transactions_apdex")]
public IDictionary`2<string, double> WebTransactionsApdex { get; }
    [JsonPropertyAttribute("agent.wrapper_exception_limit")]
public int WrapperExceptionLimit { get; }
    [JsonPropertyAttribute("utilization.detect_aws_enabled")]
public bool UtilizationDetectAws { get; }
    [JsonPropertyAttribute("utilization.detect_azure_enabled")]
public bool UtilizationDetectAzure { get; }
    [JsonPropertyAttribute("utilization.detect_gcp_enabled")]
public bool UtilizationDetectGcp { get; }
    [JsonPropertyAttribute("utilization.detect_pcf_enabled")]
public bool UtilizationDetectPcf { get; }
    [JsonPropertyAttribute("utilization.detect_docker_enabled")]
public bool UtilizationDetectDocker { get; }
    [JsonPropertyAttribute("utilization.detect_kubernetes_enabled")]
public bool UtilizationDetectKubernetes { get; }
    [JsonPropertyAttribute("utilization.detect_azure_function_enabled")]
public bool UtilizationDetectAzureFunction { get; }
    [JsonPropertyAttribute("utilization.logical_processors")]
public Nullable`1<int> UtilizationLogicalProcessors { get; }
    [JsonPropertyAttribute("utilization.total_ram_mib")]
public Nullable`1<int> UtilizationTotalRamMib { get; }
    [JsonPropertyAttribute("utilization.billing_host")]
public string UtilizationBillingHost { get; }
    [JsonPropertyAttribute("utilization.hostname")]
public string UtilizationHostName { get; }
    [JsonPropertyAttribute("utilization.full_hostname")]
public string UtilizationFullHostName { get; }
    [JsonPropertyAttribute("diagnostics.capture_agent_timing_enabled")]
public bool DiagnosticsCaptureAgentTiming { get; }
    [JsonPropertyAttribute("diagnostics.capture_agent_timing_frequency")]
public int DiagnosticsCaptureAgentTimingFrequency { get; }
    [JsonPropertyAttribute("agent.use_resource_based_naming_for_wcf_enabled")]
public bool UseResourceBasedNamingForWCFEnabled { get; }
    [JsonPropertyAttribute("agent.event_listener_samplers_enabled")]
public bool EventListenerSamplersEnabled { get; public set; }
    [JsonPropertyAttribute("agent.sampling_target")]
public Nullable`1<int> SamplingTarget { get; }
    [JsonPropertyAttribute("span_events.max_samples_stored")]
public int SpanEventsMaxSamplesStored { get; }
    [JsonPropertyAttribute("agent.sampling_target_period_in_seconds")]
public Nullable`1<int> SamplingTargetPeriodInSeconds { get; }
    [JsonPropertyAttribute("agent.payload_success_metrics_enabled")]
public bool PayloadSuccessMetricsEnabled { get; }
    [JsonPropertyAttribute("agent.process_host_display_name")]
public string ProcessHostDisplayName { get; }
    [JsonPropertyAttribute("transaction_tracer.database_statement_cache_capacity")]
public int DatabaseStatementCacheCapacity { get; }
    [JsonPropertyAttribute("agent.force_synchronous_timing_calculation_for_http_client")]
public bool ForceSynchronousTimingCalculationHttpClient { get; }
    [JsonPropertyAttribute("agent.enable_asp_net_core_6plus_browser_injection")]
public bool EnableAspNetCore6PlusBrowserInjection { get; }
    [JsonPropertyAttribute("agent.exclude_new_relic_header")]
public bool ExcludeNewrelicHeader { get; }
    [JsonPropertyAttribute("application_logging.enabled")]
public bool ApplicationLoggingEnabled { get; }
    [JsonPropertyAttribute("application_logging.metrics.enabled")]
public bool LogMetricsCollectorEnabled { get; }
    [JsonPropertyAttribute("application_logging.forwarding.enabled")]
public bool LogEventCollectorEnabled { get; }
    [JsonPropertyAttribute("application_logging.forwarding.max_samples_stored")]
public int LogEventsMaxSamplesStored { get; }
    [JsonPropertyAttribute("application_logging.forwarding.log_level_denylist")]
public HashSet`1<string> LogLevelDenyList { get; }
    [JsonPropertyAttribute("application_logging.harvest_cycle")]
public TimeSpan LogEventsHarvestCycle { get; }
    [JsonPropertyAttribute("application_logging.local_decorating.enabled")]
public bool LogDecoratorEnabled { get; }
    [JsonPropertyAttribute("agent.app_domain_caching_disabled")]
public bool AppDomainCachingDisabled { get; }
    [JsonPropertyAttribute("agent.force_new_transaction_on_new_thread_enabled")]
public bool ForceNewTransactionOnNewThread { get; }
    [JsonPropertyAttribute("agent.code_level_metrics_enabled")]
public bool CodeLevelMetricsEnabled { get; }
    [JsonPropertyAttribute("agent.app_settings")]
public IReadOnlyDictionary`2<string, string> AppSettings { get; }
    [JsonPropertyAttribute("application_logging.forwarding.context_data.enabled")]
public bool ContextDataEnabled { get; }
    [JsonPropertyAttribute("application_logging.forwarding.context_data.include")]
public IEnumerable`1<string> ContextDataInclude { get; }
    [JsonPropertyAttribute("application_logging.forwarding.context_data.exclude")]
public IEnumerable`1<string> ContextDataExclude { get; }
    [JsonPropertyAttribute("metrics.harvest_cycle")]
public TimeSpan MetricsHarvestCycle { get; }
    [JsonPropertyAttribute("transaction_traces.harvest_cycle")]
public TimeSpan TransactionTracesHarvestCycle { get; }
    [JsonPropertyAttribute("error_traces.harvest_cycle")]
public TimeSpan ErrorTracesHarvestCycle { get; }
    [JsonPropertyAttribute("get_agent_commands.cycle")]
public TimeSpan GetAgentCommandsCycle { get; }
    [JsonPropertyAttribute("default.harvest_cycle")]
public TimeSpan DefaultHarvestCycle { get; }
    [JsonPropertyAttribute("sql_traces.harvest_cycle")]
public TimeSpan SqlTracesHarvestCycle { get; }
    [JsonPropertyAttribute("update_loaded_modules.cycle")]
public TimeSpan UpdateLoadedModulesCycle { get; }
    [JsonPropertyAttribute("stackexchangeredis_cleanup.cycle")]
public TimeSpan StackExchangeRedisCleanupCycle { get; }
    [JsonPropertyAttribute("agent.logging_enabled")]
public bool LoggingEnabled { get; }
    [JsonIgnoreAttribute]
public string LoggingLevel { get; }
    [JsonPropertyAttribute("agent.instrumentation.ignore")]
public IEnumerable`1<IDictionary`2<string, string>> IgnoredInstrumentation { get; }
    [JsonPropertyAttribute("agent.disable_file_system_watcher")]
public bool DisableFileSystemWatcher { get; }
    [JsonPropertyAttribute("ai_monitoring.enabled")]
public bool AiMonitoringEnabled { get; }
    [JsonPropertyAttribute("ai_monitoring.streaming.enabled")]
public bool AiMonitoringStreamingEnabled { get; }
    [JsonPropertyAttribute("ai_monitoring.record_content.enabled")]
public bool AiMonitoringRecordContentEnabled { get; }
    [JsonIgnoreAttribute]
public Func`3<string, string, int> LlmTokenCountingCallback { get; }
    [JsonIgnoreAttribute]
public bool AzureFunctionModeDetected { get; }
    [JsonIgnoreAttribute]
public bool AzureFunctionModeEnabled { get; }
    [JsonIgnoreAttribute]
public string AzureFunctionResourceId { get; }
    [JsonIgnoreAttribute]
public string AzureFunctionResourceGroupName { get; }
    [JsonIgnoreAttribute]
public string AzureFunctionRegion { get; }
    [JsonIgnoreAttribute]
public string AzureFunctionSubscriptionId { get; }
    [JsonIgnoreAttribute]
public string AzureFunctionServiceName { get; }
    public ReportedConfiguration(IConfiguration configuration);
    public sealed virtual object get_AgentRunId();
    public sealed virtual bool get_AgentEnabled();
    public sealed virtual string get_AgentEnabledAt();
    public sealed virtual bool get_ServerlessModeEnabled();
    public sealed virtual string get_ServerlessFunctionName();
    public sealed virtual string get_ServerlessFunctionVersion();
    public sealed virtual string get_AgentLicenseKey();
    public bool get_AgentLicenseKeyConfigured();
    public sealed virtual IEnumerable`1<string> get_ApplicationNames();
    public sealed virtual string get_ApplicationNamesSource();
    public sealed virtual bool get_AutoStartAgent();
    public sealed virtual string get_BrowserMonitoringApplicationId();
    public sealed virtual bool get_BrowserMonitoringAutoInstrument();
    public sealed virtual string get_BrowserMonitoringBeaconAddress();
    public sealed virtual string get_BrowserMonitoringErrorBeaconAddress();
    public sealed virtual string get_BrowserMonitoringJavaScriptAgent();
    public bool get_BrowserMonitoringJavaScriptAgentPopulated();
    public sealed virtual string get_BrowserMonitoringJavaScriptAgentFile();
    public sealed virtual string get_BrowserMonitoringJavaScriptAgentLoaderType();
    public bool get_LoaderDebug();
    public sealed virtual string get_BrowserMonitoringKey();
    public bool get_BrowserMonitoringKeyPopulated();
    public sealed virtual bool get_BrowserMonitoringUseSsl();
    public sealed virtual string get_SecurityPoliciesToken();
    public sealed virtual bool get_SecurityPoliciesTokenExists();
    public sealed virtual bool get_AllowAllRequestHeaders();
    public sealed virtual bool get_CaptureAttributes();
    public sealed virtual bool get_CanUseAttributesIncludes();
    public sealed virtual string get_CanUseAttributesIncludesSource();
    public sealed virtual IEnumerable`1<string> get_CaptureAttributesIncludes();
    public sealed virtual IEnumerable`1<string> get_CaptureAttributesExcludes();
    public sealed virtual IEnumerable`1<string> get_CaptureAttributesDefaultExcludes();
    public sealed virtual bool get_TransactionEventsAttributesEnabled();
    public sealed virtual HashSet`1<string> get_TransactionEventsAttributesInclude();
    public sealed virtual HashSet`1<string> get_TransactionEventsAttributesExclude();
    public sealed virtual bool get_CaptureTransactionTraceAttributes();
    public sealed virtual IEnumerable`1<string> get_CaptureTransactionTraceAttributesIncludes();
    public sealed virtual IEnumerable`1<string> get_CaptureTransactionTraceAttributesExcludes();
    public sealed virtual bool get_CaptureErrorCollectorAttributes();
    public sealed virtual IEnumerable`1<string> get_CaptureErrorCollectorAttributesIncludes();
    public sealed virtual IEnumerable`1<string> get_CaptureErrorCollectorAttributesExcludes();
    public sealed virtual bool get_CaptureBrowserMonitoringAttributes();
    public sealed virtual IEnumerable`1<string> get_CaptureBrowserMonitoringAttributesIncludes();
    public sealed virtual IEnumerable`1<string> get_CaptureBrowserMonitoringAttributesExcludes();
    public sealed virtual bool get_CaptureCustomParameters();
    public sealed virtual string get_CaptureCustomParametersSource();
    public sealed virtual string get_CollectorHost();
    public sealed virtual int get_CollectorPort();
    public sealed virtual bool get_CollectorSendDataOnExit();
    public sealed virtual float get_CollectorSendDataOnExitThreshold();
    public sealed virtual bool get_CollectorSendEnvironmentInfo();
    public sealed virtual bool get_CollectorSyncStartup();
    public sealed virtual UInt32 get_CollectorTimeout();
    public sealed virtual int get_CollectorMaxPayloadSizeInBytes();
    public sealed virtual bool get_CompleteTransactionsOnThread();
    public sealed virtual string get_CompressedContentEncoding();
    public sealed virtual long get_ConfigurationVersion();
    public sealed virtual string get_CrossApplicationTracingCrossProcessId();
    public sealed virtual bool get_CrossApplicationTracingEnabled();
    public sealed virtual bool get_DistributedTracingEnabled();
    public sealed virtual bool get_SpanEventsEnabled();
    public sealed virtual TimeSpan get_SpanEventsHarvestCycle();
    public sealed virtual bool get_SpanEventsAttributesEnabled();
    public sealed virtual HashSet`1<string> get_SpanEventsAttributesInclude();
    public sealed virtual HashSet`1<string> get_SpanEventsAttributesExclude();
    public sealed virtual int get_InfiniteTracingTraceCountConsumers();
    public sealed virtual string get_InfiniteTracingTraceObserverHost();
    public sealed virtual string get_InfiniteTracingTraceObserverPort();
    public sealed virtual string get_InfiniteTracingTraceObserverSsl();
    public sealed virtual Nullable`1<float> get_InfiniteTracingTraceObserverTestFlaky();
    public sealed virtual Nullable`1<int> get_InfiniteTracingTraceObserverTestFlakyCode();
    public sealed virtual Nullable`1<int> get_InfiniteTracingTraceObserverTestDelayMs();
    public sealed virtual int get_InfiniteTracingQueueSizeSpans();
    public sealed virtual int get_InfiniteTracingPartitionCountSpans();
    public sealed virtual int get_InfiniteTracingBatchSizeSpans();
    public sealed virtual int get_InfiniteTracingTraceTimeoutMsConnect();
    public sealed virtual int get_InfiniteTracingTraceTimeoutMsSendData();
    public sealed virtual int get_InfiniteTracingExitTimeoutMs();
    public sealed virtual bool get_InfiniteTracingCompression();
    public sealed virtual string get_PrimaryApplicationId();
    public sealed virtual string get_TrustedAccountKey();
    public sealed virtual string get_AccountId();
    public sealed virtual bool get_DatabaseNameReportingEnabled();
    public sealed virtual bool get_DatastoreTracerQueryParametersEnabled();
    public sealed virtual bool get_ErrorCollectorEnabled();
    public sealed virtual bool get_ErrorCollectorCaptureEvents();
    public sealed virtual int get_ErrorCollectorMaxEventSamplesStored();
    public sealed virtual TimeSpan get_ErrorEventsHarvestCycle();
    public sealed virtual UInt32 get_ErrorsMaximumPerPeriod();
    public sealed virtual IEnumerable`1<string> get_ExpectedErrorClassesForAgentSettings();
    public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_ExpectedErrorMessagesForAgentSettings();
    public sealed virtual IEnumerable`1<MatchRule> get_ExpectedStatusCodes();
    public sealed virtual IEnumerable`1<string> get_ExpectedErrorStatusCodesForAgentSettings();
    public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_ExpectedErrorsConfiguration();
    public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_IgnoreErrorsConfiguration();
    public sealed virtual IEnumerable`1<string> get_IgnoreErrorClassesForAgentSettings();
    public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_IgnoreErrorMessagesForAgentSettings();
    public sealed virtual Func`2<IReadOnlyDictionary`2<string, object>, string> get_ErrorGroupCallback();
    public sealed virtual Dictionary`2<string, string> get_RequestHeadersMap();
    public sealed virtual string get_EncodingKey();
    public sealed virtual string get_EntityGuid();
    public sealed virtual bool get_HighSecurityModeEnabled();
    public sealed virtual bool get_CustomInstrumentationEditorEnabled();
    public sealed virtual string get_CustomInstrumentationEditorEnabledSource();
    public sealed virtual bool get_StripExceptionMessages();
    public sealed virtual string get_StripExceptionMessagesSource();
    public sealed virtual bool get_InstanceReportingEnabled();
    public sealed virtual bool get_InstrumentationLoggingEnabled();
    public sealed virtual string get_Labels();
    public sealed virtual IEnumerable`1<RegexRule> get_MetricNameRegexRules();
    public sealed virtual string get_NewRelicConfigFilePath();
    public sealed virtual string get_AppSettingsConfigFilePath();
    public sealed virtual string get_ProxyHost();
    public bool get_ProxyHostConfigured();
    public sealed virtual string get_ProxyUriPath();
    public bool get_ProxyUriPathConfigured();
    public sealed virtual int get_ProxyPort();
    public bool get_ProxyPortConfigured();
    public sealed virtual string get_ProxyUsername();
    public bool get_ProxyUsernameConfigured();
    public sealed virtual string get_ProxyPassword();
    public bool get_ProxyPasswordConfigured();
    public sealed virtual string get_ProxyDomain();
    public bool get_ProxyDomainConfigured();
    public sealed virtual bool get_PutForDataSend();
    public sealed virtual bool get_SlowSqlEnabled();
    public sealed virtual TimeSpan get_SqlExplainPlanThreshold();
    public sealed virtual bool get_SqlExplainPlansEnabled();
    public sealed virtual int get_SqlExplainPlansMax();
    public sealed virtual UInt32 get_SqlStatementsPerTransaction();
    public sealed virtual int get_SqlTracesPerPeriod();
    public sealed virtual int get_StackTraceMaximumFrames();
    public sealed virtual IEnumerable`1<string> get_HttpStatusCodesToIgnore();
    public sealed virtual IEnumerable`1<string> get_ThreadProfilingIgnoreMethods();
    public sealed virtual bool get_CustomEventsEnabled();
    public sealed virtual string get_CustomEventsEnabledSource();
    public sealed virtual bool get_CustomEventsAttributesEnabled();
    public sealed virtual HashSet`1<string> get_CustomEventsAttributesInclude();
    public sealed virtual HashSet`1<string> get_CustomEventsAttributesExclude();
    public sealed virtual int get_CustomEventsMaximumSamplesStored();
    public sealed virtual TimeSpan get_CustomEventsHarvestCycle();
    public sealed virtual bool get_DisableSamplers();
    public sealed virtual bool get_ThreadProfilingEnabled();
    public sealed virtual bool get_TransactionEventsEnabled();
    public sealed virtual int get_TransactionEventsMaximumSamplesStored();
    public sealed virtual TimeSpan get_TransactionEventsHarvestCycle();
    public sealed virtual bool get_TransactionEventsTransactionsEnabled();
    public sealed virtual IEnumerable`1<RegexRule> get_TransactionNameRegexRules();
    public sealed virtual IDictionary`2<string, IEnumerable`1<string>> get_TransactionNameWhitelistRules();
    public sealed virtual TimeSpan get_TransactionTraceApdexF();
    public sealed virtual TimeSpan get_TransactionTraceApdexT();
    public sealed virtual TimeSpan get_TransactionTraceThreshold();
    public sealed virtual bool get_TransactionTracerEnabled();
    public sealed virtual int get_TransactionTracerMaxSegments();
    public sealed virtual string get_TransactionTracerRecordSql();
    public sealed virtual string get_TransactionTracerRecordSqlSource();
    public sealed virtual int get_TransactionTracerMaxStackTraces();
    public sealed virtual IEnumerable`1<long> get_TrustedAccountIds();
    public sealed virtual bool get_ServerSideConfigurationEnabled();
    public sealed virtual bool get_IgnoreServerSideConfiguration();
    public sealed virtual IEnumerable`1<RegexRule> get_UrlRegexRules();
    public sealed virtual IEnumerable`1<Regex> get_RequestPathExclusionList();
    public sealed virtual IDictionary`2<string, double> get_WebTransactionsApdex();
    public sealed virtual int get_WrapperExceptionLimit();
    public sealed virtual bool get_UtilizationDetectAws();
    public sealed virtual bool get_UtilizationDetectAzure();
    public sealed virtual bool get_UtilizationDetectGcp();
    public sealed virtual bool get_UtilizationDetectPcf();
    public sealed virtual bool get_UtilizationDetectDocker();
    public sealed virtual bool get_UtilizationDetectKubernetes();
    public sealed virtual bool get_UtilizationDetectAzureFunction();
    public sealed virtual Nullable`1<int> get_UtilizationLogicalProcessors();
    public sealed virtual Nullable`1<int> get_UtilizationTotalRamMib();
    public sealed virtual string get_UtilizationBillingHost();
    public sealed virtual string get_UtilizationHostName();
    public sealed virtual string get_UtilizationFullHostName();
    public sealed virtual bool get_DiagnosticsCaptureAgentTiming();
    public sealed virtual int get_DiagnosticsCaptureAgentTimingFrequency();
    public sealed virtual bool get_UseResourceBasedNamingForWCFEnabled();
    public sealed virtual bool get_EventListenerSamplersEnabled();
    public sealed virtual void set_EventListenerSamplersEnabled(bool value);
    public sealed virtual Nullable`1<int> get_SamplingTarget();
    public sealed virtual int get_SpanEventsMaxSamplesStored();
    public sealed virtual Nullable`1<int> get_SamplingTargetPeriodInSeconds();
    public sealed virtual bool get_PayloadSuccessMetricsEnabled();
    public sealed virtual string get_ProcessHostDisplayName();
    public sealed virtual int get_DatabaseStatementCacheCapacity();
    public sealed virtual bool get_ForceSynchronousTimingCalculationHttpClient();
    public sealed virtual bool get_EnableAspNetCore6PlusBrowserInjection();
    public sealed virtual bool get_ExcludeNewrelicHeader();
    public sealed virtual bool get_ApplicationLoggingEnabled();
    public sealed virtual bool get_LogMetricsCollectorEnabled();
    public sealed virtual bool get_LogEventCollectorEnabled();
    public sealed virtual int get_LogEventsMaxSamplesStored();
    public sealed virtual HashSet`1<string> get_LogLevelDenyList();
    public sealed virtual TimeSpan get_LogEventsHarvestCycle();
    public sealed virtual bool get_LogDecoratorEnabled();
    public sealed virtual bool get_AppDomainCachingDisabled();
    public sealed virtual bool get_ForceNewTransactionOnNewThread();
    public sealed virtual bool get_CodeLevelMetricsEnabled();
    public IReadOnlyDictionary`2<string, string> get_AppSettings();
    public sealed virtual bool get_ContextDataEnabled();
    public sealed virtual IEnumerable`1<string> get_ContextDataInclude();
    public sealed virtual IEnumerable`1<string> get_ContextDataExclude();
    public sealed virtual TimeSpan get_MetricsHarvestCycle();
    public sealed virtual TimeSpan get_TransactionTracesHarvestCycle();
    public sealed virtual TimeSpan get_ErrorTracesHarvestCycle();
    public sealed virtual TimeSpan get_GetAgentCommandsCycle();
    public sealed virtual TimeSpan get_DefaultHarvestCycle();
    public sealed virtual TimeSpan get_SqlTracesHarvestCycle();
    public sealed virtual TimeSpan get_UpdateLoadedModulesCycle();
    public sealed virtual TimeSpan get_StackExchangeRedisCleanupCycle();
    public sealed virtual bool get_LoggingEnabled();
    public sealed virtual string get_LoggingLevel();
    public sealed virtual IEnumerable`1<IDictionary`2<string, string>> get_IgnoredInstrumentation();
    public sealed virtual bool get_DisableFileSystemWatcher();
    public sealed virtual bool get_AiMonitoringEnabled();
    public sealed virtual bool get_AiMonitoringStreamingEnabled();
    public sealed virtual bool get_AiMonitoringRecordContentEnabled();
    public sealed virtual Func`3<string, string, int> get_LlmTokenCountingCallback();
    public sealed virtual bool get_AzureFunctionModeDetected();
    public sealed virtual bool get_AzureFunctionModeEnabled();
    public sealed virtual string get_AzureFunctionResourceId();
    public sealed virtual string get_AzureFunctionResourceGroupName();
    public sealed virtual string get_AzureFunctionRegion();
    public sealed virtual string get_AzureFunctionSubscriptionId();
    public sealed virtual string get_AzureFunctionServiceName();
    public sealed virtual string AzureFunctionResourceIdWithFunctionName(string functionName);
    public sealed virtual IReadOnlyDictionary`2<string, string> GetAppSettings();
}
public class NewRelic.Agent.Core.Configuration.RunTimeConfiguration : object {
    public IEnumerable`1<string> ApplicationNames;
    public Func`2<IReadOnlyDictionary`2<string, object>, string> ErrorGroupCallback;
    public Func`3<string, string, int> LlmTokenCountingCallback;
    public RunTimeConfiguration(IEnumerable`1<string> applicationNames, Func`2<IReadOnlyDictionary`2<string, object>, string> errorGroupCallback, Func`3<string, string, int> llmTokenCountingCallback);
}
public class NewRelic.Agent.Core.Configuration.SecurityPoliciesConfiguration : object {
    public static string RecordSqlPolicyName;
    public static string AttributesIncludePolicyName;
    public static string AllowRawExceptionMessagePolicyName;
    public static string CustomEventsPolicyName;
    public static string CustomParametersPolicyName;
    public static string CustomInstrumentationEditorPolicyName;
    private static List`1<string> KnownPolicies;
    private Dictionary`2<string, SecurityPolicy> _policies;
    public SecurityPolicy RecordSql { get; }
    public SecurityPolicy AttributesInclude { get; }
    public SecurityPolicy AllowRawExceptionMessage { get; }
    public SecurityPolicy CustomEvents { get; }
    public SecurityPolicy CustomParameters { get; }
    public SecurityPolicy CustomInstrumentationEditor { get; }
    public SecurityPoliciesConfiguration(Dictionary`2<string, SecurityPolicyState> policies);
    private static SecurityPoliciesConfiguration();
    public SecurityPolicy get_RecordSql();
    public SecurityPolicy get_AttributesInclude();
    public SecurityPolicy get_AllowRawExceptionMessage();
    public SecurityPolicy get_CustomEvents();
    public SecurityPolicy get_CustomParameters();
    public SecurityPolicy get_CustomInstrumentationEditor();
    public bool SecurityPolicyExistsFor(string securityPolicyName);
    public static List`1<string> GetMissingExpectedSeverPolicyNames(Dictionary`2<string, SecurityPolicyState> policies);
    public static List`1<string> GetMissingRequiredPolicies(Dictionary`2<string, SecurityPolicyState> policies);
}
public class NewRelic.Agent.Core.Configuration.SecurityPoliciesValidationException : Exception {
    public SecurityPoliciesValidationException(string message);
    public SecurityPoliciesValidationException(string message, Exception innerException);
}
public class NewRelic.Agent.Core.Configuration.SecurityPolicy : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public string Name { get; private set; }
    public bool Enabled { get; private set; }
    public SecurityPolicy(string name, bool enabled);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
private void set_Enabled(bool value);
}
public class NewRelic.Agent.Core.Configuration.ServerConfiguration : object {
    [CompilerGeneratedAttribute]
private object <AgentRunId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <ApdexT>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ErrorEventCollectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AnalyticsEventCollectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SpanEventCollectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CustomEventCollectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ErrorCollectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <TraceCollectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AICollectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DataReportPeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxPayloadSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncodingKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HighSecurityEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<InstrumentationConfig> <Instrumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Message> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SamplingRate>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <WebTransactionsApdex>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<long> <TrustedIds>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <RequestHeadersMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ServerSideConfigurationEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private AgentConfig <RpmConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHarvestConfig <EventHarvestConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private SingleEventHarvestConfig <SpanEventHarvestConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CatId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrimaryApplicationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TrustedAccountKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SamplingTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SamplingTargetPeriodInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsApplicationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsBeacon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsBrowserKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsBrowserMonitoringLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsBrowserMonitoringLoaderDebug>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsBrowserMonitoringLoaderVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsEpisodesUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsEpisodesFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsErrorBeacon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsJavaScriptAgentFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsJavaScriptAgentLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsJavaScriptAgentLoaderVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RumSettingsJavaScriptErrorsBeta>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<RegexRule> <MetricNameRegexRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<RegexRule> <TransactionNameRegexRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<RegexRule> <UrlRegexRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<WhitelistRule> <TransactionNameWhitelistRules>k__BackingField;
    [JsonPropertyAttribute]
public object AgentRunId { get; public set; }
    [JsonPropertyAttribute("apdex_t")]
public Nullable`1<double> ApdexT { get; public set; }
    [JsonPropertyAttribute("collect_error_events")]
public Nullable`1<bool> ErrorEventCollectionEnabled { get; public set; }
    [JsonPropertyAttribute("collect_analytics_events")]
public Nullable`1<bool> AnalyticsEventCollectionEnabled { get; public set; }
    [JsonPropertyAttribute("collect_span_events")]
public Nullable`1<bool> SpanEventCollectionEnabled { get; public set; }
    [JsonPropertyAttribute("collect_custom_events")]
public Nullable`1<bool> CustomEventCollectionEnabled { get; public set; }
    [JsonPropertyAttribute("collect_errors")]
public Nullable`1<bool> ErrorCollectionEnabled { get; public set; }
    [JsonPropertyAttribute("collect_traces")]
public Nullable`1<bool> TraceCollectionEnabled { get; public set; }
    [JsonPropertyAttribute("collect_ai")]
public Nullable`1<bool> AICollectionEnabled { get; public set; }
    [JsonPropertyAttribute("data_report_period")]
public Nullable`1<long> DataReportPeriod { get; public set; }
    [JsonPropertyAttribute("max_payload_size_in_bytes")]
public Nullable`1<int> MaxPayloadSizeInBytes { get; public set; }
    [JsonPropertyAttribute("encoding_key")]
public string EncodingKey { get; public set; }
    [JsonPropertyAttribute("entity_guid")]
public string EntityGuid { get; public set; }
    [JsonPropertyAttribute("high_security")]
public Nullable`1<bool> HighSecurityEnabled { get; public set; }
    [JsonPropertyAttribute("instrumentation")]
public IEnumerable`1<InstrumentationConfig> Instrumentation { get; public set; }
    [JsonPropertyAttribute("messages")]
public IEnumerable`1<Message> Messages { get; public set; }
    [JsonPropertyAttribute("sampling_rate")]
public Nullable`1<int> SamplingRate { get; public set; }
    [JsonPropertyAttribute("web_transactions_apdex")]
public IDictionary`2<string, double> WebTransactionsApdex { get; public set; }
    [JsonPropertyAttribute("trusted_account_ids")]
public IEnumerable`1<long> TrustedIds { get; public set; }
    [JsonPropertyAttribute("request_headers_map")]
public Dictionary`2<string, string> RequestHeadersMap { get; public set; }
    public bool ServerSideConfigurationEnabled { get; private set; }
    [JsonPropertyAttribute("agent_config")]
public AgentConfig RpmConfig { get; public set; }
    [JsonPropertyAttribute("event_harvest_config")]
public EventHarvestConfig EventHarvestConfig { get; public set; }
    [JsonPropertyAttribute("span_event_harvest_config")]
public SingleEventHarvestConfig SpanEventHarvestConfig { get; public set; }
    [JsonPropertyAttribute("cross_process_id")]
public string CatId { get; public set; }
    [JsonPropertyAttribute("primary_application_id")]
public string PrimaryApplicationId { get; public set; }
    [JsonPropertyAttribute("trusted_account_key")]
public string TrustedAccountKey { get; public set; }
    [JsonPropertyAttribute("account_id")]
public string AccountId { get; public set; }
    [JsonPropertyAttribute("sampling_target")]
public Nullable`1<int> SamplingTarget { get; public set; }
    [JsonPropertyAttribute("sampling_target_period_in_seconds")]
public Nullable`1<int> SamplingTargetPeriodInSeconds { get; public set; }
    [JsonPropertyAttribute("application_id")]
public string RumSettingsApplicationId { get; public set; }
    [JsonPropertyAttribute("beacon")]
public string RumSettingsBeacon { get; public set; }
    [JsonPropertyAttribute("browser_key")]
public string RumSettingsBrowserKey { get; public set; }
    [JsonPropertyAttribute("browser_monitoring.loader")]
public string RumSettingsBrowserMonitoringLoader { get; public set; }
    [JsonPropertyAttribute("browser_monitoring.loader_debug")]
public string RumSettingsBrowserMonitoringLoaderDebug { get; public set; }
    [JsonPropertyAttribute("browser_monitoring.loader_version")]
public string RumSettingsBrowserMonitoringLoaderVersion { get; public set; }
    [JsonPropertyAttribute("episodes_url")]
public string RumSettingsEpisodesUrl { get; public set; }
    [JsonPropertyAttribute("episodes_file")]
public string RumSettingsEpisodesFile { get; public set; }
    [JsonPropertyAttribute("error_beacon")]
public string RumSettingsErrorBeacon { get; public set; }
    [JsonPropertyAttribute("js_agent_file")]
public string RumSettingsJavaScriptAgentFile { get; public set; }
    [JsonPropertyAttribute("js_agent_loader")]
public string RumSettingsJavaScriptAgentLoader { get; public set; }
    [JsonPropertyAttribute("js_agent_loader_version")]
public string RumSettingsJavaScriptAgentLoaderVersion { get; public set; }
    [JsonPropertyAttribute("js_errors_beta")]
public string RumSettingsJavaScriptErrorsBeta { get; public set; }
    [JsonPropertyAttribute("metric_name_rules")]
public IEnumerable`1<RegexRule> MetricNameRegexRules { get; public set; }
    [JsonPropertyAttribute("transaction_name_rules")]
public IEnumerable`1<RegexRule> TransactionNameRegexRules { get; public set; }
    [JsonPropertyAttribute("url_rules")]
public IEnumerable`1<RegexRule> UrlRegexRules { get; public set; }
    [JsonPropertyAttribute("transaction_segment_terms")]
public IEnumerable`1<WhitelistRule> TransactionNameWhitelistRules { get; public set; }
    [CompilerGeneratedAttribute]
public object get_AgentRunId();
    [CompilerGeneratedAttribute]
public void set_AgentRunId(object value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_ApdexT();
    [CompilerGeneratedAttribute]
public void set_ApdexT(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ErrorEventCollectionEnabled();
    [CompilerGeneratedAttribute]
public void set_ErrorEventCollectionEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AnalyticsEventCollectionEnabled();
    [CompilerGeneratedAttribute]
public void set_AnalyticsEventCollectionEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SpanEventCollectionEnabled();
    [CompilerGeneratedAttribute]
public void set_SpanEventCollectionEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CustomEventCollectionEnabled();
    [CompilerGeneratedAttribute]
public void set_CustomEventCollectionEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ErrorCollectionEnabled();
    [CompilerGeneratedAttribute]
public void set_ErrorCollectionEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_TraceCollectionEnabled();
    [CompilerGeneratedAttribute]
public void set_TraceCollectionEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AICollectionEnabled();
    [CompilerGeneratedAttribute]
public void set_AICollectionEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DataReportPeriod();
    [CompilerGeneratedAttribute]
public void set_DataReportPeriod(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxPayloadSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_MaxPayloadSizeInBytes(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_EncodingKey();
    [CompilerGeneratedAttribute]
public void set_EncodingKey(string value);
    [CompilerGeneratedAttribute]
public string get_EntityGuid();
    [CompilerGeneratedAttribute]
public void set_EntityGuid(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HighSecurityEnabled();
    [CompilerGeneratedAttribute]
public void set_HighSecurityEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<InstrumentationConfig> get_Instrumentation();
    [CompilerGeneratedAttribute]
public void set_Instrumentation(IEnumerable`1<InstrumentationConfig> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Message> get_Messages();
    [CompilerGeneratedAttribute]
public void set_Messages(IEnumerable`1<Message> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SamplingRate();
    [CompilerGeneratedAttribute]
public void set_SamplingRate(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_WebTransactionsApdex();
    [CompilerGeneratedAttribute]
public void set_WebTransactionsApdex(IDictionary`2<string, double> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<long> get_TrustedIds();
    [CompilerGeneratedAttribute]
public void set_TrustedIds(IEnumerable`1<long> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_RequestHeadersMap();
    [CompilerGeneratedAttribute]
public void set_RequestHeadersMap(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_ServerSideConfigurationEnabled();
    [CompilerGeneratedAttribute]
private void set_ServerSideConfigurationEnabled(bool value);
    [CompilerGeneratedAttribute]
public AgentConfig get_RpmConfig();
    [CompilerGeneratedAttribute]
public void set_RpmConfig(AgentConfig value);
    [CompilerGeneratedAttribute]
public EventHarvestConfig get_EventHarvestConfig();
    [CompilerGeneratedAttribute]
public void set_EventHarvestConfig(EventHarvestConfig value);
    [CompilerGeneratedAttribute]
public SingleEventHarvestConfig get_SpanEventHarvestConfig();
    [CompilerGeneratedAttribute]
public void set_SpanEventHarvestConfig(SingleEventHarvestConfig value);
    [CompilerGeneratedAttribute]
public string get_CatId();
    [CompilerGeneratedAttribute]
public void set_CatId(string value);
    [CompilerGeneratedAttribute]
public string get_PrimaryApplicationId();
    [CompilerGeneratedAttribute]
public void set_PrimaryApplicationId(string value);
    [CompilerGeneratedAttribute]
public string get_TrustedAccountKey();
    [CompilerGeneratedAttribute]
public void set_TrustedAccountKey(string value);
    [CompilerGeneratedAttribute]
public string get_AccountId();
    [CompilerGeneratedAttribute]
public void set_AccountId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SamplingTarget();
    [CompilerGeneratedAttribute]
public void set_SamplingTarget(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SamplingTargetPeriodInSeconds();
    [CompilerGeneratedAttribute]
public void set_SamplingTargetPeriodInSeconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsApplicationId();
    [CompilerGeneratedAttribute]
public void set_RumSettingsApplicationId(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsBeacon();
    [CompilerGeneratedAttribute]
public void set_RumSettingsBeacon(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsBrowserKey();
    [CompilerGeneratedAttribute]
public void set_RumSettingsBrowserKey(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsBrowserMonitoringLoader();
    [CompilerGeneratedAttribute]
public void set_RumSettingsBrowserMonitoringLoader(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsBrowserMonitoringLoaderDebug();
    [CompilerGeneratedAttribute]
public void set_RumSettingsBrowserMonitoringLoaderDebug(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsBrowserMonitoringLoaderVersion();
    [CompilerGeneratedAttribute]
public void set_RumSettingsBrowserMonitoringLoaderVersion(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsEpisodesUrl();
    [CompilerGeneratedAttribute]
public void set_RumSettingsEpisodesUrl(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsEpisodesFile();
    [CompilerGeneratedAttribute]
public void set_RumSettingsEpisodesFile(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsErrorBeacon();
    [CompilerGeneratedAttribute]
public void set_RumSettingsErrorBeacon(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsJavaScriptAgentFile();
    [CompilerGeneratedAttribute]
public void set_RumSettingsJavaScriptAgentFile(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsJavaScriptAgentLoader();
    [CompilerGeneratedAttribute]
public void set_RumSettingsJavaScriptAgentLoader(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsJavaScriptAgentLoaderVersion();
    [CompilerGeneratedAttribute]
public void set_RumSettingsJavaScriptAgentLoaderVersion(string value);
    [CompilerGeneratedAttribute]
public string get_RumSettingsJavaScriptErrorsBeta();
    [CompilerGeneratedAttribute]
public void set_RumSettingsJavaScriptErrorsBeta(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<RegexRule> get_MetricNameRegexRules();
    [CompilerGeneratedAttribute]
public void set_MetricNameRegexRules(IEnumerable`1<RegexRule> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<RegexRule> get_TransactionNameRegexRules();
    [CompilerGeneratedAttribute]
public void set_TransactionNameRegexRules(IEnumerable`1<RegexRule> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<RegexRule> get_UrlRegexRules();
    [CompilerGeneratedAttribute]
public void set_UrlRegexRules(IEnumerable`1<RegexRule> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<WhitelistRule> get_TransactionNameWhitelistRules();
    [CompilerGeneratedAttribute]
public void set_TransactionNameWhitelistRules(IEnumerable`1<WhitelistRule> value);
    public static ServerConfiguration GetDefault();
    public static ServerConfiguration FromJson(string json, bool ignoreServerConfiguration);
    public static bool JsonContainsNonNullProperty(string json, string propertyName);
    public static ServerConfiguration FromDeserializedReturnValue(object deserializedJson, bool ignoreServerConfiguration);
    [OnErrorAttribute]
public void OnError(StreamingContext context, ErrorContext errorContext);
}
public class NewRelic.Agent.Core.Configuration.SingleEventHarvestConfig : object {
    [CompilerGeneratedAttribute]
private int <ReportPeriodMs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HarvestLimit>k__BackingField;
    [JsonPropertyAttribute("report_period_ms")]
public int ReportPeriodMs { get; public set; }
    [JsonPropertyAttribute("harvest_limit")]
public int HarvestLimit { get; public set; }
    public Nullable`1<TimeSpan> HarvestCycle { get; }
    [CompilerGeneratedAttribute]
public int get_ReportPeriodMs();
    [CompilerGeneratedAttribute]
public void set_ReportPeriodMs(int value);
    [CompilerGeneratedAttribute]
public int get_HarvestLimit();
    [CompilerGeneratedAttribute]
public void set_HarvestLimit(int value);
    public Nullable`1<TimeSpan> get_HarvestCycle();
}
public class NewRelic.Agent.Core.Database.CacheByDatastoreVendor`2 : object {
    private int _capacity;
    private SimpleCache`2[] _caches;
    private int Capacity { get; private set; }
    public CacheByDatastoreVendor`2(string name);
    public TValue GetOrAdd(DatastoreVendor vendor, TKey key, Func`1<TValue> valueFunc);
    public void SetCapacity(int capacity);
    private int get_Capacity();
    private void set_Capacity(int value);
}
public class NewRelic.Agent.Core.Database.DatabaseService : ConfigurationBasedService {
    private SqlObfuscator _sqlObfuscator;
    private CacheByDatastoreVendor`2<string, string> _cache;
    public sealed virtual long GetSqlId(string sql, DatastoreVendor vendor);
    public sealed virtual string GetObfuscatedSql(string sql, DatastoreVendor vendor);
    private string GetObfuscatedSqlFromCache(string sql, DatastoreVendor vendor);
    private long GenerateSqlId(string sql);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
public interface NewRelic.Agent.Core.Database.IDatabaseService {
    public abstract virtual long GetSqlId(string sql, DatastoreVendor vendor);
    public abstract virtual string GetObfuscatedSql(string sql, DatastoreVendor vendor);
}
public abstract class NewRelic.Agent.Core.Database.SqlObfuscator : object {
    private static string ObfuscatedSetting;
    private static string RawSetting;
    private static string OffSetting;
    private static int SqlStatementMaxLength;
    private static SqlObfuscator ObfuscatingSqlObfuscatorInstanceUsingExplicit;
    private static SqlObfuscator RawSqlObfuscatorInstance;
    private static SqlObfuscator NoSqlObfuscatorInstance;
    private static SqlObfuscator();
    public abstract virtual string GetObfuscatedSql(string sql, DatastoreVendor vendor);
    public static SqlObfuscator GetObfuscatingSqlObfuscator();
    public static SqlObfuscator GetSqlObfuscator(string recordSqlValue);
}
public static class NewRelic.Agent.Core.DataTransport.Client.Constants : object {
    public static string EmptyResponseBody;
    public static int CompressMinimumByteLength;
    public static int ProtocolVersion;
    public static string LicenseKeyParameterName;
}
public static class NewRelic.Agent.Core.DataTransport.Client.DataTransportAuditLogger : object {
    public static string AuditLogFormat;
    private static string LicenseKeyParameterName;
    public static void Log(AuditLogDirection direction, AuditLogSource source, string uri);
}
public abstract class NewRelic.Agent.Core.DataTransport.Client.HttpClientBase : object {
    protected bool _diagnoseConnectionError;
    protected static IWebProxy _proxy;
    protected HttpClientBase(IWebProxy proxy);
    public abstract virtual IHttpResponse Send(IHttpRequest request);
    public virtual void Dispose();
    protected void DiagnoseConnectionError(string host);
    protected void TestConnection();
}
public class NewRelic.Agent.Core.DataTransport.Client.HttpRequest : object {
    private IConfiguration _configuration;
    private Uri _uri;
    [CompilerGeneratedAttribute]
private IConnectionInfo <ConnectionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpContent <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RequestGuid>k__BackingField;
    public IConnectionInfo ConnectionInfo { get; public set; }
    public string Endpoint { get; public set; }
    public Dictionary`2<string, string> Headers { get; }
    public Uri Uri { get; }
    public IHttpContent Content { get; }
    public Guid RequestGuid { get; public set; }
    public HttpRequest(IConfiguration configuration);
    [CompilerGeneratedAttribute]
public sealed virtual IConnectionInfo get_ConnectionInfo();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConnectionInfo(IConnectionInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Endpoint();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Endpoint(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Headers();
    public sealed virtual Uri get_Uri();
    [CompilerGeneratedAttribute]
public sealed virtual IHttpContent get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_RequestGuid();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequestGuid(Guid value);
    private Uri GetUri(string method, IConnectionInfo connectionInfo);
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpClient {
    public abstract virtual IHttpResponse Send(IHttpRequest request);
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpClientFactory {
    public abstract virtual IHttpClient CreateClient(IWebProxy proxy, IConfiguration configuration);
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpClientWrapper {
    public TimeSpan Timeout { get; public set; }
    public abstract virtual Task`1<IHttpResponseMessageWrapper> SendAsync(HttpRequestMessage message);
    public abstract virtual TimeSpan get_Timeout();
    public abstract virtual void set_Timeout(TimeSpan value);
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpContent {
    public string ContentType { get; public set; }
    public string SerializedData { get; public set; }
    public List`1<KeyValuePair`2<string, string>> Headers { get; }
    public Byte[] PayloadBytes { get; }
    public long UncompressedByteCount { get; }
    public bool IsCompressed { get; }
    public string CompressionType { get; }
    public string Encoding { get; }
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual string get_SerializedData();
    public abstract virtual void set_SerializedData(string value);
    public abstract virtual List`1<KeyValuePair`2<string, string>> get_Headers();
    public abstract virtual Byte[] get_PayloadBytes();
    public abstract virtual long get_UncompressedByteCount();
    public abstract virtual bool get_IsCompressed();
    public abstract virtual string get_CompressionType();
    public abstract virtual string get_Encoding();
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpContentHeadersWrapper {
    public ICollection`1<string> ContentEncoding { get; }
    public abstract virtual ICollection`1<string> get_ContentEncoding();
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpContentWrapper {
    public IHttpContentHeadersWrapper Headers { get; }
    public abstract virtual Stream ReadAsStream();
    public abstract virtual IHttpContentHeadersWrapper get_Headers();
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpRequest {
    public IConnectionInfo ConnectionInfo { get; public set; }
    public string Endpoint { get; public set; }
    public Dictionary`2<string, string> Headers { get; }
    public Uri Uri { get; }
    public IHttpContent Content { get; }
    public Guid RequestGuid { get; public set; }
    public abstract virtual IConnectionInfo get_ConnectionInfo();
    public abstract virtual void set_ConnectionInfo(IConnectionInfo value);
    public abstract virtual string get_Endpoint();
    public abstract virtual void set_Endpoint(string value);
    public abstract virtual Dictionary`2<string, string> get_Headers();
    public abstract virtual Uri get_Uri();
    public abstract virtual IHttpContent get_Content();
    public abstract virtual Guid get_RequestGuid();
    public abstract virtual void set_RequestGuid(Guid value);
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpResponse {
    public bool IsSuccessStatusCode { get; }
    public HttpStatusCode StatusCode { get; }
    public abstract virtual bool get_IsSuccessStatusCode();
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual string GetContent();
}
public interface NewRelic.Agent.Core.DataTransport.Client.Interfaces.IHttpResponseMessageWrapper {
    public IHttpContentWrapper Content { get; }
    public bool IsSuccessStatusCode { get; }
    public HttpStatusCode StatusCode { get; }
    public abstract virtual IHttpContentWrapper get_Content();
    public abstract virtual bool get_IsSuccessStatusCode();
    public abstract virtual HttpStatusCode get_StatusCode();
}
public class NewRelic.Agent.Core.DataTransport.Client.NRHttpContent : object {
    private IConfiguration _configuration;
    private CollectorRequestPayload _collectorRequestPayload;
    private bool _payloadInitialized;
    private long _uncompressedByteCount;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializedData>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, string>> <Headers>k__BackingField;
    public string ContentType { get; public set; }
    public string Encoding { get; }
    public string SerializedData { get; public set; }
    public Byte[] PayloadBytes { get; }
    public long UncompressedByteCount { get; }
    public List`1<KeyValuePair`2<string, string>> Headers { get; }
    public bool IsCompressed { get; }
    public string CompressionType { get; }
    public NRHttpContent(IConfiguration configuration);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentType(string value);
    public sealed virtual string get_Encoding();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SerializedData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SerializedData(string value);
    public sealed virtual Byte[] get_PayloadBytes();
    public sealed virtual long get_UncompressedByteCount();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<KeyValuePair`2<string, string>> get_Headers();
    public sealed virtual bool get_IsCompressed();
    public sealed virtual string get_CompressionType();
    private void InitializePayload();
    private CollectorRequestPayload GetRequestPayload(Byte[] bytes);
}
public class NewRelic.Agent.Core.DataTransport.Client.NRWebRequestClient : HttpClientBase {
    private IConfiguration _configuration;
    private HttpWebRequest _httpWebRequest;
    private Func`2<Uri, HttpWebRequest> _getHttpWebRequestFunc;
    public NRWebRequestClient(IWebProxy proxy, IConfiguration configuration);
    public virtual IHttpResponse Send(IHttpRequest request);
    public virtual void Dispose();
    public void SetHttpWebRequestFunc(Func`2<Uri, HttpWebRequest> getHttpWebRequestFunc);
}
public class NewRelic.Agent.Core.DataTransport.Client.PayloadSizeExceededException : Exception {
}
public class NewRelic.Agent.Core.DataTransport.Client.WebRequestClientResponse : object {
    private Guid _requestGuid;
    private HttpWebResponse _response;
    public bool IsSuccessStatusCode { get; }
    public HttpStatusCode StatusCode { get; }
    public WebRequestClientResponse(Guid requestGuid, HttpWebResponse response);
    public sealed virtual string GetContent();
    public sealed virtual bool get_IsSuccessStatusCode();
    public sealed virtual HttpStatusCode get_StatusCode();
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.DataTransport.Client.WebRequestHttpClientFactory : object {
    public sealed virtual IHttpClient CreateClient(IWebProxy proxy, IConfiguration configuration);
}
public class NewRelic.Agent.Core.DataTransport.CollectorRequestPayload : object {
    [CompilerGeneratedAttribute]
private bool <IsCompressed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public bool IsCompressed { get; public set; }
    public string CompressionType { get; }
    public Byte[] Data { get; }
    public CollectorRequestPayload(bool isCompressed, string compressionType, Byte[] data);
    [CompilerGeneratedAttribute]
public bool get_IsCompressed();
    [CompilerGeneratedAttribute]
public void set_IsCompressed(bool value);
    [CompilerGeneratedAttribute]
public string get_CompressionType();
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
}
public class NewRelic.Agent.Core.DataTransport.CollectorResponseEnvelope`1 : object {
    [JsonPropertyAttribute("return_value")]
public T ReturnValue;
    public CollectorResponseEnvelope`1(T returnValue);
}
public class NewRelic.Agent.Core.DataTransport.ConnectionHandler : ConfigurationBasedService {
    private static Dictionary`2<string, Action`2<string, Object[]>> ServerLogLevelMap;
    private ISerializer _serializer;
    private ICollectorWireFactory _collectorWireFactory;
    private ConnectionInfo _connectionInfo;
    private ICollectorWire _dataRequestWire;
    private IProcessStatic _processStatic;
    private IDnsStatic _dnsStatic;
    private ILabelsService _labelsService;
    private ISystemInfo _systemInfo;
    private Environment _environment;
    private IAgentHealthReporter _agentHealthReporter;
    private IEnvironment _environmentVariableHelper;
    public ConnectionHandler(ISerializer serializer, ICollectorWireFactory collectorWireFactory, IProcessStatic processStatic, IDnsStatic dnsStatic, ILabelsService labelsService, Environment environment, ISystemInfo systemInfo, IAgentHealthReporter agentHealthReporter, IEnvironment environmentVariableHelper);
    private static ConnectionHandler();
    public sealed virtual void Connect();
    private void LogTlsConfiguration();
    private void GenerateSpanEventsHarvestLimitMetrics(SingleEventHarvestConfig spanEventHarvestConfig);
    private void LogSecurityPolicySettingsOnceAllSettingsResolved();
    public sealed virtual void Disconnect();
    public sealed virtual T SendDataRequest(string method, Object[] data);
    private PreconnectResult SendPreconnectRequest();
    private static void ValidateNotBothHsmAndSecurityPolicies(IConfiguration configuration);
    private static void ValidateAgentExpectedSecurityPoliciesExist(Dictionary`2<string, SecurityPolicyState> securityPoliciesFromServer);
    private static void ValidateAllRequiredPoliciesFromServerExist(Dictionary`2<string, SecurityPolicyState> securityPoliciesFromServer);
    private void ValidateAgentTokenSettingToPoliciesReceived(Dictionary`2<string, SecurityPolicyState> securityPoliciesFromServer);
    private ServerConfiguration SendConnectRequest();
    private void LogConfigurationMessages(ServerConfiguration serverConfiguration);
    private ConnectModel GetConnectParameters();
    private string GetIdentifier();
    private void SendAgentSettings();
    private void GenerateFasterEventHarvestConfigMetrics(EventHarvestConfig eventHarvestConfig);
    private bool GenerateHarvestLimitMetricIfAvailable(string metricName, Nullable`1<int> harvestLimit);
    private void SendShutdownCommand();
    private void Disable();
    private T SendNonDataRequest(string method, Object[] data);
    private T SendDataOverWire(ICollectorWire wire, string method, Object[] data);
    private T ParseResponse(string responseBody);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    public virtual void Dispose();
}
public class NewRelic.Agent.Core.DataTransport.ConnectionInfo : object {
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpProtocol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyUriPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProxyPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private WebProxy <Proxy>k__BackingField;
    private static Regex accountRegionRegex;
    public string Host { get; }
    public int Port { get; }
    public string HttpProtocol { get; }
    public string ProxyHost { get; }
    public string ProxyUriPath { get; }
    public int ProxyPort { get; }
    public string ProxyUsername { get; }
    public string ProxyPassword { get; }
    public string ProxyDomain { get; }
    public WebProxy Proxy { get; }
    public ConnectionInfo(IConfiguration configuration);
    public ConnectionInfo(IConfiguration configuration, string redirectHost);
    private static ConnectionInfo();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Host();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Port();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HttpProtocol();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProxyHost();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProxyUriPath();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ProxyPort();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProxyUsername();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProxyPassword();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProxyDomain();
    [CompilerGeneratedAttribute]
public sealed virtual WebProxy get_Proxy();
    private static string GetCollectorHost(IConfiguration configuration);
    private static WebProxy GetWebProxy(string proxyHost, string proxyUriPath, int proxyPort, string proxyUsername, string proxyPassword, string proxyDomain);
    public virtual string ToString();
    private string GetProxyAddress();
    private string GetProxyHostWithoutCredentials(string proxyHost);
}
public class NewRelic.Agent.Core.DataTransport.ConnectionManager : ConfigurationBasedService {
    private static TimeSpan[] ConnectionRetryBackoffSequence;
    private IConnectionHandler _connectionHandler;
    private IScheduler _scheduler;
    private int _connectionAttempt;
    private bool _started;
    private object _syncObject;
    private bool _runtimeConfigurationUpdated;
    public ConnectionManager(IConnectionHandler connectionHandler, IScheduler scheduler);
    private static ConnectionManager();
    public sealed virtual void AttemptAutoStart();
    private void Start();
    private void Connect();
    private void Disconnect();
    private void Reconnect();
    public sealed virtual T SendDataRequest(string method, Object[] data);
    private static void ImmediateShutdown(string message);
    private void ScheduleRestart();
    private void HandleHttpErrorResponse(HttpException ex);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void OnStartAgent(StartAgentEvent eventData);
    private void OnRestartAgent(RestartAgentEvent eventData);
    private void OnCleanShutdown(CleanShutdownEvent eventData);
}
public class NewRelic.Agent.Core.DataTransport.ConnectModel : object {
    [JsonPropertyAttribute("pid")]
public int ProcessId;
    [JsonPropertyAttribute("language")]
public string Language;
    [JsonPropertyAttribute("display_host")]
public string DisplayHost;
    [JsonPropertyAttribute("host")]
public string HostName;
    [JsonPropertyAttribute("app_name")]
public IEnumerable`1<string> AppNames;
    [JsonPropertyAttribute("agent_version")]
public string AgentVersion;
    [JsonPropertyAttribute("agent_version_timestamp")]
public long AgentVersionTimestamp;
    [JsonPropertyAttribute("security_settings")]
public SecuritySettingsModel SecuritySettings;
    [JsonPropertyAttribute("high_security")]
public bool HighSecurityModeEnabled;
    [JsonPropertyAttribute("event_harvest_config")]
public EventHarvestConfigModel EventHarvestConfig;
    [JsonPropertyAttribute("identifier")]
public string Identifier;
    [JsonPropertyAttribute("labels")]
public IEnumerable`1<Label> Labels;
    [JsonPropertyAttribute("settings")]
public ReportedConfiguration Configuration;
    [JsonPropertyAttribute("metadata")]
public Dictionary`2<string, string> Metadata;
    [JsonPropertyAttribute("utilization")]
public UtilizationSettingsModel UtilizationSettings;
    [JsonPropertyAttribute("environment")]
public Environment Environment;
    [JsonPropertyAttribute("security_policies")]
public SecurityPoliciesSettingsModel SecurityPoliciesSettings;
    public ConnectModel(int processId, string language, string displayHost, string hostName, IEnumerable`1<string> appNames, string agentVersion, long agentVersionTimestamp, SecuritySettingsModel securitySettings, bool highSecurityModeEnabled, string identifier, IEnumerable`1<Label> labels, Dictionary`2<string, string> metadata, UtilizationSettingsModel utilizationSettings, Environment environment, SecurityPoliciesSettingsModel securityPoliciesSettings, EventHarvestConfigModel eventHarvestConfig, ReportedConfiguration configuration);
}
public static class NewRelic.Agent.Core.DataTransport.DataCompressor : object {
    public static string DeflateCompression;
    public static string GzipCompression;
    public static Byte[] Compress(string data);
    public static Byte[] Compress(Byte[] bytes);
    public static Byte[] Compress(Byte[] bytes, string compressionType);
    private static DeflaterOutputStream GetCompressionOutputStream(Stream stream, string requestedCompression);
    public static string Decompress(Byte[] compressedBytes);
}
public abstract class NewRelic.Agent.Core.DataTransport.DataStreamingService`3 : object {
    private static string UnimplementedStatus;
    private static string UnavailableStatus;
    private static string FailedPreconditionStatus;
    private static string InternalStatus;
    private static string OkStatus;
    private IGrpcWrapper`2<TRequestBatch, TResponse> _grpcWrapper;
    private IDelayer _delayer;
    protected IAgentHealthReporter _agentHealthReporter;
    private IAgentTimerService _agentTimerService;
    private IEnvironment _environment;
    private static string LicenseKeyHeaderName;
    private IConfigurationService _configSvc;
    private bool _hasAnyStreamStarted;
    [CompilerGeneratedAttribute]
private bool <IsStreaming>k__BackingField;
    private string _modelType;
    private string _timerEventNameForSend;
    private string _timerEventNameForChannel;
    private string _timerEventNameForStream;
    private static int _delayBetweenRpcCallsMs;
    private Int32[] _backoffDelaySequenceConnectMs;
    [CompilerGeneratedAttribute]
private int <TimeoutConnectMs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeoutSendDataMs>k__BackingField;
    private Nullable`1<bool> _isConfigurationValid;
    private InterlockedCounter _consumerId;
    private InterlockedCounter _workCounter;
    protected Metadata _metadataHeaders;
    private CancellationTokenSource _cancellationTokenSource;
    [CompilerGeneratedAttribute]
private string <EndpointHost>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndpointPort>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EndpointSsl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <EndpointTestFlaky>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <EndpointTestFlakyCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <EndpointTestDelayMs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompressionEnabled>k__BackingField;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _shouldRestart;
    private Nullable`1<bool> _isServiceEnabled;
    private PartitionedBlockingCollection`1<TRequest> _collection;
    private ConcurrentDictionary`2<int, ResponseStreamWrapper`1<TResponse>> _responseStreamsDic;
    private static TimeSpan _responseStreamResponseInterval;
    protected IConfiguration _configuration { get; }
    public bool IsStreaming { get; private set; }
    public int TimeoutConnectMs { get; private set; }
    public int TimeoutSendDataMs { get; private set; }
    protected bool IsConfigurationValid { get; }
    protected Metadata MetadataHeaders { get; }
    protected CancellationToken CancellationToken { get; }
    public string EndpointHost { get; private set; }
    public int EndpointPort { get; private set; }
    public bool EndpointSsl { get; private set; }
    public Nullable`1<float> EndpointTestFlaky { get; private set; }
    public Nullable`1<int> EndpointTestFlakyCode { get; private set; }
    public Nullable`1<int> EndpointTestDelayMs { get; private set; }
    public int BatchSizeConfigValue { get; }
    public bool CompressionEnabled { get; private set; }
    protected string EndpointHostConfigValue { get; }
    protected string EndpointPortConfigValue { get; }
    protected string EndpointSslConfigValue { get; }
    protected Nullable`1<float> EndpointTestFlakyConfigValue { get; }
    protected Nullable`1<int> EndpointTestFlakyCodeConfigValue { get; }
    protected Nullable`1<int> EndpointTestDelayMsConfigValue { get; }
    public bool IsServiceEnabled { get; }
    public bool IsServiceAvailable { get; }
    protected DataStreamingService`3(IGrpcWrapper`2<TRequestBatch, TResponse> grpcWrapper, IDelayer delayer, IConfigurationService configSvc, IAgentHealthReporter agentHealthReporter, IAgentTimerService agentTimerService, IEnvironment environment);
    private static DataStreamingService`3();
    protected IConfiguration get__configuration();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStreaming();
    [CompilerGeneratedAttribute]
private void set_IsStreaming(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TimeoutConnectMs();
    [CompilerGeneratedAttribute]
private void set_TimeoutConnectMs(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TimeoutSendDataMs();
    [CompilerGeneratedAttribute]
private void set_TimeoutSendDataMs(int value);
    protected bool get_IsConfigurationValid();
    protected Metadata get_MetadataHeaders();
    private Metadata CreateMetadataHeaders();
    protected CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointHost();
    [CompilerGeneratedAttribute]
private void set_EndpointHost(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndpointPort();
    [CompilerGeneratedAttribute]
private void set_EndpointPort(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EndpointSsl();
    [CompilerGeneratedAttribute]
private void set_EndpointSsl(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<float> get_EndpointTestFlaky();
    [CompilerGeneratedAttribute]
private void set_EndpointTestFlaky(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_EndpointTestFlakyCode();
    [CompilerGeneratedAttribute]
private void set_EndpointTestFlakyCode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_EndpointTestDelayMs();
    [CompilerGeneratedAttribute]
private void set_EndpointTestDelayMs(Nullable`1<int> value);
    public abstract virtual int get_BatchSizeConfigValue();
    [CompilerGeneratedAttribute]
public bool get_CompressionEnabled();
    [CompilerGeneratedAttribute]
private void set_CompressionEnabled(bool value);
    protected abstract virtual string get_EndpointHostConfigValue();
    protected abstract virtual string get_EndpointPortConfigValue();
    protected abstract virtual string get_EndpointSslConfigValue();
    protected abstract virtual Nullable`1<float> get_EndpointTestFlakyConfigValue();
    protected abstract virtual Nullable`1<int> get_EndpointTestFlakyCodeConfigValue();
    protected abstract virtual Nullable`1<int> get_EndpointTestDelayMsConfigValue();
    protected abstract virtual void HandleServerResponse(TResponse responseModel, int consumerId);
    protected abstract virtual void RecordSuccessfulSend(int countItems);
    protected abstract virtual void RecordGrpcError(string status);
    protected abstract virtual void RecordResponseError();
    protected abstract virtual void RecordSendTimeout();
    public sealed virtual bool get_IsServiceEnabled();
    public sealed virtual bool get_IsServiceAvailable();
    public sealed virtual bool ReadAndValidateConfiguration();
    private void CheckForLegacyProxyAndDisplayWarning();
    private void Restart(PartitionedBlockingCollection`1<TRequest> collection);
    private void ManageResponseStreams(CancellationToken serviceCancellationToken);
    private void StartConsumers();
    private bool StartService();
    private void LogConfigurationSettings();
    private bool CreateChannel(CancellationToken cancellationToken);
    private string GetIpAddressFromHostname(string endpointHost);
    public sealed virtual void Dispose();
    public sealed virtual void Shutdown(bool withRestart);
    private bool GetRequestStreamWithRetry(int consumerId, CancellationToken cancellationToken, IClientStreamWriter`1& requestStream, IAsyncStreamReader`1& responseStream);
    public sealed virtual void Wait(int millisecondsTimeout);
    public sealed virtual void StartConsumingCollection(PartitionedBlockingCollection`1<TRequest> collection);
    private void ExecuteConsumer(PartitionedBlockingCollection`1<TRequest> collection);
    private bool DequeueItems(PartitionedBlockingCollection`1<TRequest> collection, int maxBatchSize, CancellationToken cancellationToken, IList`1& items);
    protected abstract virtual TRequestBatch CreateBatch(IList`1<TRequest> items);
    private void ProcessFailedItems(IList`1<TRequest> items, PartitionedBlockingCollection`1<TRequest> collection);
    private bool StreamRequests(PartitionedBlockingCollection`1<TRequest> collection, CancellationToken serviceCancellationToken);
    private TrySendStatus<TRequest, TRequestBatch, TResponse> TrySend(int consumerId, IClientStreamWriter`1<TRequestBatch> requestStream, IList`1<TRequest> items, CancellationToken cancellationToken);
    protected void LogMessage(LogLevel level, string message, Exception ex);
    protected void LogMessage(LogLevel level, int consumerId, string message, Exception ex);
    protected void LogMessage(LogLevel level, int consumerId, TRequest item, string message, Exception ex);
    [CompilerGeneratedAttribute]
private void <StartConsumers>b__106_0();
    [CompilerGeneratedAttribute]
private void <StartConsumers>b__106_1();
    [AsyncStateMachineAttribute("NewRelic.Agent.Core.DataTransport.DataStreamingService`3/<<Wait>b__114_0>d")]
[CompilerGeneratedAttribute]
private Task <Wait>b__114_0();
}
public class NewRelic.Agent.Core.DataTransport.DataTransportResponse`1 : ValueType {
    public DataTransportResponseStatus Status;
    public T ReturnValue;
    public DataTransportResponse`1(DataTransportResponseStatus status, T returnValue);
}
public enum NewRelic.Agent.Core.DataTransport.DataTransportResponseStatus : Enum {
    public int value__;
    public static DataTransportResponseStatus RequestSuccessful;
    public static DataTransportResponseStatus Retain;
    public static DataTransportResponseStatus ReduceSizeIfPossibleOtherwiseDiscard;
    public static DataTransportResponseStatus Discard;
}
public class NewRelic.Agent.Core.DataTransport.DataTransportService : ConfigurationBasedService {
    private IConnectionManager _connectionManager;
    private IDateTimeStatic _dateTimeStatic;
    private DateTime _lastMetricSendTime;
    private IAgentHealthReporter _agentHealthReporter;
    public DataTransportService(IConnectionManager connectionManager, IDateTimeStatic dateTimeStatic, IAgentHealthReporter agentHealthReporter);
    public sealed virtual IEnumerable`1<CommandModel> GetAgentCommands();
    public sealed virtual void SendCommandResults(IDictionary`2<string, object> commandResults);
    public sealed virtual void SendThreadProfilingData(IEnumerable`1<ThreadProfilingModel> threadProfilingData);
    public sealed virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<TransactionEventWireModel> transactionEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<ErrorEventWireModel> errorEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<ISpanEventWireModel> spanEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<CustomEventWireModel> customEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<TransactionTraceWireModel> transactionSampleDatas, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<ErrorTraceWireModel> errorTraceDatas, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<SqlTraceWireModel> sqlTraceWireModels, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(LogEventWireModelCollection loggingEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<MetricWireModel> metrics, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(LoadedModuleWireModelCollection loadedModules, string transactionId);
    private DataTransportResponseStatus TrySendDataRequest(string method, Object[] data);
    private DataTransportResponse`1<T> TrySendDataRequest(string method, Object[] data);
    private static void RestartOrShutdownIfNecessary(HttpException ex);
    private static void Shutdown(string message);
    private static void Restart();
    private void LogErrorResponse(Exception exception, string method, DateTime startTime, Nullable`1<HttpStatusCode> httpStatusCode);
    private DataTransportResponseStatus GetDataTransportResponseStatusByHttpStatusCode(HttpStatusCode httpStatusCode);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
public class NewRelic.Agent.Core.DataTransport.Delayer : object {
    public sealed virtual void Delay(int milliseconds, CancellationToken token);
}
public class NewRelic.Agent.Core.DataTransport.EventHarvestConfigModel : object {
    [JsonPropertyAttribute("harvest_limits")]
public Dictionary`2<string, int> HarvestLimits;
    public EventHarvestConfigModel(IConfiguration configuration);
}
public abstract class NewRelic.Agent.Core.DataTransport.GrpcWrapper`2 : object {
    [CompilerGeneratedAttribute]
private Channel <_channel>k__BackingField;
    private List`1<ChannelState> _notConnectedStates;
    private Channel _channel { get; private set; }
    public bool IsConnected { get; }
    [CompilerGeneratedAttribute]
private Channel get__channel();
    [CompilerGeneratedAttribute]
private void set__channel(Channel value);
    public sealed virtual bool get_IsConnected();
    protected abstract virtual AsyncDuplexStreamingCall`2<TRequest, TResponse> CreateStreamsImpl(Channel channel, Metadata headers, int connectTimeoutMs, CancellationToken cancellationToken);
    public sealed virtual bool CreateChannel(string host, int port, bool ssl, Metadata headers, int connectTimeoutMs, CancellationToken cancellationToken);
    protected virtual bool TestConnect(Channel channel, int connectTimeoutMs, CancellationToken cancellationToken);
    private bool TestChannel(Channel channel, Metadata headers, int connectTimeoutMs, CancellationToken cancellationToken);
    public sealed virtual bool CreateStreams(Metadata headers, int connectTimeoutMs, CancellationToken cancellationToken, IClientStreamWriter`1& requestStream, IAsyncStreamReader`1& responseStream);
    public sealed virtual bool TrySendData(IClientStreamWriter`1<TRequest> requestStream, TRequest item, int sendTimeoutMs, CancellationToken cancellationToken);
    public sealed virtual void Shutdown();
    public sealed virtual void TryCloseRequestStream(IClientStreamWriter`1<TRequest> requestStream);
}
public class NewRelic.Agent.Core.DataTransport.GrpcWrapperChannelNotAvailableException : Exception {
    public GrpcWrapperChannelNotAvailableException(string message);
    public GrpcWrapperChannelNotAvailableException(string message, Exception innerException);
}
public class NewRelic.Agent.Core.DataTransport.GrpcWrapperException : Exception {
    public string Status;
    public GrpcWrapperException(string message, Exception innerException);
    public GrpcWrapperException(StatusCode statusCode, string message, Exception innerException);
}
public class NewRelic.Agent.Core.DataTransport.GrpcWrapperStreamNotAvailableException : Exception {
    public GrpcWrapperStreamNotAvailableException(string message, Exception innerException);
}
public class NewRelic.Agent.Core.DataTransport.HttpCollectorWire : object {
    private IHttpClientFactory _httpClientFactory;
    private IConfiguration _configuration;
    private Dictionary`2<string, string> _requestHeadersMap;
    private static Dictionary`2<string, string> _emptyRequestHeadersMap;
    private IAgentHealthReporter _agentHealthReporter;
    public HttpCollectorWire(IConfiguration configuration, IAgentHealthReporter agentHealthReporter, IHttpClientFactory httpClientFactory);
    public HttpCollectorWire(IConfiguration configuration, Dictionary`2<string, string> requestHeadersMap, IAgentHealthReporter agentHealthReporter, IHttpClientFactory httpClientFactory);
    private static HttpCollectorWire();
    public sealed virtual string SendData(string method, ConnectionInfo connectionInfo, string serializedData, Guid requestGuid);
    private static void ThrowExceptionFromHttpResponseMessage(string serializedData, HttpStatusCode statusCode, string responseText, Guid requestGuid);
}
public class NewRelic.Agent.Core.DataTransport.HttpCollectorWireFactory : object {
    private IHttpClientFactory _httpClientFactory;
    public HttpCollectorWireFactory(IHttpClientFactory httpClientFactory);
    public sealed virtual ICollectorWire GetCollectorWire(IConfiguration configuration, IAgentHealthReporter agentHealthReporter);
    public sealed virtual ICollectorWire GetCollectorWire(IConfiguration configuration, Dictionary`2<string, string> requestHeadersMap, IAgentHealthReporter agentHealthReporter);
}
public class NewRelic.Agent.Core.DataTransport.HttpException : Exception {
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    public HttpStatusCode StatusCode { get; }
    public HttpException(HttpStatusCode statusCode, string message);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
}
public interface NewRelic.Agent.Core.DataTransport.ICollectorWire {
    public abstract virtual string SendData(string method, ConnectionInfo connectionInfo, string serializedData, Guid requestGuid);
}
public interface NewRelic.Agent.Core.DataTransport.ICollectorWireFactory {
    public abstract virtual ICollectorWire GetCollectorWire(IConfiguration configuration, IAgentHealthReporter agentHealthReporter);
    public abstract virtual ICollectorWire GetCollectorWire(IConfiguration configuration, Dictionary`2<string, string> requestHeadersMap, IAgentHealthReporter agentHealthReporter);
}
public interface NewRelic.Agent.Core.DataTransport.IConnectionHandler {
    public abstract virtual void Connect();
    public abstract virtual void Disconnect();
    public abstract virtual T SendDataRequest(string method, Object[] data);
}
public interface NewRelic.Agent.Core.DataTransport.IConnectionInfo {
    public string Host { get; }
    public int Port { get; }
    public string HttpProtocol { get; }
    public string ProxyHost { get; }
    public string ProxyUriPath { get; }
    public int ProxyPort { get; }
    public string ProxyUsername { get; }
    public string ProxyPassword { get; }
    public string ProxyDomain { get; }
    public WebProxy Proxy { get; }
    public abstract virtual string get_Host();
    public abstract virtual int get_Port();
    public abstract virtual string get_HttpProtocol();
    public abstract virtual string get_ProxyHost();
    public abstract virtual string get_ProxyUriPath();
    public abstract virtual int get_ProxyPort();
    public abstract virtual string get_ProxyUsername();
    public abstract virtual string get_ProxyPassword();
    public abstract virtual string get_ProxyDomain();
    public abstract virtual WebProxy get_Proxy();
}
public interface NewRelic.Agent.Core.DataTransport.IConnectionManager {
    public abstract virtual T SendDataRequest(string method, Object[] data);
    public abstract virtual void AttemptAutoStart();
}
public interface NewRelic.Agent.Core.DataTransport.IDataStreamingService`3 {
    public bool IsServiceAvailable { get; }
    public bool IsServiceEnabled { get; }
    public bool IsStreaming { get; }
    public string EndpointHost { get; }
    public int EndpointPort { get; }
    public bool EndpointSsl { get; }
    public int BatchSizeConfigValue { get; }
    public Nullable`1<float> EndpointTestFlaky { get; }
    public Nullable`1<int> EndpointTestDelayMs { get; }
    public int TimeoutConnectMs { get; }
    public int TimeoutSendDataMs { get; }
    public abstract virtual bool get_IsServiceAvailable();
    public abstract virtual bool get_IsServiceEnabled();
    public abstract virtual bool get_IsStreaming();
    public abstract virtual string get_EndpointHost();
    public abstract virtual int get_EndpointPort();
    public abstract virtual bool get_EndpointSsl();
    public abstract virtual int get_BatchSizeConfigValue();
    public abstract virtual Nullable`1<float> get_EndpointTestFlaky();
    public abstract virtual Nullable`1<int> get_EndpointTestDelayMs();
    public abstract virtual int get_TimeoutConnectMs();
    public abstract virtual int get_TimeoutSendDataMs();
    public abstract virtual void Shutdown(bool withRestart);
    public abstract virtual void StartConsumingCollection(PartitionedBlockingCollection`1<TRequest> collection);
    public abstract virtual void Wait(int millisecondsTimeout);
    public abstract virtual bool ReadAndValidateConfiguration();
}
public interface NewRelic.Agent.Core.DataTransport.IDataTransportService {
    public abstract virtual IEnumerable`1<CommandModel> GetAgentCommands();
    public abstract virtual void SendCommandResults(IDictionary`2<string, object> commandResults);
    public abstract virtual void SendThreadProfilingData(IEnumerable`1<ThreadProfilingModel> threadProfilingData);
    public abstract virtual DataTransportResponseStatus Send(IEnumerable`1<TransactionTraceWireModel> transactionSampleDatas, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(IEnumerable`1<ErrorTraceWireModel> errorTraceDatas, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(IEnumerable`1<MetricWireModel> metrics, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<TransactionEventWireModel> transactionEvents, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<ErrorEventWireModel> errorEvents, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<ISpanEventWireModel> enumerable, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(IEnumerable`1<SqlTraceWireModel> sqlTraceWireModels, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(IEnumerable`1<CustomEventWireModel> customEvents, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(LogEventWireModelCollection loggingEvents, string transactionId);
    public abstract virtual DataTransportResponseStatus Send(LoadedModuleWireModelCollection loadedModules, string transactionId);
}
public interface NewRelic.Agent.Core.DataTransport.IDelayer {
    public abstract virtual void Delay(int milliseconds, CancellationToken token);
}
public interface NewRelic.Agent.Core.DataTransport.IGrpcWrapper`2 {
    public bool IsConnected { get; }
    public abstract virtual bool get_IsConnected();
    public abstract virtual bool CreateChannel(string host, int port, bool ssl, Metadata headers, int connectTimeoutMs, CancellationToken cancellationToken);
    public abstract virtual bool CreateStreams(Metadata headers, int connectTimeoutMs, CancellationToken cancellationToken, IClientStreamWriter`1& requestStream, IAsyncStreamReader`1& responseStream);
    public abstract virtual bool TrySendData(IClientStreamWriter`1<TRequest> stream, TRequest item, int sendTimeoutMs, CancellationToken cancellationToken);
    public abstract virtual void TryCloseRequestStream(IClientStreamWriter`1<TRequest> requestStream);
    public abstract virtual void Shutdown();
}
public interface NewRelic.Agent.Core.DataTransport.ISerializer {
    public abstract virtual string Serialize(Object[] parameters);
    public abstract virtual T Deserialize(string responseBody);
}
public interface NewRelic.Agent.Core.DataTransport.IServerlessModeDataTransportService {
    public abstract virtual bool FlushData(string transactionId);
}
public interface NewRelic.Agent.Core.DataTransport.IServerlessModePayloadManager {
    public abstract virtual void WritePayload(string jsonPayload, string outputPath);
    public abstract virtual string BuildPayload(WireData data);
}
public interface NewRelic.Agent.Core.DataTransport.IStreamingBatchModel`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public interface NewRelic.Agent.Core.DataTransport.IStreamingModel {
    public string DisplayName { get; }
    public abstract virtual string get_DisplayName();
}
public class NewRelic.Agent.Core.DataTransport.JsonSerializer : object {
    public sealed virtual string Serialize(Object[] parameters);
    public sealed virtual T Deserialize(string responseBody);
}
public class NewRelic.Agent.Core.DataTransport.NoOpCollectorWire : object {
    public sealed virtual string SendData(string method, ConnectionInfo connectionInfo, string serializedData, Guid requestGuid);
}
public class NewRelic.Agent.Core.DataTransport.PreconnectResult : object {
    [CompilerGeneratedAttribute]
private string <RedirectHost>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SecurityPolicyState> <SecurityPolicies>k__BackingField;
    [JsonPropertyAttribute("redirect_host")]
public string RedirectHost { get; public set; }
    [JsonPropertyAttribute("security_policies")]
public Dictionary`2<string, SecurityPolicyState> SecurityPolicies { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RedirectHost();
    [CompilerGeneratedAttribute]
public void set_RedirectHost(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SecurityPolicyState> get_SecurityPolicies();
    [CompilerGeneratedAttribute]
public void set_SecurityPolicies(Dictionary`2<string, SecurityPolicyState> value);
}
public class NewRelic.Agent.Core.DataTransport.ResponseStreamWrapper`1 : object {
    private static string NoStatusMessage;
    public int ConsumerID;
    private bool _isInvalid;
    public RpcException ResponseRpcException;
    private IAsyncStreamReader`1<TResponse> _responseStream;
    private CancellationToken _streamCancellationToken;
    private IAgentHealthReporter _healthReporter;
    private Task`1<int> _task;
    public bool IsInvalid { get; }
    public ResponseStreamWrapper`1(int consumerID, IAsyncStreamReader`1<TResponse> responseStream, CancellationToken streamCancellationToken, IAgentHealthReporter agentHealthReporter);
    public bool get_IsInvalid();
    [AsyncStateMachineAttribute("NewRelic.Agent.Core.DataTransport.ResponseStreamWrapper`1/<WaitForResponse>d__11")]
private Task`1<int> WaitForResponse();
    public Task`1<int> GetAwaiter();
    public TResponse RetrieveResponse();
}
public class NewRelic.Agent.Core.DataTransport.SecurityPoliciesSettingsModel : object {
    [JsonPropertyAttribute("record_sql")]
public Dictionary`2<string, bool> RecordSql;
    [JsonPropertyAttribute("attributes_include")]
public Dictionary`2<string, bool> AttributesInclude;
    [JsonPropertyAttribute("allow_raw_exception_messages")]
public Dictionary`2<string, bool> AllowRawExceptionMessages;
    [JsonPropertyAttribute("custom_events")]
public Dictionary`2<string, bool> CustomEvents;
    [JsonPropertyAttribute("custom_parameters")]
public Dictionary`2<string, bool> CustomParameters;
    [JsonPropertyAttribute("custom_instrumentation_editor")]
public Dictionary`2<string, bool> CustomInstrumentationEditor;
    public SecurityPoliciesSettingsModel(IConfiguration configuration);
}
public class NewRelic.Agent.Core.DataTransport.SecurityPolicyState : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [JsonPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    [JsonPropertyAttribute("required")]
public bool Required { get; public set; }
    public SecurityPolicyState(bool enabled, bool required);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    public virtual string ToString();
}
public class NewRelic.Agent.Core.DataTransport.SecuritySettingsModel : object {
    [JsonPropertyAttribute("transaction_tracer")]
public TransactionTraceSettingsModel TransactionTraceSettings;
    public SecuritySettingsModel(TransactionTraceSettingsModel transactionTraceSettings);
}
public class NewRelic.Agent.Core.DataTransport.ServerlessModeDataTransportService : ConfigurationBasedService {
    private TransactionWireData _transactionWireData;
    private IDateTimeStatic _dateTimeStatic;
    private IServerlessModePayloadManager _serverlessModePayloadManager;
    private DateTime _lastMetricSendTime;
    private string _outputPath;
    public ServerlessModeDataTransportService(IDateTimeStatic dateTimeStatic, IServerlessModePayloadManager serverlessModePayloadManager);
    private void OnFlushServerlessDataEvent(FlushServerlessDataEvent flushServerlessDataEvent);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void Enqueue(string transactionId, string type, Object[] data);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<TransactionTraceWireModel> transactionSampleDatas, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<ErrorTraceWireModel> errorTraceDatas, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<MetricWireModel> metrics, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<TransactionEventWireModel> transactionEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<ErrorEventWireModel> errorEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(EventHarvestData eventHarvestData, IEnumerable`1<ISpanEventWireModel> spanEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<SqlTraceWireModel> sqlTraceWireModels, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(IEnumerable`1<CustomEventWireModel> customEvents, string transactionId);
    public sealed virtual IEnumerable`1<CommandModel> GetAgentCommands();
    public sealed virtual void SendCommandResults(IDictionary`2<string, object> commandResults);
    public sealed virtual void SendThreadProfilingData(IEnumerable`1<ThreadProfilingModel> threadProfilingData);
    public sealed virtual DataTransportResponseStatus Send(LogEventWireModelCollection loggingEvents, string transactionId);
    public sealed virtual DataTransportResponseStatus Send(LoadedModuleWireModelCollection loadedModules, string transactionId);
    public sealed virtual bool FlushData(string transactionId);
    public static void SetMetadata(string functionVersion, string arn);
}
public class NewRelic.Agent.Core.DataTransport.ServerlessModePayloadManager : object {
    private IFileWrapper _fileWrapper;
    private IEnvironment _environment;
    private object _writeLock;
    private static IDictionary`2<string, object> _metadata;
    private static string _functionVersion;
    private static string _arn;
    public ServerlessModePayloadManager(IFileWrapper fileWrapper, IEnvironment environment);
    public sealed virtual void WritePayload(string payloadJson, string path);
    public sealed virtual string BuildPayload(WireData eventsToFlush);
    private Dictionary`2<string, object> GetCompressiblePayload(WireData eventsToFlush);
    private string CompressAndEncode(string compressiblePayload);
    private void InitializeMetadata();
    private static IDictionary`2<string, object> GetMetadata();
    public static void SetMetadata(string functionVersion, string arn);
}
public class NewRelic.Agent.Core.DataTransport.SpanBatchGrpcWrapper : GrpcWrapper`2<SpanBatch, RecordStatus> {
    protected virtual AsyncDuplexStreamingCall`2<SpanBatch, RecordStatus> CreateStreamsImpl(Channel channel, Metadata headers, int connectTimeoutMs, CancellationToken cancellationToken);
}
public class NewRelic.Agent.Core.DataTransport.SpanGrpcWrapper : GrpcWrapper`2<Span, RecordStatus> {
    protected virtual AsyncDuplexStreamingCall`2<Span, RecordStatus> CreateStreamsImpl(Channel channel, Metadata headers, int connectTimeoutMs, CancellationToken cancellationToken);
}
public class NewRelic.Agent.Core.DataTransport.SpanStreamingService : DataStreamingService`3<Span, SpanBatch, RecordStatus> {
    protected string EndpointHostConfigValue { get; }
    protected string EndpointPortConfigValue { get; }
    protected string EndpointSslConfigValue { get; }
    protected Nullable`1<float> EndpointTestFlakyConfigValue { get; }
    protected Nullable`1<int> EndpointTestFlakyCodeConfigValue { get; }
    protected Nullable`1<int> EndpointTestDelayMsConfigValue { get; }
    public int BatchSizeConfigValue { get; }
    public SpanStreamingService(IGrpcWrapper`2<SpanBatch, RecordStatus> grpcWrapper, IDelayer delayer, IConfigurationService configSvc, IAgentHealthReporter agentHealthReporter, IAgentTimerService agentTimerService, IEnvironment environment);
    protected virtual string get_EndpointHostConfigValue();
    protected virtual string get_EndpointPortConfigValue();
    protected virtual string get_EndpointSslConfigValue();
    protected virtual Nullable`1<float> get_EndpointTestFlakyConfigValue();
    protected virtual Nullable`1<int> get_EndpointTestFlakyCodeConfigValue();
    protected virtual Nullable`1<int> get_EndpointTestDelayMsConfigValue();
    public virtual int get_BatchSizeConfigValue();
    protected virtual void HandleServerResponse(RecordStatus responseModel, int consumerId);
    private void RecordReceived(ulong countItems);
    protected virtual void RecordSuccessfulSend(int countItems);
    protected virtual void RecordGrpcError(string status);
    protected virtual void RecordResponseError();
    protected virtual void RecordSendTimeout();
    protected virtual SpanBatch CreateBatch(IList`1<Span> items);
}
public class NewRelic.Agent.Core.DataTransport.TransactionTraceSettingsModel : object {
    [JsonPropertyAttribute("record_sql")]
public string RecordSql;
    public TransactionTraceSettingsModel(string recordSql);
}
public class NewRelic.Agent.Core.DataTransport.TransactionWireData : ConcurrentDictionary`2<string, WireData> {
}
public class NewRelic.Agent.Core.DataTransport.WireData : ConcurrentDictionary`2<string, Object[]> {
}
public class NewRelic.Agent.Core.DependencyInjection.AgentContainer : object {
    private ContainerBuilder _builder;
    private IContainer _container;
    private ILifetimeScope _scope;
    private bool _disposedValue;
    private Dictionary`2<Type, object> _registrationsToReplace;
    public sealed virtual void Build();
    public sealed virtual void ReplaceRegistrations();
    private void ReplaceRegistrations(ContainerBuilder builder);
    public sealed virtual void Register();
    public sealed virtual void Register();
    public sealed virtual void RegisterInstance(TInterface instance);
    public sealed virtual void RegisterFactory(Func`1<TInterface> func);
    public sealed virtual void ReplaceInstanceRegistration(TInterface instance);
    public sealed virtual T Resolve();
    public sealed virtual IEnumerable`1<T> ResolveAll();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public static class NewRelic.Agent.Core.DependencyInjection.AgentServices : object {
    public static IContainer GetContainer();
    public static void RegisterServices(IContainer container, bool serverlessModeEnabled);
    public static void StartServices(IContainer container, bool serverlessModeEnabled);
}
public interface NewRelic.Agent.Core.DependencyInjection.IContainer {
    public abstract virtual void Register();
    public abstract virtual void Register();
    public abstract virtual void RegisterInstance(TInterface instance);
    public abstract virtual void RegisterFactory(Func`1<TInterface> func);
    public abstract virtual void ReplaceInstanceRegistration(TInterface instance);
    public abstract virtual T Resolve();
    public abstract virtual IEnumerable`1<T> ResolveAll();
    public abstract virtual void Build();
    public abstract virtual void ReplaceRegistrations();
}
public class NewRelic.Agent.Core.DisabledAgentManager : object {
    public sealed virtual ITracer GetTracerImpl(string tracerFactoryName, UInt32 tracerArguments, string metricName, string assemblyName, Type type, string typename, string methodName, string argumentSignature, object invocationTarget, Object[] arguments, ulong functionId);
}
public class NewRelic.Agent.Core.DistributedTracing.AdaptiveSampler : ConfigurationBasedService {
    private static int MinTargetSamplesPerInterval;
    private static float PriorityBoost;
    public static int DefaultTargetSamplesPerInterval;
    public static int DefaultTargetSamplingIntervalInSeconds;
    private AdaptiveSamplerState _state;
    public int TargetSamplesPerInterval { get; }
    public AdaptiveSampler(int targetSamplesPerInterval, int targetSamplingIntervalInSeconds, Nullable`1<int> seed, Nullable`1<bool> serverlessMode);
    public int get_TargetSamplesPerInterval();
    public sealed virtual void StartTransaction();
    private static void BoostPriority(Single& priority);
    public sealed virtual bool ComputeSampled(Single& priority);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
public class NewRelic.Agent.Core.DistributedTracing.DistributedTraceAcceptPayloadException : DistributedTraceException {
    public DistributedTraceAcceptPayloadException(string message);
    public DistributedTraceAcceptPayloadException(string message, Exception inner);
}
public class NewRelic.Agent.Core.DistributedTracing.DistributedTraceAcceptPayloadNullException : DistributedTraceAcceptPayloadException {
    public DistributedTraceAcceptPayloadNullException(string message);
    public DistributedTraceAcceptPayloadNullException(string message, Exception inner);
}
public class NewRelic.Agent.Core.DistributedTracing.DistributedTraceAcceptPayloadParseException : DistributedTraceAcceptPayloadException {
    public DistributedTraceAcceptPayloadParseException(string message);
    public DistributedTraceAcceptPayloadParseException(string message, Exception inner);
}
public class NewRelic.Agent.Core.DistributedTracing.DistributedTraceAcceptPayloadVersionException : DistributedTraceAcceptPayloadException {
    public DistributedTraceAcceptPayloadVersionException(string message);
    public DistributedTraceAcceptPayloadVersionException(string message, Exception inner);
}
public class NewRelic.Agent.Core.DistributedTracing.DistributedTraceException : Exception {
    public DistributedTraceException(string message);
    public DistributedTraceException(string message, Exception inner);
}
internal enum NewRelic.Agent.Core.DistributedTracing.DistributedTraceHeaderType : Enum {
    public int value__;
    public static DistributedTraceHeaderType NewRelic;
    public static DistributedTraceHeaderType W3cTraceparent;
    public static DistributedTraceHeaderType W3cTracestate;
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.DistributedTracePayloadJsonConverter")]
public class NewRelic.Agent.Core.DistributedTracing.DistributedTracePayload : object {
    public static int SupportedMajorVersion;
    public static int SupportedMinorVersion;
    [CompilerGeneratedAttribute]
private Int32[] <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TrustKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Sampled>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionId>k__BackingField;
    public Int32[] Version { get; public set; }
    public string Type { get; public set; }
    public string AccountId { get; public set; }
    public string AppId { get; public set; }
    public string Guid { get; public set; }
    public string TraceId { get; public set; }
    public string TrustKey { get; public set; }
    public Nullable`1<float> Priority { get; public set; }
    public Nullable`1<bool> Sampled { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string TransactionId { get; public set; }
    private DistributedTracePayload(string type, string accountId, string appId, string guid, string traceId, string trustKey, Nullable`1<float> priority, Nullable`1<bool> sampled, DateTime timestamp, string transactionId);
    [CompilerGeneratedAttribute]
public Int32[] get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Int32[] value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_AccountId();
    [CompilerGeneratedAttribute]
public void set_AccountId(string value);
    [CompilerGeneratedAttribute]
public string get_AppId();
    [CompilerGeneratedAttribute]
public void set_AppId(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_TraceId();
    [CompilerGeneratedAttribute]
public void set_TraceId(string value);
    [CompilerGeneratedAttribute]
public string get_TrustKey();
    [CompilerGeneratedAttribute]
public void set_TrustKey(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Sampled();
    [CompilerGeneratedAttribute]
public void set_Sampled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_TransactionId();
    [CompilerGeneratedAttribute]
public void set_TransactionId(string value);
    public static DistributedTracePayload TryBuildOutgoingPayload(string type, string accountId, string appId, string guid, string traceId, string trustKey, Nullable`1<float> priority, Nullable`1<bool> sampled, DateTime timestamp, string transactionId);
    public static DistributedTracePayload TryBuildIncomingPayloadFromJson(string json);
    public static DistributedTracePayload TryBuildIncomingPayloadFromJson(string json, List`1<IngestErrorType> errors);
    public string ToJson(bool pretty);
    public string SerializeAndEncodeDistributedTracePayload();
    public static string SerializeAndEncodeDistributedTracePayload(DistributedTracePayload data);
    public static DistributedTracePayload TryDecodeAndDeserializeDistributedTracePayload(string encodedString);
    public static DistributedTracePayload TryDecodeAndDeserializeDistributedTracePayload(string encodedString, string agentTrustKey, List`1<IngestErrorType> errors);
}
public class NewRelic.Agent.Core.DistributedTracing.DistributedTracePayloadHandler : object {
    private static string DistributedTraceTypeDefault;
    private static int ParentType;
    private static string TraceParentVersion;
    private static string PriorityFormat;
    private static int TraceIdMaxLength;
    private IConfigurationService _configurationService;
    private IAgentHealthReporter _agentHealthReporter;
    private IAdaptiveSampler _adaptiveSampler;
    public DistributedTracePayloadHandler(IConfigurationService configurationService, IAgentHealthReporter agentHealthReporter, IAdaptiveSampler adaptiveSampler);
    public sealed virtual void InsertDistributedTraceHeaders(IInternalTransaction transaction, T carrier, Action`3<T, string, string> setter);
    private string GetOutboundHeader(DistributedTraceHeaderType headerType, IInternalTransaction transaction, DateTime timestamp);
    private string BuildTraceParent(IInternalTransaction transaction);
    private string FormatTraceId(string traceId);
    private string BuildTracestate(IInternalTransaction transaction, DateTime timestamp);
    public sealed virtual IDistributedTracePayload TryGetOutboundDistributedTraceApiModel(IInternalTransaction transaction, ISegment segment);
    private IDistributedTracePayload TryGetOutboundDistributedTraceApiModelInternal(IInternalTransaction transaction, ISegment segment, DateTime timestamp);
    public sealed virtual ITracingState AcceptDistributedTraceHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, TransportType transportType, DateTime transactionStartTime);
    private void ReportIncomingErrors(List`1<IngestErrorType> errors);
    public sealed virtual DistributedTracePayload TryDecodeInboundSerializedDistributedTracePayload(string serializedPayload);
    private bool IsValidPayload(DistributedTracePayload payload);
    private bool HasTraceablePayload(DistributedTracePayload payload);
    private bool HasTrustedAccountKey(DistributedTracePayload payload);
}
public enum NewRelic.Agent.Core.DistributedTracing.DistributedTracingParentType : Enum {
    public int value__;
    public static DistributedTracingParentType Unknown;
    public static DistributedTracingParentType App;
    public static DistributedTracingParentType Browser;
    public static DistributedTracingParentType Mobile;
}
public interface NewRelic.Agent.Core.DistributedTracing.IAdaptiveSampler {
    public abstract virtual bool ComputeSampled(Single& priority);
    public abstract virtual void StartTransaction();
}
public interface NewRelic.Agent.Core.DistributedTracing.IDistributedTracePayloadHandler {
    public abstract virtual IDistributedTracePayload TryGetOutboundDistributedTraceApiModel(IInternalTransaction transaction, ISegment segment);
    public abstract virtual DistributedTracePayload TryDecodeInboundSerializedDistributedTracePayload(string serializedPayload);
    public abstract virtual ITracingState AcceptDistributedTraceHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, TransportType transportType, DateTime transactionStartTime);
    public abstract virtual void InsertDistributedTraceHeaders(IInternalTransaction transaction, T carrier, Action`3<T, string, string> setter);
}
public enum NewRelic.Agent.Core.DistributedTracing.IngestErrorType : Enum {
    public int value__;
    public static IngestErrorType Version;
    public static IngestErrorType NullPayload;
    public static IngestErrorType ParseException;
    public static IngestErrorType OtherException;
    public static IngestErrorType NotTraceable;
    public static IngestErrorType NotTrusted;
    public static IngestErrorType TraceParentParseException;
    public static IngestErrorType TraceStateParseException;
    public static IngestErrorType TraceStateInvalidNrEntry;
    public static IngestErrorType TraceStateNoNrEntry;
    public static IngestErrorType TraceContextAcceptException;
    public static IngestErrorType TraceContextCreateException;
    public static IngestErrorType None;
}
public interface NewRelic.Agent.Core.DistributedTracing.ITracePriorityManager {
    public abstract virtual float Create();
}
public interface NewRelic.Agent.Core.DistributedTracing.ITracingState {
    public DistributedTracingParentType Type { get; }
    public string AppId { get; }
    public string AccountId { get; }
    public TransportType TransportType { get; }
    public string Guid { get; }
    public string ParentId { get; }
    public DateTime Timestamp { get; }
    public TimeSpan TransportDuration { get; }
    public string TraceId { get; }
    public string TransactionId { get; }
    public Nullable`1<bool> Sampled { get; }
    public Nullable`1<float> Priority { get; }
    public bool NewRelicPayloadWasAccepted { get; }
    public bool TraceContextWasAccepted { get; }
    public bool HasDataForParentAttributes { get; }
    public bool HasDataForAttributes { get; }
    public List`1<IngestErrorType> IngestErrors { get; }
    public List`1<string> VendorStateEntries { get; }
    public abstract virtual DistributedTracingParentType get_Type();
    public abstract virtual string get_AppId();
    public abstract virtual string get_AccountId();
    public abstract virtual TransportType get_TransportType();
    public abstract virtual string get_Guid();
    public abstract virtual string get_ParentId();
    public abstract virtual DateTime get_Timestamp();
    public abstract virtual TimeSpan get_TransportDuration();
    public abstract virtual string get_TraceId();
    public abstract virtual string get_TransactionId();
    public abstract virtual Nullable`1<bool> get_Sampled();
    public abstract virtual Nullable`1<float> get_Priority();
    public abstract virtual bool get_NewRelicPayloadWasAccepted();
    public abstract virtual bool get_TraceContextWasAccepted();
    public abstract virtual bool get_HasDataForParentAttributes();
    public abstract virtual bool get_HasDataForAttributes();
    public abstract virtual List`1<IngestErrorType> get_IngestErrors();
    public abstract virtual List`1<string> get_VendorStateEntries();
}
internal enum NewRelic.Agent.Core.DistributedTracing.SampledEnum : Enum {
    public int value__;
    public static SampledEnum IsFalse;
    public static SampledEnum IsTrue;
}
public class NewRelic.Agent.Core.DistributedTracing.TracePriorityManager : object {
    private SpinLock _spinLock;
    private Random _randomNumberGenerator;
    private static UInt32 SanitizeShiftDecimalPoint;
    public TracePriorityManager(Nullable`1<int> seed);
    private static float Sanitize(float priority);
    public sealed virtual float Create();
    public static float Adjust(float priority, float adjustment);
}
internal static class NewRelic.Agent.Core.DistributedTracing.TracestateUtils : object {
    private static int ValueMaxSize;
    private static int MaxEntriesCount;
    public static bool ValidateValue(string value);
    public static bool ParseTracestate(string tracestateString, List`1<KeyValuePair`2<string, string>> tracestateEntries);
    private static bool TryParseKeyValue(string tracestateEntryString, String& key, String& value);
}
public class NewRelic.Agent.Core.DistributedTracing.TracingState : object {
    private DistributedTracingParentType _type;
    private DateTime _timestamp;
    private Nullable`1<bool> _sampled;
    private bool _validTracestateWasAccepted;
    private DateTime _transactionStartTime;
    [CompilerGeneratedAttribute]
private TransportType <TransportType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NewRelicPayloadWasAccepted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceContextWasAccepted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDataForAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IngestErrorType> <IngestErrors>k__BackingField;
    private DistributedTracePayload _newRelicPayload;
    private W3CTraceContext _traceContext;
    public DistributedTracingParentType Type { get; }
    public string AppId { get; }
    public string AccountId { get; }
    public TransportType TransportType { get; private set; }
    public string Guid { get; }
    public string ParentId { get; }
    public DateTime Timestamp { get; }
    public TimeSpan TransportDuration { get; }
    public string TraceId { get; }
    public string TransactionId { get; }
    public Nullable`1<bool> Sampled { get; }
    public Nullable`1<float> Priority { get; }
    public bool NewRelicPayloadWasAccepted { get; private set; }
    public bool TraceContextWasAccepted { get; private set; }
    public bool HasDataForParentAttributes { get; }
    public bool HasDataForAttributes { get; private set; }
    public List`1<string> VendorStateEntries { get; }
    public List`1<IngestErrorType> IngestErrors { get; private set; }
    public sealed virtual DistributedTracingParentType get_Type();
    public sealed virtual string get_AppId();
    public sealed virtual string get_AccountId();
    [CompilerGeneratedAttribute]
public sealed virtual TransportType get_TransportType();
    [CompilerGeneratedAttribute]
private void set_TransportType(TransportType value);
    public sealed virtual string get_Guid();
    public sealed virtual string get_ParentId();
    public sealed virtual DateTime get_Timestamp();
    public sealed virtual TimeSpan get_TransportDuration();
    public sealed virtual string get_TraceId();
    public sealed virtual string get_TransactionId();
    public sealed virtual Nullable`1<bool> get_Sampled();
    public sealed virtual Nullable`1<float> get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NewRelicPayloadWasAccepted();
    [CompilerGeneratedAttribute]
private void set_NewRelicPayloadWasAccepted(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TraceContextWasAccepted();
    [CompilerGeneratedAttribute]
private void set_TraceContextWasAccepted(bool value);
    public sealed virtual bool get_HasDataForParentAttributes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasDataForAttributes();
    [CompilerGeneratedAttribute]
private void set_HasDataForAttributes(bool value);
    public sealed virtual List`1<string> get_VendorStateEntries();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<IngestErrorType> get_IngestErrors();
    [CompilerGeneratedAttribute]
private void set_IngestErrors(List`1<IngestErrorType> value);
    public static ITracingState AcceptDistributedTraceHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, TransportType transportType, string agentTrustKey, DateTime transactionStartTime);
}
internal class NewRelic.Agent.Core.DistributedTracing.W3CTraceContext : object {
    [CompilerGeneratedAttribute]
private W3CTraceparent <Traceparent>k__BackingField;
    [CompilerGeneratedAttribute]
private W3CTracestate <Tracestate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceparentPresent>k__BackingField;
    internal W3CTraceparent Traceparent { get; private set; }
    internal W3CTracestate Tracestate { get; private set; }
    internal bool TraceparentPresent { get; private set; }
    public List`1<string> VendorStateEntries { get; }
    [CompilerGeneratedAttribute]
internal W3CTraceparent get_Traceparent();
    [CompilerGeneratedAttribute]
private void set_Traceparent(W3CTraceparent value);
    [CompilerGeneratedAttribute]
internal W3CTracestate get_Tracestate();
    [CompilerGeneratedAttribute]
private void set_Tracestate(W3CTracestate value);
    [CompilerGeneratedAttribute]
internal bool get_TraceparentPresent();
    [CompilerGeneratedAttribute]
private void set_TraceparentPresent(bool value);
    public List`1<string> get_VendorStateEntries();
    internal static W3CTraceContext TryGetTraceContextFromHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, string trustedAccountKey, IList`1<IngestErrorType> errors);
    private W3CTraceparent TryGetTraceParentHeaderFromHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, IList`1<IngestErrorType> errors);
    private static W3CTracestate TryGetTracestateFromHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, string trustedAccountKey, IList`1<IngestErrorType> errors);
}
public class NewRelic.Agent.Core.DistributedTracing.W3CTraceparent : object {
    public static byte SupportedVersion;
    public static byte NumberOfFieldsV0;
    private static int TraceparentLengthV0;
    private static int VersionIndex;
    private static int VersionLengthV0;
    private static int TraceIdIndex;
    private static int TraceIdLengthV0;
    private static int ParentIdIndex;
    private static int ParentIdLengthV0;
    private static int TraceFlagsIndex;
    private static int TraceFlagsLengthV0;
    private static string ZerodOutTraceId;
    private static string ZerodOutParentId;
    private static byte InvalidVersion255;
    private static string InvalidVersionff;
    private static Char[] _separator;
    private static Regex _hexRegex;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceFlags>k__BackingField;
    public byte Version { get; }
    public string TraceId { get; }
    public string ParentId { get; }
    public string TraceFlags { get; }
    private W3CTraceparent(byte version, string traceId, string parentId, string traceFlags);
    private static W3CTraceparent();
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public string get_TraceId();
    [CompilerGeneratedAttribute]
public string get_ParentId();
    [CompilerGeneratedAttribute]
public string get_TraceFlags();
    public static W3CTraceparent GetW3CTraceParentFromHeader(string traceparentValue);
    public KeyValuePair`2<string, string> ToHeaderFormat();
    public virtual string ToString();
    private static bool TryParseVersion(string version, Byte& parsedVersion);
    private static bool ValidateTraceId(string traceId);
    private static bool ValidateParentId(string parentId);
    private static bool ValidateTraceFlags(string traceFlags);
}
public class NewRelic.Agent.Core.DistributedTracing.W3CTracestate : object {
    private static string NRVendorString;
    private static int NumberOfFieldsInSupportedVersion;
    private static int SupportedVersion;
    private static int VersionIndex;
    private static int ParentTypeIndex;
    private static int AccountIdIndex;
    private static int AppIdIndex;
    private static int SpanIdIndex;
    private static int TransactionIdIndex;
    private static int SampledIndex;
    private static int PriorityIndex;
    private static int MaxDecimalPlacesInPriority;
    private static int TimestampIndex;
    [CompilerGeneratedAttribute]
private List`1<string> <VendorstateEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountKey>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private DistributedTracingParentType <ParentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpanId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Sampled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private IngestErrorType <Error>k__BackingField;
    public List`1<string> VendorstateEntries { get; public set; }
    public string AccountKey { get; public set; }
    public int Version { get; public set; }
    public DistributedTracingParentType ParentType { get; public set; }
    public string AccountId { get; public set; }
    public string AppId { get; public set; }
    public string SpanId { get; public set; }
    public string TransactionId { get; public set; }
    public Nullable`1<int> Sampled { get; public set; }
    public Nullable`1<float> Priority { get; public set; }
    public long Timestamp { get; public set; }
    public IngestErrorType Error { get; }
    public W3CTracestate(List`1<string> vendorstates, string accountKey, int version, int parentType, string accountId, string appId, string spanId, string transactionId, Nullable`1<int> sampled, Nullable`1<float> priority, long timestamp);
    private W3CTracestate(List`1<string> vendorstates, string accountKey, int version, int parentType, string accountId, string appId, string spanId, string transactionId, Nullable`1<int> sampled, Nullable`1<float> priority, long timestamp, IngestErrorType error);
    [CompilerGeneratedAttribute]
public List`1<string> get_VendorstateEntries();
    [CompilerGeneratedAttribute]
public void set_VendorstateEntries(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_AccountKey();
    [CompilerGeneratedAttribute]
public void set_AccountKey(string value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public DistributedTracingParentType get_ParentType();
    [CompilerGeneratedAttribute]
public void set_ParentType(DistributedTracingParentType value);
    [CompilerGeneratedAttribute]
public string get_AccountId();
    [CompilerGeneratedAttribute]
public void set_AccountId(string value);
    [CompilerGeneratedAttribute]
public string get_AppId();
    [CompilerGeneratedAttribute]
public void set_AppId(string value);
    [CompilerGeneratedAttribute]
public string get_SpanId();
    [CompilerGeneratedAttribute]
public void set_SpanId(string value);
    [CompilerGeneratedAttribute]
public string get_TransactionId();
    [CompilerGeneratedAttribute]
public void set_TransactionId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Sampled();
    [CompilerGeneratedAttribute]
public void set_Sampled(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(long value);
    [CompilerGeneratedAttribute]
public IngestErrorType get_Error();
    public virtual string ToString();
    public static W3CTracestate GetW3CTracestateFromHeaders(IEnumerable`1<string> tracestateCollection, string trustedAccountKey);
    private static List`1<KeyValuePair`2<string, string>> TryExtractTracestateHeaders(IEnumerable`1<string> tracestateCollection);
    private static bool TryParseAndValidatePriority(string priorityString, Single& priority);
}
[NrExcludeFromCodeCoverageAttribute]
[JsonConverterAttribute("NewRelic.Agent.Core.Environment/EnvironmentConverter")]
public class NewRelic.Agent.Core.Environment : object {
    private List`1<Object[]> _environmentMap;
    private IProcessStatic _processStatic;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <TotalPhysicalMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppDomainAppPath>k__BackingField;
    public Nullable`1<ulong> TotalPhysicalMemory { get; }
    public string AppDomainAppPath { get; }
    public Environment(ISystemInfo systemInfo, IProcessStatic processStatic, IConfigurationService configurationService);
    [CompilerGeneratedAttribute]
public Nullable`1<ulong> get_TotalPhysicalMemory();
    [CompilerGeneratedAttribute]
public string get_AppDomainAppPath();
    public void AddVariable(string name, Func`1<object> valueGetter);
    private IProcess TryGetCurrentProcess();
    private static FileVersionInfo TryGetFileVersionInfo();
    private static string TryGetAppDomainAppId();
    public static string TryGetAppPath(Func`1<string> pathGetter);
    public Version TryGetIisVersion();
    private static IEnumerable`1<string> GetLoadedAssemblyNames();
    private static IEnumerable`1<ManagementBaseObject> TryGetManagementObjects(string query);
}
public class NewRelic.Agent.Core.Errors.ErrorData : object {
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <NoticedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyDictionary`2<string, object> <CustomAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExpected>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <RawException>k__BackingField;
    public static string StripExceptionMessagesMessage;
    public string ErrorMessage { get; }
    public string ErrorTypeName { get; }
    public string StackTrace { get; }
    public DateTime NoticedAt { get; }
    public string Path { get; public set; }
    public ReadOnlyDictionary`2<string, object> CustomAttributes { get; }
    public bool IsExpected { get; }
    public Exception RawException { get; }
    public ErrorData(string errorMessage, string errorTypeName, string stackTrace, DateTime noticedAt, ReadOnlyDictionary`2<string, object> customAttributes, bool isExpected, Exception rawException);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public string get_ErrorTypeName();
    [CompilerGeneratedAttribute]
public string get_StackTrace();
    [CompilerGeneratedAttribute]
public DateTime get_NoticedAt();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyDictionary`2<string, object> get_CustomAttributes();
    [CompilerGeneratedAttribute]
public bool get_IsExpected();
    [CompilerGeneratedAttribute]
public Exception get_RawException();
}
public class NewRelic.Agent.Core.Errors.ErrorService : object {
    private static string CustomErrorTypeName;
    private static ReadOnlyDictionary`2<string, object> _emptyCustomAttributes;
    private IConfigurationService _configurationService;
    public bool ShouldCollectErrors { get; }
    public ErrorService(IConfigurationService configurationService);
    private static ErrorService();
    public sealed virtual bool get_ShouldCollectErrors();
    public sealed virtual bool ShouldIgnoreException(Exception exception);
    public sealed virtual bool ShouldIgnoreHttpStatusCode(int statusCode, Nullable`1<int> subStatusCode);
    public sealed virtual ErrorData FromException(Exception exception);
    public sealed virtual ErrorData FromException(Exception exception, IDictionary`2<string, string> customAttributes);
    public sealed virtual ErrorData FromException(Exception exception, IDictionary`2<string, object> customAttributes);
    public sealed virtual ErrorData FromMessage(string errorMessage, IDictionary`2<string, string> customAttributes, bool isExpected);
    public sealed virtual ErrorData FromMessage(string errorMessage, IDictionary`2<string, object> customAttributes, bool isExpected);
    public sealed virtual ErrorData FromErrorHttpStatusCode(int statusCode, Nullable`1<int> subStatusCode, DateTime noticedAt);
    private static string GetFriendlyExceptionTypeName(Exception exception);
    private string GetFormattedHttpStatusCode(int statusCode, Nullable`1<int> subStatusCode);
    private ErrorData FromMessageInternal(string errorMessage, IDictionary`2<string, T> customAttributes, bool isExpected);
    private ErrorData FromExceptionInternal(Exception exception, ReadOnlyDictionary`2<string, object> customAttributes);
    private static bool IsErrorFromExceptionSpecified(Exception exception, IDictionary`2<string, IEnumerable`1<string>> source);
    private static bool IsExceptionSpecified(Exception exception, IDictionary`2<string, IEnumerable`1<string>> source);
    private static bool ContainsSubstring(IEnumerable`1<string> subStringList, string sourceString);
    private ReadOnlyDictionary`2<string, object> CaptureAttributes(IDictionary`2<string, T> attributes);
}
public static class NewRelic.Agent.Core.Errors.ExceptionFormatter : object {
    public static string FormatStackTrace(Exception exception, bool stripErrorMessage);
    private static string FormatInnerStackTrace(Exception innerException, bool stripErrorMessage);
}
public interface NewRelic.Agent.Core.Errors.IErrorService {
    public bool ShouldCollectErrors { get; }
    public abstract virtual bool get_ShouldCollectErrors();
    public abstract virtual bool ShouldIgnoreException(Exception exception);
    public abstract virtual bool ShouldIgnoreHttpStatusCode(int statusCode, Nullable`1<int> subStatusCode);
    public abstract virtual ErrorData FromException(Exception exception);
    public abstract virtual ErrorData FromException(Exception exception, IDictionary`2<string, string> customAttributes);
    public abstract virtual ErrorData FromException(Exception exception, IDictionary`2<string, object> customAttributes);
    public abstract virtual ErrorData FromMessage(string errorMessage, IDictionary`2<string, string> customAttributes, bool isExpected);
    public abstract virtual ErrorData FromMessage(string errorMessage, IDictionary`2<string, object> customAttributes, bool isExpected);
    public abstract virtual ErrorData FromErrorHttpStatusCode(int statusCode, Nullable`1<int> subStatusCode, DateTime noticedAt);
}
public class NewRelic.Agent.Core.Events.AgentConnectedEvent : object {
}
public class NewRelic.Agent.Core.Events.AppNameUpdateEvent : object {
    public IEnumerable`1<string> AppNames;
    public AppNameUpdateEvent(IEnumerable`1<string> appNames);
}
public class NewRelic.Agent.Core.Events.CleanShutdownEvent : object {
}
public class NewRelic.Agent.Core.Events.ConfigurationDeserializedEvent : object {
    public configuration Configuration;
    public ConfigurationDeserializedEvent(configuration configuration);
}
public class NewRelic.Agent.Core.Events.ConfigurationUpdatedEvent : object {
    public IConfiguration Configuration;
    public ConfigurationUpdateSource ConfigurationUpdateSource;
    public ConfigurationUpdatedEvent(IConfiguration configuration, ConfigurationUpdateSource configurationUpdateSource);
}
public enum NewRelic.Agent.Core.Events.ConfigurationUpdateSource : Enum {
    public int value__;
    public static ConfigurationUpdateSource Unknown;
    public static ConfigurationUpdateSource Server;
    public static ConfigurationUpdateSource Local;
    public static ConfigurationUpdateSource RunTime;
    public static ConfigurationUpdateSource SecurityPolicies;
}
public class NewRelic.Agent.Core.Events.CounterMetricEvent : object {
    public string Namespace;
    public string Name;
    public int Count;
    public CounterMetricEvent(string namespace, string name, int count);
    public CounterMetricEvent(string name, int count);
}
public class NewRelic.Agent.Core.Events.CustomEventEvent : object {
    public string EventType;
    public IEnumerable`1<KeyValuePair`2<string, object>> Attributes;
    public CustomEventEvent(string eventType, IEnumerable`1<KeyValuePair`2<string, object>> attributes);
}
public class NewRelic.Agent.Core.Events.ErrorGroupCallbackUpdateEvent : object {
    public Func`2<IReadOnlyDictionary`2<string, object>, string> ErrorGroupCallback;
    public ErrorGroupCallbackUpdateEvent(Func`2<IReadOnlyDictionary`2<string, object>, string> errorGroupCallback);
}
public class NewRelic.Agent.Core.Events.FlushServerlessDataEvent : object {
    public string TransactionId;
    public FlushServerlessDataEvent(string transactionId);
}
public class NewRelic.Agent.Core.Events.KillAgentEvent : object {
}
public class NewRelic.Agent.Core.Events.LlmTokenCountingCallbackUpdateEvent : object {
    public Func`3<string, string, int> LlmTokenCountingCallback;
    public LlmTokenCountingCallbackUpdateEvent(Func`3<string, string, int> llmTokenCountingCallback);
}
public class NewRelic.Agent.Core.Events.ManualHarvestEvent : object {
    public string TransactionId;
    public ManualHarvestEvent(string transactionId);
}
public class NewRelic.Agent.Core.Events.PreCleanShutdownEvent : object {
}
public class NewRelic.Agent.Core.Events.RestartAgentEvent : object {
}
public class NewRelic.Agent.Core.Events.SecurityPoliciesConfigurationUpdatedEvent : object {
    public SecurityPoliciesConfiguration Configuration;
    public SecurityPoliciesConfigurationUpdatedEvent(SecurityPoliciesConfiguration configuration);
}
public class NewRelic.Agent.Core.Events.ServerConfigurationUpdatedEvent : object {
    public ServerConfiguration Configuration;
    public ServerConfigurationUpdatedEvent(ServerConfiguration configuration);
}
public class NewRelic.Agent.Core.Events.StartAgentEvent : object {
}
public class NewRelic.Agent.Core.Events.StopHarvestEvent : object {
}
public class NewRelic.Agent.Core.Events.TransactionFinalizedEvent : object {
    public IInternalTransaction Transaction;
    public TransactionFinalizedEvent(IInternalTransaction transaction);
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute]
public class NewRelic.Agent.Core.Extension.extension : object {
    private List`1<extensionTracerFactory> instrumentationField;
    private bool enabledField;
    [XmlArrayItemAttribute("tracerFactory")]
public List`1<extensionTracerFactory> instrumentation { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    public List`1<extensionTracerFactory> get_instrumentation();
    public void set_instrumentation(List`1<extensionTracerFactory> value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public virtual extension Clone();
}
public class NewRelic.Agent.Core.Extension.ExtensionHelper : object {
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Extension.extensionTracerFactory : object {
    private List`1<extensionTracerFactoryMatch> matchField;
    private string nameField;
    private string metricNameField;
    private bool enabledField;
    private string levelField;
    private bool suppressRecursiveCallsField;
    private extensionTracerFactoryMetric metricField;
    private bool transactionTraceSegmentField;
    private Nullable`1<ushort> transactionNamingPriorityField;
    [XmlElementAttribute("match")]
public List`1<extensionTracerFactoryMatch> match { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("NewRelic.Agent.Core.Tracer.Factories.DefaultTracerFactory")]
public string name { get; public set; }
    [XmlAttributeAttribute]
public string metricName { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool enabled { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("0")]
public string level { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool suppressRecursiveCalls { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public extensionTracerFactoryMetric metric { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool transactionTraceSegment { get; public set; }
    [XmlAttributeAttribute]
public ushort transactionNamingPriority { get; public set; }
    [XmlIgnoreAttribute]
public bool transactionNamingPrioritySpecified { get; public set; }
    public List`1<extensionTracerFactoryMatch> get_match();
    public void set_match(List`1<extensionTracerFactoryMatch> value);
    public string get_name();
    public void set_name(string value);
    public string get_metricName();
    public void set_metricName(string value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public string get_level();
    public void set_level(string value);
    public bool get_suppressRecursiveCalls();
    public void set_suppressRecursiveCalls(bool value);
    public extensionTracerFactoryMetric get_metric();
    public void set_metric(extensionTracerFactoryMetric value);
    public bool get_transactionTraceSegment();
    public void set_transactionTraceSegment(bool value);
    public ushort get_transactionNamingPriority();
    public void set_transactionNamingPriority(ushort value);
    public bool get_transactionNamingPrioritySpecified();
    public void set_transactionNamingPrioritySpecified(bool value);
    public virtual extensionTracerFactory Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Extension.extensionTracerFactoryMatch : object {
    private List`1<extensionTracerFactoryMatchExactMethodMatcher> exactMethodMatcherField;
    private string assemblyNameField;
    private string minVersionField;
    private string maxVersionField;
    private string classNameField;
    [XmlElementAttribute("exactMethodMatcher")]
public List`1<extensionTracerFactoryMatchExactMethodMatcher> exactMethodMatcher { get; public set; }
    [XmlAttributeAttribute]
public string assemblyName { get; public set; }
    [XmlAttributeAttribute]
public string minVersion { get; public set; }
    [XmlAttributeAttribute]
public string maxVersion { get; public set; }
    [XmlAttributeAttribute]
public string className { get; public set; }
    public List`1<extensionTracerFactoryMatchExactMethodMatcher> get_exactMethodMatcher();
    public void set_exactMethodMatcher(List`1<extensionTracerFactoryMatchExactMethodMatcher> value);
    public string get_assemblyName();
    public void set_assemblyName(string value);
    public string get_minVersion();
    public void set_minVersion(string value);
    public string get_maxVersion();
    public void set_maxVersion(string value);
    public string get_className();
    public void set_className(string value);
    public virtual extensionTracerFactoryMatch Clone();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class NewRelic.Agent.Core.Extension.extensionTracerFactoryMatchExactMethodMatcher : object {
    private string methodNameField;
    private string parametersField;
    [XmlAttributeAttribute]
public string methodName { get; public set; }
    [XmlAttributeAttribute]
public string parameters { get; public set; }
    public string get_methodName();
    public void set_methodName(string value);
    public string get_parameters();
    public void set_parameters(string value);
    public virtual extensionTracerFactoryMatchExactMethodMatcher Clone();
    public virtual string ToString();
}
[GeneratedCodeAttribute("Xsd2Code", "3.6.0.20097")]
[XmlTypeAttribute]
public enum NewRelic.Agent.Core.Extension.extensionTracerFactoryMetric : Enum {
    public int value__;
    public static extensionTracerFactoryMetric none;
    public static extensionTracerFactoryMetric scoped;
    public static extensionTracerFactoryMetric unscoped;
    public static extensionTracerFactoryMetric both;
}
public interface NewRelic.Agent.Core.IAgentManager {
    public abstract virtual ITracer GetTracerImpl(string tracerFactoryName, UInt32 tracerArguments, string metricName, string assemblyName, Type type, string typeName, string methodName, string argumentSignature, object invocationTarget, Object[] arguments, ulong functionId);
}
public class NewRelic.Agent.Core.IgnoreWork : object {
    [ThreadStaticAttribute]
public static UInt32 AgentDepth;
    public sealed virtual void Dispose();
}
public interface NewRelic.Agent.Core.INativeMethods {
    public abstract virtual void ReleaseProfile();
    public abstract virtual int RequestFunctionNames(UIntPtr[] functionIds, int length, IntPtr& functionInfo);
    public abstract virtual int RequestProfile(IntPtr& snapshots, Int32& length);
    public abstract virtual void ShutdownNativeThreadProfiler();
    public abstract virtual int InstrumentationRefresh();
    public abstract virtual int ReloadConfiguration();
    public abstract virtual int AddCustomInstrumentation(string fileName, string xml);
    public abstract virtual int ApplyCustomInstrumentation();
}
public interface NewRelic.Agent.Core.Instrumentation.IInstrumentationService {
    public abstract virtual void AddOrUpdateLiveInstrumentation(string name, string xml);
    public abstract virtual bool ClearLiveInstrumentation();
    public abstract virtual void ApplyInstrumentation();
    public abstract virtual int InstrumentationRefresh();
}
public interface NewRelic.Agent.Core.Instrumentation.IInstrumentationStore {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void AddOrUpdateInstrumentation(string name, string xml);
    public abstract virtual KeyValuePair`2[] GetInstrumentation();
    public abstract virtual bool Clear();
}
public class NewRelic.Agent.Core.Instrumentation.InstrumentationService : object {
    private INativeMethods _nativeMethods;
    private IInstrumentationStore _liveInstrumentationStore;
    private object _nativeMethodsLock;
    public InstrumentationService(INativeMethods nativeMethods);
    public sealed virtual void ApplyInstrumentation();
    public sealed virtual int InstrumentationRefresh();
    public sealed virtual void AddOrUpdateLiveInstrumentation(string name, string xml);
    public sealed virtual bool ClearLiveInstrumentation();
}
public class NewRelic.Agent.Core.Instrumentation.InstrumentationStore : object {
    private ConcurrentDictionary`2<string, string> _instrumentation;
    public bool IsEmpty { get; }
    public sealed virtual bool get_IsEmpty();
    public sealed virtual void AddOrUpdateInstrumentation(string name, string xml);
    public sealed virtual KeyValuePair`2[] GetInstrumentation();
    public sealed virtual bool Clear();
}
public class NewRelic.Agent.Core.Instrumentation.InstrumentationWatcher : object {
    private static int RequestRejitDelayMilliseconds;
    private IInstrumentationService _instrumentationService;
    private IWrapperService _wrapperService;
    private IConfigurationService _configurationService;
    private List`1<FileSystemWatcher> _fileWatchers;
    private SignalableAction _action;
    public InstrumentationWatcher(IWrapperService wrapperService, IInstrumentationService instrumentationService, IConfigurationService configurationService);
    public void Start();
    private void SetupFileWatcherForDirectory(string path);
    private void RequestRejit();
    private void OnChanged(object sender, FileSystemEventArgs e);
    private void OnRenamed(object sender, RenamedEventArgs e);
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Instrumentation.LiveInstrumentationServerConfigurationListener : ConfigurationBasedService {
    private IInstrumentationService _instrumentationService;
    public LiveInstrumentationServerConfigurationListener(IInstrumentationService instrumentationService);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private void OnServerConfigurationUpdated(ServerConfigurationUpdatedEvent serverConfigurationUpdatedEvent);
}
public class NewRelic.Agent.Core.JsonConverters.BrowserEventWireModelSerializer : JsonConverter`1<IAttributeValueCollection> {
    public virtual IAttributeValueCollection ReadJson(JsonReader reader, Type objectType, IAttributeValueCollection existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, IAttributeValueCollection value, JsonSerializer serializer);
}
public class NewRelic.Agent.Core.JsonConverters.CrossApplicationRequestDataJsonConverter : JsonConverter`1<CrossApplicationRequestData> {
    private static int TotalProperties;
    private static int MinimumProperties;
    private static int TransactionGuidIndex;
    private static int UnusedIndex;
    private static int TripIdIndex;
    private static int PathHashIndex;
    public virtual CrossApplicationRequestData ReadJson(JsonReader reader, Type objectType, CrossApplicationRequestData existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, CrossApplicationRequestData value, JsonSerializer serializer);
}
public class NewRelic.Agent.Core.JsonConverters.CrossApplicationResponseDataJsonConverter : JsonConverter`1<CrossApplicationResponseData> {
    private static int TotalProperties;
    private static int MinimumProperties;
    private static int CrossProcessIdIndex;
    private static int TransactionNameIndex;
    private static int QueueTimeInSecondsIndex;
    private static int ResponseTimeInSecondsIndex;
    private static int ContentLengthIndex;
    private static int TransactionGuidIndex;
    private static int UnusedIndex;
    public virtual CrossApplicationResponseData ReadJson(JsonReader reader, Type objectType, CrossApplicationResponseData existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, CrossApplicationResponseData value, JsonSerializer serializer);
}
public static class NewRelic.Agent.Core.JsonConverters.CrossApplicationTracingJsonHelper : object {
    public static String[] ConvertJsonToStringArrayForCat(JsonReader reader, int minimumTokens, int maximumTokens);
    public static String[] ConvertJsonToStringArrayForCat(string json, int minimumTokens, int maximumTokens);
}
[AttributeUsageAttribute("384")]
public class NewRelic.Agent.Core.JsonConverters.DateTimeSerializesAsUnixTimeMillisecondsAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class NewRelic.Agent.Core.JsonConverters.DateTimeSerializesAsUnixTimeSecondsAttribute : Attribute {
}
public class NewRelic.Agent.Core.JsonConverters.DistributedTracePayloadJsonConverter : JsonConverter {
    private static int RequiredDataObjectFieldCount;
    private static int MaximumDataObjectFieldCount;
    private ValidationConstraint`1[] _validationConstraints;
    private static void ParseVersion(JToken selection, DistributedTracePayload payload);
    private static DateTime ParseTimestamp(JToken s);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class NewRelic.Agent.Core.JsonConverters.EventAttributesJsonConverter : JsonConverter`1<IEnumerable`1<KeyValuePair`2<string, object>>> {
    public virtual IEnumerable`1<KeyValuePair`2<string, object>> ReadJson(JsonReader reader, Type objectType, IEnumerable`1<KeyValuePair`2<string, object>> existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, IEnumerable`1<KeyValuePair`2<string, object>> value, JsonSerializer serializer);
}
public class NewRelic.Agent.Core.JsonConverters.EventWireModelSerializer : JsonConverter`1<IEventWireModel> {
    public virtual IEventWireModel ReadJson(JsonReader reader, Type objectType, IEventWireModel existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, IEventWireModel value, JsonSerializer serializer);
}
public class NewRelic.Agent.Core.JsonConverters.JsonArrayConverter : JsonConverter {
    private static SimpleCache`2<Type, MemberInfo[]> _memberInfoCache;
    private static JsonArrayConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type type, object existingValue, JsonSerializer serializer);
    private static object TryParameterizedConstruct(Type type, IList`1<JToken> jArray, IList`1<JsonMemberInfo> orderedJsonMemberInfos);
    private static object MemberJsonInfoToObject(IList`1<JToken> jArray, JsonMemberInfo info);
    private static object DefaultConstruct(Type type, IList`1<JToken> jArray, IList`1<JsonMemberInfo> orderedJsonMemberInfos);
    private static object TryConstruct(ConstructorInfo constructor, Object[] parameterValues);
    public virtual bool CanConvert(Type objectType);
    private static IList`1<object> GetJsonMemberValuesOrderedByIndex(object value);
    private static IList`1<JsonMemberInfo> GetJsonMemberInfosOrderedByIndex(Type type, object instance);
    public static object SwapInDateTimeAsUnixTimeSeconds(MemberInfo member, object value);
    public static object SwapInDateTimeAsUnixTimeMilliseconds(MemberInfo member, object value);
    public static object SwapInTimeSpanAsMilliseconds(MemberInfo member, object value);
    public static object SwapInTimeSpanAsSeconds(MemberInfo member, object value);
    private static JsonMemberInfo TryGetJsonMemberInfo(FieldInfo fieldInfo, object instance);
    private static JsonMemberInfo TryGetJsonMemberInfo(PropertyInfo propertyInfo, object instance);
    private static JsonMemberInfo TryGetJsonMemberInfo(MemberInfo memberInfo, Func`1<object> getValue, Type type, Action`2<object, object> valueSetter);
    private static void TrySetValue(object targetObject, IEnumerable`1<JsonMemberInfo> jsonInfos, IList`1<JToken> jTokens, int tokenIndex);
    private static object GetTokenValue(MemberInfo memberInfo, Type type, JToken jToken);
}
[AttributeUsageAttribute("384")]
public class NewRelic.Agent.Core.JsonConverters.JsonArrayIndexAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    public UInt32 Index { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(UInt32 value);
}
public static class NewRelic.Agent.Core.JsonConverters.JsonSerializerHelpers : object {
    public static void WriteCollection(JsonWriter writer, IEnumerable`1<IAttributeValue> attribValues);
    public static void WriteObjectCollection(JsonWriter writer, IEnumerable`1<KeyValuePair`2<string, object>> collection);
    private static void WriteJsonKeyAndValue(JsonWriter writer, string key, object value);
}
public class NewRelic.Agent.Core.JsonConverters.LoadedModuleWireModelCollectionJsonConverter : JsonConverter`1<LoadedModuleWireModelCollection> {
    private static string JarsName;
    public virtual LoadedModuleWireModelCollection ReadJson(JsonReader reader, Type objectType, LoadedModuleWireModelCollection existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, LoadedModuleWireModelCollection value, JsonSerializer serializer);
    private static void WriteJsonImpl(JsonWriter jsonWriter, LoadedModuleWireModelCollection value);
}
public class NewRelic.Agent.Core.JsonConverters.LogEventWireModelCollectionJsonConverter : JsonConverter`1<LogEventWireModelCollection> {
    private static string Common;
    private static string Attributes;
    private static string EntityName;
    private static string EntityGuid;
    private static string Hostname;
    private static string Logs;
    private static string TimeStamp;
    private static string Message;
    private static string Level;
    private static string SpanId;
    private static string TraceId;
    private static string ErrorStack;
    private static string ErrorMessage;
    private static string ErrorClass;
    private static string Context;
    public virtual LogEventWireModelCollection ReadJson(JsonReader reader, Type objectType, LogEventWireModelCollection existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, LogEventWireModelCollection value, JsonSerializer serializer);
    private static void WriteJsonImpl(JsonWriter jsonWriter, LogEventWireModelCollection value);
}
public class NewRelic.Agent.Core.JsonConverters.MetricDataWireModelJsonConverter : JsonConverter`1<MetricDataWireModel> {
    public virtual MetricDataWireModel ReadJson(JsonReader reader, Type objectType, MetricDataWireModel existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, MetricDataWireModel value, JsonSerializer serializer);
    public static void WriteJsonImpl(JsonWriter jsonWriter, MetricDataWireModel value, JsonSerializer serializer);
}
public class NewRelic.Agent.Core.JsonConverters.MetricNameWireModelJsonConverter : JsonConverter`1<MetricNameWireModel> {
    private static string PropertyName;
    private static string PropertyScope;
    public virtual MetricNameWireModel ReadJson(JsonReader reader, Type objectType, MetricNameWireModel existingValue, bool hasExistingValue, JsonSerializer serializer);
    public static void WriteJsonImpl(JsonWriter jsonWriter, MetricNameWireModel value, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, MetricNameWireModel value, JsonSerializer serializer);
}
public class NewRelic.Agent.Core.JsonConverters.MetricWireModelCollectionJsonConverter : JsonConverter`1<MetricWireModelCollection> {
    public virtual MetricWireModelCollection ReadJson(JsonReader reader, Type objectType, MetricWireModelCollection existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, MetricWireModelCollection value, JsonSerializer serializer);
}
public class NewRelic.Agent.Core.JsonConverters.MetricWireModelJsonConverter : JsonConverter`1<MetricWireModel> {
    public virtual MetricWireModel ReadJson(JsonReader reader, Type objectType, MetricWireModel existingValue, bool hasExistingValue, JsonSerializer serializer);
    public static void WriteJsonImpl(JsonWriter jsonWriter, MetricWireModel value, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, MetricWireModel value, JsonSerializer serializer);
}
public class NewRelic.Agent.Core.JsonConverters.SpanEventWireModelSerializer : JsonConverter`1<ISpanEventWireModel> {
    public virtual ISpanEventWireModel ReadJson(JsonReader reader, Type objectType, ISpanEventWireModel existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, ISpanEventWireModel value, JsonSerializer serializer);
}
[AttributeUsageAttribute("384")]
public class NewRelic.Agent.Core.JsonConverters.TimeSpanSerializesAsMillisecondsAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class NewRelic.Agent.Core.JsonConverters.TimeSpanSerializesAsSecondsAttribute : Attribute {
}
public class NewRelic.Agent.Core.JsonConverters.ValidationConstraint`1 : object {
    private string _path;
    private bool _isRequired;
    private JTokenType _type;
    private int _requiredChildrenMinimum;
    private int _requiredChildrenMaximum;
    private Action`2<JToken, T> _parse;
    public ValidationConstraint`1(string path, JTokenType type, bool isRequired, int miniumChildren, int maximumChildren, Action`2<JToken, T> parse);
    public void ParseAndThrowOnFailure(JToken jObject, T parsedPayload);
}
public interface NewRelic.Agent.Core.Labels.ILabelsService {
    public IEnumerable`1<Label> Labels { get; }
    public abstract virtual IEnumerable`1<Label> get_Labels();
}
public class NewRelic.Agent.Core.Labels.Label : object {
    [JsonPropertyAttribute]
public string Type;
    [JsonPropertyAttribute]
public string Value;
    public Label(string labelType, string labelValue);
}
public class NewRelic.Agent.Core.Labels.LabelsService : object {
    private ILogger Log;
    private static int MaxLabels;
    private static int MaxLength;
    private IConfigurationService _configurationService;
    public IEnumerable`1<Label> Labels { get; }
    public LabelsService(IConfigurationService configurationService);
    public sealed virtual IEnumerable`1<Label> get_Labels();
    private IEnumerable`1<Label> GetLabelsFromConfiguration();
    private Label CreateLabelFromString(string typeAndValueString);
    private string Truncate(string value);
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.LinuxNativeMethods : object {
    private static string DllName;
    private static int ExternInstrumentationRefresh();
    private static int ExternReloadConfiguration();
    private static int ExternAddCustomInstrumentation(string fileName, string xml);
    private static int ExternApplyCustomInstrumentation();
    public sealed virtual int InstrumentationRefresh();
    public sealed virtual int ReloadConfiguration();
    public sealed virtual int AddCustomInstrumentation(string fileName, string xml);
    public sealed virtual int ApplyCustomInstrumentation();
    private static void ExternShutdownThreadProfiler();
    private static void ExternReleaseProfile();
    private static int ExternRequestProfile(IntPtr& snapshots, Int32& length);
    private static int ExternRequestFunctionNames(UIntPtr[] functionIds, int length, IntPtr& functionInfo);
    public sealed virtual void ReleaseProfile();
    public sealed virtual int RequestFunctionNames(UIntPtr[] functionIds, int length, IntPtr& functionInfo);
    public sealed virtual int RequestProfile(IntPtr& snapshots, Int32& length);
    public sealed virtual void ShutdownNativeThreadProfiler();
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.LoggerBootstrapper : object {
    private static string AuditLogLayout;
    private static string FileLogLayout;
    private static LoggingLevelSwitch _loggingLevelSwitch;
    private static InMemorySink _inMemorySink;
    private static LoggerBootstrapper();
    public static void SetLoggingLevel(string newLogLevel);
    public static void Initialize();
    public static void ConfigureLogger(ILogConfig config);
    private static void EchoInMemoryLogsToConfiguredLogger(ILogger configuredLogger);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureInMemoryLogSink(LoggerConfiguration loggerConfiguration);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureEventLogSink(LoggerConfiguration loggerConfiguration);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureDebugSink(LoggerConfiguration loggerConfiguration);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureConsoleSink(LoggerConfiguration loggerConfiguration);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureFileSink(LoggerConfiguration loggerConfiguration, ILogConfig config);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureAuditLogSink(LoggerConfiguration loggerConfiguration, ILogConfig config);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureRollingLogSink(LoggerConfiguration loggerConfiguration, string fileName, string outputFormat, ILogConfig config);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Logging.AuditLog : object {
    private static Lazy`1<ILogger> _lazyAuditLogger;
    [CompilerGeneratedAttribute]
private static bool <IsAuditLogEnabled>k__BackingField;
    public static bool IsAuditLogEnabled { get; public set; }
    private static AuditLog();
    [CompilerGeneratedAttribute]
public static bool get_IsAuditLogEnabled();
    [CompilerGeneratedAttribute]
public static void set_IsAuditLogEnabled(bool value);
    public static void ResetLazyLogger();
    private static Lazy`1<ILogger> LazyAuditLogger();
    public static void Log(string message);
    [ExtensionAttribute]
public static LoggerConfiguration IncludeOnlyAuditLog(LoggerConfiguration loggerConfiguration);
    [ExtensionAttribute]
public static LoggerConfiguration ExcludeAuditLog(LoggerConfiguration loggerConfiguration);
}
public class NewRelic.Agent.Core.Logging.InMemorySink : object {
    private ConcurrentQueue`1<LogEvent> _logEvents;
    public IEnumerable`1<LogEvent> LogEvents { get; }
    public sealed virtual void Emit(LogEvent logEvent);
    public IEnumerable`1<LogEvent> get_LogEvents();
    public void Clear();
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Logging.Logger : object {
    private ILogger _logger;
    public bool IsErrorEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsFinestEnabled { get; }
    public sealed virtual bool IsEnabledFor(Level level);
    public sealed virtual void Log(Level level, string message);
    public sealed virtual void Log(Level level, Exception ex, string message);
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual void Error(Exception exception, string message, Object[] args);
    public sealed virtual void Error(string message, Object[] args);
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual void Warn(Exception exception, string message, Object[] args);
    public sealed virtual void Warn(string message, Object[] args);
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual void Info(Exception exception, string message, Object[] args);
    public sealed virtual void Info(string message, Object[] args);
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual void Debug(Exception exception, string message, Object[] args);
    public sealed virtual void Debug(string message, Object[] args);
    public sealed virtual bool get_IsFinestEnabled();
    public sealed virtual void Finest(Exception exception, string message, Object[] args);
    public sealed virtual void Finest(string message, Object[] args);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.LogLevelExtensions : object {
    private static List`1<string> DeprecatedLogLevels;
    public static string AuditLevel;
    private static LogLevelExtensions();
    [ExtensionAttribute]
public static bool IsLogLevelDeprecated(string level);
    [ExtensionAttribute]
public static LogEventLevel MapToSerilogLogLevel(string configLogLevel);
    [ExtensionAttribute]
public static string TranslateLogLevel(LogEventLevel logEventLevel);
}
public static class NewRelic.Agent.Core.Metrics.ApdexStats : object {
    private static string ApdexPerfZoneSatisfying;
    private static string ApdexPerfZoneTolerating;
    private static string ApdexPerfZoneFrustrating;
    public static string GetApdexPerfZoneOrNull(Nullable`1<TimeSpan> responseTime, Nullable`1<TimeSpan> apdexT);
}
public enum NewRelic.Agent.Core.Metrics.ApiMethod : Enum {
    public int value__;
    public static ApiMethod CurrentTransaction;
    public static ApiMethod DisableBrowserMonitoring;
    public static ApiMethod GetBrowserTimingHeader;
    public static ApiMethod IgnoreApdex;
    public static ApiMethod IgnoreTransaction;
    public static ApiMethod IncrementCounter;
    public static ApiMethod NoticeError;
    public static ApiMethod RecordCustomEvent;
    public static ApiMethod RecordMetric;
    public static ApiMethod RecordResponseTimeMetric;
    public static ApiMethod SetApplicationName;
    public static ApiMethod SetTransactionName;
    public static ApiMethod SetUserParameters;
    public static ApiMethod GetBrowserTimingFooter;
    public static ApiMethod StartAgent;
    public static ApiMethod SetTransactionUri;
    public static ApiMethod TraceMetadata;
    public static ApiMethod GetLinkingMetadata;
    public static ApiMethod TransactionAddCustomAttribute;
    public static ApiMethod TransactionGetCurrentSpan;
    public static ApiMethod SpanAddCustomAttribute;
    public static ApiMethod InsertDistributedTraceHeaders;
    public static ApiMethod AcceptDistributedTraceHeaders;
    public static ApiMethod SpanSetName;
    public static ApiMethod SetErrorGroupCallback;
    public static ApiMethod SetUserId;
    public static ApiMethod StartDatastoreSegment;
    public static ApiMethod SetLlmTokenCountingCallback;
    public static ApiMethod RecordLlmFeedbackEvent;
}
public class NewRelic.Agent.Core.Metrics.ApiSupportabilityMetricCounters : object {
    private static String[] MetricNames;
    private static InterlockedCounter[] Counters;
    private IMetricBuilder _metricBuilder;
    private PublishMetricDelegate _publishMetricDelegate;
    private static ApiSupportabilityMetricCounters();
    public ApiSupportabilityMetricCounters(IMetricBuilder metricBuilder);
    public sealed virtual void Record(ApiMethod method);
    public sealed virtual void CollectMetrics();
    private bool TryGetCount(InterlockedCounter counter, Int32& metricCount);
    private void TrySend(MetricWireModel metric);
    public sealed virtual void RegisterPublishMetricHandler(PublishMetricDelegate publishMetricDelegate);
}
public enum NewRelic.Agent.Core.Metrics.CATSupportabilityCondition : Enum {
    public int value__;
    public static CATSupportabilityCondition Request_Create_Success;
    public static CATSupportabilityCondition Request_Create_Failure;
    public static CATSupportabilityCondition Request_Create_Failure_XProcID;
    public static CATSupportabilityCondition Request_Accept_Success;
    public static CATSupportabilityCondition Request_Accept_Failure;
    public static CATSupportabilityCondition Request_Accept_Failure_NotTrusted;
    public static CATSupportabilityCondition Request_Accept_Failure_Decode;
    public static CATSupportabilityCondition Request_Accept_Multiple;
    public static CATSupportabilityCondition Response_Create_Success;
    public static CATSupportabilityCondition Response_Create_Failure;
    public static CATSupportabilityCondition Response_Create_Failure_XProcID;
    public static CATSupportabilityCondition Response_Accept_Success;
    public static CATSupportabilityCondition Response_Accept_Failure;
    public static CATSupportabilityCondition Response_Accept_MultipleResponses;
}
public class NewRelic.Agent.Core.Metrics.CATSupportabilityMetricCounters : object {
    private Dictionary`2<CATSupportabilityCondition, InterlockedCounter> _counters;
    private PublishMetricDelegate _publishMetricDelegate;
    private IMetricBuilder _metricBuilder;
    public CATSupportabilityMetricCounters(IMetricBuilder metricBuilder);
    public sealed virtual void CollectMetrics();
    private void TrySend(MetricWireModel metric);
    private bool TryGetCount(InterlockedCounter counter, Int32& metricCount);
    public sealed virtual void Record(CATSupportabilityCondition condition);
    public sealed virtual void RegisterPublishMetricHandler(PublishMetricDelegate publishMetricDelegate);
}
public interface NewRelic.Agent.Core.Metrics.IApiSupportabilityMetricCounters {
    public abstract virtual void Record(ApiMethod method);
}
public interface NewRelic.Agent.Core.Metrics.ICATSupportabilityMetricCounters {
    public abstract virtual void Record(CATSupportabilityCondition condition);
}
public interface NewRelic.Agent.Core.Metrics.IMetricNameService {
    public abstract virtual string RenameMetric(string metricName);
    public abstract virtual string NormalizeUrl(string url);
    public abstract virtual TransactionMetricName RenameTransaction(TransactionMetricName proposedTransactionName);
    public abstract virtual Nullable`1<TimeSpan> TryGetApdex_t(string transactionName);
}
public abstract class NewRelic.Agent.Core.Metrics.MetricName : object {
    private int _hashCode;
    private int _length;
    private MetricName(int length, int hashCode);
    public static MetricName Create(string prefix, String[] segments);
    public static MetricName Create(string prefix, Object[] segments);
    public static MetricName Create(string name);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Metrics.MetricNames : object {
    public static string PathSeparator;
    public static string Controller;
    public static string Uri;
    public static string NormalizedUri;
    public static string All;
    public static string AllWeb;
    public static string AllOther;
    public static string Custom;
    public static string OtherTransactionPrefix;
    public static string WebTransactionPrefix;
    public static string SupportabilityPayloadsDroppedDueToMaxPayloadLimitPrefix;
    public static string KafkaMessageBrokerConsume;
    public static char PathSeparatorChar;
    public static Char[] PathSeparatorCharArray;
    public static MetricName Dispatcher;
    public static MetricName RequestQueueTime;
    private static Func`2<DatastoreVendor, MetricName> _databaseVendorAll;
    private static Func`2<DatastoreVendor, MetricName> _databaseVendorAllWeb;
    private static Func`2<DatastoreVendor, MetricName> _databaseVendorAllOther;
    private static Func`2<DatastoreVendor, Func`2<string, MetricName>> _databaseVendorOperations;
    public static string ApdexWeb;
    public static string ApdexOther;
    public static MetricName ApdexAll;
    public static MetricName ApdexAllWeb;
    public static MetricName ApdexAllOther;
    public static string Errors;
    public static string ErrorsExpected;
    public static MetricName ErrorsAll;
    public static MetricName ErrorsAllWeb;
    public static MetricName ErrorsAllOther;
    public static MetricName ErrorsExpectedAll;
    private static string DotNetInvocation;
    public static string Message;
    public static MetricName WebTransactionAll;
    public static MetricName OtherTransactionAll;
    public static MetricName WebTransactionTotalTimeAll;
    public static MetricName OtherTransactionTotalTimeAll;
    private static string CpuTimePrefix;
    public static string WebTransactionCpuTimeAll;
    public static string OtherTransactionCpuTimeAll;
    public static string MessageBrokerPrefix;
    public static string MessageBrokerNamed;
    public static string MessageBrokerTemp;
    public static string Msmq;
    public static string Serialization;
    private static string KakfaTopic;
    private static string KakfaReceived;
    private static string KakfaMessages;
    private static string Datastore;
    private static string DatastoreOperation;
    private static string DatastoreStatement;
    private static string DatastoreInstance;
    public static string DatastoreUnknownOperationName;
    public static MetricName DatastoreAll;
    public static MetricName DatastoreAllWeb;
    public static MetricName DatastoreAllOther;
    private static string External;
    public static MetricName ExternalAll;
    public static MetricName ExternalAllWeb;
    public static MetricName ExternalAllOther;
    private static string Supportability;
    private static string SupportabilityDotnetPs;
    private static string SupportabilityPs;
    private static string SupportabilityNetFrameworkVersionPs;
    private static string SupportabilityNetCoreVersionPs;
    public static string SupportabilityMetricHarvestTransmit;
    public static string SupportabilityRumHeaderRendered;
    public static string SupportabilityRumFooterRendered;
    public static string SupportabilityHtmlPageRendered;
    public static string SupportabilityThreadProfilingSampleCount;
    private static string SupportabilityTransactionEventsPs;
    public static string SupportabilityTransactionEventsSent;
    public static string SupportabilityTransactionEventsSeen;
    public static string SupportabilityTransactionEventsCollected;
    public static string SupportabilityTransactionEventsRecollected;
    public static string SupportabilityTransactionEventsReservoirResize;
    private static string SupportabilityEventsPs;
    private static string SupportabilityCustomEventsPs;
    private static string SupportabilityErrorEventsPs;
    public static string SupportabilityErrorEventsSent;
    public static string SupportabilityErrorEventsSeen;
    public static string SupportabilityCustomEventsSent;
    public static string SupportabilityCustomEventsSeen;
    public static string SupportabilityCustomEventsCollected;
    public static string SupportabilityCustomEventsRecollected;
    public static string SupportabilityCustomEventsReservoirResize;
    private static string SupportabilitySqlTracesPs;
    public static string SupportabilitySqlTracesSent;
    public static string SupportabilitySqlTracesRecollected;
    public static string SupportabilityCachePrefix;
    public static MetricName SupportabilitySqlTracesCollected;
    private static string SupportabilityErrorTracesPs;
    public static string SupportabilityErrorTracesSent;
    public static string SupportabilityErrorTracesCollected;
    public static string SupportabilityErrorTracesRecollected;
    private static string SupportabilityTransactionBuilderGarbageCollectedPs;
    public static string SupportabilityTransactionBuilderGarbageCollectedAll;
    public static string SupportabilityEventHarvestPs;
    public static string SupportabilityEventHarvestReportPeriod;
    private static string SupportabilityEventHarvestHarvestLimit;
    public static string SupportabilityEventHarvestErrorEventHarvestLimit;
    public static string SupportabilityEventHarvestCustomEventHarvestLimit;
    public static string SupportabilityEventHarvestTransactionEventHarvestLimit;
    private static string SupportabilityAgentVersionPs;
    private static string SupportabilityLibraryVersionPs;
    private static string SupportabilityUtilizationPs;
    private static string SupportabilityUtilizationBootIdError;
    private static string SupportabilityUtilizationKubernetesError;
    private static string SupportabilityUtilizationAwsError;
    private static string SupportabilityUtilizationAzureError;
    private static string SupportabilityUtilizationGcpError;
    private static string SupportabilityUtilizationPcfError;
    private static string SupportabilityFeatureEnabledPs;
    private static string SupportabilityAgentApiPs;
    private static string SupportabilityCAT;
    private static string SupportabilityCATRequest;
    private static string SupportabilityCATRequestCreate;
    private static string SupportabilityCATRequestAccept;
    private static string SupportabilityCATResponse;
    private static string SupportabilityCATResponseCreate;
    private static string SupportabilityCATResponseAccept;
    private static Dictionary`2<CATSupportabilityCondition, string> _catMetricNames;
    private static string SupportabilityDistributedTracePs;
    private static string SupportabilityDistributedTraceAcceptPayloadPs;
    private static string SupportabilityDistributedTraceCreatePayloadPs;
    private static string SupportabilityDistributedTraceAcceptPayloadIgnoredPs;
    public static string SupportabilityDistributedTraceAcceptPayloadSuccess;
    public static string SupportabilityDistributedTraceAcceptPayloadException;
    public static string SupportabilityDistributedTraceAcceptPayloadParseException;
    public static string SupportabilityDistributedTraceAcceptPayloadIgnoredCreateBeforeAccept;
    public static string SupportabilityDistributedTraceAcceptPayloadIgnoredMultiple;
    public static string SupportabilityDistributedTraceAcceptPayloadIgnoredMajorVersion;
    public static string SupportabilityDistributedTraceAcceptPayloadIgnoredNull;
    public static string SupportabilityDistributedTraceAcceptPayloadIgnoredUntrustedAccount;
    public static string SupportabilityDistributedTraceCreatePayloadSuccess;
    public static string SupportabilityDistributedTraceCreatePayloadException;
    private static string SupportabilityTraceContextPs;
    private static string SupportabilityTraceContextAcceptPs;
    private static string SupportabilityTraceContextCreatePs;
    private static string SupportabilityTraceContextTraceParentPs;
    private static string SupportabilityTraceContextTraceStatePs;
    public static string SupportabilityTraceContextAcceptSuccess;
    public static string SupportabilityTraceContextAcceptException;
    public static string SupportabilityTraceContextCreateSuccess;
    public static string SupportabilityTraceContextCreateException;
    public static string SupportabilityTraceContextTraceParentParseException;
    public static string SupportabilityTraceContextTraceStateParseException;
    public static string SupportabilityTraceContextTraceStateInvalidNrEntry;
    public static string SupportabilityTraceContextTraceStateNoNrEntry;
    private static string SupportabilityInstallTypePs;
    public static string SupportabilityAppDomainCachingDisabled;
    public static string SupportabilityLoggingDisabled;
    public static string SupportabilityLoggingFatalError;
    public static string SupportabilityIgnoredInstrumentation;
    private static string Unknown;
    private static string DistributedTraceDurationByCallerPs;
    private static string DistributedTraceErrorsByCallerPs;
    private static string DistributedTraceTransportDurationPs;
    private static string SpanEventsPs;
    public static string SupportabilitySpanEventsSent;
    public static string SupportabilitySpanEventsSeen;
    public static string SupportabilitySpanEventsLimit;
    private static string SupportabilityInfiniteTracing;
    private static string SupportabilityInfiniteTracingSpan;
    public static string SupportabilityInfiniteTracingSpanResponseError;
    public static string SupportabilityInfiniteTracingSpanAgentQueueDumped;
    public static string SupportabilityInfiniteTracingSpanSeen;
    public static string SupportabilityInfiniteTracingSpanSent;
    public static string SupportabilityInfiniteTracingSpanSentBatchSize;
    public static string SupportabilityInfiniteTracingSpanQueueSize;
    public static string SupportabilityInfiniteTracingSpanReceived;
    public static string SupportabilityInfiniteTracingSpanDropped;
    public static string SupportabilityInfiniteTracingSpanGrpcTimeout;
    private static string _memoryPrefix;
    public static string MemoryPhysical;
    public static string MemoryWorkingSet;
    public static string CpuUserUtilization;
    public static string CpuUserTime;
    public static string DotNetPerfThreadpool;
    public static string DotNetPerfThreadpoolThroughput;
    private static Dictionary`2<GCSampleType, string> _gcMetricNames;
    private static string dataUsageRoot;
    private static string outputBytesDecorator;
    private static string LoggingMetrics;
    private static string LoggingMetricsDotnetLines;
    private static string LoggingMetricsDotnetDenied;
    private static string SupportabilityLoggingEventsPs;
    public static string SupportabilityLoggingEventsSent;
    public static string SupportabilityLoggingEventsCollected;
    public static string SupportabilityLoggingEventsDropped;
    public static string SupportabilityLoggingEventEmpty;
    private static string Enabled;
    private static string Disabled;
    private static string Metrics;
    private static string Forwarding;
    private static string LocalDecorating;
    private static string DotNet;
    private static string SupportabilityLogMetricsConfigPs;
    private static string SupportabilityLogForwardingConfigPs;
    private static string SupportabilityLogDecoratingConfigPs;
    private static string SupportabilityLogFrameworkPs;
    private static string SupportabilityLogForwardingEnabledWithFrameworkNamePs;
    private static MetricNames();
    public static MetricName GetCustom(string suffix);
    private static Func`2<TEnum, TResult> GetEnumerationFunc(Func`2<TEnum, TResult> valueSupplier);
    private static string Join(String[] strings);
    public static MetricName GetApdexAllWebOrOther(bool isWebTransaction);
    public static string GetTransactionApdex(TransactionMetricName transactionMetricName);
    public static MetricName GetErrorTransaction(string transactionMetricName);
    public static MetricName GetDotNetInvocation(String[] segments);
    public static MetricName TransactionTotalTime(TransactionMetricName transactionMetricName);
    public static string TransactionCpuTime(TransactionMetricName transactionMetricName);
    public static MetricName GetMessageBroker(MessageBrokerDestinationType type, MessageBrokerAction action, string vendor, string queueName);
    public static MetricName GetMessageBrokerSerialization(MessageBrokerDestinationType type, MessageBrokerAction action, string vendor, string queueName, string kind);
    private static MessageBrokerDestinationType NormalizeMessageBrokerDestinationTypeForMetricName(MessageBrokerDestinationType type);
    public static MetricName GetKafkaMessagesReceivedPerConsume(string topic);
    [ExtensionAttribute]
public static MetricName GetDatastoreVendorAll(DatastoreVendor vendor);
    [ExtensionAttribute]
public static MetricName GetDatastoreVendorAllWeb(DatastoreVendor vendor);
    [ExtensionAttribute]
public static MetricName GetDatastoreVendorAllOther(DatastoreVendor vendor);
    [ExtensionAttribute]
public static MetricName GetDatastoreOperation(DatastoreVendor vendor, string operation);
    public static MetricName GetDatastoreStatement(DatastoreVendor vendor, string model, string operation);
    public static MetricName GetDatastoreInstance(DatastoreVendor vendor, string host, string portPathOrId);
    public static MetricName GetExternalHostRollup(string host);
    public static MetricName GetExternalHost(string host, string library, string operation);
    public static MetricName GetExternalErrors(string server);
    public static MetricName GetClientApplication(string crossProcessId);
    public static MetricName GetExternalApp(string host, string crossProcessId);
    public static MetricName GetExternalTransaction(string host, string crossProcessId, string transactionName);
    public static string GetSupportabilityAgentTimingMetric(string suffix);
    public static string GetSupportabilityCATConditionMetricName(CATSupportabilityCondition condition);
    public static string GetSupportabilityName(string metricName);
    public static string GetSupportabilityDotnetFrameworkVersion(DotnetFrameworkVersion version);
    public static string GetSupportabilityDotnetCoreVersion(DotnetCoreVersion version);
    public static string GetSupportabilityAgentVersion(string version);
    public static string GetSupportabilityAgentVersionByHost(string host, string version);
    public static string GetSupportabilityLibraryVersion(string assemblyName, string assemblyVersion);
    public static string GetSupportabilityLinuxOs();
    public static string GetSupportabilityBootIdError();
    public static string GetSupportabilityKubernetesUsabilityError();
    public static string GetSupportabilityAwsUsabilityError();
    public static string GetSupportabilityAzureUsabilityError();
    public static string GetSupportabilityGcpUsabilityError();
    public static string GetSupportabilityPcfUsabilityError();
    public static string GetSupportabilityPayloadsDroppedDueToMaxPayloadLimit(string endpoint);
    public static string GetSupportabilityAgentHealthEvent(AgentHealthEvent agentHealthEvent, string additionalData);
    public static string GetSupportabilityFeatureEnabled(string featureName);
    public static string GetSupportabilityAgentApi(string methodName);
    public static string GetSupportabilityErrorHttpStatusCodeFromCollector(HttpStatusCode statusCode);
    public static string GetSupportabilityEndpointMethodErrorAttempts(string enpointMethod);
    public static string GetSupportabilityEndpointMethodErrorDuration(string enpointMethod);
    public static string GetSupportabilityInstallType(string installType);
    private static string GetDistributedTraceMetricPrefix(string metricTag, string type, string accountId, string app, string transport);
    public static ValueTuple`2<MetricName, MetricName> GetDistributedTraceDurationByCaller(string type, string accountId, string app, string transport, bool isWeb);
    public static ValueTuple`2<MetricName, MetricName> GetDistributedTraceErrorsByCaller(string type, string accountId, string app, string transport, bool isWeb);
    public static ValueTuple`2<MetricName, MetricName> GetDistributedTraceTransportDuration(string type, string accountId, string app, string transport, bool isWeb);
    public static string SupportabilityInfiniteTracingSpanGrpcError(string error);
    public static string SupportabilityInfiniteTracingCompression(bool compressionEnabled);
    public static string GetThreadpoolUsageStatsName(ThreadType type, ThreadStatus status);
    public static string GetThreadpoolThroughputStatsName(ThreadpoolThroughputStatsType type);
    public static string GetGCMetricName(GCSampleType sampleType);
    public static string GetPerDestinationDataUsageMetricName(string destination);
    public static string GetPerDestinationAreaDataUsageMetricName(string destination, string destinationArea);
    public static string GetLoggingMetricsLinesBySeverityName(string logLevel);
    public static string GetLoggingMetricsLinesName();
    public static string GetLoggingMetricsDeniedBySeverityName(string logLevel);
    public static string GetLoggingMetricsDeniedName();
    public static string GetSupportabilityLogMetricsConfiguredName(bool enabled);
    public static string GetSupportabilityLogForwardingConfiguredName(bool enabled);
    public static string GetSupportabilityLogDecoratingConfiguredName(bool enabled);
    public static string GetSupportabilityLogFrameworkName(string loggingFramework);
    public static string GetSupportabilityLogForwardingEnabledWithFrameworkName(string loggingFramework);
}
public class NewRelic.Agent.Core.Metrics.MetricNameService : ConfigurationBasedService {
    public sealed virtual string NormalizeUrl(string url);
    public sealed virtual Nullable`1<TimeSpan> TryGetApdex_t(string transactionName);
    public sealed virtual TransactionMetricName RenameTransaction(TransactionMetricName proposedTransactionName);
    public sealed virtual string RenameMetric(string metricName);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    private static TransactionMetricName GetTransactionMetricName(string proposedPrefixedTransactionName, TransactionMetricName originalTransactionMetricName, bool shouldIgnore);
    private static string StripParameters(string url);
    private static string RenameUsingRegexRules(string input, IEnumerable`1<RegexRule> rules);
    private static string RenameUsingWhitelistRules(string metricName, IDictionary`2<string, IEnumerable`1<string>> whitelistRules);
    private static string FilterSegment(string segment, IEnumerable`1<string> allowedSegments);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Metrics.RegexRuleExtensions : object {
    [ExtensionAttribute]
public static RuleResult ApplyTo(RegexRule regexRule, string url);
    private static IEnumerable`1<string> GetChunks(string url, RegexRule regexRule);
    private static IEnumerable`1<string> ApplyRuleToChunks(RegexRule regexRule, IEnumerable`1<string> chunks, Boolean& anyChunkUpdated);
    private static RuleResult ApplyRuleToChunk(string chunk, RegexRule regexRule);
}
[NrExcludeFromCodeCoverageAttribute]
internal class NewRelic.Agent.Core.NrLogLevelEnricher : object {
    [NrExcludeFromCodeCoverageAttribute]
public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
[NrExcludeFromCodeCoverageAttribute]
internal class NewRelic.Agent.Core.ProcessIdEnricher : object {
    private static int _pid;
    private static LogEventProperty _prop;
    private static ProcessIdEnricher();
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
public class NewRelic.Agent.Core.Requests.GetCleanedAndFormattedSqlRequest : object {
    public string SqlStatement;
    public GetCleanedAndFormattedSqlRequest(string sqlStatement);
}
public class NewRelic.Agent.Core.Requests.GetCurrentConfigurationRequest : object {
}
[NrCoveredByIntegrationTestsAttribute]
public static class NewRelic.Agent.Core.RuntimeEnvironmentInfo : object {
    private static Lazy`1<Platform> _platform;
    private static Lazy`1<DistroInfo> _distroInfo;
    [CompilerGeneratedAttribute]
private static string <OperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystem>k__BackingField;
    public static string OperatingSystemVersion { get; }
    public static string OperatingSystem { get; }
    private static RuntimeEnvironmentInfo();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystemVersion();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystem();
    private static string GetOSName();
    private static string GetOSVersion();
    private static string GetFreeBSDVersion();
    private static Platform GetOSPlatform();
    private static string GetDistroId();
    private static string GetDistroVersionId();
    private static DistroInfo LoadDistroInfo();
    private static DistroInfo NormalizeDistroInfo(DistroInfo distroInfo);
    private static Platform DetermineOSPlatform();
}
public abstract class NewRelic.Agent.Core.Samplers.AbstractSampler : ConfigurationBasedService {
    private IScheduler _scheduler;
    private TimeSpan _frequency;
    protected bool Enabled { get; }
    protected AbstractSampler(IScheduler scheduler, TimeSpan frequency);
    protected virtual bool get_Enabled();
    public abstract virtual void Sample();
    public virtual void Dispose();
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    public virtual void Start();
    protected virtual void Stop();
}
public class NewRelic.Agent.Core.Samplers.CpuSampler : AbstractSampler {
    private ICpuSampleTransformer _cpuSampleTransformer;
    private int _processorCount;
    private DateTime _lastSampleTime;
    private TimeSpan _lastProcessorTime;
    private IProcessStatic _processStatic;
    private static int CpuSampleIntervalSeconds;
    public CpuSampler(IScheduler scheduler, ICpuSampleTransformer cpuSampleTransformer, IProcessStatic processStatic);
    public virtual void Sample();
    private TimeSpan GetCurrentUserProcessorTime();
}
public class NewRelic.Agent.Core.Samplers.GCEventsListener : SampledEventListener`1<Dictionary`2<GCSampleType, float>> {
    public static string DotNetEventSourceName;
    public static string EventSourceNameToMonitor;
    public static int GCKeyword;
    public static int EventID_GCStart;
    public static int EventID_GCHeapStats;
    private object _gen0Size;
    private object _gen0Promoted;
    private object _gen1Size;
    private object _gen1Promoted;
    private object _gen2Size;
    private object _gen2Promoted;
    private object _lohSize;
    private object _lohPromoted;
    private object _handlesCount;
    private InterlockedCounter _inducedCount;
    private InterlockedCounter[] _collectionCountPerGen;
    private static GCEventsListener();
    protected virtual void OnEventSourceCreated(EventSource eventSource);
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    private void ProcessEvent_GCStart(EventWrittenEventArgs eventArgs);
    private void ProcessEvent_GCHeapStats(EventWrittenEventArgs eventArgs);
    public virtual Dictionary`2<GCSampleType, float> Sample();
    public virtual void StartListening();
}
public class NewRelic.Agent.Core.Samplers.GcSampler : AbstractSampler {
    private static string GCPerfCounterCategoryName;
    private static int MaxConsecutiveFailuresBeforeDisable;
    private IGcSampleTransformer _transformer;
    private static int GcSampleIntervalSeconds;
    private IPerformanceCounterProxyFactory _pcProxyFactory;
    private int _countConsecutiveSamplingFailures;
    private string _perfCounterInstanceName;
    private static string LOG_PREFIX;
    private Dictionary`2<GCSampleType, string> _perfCounterNames;
    private Dictionary`2<GCSampleType, Func`2<IPerformanceCounterProxy, float>> _perfCounterValueHandlers;
    private Dictionary`2<GCSampleType, IPerformanceCounterProxy> _perfCounterProxies;
    private float _PrevGen0CollectionCount;
    private float _PrevGen1CollectionCount;
    private float _PrevGen2CollectionCount;
    private float _PrevInducedCount;
    public GcSampler(IScheduler scheduler, IGcSampleTransformer gcSampleTransformer, IPerformanceCounterProxyFactory pcProxyFactory);
    private float GetPerfCounterValue_Raw(IPerformanceCounterProxy proxy);
    private float GetPerfCounterValue_DeltaValue(IPerformanceCounterProxy proxy, Single& prevValue);
    private float GetPerfCounterValue_Gen0CollectionCount(IPerformanceCounterProxy proxy);
    private float GetPerfCounterValue_Gen1CollectionCount(IPerformanceCounterProxy proxy);
    private float GetPerfCounterValue_Gen2CollectionCount(IPerformanceCounterProxy proxy);
    private float GetPerfCounterValue_InducedCount(IPerformanceCounterProxy proxy);
    public virtual void Start();
    protected virtual void Stop();
    private void DisposeProxies(IEnumerable`1<IPerformanceCounterProxy> proxies);
    private int CreatePerfCounterProxies(string processInstanceName);
    private bool EnsurePerformanceCounters(string currentProcessInstanceName);
    private void HandleUnauthorizedException();
    private void HandleProblem();
    public virtual void Sample();
}
public class NewRelic.Agent.Core.Samplers.GCSamplerNetCore : AbstractSampler {
    private ISampledEventListener`1<Dictionary`2<GCSampleType, float>> _listener;
    private Func`1<ISampledEventListener`1<Dictionary`2<GCSampleType, float>>> _eventListenerFactory;
    private IGcSampleTransformer _transformer;
    private static int GCSampleNetCoreIntervalSeconds;
    private Func`1<SamplerIsApplicableToFrameworkResult> _fxSamplerIsApplicableToFramework;
    private static Nullable`1<bool> _fxSamplerIsApplicableToFrameworkDefaultValue;
    protected bool Enabled { get; }
    public GCSamplerNetCore(IScheduler scheduler, Func`1<ISampledEventListener`1<Dictionary`2<GCSampleType, float>>> eventListenerFactory, IGcSampleTransformer transformer, Func`1<SamplerIsApplicableToFrameworkResult> fxSamplerIsApplicableToFramework);
    protected virtual bool get_Enabled();
    public static SamplerIsApplicableToFrameworkResult FXsamplerIsApplicableToFrameworkDefault();
    public virtual void Sample();
    public virtual void Start();
    protected virtual void Stop();
    public virtual void Dispose();
}
public enum NewRelic.Agent.Core.Samplers.GCSampleType : Enum {
    public int value__;
    public static GCSampleType Gen0Size;
    public static GCSampleType Gen0Promoted;
    public static GCSampleType Gen1Size;
    public static GCSampleType Gen1Promoted;
    public static GCSampleType Gen2Size;
    public static GCSampleType Gen2Survived;
    public static GCSampleType LOHSize;
    public static GCSampleType LOHSurvived;
    public static GCSampleType HandlesCount;
    public static GCSampleType InducedCount;
    public static GCSampleType PercentTimeInGc;
    public static GCSampleType Gen0CollectionCount;
    public static GCSampleType Gen1CollectionCount;
    public static GCSampleType Gen2CollectionCount;
}
public class NewRelic.Agent.Core.Samplers.ImmutableCpuSample : object {
    public int ProcessorCount;
    public DateTime LastSampleTime;
    public TimeSpan LastUserProcessorTime;
    public DateTime CurrentSampleTime;
    public TimeSpan CurrentUserProcessorTime;
    public ImmutableCpuSample(int processorCount, DateTime lastSampleTime, TimeSpan lastUserProcessorTime, DateTime currentSampleTime, TimeSpan currentUserProcessorTime);
}
public class NewRelic.Agent.Core.Samplers.ImmutableMemorySample : object {
    public long MemoryPrivate;
    public long MemoryWorkingSet;
    public ImmutableMemorySample(long memoryPrivate, long memoryWorkingSet);
}
public interface NewRelic.Agent.Core.Samplers.ISampledEventListener`1 {
    public abstract virtual T Sample();
    public abstract virtual void StopListening();
    public abstract virtual void StartListening();
}
public class NewRelic.Agent.Core.Samplers.MemorySampler : AbstractSampler {
    private IMemorySampleTransformer _memorySampleTransformer;
    private IProcessStatic _processStatic;
    private static int MemorySampleIntervalSeconds;
    public MemorySampler(IScheduler scheduler, IMemorySampleTransformer memorySampleTransformer, IProcessStatic processStatic);
    public virtual void Sample();
    private long GetCurrentProcessPrivateMemorySize();
    private long GetCurrentProcessWorkingSet();
}
public abstract class NewRelic.Agent.Core.Samplers.SampledEventListener`1 : EventListener {
    public static object ListenerLock;
    protected EventSource _eventSource;
    private static SampledEventListener`1();
    public abstract virtual T Sample();
    public sealed virtual void StopListening();
    public abstract virtual void StartListening();
    public virtual void Dispose();
}
public class NewRelic.Agent.Core.Samplers.ThreadEventsListener : SampledEventListener`1<ThreadpoolThroughputEventsSample> {
    public static Guid ClrEventSourceId;
    public static Guid EventSourceIdToMonitor;
    public static int EventId_ThreadPoolDequeue;
    public static int EventId_ThreadPoolEnqueue;
    private static int _threadpool_Keyword;
    private int _countThreadRequestsQueued;
    private int _countThreadRequestsDequeued;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _threadRequestQueueLength;
    private static ThreadEventsListener();
    protected virtual void OnEventSourceCreated(EventSource eventSource);
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    public virtual ThreadpoolThroughputEventsSample Sample();
    public virtual void StartListening();
}
public class NewRelic.Agent.Core.Samplers.ThreadpoolThroughputEventsSample : object {
    public int CountThreadRequestsQueued;
    public int CountThreadRequestsDequeued;
    public int ThreadRequestQueueLength;
    public ThreadpoolThroughputEventsSample(int countThreadRequestsQueued, int countThreadRequestsDequeued, int threadRequestQueueLength);
}
public enum NewRelic.Agent.Core.Samplers.ThreadpoolThroughputStatsType : Enum {
    public int value__;
    public static ThreadpoolThroughputStatsType Requested;
    public static ThreadpoolThroughputStatsType Started;
    public static ThreadpoolThroughputStatsType QueueLength;
}
public class NewRelic.Agent.Core.Samplers.ThreadpoolUsageStatsSample : object {
    public int WorkerCountThreadsAvail;
    public int WorkerCountThreadsUsed;
    public int CompletionCountThreadsAvail;
    public int CompletionCountThreadsUsed;
    public ThreadpoolUsageStatsSample(int countWorkerThreadsMax, int countWorkerThreadAvail, int countCompletionThreadssMax, int countCompletionThreadsAvail);
}
public class NewRelic.Agent.Core.Samplers.ThreadStatsSampler : AbstractSampler {
    public ISampledEventListener`1<ThreadpoolThroughputEventsSample> _listener;
    private Func`1<ISampledEventListener`1<ThreadpoolThroughputEventsSample>> _threadListenerFactory;
    private IThreadStatsSampleTransformer _transformer;
    private static int ThreadStatsSampleIntervalSeconds;
    private IThreadPoolStatic _threadPoolProxy;
    public ThreadStatsSampler(IScheduler scheduler, Func`1<ISampledEventListener`1<ThreadpoolThroughputEventsSample>> threadEventListenerFactory, IThreadStatsSampleTransformer threadpoolStatsTransformer, IThreadPoolStatic threadpoolProxy);
    public virtual void Sample();
    public virtual void Start();
    protected virtual void Stop();
    public virtual void Dispose();
}
public enum NewRelic.Agent.Core.Samplers.ThreadStatus : Enum {
    public int value__;
    public static ThreadStatus Available;
    public static ThreadStatus InUse;
}
public enum NewRelic.Agent.Core.Samplers.ThreadType : Enum {
    public int value__;
    public static ThreadType Worker;
    public static ThreadType Completion;
}
public abstract class NewRelic.Agent.Core.Segments.AbstractSegmentData : object {
    protected ISegmentDataState _segmentState;
    protected IAttributeDefinitions AttribDefs { get; }
    public SpanCategory SpanCategory { get; }
    protected IAttributeDefinitions get_AttribDefs();
    public virtual SpanCategory get_SpanCategory();
    public void AttachSegmentDataState(ISegmentDataState segmentState);
    internal virtual IEnumerable`1<KeyValuePair`2<string, object>> Finish();
    public abstract virtual bool IsCombinableWith(AbstractSegmentData otherData);
    public abstract virtual string GetTransactionTraceName();
    public abstract virtual void AddMetricStats(Segment segment, TimeSpan durationOfChildren, TransactionMetricStatsCollection txStats, IConfigurationService configService);
    public virtual void SetSpanTypeSpecificAttributes(SpanAttributeValueCollection attribVals);
    internal virtual void AddTransactionTraceParameters(IConfigurationService configurationService, Segment segment, IDictionary`2<string, object> segmentParameters, ImmutableTransaction immutableTransaction);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class NewRelic.Agent.Core.Segments.AttributeValue : object {
    private AttributeDefinition _attributeDefinition;
    [CompilerGeneratedAttribute]
private bool <IsImmutable>k__BackingField;
    private Lazy`1<object> _lazyValue;
    private static MessageParser`1<AttributeValue> _parser;
    private UnknownFieldSet _unknownFields;
    public static int StringValueFieldNumber;
    public static int BoolValueFieldNumber;
    public static int IntValueFieldNumber;
    public static int DoubleValueFieldNumber;
    private object value_;
    private ValueOneofCase valueCase_;
    public AttributeDefinition AttributeDefinition { get; }
    public bool IsImmutable { get; private set; }
    public Lazy`1<object> LazyValue { get; public set; }
    public object Value { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<AttributeValue> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string StringValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasStringValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool BoolValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasBoolValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public long IntValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasIntValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public double DoubleValue { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public bool HasDoubleValue { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ValueOneofCase ValueCase { get; }
    public AttributeValue(AttributeDefinition attributeDefinition);
    public AttributeValue(IAttributeValue attribValue);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public AttributeValue(AttributeValue other);
    private static AttributeValue();
    public sealed virtual AttributeDefinition get_AttributeDefinition();
    [CompilerGeneratedAttribute]
public bool get_IsImmutable();
    [CompilerGeneratedAttribute]
private void set_IsImmutable(bool value);
    public sealed virtual Lazy`1<object> get_LazyValue();
    public sealed virtual void set_LazyValue(Lazy`1<object> value);
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    public sealed virtual void MakeImmutable();
    private void SetValue(Lazy`1<object> lazyValue);
    private void SetValue(object value);
    public static MessageParser`1<AttributeValue> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual AttributeValue Clone();
    public string get_StringValue();
    public void set_StringValue(string value);
    public bool get_HasStringValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearStringValue();
    public bool get_BoolValue();
    public void set_BoolValue(bool value);
    public bool get_HasBoolValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearBoolValue();
    public long get_IntValue();
    public void set_IntValue(long value);
    public bool get_HasIntValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearIntValue();
    public double get_DoubleValue();
    public void set_DoubleValue(double value);
    public bool get_HasDoubleValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearDoubleValue();
    public ValueOneofCase get_ValueCase();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public void ClearValue();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(AttributeValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(AttributeValue other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
public class NewRelic.Agent.Core.Segments.CustomSegmentData : AbstractSegmentData {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public CustomSegmentData(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual bool IsCombinableWith(AbstractSegmentData otherData);
    public virtual string GetTransactionTraceName();
    public virtual void AddMetricStats(Segment segment, TimeSpan durationOfChildren, TransactionMetricStatsCollection txStats, IConfigurationService configService);
}
public class NewRelic.Agent.Core.Segments.DatastoreSegmentData : AbstractSegmentData {
    private static ConnectionInfo EmptyConnectionInfo;
    [CompilerGeneratedAttribute]
private string <CommandText>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <GetExplainPlanResources>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, ExplainPlan> <GenerateExplainPlan>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<bool> <DoExplainPlanCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IConvertible> <QueryParameters>k__BackingField;
    private object _explainPlanResources;
    private ExplainPlan _explainPlan;
    private ConnectionInfo _connectionInfo;
    private ParsedSqlStatement _parsedSqlStatement;
    private IDatabaseService _databaseService;
    public SpanCategory SpanCategory { get; }
    public string Operation { get; }
    public DatastoreVendor DatastoreVendorName { get; }
    public string Model { get; }
    public string CommandText { get; public set; }
    public string Vendor { get; }
    public string Host { get; }
    public Nullable`1<int> Port { get; }
    public string PathOrId { get; }
    public string PortPathOrId { get; }
    public string DatabaseName { get; }
    public Func`1<object> GetExplainPlanResources { get; public set; }
    public Func`2<object, ExplainPlan> GenerateExplainPlan { get; public set; }
    public Func`1<bool> DoExplainPlanCondition { get; public set; }
    public IDictionary`2<string, IConvertible> QueryParameters { get; public set; }
    public ExplainPlan ExplainPlan { get; }
    public DatastoreSegmentData(IDatabaseService databaseService, ParsedSqlStatement parsedSqlStatement, string commandText, ConnectionInfo connectionInfo, IDictionary`2<string, IConvertible> queryParameters);
    private static DatastoreSegmentData();
    public virtual SpanCategory get_SpanCategory();
    public string get_Operation();
    public DatastoreVendor get_DatastoreVendorName();
    public string get_Model();
    [CompilerGeneratedAttribute]
public string get_CommandText();
    [CompilerGeneratedAttribute]
public void set_CommandText(string value);
    public string get_Vendor();
    public string get_Host();
    public Nullable`1<int> get_Port();
    public string get_PathOrId();
    public string get_PortPathOrId();
    public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public Func`1<object> get_GetExplainPlanResources();
    [CompilerGeneratedAttribute]
public void set_GetExplainPlanResources(Func`1<object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, ExplainPlan> get_GenerateExplainPlan();
    [CompilerGeneratedAttribute]
public void set_GenerateExplainPlan(Func`2<object, ExplainPlan> value);
    [CompilerGeneratedAttribute]
public Func`1<bool> get_DoExplainPlanCondition();
    [CompilerGeneratedAttribute]
public void set_DoExplainPlanCondition(Func`1<bool> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IConvertible> get_QueryParameters();
    [CompilerGeneratedAttribute]
public void set_QueryParameters(IDictionary`2<string, IConvertible> value);
    public ExplainPlan get_ExplainPlan();
    internal virtual void AddTransactionTraceParameters(IConfigurationService configurationService, Segment segment, IDictionary`2<string, object> segmentParameters, ImmutableTransaction immutableTransaction);
    internal virtual IEnumerable`1<KeyValuePair`2<string, object>> Finish();
    public void ExecuteExplainPlan(SqlObfuscator obfuscator);
    public virtual bool IsCombinableWith(AbstractSegmentData otherSegment);
    public virtual string GetTransactionTraceName();
    public virtual void AddMetricStats(Segment segment, TimeSpan durationOfChildren, TransactionMetricStatsCollection txStats, IConfigurationService configService);
    private string GetObfuscatedSQL();
    public virtual void SetSpanTypeSpecificAttributes(SpanAttributeValueCollection attribVals);
    public sealed virtual void SetConnectionInfo(ConnectionInfo connInfo);
}
public class NewRelic.Agent.Core.Segments.ExternalSegmentData : AbstractSegmentData {
    private static string TransactionGuidSegmentParameterKey;
    private Nullable`1<int> _httpStatusCode;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private CrossApplicationResponseData <CrossApplicationResponseData>k__BackingField;
    public SpanCategory SpanCategory { get; }
    public Uri Uri { get; }
    public string Method { get; }
    public string Type { get; }
    public CrossApplicationResponseData CrossApplicationResponseData { get; public set; }
    public ExternalSegmentData(Uri uri, string method, CrossApplicationResponseData crossApplicationResponseData);
    public virtual SpanCategory get_SpanCategory();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public CrossApplicationResponseData get_CrossApplicationResponseData();
    [CompilerGeneratedAttribute]
public void set_CrossApplicationResponseData(CrossApplicationResponseData value);
    public sealed virtual void SetHttpStatusCode(int httpStatusCode);
    internal virtual IEnumerable`1<KeyValuePair`2<string, object>> Finish();
    public virtual void AddMetricStats(Segment segment, TimeSpan durationOfChildren, TransactionMetricStatsCollection txStats, IConfigurationService configService);
    public virtual void SetSpanTypeSpecificAttributes(SpanAttributeValueCollection attribVals);
    public virtual string GetTransactionTraceName();
    public virtual bool IsCombinableWith(AbstractSegmentData otherData);
}
public interface NewRelic.Agent.Core.Segments.IInternalSpan {
    public ErrorData ErrorData { get; public set; }
    public abstract virtual ErrorData get_ErrorData();
    public abstract virtual void set_ErrorData(ErrorData value);
}
public static class NewRelic.Agent.Core.Segments.IngestService : object {
    private static string __ServiceName;
    [GeneratedCodeAttribute("grpc_csharp_plugin", "")]
private static Marshaller`1<Span> __Marshaller_com_newrelic_trace_v1_Span;
    [GeneratedCodeAttribute("grpc_csharp_plugin", "")]
private static Marshaller`1<RecordStatus> __Marshaller_com_newrelic_trace_v1_RecordStatus;
    [GeneratedCodeAttribute("grpc_csharp_plugin", "")]
private static Marshaller`1<SpanBatch> __Marshaller_com_newrelic_trace_v1_SpanBatch;
    [GeneratedCodeAttribute("grpc_csharp_plugin", "")]
private static Method`2<Span, RecordStatus> __Method_RecordSpan;
    [GeneratedCodeAttribute("grpc_csharp_plugin", "")]
private static Method`2<SpanBatch, RecordStatus> __Method_RecordSpanBatch;
    public static ServiceDescriptor Descriptor { get; }
    private static IngestService();
    [GeneratedCodeAttribute("grpc_csharp_plugin", "")]
private static void __Helper_SerializeMessage(IMessage message, SerializationContext context);
    [GeneratedCodeAttribute("grpc_csharp_plugin", "")]
private static T __Helper_DeserializeMessage(DeserializationContext context, MessageParser`1<T> parser);
    public static ServiceDescriptor get_Descriptor();
}
public interface NewRelic.Agent.Core.Segments.ISegmentDataState {
    public IAttributeDefinitions AttribDefs { get; }
    public string TypeName { get; }
    public abstract virtual IAttributeDefinitions get_AttribDefs();
    public abstract virtual string get_TypeName();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.SpanEventWireModelSerializer")]
public interface NewRelic.Agent.Core.Segments.ISpanEventWireModel {
    public Span Span { get; }
    public abstract virtual Span get_Span();
}
public class NewRelic.Agent.Core.Segments.MessageBrokerSegmentData : AbstractSegmentData {
    private static string TransactionGuidSegmentParameterKey;
    [CompilerGeneratedAttribute]
private string <Vendor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageBrokerDestinationType <DestinationType>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageBrokerAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessagingSystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ServerPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public string Vendor { get; public set; }
    public string Destination { get; public set; }
    public MessageBrokerDestinationType DestinationType { get; public set; }
    public MessageBrokerAction Action { get; public set; }
    public string MessagingSystemName { get; public set; }
    public string CloudAccountId { get; public set; }
    public string CloudRegion { get; public set; }
    public string ServerAddress { get; public set; }
    public Nullable`1<int> ServerPort { get; public set; }
    public string RoutingKey { get; public set; }
    public MessageBrokerSegmentData(string vendor, string destination, MessageBrokerDestinationType destinationType, MessageBrokerAction action, string messagingSystemName, string cloudAccountId, string cloudRegion, string serverAddress, Nullable`1<int> serverPort, string routingKey);
    [CompilerGeneratedAttribute]
public string get_Vendor();
    [CompilerGeneratedAttribute]
public void set_Vendor(string value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public MessageBrokerDestinationType get_DestinationType();
    [CompilerGeneratedAttribute]
public void set_DestinationType(MessageBrokerDestinationType value);
    [CompilerGeneratedAttribute]
public MessageBrokerAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(MessageBrokerAction value);
    [CompilerGeneratedAttribute]
public string get_MessagingSystemName();
    [CompilerGeneratedAttribute]
public void set_MessagingSystemName(string value);
    [CompilerGeneratedAttribute]
public string get_CloudAccountId();
    [CompilerGeneratedAttribute]
public void set_CloudAccountId(string value);
    [CompilerGeneratedAttribute]
public string get_CloudRegion();
    [CompilerGeneratedAttribute]
public void set_CloudRegion(string value);
    [CompilerGeneratedAttribute]
public string get_ServerAddress();
    [CompilerGeneratedAttribute]
public void set_ServerAddress(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ServerPort();
    [CompilerGeneratedAttribute]
public void set_ServerPort(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
public void set_RoutingKey(string value);
    public virtual bool IsCombinableWith(AbstractSegmentData otherData);
    public virtual string GetTransactionTraceName();
    public virtual void AddMetricStats(Segment segment, TimeSpan durationOfChildren, TransactionMetricStatsCollection txStats, IConfigurationService configService);
    public virtual void SetSpanTypeSpecificAttributes(SpanAttributeValueCollection attribVals);
}
public class NewRelic.Agent.Core.Segments.MessageBrokerSerializationSegmentData : AbstractSegmentData {
    private static string TransactionGuidSegmentParameterKey;
    [CompilerGeneratedAttribute]
private string <Vendor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageBrokerDestinationType <DestinationType>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageBrokerAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    public string Vendor { get; public set; }
    public string Destination { get; public set; }
    public MessageBrokerDestinationType DestinationType { get; public set; }
    public MessageBrokerAction Action { get; public set; }
    public string Kind { get; public set; }
    public MessageBrokerSerializationSegmentData(string vendor, string destination, MessageBrokerDestinationType destinationType, MessageBrokerAction action, string kind);
    [CompilerGeneratedAttribute]
public string get_Vendor();
    [CompilerGeneratedAttribute]
public void set_Vendor(string value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public MessageBrokerDestinationType get_DestinationType();
    [CompilerGeneratedAttribute]
public void set_DestinationType(MessageBrokerDestinationType value);
    [CompilerGeneratedAttribute]
public MessageBrokerAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(MessageBrokerAction value);
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(string value);
    public virtual bool IsCombinableWith(AbstractSegmentData otherData);
    public virtual string GetTransactionTraceName();
    public virtual void AddMetricStats(Segment segment, TimeSpan durationOfChildren, TransactionMetricStatsCollection txStats, IConfigurationService configService);
}
public class NewRelic.Agent.Core.Segments.MethodSegmentData : AbstractSegmentData {
    private string _typeName;
    private string _methodName;
    public string Type { get; }
    public string Method { get; }
    public MethodSegmentData(string typeName, string methodName);
    public string get_Type();
    public string get_Method();
    public virtual bool IsCombinableWith(AbstractSegmentData otherData);
    public virtual string GetTransactionTraceName();
    public virtual void AddMetricStats(Segment segment, TimeSpan durationOfChildren, TransactionMetricStatsCollection txStats, IConfigurationService configService);
}
public class NewRelic.Agent.Core.Segments.NoOpSegment : object {
    private static ISegmentData _noOpSegmentDataImpl;
    private static SpanAttributeValueCollection _attribValCollectionImpl;
    private IAttributeDefinitions _attribDefs;
    [CompilerGeneratedAttribute]
private bool <DurationShouldBeDeductedFromParent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysDeductChildDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SegmentNameOverride>k__BackingField;
    private ISegmentData _noOpSegmentData { get; }
    private SpanAttributeValueCollection _attribValCollection { get; }
    public bool IsDone { get; }
    public bool IsValid { get; }
    public bool DurationShouldBeDeductedFromParent { get; public set; }
    private bool AlwaysDeductChildDuration { get; public set; }
    public bool IsLeaf { get; }
    public bool IsExternal { get; }
    public string SpanId { get; }
    public ISegmentData SegmentData { get; }
    public IAttributeDefinitions AttribDefs { get; }
    public SpanAttributeValueCollection AttribValues { get; }
    public string TypeName { get; }
    public string UserCodeFunction { get; public set; }
    public string UserCodeNamespace { get; public set; }
    public string SegmentNameOverride { get; public set; }
    public TimeSpan DurationOrZero { get; }
    private ISegmentData get__noOpSegmentData();
    private SpanAttributeValueCollection get__attribValCollection();
    public sealed virtual bool get_IsDone();
    public sealed virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DurationShouldBeDeductedFromParent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DurationShouldBeDeductedFromParent(bool value);
    [CompilerGeneratedAttribute]
private bool get_AlwaysDeductChildDuration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AlwaysDeductChildDuration(bool value);
    public sealed virtual bool get_IsLeaf();
    public sealed virtual bool get_IsExternal();
    public sealed virtual string get_SpanId();
    public sealed virtual ISegmentData get_SegmentData();
    public sealed virtual IAttributeDefinitions get_AttribDefs();
    public SpanAttributeValueCollection get_AttribValues();
    public sealed virtual string get_TypeName();
    public sealed virtual string get_UserCodeFunction();
    public sealed virtual void set_UserCodeFunction(string value);
    public sealed virtual string get_UserCodeNamespace();
    public sealed virtual void set_UserCodeNamespace(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SegmentNameOverride();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SegmentNameOverride(string value);
    public sealed virtual void End();
    public sealed virtual void End(Exception ex);
    public sealed virtual void EndStackExchangeRedis();
    public sealed virtual void MakeCombinable();
    public sealed virtual ISegmentExperimental MakeLeaf();
    public sealed virtual void RemoveSegmentFromCallStack();
    public sealed virtual void SetMessageBrokerDestination(string destination);
    public sealed virtual ISegmentExperimental SetSegmentData(ISegmentData segmentData);
    public sealed virtual ISpan AddCustomAttribute(string key, object value);
    public sealed virtual ISpan SetName(string name);
    public sealed virtual string GetCategory();
    public sealed virtual TimeSpan get_DurationOrZero();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class NewRelic.Agent.Core.Segments.RecordStatus : object {
    private static MessageParser`1<RecordStatus> _parser;
    private UnknownFieldSet _unknownFields;
    public static int MessagesSeenFieldNumber;
    private ulong messagesSeen_;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<RecordStatus> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public ulong MessagesSeen { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RecordStatus(RecordStatus other);
    private static RecordStatus();
    public static MessageParser`1<RecordStatus> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual RecordStatus Clone();
    public ulong get_MessagesSeen();
    public void set_MessagesSeen(ulong value);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(RecordStatus other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(RecordStatus other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
public class NewRelic.Agent.Core.Segments.Segment : object {
    private static ConfigurationSubscriber _configurationSubscriber;
    private SpanAttributeValueCollection _customAttribValues;
    [CompilerGeneratedAttribute]
private bool <DurationShouldBeDeductedFromParent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysDeductChildDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLeaf>k__BackingField;
    private string _spanId;
    private static long NoEndTime;
    internal static NoOpSegment NoOpSegment;
    protected static IEnumerable`1<KeyValuePair`2<string, object>> EmptyImmutableParameters;
    private ITransactionSegmentState _transactionSegmentState;
    protected IEnumerable`1<KeyValuePair`2<string, object>> _parameters;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _parentNotified;
    private long _childDurationTicks;
    private long _relativeEndTicks;
    [CompilerGeneratedAttribute]
private AbstractSegmentData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unfinished>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorData <ErrorData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Combinable>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodCallData <MethodCallData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ParentUniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RelativeStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserCodeNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserCodeFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SegmentNameOverride>k__BackingField;
    private object _customAttribValuesSyncRoot;
    public IAttributeDefinitions AttribDefs { get; }
    public string TypeName { get; }
    public bool IsDone { get; }
    public bool IsValid { get; }
    public bool DurationShouldBeDeductedFromParent { get; public set; }
    private bool AlwaysDeductChildDuration { get; public set; }
    public bool IsLeaf { get; public set; }
    public bool IsExternal { get; }
    public string SpanId { get; public set; }
    public AbstractSegmentData Data { get; private set; }
    public ISegmentData SegmentData { get; }
    public int ThreadId { get; private set; }
    public bool IsAsync { get; private set; }
    public bool Unfinished { get; private set; }
    public IEnumerable`1<KeyValuePair`2<string, object>> Parameters { get; }
    public ErrorData ErrorData { get; public set; }
    public bool Combinable { get; public set; }
    public MethodCallData MethodCallData { get; private set; }
    public Nullable`1<int> ParentUniqueId { get; }
    public int UniqueId { get; }
    public TimeSpan RelativeStartTime { get; private set; }
    public Nullable`1<TimeSpan> RelativeEndTime { get; private set; }
    public TimeSpan CalculatedRelativeEndTime { get; }
    public TimeSpan DurationOrZero { get; }
    public Nullable`1<TimeSpan> Duration { get; }
    public TimeSpan TotalChildDuration { get; }
    public TimeSpan ExclusiveDurationOrZero { get; }
    public string UserCodeNamespace { get; public set; }
    public string UserCodeFunction { get; public set; }
    public string SegmentNameOverride { get; public set; }
    public Segment(ITransactionSegmentState transactionSegmentState, MethodCallData methodCallData);
    public Segment(ITransactionSegmentState transactionSegmentState, MethodCallData methodCallData, TimeSpan relativeStartTime, TimeSpan relativeEndTime);
    public Segment(TimeSpan relativeStartTime, Nullable`1<TimeSpan> duration, Segment segment, IEnumerable`1<KeyValuePair`2<string, object>> parameters);
    private static Segment();
    public sealed virtual IAttributeDefinitions get_AttribDefs();
    public sealed virtual string get_TypeName();
    public sealed virtual bool get_IsDone();
    public sealed virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DurationShouldBeDeductedFromParent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DurationShouldBeDeductedFromParent(bool value);
    [CompilerGeneratedAttribute]
private bool get_AlwaysDeductChildDuration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AlwaysDeductChildDuration(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLeaf();
    [CompilerGeneratedAttribute]
public void set_IsLeaf(bool value);
    public sealed virtual bool get_IsExternal();
    public sealed virtual string get_SpanId();
    public void set_SpanId(string value);
    public sealed virtual void End();
    private void Finish();
    public sealed virtual void EndStackExchangeRedis();
    public sealed virtual void End(Exception ex);
    public sealed virtual void MakeCombinable();
    public sealed virtual void RemoveSegmentFromCallStack();
    public sealed virtual void SetMessageBrokerDestination(string destination);
    [CompilerGeneratedAttribute]
public AbstractSegmentData get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(AbstractSegmentData value);
    public sealed virtual ISegmentData get_SegmentData();
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
private void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public bool get_IsAsync();
    [CompilerGeneratedAttribute]
private void set_IsAsync(bool value);
    [CompilerGeneratedAttribute]
public bool get_Unfinished();
    [CompilerGeneratedAttribute]
private void set_Unfinished(bool value);
    public IEnumerable`1<KeyValuePair`2<string, object>> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual ErrorData get_ErrorData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ErrorData(ErrorData value);
    [CompilerGeneratedAttribute]
public bool get_Combinable();
    [CompilerGeneratedAttribute]
public void set_Combinable(bool value);
    [CompilerGeneratedAttribute]
public MethodCallData get_MethodCallData();
    [CompilerGeneratedAttribute]
private void set_MethodCallData(MethodCallData value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ParentUniqueId();
    [CompilerGeneratedAttribute]
public int get_UniqueId();
    [CompilerGeneratedAttribute]
public TimeSpan get_RelativeStartTime();
    [CompilerGeneratedAttribute]
private void set_RelativeStartTime(TimeSpan value);
    public Nullable`1<TimeSpan> get_RelativeEndTime();
    private void set_RelativeEndTime(Nullable`1<TimeSpan> value);
    public TimeSpan get_CalculatedRelativeEndTime();
    public sealed virtual TimeSpan get_DurationOrZero();
    public Nullable`1<TimeSpan> get_Duration();
    public TimeSpan get_TotalChildDuration();
    public TimeSpan get_ExclusiveDurationOrZero();
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserCodeNamespace();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserCodeNamespace(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserCodeFunction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserCodeFunction(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SegmentNameOverride();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SegmentNameOverride(string value);
    public SpanAttributeValueCollection GetAttributeValues();
    public void ForceEnd();
    public void ChildFinished(Segment childSegment);
    public void AddMetricStats(TransactionMetricStatsCollection txStats, IConfigurationService configService);
    public string GetTransactionTraceName();
    public bool IsCombinableWith(Segment otherSegment);
    public Segment CreateSimilar(TimeSpan newRelativeStartTime, TimeSpan newDuration, IEnumerable`1<KeyValuePair`2<string, object>> newParameters);
    public string ToStringForFinestLogging();
    public sealed virtual ISegmentExperimental SetSegmentData(ISegmentData segmentData);
    public sealed virtual ISegmentExperimental MakeLeaf();
    public sealed virtual ISpan AddCustomAttribute(string key, object value);
    public sealed virtual ISpan SetName(string name);
    public sealed virtual string GetCategory();
}
public class NewRelic.Agent.Core.Segments.SimpleSegmentData : AbstractSegmentData {
    private string _name;
    public string Name { get; }
    public SimpleSegmentData(string name);
    public string get_Name();
    public virtual bool IsCombinableWith(AbstractSegmentData otherData);
    public virtual string GetTransactionTraceName();
    public virtual void AddMetricStats(Segment segment, TimeSpan durationOfChildren, TransactionMetricStatsCollection txStats, IConfigurationService configService);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class NewRelic.Agent.Core.Segments.Span : object {
    [CompilerGeneratedAttribute]
private string <SpanId>k__BackingField;
    private static MessageParser`1<Span> _parser;
    private UnknownFieldSet _unknownFields;
    public static int TraceIdFieldNumber;
    private string traceId_;
    public static int IntrinsicsFieldNumber;
    private static Codec<string, AttributeValue> _map_intrinsics_codec;
    private MapField`2<string, AttributeValue> intrinsics_;
    public static int UserAttributesFieldNumber;
    private static Codec<string, AttributeValue> _map_userAttributes_codec;
    private MapField`2<string, AttributeValue> userAttributes_;
    public static int AgentAttributesFieldNumber;
    private static Codec<string, AttributeValue> _map_agentAttributes_codec;
    private MapField`2<string, AttributeValue> agentAttributes_;
    public string SpanId { get; public set; }
    public string DisplayName { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<Span> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public string TraceId { get; public set; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MapField`2<string, AttributeValue> Intrinsics { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MapField`2<string, AttributeValue> UserAttributes { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public MapField`2<string, AttributeValue> AgentAttributes { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public Span(Span other);
    private static Span();
    [CompilerGeneratedAttribute]
public string get_SpanId();
    [CompilerGeneratedAttribute]
public void set_SpanId(string value);
    public sealed virtual string get_DisplayName();
    public static MessageParser`1<Span> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual Span Clone();
    public string get_TraceId();
    public void set_TraceId(string value);
    public MapField`2<string, AttributeValue> get_Intrinsics();
    public MapField`2<string, AttributeValue> get_UserAttributes();
    public MapField`2<string, AttributeValue> get_AgentAttributes();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(Span other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(Span other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
public class NewRelic.Agent.Core.Segments.SpanAttributeValueCollection : AttributeValueCollectionBase`1<AttributeValue> {
    [CompilerGeneratedAttribute]
private float <Priority>k__BackingField;
    private Dictionary`2<AttributeClassification, object> _lockObjects;
    private Span _span;
    public float Priority { get; public set; }
    public Span Span { get; }
    [CompilerGeneratedAttribute]
public sealed virtual float get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(float value);
    public sealed virtual Span get_Span();
    protected virtual IEnumerable`1<AttributeValue> GetAttribValuesImpl(AttributeClassification classification);
    public virtual bool CollectionContainsAttribute(AttributeDefinition attrDef);
    protected virtual bool SetValueImpl(IAttributeValue value);
    protected virtual bool SetValueImpl(AttributeDefinition attribDef, object value);
    protected virtual bool SetValueImpl(AttributeDefinition attribDef, Lazy`1<object> lazyValue);
    protected virtual void RemoveItemsImpl(IEnumerable`1<AttributeValue> itemsToRemove);
    private bool SetValueInternal(AttributeValue attribVal);
    private MapField`2<string, AttributeValue> GetAttribValuesInternal(AttributeClassification classification);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class NewRelic.Agent.Core.Segments.SpanBatch : object {
    private static MessageParser`1<SpanBatch> _parser;
    private UnknownFieldSet _unknownFields;
    public static int SpansFieldNumber;
    private static FieldCodec`1<Span> _repeated_spans_codec;
    private RepeatedField`1<Span> spans_;
    public int Count { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageParser`1<SpanBatch> Parser { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public RepeatedField`1<Span> Spans { get; }
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public SpanBatch(SpanBatch other);
    private static SpanBatch();
    public sealed virtual int get_Count();
    public static MessageParser`1<SpanBatch> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual SpanBatch Clone();
    public RepeatedField`1<Span> get_Spans();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual bool Equals(SpanBatch other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalWriteTo(WriteContext& output);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(SpanBatch other);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
public sealed virtual void MergeFrom(CodedInputStream input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("protoc", "")]
private sealed virtual override void pb::Google.Protobuf.IBufferMessage.InternalMergeFrom(ParseContext& input);
}
public static class NewRelic.Agent.Core.Segments.TraceServiceReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static TraceServiceReflection();
    public static FileDescriptor get_Descriptor();
}
public class NewRelic.Agent.Core.SharedInterfaces.DateTimeStatic : object {
    public DateTime Now { get; }
    public DateTime UtcNow { get; }
    public sealed virtual DateTime get_Now();
    public sealed virtual DateTime get_UtcNow();
}
public class NewRelic.Agent.Core.SharedInterfaces.DnsStatic : object {
    private static string Ipv6ScopeIDPattern;
    private INetworkData _networkData;
    private Regex _regex;
    public DnsStatic(INetworkData networkData);
    public sealed virtual string GetHostName();
    public sealed virtual IPHostEntry GetHostEntry(string hostNameOrAddres);
    public sealed virtual string GetFullHostName();
    public sealed virtual List`1<string> GetIpAddresses();
    private INetworkInterfaceData GetActiveNetworkInterface();
}
public class NewRelic.Agent.Core.SharedInterfaces.Environment : object {
    public sealed virtual String[] GetCommandLineArgs();
    public sealed virtual string GetEnvironmentVariable(string variable);
    public sealed virtual string GetEnvironmentVariable(string variable, EnvironmentVariableTarget environmentVariableTarget);
    public sealed virtual Dictionary`2<string, string> GetEnvironmentVariablesWithPrefix(string prefix);
}
public class NewRelic.Agent.Core.SharedInterfaces.EnvironmentMock : object {
    private static String[] _emptyCommandLineArgs;
    private static Dictionary`2<string, string> _emptyEnvVarDictionary;
    private static EnvironmentMock();
    public sealed virtual String[] GetCommandLineArgs();
    public sealed virtual string GetEnvironmentVariable(string variable);
    public sealed virtual string GetEnvironmentVariable(string variable, EnvironmentVariableTarget environmentVariableTarget);
    public sealed virtual Dictionary`2<string, string> GetEnvironmentVariablesWithPrefix(string prefix);
}
public interface NewRelic.Agent.Core.SharedInterfaces.IDateTimeStatic {
    public DateTime Now { get; }
    public DateTime UtcNow { get; }
    public abstract virtual DateTime get_Now();
    public abstract virtual DateTime get_UtcNow();
}
public interface NewRelic.Agent.Core.SharedInterfaces.IDnsStatic {
    public abstract virtual string GetHostName();
    public abstract virtual IPHostEntry GetHostEntry(string hostNameOrAddres);
    public abstract virtual string GetFullHostName();
    public abstract virtual List`1<string> GetIpAddresses();
}
public interface NewRelic.Agent.Core.SharedInterfaces.IEnvironment {
    public abstract virtual String[] GetCommandLineArgs();
    public abstract virtual string GetEnvironmentVariable(string variable);
    public abstract virtual string GetEnvironmentVariable(string variable, EnvironmentVariableTarget environmentVariableTarget);
    public abstract virtual Dictionary`2<string, string> GetEnvironmentVariablesWithPrefix(string prefix);
}
public interface NewRelic.Agent.Core.SharedInterfaces.INetworkData {
    public abstract virtual IPAddress GetLocalIPAddress();
    public abstract virtual string GetDomainName(INetworkInterfaceData networkInterfaceData);
    public abstract virtual INetworkInterfaceData GetActiveNetworkInterface(IPAddress localIPAddress, List`1<INetworkInterfaceData> networkInterfaces);
    public abstract virtual List`1<INetworkInterfaceData> GetNetworkInterfaceData();
}
public interface NewRelic.Agent.Core.SharedInterfaces.INetworkInterfaceData {
    public string DnsSuffix { get; }
    public ICollection`1<UnicastIPAddressInformation> UnicastIPAddresses { get; }
    public abstract virtual string get_DnsSuffix();
    public abstract virtual ICollection`1<UnicastIPAddressInformation> get_UnicastIPAddresses();
}
public interface NewRelic.Agent.Core.SharedInterfaces.IOutOfBandMetricSource {
    public abstract virtual void CollectMetrics();
    public abstract virtual void RegisterPublishMetricHandler(PublishMetricDelegate publishMetricDelegate);
}
public interface NewRelic.Agent.Core.SharedInterfaces.IPerformanceCounterCategoryProxy {
    public abstract virtual String[] GetInstanceNames();
}
public interface NewRelic.Agent.Core.SharedInterfaces.IPerformanceCounterProxy {
    public abstract virtual float NextValue();
}
public interface NewRelic.Agent.Core.SharedInterfaces.IPerformanceCounterProxyFactory {
    public abstract virtual IPerformanceCounterProxy CreatePerformanceCounterProxy(string categoryName, string counterName, string instanceName);
    public abstract virtual string GetCurrentProcessInstanceNameForCategory(string categoryName, string lastKnownName);
}
public interface NewRelic.Agent.Core.SharedInterfaces.IProcess {
    public string ProcessName { get; }
    public int Id { get; }
    public string MainModuleFileName { get; }
    public DateTime StartTime { get; }
    public long PrivateMemorySize64 { get; }
    public long WorkingSet64 { get; }
    public FileVersionInfo FileVersionInfo { get; }
    public TimeSpan UserProcessorTime { get; }
    public abstract virtual string get_ProcessName();
    public abstract virtual int get_Id();
    public abstract virtual string get_MainModuleFileName();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual long get_PrivateMemorySize64();
    public abstract virtual long get_WorkingSet64();
    public abstract virtual FileVersionInfo get_FileVersionInfo();
    public abstract virtual TimeSpan get_UserProcessorTime();
    public abstract virtual void Refresh();
}
public interface NewRelic.Agent.Core.SharedInterfaces.IProcessStatic {
    public abstract virtual IProcess GetCurrentProcess();
}
public interface NewRelic.Agent.Core.SharedInterfaces.IThreadPoolStatic {
    public abstract virtual bool QueueUserWorkItem(WaitCallback callBack);
    public abstract virtual bool QueueUserWorkItem(WaitCallback callBack, object state);
    public abstract virtual void GetMaxThreads(Int32& countMaxWorkerThreads, Int32& countMaxCompletionThreads);
    public abstract virtual void GetMinThreads(Int32& countMinWorkerThreads, Int32& countMinCompletionThreads);
    public abstract virtual void GetAvailableThreads(Int32& countAvailWorkerThreads, Int32& countAvailCompletionThreads);
}
public class NewRelic.Agent.Core.SharedInterfaces.NetworkData : object {
    private INetworkInterfaceData _activeNetworkInterface;
    private IPAddress _localIPAddress;
    public sealed virtual string GetDomainName(INetworkInterfaceData networkInterfaceData);
    public sealed virtual IPAddress GetLocalIPAddress();
    public sealed virtual INetworkInterfaceData GetActiveNetworkInterface(IPAddress localIPAddress, List`1<INetworkInterfaceData> networkInterfaces);
    public sealed virtual List`1<INetworkInterfaceData> GetNetworkInterfaceData();
}
public class NewRelic.Agent.Core.SharedInterfaces.NetworkInterfaceData : object {
    [CompilerGeneratedAttribute]
private string <DnsSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<UnicastIPAddressInformation> <UnicastIPAddresses>k__BackingField;
    public string DnsSuffix { get; private set; }
    public ICollection`1<UnicastIPAddressInformation> UnicastIPAddresses { get; private set; }
    public NetworkInterfaceData(string dnsSuffix, ICollection`1<UnicastIPAddressInformation> ipAddresses);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DnsSuffix();
    [CompilerGeneratedAttribute]
private void set_DnsSuffix(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<UnicastIPAddressInformation> get_UnicastIPAddresses();
    [CompilerGeneratedAttribute]
private void set_UnicastIPAddresses(ICollection`1<UnicastIPAddressInformation> value);
}
public class NewRelic.Agent.Core.SharedInterfaces.PerformanceCounterCategoryProxy : object {
    private PerformanceCounterCategory _performanceCounterCategory;
    public PerformanceCounterCategoryProxy(string categoryName);
    public sealed virtual String[] GetInstanceNames();
}
public class NewRelic.Agent.Core.SharedInterfaces.PerformanceCounterProxy : object {
    private PerformanceCounter _counter;
    private bool _counterIsDisposed;
    public PerformanceCounterProxy(string categoryName, string counterName, string instanceName);
    public sealed virtual float NextValue();
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.SharedInterfaces.PerformanceCounterProxyFactory : object {
    public static string ProcessIdCounterName;
    private IProcessStatic _processStatic;
    private Func`2<string, IPerformanceCounterCategoryProxy> _createPerformanceCounterCategory;
    private Func`4<string, string, string, IPerformanceCounterProxy> _createPerformanceCounter;
    public PerformanceCounterProxyFactory(IProcessStatic processStatic, Func`2<string, IPerformanceCounterCategoryProxy> performanceCounterCategoryProxyFactory, Func`4<string, string, string, IPerformanceCounterProxy> performanceCounterCreator);
    public static IPerformanceCounterCategoryProxy DefaultCreatePerformanceCounterCategoryProxy(string categoryName);
    public static IPerformanceCounterProxy DefaultCreatePerformanceCounterProxy(string categoryName, string counterName, string instanceName);
    public sealed virtual string GetCurrentProcessInstanceNameForCategory(string categoryName, string lastKnownName);
    public sealed virtual IPerformanceCounterProxy CreatePerformanceCounterProxy(string categoryName, string counterName, string instanceName);
    private string GetInstanceNameForProcessAndCategory(string perfCategoryName, string processName, int pid, string lastKnownName);
}
public class NewRelic.Agent.Core.SharedInterfaces.Process : object {
    private Process _process;
    public string ProcessName { get; }
    public int Id { get; }
    public string MainModuleFileName { get; }
    public DateTime StartTime { get; }
    public long PrivateMemorySize64 { get; }
    public long WorkingSet64 { get; }
    public FileVersionInfo FileVersionInfo { get; }
    public TimeSpan UserProcessorTime { get; }
    public Process(Process process);
    public sealed virtual string get_ProcessName();
    public sealed virtual int get_Id();
    public sealed virtual string get_MainModuleFileName();
    public sealed virtual DateTime get_StartTime();
    public sealed virtual long get_PrivateMemorySize64();
    public sealed virtual long get_WorkingSet64();
    public sealed virtual FileVersionInfo get_FileVersionInfo();
    public sealed virtual TimeSpan get_UserProcessorTime();
    public sealed virtual void Refresh();
}
public class NewRelic.Agent.Core.SharedInterfaces.ProcessStatic : object {
    private static Process _currentSystemProcess;
    private static IProcess _currentProcess;
    public sealed virtual IProcess GetCurrentProcess();
    private static IProcess CreateProcess();
    private static Process GetCurrentSystemProcess();
}
public class NewRelic.Agent.Core.SharedInterfaces.PublishMetricDelegate : MulticastDelegate {
    public PublishMetricDelegate(object object, IntPtr method);
    public virtual void Invoke(MetricWireModel metric);
    public virtual IAsyncResult BeginInvoke(MetricWireModel metric, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NewRelic.Agent.Core.SharedInterfaces.ThreadPoolStatic : object {
    public sealed virtual void GetAvailableThreads(Int32& countAvailWorkerThreads, Int32& countAvailCompletionThreads);
    public sealed virtual void GetMaxThreads(Int32& countMaxWorkerThreads, Int32& countMaxCompletionThreads);
    public sealed virtual void GetMinThreads(Int32& countMinWorkerThreads, Int32& countMinCompletionThreads);
    public sealed virtual bool QueueUserWorkItem(WaitCallback callBack);
    public sealed virtual bool QueueUserWorkItem(WaitCallback callBack, object state);
}
public class NewRelic.Agent.Core.SharedInterfaces.Web.HttpRuntimeStatic : object {
    public string AppDomainAppVirtualPath { get; }
    public sealed virtual string get_AppDomainAppVirtualPath();
}
public interface NewRelic.Agent.Core.SharedInterfaces.Web.IHttpRuntimeStatic {
    public string AppDomainAppVirtualPath { get; }
    public abstract virtual string get_AppDomainAppVirtualPath();
}
public abstract class NewRelic.Agent.Core.Singleton`1 : object {
    private T _instance;
    public T ExistingInstance { get; }
    protected Singleton`1(T instance);
    public T get_ExistingInstance();
    public void SetInstance(T instance);
    protected abstract virtual T CreateInstance();
}
public interface NewRelic.Agent.Core.Spans.ISpanEventMaker {
    public abstract virtual IEnumerable`1<ISpanEventWireModel> GetSpanEvents(ImmutableTransaction immutableTransaction, string transactionName, IAttributeValueCollection transactionAttribValues);
}
public enum NewRelic.Agent.Core.Spans.SpanCategory : Enum {
    public int value__;
    public static SpanCategory Generic;
    public static SpanCategory Datastore;
    public static SpanCategory Http;
}
public class NewRelic.Agent.Core.Spans.SpanEventMaker : object {
    private IAttributeDefinitionService _attribDefSvc;
    private IConfigurationService _configurationService;
    private IAttributeDefinitions _attribDefs { get; }
    public SpanEventMaker(IAttributeDefinitionService attribDefSvc, IConfigurationService configurationService);
    private IAttributeDefinitions get__attribDefs();
    [IteratorStateMachineAttribute("NewRelic.Agent.Core.Spans.SpanEventMaker/<GetSpanEvents>d__5")]
public sealed virtual IEnumerable`1<ISpanEventWireModel> GetSpanEvents(ImmutableTransaction immutableTransaction, string transactionName, IAttributeValueCollection transactionAttribValues);
    private SpanAttributeValueCollection GenerateRootSpan(string rootSpanId, ImmutableTransaction immutableTransaction, string transactionName, IAttributeValueCollection transactionAttribValues);
    private SpanAttributeValueCollection GetAttributeValues(Segment segment, ImmutableTransaction immutableTransaction, string rootSpanId);
    private static string GetParentSpanId(Segment segment, ImmutableTransaction immutableTransaction, string rootSpanId);
}
[NrExcludeFromCodeCoverageAttribute]
internal class NewRelic.Agent.Core.ThreadIdEnricher : object {
    private static ThreadLocal`1<LogEventProperty> _tidProperty;
    private static ThreadIdEnricher();
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
public class NewRelic.Agent.Core.ThreadProfiling.BucketProfile : object {
    public ProfileNode Root;
}
public class NewRelic.Agent.Core.ThreadProfiling.ClassMethodNames : object {
    public string Class;
    public string Method;
    public ClassMethodNames(string class, string method);
}
public class NewRelic.Agent.Core.ThreadProfiling.FidTypeMethodName : object {
    public UIntPtr FunctionID;
    public string TypeName;
    public string MethodName;
}
public class NewRelic.Agent.Core.ThreadProfiling.InvalidProfileIdException : Exception {
    public InvalidProfileIdException(string message);
}
public interface NewRelic.Agent.Core.ThreadProfiling.ISampleSink {
    public abstract virtual void SampleAcquired(ThreadSnapshot[] threadSnapshots);
    public abstract virtual void SamplingComplete();
}
public interface NewRelic.Agent.Core.ThreadProfiling.IThreadProfilingProcessing {
    public ArrayList PruningList { get; }
    public abstract virtual ArrayList get_PruningList();
    public abstract virtual void AddNodeToPruningList(ProfileNode node);
    public abstract virtual void ResetCache();
    public abstract virtual void SortPruningTree();
}
public interface NewRelic.Agent.Core.ThreadProfiling.IThreadProfilingSampler {
    public abstract virtual bool Start(UInt32 frequencyInMsec, UInt32 durationInMsec, ISampleSink sampleSink, INativeMethods nativeMethods);
    public abstract virtual void Stop();
}
public interface NewRelic.Agent.Core.ThreadProfiling.IThreadProfilingSessionControl {
    public bool IgnoreMinMinimumSamplingDuration { get; }
    public abstract virtual bool StartThreadProfilingSession(int profileSessionId, UInt32 frequencyInMsec, UInt32 durationInMsec);
    public abstract virtual bool StopThreadProfilingSession(int profileId, bool reportData);
    public abstract virtual bool get_IgnoreMinMinimumSamplingDuration();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.ThreadProfiling.ProfileNode : object {
    [JsonArrayIndexAttribute]
public ProfileNodeDetails Details;
    [JsonArrayIndexAttribute]
public UInt32 RunnableCount;
    [JsonArrayIndexAttribute]
public UInt32 Unused;
    [JsonArrayIndexAttribute]
public ProfileNodes Children;
    public UInt32 NonRunnableCount;
    [CompilerGeneratedAttribute]
private UIntPtr <FunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreForReporting>k__BackingField;
    public UIntPtr FunctionId { get; public set; }
    public UInt32 Depth { get; public set; }
    public bool IgnoreForReporting { get; public set; }
    public ProfileNode(UIntPtr functionId, UInt32 runnableCount, UInt32 depth);
    [CompilerGeneratedAttribute]
public UIntPtr get_FunctionId();
    [CompilerGeneratedAttribute]
public void set_FunctionId(UIntPtr value);
    [CompilerGeneratedAttribute]
public UInt32 get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreForReporting();
    [CompilerGeneratedAttribute]
public void set_IgnoreForReporting(bool value);
    public void AddChild(ProfileNode node);
    public void ClearChildren();
}
public class NewRelic.Agent.Core.ThreadProfiling.ProfileNodeComparer : object {
    public sealed virtual int Compare(object x, object y);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.ThreadProfiling.ProfileNodeDetails : object {
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LineNumber>k__BackingField;
    [JsonArrayIndexAttribute]
public string ClassName { get; public set; }
    [JsonArrayIndexAttribute]
public string MethodName { get; public set; }
    [JsonArrayIndexAttribute]
public UInt32 LineNumber { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(UInt32 value);
}
public class NewRelic.Agent.Core.ThreadProfiling.ProfileNodes : object {
    private List`1<ProfileNode> _children;
    public int Count { get; }
    public int get_Count();
    public void Add(ProfileNode node);
    public void Remove(ProfileNode node);
    public void Clear();
    public object ToJsonObject();
    public sealed virtual IEnumerator`1<ProfileNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NewRelic.Agent.Core.ThreadProfiling.ThreadProfilingBucket : object {
    private static string NativeClassDescriptiveName;
    private static string NativeFunctionDescriptiveName;
    private static string UnknownClassName;
    private static string UnknownMethodName;
    public BucketProfile Tree;
    private object _syncObj;
    private IThreadProfilingProcessing _service;
    public ThreadProfilingBucket(IThreadProfilingProcessing service);
    public void ClearTree();
    public void UpdateTree(UIntPtr[] fids);
    private void UpdateTree(ProfileNode parent, UIntPtr[] fids, int fidIndex, UInt32 depth);
    public int GetNodeCount();
    public int GetDepth();
    private static int GetDepth(ProfileNode node, int currentDepth);
    internal IEnumerable`1<UIntPtr> GetFunctionIds();
    public void PopulateNames(IDictionary`2<UIntPtr, ClassMethodNames> namesSource);
    private void PopulateNames(ProfileNode node, IDictionary`2<UIntPtr, ClassMethodNames> namesSource);
    public void PruneTree();
    private static void PruneTree(ProfileNode node);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.ThreadProfiling.ThreadProfilingModel : object {
    [JsonArrayIndexAttribute]
public int ProfileSessionId;
    [JsonArrayIndexAttribute]
[DateTimeSerializesAsUnixTimeSecondsAttribute]
public DateTime StartTime;
    [JsonArrayIndexAttribute]
[DateTimeSerializesAsUnixTimeSecondsAttribute]
public DateTime StopTime;
    [JsonArrayIndexAttribute]
public int NumberOfSamples;
    [JsonArrayIndexAttribute]
public IDictionary`2<string, object> Samples;
    [JsonArrayIndexAttribute]
public int TotalThreadCount;
    [JsonArrayIndexAttribute]
public int RunnableThreadCount;
    public ThreadProfilingModel(int profileSessionId, DateTime startTime, DateTime stopTime, int numberOfSamples, IDictionary`2<string, object> samples, int totalThreadCount, int runnableThreadCount);
}
public class NewRelic.Agent.Core.ThreadProfiling.ThreadProfilingSampler : object {
    private int _workerRunning;
    private ManualResetEventSlim _shutdownEvent;
    private Thread _samplingWorker;
    private INativeMethods _nativeMethods;
    public ThreadProfilingSampler(INativeMethods nativeMethods);
    public sealed virtual bool Start(UInt32 frequencyInMsec, UInt32 durationInMsec, ISampleSink sampleSink, INativeMethods nativeMethods);
    public sealed virtual void Stop();
    private void InternalPolling_WaitCallback(UInt32 frequencyInMsec, UInt32 durationInMsec, ISampleSink sampleSink, INativeMethods nativeMethods);
    private ThreadSnapshot[] GetProfileWithRelease(Int32& hresult);
    private static UIntPtr ReadUIntPtr(IntPtr address);
    private ThreadSnapshot[] GetProfile(Int32& hresult);
}
public class NewRelic.Agent.Core.ThreadProfiling.ThreadProfilingService : ConfigurationBasedService {
    private static int InvalidSessionId;
    private INativeMethods _nativeMethods;
    private IDataTransportService _dataTransportService;
    private ThreadProfilingSampler _sampler;
    private int _profileSessionId;
    private DateTime _startSessionTime;
    private DateTime _stopSessionTime;
    private Dictionary`2<UIntPtr, ClassMethodNames> _functionNames;
    private object _syncObjFunctionNames;
    private int _maxAggregatedNodes;
    private int _numberSamplesInSession;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _reportData;
    private Dictionary`2<UIntPtr, int> _managedThreadsFromProfiler;
    private ThreadProfilingBucket _threadProfilingBucket;
    [CompilerGeneratedAttribute]
private ArrayList <PruningList>k__BackingField;
    private object _syncObjFailedProfiles;
    private Dictionary`2<UIntPtr, UInt32> _failedThreads;
    private Dictionary`2<UIntPtr, int> _failedThreadErrorCodes;
    private List`1<UIntPtr> _largeStackOverflows;
    public ArrayList PruningList { get; private set; }
    public bool IgnoreMinMinimumSamplingDuration { get; }
    public ThreadProfilingService(IDataTransportService dataTransportService, INativeMethods nativeMethods, int maxAggregatedNodes);
    [CompilerGeneratedAttribute]
public sealed virtual ArrayList get_PruningList();
    [CompilerGeneratedAttribute]
private void set_PruningList(ArrayList value);
    public void Start();
    public void Stop();
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    public sealed virtual bool StartThreadProfilingSession(int profileSessionId, UInt32 frequencyInMsec, UInt32 durationInMsec);
    public sealed virtual bool StopThreadProfilingSession(int profileId, bool reportData);
    public sealed virtual void SampleAcquired(ThreadSnapshot[] threadSnapshots);
    public sealed virtual void SamplingComplete();
    private void AddLargeStackOverflowProfile(UIntPtr threadId);
    private void AddFailedThreadProfile(UIntPtr threadId, int errorCode);
    private void LogFailedProfiles();
    private void UpdateTree(UIntPtr threadId, UIntPtr[] fids);
    public sealed virtual void AddNodeToPruningList(ProfileNode node);
    public int GetTotalBucketNodeCount();
    public void PerformAggregation();
    public sealed virtual void SortPruningTree();
    private IEnumerable`1<ThreadProfilingModel> SerializeData();
    private void ResolveFunctionNames();
    private void PopulateFunctionNameCache(UIntPtr[] functionIds);
    private void UpdateRunnableCounts();
    private static void UpdateRunnableCounts(ProfileNode node, IEnumerable`1<string> nonRunnableLeafNodes);
    private static void UpdateRunnableCountsForLeafNode(ProfileNode node, IEnumerable`1<string> nonRunnableLeafNodes);
    private static void UpdateRunnableCountsForNodeChildren(ProfileNode node, IEnumerable`1<string> nonRunnableLeafNodes);
    public sealed virtual void ResetCache();
    private FidTypeMethodName[] GetFunctionInfo(UIntPtr[] functionIDs);
    public sealed virtual bool get_IgnoreMinMinimumSamplingDuration();
}
public class NewRelic.Agent.Core.ThreadProfiling.ThreadSnapshot : ValueType {
    public UIntPtr ThreadId;
    public int ErrorCode;
    public UIntPtr[] FunctionIDs;
}
public static class NewRelic.Agent.Core.Time.DateTimeMath : object {
    public static DateTime Min(DateTime dateTime1, DateTime dateTime2);
    public static DateTime Max(DateTime dateTime1, DateTime dateTime2);
    public static TimeSpan Min(TimeSpan timespan1, TimeSpan timespan2);
    public static TimeSpan Max(TimeSpan timespan1, TimeSpan timespan2);
}
public interface NewRelic.Agent.Core.Time.IScheduler {
    public abstract virtual void ExecuteOnce(Action action, TimeSpan timeUntilExecution);
    public abstract virtual void ExecuteEvery(Action action, TimeSpan timeBetweenExecutions, Nullable`1<TimeSpan> optionalInitialDelay);
    public abstract virtual void StopExecuting(Action action, Nullable`1<TimeSpan> timeToWaitForInProgressAction);
}
public interface NewRelic.Agent.Core.Time.ISimpleTimer {
    public TimeSpan Duration { get; }
    public bool IsRunning { get; }
    public abstract virtual void Stop();
    public abstract virtual TimeSpan get_Duration();
    public abstract virtual bool get_IsRunning();
}
public interface NewRelic.Agent.Core.Time.ISimpleTimerFactory {
    public abstract virtual ISimpleTimer StartNewTimer();
}
public class NewRelic.Agent.Core.Time.Scheduler : object {
    private static TimeSpan DisablePeriodicExecution;
    private object _lock;
    private DisposableCollection`1<TimerStatus> _oneTimeTimers;
    private IDictionary`2<Action, Timer> _recurringTimers;
    private static Scheduler();
    public sealed virtual void ExecuteOnce(Action action, TimeSpan timeUntilExecution);
    public sealed virtual void ExecuteEvery(Action action, TimeSpan timeBetweenExecutions, Nullable`1<TimeSpan> optionalInitialDelay);
    public static Timer CreateExecuteOnceTimer(Action action);
    public static Timer CreateExecuteOnceTimer(Action action, TimeSpan timeUntilExecution);
    private static Timer PrivateCreateExecuteOnceTimer(Action action, TimeSpan timeUntilExecution);
    public static Timer CreateExecuteEveryTimer(Action action, TimeSpan timeBetweenExecutions, Nullable`1<TimeSpan> optionalInitialDelay);
    public sealed virtual void StopExecuting(Action action, Nullable`1<TimeSpan> timeToWaitForInProgressAction);
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Time.SimpleSchedulingService : DisposableService {
    private IScheduler _scheduler;
    private List`1<Action> _executingActions;
    public SimpleSchedulingService(IScheduler scheduler);
    public sealed virtual void StartExecuteEvery(Action action, TimeSpan timeBetweenExecutions, Nullable`1<TimeSpan> optionalInitialDelay);
    public sealed virtual void StopExecuting(Action action);
    public virtual void Dispose();
}
internal class NewRelic.Agent.Core.Time.SimpleTimer : object {
    private Stopwatch _timer;
    public TimeSpan Duration { get; }
    public bool IsRunning { get; }
    public sealed virtual void Stop();
    public sealed virtual TimeSpan get_Duration();
    public sealed virtual bool get_IsRunning();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class NewRelic.Agent.Core.Time.SimpleTimerFactory : object {
    public sealed virtual ISimpleTimer StartNewTimer();
}
public static class NewRelic.Agent.Core.Time.TimeSpanMath : object {
    public static TimeSpan Min(TimeSpan timeSpan1, TimeSpan timeSpan2);
    public static TimeSpan Max(TimeSpan timeSpan1, TimeSpan timeSpan2);
}
public interface NewRelic.Agent.Core.Tracer.ITracer {
    public abstract virtual void Finish(object returnValue, Exception exception);
}
public static class NewRelic.Agent.Core.Tracer.TracerArgument : object {
    public static Nullable`1<TransactionNamePriority> GetTransactionNamingPriority(UInt32 tracerArguments);
    public static bool IsAsync(UInt32 tracerArguments);
    public static bool IsFlagSet(UInt32 tracerArguments, TracerFlags flag);
}
[FlagsAttribute]
public enum NewRelic.Agent.Core.Tracer.TracerFlags : Enum {
    public UInt32 value__;
    public static TracerFlags Async;
    public static TracerFlags OtherTransaction;
    public static TracerFlags WebTransaction;
    public static TracerFlags AttributeInstrumentation;
    public static TracerFlags UseInvocationTargetClassName;
    public static TracerFlags CustomMetricName;
    public static TracerFlags SuppressRecursiveCalls;
    public static TracerFlags GenerateScopedMetric;
    public static TracerFlags GenerateUnscopedMetric;
    public static TracerFlags TransactionTracerSegment;
    public static TracerFlags CombineMultipleInvocations;
    public static TracerFlags FullClassMatch;
}
public class NewRelic.Agent.Core.TracerWrapper : object {
    private ITracer tracer;
    public TracerWrapper(ITracer tracer);
    public void FinishTracer(object returnValue, Exception exception);
}
public class NewRelic.Agent.Core.Transactions.IgnoreTransactionException : Exception {
    public string IgnoredTransactionName;
    public IgnoreTransactionException(string message, string ignoredTransactionName);
}
public interface NewRelic.Agent.Core.Transactions.IImmutableTransactionMetadata {
    public IEnumerable`1<string> CrossApplicationAlternatePathHashes { get; }
    public string CrossApplicationReferrerTransactionGuid { get; }
    public string CrossApplicationReferrerPathHash { get; }
    public string CrossApplicationPathHash { get; }
    public string CrossApplicationReferrerProcessId { get; }
    public string CrossApplicationReferrerTripId { get; }
    public float CrossApplicationResponseTimeInSeconds { get; }
    public bool HasOutgoingTraceHeaders { get; }
    public Nullable`1<int> HttpResponseSubStatusCode { get; }
    public string SyntheticsResourceId { get; }
    public string SyntheticsJobId { get; }
    public string SyntheticsMonitorId { get; }
    public bool IsSynthetics { get; }
    public bool HasCatResponseHeaders { get; }
    public abstract virtual IEnumerable`1<string> get_CrossApplicationAlternatePathHashes();
    public abstract virtual string get_CrossApplicationReferrerTransactionGuid();
    public abstract virtual string get_CrossApplicationReferrerPathHash();
    public abstract virtual string get_CrossApplicationPathHash();
    public abstract virtual string get_CrossApplicationReferrerProcessId();
    public abstract virtual string get_CrossApplicationReferrerTripId();
    public abstract virtual float get_CrossApplicationResponseTimeInSeconds();
    public abstract virtual bool get_HasOutgoingTraceHeaders();
    public abstract virtual Nullable`1<int> get_HttpResponseSubStatusCode();
    public abstract virtual string get_SyntheticsResourceId();
    public abstract virtual string get_SyntheticsJobId();
    public abstract virtual string get_SyntheticsMonitorId();
    public abstract virtual bool get_IsSynthetics();
    public abstract virtual bool get_HasCatResponseHeaders();
}
[NeedSerializableContainer]
public interface NewRelic.Agent.Core.Transactions.IInternalTransaction {
    public IList`1<Segment> Segments { get; }
    public ICandidateTransactionName CandidateTransactionName { get; }
    public ITransactionMetadata TransactionMetadata { get; }
    public ICallStackManager CallStackManager { get; }
    public int UnitOfWorkCount { get; }
    public int NestedTransactionAttempts { get; }
    public ITracingState TracingState { get; }
    public string TraceId { get; }
    public float Priority { get; }
    public Nullable`1<bool> Sampled { get; }
    public bool Ignored { get; }
    public bool IgnoreAutoBrowserMonitoring { get; }
    public bool IgnoreAllBrowserMonitoring { get; }
    public string Guid { get; }
    public Nullable`1<TimeSpan> ResponseTime { get; }
    public abstract virtual IList`1<Segment> get_Segments();
    public abstract virtual ICandidateTransactionName get_CandidateTransactionName();
    public abstract virtual void RollupTransactionNameByStatusCodeIfNeeded();
    public abstract virtual ITransactionMetadata get_TransactionMetadata();
    public abstract virtual ICallStackManager get_CallStackManager();
    public abstract virtual int get_UnitOfWorkCount();
    public abstract virtual int get_NestedTransactionAttempts();
    public abstract virtual ImmutableTransaction ConvertToImmutableTransaction();
    public abstract virtual int NoticeUnitOfWorkBegins();
    public abstract virtual int NoticeUnitOfWorkEnds();
    public abstract virtual int NoticeNestedTransactionAttempt();
    public abstract virtual void IgnoreAutoBrowserMonitoringForThisTx();
    public abstract virtual void IgnoreAllBrowserMonitoringForThisTx();
    public abstract virtual void IgnoreApdex();
    public abstract virtual ITracingState get_TracingState();
    public abstract virtual string get_TraceId();
    public abstract virtual float get_Priority();
    public abstract virtual Nullable`1<bool> get_Sampled();
    public abstract virtual void SetSampled(IAdaptiveSampler adaptiveSampler);
    public abstract virtual bool Finish();
    public abstract virtual void ForceChangeDuration(TimeSpan duration);
    public abstract virtual bool get_Ignored();
    public abstract virtual bool get_IgnoreAutoBrowserMonitoring();
    public abstract virtual bool get_IgnoreAllBrowserMonitoring();
    public abstract virtual string get_Guid();
    public abstract virtual TimeSpan GetDurationUntilNow();
    public abstract virtual Nullable`1<TimeSpan> get_ResponseTime();
    public abstract virtual bool TryCaptureResponseTime();
    public abstract virtual ITransactionSegmentState GetTransactionSegmentState();
    public abstract virtual void NoticeError(ErrorData errorData);
    public abstract virtual IList`1<LogEventWireModel> HarvestLogEvents();
    public abstract virtual bool AddLogEvent(LogEventWireModel logEvent);
}
public class NewRelic.Agent.Core.Transactions.ImmutableTransaction : object {
    public ITransactionName TransactionName;
    public IList`1<Segment> Segments;
    public IImmutableTransactionMetadata TransactionMetadata;
    public DateTime StartTime;
    public TimeSpan Duration;
    public TimeSpan ResponseTimeOrDuration;
    public string Guid;
    public bool IgnoreAutoBrowserMonitoring;
    public bool IgnoreAllBrowserMonitoring;
    public bool IgnoreApdex;
    public float Priority;
    public bool Sampled;
    public string TraceId;
    public ITracingState TracingState;
    private IAttributeDefinitions _attribDefs;
    private SpanAttributeValueCollection _commonSpanAttributes;
    public SpanAttributeValueCollection CommonSpanAttributes { get; }
    public ImmutableTransaction(ITransactionName transactionName, IEnumerable`1<Segment> segments, IImmutableTransactionMetadata transactionMetadata, DateTime startTime, TimeSpan duration, Nullable`1<TimeSpan> responseTime, string guid, bool ignoreAutoBrowserMonitoring, bool ignoreAllBrowserMonitoring, bool ignoreApdex, float priority, Nullable`1<bool> sampled, string traceId, ITracingState tracingState, IAttributeDefinitions attribDefs);
    public SpanAttributeValueCollection get_CommonSpanAttributes();
    public bool IsWebTransaction();
}
public interface NewRelic.Agent.Core.Transactions.IReadOnlyTransactionErrorState {
    public bool HasError { get; }
    public ErrorData ErrorData { get; }
    public string ErrorDataSpanId { get; }
    public bool IgnoreCustomErrors { get; }
    public bool IgnoreAgentNoticedErrors { get; }
    public abstract virtual bool get_HasError();
    public abstract virtual ErrorData get_ErrorData();
    public abstract virtual string get_ErrorDataSpanId();
    public abstract virtual bool get_IgnoreCustomErrors();
    public abstract virtual bool get_IgnoreAgentNoticedErrors();
}
public interface NewRelic.Agent.Core.Transactions.ITransactionAttributeMetadata {
    public AttributeValueCollection UserAndRequestAttributes { get; }
    public IReadOnlyTransactionErrorState ReadOnlyTransactionErrorState { get; }
    public string RequestMethod { get; }
    public string Uri { get; }
    public string OriginalUri { get; }
    public string ReferrerUri { get; }
    public Nullable`1<int> HttpResponseStatusCode { get; }
    public Nullable`1<TimeSpan> QueueTime { get; }
    public bool IsLlmTransaction { get; }
    public abstract virtual AttributeValueCollection get_UserAndRequestAttributes();
    public abstract virtual IReadOnlyTransactionErrorState get_ReadOnlyTransactionErrorState();
    public abstract virtual string get_RequestMethod();
    public abstract virtual string get_Uri();
    public abstract virtual string get_OriginalUri();
    public abstract virtual string get_ReferrerUri();
    public abstract virtual Nullable`1<int> get_HttpResponseStatusCode();
    public abstract virtual Nullable`1<TimeSpan> get_QueueTime();
    public abstract virtual bool get_IsLlmTransaction();
}
public interface NewRelic.Agent.Core.Transactions.ITransactionErrorState {
    public abstract virtual void AddCustomErrorData(ErrorData errorData);
    public abstract virtual void AddExceptionData(ErrorData errorData);
    public abstract virtual void AddStatusCodeErrorData(ErrorData errorData);
    public abstract virtual void SetIgnoreCustomErrors();
    public abstract virtual void SetIgnoreAgentNoticedErrors();
    public abstract virtual void TrySetSpanIdForErrorData(ErrorData errorData, string spanId);
}
public interface NewRelic.Agent.Core.Transactions.ITransactionFinalizer {
    public abstract virtual bool Finish(IInternalTransaction transaction);
}
public interface NewRelic.Agent.Core.Transactions.ITransactionMetadata {
    public string LatestCrossApplicationPathHash { get; }
    public bool HasOutgoingTraceHeaders { get; public set; }
    public ITransactionErrorState TransactionErrorState { get; }
    public abstract virtual IImmutableTransactionMetadata ConvertToImmutableMetadata();
    public abstract virtual string get_LatestCrossApplicationPathHash();
    public abstract virtual void SetRequestMethod(string requestMethod);
    public abstract virtual void SetUri(string uri);
    public abstract virtual void SetOriginalUri(string uri);
    public abstract virtual void SetReferrerUri(string uri);
    public abstract virtual void SetQueueTime(TimeSpan queueTime);
    public abstract virtual void SetHttpResponseStatusCode(int statusCode, Nullable`1<int> subStatusCode, IErrorService errorService);
    public abstract virtual void SetCrossApplicationReferrerTripId(string tripId);
    public abstract virtual void SetCrossApplicationReferrerPathHash(string referrerPathHash);
    public abstract virtual void SetCrossApplicationReferrerProcessId(string referrerProcessId);
    public abstract virtual void SetCrossApplicationReferrerContentLength(long referrerContentLength);
    public abstract virtual void SetCrossApplicationReferrerTransactionGuid(string transactionGuid);
    public abstract virtual void SetCrossApplicationPathHash(string pathHash);
    public abstract virtual void SetCrossApplicationResponseTimeInSeconds(float responseTimeInSeconds);
    public abstract virtual bool get_HasOutgoingTraceHeaders();
    public abstract virtual void set_HasOutgoingTraceHeaders(bool value);
    public abstract virtual void SetSyntheticsResourceId(string syntheticsResourceId);
    public abstract virtual void SetSyntheticsJobId(string syntheticsJobId);
    public abstract virtual void SetSyntheticsMonitorId(string syntheticsMonitorId);
    public abstract virtual void MarkHasCatResponseHeaders();
    public abstract virtual void SetLlmTransaction(bool isLlmTransaction);
    public abstract virtual long GetCrossApplicationReferrerContentLength();
    public abstract virtual ITransactionErrorState get_TransactionErrorState();
}
public interface NewRelic.Agent.Core.Transactions.ITransactionName {
    public bool IsWeb { get; }
    public string Category { get; }
    public string Name { get; }
    public string UnprefixedName { get; }
    public abstract virtual bool get_IsWeb();
    public abstract virtual string get_Category();
    public abstract virtual string get_Name();
    public abstract virtual string get_UnprefixedName();
}
public interface NewRelic.Agent.Core.Transactions.ITransactionSegmentState {
    public DateTime StartTime { get; }
    public int CurrentManagedThreadId { get; }
    public IAttributeDefinitions AttribDefs { get; }
    public IErrorService ErrorService { get; }
    public abstract virtual TimeSpan GetRelativeTime();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual Nullable`1<int> ParentSegmentId();
    public abstract virtual int CallStackPush(Segment segment);
    public abstract virtual void CallStackPop(Segment segment, bool notifyParent);
    public abstract virtual int get_CurrentManagedThreadId();
    public abstract virtual IAttributeDefinitions get_AttribDefs();
    public abstract virtual IErrorService get_ErrorService();
}
public interface NewRelic.Agent.Core.Transactions.ITransactionService {
    public bool IsAttachedToAsyncStorage { get; }
    public abstract virtual IInternalTransaction GetCurrentInternalTransaction();
    public abstract virtual IInternalTransaction GetOrCreateInternalTransaction(ITransactionName initialTransactionName, Action onCreate, bool doNotTrackAsUnitOfWork);
    public abstract virtual void RemoveOutstandingInternalTransactions(bool removeAsync, bool removePrimary);
    public abstract virtual bool SetTransactionOnAsyncContext(IInternalTransaction transaction);
    public abstract virtual bool get_IsAttachedToAsyncStorage();
    public abstract virtual float CreatePriority();
}
[NrExcludeFromCodeCoverageAttribute]
public class NewRelic.Agent.Core.Transactions.NoOpTransaction : object {
    private object _wrapperToken;
    private static IExternalSegmentData _noOpExternalSegmentData;
    private static IDatastoreSegmentData _noOpDatastoreSegmentData;
    public bool IsValid { get; }
    public bool IsFinished { get; }
    public ISegment CurrentSegment { get; }
    public bool HasHttpResponseStatusCode { get; }
    public DateTime StartTime { get; }
    private static NoOpTransaction();
    public sealed virtual bool get_IsValid();
    public sealed virtual bool get_IsFinished();
    public sealed virtual ISegment get_CurrentSegment();
    public sealed virtual bool get_HasHttpResponseStatusCode();
    public sealed virtual DateTime get_StartTime();
    public sealed virtual void End(bool captureResponseTime);
    public void Dispose();
    public sealed virtual ISegment StartCustomSegment(MethodCall methodCall, string segmentName);
    public sealed virtual ISegment StartDatastoreSegment(MethodCall methodCall, ParsedSqlStatement parsedSqlStatement, ConnectionInfo connectionInfo, string commandText, IDictionary`2<string, IConvertible> queryParameters, bool isLeaf);
    public sealed virtual ISegment StartExternalRequestSegment(MethodCall methodCall, Uri destinationUri, string method, bool isLeaf);
    public ISegment StartExternalRequestSegment(MethodCall methodCall, Uri destinationUri, string method, Action`1<IExternalSegmentData> segmentDataDelegate);
    public sealed virtual ISegment StartMessageBrokerSegment(MethodCall methodCall, MessageBrokerDestinationType destinationType, MessageBrokerAction operation, string brokerVendorName, string destinationName, string messagingSystemName, string cloudAccountId, string cloudRegion, string serverAddress, Nullable`1<int> serverPort, string routingKey);
    public sealed virtual ISegment StartMessageBrokerSerializationSegment(MethodCall methodCall, MessageBrokerDestinationType destinationType, MessageBrokerAction operation, string brokerVendorName, string destinationName, string kind);
    public sealed virtual ISegment StartMethodSegment(MethodCall methodCall, string typeName, string methodName, bool isLeaf);
    public sealed virtual ISegment StartTransactionSegment(MethodCall methodCall, string segmentDisplayName);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> GetResponseMetadata();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> GetRequestMetadata();
    public sealed virtual IDistributedTracePayload CreateDistributedTracePayload();
    public sealed virtual void NoticeError(Exception exception);
    public void NoticeError(string message);
    public sealed virtual void SetHttpResponseStatusCode(int statusCode, Nullable`1<int> subStatusCode);
    public sealed virtual void AttachToAsync();
    public sealed virtual void Detach();
    public sealed virtual void DetachFromPrimary();
    public sealed virtual void ProcessInboundResponse(IEnumerable`1<KeyValuePair`2<string, string>> headers, ISegment segment);
    public sealed virtual void Hold();
    public sealed virtual void Release();
    public sealed virtual void SetWebTransactionName(WebTransactionType type, string name, TransactionNamePriority priority);
    public sealed virtual void SetWebTransactionNameFromPath(WebTransactionType type, string path);
    public sealed virtual void SetMessageBrokerTransactionName(MessageBrokerDestinationType destinationType, string brokerVendorName, string destination, TransactionNamePriority priority);
    public sealed virtual void SetKafkaMessageBrokerTransactionName(MessageBrokerDestinationType destinationType, string brokerVendorName, string destination, TransactionNamePriority priority);
    public sealed virtual void SetOtherTransactionName(string category, string name, TransactionNamePriority priority);
    public sealed virtual void SetCustomTransactionName(string name, TransactionNamePriority priority);
    public sealed virtual void SetRequestMethod(string requestMethod);
    public sealed virtual void SetUri(string uri);
    public sealed virtual void SetOriginalUri(string uri);
    public sealed virtual void SetReferrerUri(string uri);
    public sealed virtual void SetQueueTime(TimeSpan queueTime);
    public sealed virtual void SetRequestParameters(IEnumerable`1<KeyValuePair`2<string, string>> parameters);
    public sealed virtual object GetOrSetValueFromCache(string key, Func`1<object> func);
    public sealed virtual void LogFinest(string message);
    public sealed virtual void Ignore();
    public sealed virtual ParsedSqlStatement GetParsedDatabaseStatement(DatastoreVendor vendor, CommandType commandType, string sql);
    public Dictionary`2<string, string> GetLinkingMetadata();
    public sealed virtual object GetWrapperToken();
    public sealed virtual void SetWrapperToken(object wrapperToken);
    public sealed virtual ISegment StartSegment(MethodCall methodCall);
    public sealed virtual IExternalSegmentData CreateExternalSegmentData(Uri destinationUri, string method);
    public sealed virtual IDatastoreSegmentData CreateDatastoreSegmentData(ParsedSqlStatement sqlStatement, ConnectionInfo connectionInfo, string commandText, IDictionary`2<string, IConvertible> queryParameters);
    public sealed virtual ITransaction AddCustomAttribute(string key, object value);
    public sealed virtual void InsertDistributedTraceHeaders(T carrier, Action`3<T, string, string> setter);
    public sealed virtual void AcceptDistributedTraceHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, TransportType transportType);
    public sealed virtual ITransaction SetRequestHeaders(T headers, IEnumerable`1<string> keysToCapture, Func`3<T, string, string> getter);
    public sealed virtual ISegment StartStackExchangeRedisSegment(int invocationTargetHashCode, ParsedSqlStatement parsedSqlStatement, ConnectionInfo connectionInfo, TimeSpan relativeStartTime, TimeSpan relativeEndTime);
    public sealed virtual void SetUserId(string userid);
    public sealed virtual void SetLlmTransaction(bool isLlmTransaction);
    public sealed virtual void AddLambdaAttribute(string name, object value);
    public sealed virtual void AddFaasAttribute(string name, object value);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.Transactions.SyntheticsHeader : object {
    public static int MaxEventCount;
    public static int MaxTraceCount;
    public static string HeaderKey;
    public string EncodingKey;
    public static long SupportedHeaderVersion;
    [JsonArrayIndexAttribute]
public long Version;
    [JsonArrayIndexAttribute]
public long AccountId;
    [JsonArrayIndexAttribute]
public string ResourceId;
    [JsonArrayIndexAttribute]
public string JobId;
    [JsonArrayIndexAttribute]
public string MonitorId;
    public SyntheticsHeader(long version, long accountId, string resourceId, string jobId, string monitorId);
    public bool IsValidSyntheticsDataForSave();
    public static SyntheticsHeader TryCreate(IEnumerable`1<long> trustedAccountIds, string obfuscatedHeader, string encodingKey);
    public string TryGetObfuscated();
    private static string Obfuscate(string serializedHeader, string encodingKey);
    private static string Deobfuscate(string obfuscatedHeader, string encodingKey);
    private static long DeserializeVersion(string jsonSerializedHeader);
    private static bool IsUnsupportedVersion(long version);
    private static bool IsUntrustedAccount(SyntheticsHeader syntheticsHeader, IEnumerable`1<long> trustedAccountIds);
}
public class NewRelic.Agent.Core.Transactions.Transaction : object {
    private static int MaxSegmentLength;
    private static HashSet`1<string> HeadersNeedQueryParametersRemoval;
    private Agent _agent;
    [CompilerGeneratedAttribute]
private ITracingState <TracingState>k__BackingField;
    private ConcurrentList`1<LogEventWireModel> _logEvents;
    private ConcurrentList`1<Segment> _segments;
    private ISimpleTimer _timer;
    private Nullable`1<TimeSpan> _forcedDuration;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) _responseTime;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _ignored;
    private int _unitOfWorkCount;
    private int _totalNestedTransactionAttempts;
    private int _transactionTracerMaxSegments;
    private string _guid;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _ignoreAutoBrowserMonitoring;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _ignoreAllBrowserMonitoring;
    private bool _ignoreApdex;
    [CompilerGeneratedAttribute]
private ICandidateTransactionName <CandidateTransactionName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransactionMetadata <TransactionMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ICallStackManager <CallStackManager>k__BackingField;
    private IDatabaseService _databaseService;
    private IDatabaseStatementParser _databaseStatementParser;
    private IErrorService _errorService;
    private IConfiguration _configuration;
    private IDistributedTracePayloadHandler _distributedTracePayloadHandler;
    private IAttributeDefinitions _attribDefs;
    private object _wrapperToken;
    private object _sync;
    private Single modreq(System.Runtime.CompilerServices.IsVolatile) _priority;
    private Nullable`1<bool> _sampled;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _traceId;
    private DateTime _startTime;
    private ConcurrentDictionary`2<string, object> _transactionCache;
    [CompilerGeneratedAttribute]
private bool <IsFinished>k__BackingField;
    private object _finishLock;
    private Agent Agent { get; }
    public bool IsValid { get; }
    public ISegment CurrentSegment { get; }
    public bool HasHttpResponseStatusCode { get; }
    public ITracingState TracingState { get; private set; }
    public string TraceId { get; internal set; }
    public float Priority { get; internal set; }
    public Nullable`1<bool> Sampled { get; internal set; }
    public IList`1<Segment> Segments { get; }
    public string Guid { get; }
    public ICandidateTransactionName CandidateTransactionName { get; }
    public ITransactionMetadata TransactionMetadata { get; }
    public int UnitOfWorkCount { get; }
    public int NestedTransactionAttempts { get; }
    public ICallStackManager CallStackManager { get; }
    public IErrorService ErrorService { get; }
    public IAttributeDefinitions AttribDefs { get; }
    public bool IgnoreAutoBrowserMonitoring { get; }
    public bool IgnoreAllBrowserMonitoring { get; }
    public bool Ignored { get; }
    public DateTime StartTime { get; }
    private ConcurrentDictionary`2<string, object> TransactionCache { get; }
    public int CurrentManagedThreadId { get; }
    public Nullable`1<TimeSpan> ResponseTime { get; }
    public bool IsFinished { get; private set; }
    public Transaction(IConfiguration configuration, ITransactionName initialTransactionName, ISimpleTimer timer, DateTime startTime, ICallStackManager callStackManager, IDatabaseService databaseService, float priority, IDatabaseStatementParser databaseStatementParser, IDistributedTracePayloadHandler distributedTracePayloadHandler, IErrorService errorService, IAttributeDefinitions attribDefs);
    private static Transaction();
    private Agent get_Agent();
    public sealed virtual bool get_IsValid();
    public sealed virtual ISegment get_CurrentSegment();
    public sealed virtual bool get_HasHttpResponseStatusCode();
    [CompilerGeneratedAttribute]
public sealed virtual ITracingState get_TracingState();
    [CompilerGeneratedAttribute]
private void set_TracingState(ITracingState value);
    public sealed virtual string get_TraceId();
    internal void set_TraceId(string value);
    public sealed virtual float get_Priority();
    internal void set_Priority(float value);
    public sealed virtual Nullable`1<bool> get_Sampled();
    internal void set_Sampled(Nullable`1<bool> value);
    public sealed virtual void SetSampled(IAdaptiveSampler adaptiveSampler);
    public sealed virtual void End(bool captureResponseTime);
    public void Dispose();
    public sealed virtual ISegment StartSegment(MethodCall methodCall);
    private Segment StartSegmentImpl(MethodCall methodCall);
    private Segment StartSegmentImpl(string typeName, string methodName, int invocationTargetHashCode, TimeSpan relativeStartTime, TimeSpan relativeEndTime);
    public sealed virtual ISegment StartCustomSegment(MethodCall methodCall, string segmentName);
    public AbstractSegmentData CreateCustomSegmentData(string segmentName);
    public sealed virtual ISegment StartMessageBrokerSegment(MethodCall methodCall, MessageBrokerDestinationType destinationType, MessageBrokerAction operation, string brokerVendorName, string destinationName, string messagingSystemName, string cloudAccountId, string cloudRegion, string serverAddress, Nullable`1<int> serverPort, string routingKey);
    public sealed virtual ISegment StartMessageBrokerSerializationSegment(MethodCall methodCall, MessageBrokerDestinationType destinationType, MessageBrokerAction operation, string brokerVendorName, string destinationName, string kind);
    public AbstractSegmentData CreateMessageBrokerSegmentData(MessageBrokerDestinationType destinationType, MessageBrokerAction operation, string brokerVendorName, string destinationName, string messagingSystemName, string cloudAccountId, string cloudRegion, string serverAddress, Nullable`1<int> serverPort, string routingKey);
    public AbstractSegmentData CreateMessageBrokerSerializationSegmentData(MessageBrokerDestinationType destinationType, MessageBrokerAction operation, string brokerVendorName, string destinationName, string kind);
    public sealed virtual ISegment StartStackExchangeRedisSegment(int invocationTargetHashCode, ParsedSqlStatement parsedSqlStatement, ConnectionInfo connectionInfo, TimeSpan relativeStartTime, TimeSpan relativeEndTime);
    public sealed virtual ISegment StartDatastoreSegment(MethodCall methodCall, ParsedSqlStatement parsedSqlStatement, ConnectionInfo connectionInfo, string commandText, IDictionary`2<string, IConvertible> queryParameters, bool isLeaf);
    public sealed virtual IDatastoreSegmentData CreateDatastoreSegmentData(ParsedSqlStatement parsedSqlStatement, ConnectionInfo connectionInfo, string commandText, IDictionary`2<string, IConvertible> queryParameters);
    private static MethodCallData GetMethodCallData(MethodCall methodCall);
    private static MethodCallData GetMethodCallData(string typeName, string methodName, int invocationTargetHashCode);
    private static MessageBrokerDestinationType AgentWrapperApiEnumToMetricNamesEnum(MessageBrokerDestinationType wrapper);
    private static MessageBrokerAction AgentWrapperApiEnumToMetricNamesEnum(MessageBrokerAction wrapper);
    private Dictionary`2<string, IConvertible> GetNormalizedQueryParameters(IDictionary`2<string, IConvertible> originalQueryParameters);
    private string GetTruncatedString(string originalString);
    private IConvertible GetNormalizedValue(IConvertible originalValue);
    public ISegment StartExternalRequestSegmentImpl(MethodCall methodCall, Uri destinationUri, string method, bool isLeaf);
    public ISegment StartExternalRequestSegment(MethodCall methodCall, Uri destinationUri, string method);
    public sealed virtual ISegment StartExternalRequestSegment(MethodCall methodCall, Uri destinationUri, string method, bool isLeaf);
    public sealed virtual IExternalSegmentData CreateExternalSegmentData(Uri destinationUri, string method);
    public sealed virtual ISegment StartMethodSegment(MethodCall methodCall, string typeName, string methodName, bool isLeaf);
    public AbstractSegmentData CreateMethodSegmentData(string typeName, string methodName);
    public sealed virtual ISegment StartTransactionSegment(MethodCall methodCall, string segmentDisplayName);
    public AbstractSegmentData CreateSimpleSegmentData(string segmentDisplayName);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> GetRequestMetadata();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> GetResponseMetadata();
    private void UpdatePathHash(TransactionMetricName transactionMetricName);
    public sealed virtual void AcceptDistributedTraceHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter, TransportType transportType);
    public sealed virtual IDistributedTracePayload CreateDistributedTracePayload();
    public sealed virtual void NoticeError(Exception exception);
    public sealed virtual void NoticeError(ErrorData errorData);
    private void TryNoticeErrorOnCurrentSpan(ErrorData errorData);
    public sealed virtual void SetHttpResponseStatusCode(int statusCode, Nullable`1<int> subStatusCode);
    public sealed virtual void AttachToAsync();
    public sealed virtual void Detach();
    public sealed virtual void DetachFromPrimary();
    public sealed virtual void ProcessInboundResponse(IEnumerable`1<KeyValuePair`2<string, string>> headers, ISegment segment);
    public sealed virtual void Hold();
    public sealed virtual void Release();
    private void SetTransactionName(ITransactionName transactionName, TransactionNamePriority priority);
    public sealed virtual void SetWebTransactionName(WebTransactionType type, string name, TransactionNamePriority priority);
    public void SetWebTransactionNameFromPath(string normalizedPath);
    public sealed virtual void SetWebTransactionNameFromPath(WebTransactionType type, string path);
    public sealed virtual void SetMessageBrokerTransactionName(MessageBrokerDestinationType destinationType, string brokerVendorName, string destination, TransactionNamePriority priority);
    public sealed virtual void SetKafkaMessageBrokerTransactionName(MessageBrokerDestinationType destinationType, string brokerVendorName, string destination, TransactionNamePriority priority);
    public sealed virtual void SetOtherTransactionName(string category, string name, TransactionNamePriority priority);
    public sealed virtual void SetCustomTransactionName(string name, TransactionNamePriority priority);
    public sealed virtual void RollupTransactionNameByStatusCodeIfNeeded();
    public sealed virtual void SetRequestMethod(string requestMethod);
    public sealed virtual void SetUri(string uri);
    public sealed virtual void SetOriginalUri(string uri);
    public sealed virtual void SetReferrerUri(string uri);
    public sealed virtual void SetQueueTime(TimeSpan queueTime);
    public sealed virtual void SetRequestParameters(IEnumerable`1<KeyValuePair`2<string, string>> parameters);
    public sealed virtual ITransaction AddCustomAttribute(string key, object value);
    public sealed virtual IList`1<LogEventWireModel> HarvestLogEvents();
    public sealed virtual bool AddLogEvent(LogEventWireModel logEvent);
    public sealed virtual IList`1<Segment> get_Segments();
    public sealed virtual string get_Guid();
    [CompilerGeneratedAttribute]
public sealed virtual ICandidateTransactionName get_CandidateTransactionName();
    [CompilerGeneratedAttribute]
public sealed virtual ITransactionMetadata get_TransactionMetadata();
    public sealed virtual int get_UnitOfWorkCount();
    public sealed virtual int get_NestedTransactionAttempts();
    [CompilerGeneratedAttribute]
public sealed virtual ICallStackManager get_CallStackManager();
    public sealed virtual IErrorService get_ErrorService();
    public sealed virtual IAttributeDefinitions get_AttribDefs();
    public int Add(Segment segment);
    public sealed virtual ImmutableTransaction ConvertToImmutableTransaction();
    public sealed virtual void LogFinest(string message);
    public sealed virtual void Ignore();
    public sealed virtual int NoticeUnitOfWorkBegins();
    public sealed virtual int NoticeUnitOfWorkEnds();
    public sealed virtual int NoticeNestedTransactionAttempt();
    public sealed virtual void IgnoreAutoBrowserMonitoringForThisTx();
    public sealed virtual void IgnoreAllBrowserMonitoringForThisTx();
    public sealed virtual void IgnoreApdex();
    public sealed virtual bool get_IgnoreAutoBrowserMonitoring();
    public sealed virtual bool get_IgnoreAllBrowserMonitoring();
    public sealed virtual bool get_Ignored();
    public sealed virtual DateTime get_StartTime();
    public sealed virtual ITransactionSegmentState GetTransactionSegmentState();
    private ConcurrentDictionary`2<string, object> get_TransactionCache();
    public sealed virtual int get_CurrentManagedThreadId();
    public sealed virtual object GetOrSetValueFromCache(string key, Func`1<object> func);
    public sealed virtual TimeSpan GetDurationUntilNow();
    public sealed virtual TimeSpan GetRelativeTime();
    public sealed virtual bool TryCaptureResponseTime();
    public sealed virtual Nullable`1<TimeSpan> get_ResponseTime();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFinished();
    [CompilerGeneratedAttribute]
private void set_IsFinished(bool value);
    public sealed virtual bool Finish();
    protected virtual override void Finalize();
    public sealed virtual void ForceChangeDuration(TimeSpan duration);
    public sealed virtual int CallStackPush(Segment segment);
    public sealed virtual void CallStackPop(Segment segment, bool notifyParent);
    public sealed virtual Nullable`1<int> ParentSegmentId();
    public sealed virtual ParsedSqlStatement GetParsedDatabaseStatement(DatastoreVendor datastoreVendor, CommandType commandType, string sql);
    public sealed virtual object GetWrapperToken();
    public sealed virtual void SetWrapperToken(object wrapperToken);
    public sealed virtual void InsertDistributedTraceHeaders(T carrier, Action`3<T, string, string> setter);
    public sealed virtual ITransaction SetRequestHeaders(T headers, IEnumerable`1<string> keysToCapture, Func`3<T, string, string> getter);
    private string RemoveQueryParameters(string url);
    public sealed virtual void SetUserId(string userid);
    public sealed virtual void SetLlmTransaction(bool isLlmTransaction);
    public sealed virtual void AddLambdaAttribute(string name, object value);
    public sealed virtual void AddFaasAttribute(string name, object value);
}
public class NewRelic.Agent.Core.Transactions.TransactionErrorState : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<ErrorData, string> _customErrorData;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<ErrorData, string> _transactionExceptionData;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<ErrorData, string> _statusCodeErrorData;
    [CompilerGeneratedAttribute]
private bool <IgnoreCustomErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreAgentNoticedErrors>k__BackingField;
    public bool HasError { get; }
    public ErrorData ErrorData { get; }
    public string ErrorDataSpanId { get; }
    public bool IgnoreCustomErrors { get; private set; }
    public bool IgnoreAgentNoticedErrors { get; private set; }
    public sealed virtual bool get_HasError();
    public sealed virtual ErrorData get_ErrorData();
    public sealed virtual string get_ErrorDataSpanId();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IgnoreCustomErrors();
    [CompilerGeneratedAttribute]
private void set_IgnoreCustomErrors(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IgnoreAgentNoticedErrors();
    [CompilerGeneratedAttribute]
private void set_IgnoreAgentNoticedErrors(bool value);
    private ValueTuple`2<ErrorData, string> GetErrorToReport();
    public sealed virtual void AddCustomErrorData(ErrorData errorData);
    public sealed virtual void AddExceptionData(ErrorData errorData);
    public sealed virtual void AddStatusCodeErrorData(ErrorData errorData);
    public sealed virtual void SetIgnoreAgentNoticedErrors();
    public sealed virtual void SetIgnoreCustomErrors();
    public sealed virtual void TrySetSpanIdForErrorData(ErrorData errorData, string spanId);
}
public class NewRelic.Agent.Core.Transactions.TransactionFinalizer : DisposableService {
    private IAgentHealthReporter _agentHealthReporter;
    private ITransactionMetricNameMaker _transactionMetricNameMaker;
    private IPathHashMaker _pathHashMaker;
    private ITransactionTransformer _transactionTransformer;
    public TransactionFinalizer(IAgentHealthReporter agentHealthReporter, ITransactionMetricNameMaker transactionMetricNameMaker, IPathHashMaker pathHashMaker, ITransactionTransformer transactionTransformer);
    public sealed virtual bool Finish(IInternalTransaction transaction);
    private void OnTransactionFinalized(TransactionFinalizedEvent eventData);
    private static Segment TryGetLastStartedSegment(ImmutableTransaction transaction);
    private static Segment TryGetLastFinishedSegment(ImmutableTransaction transaction);
    private static TimeSpan GetEstimatedTransactionDuration(IInternalTransaction internalTransaction, Segment lastStartedSegment, Segment lastFinishedSegment);
    private void UpdatePathHash(IInternalTransaction transaction);
}
public class NewRelic.Agent.Core.Transactions.TransactionMetadata : object {
    private object _sync;
    public static String[] TransportTypeToStringMapping;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _crossApplicationReferrerPathHash;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _crossApplicationReferrerProcessId;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _crossApplicationReferrerTripId;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _crossApplicationReferrerTransactionGuid;
    private Single modreq(System.Runtime.CompilerServices.IsVolatile) _crossApplicationResponseTimeInSeconds;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _syntheticsResourceId;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _syntheticsJobId;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _syntheticsMonitorId;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _latestCrossApplicationPathHash;
    private long _crossApplicationReferrerContentLength;
    private Func`1 modreq(System.Runtime.CompilerServices.IsVolatile) _timeSpanQueueTime;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _httpResponseStatusCode;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _httpResponseSubStatusCode;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _requestMethod;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _uri;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _originalUri;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _referrerUri;
    private AttributeValueCollection _transactionAttributes;
    private ConcurrentHashSet`1<string> _allCrossApplicationPathHashes;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _hasResponseCatHeaders;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isLlmTransaction;
    private string _transactionGuid;
    [CompilerGeneratedAttribute]
private ITransactionErrorState <TransactionErrorState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOutgoingTraceHeaders>k__BackingField;
    public AttributeValueCollection UserAndRequestAttributes { get; }
    public bool IsSynthetics { get; }
    public ITransactionErrorState TransactionErrorState { get; }
    public IReadOnlyTransactionErrorState ReadOnlyTransactionErrorState { get; }
    public string SyntheticsJobId { get; }
    public string SyntheticsMonitorId { get; }
    public string SyntheticsResourceId { get; }
    public string CrossApplicationReferrerPathHash { get; }
    public string CrossApplicationReferrerTripId { get; }
    public string CrossApplicationReferrerProcessId { get; }
    public string CrossApplicationReferrerTransactionGuid { get; }
    public string LatestCrossApplicationPathHash { get; }
    public float CrossApplicationResponseTimeInSeconds { get; }
    public bool HasOutgoingTraceHeaders { get; public set; }
    public string RequestMethod { get; }
    public string Uri { get; }
    public string OriginalUri { get; }
    public string ReferrerUri { get; }
    public Nullable`1<TimeSpan> QueueTime { get; }
    public Nullable`1<int> HttpResponseStatusCode { get; }
    public Nullable`1<int> HttpResponseSubStatusCode { get; }
    public IEnumerable`1<string> CrossApplicationAlternatePathHashes { get; }
    public string CrossApplicationPathHash { get; }
    public bool HasCatResponseHeaders { get; }
    public bool IsLlmTransaction { get; }
    public TransactionMetadata(string transactionGuid);
    private static TransactionMetadata();
    public sealed virtual AttributeValueCollection get_UserAndRequestAttributes();
    public sealed virtual IImmutableTransactionMetadata ConvertToImmutableMetadata();
    public sealed virtual bool get_IsSynthetics();
    public sealed virtual void SetRequestMethod(string requestMethod);
    public sealed virtual void SetUri(string uri);
    public sealed virtual void SetOriginalUri(string uri);
    public sealed virtual void SetReferrerUri(string uri);
    public sealed virtual void SetLlmTransaction(bool isLlmTransaction);
    public sealed virtual void SetQueueTime(TimeSpan queueTime);
    public sealed virtual void SetHttpResponseStatusCode(int statusCode, Nullable`1<int> subStatusCode, IErrorService errorService);
    [CompilerGeneratedAttribute]
public sealed virtual ITransactionErrorState get_TransactionErrorState();
    public sealed virtual IReadOnlyTransactionErrorState get_ReadOnlyTransactionErrorState();
    public sealed virtual void SetCrossApplicationReferrerPathHash(string referrerPathHash);
    public sealed virtual void SetCrossApplicationReferrerProcessId(string referrerProcessId);
    public sealed virtual void SetCrossApplicationReferrerContentLength(long contentLength);
    public sealed virtual void SetCrossApplicationReferrerTransactionGuid(string transactionGuid);
    public sealed virtual void SetCrossApplicationPathHash(string pathHash);
    public sealed virtual void SetCrossApplicationReferrerTripId(string referrerTripId);
    public sealed virtual void SetCrossApplicationResponseTimeInSeconds(float responseTimeInSeconds);
    public sealed virtual void SetSyntheticsResourceId(string syntheticsResourceId);
    public sealed virtual void SetSyntheticsJobId(string syntheticsJobId);
    public sealed virtual void SetSyntheticsMonitorId(string syntheticsMonitorId);
    public sealed virtual void MarkHasCatResponseHeaders();
    public sealed virtual long GetCrossApplicationReferrerContentLength();
    public sealed virtual string get_SyntheticsJobId();
    public sealed virtual string get_SyntheticsMonitorId();
    public sealed virtual string get_SyntheticsResourceId();
    public sealed virtual string get_CrossApplicationReferrerPathHash();
    public sealed virtual string get_CrossApplicationReferrerTripId();
    public sealed virtual string get_CrossApplicationReferrerProcessId();
    public sealed virtual string get_CrossApplicationReferrerTransactionGuid();
    public sealed virtual string get_LatestCrossApplicationPathHash();
    public sealed virtual float get_CrossApplicationResponseTimeInSeconds();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasOutgoingTraceHeaders();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HasOutgoingTraceHeaders(bool value);
    public sealed virtual string get_RequestMethod();
    public sealed virtual string get_Uri();
    public sealed virtual string get_OriginalUri();
    public sealed virtual string get_ReferrerUri();
    public sealed virtual Nullable`1<TimeSpan> get_QueueTime();
    private Nullable`1<TimeSpan> GetTimeSpan();
    public sealed virtual Nullable`1<int> get_HttpResponseStatusCode();
    public sealed virtual Nullable`1<int> get_HttpResponseSubStatusCode();
    public sealed virtual IEnumerable`1<string> get_CrossApplicationAlternatePathHashes();
    public sealed virtual string get_CrossApplicationPathHash();
    public sealed virtual bool get_HasCatResponseHeaders();
    public sealed virtual bool get_IsLlmTransaction();
}
public class NewRelic.Agent.Core.Transactions.TransactionName : object {
    [CompilerGeneratedAttribute]
private bool <IsWeb>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool IsWeb { get; }
    public string Category { get; }
    public string Name { get; }
    public string UnprefixedName { get; }
    private TransactionName(bool isWeb, string category, string name);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsWeb();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Category();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual string get_UnprefixedName();
    public static TransactionName ForOtherTransaction(string category, string name);
    public static TransactionName ForWebTransaction(WebTransactionType type, string name);
    public static TransactionName ForWebTransaction(string type, string name);
    public static TransactionName ForUriTransaction(string normalizedUri);
    public static TransactionName ForBrokerTransaction(MessageBrokerDestinationType type, string vendor, string destination);
    public static TransactionName ForKafkaBrokerTransaction(MessageBrokerDestinationType type, string vendor, string destination);
    public static TransactionName ForCustomTransaction(bool isWeb, string name, int maxLength);
}
public class NewRelic.Agent.Core.Transactions.TransactionService : ConfigurationBasedService {
    private static string TransactionContextKey;
    private IEnumerable`1<IContextStorage`1<IInternalTransaction>> _sortedPrimaryContexts;
    private IContextStorage`1<IInternalTransaction> _asyncContext;
    private ISimpleTimerFactory _timerFactory;
    private ICallStackManagerFactory _callStackManagerFactory;
    private IDatabaseService _databaseService;
    private ITracePriorityManager _tracePriorityManager;
    private IDatabaseStatementParser _databaseStatementParser;
    private IErrorService _errorService;
    private IDistributedTracePayloadHandler _distributedTracePayloadHandler;
    private IAttributeDefinitionService _attribDefSvc;
    private IAdaptiveSampler _adaptiveSampler;
    public bool IsAttachedToAsyncStorage { get; }
    public TransactionService(IEnumerable`1<IContextStorageFactory> factories, ISimpleTimerFactory timerFactory, ICallStackManagerFactory callStackManagerFactory, IDatabaseService databaseService, ITracePriorityManager tracePriorityManager, IDatabaseStatementParser databaseStatementParser, IErrorService errorService, IDistributedTracePayloadHandler distributedTracePayloadHandler, IAttributeDefinitionService attribDefSvc, IAdaptiveSampler adaptiveSampler);
    public sealed virtual bool get_IsAttachedToAsyncStorage();
    public sealed virtual float CreatePriority();
    private static IEnumerable`1<IContextStorage`1<IInternalTransaction>> GetPrimaryTransactionContexts(IEnumerable`1<IContextStorageFactory> factories);
    private static IContextStorage`1<IInternalTransaction> GetAsyncTransactionContext(IEnumerable`1<IContextStorageFactory> factories);
    private IInternalTransaction TryGetInternalTransaction(IContextStorage`1<IInternalTransaction> transactionContext);
    private IContextStorage`1<IInternalTransaction> GetFirstActivePrimaryContext();
    private IInternalTransaction CreateInternalTransaction(ITransactionName initialTransactionName, Action onCreate);
    private void TryClearContexts(IEnumerable`1<IContextStorage`1<IInternalTransaction>> contexts);
    public sealed virtual IInternalTransaction GetCurrentInternalTransaction();
    public sealed virtual bool SetTransactionOnAsyncContext(IInternalTransaction transaction);
    public sealed virtual IInternalTransaction GetOrCreateInternalTransaction(ITransactionName initialTransactionName, Action onCreate, bool doNotTrackAsUnitOfWork);
    public sealed virtual void RemoveOutstandingInternalTransactions(bool removeAsync, bool removePrimary);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
public interface NewRelic.Agent.Core.TransactionTraces.ITransactionCollector {
    public abstract virtual void Collect(TransactionTraceWireModelComponents transactionTraceWireModelComponents);
    public abstract virtual IEnumerable`1<TransactionTraceWireModelComponents> GetCollectedSamples();
}
public class NewRelic.Agent.Core.TransactionTraces.KeyTransactionCollector : object {
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _keyTransactions;
    protected ConfigurationSubscriber ConfigurationSubscription;
    public sealed virtual void Collect(TransactionTraceWireModelComponents transactionTraceWireModelComponents);
    public sealed virtual IEnumerable`1<TransactionTraceWireModelComponents> GetCollectedSamples();
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.TransactionTraces.SlowestTransactionCollector : object {
    private ConcurrentBag`1 modreq(System.Runtime.CompilerServices.IsVolatile) _slowTransactions;
    protected ConfigurationSubscriber ConfigurationSubscription;
    public sealed virtual void Collect(TransactionTraceWireModelComponents transactionTraceWireModelComponents);
    public sealed virtual IEnumerable`1<TransactionTraceWireModelComponents> GetCollectedSamples();
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.TransactionTraces.SyntheticsTransactionCollector : object {
    private ConcurrentBag`1 modreq(System.Runtime.CompilerServices.IsVolatile) _collectedSamples;
    public sealed virtual void Collect(TransactionTraceWireModelComponents transactionTraceWireModelComponents);
    public sealed virtual IEnumerable`1<TransactionTraceWireModelComponents> GetCollectedSamples();
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Transformers.CpuSampleTransformer : object {
    protected IMetricBuilder MetricBuilder;
    private IMetricAggregator _metricAggregator;
    public CpuSampleTransformer(IMetricBuilder metricBuilder, IMetricAggregator metricAggregator);
    public sealed virtual void Transform(ImmutableCpuSample sample);
    private void RecordMetric(MetricWireModel metric);
    private TimeSpan GetCpuUserTime(TimeSpan currentUserProcessorTime, TimeSpan lastUserProcessorTime);
    private float GetCpuUserUtilization(TimeSpan cpuUserTime, DateTime currentSampleTime, DateTime lastSampleTime, int processorCount);
}
public class NewRelic.Agent.Core.Transformers.CustomErrorDataTransformer : object {
    private IConfigurationService _configurationService;
    private IAttributeDefinitionService _attribDefSvc;
    private IErrorTraceMaker _errorTraceMaker;
    private IErrorEventMaker _errorEventMaker;
    private IErrorTraceAggregator _errorTraceAggregator;
    private IErrorEventAggregator _errorEventAggregator;
    private IAttributeDefinitions _attribDefs { get; }
    public CustomErrorDataTransformer(IConfigurationService configurationService, IAttributeDefinitionService attribDefSvc, IErrorTraceMaker errorTraceMaker, IErrorTraceAggregator errorTraceAggregator, IErrorEventMaker errorEventMaker, IErrorEventAggregator errorEventAggregator);
    private IAttributeDefinitions get__attribDefs();
    public sealed virtual void Transform(ErrorData errorData, float priority, string userid);
}
public class NewRelic.Agent.Core.Transformers.CustomEventTransformer : object {
    private static string EventTypeRegexText;
    private static int CustomEventTypeMaxLengthBytes;
    private static Regex EventTypeRegex;
    private IConfigurationService _configurationService;
    private ICustomEventAggregator _customEventAggregator;
    private IAttributeDefinitionService _attribDefSvc;
    private IAttributeDefinitions _attribDefs { get; }
    public CustomEventTransformer(IConfigurationService configurationService, ICustomEventAggregator customEventAggregator, IAttributeDefinitionService attribDefSvc);
    private static CustomEventTransformer();
    private IAttributeDefinitions get__attribDefs();
    public sealed virtual void Transform(string eventType, IEnumerable`1<KeyValuePair`2<string, object>> attributes, float priority);
}
public class NewRelic.Agent.Core.Transformers.GcSampleTransformer : object {
    private IMetricBuilder _metricBuilder;
    private IMetricAggregator _metricAggregator;
    private Dictionary`2<GCSampleType, Func`3<GCSampleType, float, MetricWireModel>> _metricBuilderHandlers;
    public GcSampleTransformer(IMetricBuilder metricBuilder, IMetricAggregator metricAggregator);
    public sealed virtual void Transform(Dictionary`2<GCSampleType, float> sampleValues);
    private MetricWireModel CreateMetric_Gauge(GCSampleType sampleType, float sampleValue);
    private MetricWireModel CreateMetric_Count(GCSampleType sampleType, float sampleValue);
    private MetricWireModel CreateMetric_ByteData(GCSampleType sampleType, float sampleValue);
    private MetricWireModel CreateMetric_Percent(GCSampleType sampleType, float sampleValue);
    private void RecordMetrics(IEnumerable`1<MetricWireModel> metrics);
}
public interface NewRelic.Agent.Core.Transformers.ICpuSampleTransformer {
    public abstract virtual void Transform(ImmutableCpuSample sample);
}
public interface NewRelic.Agent.Core.Transformers.ICustomErrorDataTransformer {
    public abstract virtual void Transform(ErrorData errorData, float priority, string userid);
}
public interface NewRelic.Agent.Core.Transformers.ICustomEventTransformer {
    public abstract virtual void Transform(string eventType, IEnumerable`1<KeyValuePair`2<string, object>> attributes, float priority);
}
public interface NewRelic.Agent.Core.Transformers.IGcSampleTransformer {
    public abstract virtual void Transform(Dictionary`2<GCSampleType, float> sampleValues);
}
public interface NewRelic.Agent.Core.Transformers.IMemorySampleTransformer {
    public abstract virtual void Transform(ImmutableMemorySample sample);
}
public interface NewRelic.Agent.Core.Transformers.IThreadStatsSampleTransformer {
    public abstract virtual void Transform(ThreadpoolUsageStatsSample threadpoolStats);
    public abstract virtual void Transform(ThreadpoolThroughputEventsSample threadpoolEventStats);
}
public class NewRelic.Agent.Core.Transformers.MemorySampleTransformer : object {
    private IMetricBuilder _metricBuilder;
    private IMetricAggregator _metricAggregator;
    private bool _isWindows;
    public MemorySampleTransformer(IMetricBuilder metricBuilder, IMetricAggregator metricAggregator, IsWindowsDelegate getIsWindows);
    public sealed virtual void Transform(ImmutableMemorySample sample);
    private void RecordMemoryPhysicalMetric(long memoryValue);
    private void RecordMemoryWorkingSetMetric(long memoryValue);
    private void RecordMetric(MetricWireModel metric);
}
public class NewRelic.Agent.Core.Transformers.ThreadStatsSampleTransformer : object {
    private IMetricBuilder _metricBuilder;
    private IMetricAggregator _metricAggregator;
    public ThreadStatsSampleTransformer(IMetricBuilder metricBuilder, IMetricAggregator metricAggregator);
    public sealed virtual void Transform(ThreadpoolUsageStatsSample threadpoolStats);
    public sealed virtual void Transform(ThreadpoolThroughputEventsSample throughputStats);
    private void RecordMetrics(MetricWireModel[] metrics);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.ErrorEventMaker : object {
    private static string SetErrorGroupSupportabilityName;
    private static string ExceptionAttributeName;
    private static string StackTraceAttributeName;
    private IConfigurationService _configurationService;
    private IAttributeDefinitionService _attribDefSvc;
    private IAgentTimerService _agentTimerService;
    private IAttributeDefinitions _attribDefs { get; }
    public ErrorEventMaker(IAttributeDefinitionService attributeService, IConfigurationService configurationService, IAgentTimerService agentTimerService);
    private IAttributeDefinitions get__attribDefs();
    public sealed virtual ErrorEventWireModel GetErrorEvent(ErrorData errorData, IAttributeValueCollection attribValues, float priority);
    public sealed virtual ErrorEventWireModel GetErrorEvent(ImmutableTransaction immutableTransaction, IAttributeValueCollection attribValues);
    private IList`1<string> GetFormattedStackTrace(ErrorData errorData);
    private void SetErrorGroup(ErrorData errorData, IAttributeValueCollection attribValues);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.ErrorTraceMaker : object {
    private static string SetErrorGroupSupportabilityName;
    private static string ExceptionAttributeName;
    private static string StackTraceAttributeName;
    private IConfigurationService _configurationService;
    private IAttributeDefinitionService _attribDefSvc;
    private IAgentTimerService _agentTimerService;
    private IAttributeDefinitions _attribDefs { get; }
    public ErrorTraceMaker(IConfigurationService configurationService, IAttributeDefinitionService attributeService, IAgentTimerService agentTimerService);
    private IAttributeDefinitions get__attribDefs();
    public sealed virtual ErrorTraceWireModel GetErrorTrace(IAttributeValueCollection attribValues, ErrorData errorData);
    public sealed virtual ErrorTraceWireModel GetErrorTrace(ImmutableTransaction immutableTransaction, IAttributeValueCollection transactionAttributes, TransactionMetricName transactionMetricName);
    private IList`1<string> GetFormattedStackTrace(ErrorData errorData);
    private ErrorTraceAttributesWireModel GetErrorTraceAttributes(IAttributeValueCollection attributes, IList`1<string> stackTrace);
    private void SetErrorGroup(ErrorData errorData, IList`1<string> stackTrace, IAttributeValueCollection attribValues);
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.IErrorEventMaker {
    public abstract virtual ErrorEventWireModel GetErrorEvent(ImmutableTransaction immutableTransaction, IAttributeValueCollection attribValues);
    public abstract virtual ErrorEventWireModel GetErrorEvent(ErrorData errorData, IAttributeValueCollection attribValues, float priority);
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.IErrorTraceMaker {
    public abstract virtual ErrorTraceWireModel GetErrorTrace(ImmutableTransaction immutableTransaction, IAttributeValueCollection attributeValues, TransactionMetricName transactionMetricName);
    public abstract virtual ErrorTraceWireModel GetErrorTrace(IAttributeValueCollection attributeValues, ErrorData errorData);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.ImmutableSegmentTreeNode : object {
    public Segment Segment;
    public IEnumerable`1<ImmutableSegmentTreeNode> Children;
    public TimeSpan TotalChildDuration;
    public bool Unfinished { get; }
    public ImmutableSegmentTreeNode(Segment segment, IEnumerable`1<ImmutableSegmentTreeNode> children);
    public bool get_Unfinished();
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.ISegmentTreeMaker {
    public abstract virtual IEnumerable`1<ImmutableSegmentTreeNode> BuildSegmentTrees(IEnumerable`1<Segment> segments);
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.ISqlTraceMaker {
    public abstract virtual SqlTraceWireModel TryGetSqlTrace(ImmutableTransaction immutableTransaction, TransactionMetricName transactionMetricName, Segment segment);
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.ITransactionAttributeMaker {
    public abstract virtual IAttributeValueCollection GetAttributes(ImmutableTransaction immutableTransaction, TransactionMetricName transactionMetricName, Nullable`1<TimeSpan> apdexT, TimeSpan totalTime, TransactionMetricStatsCollection txStats);
    public abstract virtual void SetUserAndAgentAttributes(IAttributeValueCollection attribValues, ITransactionAttributeMetadata metadata);
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.ITransactionEventMaker {
    public abstract virtual TransactionEventWireModel GetTransactionEvent(ImmutableTransaction immutableTransaction, IAttributeValueCollection attributes);
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.ITransactionMetricNameMaker {
    public abstract virtual TransactionMetricName GetTransactionMetricName(ITransactionName transactionName);
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.ITransactionTraceMaker {
    public abstract virtual TransactionTraceWireModel GetTransactionTrace(ImmutableTransaction immutableTransaction, IEnumerable`1<ImmutableSegmentTreeNode> segmentTrees, TransactionMetricName transactionMetricName, IAttributeValueCollection attributes);
}
public interface NewRelic.Agent.Core.Transformers.TransactionTransformer.ITransactionTransformer {
    public abstract virtual void Transform(IInternalTransaction transaction);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.SegmentTreeMaker : object {
    public sealed virtual IEnumerable`1<ImmutableSegmentTreeNode> BuildSegmentTrees(IEnumerable`1<Segment> segments);
    private static void CombineSimilarChildren(SegmentTreeNodeBuilder node);
    private static SegmentTreeNodeBuilder GetCombinedNode(IEnumerable`1<SegmentTreeNodeBuilder> nodes);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.SegmentTreeNodeBuilder : object {
    public Segment Segment;
    public IList`1<SegmentTreeNodeBuilder> Children;
    public SegmentTreeNodeBuilder(Segment segment);
    public ImmutableSegmentTreeNode Build();
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.SqlTraceMaker : object {
    private IConfigurationService _configurationService;
    private IAttributeDefinitionService _attribDefSvc;
    private IDatabaseService _databaseService;
    private IAttributeDefinitions _attribDefs { get; }
    public SqlTraceMaker(IConfigurationService configurationService, IAttributeDefinitionService attribDefSvc, IDatabaseService databaseService);
    private IAttributeDefinitions get__attribDefs();
    public sealed virtual SqlTraceWireModel TryGetSqlTrace(ImmutableTransaction immutableTransaction, TransactionMetricName transactionMetricName, Segment segment);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.TransactionAttributeMaker : object {
    private IConfigurationService _configurationService;
    private IAttributeDefinitionService _attribDefSvc;
    private IAttributeDefinitions _attribDefs { get; }
    public TransactionAttributeMaker(IConfigurationService configurationService, IAttributeDefinitionService attribDefSvc);
    private IAttributeDefinitions get__attribDefs();
    public sealed virtual IAttributeValueCollection GetAttributes(ImmutableTransaction immutableTransaction, TransactionMetricName transactionMetricName, Nullable`1<TimeSpan> apdexT, TimeSpan totalTime, TransactionMetricStatsCollection txStats);
    private void SetIntrinsicAttributes(IAttributeValueCollection attribValues, ImmutableTransaction immutableTransaction, TransactionMetricName transactionMetricName, Nullable`1<TimeSpan> apdexT, TimeSpan totalTime, TransactionMetricStatsCollection txStats);
    public sealed virtual void SetUserAndAgentAttributes(IAttributeValueCollection attribValues, ITransactionAttributeMetadata metadata);
    private static bool IsCatParticipant(ImmutableTransaction immutableTransaction);
    private static bool IsSyntheticsParticipant(ImmutableTransaction immutableTransaction);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.TransactionEventMaker : object {
    private IAttributeDefinitionService _attribDefSvc;
    private IAttributeDefinitions _attribDefs { get; }
    public TransactionEventMaker(IAttributeDefinitionService attribDefSvc);
    private IAttributeDefinitions get__attribDefs();
    public sealed virtual TransactionEventWireModel GetTransactionEvent(ImmutableTransaction immutableTransaction, IAttributeValueCollection attribValues);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.TransactionMetricName : ValueType {
    public string Prefix;
    public string UnPrefixedName;
    public string PrefixedName;
    public bool IsWebTransactionName;
    public bool ShouldIgnore;
    public TransactionMetricName(string prefix, string unprefixedName, bool shouldIgnore);
    public virtual string ToString();
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.TransactionMetricNameMaker : object {
    private IMetricNameService _metricNameService;
    public TransactionMetricNameMaker(IMetricNameService metricNameService);
    public sealed virtual TransactionMetricName GetTransactionMetricName(ITransactionName transactionName);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.TransactionTraceMaker : object {
    private IConfigurationService _configurationService;
    private IAttributeDefinitionService _attribDefSvc;
    private IAttributeDefinitions _attribDefs { get; }
    public TransactionTraceMaker(IConfigurationService configurationService, IAttributeDefinitionService attribDefSvc);
    private IAttributeDefinitions get__attribDefs();
    public sealed virtual TransactionTraceWireModel GetTransactionTrace(ImmutableTransaction immutableTransaction, IEnumerable`1<ImmutableSegmentTreeNode> segmentTrees, TransactionMetricName transactionMetricName, IAttributeValueCollection attribValues);
    private TransactionTraceSegment GetRootSegment(IEnumerable`1<ImmutableSegmentTreeNode> segmentTrees, ImmutableTransaction immutableTransaction);
    private TransactionTraceSegment GetFauxTopLevelSegment(IEnumerable`1<ImmutableSegmentTreeNode> segmentTrees, ImmutableTransaction immutableTransaction);
    private TransactionTraceSegment CreateTransactionTraceSegment(ImmutableSegmentTreeNode node, ImmutableTransaction immutableTransaction);
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.TransactionTraceWireModelComponents : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSynthetics>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionMetricName <TransactionMetricName>k__BackingField;
    private GenerateWireModel _generateWireModel;
    public TimeSpan Duration { get; }
    public bool IsSynthetics { get; }
    public TransactionMetricName TransactionMetricName { get; }
    public TransactionTraceWireModelComponents(TransactionMetricName transactionMetricName, TimeSpan duration, bool isSynthetics, GenerateWireModel generateWireModel);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public bool get_IsSynthetics();
    [CompilerGeneratedAttribute]
public TransactionMetricName get_TransactionMetricName();
    internal TransactionTraceWireModel CreateWireModel();
}
public class NewRelic.Agent.Core.Transformers.TransactionTransformer.TransactionTransformer : object {
    private ITransactionMetricNameMaker _transactionMetricNameMaker;
    private ISegmentTreeMaker _segmentTreeMaker;
    private IMetricNameService _metricNameService;
    private IMetricAggregator _metricAggregator;
    private IConfigurationService _configurationService;
    private ITransactionTraceAggregator _transactionTraceAggregator;
    private ITransactionTraceMaker _transactionTraceMaker;
    private ITransactionEventAggregator _transactionEventAggregator;
    private ITransactionEventMaker _transactionEventMaker;
    private ISpanEventAggregator _spanEventAggregator;
    private ISpanEventAggregatorInfiniteTracing _spanEventAggregatorInfiniteTracing;
    private ISpanEventMaker _spanEventMaker;
    private ITransactionAttributeMaker _transactionAttributeMaker;
    private IErrorTraceAggregator _errorTraceAggregator;
    private IErrorTraceMaker _errorTraceMaker;
    private IErrorEventAggregator _errorEventAggregator;
    private IErrorEventMaker _errorEventMaker;
    private ISqlTraceAggregator _sqlTraceAggregator;
    private ISqlTraceMaker _sqlTraceMaker;
    private IAgentTimerService _agentTimerService;
    private IAdaptiveSampler _adaptiveSampler;
    private IErrorService _errorService;
    private ILogEventAggregator _logEventAggregator;
    public TransactionTransformer(ITransactionMetricNameMaker transactionMetricNameMaker, ISegmentTreeMaker segmentTreeMaker, IMetricNameService metricNameService, IMetricAggregator metricAggregator, IConfigurationService configurationService, ITransactionTraceAggregator transactionTraceAggregator, ITransactionTraceMaker transactionTraceMaker, ITransactionEventAggregator transactionEventAggregator, ITransactionEventMaker transactionEventMaker, ITransactionAttributeMaker transactionAttributeMaker, IErrorTraceAggregator errorTraceAggregator, IErrorTraceMaker errorTraceMaker, IErrorEventAggregator errorEventAggregator, IErrorEventMaker errorEventMaker, ISqlTraceAggregator sqlTraceAggregator, ISqlTraceMaker sqlTraceMaker, ISpanEventAggregator spanEventAggregator, ISpanEventMaker spanEventMaker, IAgentTimerService agentTimerService, IAdaptiveSampler adaptiveSampler, IErrorService errorService, ISpanEventAggregatorInfiniteTracing spanEventAggregatorInfiniteTracing, ILogEventAggregator logEventAggregator);
    public sealed virtual void Transform(IInternalTransaction transaction);
    private void Transform(ImmutableTransaction immutableTransaction, TransactionMetricName transactionMetricName);
    private static void FinishSegments(IEnumerable`1<Segment> segments);
    private static TimeSpan GetTotalExclusiveTime(IEnumerable`1<Segment> segments);
    private ErrorTraceWireModel GenerateErrorTrace(ImmutableTransaction immutableTransaction, IAttributeValueCollection attributes, TransactionMetricName transactionMetricName);
    private Nullable`1<TimeSpan> GetApdexT(ImmutableTransaction immutableTransaction, string transactionApdexMetricName);
    private void GenerateAndCollectErrorEventTracesAndEvents(ImmutableTransaction immutableTransaction, IAttributeValueCollection attributes, TransactionMetricName transactionMetricName);
    private void GenerateAndCollectMetrics(ImmutableTransaction immutableTransaction, Nullable`1<TimeSpan> apdexT, string transactionApdexMetricName, TimeSpan totalTime, TransactionMetricStatsCollection txStats);
    private void GenerateAndCollectTransactionEvent(ImmutableTransaction immutableTransaction, Func`1<IAttributeValueCollection> attributes);
    private void GenerateAndCollectSpanEvents(ImmutableTransaction immutableTransaction, string transactionName, Func`1<IAttributeValueCollection> attributes);
    private void GenerateAndCollectTransactionTrace(ImmutableTransaction immutableTransaction, TransactionMetricName transactionMetricName, Func`1<IAttributeValueCollection> attributes);
    private void GenerateAndCollectSqlTrace(ImmutableTransaction immutableTransaction, TransactionMetricName transactionMetricName, TransactionMetricStatsCollection txStats);
    private void TryGenerateExplainPlans(IEnumerable`1<Segment> segments);
    private void GenerateSegmentMetrics(Segment segment, TransactionMetricStatsCollection txStats);
    private void GetApdexMetrics(ImmutableTransaction immutableTransaction, TimeSpan apdexT, string transactionApdexMetricName, TransactionMetricStatsCollection txStats);
    private void AddSqlTraceStats(SqlTraceStatsCollection txSqlTrStats, SqlTraceWireModel model);
    private void ComputeSampled(IInternalTransaction transaction);
    private bool ErrorCollectionEnabled();
    private void PrioritizeAndCollectLogEvents(IInternalTransaction transaction);
}
[NrExcludeFromCodeCoverageAttribute]
public class NewRelic.Agent.Core.UTCTimestampEnricher : object {
    public static string UTCTimestampPropertyName;
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Utilities.ActionExtensions : object {
    [ExtensionAttribute]
public static void CatchAndLog(Action action);
}
public class NewRelic.Agent.Core.Utilities.AgentTimer : object {
    private IAgentHealthReporter _agentHealthReporter;
    private string _eventName;
    private Stopwatch _stopWatch;
    public AgentTimer(IAgentHealthReporter agentHealthReporter, string eventName);
    public sealed virtual void Start();
    public sealed virtual void StopAndRecordMetric();
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Utilities.AgentTimerService : ConfigurationBasedService {
    private ConcurrentDictionary`2<string, InterlockedLongCounter> _eventCounters;
    private bool _enabled;
    private int _sampleFrequency;
    private IAgentHealthReporter _agentHealthReporter;
    public AgentTimerService(IAgentHealthReporter agentHealthReporter);
    public sealed virtual IAgentTimer StartNew(String[] nameParts);
    private IAgentTimer StartNewImpl(string eventName);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
[AttributeUsageAttribute("1")]
public class NewRelic.Agent.Core.Utilities.BuildTimestampAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BuildTimestamp>k__BackingField;
    public Nullable`1<long> BuildTimestamp { get; }
    public BuildTimestampAttribute(string utcTicksAsString);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BuildTimestamp();
}
public class NewRelic.Agent.Core.Utilities.Clamper : object {
    private static int CLAMPED_STRING_LENGTH;
    private static int CLAMPED_EXCEPTION_LENGTH;
    public static string ClampLength(string fromUser);
    public static Exception ClampLength(Exception fromUser);
    public static string ClampLength(string fromUser, int maxLength);
    public static IDictionary`2<string, string> ClampLength(IDictionary`2<string, string> fromUser, int maxLength);
    public static Exception ClampLength(Exception fromUser, int maxLength);
}
public abstract class NewRelic.Agent.Core.Utilities.ConfigurationBasedService : DisposableService {
    private EventSubscription`1<ConfigurationUpdatedEvent> _configurationUpdatedEventSubscription;
    [CompilerGeneratedAttribute]
private IConfiguration <_configuration>k__BackingField;
    protected IConfiguration _configuration { get; private set; }
    [CompilerGeneratedAttribute]
protected IConfiguration get__configuration();
    [CompilerGeneratedAttribute]
private void set__configuration(IConfiguration value);
    protected abstract virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
    protected void OnConfigurationUpdatedInternal(ConfigurationUpdatedEvent eventData);
    public virtual void Dispose();
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Utilities.DateTimeExtensions : object {
    private static DateTime Epoch;
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1970;
    public static long UnixEpochTicks;
    private static long UnixEpochMilliseconds;
    private static DateTimeExtensions();
    [ExtensionAttribute]
public static long ToUnixTimeMilliseconds(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime FromUnixTimeMilliseconds(long unixTimeMilliseconds);
    [ExtensionAttribute]
public static double ToUnixTimeSeconds(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime ToDateTime(double secondsSinceEpoch);
}
public class NewRelic.Agent.Core.Utilities.DateTimeRange : ValueType {
    public TimeSpan StartTime;
    public TimeSpan EndTime;
    public TimeSpan Duration { get; }
    public DateTimeRange(TimeSpan startTime, TimeSpan endTime);
    public TimeSpan get_Duration();
    public bool Overlaps(DateTimeRange other);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Utilities.DictionaryExtensions : object {
    [ExtensionAttribute]
public static void Merge(IDictionary`2<TKey, TValue> me, IDictionary`2<TKey, TValue> merge);
    [ExtensionAttribute]
public static IDictionary`2<string, object> DowncastCopyConstruct(IEnumerable`1<KeyValuePair`2<string, T>> source);
    [ExtensionAttribute]
public static void AddIfNotNull(IDictionary`2<T, U> dictionary, T key, U value);
    [ExtensionAttribute]
public static void AddStringIfNotNullOrEmpty(IDictionary`2<T, object> dictionary, T key, string value);
    [ExtensionAttribute]
public static void AddTimespanIfNotNull(IDictionary`2<T, object> dictionary, T key, Nullable`1<TimeSpan> value, TimeUnit timeUnit);
    [ExtensionAttribute]
public static ReadOnlyDictionary`2<TKey, TValue> WrapInReadOnly(IDictionary`2<TKey, TValue> source);
    [ExtensionAttribute]
public static ReadOnlyDictionary`2<TKey, TValue> CopyToReadOnly(IDictionary`2<TKey, TValue> source);
}
public class NewRelic.Agent.Core.Utilities.DisposableCollection : object {
    private ICollection`1<IDisposable> _disposables;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<IDisposable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(IDisposable item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IDisposable item);
    public sealed virtual void CopyTo(IDisposable[] array, int arrayIndex);
    public sealed virtual bool Remove(IDisposable item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public abstract class NewRelic.Agent.Core.Utilities.DisposableService : object {
    [CompilerGeneratedAttribute]
private Subscriptions <_subscriptions>k__BackingField;
    protected Subscriptions _subscriptions { get; private set; }
    [CompilerGeneratedAttribute]
protected Subscriptions get__subscriptions();
    [CompilerGeneratedAttribute]
private void set__subscriptions(Subscriptions value);
    public virtual void Dispose();
}
public enum NewRelic.Agent.Core.Utilities.DotnetCoreVersion : Enum {
    public int value__;
    public static DotnetCoreVersion LessThan30;
    public static DotnetCoreVersion netcoreapp30;
    public static DotnetCoreVersion netcoreapp31;
    public static DotnetCoreVersion net5;
    public static DotnetCoreVersion net6;
    public static DotnetCoreVersion net7;
    public static DotnetCoreVersion net8;
    public static DotnetCoreVersion Other;
}
public enum NewRelic.Agent.Core.Utilities.DotnetFrameworkVersion : Enum {
    public int value__;
    public static DotnetFrameworkVersion LessThan45;
    public static DotnetFrameworkVersion net45;
    public static DotnetFrameworkVersion net451;
    public static DotnetFrameworkVersion net452;
    public static DotnetFrameworkVersion net46;
    public static DotnetFrameworkVersion net461;
    public static DotnetFrameworkVersion net462;
    public static DotnetFrameworkVersion net47;
    public static DotnetFrameworkVersion net471;
    public static DotnetFrameworkVersion net472;
    public static DotnetFrameworkVersion net48;
    public static DotnetFrameworkVersion net481;
}
public static class NewRelic.Agent.Core.Utilities.DotnetVersion : object {
    public static DotnetFrameworkVersion GetDotnetFrameworkVersion();
    public static bool IsUnsupportedDotnetCoreVersion(DotnetCoreVersion version);
    public static bool IsUnsupportedDotnetFrameworkVersion(DotnetFrameworkVersion version);
    [CompilerGeneratedAttribute]
internal static DotnetFrameworkVersion <GetDotnetFrameworkVersion>g__CheckFor45PlusVersion|0_0(int releaseKey);
}
public static class NewRelic.Agent.Core.Utilities.EventBus`1 : object {
    [CompilerGeneratedAttribute]
private static Action`1<T> Events;
    private static ReaderWriterLock Lock;
    private static ReaderLockGuard ReaderLockGuard;
    private static WriterLockGuard WriterLockGuard;
    private static EventBus`1();
    [CompilerGeneratedAttribute]
private static void add_Events(Action`1<T> value);
    [CompilerGeneratedAttribute]
private static void remove_Events(Action`1<T> value);
    public static void Subscribe(Action`1<T> callback);
    public static void Unsubscribe(Action`1<T> callback);
    public static void Publish(T message);
}
public class NewRelic.Agent.Core.Utilities.EventSubscription`1 : object {
    private Action`1<T> _callback;
    public EventSubscription`1(Action`1<T> callback);
    public sealed virtual void Dispose();
}
[NrCoveredByIntegrationTestsAttribute]
public class NewRelic.Agent.Core.Utilities.ExtensionsLoader : object {
    private static Dictionary`2<string, string> _dynamicLoadWrapperAssemblies;
    private static string _installPathExtensionsDirectory;
    private static String[] _autoReflectedAssemblies;
    private static Dictionary`2<string, IWrapper[]> _dynamicLoadAssemblyStatus;
    private static object _loadDynamicWrapperLockObj;
    private static ExtensionsLoader();
    [NrExcludeFromCodeCoverageAttribute]
public static void Initialize(string installPathExtensionsDirectory);
    private static IEnumerable`1<T> AutoLoadExtensions();
    public static IEnumerable`1<IWrapper> LoadWrappers();
    private static List`1<string> GetAssemblyFilesFromFolder(string folder);
    public static IEnumerable`1<IContextStorageFactory> LoadContextStorageFactories();
    public static IEnumerable`1<IWrapper> LoadDynamicWrapper(string assemblyPath);
    public static IEnumerable`1<IWrapper> TryGetDynamicWrapperInstance(string requestedWrapperName);
    private static bool IsValid(IContextStorageFactory factory);
}
public class NewRelic.Agent.Core.Utilities.FileWrapper : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual FileStream OpenWrite(string path);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Utilities.FuncExtension : object {
    [ExtensionAttribute]
public static Func`1<R> Memoize(Func`1<R> func);
}
[NrExcludeFromCodeCoverageAttribute]
public static class NewRelic.Agent.Core.Utilities.GuidGenerator : object {
    private static RNGCryptoServiceProvider RngCryptoServiceProvider;
    private static Func`1<string> _traceGeneratorFunc;
    private static bool _initialized;
    private static object _lockObj;
    private static bool _hasDiagnosticSourceReference;
    private static Func`2<object, object> _fieldReadAccessor;
    private static Func`2<object, object> _valuePropertyAccessor;
    private static Func`2<object, object> _traceIdGetter;
    private static Func`2<object, object> _idFormatGetter;
    private static GuidGenerator();
    public static string GenerateNewRelicGuid();
    public static string GenerateNewRelicTraceId();
    private static string GenerateTraceId();
    private static string GetTraceIdFromCurrentActivity();
}
public static class NewRelic.Agent.Core.Utilities.HeaderEncoder : object {
    public static string SerializeAndEncode(object data, string encodingKey);
    public static T TryDecodeAndDeserialize(string encodedString, string encodingKey);
    public static string EncodeSerializedData(string serializedData, string encodingKey);
    private static string DecodeSerializedData(string encodedString, string encodingKey);
}
public interface NewRelic.Agent.Core.Utilities.IAgentTimer {
    public abstract virtual void Start();
    public abstract virtual void StopAndRecordMetric();
}
public interface NewRelic.Agent.Core.Utilities.IAgentTimerService {
    public abstract virtual IAgentTimer StartNew(String[] nameParts);
}
public interface NewRelic.Agent.Core.Utilities.IFileWrapper {
    public abstract virtual bool Exists(string path);
    public abstract virtual FileStream OpenWrite(string path);
}
[DebuggerDisplayAttribute("{_value}")]
public class NewRelic.Agent.Core.Utilities.InterlockedCounter : object {
    private int _value;
    public int Value { get; }
    public InterlockedCounter(int initialValue);
    public int get_Value();
    public int Increment();
    public int Decrement();
    public int Add(int value);
    public int Exchange(int value);
    public int CompareExchange(int value, int comparand);
    public void Set(int value);
}
[DebuggerDisplayAttribute("{_value}")]
public class NewRelic.Agent.Core.Utilities.InterlockedLongCounter : object {
    private long _value;
    public long Value { get; }
    public InterlockedLongCounter(long initialValue);
    public long get_Value();
    public long Increment();
    public long Decrement();
    public long Add(int value);
    public long Add(UInt32 value);
    public long Add(long value);
    public long Add(ulong value);
    public long Exchange(long value);
    public long CompareExchange(long value, long comparand);
    public void Set(long value);
}
public interface NewRelic.Agent.Core.Utilities.ISystemInfo {
    public abstract virtual Nullable`1<ulong> GetTotalPhysicalMemoryBytes();
    public abstract virtual Nullable`1<int> GetTotalLogicalProcessors();
    public abstract virtual BootIdResult GetBootId();
}
public class NewRelic.Agent.Core.Utilities.Memoizer : object {
    public static T Memoize(T& backer, Func`1<T> evaluator);
    public static T Memoize(Nullable`1& backer, Func`1<T> evaluator);
}
public class NewRelic.Agent.Core.Utilities.NrCoveredByIntegrationTestsAttribute : Attribute {
}
public class NewRelic.Agent.Core.Utilities.NrExcludeFromCodeCoverageAttribute : Attribute {
}
public class NewRelic.Agent.Core.Utilities.ReaderLockGuard : object {
    private ReaderWriterLock _lock;
    public ReaderLockGuard(ReaderWriterLock readerWriterLock);
    public ReaderLockGuard Acquire();
    public sealed virtual void Dispose();
}
public static class NewRelic.Agent.Core.Utilities.RequestBus`2 : object {
    private static IList`1<RequestHandler<TRequest, TResponse>> RequestHandlers;
    private static ReaderWriterLock Lock;
    private static ReaderLockGuard ReaderLockGuard;
    private static WriterLockGuard WriterLockGuard;
    private static RequestBus`2();
    public static void AddResponder(RequestHandler<TRequest, TResponse> requestHandler);
    public static void RemoveResponder(RequestHandler<TRequest, TResponse> requestHandler);
    public static void Post(TRequest request, ResponsesCallback<TRequest, TResponse> responsesCallback);
    public static void Post(TRequest request, ResponseCallback<TRequest, TResponse> responseCallback);
    public static TResponse Post(TRequest request);
    private static void ValidateTResponse();
}
public class NewRelic.Agent.Core.Utilities.RequestSubscription`2 : object {
    private RequestHandler<TRequest, TResponse> _requestHandler;
    public RequestSubscription`2(RequestHandler<TRequest, TResponse> requestHandler);
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Utilities.SignalableAction : object {
    private Thread _worker;
    private object _lock;
    private bool _signaled;
    private CancellationTokenSource _cancellationTokenSource;
    public SignalableAction(Action action, int delay);
    public void Start();
    public void Signal();
    public sealed virtual void Dispose();
}
public static class NewRelic.Agent.Core.Utilities.StackTraces : object {
    public static ICollection`1<string> ScrubAndTruncate(Exception exception, int maxDepth);
    public static string MethodToString(MethodBase method);
    private static string FormatMethodParameters(ParameterInfo[] parameterInfo);
    public static IList`1<string> ScrubAndTruncate(string stackTrace, int maxDepth);
    public static String[] ParseStackTrace(string stackTrace);
    public static IList`1<StackFrame> ScrubAndTruncate(StackTrace stackTrace, int maxDepth);
    public static IList`1<StackFrame> ScrubAndTruncate(StackFrame[] frames, int maxDepth);
    public static string ToString(StackFrame frame);
    public static ICollection`1<string> ToStringList(IList`1<StackFrame> stackFrames);
    public static object ToJson(Exception ex);
}
[ExtensionAttribute]
public static class NewRelic.Agent.Core.Utilities.Strings : object {
    private static UTF8Encoding _encoding;
    private static Strings();
    public static string SafeFileName(string name);
    public static string TryBase64Decode(string val, string encodingKey);
    public static string Base64Decode(string val, string encodingKey);
    public static string Base64Encode(string val, string encodingKey);
    private static Byte[] EncodeWithKey(Byte[] bytes, string key);
    public static string ObfuscateStringWithKey(string val, string key);
    public static string ToString(IEnumerable enumerable, char separator);
    [ExtensionAttribute]
public static string Replace(string originalString, string oldValue, string newValue, StringComparison comparisonType, int count);
    public static string GetStringBufferFromBytes(Decoder decoder, Byte[] buffer, int offset, int count);
    public static string ObfuscateLicenseKeyInAuditLog(string text, string licenseKeyParameterName);
    public static string ObfuscateLicenseKey(string licenseKey);
}
public class NewRelic.Agent.Core.Utilities.Subscriptions : object {
    private ICollection`1<IDisposable> _subscriptions;
    public void Add(Action`1<T> callback);
    public void Add(RequestHandler<TRequest, TResponse> requestHandler);
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Utilities.SystemInfo : object {
    private IDnsStatic _dnsStatic;
    private static int ExpectedBootIdLength;
    private static int AsciiMaxValue;
    public SystemInfo(IDnsStatic dnsStatic);
    public sealed virtual Nullable`1<ulong> GetTotalPhysicalMemoryBytes();
    public sealed virtual Nullable`1<int> GetTotalLogicalProcessors();
    public sealed virtual BootIdResult GetBootId();
    private bool ValidateBootId(string bootId);
    private static bool IsAsciiString(string inputString);
    private static bool GlobalMemoryStatusEx(MemoryStatus& buffer);
}
public enum NewRelic.Agent.Core.Utilities.TimeUnit : Enum {
    public int value__;
    public static TimeUnit Ticks;
    public static TimeUnit Milliseconds;
    public static TimeUnit Seconds;
    public static TimeUnit Minutes;
    public static TimeUnit Hours;
    public static TimeUnit Days;
    public static TimeUnit Years;
}
[AttributeUsageAttribute("32767")]
public class NewRelic.Agent.Core.Utilities.ToBeRemovedInFutureReleaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Notes>k__BackingField;
    public string Notes { get; private set; }
    public ToBeRemovedInFutureReleaseAttribute(string notes);
    [CompilerGeneratedAttribute]
public string get_Notes();
    [CompilerGeneratedAttribute]
private void set_Notes(string value);
}
public class NewRelic.Agent.Core.Utilities.TrimmedEncodedBuffer : object {
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    private int _originalOffset;
    private int _originalCount;
    private Nullable`1<int> _leadingExtraBytesCount;
    private Nullable`1<int> _trailingExtraBytesOffset;
    private Nullable`1<int> _trailingExtraBytesCount;
    private bool _hasLeadingExtraBytes;
    private bool _hasTrailingExtraBytes;
    public Byte[] Buffer { get; }
    public Encoding Encoding { get; }
    public int Offset { get; }
    public int Length { get; }
    public int LeadingExtraBytesOffset { get; }
    public bool HasLeadingExtraBytes { get; }
    public int LeadingExtraBytesCount { get; }
    public int TrailingExtraBytesOffset { get; }
    public bool HasTrailingExtraBytes { get; }
    public int TrailingExtraBytesCount { get; }
    public TrimmedEncodedBuffer(Encoding encoding, Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    public int get_Offset();
    public int get_Length();
    public int get_LeadingExtraBytesOffset();
    public bool get_HasLeadingExtraBytes();
    public int get_LeadingExtraBytesCount();
    public int get_TrailingExtraBytesOffset();
    public bool get_HasTrailingExtraBytes();
    public int get_TrailingExtraBytesCount();
    private static int GetLeadingBytesCount(Encoding encoding, Byte[] buffer, int offset, int count);
    private static int GetTrailingBytesCount(Encoding encoding, Byte[] buffer, int offset, int count);
}
public class NewRelic.Agent.Core.Utilities.TypeInstantiator : object {
    private static TypeInstantiator();
    private static Assembly AssemblyFromPath(string path);
    private static IEnumerable`1<Type> ExportedTypesFromAssembly(Assembly assembly);
    private static bool TypeIsInstantiatable(Type type);
    private static bool TypeImplements(Type type);
    private static T InstanceFromType(Type type);
    private static GetTypesResult GetExportedTypes(IEnumerable`1<Assembly> assemblies);
    public static TypeInstantiatorResult`1<T> ExportedInstancesFromAssemblyPaths(String[] assemblyPaths);
    public static TypeInstantiatorResult`1<T> ExportedInstancesFromAssemblies(Assembly[] assemblies);
    public static TypeInstantiatorResult`1<T> InstancesFromTypes(IEnumerable`1<Type> types);
}
public class NewRelic.Agent.Core.Utilities.TypeInstantiatorResult`1 : object {
    public IEnumerable`1<T> Instances;
    public IEnumerable`1<Exception> Exceptions;
    public TypeInstantiatorResult`1(IEnumerable`1<T> instances, IEnumerable`1<Exception> exceptions);
}
public class NewRelic.Agent.Core.Utilities.UpdatedLoadedModulesService : DisposableService {
    private IList`1<string> _loadedModulesSeen;
    private IScheduler _scheduler;
    private IDataTransportService _dataTransportService;
    private IConfigurationService _configurationService;
    private IConfiguration _configuration { get; }
    public UpdatedLoadedModulesService(IScheduler scheduler, IDataTransportService dataTransportService, IConfigurationService configurationService);
    private IConfiguration get__configuration();
    private void GetLoadedModules();
    private void SendUpdatedLoadedModules(LoadedModuleWireModelCollection loadedModulesCollection);
    [CompilerGeneratedAttribute]
private bool <GetLoadedModules>b__7_1(Assembly assembly);
}
internal class NewRelic.Agent.Core.Utilities.WriterLockGuard : object {
    private ReaderWriterLock _lock;
    public WriterLockGuard(ReaderWriterLock readerWriterLock);
    public WriterLockGuard Acquire();
    public sealed virtual void Dispose();
}
public class NewRelic.Agent.Core.Utilization.AwsVendorModel : object {
    private string _availabilityZone;
    private string _instanceId;
    private string _instanceType;
    public string VendorName { get; }
    [JsonPropertyAttribute("availabilityZone")]
public string AvailabilityZone { get; }
    [JsonPropertyAttribute("instanceId")]
public string InstanceId { get; }
    [JsonPropertyAttribute("instanceType")]
public string InstanceType { get; }
    public AwsVendorModel(string availabilityZone, string instanceId, string instanceType);
    public sealed virtual string get_VendorName();
    public string get_AvailabilityZone();
    public string get_InstanceId();
    public string get_InstanceType();
}
public class NewRelic.Agent.Core.Utilization.AzureFunctionVendorModel : object {
    [CompilerGeneratedAttribute]
private string <AppName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudRegion>k__BackingField;
    public string VendorName { get; }
    [JsonPropertyAttribute("faas.app_name")]
public string AppName { get; }
    [JsonPropertyAttribute("cloud.region")]
public string CloudRegion { get; }
    public AzureFunctionVendorModel(string appName, string cloudRegion);
    public sealed virtual string get_VendorName();
    [CompilerGeneratedAttribute]
public string get_AppName();
    [CompilerGeneratedAttribute]
public string get_CloudRegion();
}
public class NewRelic.Agent.Core.Utilization.AzureVendorModel : object {
    private string _location;
    private string _name;
    private string _vmId;
    private string _vmSize;
    [JsonPropertyAttribute("location")]
public string Location { get; }
    [JsonPropertyAttribute("name")]
public string Name { get; }
    [JsonPropertyAttribute("vmId")]
public string VmId { get; }
    [JsonPropertyAttribute("vmSize")]
public string VmSize { get; }
    public string VendorName { get; }
    public AzureVendorModel(string location, string name, string vmId, string vmSize);
    public string get_Location();
    public string get_Name();
    public string get_VmId();
    public string get_VmSize();
    public sealed virtual string get_VendorName();
}
public class NewRelic.Agent.Core.Utilization.BootIdResult : object {
    [CompilerGeneratedAttribute]
private string <BootId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    public string BootId { get; }
    public bool IsValid { get; }
    public BootIdResult(string bootId, bool isValid);
    [CompilerGeneratedAttribute]
public string get_BootId();
    [CompilerGeneratedAttribute]
public bool get_IsValid();
}
public class NewRelic.Agent.Core.Utilization.DockerVendorModel : object {
    private string _id;
    public string VendorName { get; }
    [JsonPropertyAttribute("id")]
public string Id { get; }
    public DockerVendorModel(string id);
    public sealed virtual string get_VendorName();
    public string get_Id();
}
public class NewRelic.Agent.Core.Utilization.EcsVendorModel : object {
    private string _ecsDockerId;
    public string VendorName { get; }
    [JsonPropertyAttribute("ecsDockerId")]
public string EcsDockerId { get; }
    public EcsVendorModel(string ecsDockerId);
    public sealed virtual string get_VendorName();
    public string get_EcsDockerId();
}
public class NewRelic.Agent.Core.Utilization.FileReaderWrapper : object {
    public sealed virtual string ReadAllText(string fileName);
}
public class NewRelic.Agent.Core.Utilization.GcpVendorModel : object {
    private string _id;
    private string _machineType;
    private string _name;
    private string _zone;
    public string VendorName { get; }
    [JsonPropertyAttribute("id")]
public string Id { get; }
    [JsonPropertyAttribute("machineType")]
public string MachineType { get; }
    [JsonPropertyAttribute("name")]
public string Name { get; }
    [JsonPropertyAttribute("zone")]
public string Zone { get; }
    public GcpVendorModel(string id, string machineType, string name, string zone);
    public sealed virtual string get_VendorName();
    public string get_Id();
    public string get_MachineType();
    public string get_Name();
    public string get_Zone();
}
public interface NewRelic.Agent.Core.Utilization.IFileReaderWrapper {
    public abstract virtual string ReadAllText(string fileName);
}
public interface NewRelic.Agent.Core.Utilization.IVendorModel {
    [JsonIgnoreAttribute]
public string VendorName { get; }
    public abstract virtual string get_VendorName();
}
public class NewRelic.Agent.Core.Utilization.KubernetesVendorModel : object {
    private string _kubernetesServiceHost;
    public string VendorName { get; }
    [JsonPropertyAttribute("kubernetes_service_host")]
public string KubernetesServiceHost { get; }
    public KubernetesVendorModel(string kubernetesServiceHost);
    public sealed virtual string get_VendorName();
    public string get_KubernetesServiceHost();
}
public class NewRelic.Agent.Core.Utilization.PcfVendorModel : object {
    private string _cfInstanceGuid;
    private string _cfInstanceIp;
    private string _memoryLimit;
    public string VendorName { get; }
    [JsonPropertyAttribute("cf_instance_guid")]
public string CfInstanceGuid { get; }
    [JsonPropertyAttribute("cf_instance_ip")]
public string CfInstanceIp { get; }
    [JsonPropertyAttribute("memory_limit")]
public string MemoryLimit { get; }
    public PcfVendorModel(string cfInstanceGuid, string cfInstanceIp, string memoryLimit);
    public sealed virtual string get_VendorName();
    public string get_CfInstanceGuid();
    public string get_CfInstanceIp();
    public string get_MemoryLimit();
}
public class NewRelic.Agent.Core.Utilization.UtilitizationConfig : object {
    private string _billingHost;
    private Nullable`1<int> _logicalProcessors;
    private Nullable`1<int> _totalRamMib;
    [JsonPropertyAttribute("hostname")]
public string BillingHost { get; }
    [JsonPropertyAttribute("logical_processors")]
public Nullable`1<int> LogicalProcessors { get; }
    [JsonPropertyAttribute("total_ram_mib")]
public Nullable`1<int> TotalRamMib { get; }
    public UtilitizationConfig(string billingHost, Nullable`1<int> logicalProcessors, Nullable`1<int> totalRamMib);
    public string get_BillingHost();
    public Nullable`1<int> get_LogicalProcessors();
    public Nullable`1<int> get_TotalRamMib();
}
[JsonObjectAttribute("1")]
public class NewRelic.Agent.Core.Utilization.UtilizationSettingsModel : object {
    [JsonPropertyAttribute("metadata_version")]
public int MetadataVersion;
    [JsonPropertyAttribute("logical_processors")]
public Nullable`1<int> LogicalProcessors;
    [JsonPropertyAttribute("total_ram_mib")]
public Nullable`1<ulong> TotalRamMebibytes;
    [JsonPropertyAttribute("hostname")]
public string Hostname;
    [JsonPropertyAttribute("full_hostname")]
public string FullHostName;
    [JsonPropertyAttribute("ip_address")]
public List`1<string> IpAddress;
    [JsonPropertyAttribute("boot_id")]
public string BootId;
    public IDictionary`2<string, IVendorModel> Vendors;
    [JsonPropertyAttribute("config")]
public UtilitizationConfig Config;
    [JsonPropertyAttribute("vendors")]
private IDictionary`2<string, IVendorModel> VendorsForSerialization { get; }
    public UtilizationSettingsModel(Nullable`1<int> logicalProcessors, Nullable`1<ulong> totalRamBytes, string hostname, string fullHostName, List`1<string> ipAddress, string bootId, IDictionary`2<string, IVendorModel> vendors, UtilitizationConfig utilitizationConfig);
    private IDictionary`2<string, IVendorModel> get_VendorsForSerialization();
}
public class NewRelic.Agent.Core.Utilization.UtilizationStore : object {
    private ISystemInfo _systemInfo;
    private IDnsStatic _dnsStatic;
    private IConfiguration _configuration;
    private IAgentHealthReporter _agentHealthReporter;
    private static int MaxBootIdLength;
    public UtilizationStore(ISystemInfo systemInfo, IDnsStatic dnsStatic, IConfiguration configuration, IAgentHealthReporter agentHealthReporter);
    public UtilizationSettingsModel GetUtilizationSettings();
    private string Truncate(string bootId, int maxLength);
    public IDictionary`2<string, IVendorModel> GetVendorSettings();
    private UtilitizationConfig GetUtilitizationConfig();
}
public class NewRelic.Agent.Core.Utilization.VendorHttpApiRequestor : object {
    private static int WebReqeustTimeout;
    public virtual string CallVendorApi(Uri uri, string method, string vendorName, IEnumerable`1<string> headers);
    private string CallWithWebRequest(Uri uri, string method, string vendorName, IEnumerable`1<string> headers);
}
public class NewRelic.Agent.Core.Utilization.VendorInfo : object {
    private static string ValidateMetadataRegex;
    private static string StandardDockerIdRegex;
    private static string ContainerIdV1Regex;
    private static string ContainerIdV2Regex;
    private static string AwsEcsMetadataV3EnvVar;
    private static string AwsEcsMetadataV4EnvVar;
    private static string AwsName;
    private static string AzureName;
    private static string AzureFunctionAppName;
    private static string GcpName;
    private static string PcfName;
    private static string DockerName;
    private static string KubernetesName;
    private static string EcsName;
    private string AwsTokenUri;
    private string AwsMetadataUri;
    private static string AwsTokenDurationHeader;
    private string AzureUri;
    private static string AzureHeader;
    private string GcpUri;
    private static string GcpHeader;
    private static string PcfInstanceGuid;
    private static string PcfInstanceIp;
    private static string PcfMemoryLimit;
    private IConfiguration _configuration;
    private IAgentHealthReporter _agentHealthReporter;
    private IEnvironment _environment;
    private VendorHttpApiRequestor _vendorHttpApiRequestor;
    private static string GetMethod;
    private static string PutMethod;
    public VendorInfo(IConfiguration configuration, IAgentHealthReporter agentHealthReporter, IEnvironment environment, VendorHttpApiRequestor vendorHttpApiRequestor);
    public IDictionary`2<string, IVendorModel> GetVendors();
    public IVendorModel GetAzureFunctionVendorInfo();
    private IVendorModel GetAwsVendorInfo();
    public IVendorModel ParseAwsVendorInfo(string json);
    private IVendorModel GetAzureVendorInfo();
    public IVendorModel ParseAzureVendorInfo(string json);
    private IVendorModel GetGcpVendorInfo();
    public IVendorModel ParseGcpVendorInfo(string json);
    public IVendorModel GetPcfVendorInfo();
    private string GetProcessEnvironmentVariable(string variableName);
    public IVendorModel GetDockerVendorInfo(IFileReaderWrapper fileReaderWrapper, bool isLinux);
    private IVendorModel TryGetDockerCGroupV1(string fileContent);
    private bool TryGetIdFromRegexMatch(MatchCollection matches, String& id);
    private IVendorModel TryGetDockerCGroupV2(string fileContent);
    public IVendorModel GetEcsVendorInfo();
    private IVendorModel TryGetEcsVendorModel(string metadataUri);
    public IVendorModel GetKubernetesInfo();
    public string NormalizeAndValidateMetadata(string metadataValue, string metadataField, string vendorName);
    private string NormalizeString(string data);
    public bool IsValidMetadata(string data);
    private static bool IsLinux();
}
public class NewRelic.Agent.Core.WindowsNativeMethods : object {
    private static string DllName;
    private static int ExternInstrumentationRefresh();
    private static int ExternReloadConfiguration();
    private static int ExternAddCustomInstrumentation(string fileName, string xml);
    private static int ExternApplyCustomInstrumentation();
    public sealed virtual int InstrumentationRefresh();
    public sealed virtual int ReloadConfiguration();
    public sealed virtual int AddCustomInstrumentation(string fileName, string xml);
    public sealed virtual int ApplyCustomInstrumentation();
    private static void ExternShutdownThreadProfiler();
    private static void ExternReleaseProfile();
    private static int ExternRequestProfile(IntPtr& snapshots, Int32& length);
    private static int ExternRequestFunctionNames(UIntPtr[] functionIds, int length, IntPtr& functionInfo);
    public sealed virtual void ReleaseProfile();
    public sealed virtual int RequestFunctionNames(UIntPtr[] functionIds, int length, IntPtr& functionInfo);
    public sealed virtual int RequestProfile(IntPtr& snapshots, Int32& length);
    public sealed virtual void ShutdownNativeThreadProfiler();
}
public class NewRelic.Agent.Core.WireModels.CustomEventWireModel : object {
    [CompilerGeneratedAttribute]
private IAttributeValueCollection <AttributeValues>k__BackingField;
    private float _priority;
    public IAttributeValueCollection AttributeValues { get; private set; }
    [JsonIgnoreAttribute]
public float Priority { get; public set; }
    public CustomEventWireModel(float priority, IAttributeValueCollection attribValues);
    [CompilerGeneratedAttribute]
public sealed virtual IAttributeValueCollection get_AttributeValues();
    [CompilerGeneratedAttribute]
private void set_AttributeValues(IAttributeValueCollection value);
    public sealed virtual float get_Priority();
    public void set_Priority(float value);
}
public class NewRelic.Agent.Core.WireModels.ErrorEventWireModel : EventWireModel {
    public ErrorEventWireModel(IAttributeValueCollection attribValues, bool isSynthetics, float priority);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.WireModels.ErrorTraceWireModel : object {
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorTraceAttributesWireModel <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [JsonArrayIndexAttribute]
[DateTimeSerializesAsUnixTimeMillisecondsAttribute]
public DateTime TimeStamp { get; }
    [JsonArrayIndexAttribute]
public string Path { get; }
    [JsonArrayIndexAttribute]
public string Message { get; }
    [JsonArrayIndexAttribute]
public string ExceptionClassName { get; }
    [JsonArrayIndexAttribute]
public ErrorTraceAttributesWireModel Attributes { get; }
    [JsonArrayIndexAttribute]
public string Guid { get; }
    public ErrorTraceWireModel(DateTime timestamp, string path, string message, string exceptionClassName, ErrorTraceAttributesWireModel attributes, string guid);
    [CompilerGeneratedAttribute]
public virtual DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual string get_ExceptionClassName();
    [CompilerGeneratedAttribute]
public virtual ErrorTraceAttributesWireModel get_Attributes();
    [CompilerGeneratedAttribute]
public virtual string get_Guid();
}
public abstract class NewRelic.Agent.Core.WireModels.EventWireModel : object {
    [CompilerGeneratedAttribute]
private IAttributeValueCollection <AttributeValues>k__BackingField;
    private AttributeDestinations _targetObject;
    public bool IsSynthetics;
    private float _priority;
    public IAttributeValueCollection AttributeValues { get; private set; }
    public float Priority { get; public set; }
    protected EventWireModel(AttributeDestinations targetObject, IAttributeValueCollection attribValues, bool isSynthetics, float priority);
    [CompilerGeneratedAttribute]
public sealed virtual IAttributeValueCollection get_AttributeValues();
    [CompilerGeneratedAttribute]
private void set_AttributeValues(IAttributeValueCollection value);
    public sealed virtual float get_Priority();
    public void set_Priority(float value);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.WireModels.ExplainPlanWireModel : object {
    private ExplainPlan _explainPlan;
    [JsonArrayIndexAttribute]
public IEnumerable`1<string> ExplainPlanHeaders { get; }
    [JsonArrayIndexAttribute]
public List`1<List`1<object>> ExplainPlanDatas { get; }
    public ExplainPlanWireModel(ExplainPlan explainPlan);
    public IEnumerable`1<string> get_ExplainPlanHeaders();
    public List`1<List`1<object>> get_ExplainPlanDatas();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.EventWireModelSerializer")]
public interface NewRelic.Agent.Core.WireModels.IEventWireModel {
    public IAttributeValueCollection AttributeValues { get; }
    public abstract virtual IAttributeValueCollection get_AttributeValues();
}
public interface NewRelic.Agent.Core.WireModels.IMetricBuilder {
    public MetricWireModel TryBuildAcceptPayloadException { get; }
    public MetricWireModel TryBuildAcceptPayloadParseException { get; }
    public MetricWireModel TryBuildAcceptPayloadIgnoredCreateBeforeAccept { get; }
    public MetricWireModel TryBuildAcceptPayloadIgnoredMultiple { get; }
    public MetricWireModel TryBuildAcceptPayloadIgnoredMajorVersion { get; }
    public MetricWireModel TryBuildAcceptPayloadIgnoredNull { get; }
    public MetricWireModel TryBuildCreatePayloadException { get; }
    public MetricWireModel TryBuildTraceContextAcceptException { get; }
    public MetricWireModel TryBuildTraceContextTraceParentParseException { get; }
    public MetricWireModel TryBuildTraceContextTraceStateParseException { get; }
    public MetricWireModel TryBuildTraceContextCreateException { get; }
    public MetricWireModel TryBuildTraceContextTraceStateInvalidNrEntry { get; }
    public MetricWireModel TryBuildTraceContextTraceStateNoNrEntry { get; }
    public abstract virtual MetricWireModel TryBuildMemoryPhysicalMetric(long memoryPhysical);
    public abstract virtual MetricWireModel TryBuildMemoryWorkingSetMetric(long memoryWorkingSet);
    public abstract virtual MetricWireModel TryBuildCpuUserTimeMetric(TimeSpan cpuTime);
    public abstract virtual MetricWireModel TryBuildCpuUserUtilizationMetric(float cpuUtilization);
    public abstract virtual MetricWireModel TryBuildCpuTimeRollupMetric(bool isWebTransaction, TimeSpan cpuTime);
    public abstract virtual MetricWireModel TryBuildCpuTimeMetric(TransactionMetricName transactionMetricName, TimeSpan cpuTime);
    public abstract virtual MetricWireModel TryBuildGCBytesMetric(GCSampleType sampleType, long value);
    public abstract virtual MetricWireModel TryBuildGCCountMetric(GCSampleType sampleType, int value);
    public abstract virtual MetricWireModel TryBuildGCPercentMetric(GCSampleType sampleType, float value);
    public abstract virtual MetricWireModel TryBuildGCGaugeMetric(GCSampleType sampleType, float value);
    public abstract virtual MetricWireModel TryBuildCATSupportabilityCountMetric(CATSupportabilityCondition conditionType, int count);
    public abstract virtual MetricWireModel TryBuildDotnetFrameworkVersionMetric(DotnetFrameworkVersion version);
    public abstract virtual MetricWireModel TryBuildDotnetCoreVersionMetric(DotnetCoreVersion version);
    public abstract virtual MetricWireModel TryBuildAgentVersionMetric(string agentVersion);
    public abstract virtual MetricWireModel TryBuildAgentVersionByHostMetric(string hostName, string agentVersion);
    public abstract virtual MetricWireModel TryBuildThreadpoolUsageStatsMetric(ThreadType type, ThreadStatus status, int countThreadpoolThreads);
    public abstract virtual MetricWireModel TryBuildThreadpoolThroughputStatsMetric(ThreadpoolThroughputStatsType type, int statsVal);
    public abstract virtual MetricWireModel TryBuildLibraryVersionMetric(string assemblyName, string assemblyVersion);
    public abstract virtual MetricWireModel TryBuildMetricHarvestAttemptMetric();
    public abstract virtual MetricWireModel TryBuildTransactionEventReservoirResizedMetric();
    public abstract virtual MetricWireModel TryBuildTransactionEventsRecollectedMetric(int eventsRecollected);
    public abstract virtual MetricWireModel TryBuildTransactionEventsSentMetric(int eventCount);
    public abstract virtual MetricWireModel TryBuildTransactionEventsSeenMetric();
    public abstract virtual MetricWireModel TryBuildTransactionEventsCollectedMetric();
    public abstract virtual MetricWireModel TryBuildCustomEventReservoirResizedMetric();
    public abstract virtual MetricWireModel TryBuildCustomEventsRecollectedMetric(int eventsRecollected);
    public abstract virtual MetricWireModel TryBuildCustomEventsSentMetric(int eventCount);
    public abstract virtual MetricWireModel TryBuildCustomEventsSeenMetric();
    public abstract virtual MetricWireModel TryBuildCustomEventsCollectedMetric();
    public abstract virtual MetricWireModel TryBuildErrorTracesCollectedMetric();
    public abstract virtual MetricWireModel TryBuildErrorTracesRecollectedMetric(int errorTracesRecollected);
    public abstract virtual MetricWireModel TryBuildErrorTracesSentMetric(int errorTraceCount);
    public abstract virtual MetricWireModel TryBuildErrorEventsSentMetric(int eventCount);
    public abstract virtual MetricWireModel TryBuildErrorEventsSeenMetric();
    public abstract virtual MetricWireModel TryBuildSqlTracesRecollectedMetric(int sqlTracesRecollected);
    public abstract virtual MetricWireModel TryBuildSqlTracesSentMetric(int sqlTraceCount);
    public abstract virtual MetricWireModel TryBuildAgentHealthEventMetric(AgentHealthEvent agentHealthEvent, string additionalData);
    public abstract virtual MetricWireModel TryBuildAgentHealthEventMetric(AgentHealthEvent agentHealthEvent, string wrapperName, string typeName, string methodName);
    public abstract virtual MetricWireModel TryBuildFeatureEnabledMetric(string featureName);
    public abstract virtual MetricWireModel TryBuildAgentApiMetric(string methodName, int count);
    public abstract virtual MetricWireModel TryBuildCustomTimingMetric(string suffix, TimeSpan time);
    public abstract virtual MetricWireModel TryBuildCustomCountMetric(string suffix, int count);
    public abstract virtual MetricWireModel TryBuildLinuxOsMetric(bool isLinux);
    public abstract virtual MetricWireModel TryBuildBootIdError();
    public abstract virtual MetricWireModel TryBuildKubernetesUsabilityError();
    public abstract virtual MetricWireModel TryBuildAwsUsabilityError();
    public abstract virtual MetricWireModel TryBuildAzureUsabilityError();
    public abstract virtual MetricWireModel TryBuildPcfUsabilityError();
    public abstract virtual MetricWireModel TryBuildGcpUsabilityError();
    public abstract virtual MetricWireModel TryBuildAgentTimingMetric(string suffix, TimeSpan time);
    public abstract virtual MetricWireModel TryBuildAcceptPayloadSuccess(int count);
    public abstract virtual MetricWireModel get_TryBuildAcceptPayloadException();
    public abstract virtual MetricWireModel get_TryBuildAcceptPayloadParseException();
    public abstract virtual MetricWireModel get_TryBuildAcceptPayloadIgnoredCreateBeforeAccept();
    public abstract virtual MetricWireModel get_TryBuildAcceptPayloadIgnoredMultiple();
    public abstract virtual MetricWireModel get_TryBuildAcceptPayloadIgnoredMajorVersion();
    public abstract virtual MetricWireModel get_TryBuildAcceptPayloadIgnoredNull();
    public abstract virtual MetricWireModel TryBuildAcceptPayloadIgnoredUntrustedAccount();
    public abstract virtual MetricWireModel TryBuildCreatePayloadSuccess(int count);
    public abstract virtual MetricWireModel get_TryBuildCreatePayloadException();
    public abstract virtual MetricWireModel TryBuildTraceContextAcceptSuccess(int count);
    public abstract virtual MetricWireModel TryBuildTraceContextCreateSuccess(int count);
    public abstract virtual MetricWireModel get_TryBuildTraceContextAcceptException();
    public abstract virtual MetricWireModel get_TryBuildTraceContextTraceParentParseException();
    public abstract virtual MetricWireModel get_TryBuildTraceContextTraceStateParseException();
    public abstract virtual MetricWireModel get_TryBuildTraceContextCreateException();
    public abstract virtual MetricWireModel get_TryBuildTraceContextTraceStateInvalidNrEntry();
    public abstract virtual MetricWireModel get_TryBuildTraceContextTraceStateNoNrEntry();
    public abstract virtual MetricWireModel TryBuildSupportabilityErrorHttpStatusCodeFromCollector(HttpStatusCode statusCode);
    public abstract virtual MetricWireModel TryBuildSupportabilityEndpointMethodErrorAttempts(string endpointMethod);
    public abstract virtual MetricWireModel TryBuildSupportabilityEndpointMethodErrorDuration(string endpointMethod, TimeSpan duration);
    public abstract virtual MetricWireModel TryBuildSpanEventsSeenMetric(int count);
    public abstract virtual MetricWireModel TryBuildSpanEventsSentMetric(int count);
    public abstract virtual MetricWireModel TryBuildSupportabilityPayloadsDroppedDueToMaxPayloadLimit(string endpoint, int count);
    public abstract virtual MetricWireModel TryBuildInstallTypeMetric(string installType);
    public abstract virtual MetricWireModel TryBuildSupportabilityCountMetric(string metricName, long count);
    public abstract virtual MetricWireModel TryBuildSupportabilityDataUsageMetric(string metricName, long callCount, float dataSent, float dataReceived);
    public abstract virtual MetricWireModel TryBuildSupportabilitySummaryMetric(string metricName, float totalValue, int countSamples, float minValue, float maxValue);
    public abstract virtual MetricWireModel TryBuildSupportabilityGaugeMetric(string metricName, float value);
    public abstract virtual MetricWireModel TryBuildLoggingMetricsLinesCountBySeverityMetric(string logLevel, int count);
    public abstract virtual MetricWireModel TryBuildLoggingMetricsLinesCountMetric(int count);
    public abstract virtual MetricWireModel TryBuildLoggingMetricsDeniedCountBySeverityMetric(string logLevel, int count);
    public abstract virtual MetricWireModel TryBuildLoggingMetricsDeniedCountMetric(int count);
    public abstract virtual MetricWireModel TryBuildSupportabilityLoggingEventsCollectedMetric();
    public abstract virtual MetricWireModel TryBuildSupportabilityLoggingEventsSentMetric(int loggingEventCount);
    public abstract virtual MetricWireModel TryBuildSupportabilityLoggingEventsDroppedMetric(int droppedCount);
    public abstract virtual MetricWireModel TryBuildCountMetric(string metricName, long count);
    public abstract virtual MetricWireModel TryBuildByteMetric(string metricName, long totalBytes, Nullable`1<long> exclusiveBytes);
}
public interface NewRelic.Agent.Core.WireModels.IWireModel {
}
public class NewRelic.Agent.Core.WireModels.LoadedModuleWireModel : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Data>k__BackingField;
    public string AssemblyName { get; }
    public string Version { get; }
    public Dictionary`2<string, object> Data { get; }
    public LoadedModuleWireModel(string assemblyName, string version);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Data();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.LoadedModuleWireModelCollectionJsonConverter")]
public class NewRelic.Agent.Core.WireModels.LoadedModuleWireModelCollection : object {
    private static Version zeroedVersion;
    [CompilerGeneratedAttribute]
private List`1<LoadedModuleWireModel> <LoadedModules>k__BackingField;
    public List`1<LoadedModuleWireModel> LoadedModules { get; }
    private static LoadedModuleWireModelCollection();
    [CompilerGeneratedAttribute]
public List`1<LoadedModuleWireModel> get_LoadedModules();
    public static LoadedModuleWireModelCollection Build(IList`1<Assembly> assemblies);
    private static bool TryGetAssemblyName(Assembly assembly, String& assemblyName);
    private static bool TryGetPublicKeyToken(AssemblyName assemblyDetails, String& publicKey);
    private static bool TryGetShaFileHashes(Assembly assembly, String& sha1FileHash, String& sha512FileHash);
    private static bool TryGetAssemblyHashCode(Assembly assembly, String& assemblyHashCode);
    private static bool TryGetCompanyName(Assembly assembly, String& companyName);
    private static bool TryGetCopyright(Assembly assembly, String& copyright);
}
public class NewRelic.Agent.Core.WireModels.LogEventWireModel : object {
    private static UInt32 MaxMessageLengthInBytes;
    [CompilerGeneratedAttribute]
private long <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpanId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorStack>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorClass>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <ContextData>k__BackingField;
    private float _priority;
    public long TimeStamp { get; }
    public string Message { get; }
    public string Level { get; }
    public string SpanId { get; }
    public string TraceId { get; }
    public string ErrorStack { get; }
    public string ErrorMessage { get; }
    public string ErrorClass { get; }
    public Dictionary`2<string, object> ContextData { get; }
    public float Priority { get; public set; }
    public LogEventWireModel(long unixTimestampMS, string message, string level, string spanId, string traceId, Dictionary`2<string, object> contextData);
    public LogEventWireModel(long unixTimestampMS, string message, string level, string spanId, string traceId, Dictionary`2<string, object> contextData, float priority);
    public LogEventWireModel(long unixTimestampMS, string message, string level, ICollection`1<string> errorStack, string errorMessage, string errorClass, string spanId, string traceId, Dictionary`2<string, object> contextData);
    public LogEventWireModel(long unixTimestampMS, string message, string level, ICollection`1<string> errorStack, string errorMessage, string errorClass, string spanId, string traceId, Dictionary`2<string, object> contextData, float priority);
    [CompilerGeneratedAttribute]
public long get_TimeStamp();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Level();
    [CompilerGeneratedAttribute]
public string get_SpanId();
    [CompilerGeneratedAttribute]
public string get_TraceId();
    [CompilerGeneratedAttribute]
public string get_ErrorStack();
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public string get_ErrorClass();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_ContextData();
    public sealed virtual float get_Priority();
    public void set_Priority(float value);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.LogEventWireModelCollectionJsonConverter")]
public class NewRelic.Agent.Core.WireModels.LogEventWireModelCollection : object {
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hostname>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LogEventWireModel> <LoggingEvents>k__BackingField;
    public string EntityName { get; }
    public string EntityGuid { get; }
    public string Hostname { get; }
    public IList`1<LogEventWireModel> LoggingEvents { get; }
    public LogEventWireModelCollection(string entityName, string entityGuid, string hostname, IList`1<LogEventWireModel> loggingEvents);
    [CompilerGeneratedAttribute]
public string get_EntityName();
    [CompilerGeneratedAttribute]
public string get_EntityGuid();
    [CompilerGeneratedAttribute]
public string get_Hostname();
    [CompilerGeneratedAttribute]
public IList`1<LogEventWireModel> get_LoggingEvents();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.MetricDataWireModelJsonConverter")]
public class NewRelic.Agent.Core.WireModels.MetricDataWireModel : object {
    private static string CannotBeNegative;
    public long Value0;
    public float Value1;
    public float Value2;
    public float Value3;
    public float Value4;
    public float Value5;
    private MetricDataWireModel(long value0, float value1, float value2, float value3, float value4, float value5);
    public static MetricDataWireModel BuildAggregateData(IEnumerable`1<MetricDataWireModel> metrics);
    public static MetricDataWireModel BuildAggregateData(MetricDataWireModel metric0, MetricDataWireModel metric1);
    public static MetricDataWireModel BuildTimingData(TimeSpan totalTime, TimeSpan totalExclusiveTime);
    public static MetricDataWireModel BuildCountData(long callCount);
    public static MetricDataWireModel BuildDataUsageValue(long callCount, float dataSent, float dataReceived);
    public static MetricDataWireModel BuildGaugeValue(float gaugeValue);
    public static MetricDataWireModel BuildSummaryValue(int count, float value, float min, float max);
    public static MetricDataWireModel BuildByteData(long totalBytes, Nullable`1<long> exclusiveBytes);
    public static MetricDataWireModel BuildPercentageData(float percentage);
    public static MetricDataWireModel BuildCpuTimeData(TimeSpan cpuTime);
    public static MetricDataWireModel BuildApdexData(TimeSpan responseTime, TimeSpan apdexT);
    public static MetricDataWireModel BuildFrustratedApdexData();
    public static MetricDataWireModel BuildIfLinuxData(bool isLinux);
    public static MetricDataWireModel BuildBootIdError();
    internal static MetricDataWireModel BuildKubernetesUsabilityError();
    public static MetricDataWireModel BuildAwsUsabilityError();
    public static MetricDataWireModel BuildAzureUsabilityError();
    public static MetricDataWireModel BuildPcfUsabilityError();
    public static MetricDataWireModel BuildGcpUsabilityError();
    public static MetricDataWireModel BuildAverageData(float value);
    private static ApdexPerfZone GetApdexPerfZone(TimeSpan responseTime, TimeSpan apdexT);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.MetricNameWireModelJsonConverter")]
public class NewRelic.Agent.Core.WireModels.MetricNameWireModel : object {
    private static string PropertyName;
    private static string PropertyScope;
    public string Name;
    public string Scope;
    private int _hashCode;
    public MetricNameWireModel(string name, string scope);
    private static int HashCodeCombiner(int h1, int h2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.MetricWireModelJsonConverter")]
public class NewRelic.Agent.Core.WireModels.MetricWireModel : object {
    public MetricNameWireModel MetricNameModel;
    public MetricDataWireModel DataModel;
    private MetricWireModel(MetricNameWireModel metricNameModel, MetricDataWireModel dataModel);
    public static MetricWireModel Merge(MetricWireModel first, MetricWireModel second);
    public static MetricWireModel Merge(IEnumerable`1<MetricWireModel> metrics);
    public static MetricWireModel BuildMetric(IMetricNameService metricNameService, string proposedName, string scope, MetricDataWireModel metricData);
    public virtual string ToString();
    public sealed virtual void AddMetricsToCollection(MetricStatsCollection collection);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.MetricWireModelCollectionJsonConverter")]
public class NewRelic.Agent.Core.WireModels.MetricWireModelCollection : object {
    [CompilerGeneratedAttribute]
private string <AgentRunID>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StartEpochTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EndEpochTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MetricWireModel> <Metrics>k__BackingField;
    public string AgentRunID { get; private set; }
    public double StartEpochTime { get; private set; }
    public double EndEpochTime { get; private set; }
    public IEnumerable`1<MetricWireModel> Metrics { get; private set; }
    public MetricWireModelCollection(string agentRunId, double beginEpoch, double endEpoch, IEnumerable`1<MetricWireModel> metrics);
    [CompilerGeneratedAttribute]
public string get_AgentRunID();
    [CompilerGeneratedAttribute]
private void set_AgentRunID(string value);
    [CompilerGeneratedAttribute]
public double get_StartEpochTime();
    [CompilerGeneratedAttribute]
private void set_StartEpochTime(double value);
    [CompilerGeneratedAttribute]
public double get_EndEpochTime();
    [CompilerGeneratedAttribute]
private void set_EndEpochTime(double value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<MetricWireModel> get_Metrics();
    [CompilerGeneratedAttribute]
private void set_Metrics(IEnumerable`1<MetricWireModel> value);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.WireModels.SqlTraceWireModel : object {
    [CompilerGeneratedAttribute]
private string <TransactionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SqlId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sql>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatastoreMetricName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CallCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TotalCallTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinCallTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCallTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ParameterData>k__BackingField;
    [JsonArrayIndexAttribute]
public string TransactionName { get; }
    [JsonArrayIndexAttribute]
public string Uri { get; }
    [JsonArrayIndexAttribute]
public long SqlId { get; }
    [JsonArrayIndexAttribute]
public string Sql { get; }
    [JsonArrayIndexAttribute]
public string DatastoreMetricName { get; }
    [JsonArrayIndexAttribute]
public UInt32 CallCount { get; }
    [JsonArrayIndexAttribute]
[TimeSpanSerializesAsMillisecondsAttribute]
public TimeSpan TotalCallTime { get; }
    [JsonArrayIndexAttribute]
[TimeSpanSerializesAsMillisecondsAttribute]
public TimeSpan MinCallTime { get; }
    [JsonArrayIndexAttribute]
[TimeSpanSerializesAsMillisecondsAttribute]
public TimeSpan MaxCallTime { get; }
    [JsonArrayIndexAttribute]
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.EventAttributesJsonConverter")]
public IDictionary`2<string, object> ParameterData { get; }
    public SqlTraceWireModel(string transactionName, string uri, long sqlId, string sql, string datastoreMetricName, UInt32 callCount, TimeSpan totalCallTime, TimeSpan minCallTime, TimeSpan maxCallTime, IDictionary`2<string, object> parameterData);
    [CompilerGeneratedAttribute]
public virtual string get_TransactionName();
    [CompilerGeneratedAttribute]
public virtual string get_Uri();
    [CompilerGeneratedAttribute]
public virtual long get_SqlId();
    [CompilerGeneratedAttribute]
public virtual string get_Sql();
    [CompilerGeneratedAttribute]
public virtual string get_DatastoreMetricName();
    [CompilerGeneratedAttribute]
public virtual UInt32 get_CallCount();
    [CompilerGeneratedAttribute]
public virtual TimeSpan get_TotalCallTime();
    [CompilerGeneratedAttribute]
public virtual TimeSpan get_MinCallTime();
    [CompilerGeneratedAttribute]
public virtual TimeSpan get_MaxCallTime();
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_ParameterData();
}
public class NewRelic.Agent.Core.WireModels.TransactionEventWireModel : EventWireModel {
    public TransactionEventWireModel(IAttributeValueCollection attribValues, bool isSynthetics, float priority);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
[JsonObjectAttribute("1")]
public class NewRelic.Agent.Core.WireModels.TransactionTraceData : object {
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private object <UnusedArray1>k__BackingField;
    [CompilerGeneratedAttribute]
private object <UnusedArray2>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionTraceSegment <RootSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionTraceAttributes <Attributes>k__BackingField;
    [JsonArrayIndexAttribute]
[DateTimeSerializesAsUnixTimeMillisecondsAttribute]
public DateTime StartTime { get; }
    [JsonArrayIndexAttribute]
public object UnusedArray1 { get; }
    [JsonArrayIndexAttribute]
public object UnusedArray2 { get; }
    [JsonArrayIndexAttribute]
public TransactionTraceSegment RootSegment { get; }
    [JsonArrayIndexAttribute]
public TransactionTraceAttributes Attributes { get; }
    public TransactionTraceData(DateTime startTime, TransactionTraceSegment rootSegment, IAttributeValueCollection attribValues);
    [CompilerGeneratedAttribute]
public virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public virtual object get_UnusedArray1();
    [CompilerGeneratedAttribute]
public virtual object get_UnusedArray2();
    [CompilerGeneratedAttribute]
public virtual TransactionTraceSegment get_RootSegment();
    [CompilerGeneratedAttribute]
public virtual TransactionTraceAttributes get_Attributes();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.WireModels.TransactionTraceSegment : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TimeBetweenTransactionStartAndSegmentStart>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeBetweenTransactionStartAndSegmentEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyDictionary`2<string, object> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TransactionTraceSegment> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [JsonArrayIndexAttribute]
[TimeSpanSerializesAsMillisecondsAttribute]
public TimeSpan TimeBetweenTransactionStartAndSegmentStart { get; }
    [JsonArrayIndexAttribute]
[TimeSpanSerializesAsMillisecondsAttribute]
public TimeSpan TimeBetweenTransactionStartAndSegmentEnd { get; }
    [JsonArrayIndexAttribute]
public string Name { get; }
    [JsonArrayIndexAttribute]
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.EventAttributesJsonConverter")]
public ReadOnlyDictionary`2<string, object> Parameters { get; }
    [JsonArrayIndexAttribute]
public IList`1<TransactionTraceSegment> Children { get; }
    [JsonArrayIndexAttribute]
public string ClassName { get; }
    [JsonArrayIndexAttribute]
public string MethodName { get; }
    public TransactionTraceSegment(TimeSpan timeBetweenTransactionStartAndSegmentStart, TimeSpan timeBetweenTransactionStartAndSegmentEnd, string name, IDictionary`2<string, object> parameters, IEnumerable`1<TransactionTraceSegment> children, string className, string methodName);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeBetweenTransactionStartAndSegmentStart();
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeBetweenTransactionStartAndSegmentEnd();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ReadOnlyDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public IList`1<TransactionTraceSegment> get_Children();
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public string get_MethodName();
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.JsonArrayConverter")]
public class NewRelic.Agent.Core.WireModels.TransactionTraceWireModel : object {
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionMetricName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionTraceData <TransactionTraceData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Unused1>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unused2>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <XraySessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SyntheticsResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSynthetics>k__BackingField;
    [JsonArrayIndexAttribute]
[DateTimeSerializesAsUnixTimeMillisecondsAttribute]
public DateTime StartTime { get; }
    [JsonArrayIndexAttribute]
[TimeSpanSerializesAsMillisecondsAttribute]
public TimeSpan Duration { get; }
    [JsonArrayIndexAttribute]
public string TransactionMetricName { get; }
    [JsonArrayIndexAttribute]
public string Uri { get; }
    [JsonArrayIndexAttribute]
public TransactionTraceData TransactionTraceData { get; }
    [JsonArrayIndexAttribute]
public string Guid { get; }
    [JsonArrayIndexAttribute]
public object Unused1 { get; }
    [JsonArrayIndexAttribute]
public bool Unused2 { get; }
    [JsonArrayIndexAttribute]
public Nullable`1<ulong> XraySessionId { get; }
    [JsonArrayIndexAttribute]
public string SyntheticsResourceId { get; }
    [JsonIgnoreAttribute]
public bool IsSynthetics { get; }
    public TransactionTraceWireModel(DateTime startTime, TimeSpan duration, string transactionMetricName, string uri, TransactionTraceData transactionTraceData, string guid, Nullable`1<ulong> xraySessionId, string syntheticsResourceId, bool isSynthetics);
    [CompilerGeneratedAttribute]
public virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public virtual TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public virtual string get_TransactionMetricName();
    [CompilerGeneratedAttribute]
public virtual string get_Uri();
    [CompilerGeneratedAttribute]
public virtual TransactionTraceData get_TransactionTraceData();
    [CompilerGeneratedAttribute]
public virtual string get_Guid();
    [CompilerGeneratedAttribute]
public virtual object get_Unused1();
    [CompilerGeneratedAttribute]
public virtual bool get_Unused2();
    [CompilerGeneratedAttribute]
public virtual Nullable`1<ulong> get_XraySessionId();
    [CompilerGeneratedAttribute]
public virtual string get_SyntheticsResourceId();
    [CompilerGeneratedAttribute]
public bool get_IsSynthetics();
}
public class NewRelic.Agent.Core.Wrapper.AgentWrapperApi.Builders.CandidateTransactionName : object {
    private ITransactionName modreq(System.Runtime.CompilerServices.IsVolatile) _currentTransactionName;
    private ITransaction _transaction;
    private TransactionNamePriority _highestPriority;
    private bool _isFrozen;
    public ITransactionName CurrentTransactionName { get; }
    public CandidateTransactionName(ITransaction transaction, ITransactionName initialTransactionName);
    public sealed virtual bool TrySet(ITransactionName transactionName, TransactionNamePriority priority);
    private bool ChangeName(TransactionNamePriority newPriority);
    public sealed virtual void Freeze(TransactionNameFreezeReason reason);
    public sealed virtual ITransactionName get_CurrentTransactionName();
    private static string FormatTransactionName(ITransactionName transactionName, TransactionNamePriority priority);
}
public class NewRelic.Agent.Core.Wrapper.AgentWrapperApi.Builders.DatabaseStatementParser : ConfigurationBasedService {
    private CacheByDatastoreVendor`2<string, ParsedSqlStatement> _cache;
    public sealed virtual ParsedSqlStatement ParseDatabaseStatement(DatastoreVendor datastoreVendor, CommandType commandType, string sql);
    protected virtual void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource);
}
public interface NewRelic.Agent.Core.Wrapper.AgentWrapperApi.Builders.ICandidateTransactionName {
    public ITransactionName CurrentTransactionName { get; }
    public abstract virtual bool TrySet(ITransactionName transactionName, TransactionNamePriority priority);
    public abstract virtual void Freeze(TransactionNameFreezeReason reason);
    public abstract virtual ITransactionName get_CurrentTransactionName();
}
public interface NewRelic.Agent.Core.Wrapper.AgentWrapperApi.Builders.IDatabaseStatementParser {
    public abstract virtual ParsedSqlStatement ParseDatabaseStatement(DatastoreVendor datastoreVendor, CommandType commandType, string sql);
}
public enum NewRelic.Agent.Core.Wrapper.AgentWrapperApi.Builders.TransactionNameFreezeReason : Enum {
    public int value__;
    public static TransactionNameFreezeReason AutoBrowserScriptInjection;
    public static TransactionNameFreezeReason ManualBrowserScriptInjection;
    public static TransactionNameFreezeReason CrossApplicationTracing;
}
public class NewRelic.Agent.Core.Wrapper.AgentWrapperApi.CrossApplicationTracing.CatHeaderHandler : object {
    private static string NewRelicIdHttpHeader;
    private static string TransactionDataHttpHeader;
    private static string AppDataHttpHeader;
    private IConfigurationService _configurationService;
    private ICATSupportabilityMetricCounters _supportabilityMetrics;
    public CatHeaderHandler(IConfigurationService configurationService, ICATSupportabilityMetricCounters supportabilityMetricCounters);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> TryGetOutboundRequestHeaders(IInternalTransaction transaction);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> TryGetOutboundResponseHeaders(IInternalTransaction transaction, TransactionMetricName transactionMetricName);
    public sealed virtual CrossApplicationResponseData TryDecodeInboundResponseHeaders(IDictionary`2<string, string> headers);
    public sealed virtual string TryDecodeInboundRequestHeadersForCrossProcessId(T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
    public sealed virtual CrossApplicationRequestData TryDecodeInboundRequestHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
    private string TryDecodeNewRelicIdHttpHeader(string encodedNewRelicIdHttpHeader);
    private string GetEncodedAppData(IInternalTransaction transaction, TransactionMetricName transactionMetricName, string crossProcessId);
    private string GetEncodedNewRelicId(string referrerCrossProcessId);
    private string GetEncodedTransactionData(IInternalTransaction transaction);
    private bool IsTrustedCrossProcessAccountId(string accountId, IEnumerable`1<long> trustedAccountIds);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.CrossApplicationRequestDataJsonConverter")]
public class NewRelic.Agent.Core.Wrapper.AgentWrapperApi.CrossApplicationTracing.CrossApplicationRequestData : object {
    public string TransactionGuid;
    public bool Unused;
    public string TripId;
    public string PathHash;
    public CrossApplicationRequestData(string transactionGuid, bool unused, string tripId, string pathHash);
}
[JsonConverterAttribute("NewRelic.Agent.Core.JsonConverters.CrossApplicationResponseDataJsonConverter")]
public class NewRelic.Agent.Core.Wrapper.AgentWrapperApi.CrossApplicationTracing.CrossApplicationResponseData : object {
    public string CrossProcessId;
    public string TransactionName;
    public float QueueTimeInSeconds;
    public float ResponseTimeInSeconds;
    public long ContentLength;
    public string TransactionGuid;
    public bool Unused;
    public CrossApplicationResponseData(string crossProcessId, string transactionName, float queueTimeInSeconds, float responseTimeInSeconds, long contentLength);
    public CrossApplicationResponseData(string crossProcessId, string transactionName, float queueTimeInSeconds, float responseTimeInSeconds, long contentLength, string transactionGuid);
    public CrossApplicationResponseData(string crossProcessId, string transactionName, float queueTimeInSeconds, float responseTimeInSeconds, long contentLength, string transactionGuid, bool unused);
}
public interface NewRelic.Agent.Core.Wrapper.AgentWrapperApi.CrossApplicationTracing.ICatHeaderHandler {
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> TryGetOutboundRequestHeaders(IInternalTransaction transaction);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> TryGetOutboundResponseHeaders(IInternalTransaction transaction, TransactionMetricName transactionMetricName);
    public abstract virtual CrossApplicationResponseData TryDecodeInboundResponseHeaders(IDictionary`2<string, string> headers);
    public abstract virtual string TryDecodeInboundRequestHeadersForCrossProcessId(T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
    public abstract virtual CrossApplicationRequestData TryDecodeInboundRequestHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
}
public interface NewRelic.Agent.Core.Wrapper.AgentWrapperApi.CrossApplicationTracing.IPathHashMaker {
    public abstract virtual string CalculatePathHash(string transactionName, string referringPathHash);
}
public class NewRelic.Agent.Core.Wrapper.AgentWrapperApi.CrossApplicationTracing.PathHashMaker : object {
    private static int TotalBits;
    private static string PathHashSeparator;
    public static int AlternatePathHashMaxSize;
    private IConfigurationService _configurationService;
    public PathHashMaker(IConfigurationService configurationService);
    public sealed virtual string CalculatePathHash(string transactionName, string referringPathHash);
    private static string ReversePathHash(string transactionName, string appName, string pathHash);
    private static int GetHash(string appName, string txName);
    private static int HexToIntOrZero(string val);
    private static int HexToInt(string val);
    private static string IntToHex(int val);
}
public class NewRelic.Agent.Core.Wrapper.AgentWrapperApi.Data.MethodCallData : object {
    public string TypeName;
    public string MethodName;
    public int InvocationTargetHashCode;
    public bool IsAsync;
    public MethodCallData(string typeName, string methodName, int invocationTargetHashCode, bool isAsync);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public interface NewRelic.Agent.Core.Wrapper.AgentWrapperApi.Synthetics.ISyntheticsHeaderHandler {
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> TryGetOutboundSyntheticsRequestHeader(IInternalTransaction transaction);
    public abstract virtual SyntheticsHeader TryDecodeInboundRequestHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
}
public class NewRelic.Agent.Core.Wrapper.AgentWrapperApi.Synthetics.SyntheticsHeaderHandler : object {
    private IConfigurationService _configurationService;
    public SyntheticsHeaderHandler(IConfigurationService configurationService);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> TryGetOutboundSyntheticsRequestHeader(IInternalTransaction transaction);
    public sealed virtual SyntheticsHeader TryDecodeInboundRequestHeaders(T carrier, Func`3<T, string, IEnumerable`1<string>> getter);
}
public class NewRelic.Agent.Core.Wrapper.AttachToAsyncWrapper : object {
    private static String[] PossibleWrapperNames;
    public bool IsTransactionRequired { get; }
    private static AttachToAsyncWrapper();
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo instrumentedMethodInfo);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
}
public class NewRelic.Agent.Core.Wrapper.CustomSegmentWrapper : object {
    private static String[] PossibleWrapperNames;
    public bool IsTransactionRequired { get; }
    private static CustomSegmentWrapper();
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo instrumentedMethodInfo);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
}
public class NewRelic.Agent.Core.Wrapper.DefaultWrapper : object {
    private static String[] PossibleWrapperNames;
    public bool IsTransactionRequired { get; }
    private static DefaultWrapper();
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo instrumentedMethodInfo);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
}
public class NewRelic.Agent.Core.Wrapper.DefaultWrapperAsync : object {
    private static String[] PossibleWrapperNames;
    public bool IsTransactionRequired { get; }
    private static DefaultWrapperAsync();
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo instrumentedMethodInfo);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
}
public class NewRelic.Agent.Core.Wrapper.DetachWrapper : object {
    public bool IsTransactionRequired { get; }
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo methodInfo);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
}
public interface NewRelic.Agent.Core.Wrapper.IDefaultWrapper {
}
public class NewRelic.Agent.Core.Wrapper.IgnoreTransactionWrapper : object {
    private static String[] PossibleWrapperNames;
    public bool IsTransactionRequired { get; }
    private static IgnoreTransactionWrapper();
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo instrumentedMethodInfo);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
}
public interface NewRelic.Agent.Core.Wrapper.INoOpWrapper {
}
public interface NewRelic.Agent.Core.Wrapper.IWrapperMap {
    public abstract virtual TrackedWrapper Get(InstrumentedMethodInfo instrumentedMethodInfo);
    public abstract virtual TrackedWrapper GetNoOpWrapper();
}
public interface NewRelic.Agent.Core.Wrapper.IWrapperService {
    public abstract virtual AfterWrappedMethodDelegate BeforeWrappedMethod(Type type, string methodName, string argumentSignature, object invocationTarget, Object[] methodArguments, string tracerFactoryName, string metricName, UInt32 tracerArguments, ulong functionId);
    public abstract virtual void ClearCaches();
}
public class NewRelic.Agent.Core.Wrapper.MultithreadedTrackingWrapper : object {
    public bool IsTransactionRequired { get; }
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo instrumentedMethodInfo);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
}
public class NewRelic.Agent.Core.Wrapper.NoOpWrapper : object {
    private static String[] PossibleWrapperNames;
    public bool IsTransactionRequired { get; }
    private static NoOpWrapper();
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo instrumentedMethodInfo);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
}
public class NewRelic.Agent.Core.Wrapper.OtherTransactionWrapper : object {
    private static string ForceNewTransactionOnAsyncWrapperName;
    private static String[] PossibleWrapperNames;
    public bool IsTransactionRequired { get; }
    private static OtherTransactionWrapper();
    public sealed virtual bool get_IsTransactionRequired();
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(InstrumentedMethodCall instrumentedMethodCall, IAgent agent, ITransaction transaction);
    public sealed virtual CanWrapResponse CanWrap(InstrumentedMethodInfo instrumentedMethodInfo);
}
public class NewRelic.Agent.Core.Wrapper.TrackedWrapper : object {
    public IWrapper Wrapper;
    private int _numberOfConsecutiveFailures;
    public int NumberOfConsecutiveFailures { get; }
    public TrackedWrapper(IWrapper wrapper);
    public int get_NumberOfConsecutiveFailures();
    public void NoticeSuccess();
    public void NoticeFailure();
}
public class NewRelic.Agent.Core.Wrapper.WrapperMap : object {
    private List`1<IDefaultWrapper> _defaultWrappers;
    private List`1<IWrapper> _nonDefaultWrappers;
    private TrackedWrapper _noOpTrackedWrapper;
    public WrapperMap(IEnumerable`1<IWrapper> wrappers, IDefaultWrapper defaultWrapper, INoOpWrapper noOpWrapper);
    public sealed virtual TrackedWrapper Get(InstrumentedMethodInfo instrumentedMethodInfo);
    public sealed virtual TrackedWrapper GetNoOpWrapper();
    private TrackedWrapper GetDefaultWrapperOrSetNoOp(InstrumentedMethodInfo instrumentedMethodInfo);
    private static bool CanWrap(InstrumentedMethodInfo instrumentedMethodInfo, IWrapper wrapper);
}
public class NewRelic.Agent.Core.Wrapper.WrapperService : object {
    private int _maxConsecutiveFailures;
    private IConfigurationService _configurationService;
    private IAgent _agent;
    private IWrapperMap _wrapperMap;
    private IAgentHealthReporter _agentHealthReporter;
    private IAgentTimerService _agentTimerService;
    private ConcurrentDictionary`2<ulong, InstrumentedMethodInfoWrapper> _functionIdToWrapper;
    public WrapperService(IConfigurationService configurationService, IWrapperMap wrapperMap, IAgent agent, IAgentHealthReporter agentHealthReporter, IAgentTimerService agentTimerService);
    public sealed virtual AfterWrappedMethodDelegate BeforeWrappedMethod(Type type, string methodName, string argumentSignature, object invocationTarget, Object[] methodArguments, string tracerFactoryName, string metricName, UInt32 tracerArguments, ulong functionId);
    public sealed virtual void ClearCaches();
    public static string ResolveTracerFactoryNameForAttributeInstrumentation(UInt32 tracerArguments, bool isAsync, string tracerFactoryName);
    private void HandleBeforeWrappedMethodException(ulong functionId, TrackedWrapper trackedWrapper, InstrumentedMethodCall instrumentedMethodCall, InstrumentedMethodInfo instrumetedMethodInfo);
    private void GenerateLibraryVersionSupportabilityMetric(InstrumentedMethodInfo instrumentedMethodInfo);
}
public class NewRelic.Agent.Core.Wrapper.WrapperTracer : object {
    private AfterWrappedMethodDelegate _afterWrappedMethodDelegate;
    public WrapperTracer(AfterWrappedMethodDelegate afterWrappedMethodDelegate);
    public sealed virtual void Finish(object returnValue, Exception exception);
}
internal class Newtonsoft.Json.Bson.BsonArray : BsonToken {
    private List`1<BsonToken> _children;
    public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Newtonsoft.Json.Bson.BsonBinary : BsonValue {
    [CompilerGeneratedAttribute]
private BsonBinaryType <BinaryType>k__BackingField;
    public BsonBinaryType BinaryType { get; public set; }
    public BsonBinary(Byte[] value, BsonBinaryType binaryType);
    [CompilerGeneratedAttribute]
public BsonBinaryType get_BinaryType();
    [CompilerGeneratedAttribute]
public void set_BinaryType(BsonBinaryType value);
}
internal enum Newtonsoft.Json.Bson.BsonBinaryType : Enum {
    public byte value__;
    public static BsonBinaryType Binary;
    public static BsonBinaryType Function;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Binary instead.")]
public static BsonBinaryType BinaryOld;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Uuid instead.")]
public static BsonBinaryType UuidOld;
    public static BsonBinaryType Uuid;
    public static BsonBinaryType Md5;
    public static BsonBinaryType UserDefined;
}
internal class Newtonsoft.Json.Bson.BsonBinaryWriter : object {
    private static Encoding Encoding;
    private BinaryWriter _writer;
    private Byte[] _largeByteBuffer;
    [CompilerGeneratedAttribute]
private DateTimeKind <DateTimeKindHandling>k__BackingField;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(BinaryWriter writer);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void Close();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    public void WriteUtf8Bytes(string s, int byteCount);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
internal class Newtonsoft.Json.Bson.BsonBoolean : BsonValue {
    public static BsonBoolean False;
    public static BsonBoolean True;
    private BsonBoolean(bool value);
    private static BsonBoolean();
}
internal class Newtonsoft.Json.Bson.BsonEmpty : BsonToken {
    public static BsonToken Null;
    public static BsonToken Undefined;
    [CompilerGeneratedAttribute]
private BsonType <Type>k__BackingField;
    public BsonType Type { get; }
    private BsonEmpty(BsonType type);
    private static BsonEmpty();
    [CompilerGeneratedAttribute]
public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonObject : BsonToken {
    private List`1<BsonProperty> _children;
    public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Newtonsoft.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
}
internal class Newtonsoft.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]
private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonToken <Value>k__BackingField;
    public BsonString Name { get; public set; }
    public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Newtonsoft.Json.Bson.BsonReader : JsonReader {
    private static int MaxCharBytesSize;
    private static Byte[] SeqRange1;
    private static Byte[] SeqRange2;
    private static Byte[] SeqRange3;
    private static Byte[] SeqRange4;
    private BinaryReader _reader;
    private List`1<ContainerContext> _stack;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;
    private bool _readRootValueAsArray;
    private bool _jsonNet35BinaryCompatibility;
    private DateTimeKind _dateTimeKindHandling;
    [ObsoleteAttribute("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
public bool JsonNet35BinaryCompatibility { get; public set; }
    public bool ReadRootValueAsArray { get; public set; }
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(BinaryReader reader);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_JsonNet35BinaryCompatibility();
    public void set_JsonNet35BinaryCompatibility(bool value);
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual bool Read();
    public virtual void Close();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary(BsonBinaryType& binaryType);
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
internal class Newtonsoft.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]
private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonString <Options>k__BackingField;
    public BsonString Pattern { get; public set; }
    public BsonString Options { get; public set; }
    public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLength>k__BackingField;
    public int ByteCount { get; public set; }
    public bool IncludeLength { get; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
}
internal abstract class Newtonsoft.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]
private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalculatedSize>k__BackingField;
    public BsonType Type { get; }
    public BsonToken Parent { get; public set; }
    public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
internal enum Newtonsoft.Json.Bson.BsonType : Enum {
    public sbyte value__;
    public static BsonType Number;
    public static BsonType String;
    public static BsonType Object;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType Undefined;
    public static BsonType Oid;
    public static BsonType Boolean;
    public static BsonType Date;
    public static BsonType Null;
    public static BsonType Regex;
    public static BsonType Reference;
    public static BsonType Code;
    public static BsonType Symbol;
    public static BsonType CodeWScope;
    public static BsonType Integer;
    public static BsonType TimeStamp;
    public static BsonType Long;
    public static BsonType MinKey;
    public static BsonType MaxKey;
}
internal class Newtonsoft.Json.Bson.BsonValue : BsonToken {
    private object _value;
    private BsonType _type;
    public object Value { get; }
    public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
    private BsonBinaryWriter _writer;
    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public BsonWriter(BinaryWriter writer);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    public virtual void Close();
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
public enum Newtonsoft.Json.ConstructorHandling : Enum {
    public int value__;
    public static ConstructorHandling Default;
    public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
    private static string BinaryTypeName;
    private static string BinaryToArrayName;
    [NullableAttribute("2")]
private static ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    private static void EnsureReflectionObject(Type t);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private Byte[] ReadByteArray(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.DataSetConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.DataTableConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void CreateRow(JsonReader reader, DataTable dt, JsonSerializer serializer);
    private static Type GetColumnDataType(JsonReader reader);
    public virtual bool CanConvert(Type valueType);
}
internal abstract class Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.DiscriminatedUnionConverter : JsonConverter {
    private static string CasePropertyName;
    private static string FieldsPropertyName;
    private static ThreadSafeStore`2<Type, Union> UnionCache;
    private static ThreadSafeStore`2<Type, Type> UnionTypeLookupCache;
    private static DiscriminatedUnionConverter();
    private static Type CreateUnionTypeLookup(Type t);
    private static Union CreateUnion(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.EntityKeyMemberConverter : JsonConverter {
    private static string EntityKeyMemberFullTypeName;
    private static string KeyPropertyName;
    private static string TypePropertyName;
    private static string ValuePropertyName;
    [NullableAttribute("2")]
private static ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static void ReadAndAssertProperty(JsonReader reader, string propertyName);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void EnsureReflectionObject(Type objectType);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.ExpandoObjectConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadValue(JsonReader reader);
    private object ReadList(JsonReader reader);
    private object ReadObject(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    private static string DefaultDateTimeFormat;
    private DateTimeStyles _dateTimeStyles;
    [NullableAttribute("2")]
private string _dateTimeFormat;
    [NullableAttribute("2")]
private CultureInfo _culture;
    public DateTimeStyles DateTimeStyles { get; public set; }
    [NullableAttribute("2")]
public string DateTimeFormat { get; public set; }
    public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    [NullableContextAttribute("2")]
public string get_DateTimeFormat();
    [NullableContextAttribute("2")]
public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlDeclaration {
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Converters.IXmlDocument {
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public abstract virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public abstract virtual IXmlElement get_DocumentElement();
}
[NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlDocumentType {
    [NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    [NullableContextAttribute("1")]
public abstract virtual string get_Name();
    public abstract virtual string get_System();
    public abstract virtual string get_Public();
    public abstract virtual string get_InternalSubset();
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Converters.IXmlElement {
    public bool IsEmpty { get; }
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
    public abstract virtual string GetPrefixOfNamespace(string namespaceUri);
    public abstract virtual bool get_IsEmpty();
}
[NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlNode {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    [NullableContextAttribute("1")]
public abstract virtual List`1<IXmlNode> get_ChildNodes();
    [NullableContextAttribute("1")]
public abstract virtual List`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    [NullableContextAttribute("1")]
public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceUri();
    public abstract virtual object get_WrappedNode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
    private static string KeyName;
    private static string ValueName;
    private static ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType;
    private static KeyValuePairConverter();
    private static ReflectionObject InitializeReflectionObject(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
    private static string PatternName;
    private static string OptionsName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadRegexString(JsonReader reader);
    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private bool IsRegex(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIntegerValues>k__BackingField;
    [ObsoleteAttribute("StringEnumConverter.CamelCaseText is obsolete. Set StringEnumConverter.NamingStrategy with CamelCaseNamingStrategy instead.")]
public bool CamelCaseText { get; public set; }
    [NullableAttribute("2")]
public NamingStrategy NamingStrategy { get; public set; }
    public bool AllowIntegerValues { get; public set; }
    [ObsoleteAttribute("StringEnumConverter(bool) is obsolete. Create a converter with StringEnumConverter(NamingStrategy, bool) instead.")]
public StringEnumConverter(bool camelCaseText);
    public StringEnumConverter(NamingStrategy namingStrategy, bool allowIntegerValues);
    public StringEnumConverter(Type namingStrategyType);
    public StringEnumConverter(Type namingStrategyType, Object[] namingStrategyParameters);
    public StringEnumConverter(Type namingStrategyType, Object[] namingStrategyParameters, bool allowIntegerValues);
    public bool get_CamelCaseText();
    public void set_CamelCaseText(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NamingStrategy get_NamingStrategy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NamingStrategy(NamingStrategy value);
    [CompilerGeneratedAttribute]
public bool get_AllowIntegerValues();
    [CompilerGeneratedAttribute]
public void set_AllowIntegerValues(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.UnixDateTimeConverter : DateTimeConverterBase {
    internal static DateTime UnixEpoch;
    [CompilerGeneratedAttribute]
private bool <AllowPreEpoch>k__BackingField;
    public bool AllowPreEpoch { get; public set; }
    public UnixDateTimeConverter(bool allowPreEpoch);
    private static UnixDateTimeConverter();
    [CompilerGeneratedAttribute]
public bool get_AllowPreEpoch();
    [CompilerGeneratedAttribute]
public void set_AllowPreEpoch(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XAttribute Attribute { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("1")]
public XAttributeWrapper(XAttribute attribute);
    [NullableContextAttribute("1")]
private XAttribute get_Attribute();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual IXmlNode get_ParentNode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XComment Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("1")]
public XCommentWrapper(XComment text);
    [NullableContextAttribute("1")]
private XComment get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _childNodes;
    private XContainer Container { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("2")]
public IXmlNode ParentNode { get; }
    public XContainerWrapper(XContainer container);
    private XContainer get_Container();
    public virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    [NullableContextAttribute("2")]
public virtual IXmlNode get_ParentNode();
    internal static IXmlNode WrapNode(XObject node);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private XDeclaration <Declaration>k__BackingField;
    [NullableAttribute("1")]
internal XDeclaration Declaration { get; }
    public XmlNodeType NodeType { get; }
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    [NullableContextAttribute("1")]
public XDeclarationWrapper(XDeclaration declaration);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal XDeclaration get_Declaration();
    public virtual XmlNodeType get_NodeType();
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XDocumentType _documentType;
    [NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    [NullableContextAttribute("1")]
public XDocumentTypeWrapper(XDocumentType documentType);
    [NullableContextAttribute("1")]
public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
    private XDocument Document { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public XDocumentWrapper(XDocument document);
    private XDocument get_Document();
    public virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    public sealed virtual IXmlNode CreateComment(string text);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public sealed virtual IXmlElement get_DocumentElement();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _attributes;
    private XElement Element { get; }
    public List`1<IXmlNode> Attributes { get; }
    [NullableAttribute("2")]
public string Value { get; public set; }
    [NullableAttribute("2")]
public string LocalName { get; }
    [NullableAttribute("2")]
public string NamespaceUri { get; }
    public bool IsEmpty { get; }
    public XElementWrapper(XElement element);
    private XElement get_Element();
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public virtual List`1<IXmlNode> get_Attributes();
    private bool HasImplicitNamespaceAttribute(string namespaceUri);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    [NullableContextAttribute("2")]
public virtual string get_Value();
    [NullableContextAttribute("2")]
public virtual void set_Value(string value);
    [NullableContextAttribute("2")]
public virtual string get_LocalName();
    [NullableContextAttribute("2")]
public virtual string get_NamespaceUri();
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    [NullableAttribute("1")]
private XmlDeclaration _declaration;
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    [NullableContextAttribute("1")]
public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
    [NullableAttribute("1")]
private XmlDocumentType _documentType;
    [NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    [NullableContextAttribute("1")]
public XmlDocumentTypeWrapper(XmlDocumentType documentType);
    [NullableContextAttribute("1")]
public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    private XmlDocument _document;
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public sealed virtual IXmlElement get_DocumentElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    private XmlElement _element;
    public bool IsEmpty { get; }
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
    internal static List`1<IXmlNode> EmptyChildNodes;
    private static string TextName;
    private static string CommentName;
    private static string CDataName;
    private static string WhitespaceName;
    private static string SignificantWhitespaceName;
    private static string DeclarationName;
    private static string JsonNamespaceUri;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitRootObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncodeSpecialCharacters>k__BackingField;
    [NullableAttribute("2")]
public string DeserializeRootElementName { get; public set; }
    public bool WriteArrayAttribute { get; public set; }
    public bool OmitRootObject { get; public set; }
    public bool EncodeSpecialCharacters { get; public set; }
    private static XmlNodeConverter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteArrayAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteArrayAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitRootObject();
    [CompilerGeneratedAttribute]
public void set_OmitRootObject(bool value);
    [CompilerGeneratedAttribute]
public bool get_EncodeSpecialCharacters();
    [CompilerGeneratedAttribute]
public void set_EncodeSpecialCharacters(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private IXmlNode WrapXml(object value);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private bool IsArray(IXmlNode node);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, List`1<IXmlNode> groupedNodes, string elementNames);
    private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, IXmlNode node, string elementNames);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private static bool AllSameName(IXmlNode node);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary`2<string, string> attributeNameValues);
    private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, string attributeName, XmlNamespaceManager manager, string attributePrefix);
    private static string ConvertTokenToXmlValue(JsonReader reader);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document);
    private bool ShouldReadInto(JsonReader reader);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private bool ValueAttributes(List`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
    private bool IsXObject(Type valueType);
    private bool IsXmlNode(Type valueType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlNodeWrapper : object {
    [NullableAttribute("1")]
private XmlNode _node;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _childNodes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _attributes;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    private bool HasAttributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    [NullableContextAttribute("1")]
public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    [NullableContextAttribute("1")]
public sealed virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    [NullableContextAttribute("1")]
internal static IXmlNode WrapNode(XmlNode node);
    [NullableContextAttribute("1")]
public sealed virtual List`1<IXmlNode> get_Attributes();
    private bool get_HasAttributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    [NullableContextAttribute("1")]
public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public sealed virtual string get_NamespaceUri();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XObjectWrapper : object {
    private XObject _xmlObject;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XObjectWrapper(XObject xmlObject);
    public sealed virtual object get_WrappedNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    [NullableContextAttribute("1")]
public virtual List`1<IXmlNode> get_ChildNodes();
    [NullableContextAttribute("1")]
public virtual List`1<IXmlNode> get_Attributes();
    public virtual IXmlNode get_ParentNode();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    [NullableContextAttribute("1")]
public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_NamespaceUri();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XProcessingInstruction ProcessingInstruction { get; }
    public string LocalName { get; }
    public string Value { get; public set; }
    [NullableContextAttribute("1")]
public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction);
    [NullableContextAttribute("1")]
private XProcessingInstruction get_ProcessingInstruction();
    public virtual string get_LocalName();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XText Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("1")]
public XTextWrapper(XText text);
    [NullableContextAttribute("1")]
private XText get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
public enum Newtonsoft.Json.DateFormatHandling : Enum {
    public int value__;
    public static DateFormatHandling IsoDateFormat;
    public static DateFormatHandling MicrosoftDateFormat;
}
public enum Newtonsoft.Json.DateParseHandling : Enum {
    public int value__;
    public static DateParseHandling None;
    public static DateParseHandling DateTime;
    public static DateParseHandling DateTimeOffset;
}
public enum Newtonsoft.Json.DateTimeZoneHandling : Enum {
    public int value__;
    public static DateTimeZoneHandling Local;
    public static DateTimeZoneHandling Utc;
    public static DateTimeZoneHandling Unspecified;
    public static DateTimeZoneHandling RoundtripKind;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.DefaultJsonNameTable : JsonNameTable {
    private static int HashCodeRandomizer;
    private int _count;
    private Entry[] _entries;
    private int _mask;
    private static DefaultJsonNameTable();
    public virtual string Get(Char[] key, int start, int length);
    public string Add(string key);
    private string AddEntry(string str, int hashCode);
    private void Grow();
    private static bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length);
}
[FlagsAttribute]
public enum Newtonsoft.Json.DefaultValueHandling : Enum {
    public int value__;
    public static DefaultValueHandling Include;
    public static DefaultValueHandling Ignore;
    public static DefaultValueHandling Populate;
    public static DefaultValueHandling IgnoreAndPopulate;
}
public enum Newtonsoft.Json.FloatFormatHandling : Enum {
    public int value__;
    public static FloatFormatHandling String;
    public static FloatFormatHandling Symbol;
    public static FloatFormatHandling DefaultValue;
}
public enum Newtonsoft.Json.FloatParseHandling : Enum {
    public int value__;
    public static FloatParseHandling Double;
    public static FloatParseHandling Decimal;
}
public enum Newtonsoft.Json.Formatting : Enum {
    public int value__;
    public static Formatting None;
    public static Formatting Indented;
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.IArrayPool`1 {
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array);
}
internal interface Newtonsoft.Json.IJsonLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[AttributeUsageAttribute("1028")]
internal class Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
    private bool _allowNullItems;
    public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    [NullableContextAttribute("1")]
public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[AttributeUsageAttribute("32")]
internal class Newtonsoft.Json.JsonConstructorAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
internal abstract class Newtonsoft.Json.JsonContainerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategyInstance>k__BackingField;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    private Type _namingStrategyType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _namingStrategyParameters;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public Type ItemConverterType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ItemConverterParameters { get; public set; }
    public Type NamingStrategyType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] NamingStrategyParameters { get; public set; }
    internal NamingStrategy NamingStrategyInstance { get; internal set; }
    public bool IsReference { get; public set; }
    public bool ItemIsReference { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    [NullableContextAttribute("1")]
protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public Type get_NamingStrategyType();
    public void set_NamingStrategyType(Type value);
    public Object[] get_NamingStrategyParameters();
    public void set_NamingStrategyParameters(Object[] value);
    [CompilerGeneratedAttribute]
internal NamingStrategy get_NamingStrategyInstance();
    [CompilerGeneratedAttribute]
internal void set_NamingStrategyInstance(NamingStrategy value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
}
internal enum Newtonsoft.Json.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.JsonConvert : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField;
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`1<JsonSerializerSettings> DefaultSettings { get; public set; }
    private static JsonConvert();
    [CompilerGeneratedAttribute]
public static Func`1<JsonSerializerSettings> get_DefaultSettings();
    [CompilerGeneratedAttribute]
public static void set_DefaultSettings(Func`1<JsonSerializerSettings> value);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, DateFormatHandling format);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    private static string ToStringInternal(BigInteger value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    public static string ToString(double value);
    internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    internal static string ToString(Guid value, char quoteChar);
    public static string ToString(TimeSpan value);
    internal static string ToString(TimeSpan value, char quoteChar);
    public static string ToString(Uri value);
    internal static string ToString(Uri value, char quoteChar);
    public static string ToString(string value);
    public static string ToString(string value, char delimiter);
    public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling);
    public static string ToString(object value);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, JsonConverter[] converters);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Type type, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings);
    private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, Type type);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static T DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value, JsonConverter[] converters);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static T DeserializeObject(string value, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    [NullableContextAttribute("2")]
public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject);
    public static XmlDocument DeserializeXmlNode(string value);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters);
    public static string SerializeXNode(XObject node);
    public static string SerializeXNode(XObject node, Formatting formatting);
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject);
    public static XDocument DeserializeXNode(string value);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.JsonConverter : object {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.JsonConverter`1 : JsonConverter {
    public sealed virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual void WriteJson(JsonWriter writer, T value, JsonSerializer serializer);
    public sealed virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T ReadJson(JsonReader reader, Type objectType, T existingValue, bool hasExistingValue, JsonSerializer serializer);
    public sealed virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("3484")]
internal class Newtonsoft.Json.JsonConverterAttribute : Attribute {
    private Type _converterType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ConverterParameters>k__BackingField;
    public Type ConverterType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ConverterParameters { get; }
    public JsonConverterAttribute(Type converterType);
    public JsonConverterAttribute(Type converterType, Object[] converterParameters);
    public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public Object[] get_ConverterParameters();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Newtonsoft.Json.JsonConverterCollection : Collection`1<JsonConverter> {
}
[AttributeUsageAttribute("1028")]
internal class Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
    [NullableContextAttribute("1")]
public JsonDictionaryAttribute(string id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.JsonException : Exception {
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    public JsonException(SerializationInfo info, StreamingContext context);
    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("384")]
internal class Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WriteData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadData>k__BackingField;
    public bool WriteData { get; public set; }
    public bool ReadData { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WriteData();
    [CompilerGeneratedAttribute]
public void set_WriteData(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadData();
    [CompilerGeneratedAttribute]
public void set_ReadData(bool value);
}
[AttributeUsageAttribute("384")]
internal class Newtonsoft.Json.JsonIgnoreAttribute : Attribute {
}
internal abstract class Newtonsoft.Json.JsonNameTable : object {
    [NullableContextAttribute("1")]
public abstract virtual string Get(Char[] key, int start, int length);
}
[AttributeUsageAttribute("1036")]
internal class Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
    private MemberSerialization _memberSerialization;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<Required> _itemRequired;
    internal Nullable`1<NullValueHandling> _itemNullValueHandling;
    public MemberSerialization MemberSerialization { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling ItemNullValueHandling { get; public set; }
    public Required ItemRequired { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    [NullableContextAttribute("1")]
public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public NullValueHandling get_ItemNullValueHandling();
    public void set_ItemNullValueHandling(NullValueHandling value);
    public Required get_ItemRequired();
    public void set_ItemRequired(Required value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.JsonPosition : ValueType {
    private static Char[] SpecialCharacters;
    internal JsonContainerType Type;
    internal int Position;
    [NullableAttribute("2")]
internal string PropertyName;
    internal bool HasIndex;
    public JsonPosition(JsonContainerType type);
    private static JsonPosition();
    internal int CalculateLength();
    [NullableContextAttribute("2")]
internal void WriteTo(StringBuilder sb, StringWriter& writer, Char[]& buffer);
    internal static bool TypeHasIndex(JsonContainerType type);
    internal static string BuildPath(List`1<JsonPosition> positions, Nullable`1<JsonPosition> currentPosition);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
internal class Newtonsoft.Json.JsonPropertyAttribute : Attribute {
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<int> _order;
    internal Nullable`1<Required> _required;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NamingStrategyType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <NamingStrategyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public Type ItemConverterType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ItemConverterParameters { get; public set; }
    public Type NamingStrategyType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] NamingStrategyParameters { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public bool IsReference { get; public set; }
    public int Order { get; public set; }
    public Required Required { get; public set; }
    public string PropertyName { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    public bool ItemIsReference { get; public set; }
    [NullableContextAttribute("1")]
public JsonPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    [CompilerGeneratedAttribute]
public Type get_NamingStrategyType();
    [CompilerGeneratedAttribute]
public void set_NamingStrategyType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_NamingStrategyParameters();
    [CompilerGeneratedAttribute]
public void set_NamingStrategyParameters(Object[] value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public int get_Order();
    public void set_Order(int value);
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    private JsonPosition _currentPosition;
    private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    internal FloatParseHandling _floatParseHandling;
    private string _dateFormatString;
    private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public char QuoteChar { get; protected internal set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Depth { get; }
    [NullableAttribute("1")]
public string Path { get; }
    [NullableAttribute("1")]
public CultureInfo Culture { get; public set; }
    [NullableContextAttribute("1")]
public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<SkipAsync>d__1")]
public Task SkipAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReaderReadAndAssertAsync>d__2")]
internal Task ReaderReadAndAssertAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<bool>> ReadAsBooleanAsync(CancellationToken cancellationToken);
    public virtual Task`1<Byte[]> ReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReadArrayIntoByteArrayAsync>d__5")]
internal Task`1<Byte[]> ReadArrayIntoByteArrayAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<DateTime>> ReadAsDateTimeAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<decimal>> ReadAsDecimalAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<double>> ReadAsDoubleAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<int>> ReadAsInt32Async(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReadAndMoveToContentAsync>d__12")]
internal Task`1<bool> ReadAndMoveToContentAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
internal Task`1<bool> MoveToContentAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<MoveToContentFromNonContentAsync>d__14")]
private Task`1<bool> MoveToContentFromNonContentAsync(CancellationToken cancellationToken);
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    [NullableContextAttribute("1")]
public virtual string get_Path();
    [NullableContextAttribute("1")]
public CultureInfo get_Culture();
    [NullableContextAttribute("1")]
public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    internal Nullable`1<int> ReadInt32String(string s);
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    [NullableContextAttribute("1")]
internal Byte[] ReadArrayIntoByteArray();
    [NullableContextAttribute("1")]
private bool ReadArrayElementIntoByteArrayReportDone(List`1<byte> buffer);
    public virtual Nullable`1<double> ReadAsDouble();
    internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    internal Nullable`1<decimal> ReadDecimalString(string s);
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    internal Nullable`1<DateTime> ReadDateTimeString(string s);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal Nullable`1<DateTimeOffset> ReadDateTimeOffsetString(string s);
    internal void ReaderReadAndAssert();
    [NullableContextAttribute("1")]
internal JsonReaderException CreateUnexpectedEndException();
    internal void ReadIntoWrappedTypeObject();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    protected void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    internal void ReadForTypeAndAssert(JsonContract contract, bool hasConverter);
    internal bool ReadForType(JsonContract contract, bool hasConverter);
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.JsonReaderException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    [NullableAttribute("2")]
public string Path { get; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    public JsonReaderException(SerializationInfo info, StreamingContext context);
    public JsonReaderException(string message, string path, int lineNumber, int linePosition, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonReaderException Create(JsonReader reader, string message);
    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex);
    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[AttributeUsageAttribute("384")]
internal class Newtonsoft.Json.JsonRequiredAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.JsonSerializationException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    [NullableAttribute("2")]
public string Path { get; }
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
    public JsonSerializationException(SerializationInfo info, StreamingContext context);
    public JsonSerializationException(string message, string path, int lineNumber, int linePosition, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonSerializationException Create(JsonReader reader, string message);
    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex);
    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonSerializer : object {
    internal TypeNameHandling _typeNameHandling;
    internal TypeNameAssemblyFormatHandling _typeNameAssemblyFormatHandling;
    internal PreserveReferencesHandling _preserveReferencesHandling;
    internal ReferenceLoopHandling _referenceLoopHandling;
    internal MissingMemberHandling _missingMemberHandling;
    internal ObjectCreationHandling _objectCreationHandling;
    internal NullValueHandling _nullValueHandling;
    internal DefaultValueHandling _defaultValueHandling;
    internal ConstructorHandling _constructorHandling;
    internal MetadataPropertyHandling _metadataPropertyHandling;
    [NullableAttribute("2")]
internal JsonConverterCollection _converters;
    internal IContractResolver _contractResolver;
    [NullableAttribute("2")]
internal ITraceWriter _traceWriter;
    [NullableAttribute("2")]
internal IEqualityComparer _equalityComparer;
    internal ISerializationBinder _serializationBinder;
    internal StreamingContext _context;
    [NullableAttribute("2")]
private IReferenceResolver _referenceResolver;
    private Nullable`1<Formatting> _formatting;
    private Nullable`1<DateFormatHandling> _dateFormatHandling;
    private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    private Nullable`1<DateParseHandling> _dateParseHandling;
    private Nullable`1<FloatFormatHandling> _floatFormatHandling;
    private Nullable`1<FloatParseHandling> _floatParseHandling;
    private Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _maxDepthSet;
    private Nullable`1<bool> _checkAdditionalContent;
    [NullableAttribute("2")]
private string _dateFormatString;
    private bool _dateFormatStringSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Error;
    [NullableAttribute("2")]
public IReferenceResolver ReferenceResolver { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    [NullableAttribute("2")]
public ITraceWriter TraceWriter { get; public set; }
    [NullableAttribute("2")]
public IEqualityComparer EqualityComparer { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public JsonConverterCollection Converters { get; }
    public IContractResolver ContractResolver { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    [CompilerGeneratedAttribute]
public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [NullableContextAttribute("2")]
public virtual IReferenceResolver get_ReferenceResolver();
    [NullableContextAttribute("2")]
public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ISerializationBinder get_SerializationBinder();
    public virtual void set_SerializationBinder(ISerializationBinder value);
    [NullableContextAttribute("2")]
public virtual ITraceWriter get_TraceWriter();
    [NullableContextAttribute("2")]
public virtual void set_TraceWriter(ITraceWriter value);
    [NullableContextAttribute("2")]
public virtual IEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public virtual void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal bool IsCheckAdditionalContentSet();
    public static JsonSerializer Create();
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public static JsonSerializer CreateDefault();
    public static JsonSerializer CreateDefault(JsonSerializerSettings settings);
    private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public void Populate(TextReader reader, object target);
    [DebuggerStepThroughAttribute]
public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    [DebuggerStepThroughAttribute]
public object Deserialize(JsonReader reader);
    [DebuggerStepThroughAttribute]
public object Deserialize(TextReader reader, Type objectType);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public T Deserialize(JsonReader reader);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public object Deserialize(JsonReader reader, Type objectType);
    [NullableContextAttribute("2")]
internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    [NullableContextAttribute("2")]
internal void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString);
    [NullableContextAttribute("2")]
private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString);
    public void Serialize(TextWriter textWriter, object value);
    [NullableContextAttribute("2")]
public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    public void Serialize(TextWriter textWriter, object value, Type objectType);
    public void Serialize(JsonWriter jsonWriter, object value);
    private TraceJsonReader CreateTraceJsonReader(JsonReader reader);
    [NullableContextAttribute("2")]
internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType);
    internal IReferenceResolver GetReferenceResolver();
    internal JsonConverter GetMatchingConverter(Type type);
    internal static JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType);
    internal void OnError(ErrorEventArgs e);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonSerializerSettings : object {
    internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    internal static MissingMemberHandling DefaultMissingMemberHandling;
    internal static NullValueHandling DefaultNullValueHandling;
    internal static DefaultValueHandling DefaultDefaultValueHandling;
    internal static ObjectCreationHandling DefaultObjectCreationHandling;
    internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    internal static ConstructorHandling DefaultConstructorHandling;
    internal static TypeNameHandling DefaultTypeNameHandling;
    internal static MetadataPropertyHandling DefaultMetadataPropertyHandling;
    internal static StreamingContext DefaultContext;
    internal static Formatting DefaultFormatting;
    internal static DateFormatHandling DefaultDateFormatHandling;
    internal static DateTimeZoneHandling DefaultDateTimeZoneHandling;
    internal static DateParseHandling DefaultDateParseHandling;
    internal static FloatParseHandling DefaultFloatParseHandling;
    internal static FloatFormatHandling DefaultFloatFormatHandling;
    internal static StringEscapeHandling DefaultStringEscapeHandling;
    internal static TypeNameAssemblyFormatHandling DefaultTypeNameAssemblyFormatHandling;
    [NullableAttribute("1")]
internal static CultureInfo DefaultCulture;
    internal static bool DefaultCheckAdditionalContent;
    [NullableAttribute("1")]
internal static string DefaultDateFormatString;
    internal static int DefaultMaxDepth;
    internal Nullable`1<Formatting> _formatting;
    internal Nullable`1<DateFormatHandling> _dateFormatHandling;
    internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    internal Nullable`1<DateParseHandling> _dateParseHandling;
    internal Nullable`1<FloatFormatHandling> _floatFormatHandling;
    internal Nullable`1<FloatParseHandling> _floatParseHandling;
    internal Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    internal CultureInfo _culture;
    internal Nullable`1<bool> _checkAdditionalContent;
    internal Nullable`1<int> _maxDepth;
    internal bool _maxDepthSet;
    internal string _dateFormatString;
    internal bool _dateFormatStringSet;
    internal Nullable`1<TypeNameAssemblyFormatHandling> _typeNameAssemblyFormatHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling;
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<StreamingContext> _context;
    internal Nullable`1<ConstructorHandling> _constructorHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer <EqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializationBinder <SerializationBinder>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    [NullableAttribute("1")]
public IList`1<JsonConverter> Converters { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public IEqualityComparer EqualityComparer { get; public set; }
    [ObsoleteAttribute("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
public IReferenceResolver ReferenceResolver { get; public set; }
    public Func`1<IReferenceResolver> ReferenceResolverProvider { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    public StreamingContext Context { get; public set; }
    [NullableAttribute("1")]
public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    [NullableAttribute("1")]
public CultureInfo Culture { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    private static JsonSerializerSettings();
    [NullableContextAttribute("1")]
public JsonSerializerSettings(JsonSerializerSettings original);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    public PreserveReferencesHandling get_PreserveReferencesHandling();
    public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public MetadataPropertyHandling get_MetadataPropertyHandling();
    public void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public ConstructorHandling get_ConstructorHandling();
    public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public IEqualityComparer get_EqualityComparer();
    [CompilerGeneratedAttribute]
public void set_EqualityComparer(IEqualityComparer value);
    public IReferenceResolver get_ReferenceResolver();
    public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public Func`1<IReferenceResolver> get_ReferenceResolverProvider();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    public SerializationBinder get_Binder();
    public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public ISerializationBinder get_SerializationBinder();
    [CompilerGeneratedAttribute]
public void set_SerializationBinder(ISerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    public StreamingContext get_Context();
    public void set_Context(StreamingContext value);
    [NullableContextAttribute("1")]
public string get_DateFormatString();
    [NullableContextAttribute("1")]
public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    [NullableContextAttribute("1")]
public CultureInfo get_Culture();
    [NullableContextAttribute("1")]
public void set_Culture(CultureInfo value);
    public bool get_CheckAdditionalContent();
    public void set_CheckAdditionalContent(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.JsonTextReader : JsonReader {
    private bool _safeAsync;
    private static char UnicodeReplacementChar;
    private static int MaximumJavascriptIntegerCharacterLength;
    private static int LargeBufferLength;
    private TextReader _reader;
    [NullableAttribute("2")]
private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _stringBuffer;
    private StringReference _stringReference;
    [NullableAttribute("2")]
private IArrayPool`1<char> _arrayPool;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNameTable <PropertyNameTable>k__BackingField;
    [NullableAttribute("2")]
public JsonNameTable PropertyNameTable { get; public set; }
    [NullableAttribute("2")]
public IArrayPool`1<char> ArrayPool { get; public set; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    internal Task`1<bool> DoReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsync>d__3")]
private Task`1<bool> DoReadAsync(Task`1<bool> task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParsePostValueAsync>d__4")]
private Task`1<bool> ParsePostValueAsync(bool ignoreComments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadFromFinishedAsync>d__5")]
private Task`1<bool> ReadFromFinishedAsync(CancellationToken cancellationToken);
    private Task`1<int> ReadDataAsync(bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadDataAsync>d__7")]
private Task`1<int> ReadDataAsync(bool append, int charsRequired, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseValueAsync>d__8")]
private Task`1<bool> ParseValueAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadStringIntoBufferAsync>d__9")]
private Task ReadStringIntoBufferAsync(char quote, CancellationToken cancellationToken);
    private Task ProcessCarriageReturnAsync(bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ProcessCarriageReturnAsync>d__11")]
private Task ProcessCarriageReturnAsync(Task`1<bool> task);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseUnicodeAsync>d__12")]
private Task`1<char> ParseUnicodeAsync(CancellationToken cancellationToken);
    private Task`1<bool> EnsureCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadCharsAsync>d__14")]
private Task`1<bool> ReadCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseObjectAsync>d__15")]
private Task`1<bool> ParseObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseCommentAsync>d__16")]
private Task ParseCommentAsync(bool setToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<EatWhitespaceAsync>d__17")]
private Task EatWhitespaceAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseStringAsync>d__18")]
private Task ParseStringAsync(char quote, ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchValueAsync>d__19")]
private Task`1<bool> MatchValueAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchValueWithTrailingSeparatorAsync>d__20")]
private Task`1<bool> MatchValueWithTrailingSeparatorAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchAndSetAsync>d__21")]
private Task MatchAndSetAsync(string value, JsonToken newToken, object tokenValue, CancellationToken cancellationToken);
    private Task ParseTrueAsync(CancellationToken cancellationToken);
    private Task ParseFalseAsync(CancellationToken cancellationToken);
    private Task ParseNullAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseConstructorAsync>d__25")]
private Task ParseConstructorAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberNaNAsync>d__26")]
private Task`1<object> ParseNumberNaNAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberPositiveInfinityAsync>d__27")]
private Task`1<object> ParseNumberPositiveInfinityAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberNegativeInfinityAsync>d__28")]
private Task`1<object> ParseNumberNegativeInfinityAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberAsync>d__29")]
private Task ParseNumberAsync(ReadType readType, CancellationToken cancellationToken);
    private Task ParseUndefinedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParsePropertyAsync>d__31")]
private Task`1<bool> ParsePropertyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNumberIntoBufferAsync>d__32")]
private Task ReadNumberIntoBufferAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseUnquotedPropertyAsync>d__33")]
private Task ParseUnquotedPropertyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNullCharAsync>d__34")]
private Task`1<bool> ReadNullCharAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<HandleNullAsync>d__35")]
private Task HandleNullAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadFinishedAsync>d__36")]
private Task ReadFinishedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadStringValueAsync>d__37")]
private Task`1<object> ReadStringValueAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNumberValueAsync>d__38")]
private Task`1<object> ReadNumberValueAsync(ReadType readType, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<bool>> ReadAsBooleanAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsBooleanAsync>d__40")]
internal Task`1<Nullable`1<bool>> DoReadAsBooleanAsync(CancellationToken cancellationToken);
    public virtual Task`1<Byte[]> ReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsBytesAsync>d__42")]
internal Task`1<Byte[]> DoReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadIntoWrappedTypeObjectAsync>d__43")]
private Task ReadIntoWrappedTypeObjectAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTime>> ReadAsDateTimeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDateTimeAsync>d__45")]
internal Task`1<Nullable`1<DateTime>> DoReadAsDateTimeAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDateTimeOffsetAsync>d__47")]
internal Task`1<Nullable`1<DateTimeOffset>> DoReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<decimal>> ReadAsDecimalAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDecimalAsync>d__49")]
internal Task`1<Nullable`1<decimal>> DoReadAsDecimalAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<double>> ReadAsDoubleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDoubleAsync>d__51")]
internal Task`1<Nullable`1<double>> DoReadAsDoubleAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<int>> ReadAsInt32Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsInt32Async>d__53")]
internal Task`1<Nullable`1<int>> DoReadAsInt32Async(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsStringAsync>d__55")]
internal Task`1<string> DoReadAsStringAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNameTable get_PropertyNameTable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PropertyNameTable(JsonNameTable value);
    [NullableContextAttribute("2")]
public IArrayPool`1<char> get_ArrayPool();
    [NullableContextAttribute("2")]
public void set_ArrayPool(IArrayPool`1<char> value);
    private void EnsureBufferNotEmpty();
    private void SetNewLine(bool hasNextChar);
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private void ParseReadString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private void PrepareBufferForReadData(bool append, int charsRequired);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    [NullableContextAttribute("2")]
public virtual string ReadAsString();
    [NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    [NullableContextAttribute("2")]
private object ReadStringValue(ReadType readType);
    [NullableContextAttribute("2")]
private object FinishReadQuotedStringValue(ReadType readType);
    private JsonReaderException CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    [NullableContextAttribute("2")]
private object ReadNumberValue(ReadType readType);
    [NullableContextAttribute("2")]
private object FinishReadQuotedNumber(ReadType readType);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void FinishReadStringIntoBuffer(int charPos, int initialPosition, int lastWritePosition);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ConvertUnicode(bool enoughChars);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private bool ReadNumberCharIntoBuffer(char currentChar, int charPos);
    private void ClearRecentString();
    private bool ParsePostValue(bool ignoreComments);
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition);
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private void EatWhitespace();
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition);
    private JsonReaderException ThrowReaderError(string message, Exception ex);
    private static object BigIntegerParse(string number, CultureInfo culture);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValue(bool enoughChars, string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberNegativeInfinity(ReadType readType, bool matched);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType, bool matched);
    private object ParseNumberNaN(ReadType readType);
    private object ParseNumberNaN(ReadType readType, bool matched);
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.JsonTextWriter : JsonWriter {
    private bool _safeAsync;
    private static int IndentCharBufferSize;
    private TextWriter _writer;
    [NullableAttribute("2")]
private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;
    [NullableAttribute("2")]
private Boolean[] _charEscapeFlags;
    [NullableAttribute("2")]
private Char[] _writeBuffer;
    [NullableAttribute("2")]
private IArrayPool`1<char> _arrayPool;
    [NullableAttribute("2")]
private Char[] _indentChars;
    private Base64Encoder Base64Encoder { get; }
    [NullableAttribute("2")]
public IArrayPool`1<char> ArrayPool { get; public set; }
    public int Indentation { get; public set; }
    public char QuoteChar { get; public set; }
    public char IndentChar { get; public set; }
    public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    internal Task DoFlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken);
    internal Task DoWriteValueDelimiterAsync(CancellationToken cancellationToken);
    protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    internal Task DoWriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoCloseAsync>d__8")]
internal Task DoCloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<CloseBufferAndWriterAsync>d__9")]
private Task CloseBufferAndWriterAsync();
    public virtual Task WriteEndAsync(CancellationToken cancellationToken);
    protected virtual Task WriteIndentAsync(CancellationToken cancellationToken);
    internal Task DoWriteIndentAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteIndentAsync>d__13")]
private Task WriteIndentAsync(int currentIndentCount, int newLineLen, CancellationToken cancellationToken);
    private Task WriteValueInternalAsync(JsonToken token, string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueInternalAsync>d__15")]
private Task WriteValueInternalAsync(Task task, string value, CancellationToken cancellationToken);
    protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken);
    internal Task DoWriteIndentSpaceAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawAsync(string json, CancellationToken cancellationToken);
    internal Task DoWriteRawAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteNullAsync(CancellationToken cancellationToken);
    internal Task DoWriteNullAsync(CancellationToken cancellationToken);
    private Task WriteDigitsAsync(ulong uvalue, bool negative, CancellationToken cancellationToken);
    private Task WriteIntegerValueAsync(ulong uvalue, bool negative, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteIntegerValueAsync>d__24")]
private Task WriteIntegerValueAsync(Task task, ulong uvalue, bool negative, CancellationToken cancellationToken);
    internal Task WriteIntegerValueAsync(long value, CancellationToken cancellationToken);
    internal Task WriteIntegerValueAsync(ulong uvalue, CancellationToken cancellationToken);
    private Task WriteEscapedStringAsync(string value, bool quote, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken);
    internal Task DoWritePropertyNameAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWritePropertyNameAsync>d__30")]
private Task DoWritePropertyNameAsync(Task task, string name, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWritePropertyNameAsync>d__32")]
internal Task DoWritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken);
    internal Task DoWriteStartArrayAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartArrayAsync>d__35")]
internal Task DoWriteStartArrayAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken);
    internal Task DoWriteStartObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartObjectAsync>d__38")]
internal Task DoWriteStartObjectAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartConstructorAsync>d__40")]
internal Task DoWriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken);
    internal Task DoWriteUndefinedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteUndefinedAsync>d__43")]
private Task DoWriteUndefinedAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    internal Task DoWriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(bool value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueNonNullAsync>d__54")]
internal Task WriteValueNonNullAsync(Byte[] value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(char value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__60")]
internal Task DoWriteValueAsync(DateTime value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__64")]
internal Task DoWriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(decimal value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(double value, bool nullable, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(float value, bool nullable, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__78")]
internal Task DoWriteValueAsync(Guid value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(BigInteger value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(object value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(string value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__97")]
private Task DoWriteValueAsync(Task task, string value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__99")]
internal Task DoWriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Uri value, CancellationToken cancellationToken);
    internal Task WriteValueNotNullAsync(Uri value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueNotNullAsync>d__110")]
internal Task WriteValueNotNullAsync(Task task, Uri value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public virtual Task WriteCommentAsync(string text, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteCommentAsync>d__115")]
internal Task DoWriteCommentAsync(string text, CancellationToken cancellationToken);
    public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawValueAsync(string json, CancellationToken cancellationToken);
    internal Task DoWriteRawValueAsync(string json, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteRawValueAsync>d__121")]
private Task DoWriteRawValueAsync(Task task, string json, CancellationToken cancellationToken);
    internal Char[] EnsureWriteBuffer(int length, int copyTo);
    private Base64Encoder get_Base64Encoder();
    [NullableContextAttribute("2")]
public IArrayPool`1<char> get_ArrayPool();
    [NullableContextAttribute("2")]
public void set_ArrayPool(IArrayPool`1<char> value);
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    private void CloseBufferAndWriter();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    internal virtual void OnStringEscapeHandlingChanged();
    private void UpdateCharEscapeFlags();
    protected virtual void WriteIndent();
    private int SetIndentChars();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    private void WriteEscapedString(string value, bool quote);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    private int WriteValueToBuffer(DateTime value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    private int WriteValueToBuffer(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void EnsureWriteBuffer();
    private void WriteIntegerValue(long value);
    private void WriteIntegerValue(ulong value, bool negative);
    private int WriteNumberToBuffer(ulong value, bool negative);
    private void WriteIntegerValue(int value);
    private void WriteIntegerValue(UInt32 value, bool negative);
    private int WriteNumberToBuffer(UInt32 value, bool negative);
}
public enum Newtonsoft.Json.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.JsonValidatingReader : JsonReader {
    private JsonReader _reader;
    private Stack`1<SchemaScope> _stack;
    private JsonSchema _schema;
    private JsonSchemaModel _model;
    private SchemaScope _currentScope;
    [CompilerGeneratedAttribute]
private ValidationEventHandler ValidationEventHandler;
    private static IList`1<JsonSchemaModel> EmptySchemaList;
    public object Value { get; }
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public Type ValueType { get; }
    private IList`1<JsonSchemaModel> CurrentSchemas { get; }
    private IList`1<JsonSchemaModel> CurrentMemberSchemas { get; }
    public JsonSchema Schema { get; public set; }
    public JsonReader Reader { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JsonValidatingReader(JsonReader reader);
    private static JsonValidatingReader();
    [CompilerGeneratedAttribute]
public void add_ValidationEventHandler(ValidationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ValidationEventHandler(ValidationEventHandler value);
    public virtual object get_Value();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual Type get_ValueType();
    private void Push(SchemaScope scope);
    private SchemaScope Pop();
    private IList`1<JsonSchemaModel> get_CurrentSchemas();
    private IList`1<JsonSchemaModel> get_CurrentMemberSchemas();
    private void RaiseError(string message, JsonSchemaModel schema);
    private void OnValidationEvent(JsonSchemaException exception);
    public JsonSchema get_Schema();
    public void set_Schema(JsonSchema value);
    public JsonReader get_Reader();
    public virtual void Close();
    private void ValidateNotDisallowed(JsonSchemaModel schema);
    private Nullable`1<JsonSchemaType> GetCurrentNodeSchemaType();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    private void ValidateCurrentToken();
    private void WriteToken(IList`1<JsonSchemaModel> schemas);
    private void ValidateEndObject(JsonSchemaModel schema);
    private void ValidateEndArray(JsonSchemaModel schema);
    private void ValidateNull(JsonSchemaModel schema);
    private void ValidateBoolean(JsonSchemaModel schema);
    private void ValidateString(JsonSchemaModel schema);
    private void ValidateInteger(JsonSchemaModel schema);
    private void ProcessValue();
    private void ValidateFloat(JsonSchemaModel schema);
    private static double FloatingPointRemainder(double dividend, double divisor);
    private static bool IsZero(double value);
    private void ValidatePropertyName(JsonSchemaModel schema);
    private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName);
    private bool ValidateArray(JsonSchemaModel schema);
    private bool ValidateObject(JsonSchemaModel schema);
    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.JsonWriter : object {
    private static State[][] StateArray;
    internal static State[][] StateArrayTemplate;
    [NullableAttribute("2")]
private List`1<JsonPosition> _stack;
    private JsonPosition _currentPosition;
    private State _currentState;
    private Formatting _formatting;
    [CompilerGeneratedAttribute]
private bool <CloseOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoCompleteOnClose>k__BackingField;
    private DateFormatHandling _dateFormatHandling;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private StringEscapeHandling _stringEscapeHandling;
    private FloatFormatHandling _floatFormatHandling;
    [NullableAttribute("2")]
private string _dateFormatString;
    [NullableAttribute("2")]
private CultureInfo _culture;
    public bool CloseOutput { get; public set; }
    public bool AutoCompleteOnClose { get; public set; }
    protected internal int Top { get; }
    public WriteState WriteState { get; }
    internal string ContainerPath { get; }
    public string Path { get; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    [NullableAttribute("2")]
public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static JsonWriter();
    internal Task AutoCompleteAsync(JsonToken tokenBeingWritten, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<AutoCompleteAsync>d__1")]
private Task AutoCompleteAsync(CancellationToken cancellationToken);
    public virtual Task CloseAsync(CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    protected virtual Task WriteIndentAsync(CancellationToken cancellationToken);
    protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken);
    protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteEndAsync(CancellationToken cancellationToken);
    internal Task WriteEndInternalAsync(CancellationToken cancellationToken);
    internal Task InternalWriteEndAsync(JsonContainerType type, CancellationToken cancellationToken);
    public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken);
    public virtual Task WriteNullAsync(CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    internal Task InternalWritePropertyNameAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<InternalWriteStartAsync>d__20")]
internal Task InternalWriteStartAsync(JsonToken token, JsonContainerType container, CancellationToken cancellationToken);
    public virtual Task WriteCommentAsync(string text, CancellationToken cancellationToken);
    internal Task InternalWriteCommentAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawValueAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonReader reader, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonReader reader, bool writeChildren, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonToken token, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonToken token, object value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteTokenAsync>d__30")]
internal virtual Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteTokenSyncReadingAsync>d__31")]
internal Task WriteTokenSyncReadingAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteConstructorDateAsync>d__32")]
private Task WriteConstructorDateAsync(JsonReader reader, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Byte[] value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(object value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(string value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Uri value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken);
    public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    internal Task InternalWriteValueAsync(JsonToken token, CancellationToken cancellationToken);
    protected Task SetWriteStateAsync(JsonToken token, object value, CancellationToken cancellationToken);
    internal static Task WriteValueAsync(JsonWriter writer, PrimitiveTypeCode typeCode, object value, CancellationToken cancellationToken);
    internal static State[][] BuildStateArray();
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoCompleteOnClose();
    [CompilerGeneratedAttribute]
public void set_AutoCompleteOnClose(bool value);
    protected internal int get_Top();
    public WriteState get_WriteState();
    internal string get_ContainerPath();
    public string get_Path();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    internal virtual void OnStringEscapeHandlingChanged();
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    [NullableContextAttribute("2")]
public string get_DateFormatString();
    [NullableContextAttribute("2")]
public void set_DateFormatString(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal void UpdateScopeWithFinishedValue();
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteEnd();
    public void WriteToken(JsonReader reader);
    public void WriteToken(JsonReader reader, bool writeChildren);
    [NullableContextAttribute("2")]
public void WriteToken(JsonToken token, object value);
    public void WriteToken(JsonToken token);
    internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
    private bool IsWriteTokenIncomplete(JsonReader reader, bool writeChildren, int initialDepth);
    private int CalculateWriteTokenInitialDepth(JsonReader reader);
    private int CalculateWriteTokenFinalDepth(JsonReader reader);
    private void WriteConstructorDate(JsonReader reader);
    private void WriteEnd(JsonContainerType type);
    private void AutoCompleteAll();
    private JsonToken GetCloseTokenForType(JsonContainerType type);
    private void AutoCompleteClose(JsonContainerType type);
    private int CalculateLevelsToComplete(JsonContainerType type);
    private void UpdateCurrentState();
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    [NullableContextAttribute("2")]
public virtual void WriteRawValue(string json);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value);
    private static void ResolveConvertibleValue(IConvertible convertible, PrimitiveTypeCode& typeCode, Object& value);
    private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value);
    protected void SetWriteState(JsonToken token, object value);
    internal void InternalWriteEnd(JsonContainerType container);
    internal void InternalWritePropertyName(string name);
    internal void InternalWriteRaw();
    internal void InternalWriteStart(JsonToken token, JsonContainerType container);
    internal void InternalWriteValue(JsonToken token);
    internal void InternalWriteWhitespace(string ws);
    internal void InternalWriteComment();
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitProperty|11_0>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitProperty|11_0(Task task, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitIndent|11_1>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitIndent|11_1(Task task, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitEnd|11_2>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitEnd|11_2(Task task, int LevelsToComplete, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitRemaining|11_3>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitRemaining|11_3(int LevelsToComplete, CancellationToken CancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.JsonWriterException : JsonException {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [NullableAttribute("2")]
public string Path { get; }
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
    public JsonWriterException(SerializationInfo info, StreamingContext context);
    public JsonWriterException(string message, string path, Exception innerException);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex);
    internal static JsonWriterException Create(string path, string message, Exception ex);
}
public enum Newtonsoft.Json.Linq.CommentHandling : Enum {
    public int value__;
    public static CommentHandling Ignore;
    public static CommentHandling Load;
}
public enum Newtonsoft.Json.Linq.DuplicatePropertyNameHandling : Enum {
    public int value__;
    public static DuplicatePropertyNameHandling Replace;
    public static DuplicatePropertyNameHandling Ignore;
    public static DuplicatePropertyNameHandling Error;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Linq.Extensions : object {
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.Extensions/<Values>d__11`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.Extensions/<Convert>d__14`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface Newtonsoft.Json.Linq.IJEnumerable`1 {
    public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(JArray other);
    internal JArray(JArray other, JsonCloneSettings settings);
    public JArray(Object[] content);
    public JArray(object content);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JArray/<WriteToAsync>d__0")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JArray> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JArray/<LoadAsync>d__2")]
public static Task`1<JArray> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public static JArray Load(JsonReader reader);
    public static JArray Load(JsonReader reader, JsonLoadSettings settings);
    public static JArray Parse(string json);
    public static JArray Parse(string json, JsonLoadSettings settings);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JConstructor : JContainer {
    [NullableAttribute("2")]
private string _name;
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    [NullableAttribute("2")]
public string Name { get; public set; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    internal JConstructor(JConstructor other, JsonCloneSettings settings);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JConstructor/<WriteToAsync>d__0")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JConstructor> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JConstructor/<LoadAsync>d__2")]
public static Task`1<JConstructor> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    [NullableContextAttribute("2")]
public string get_Name();
    [NullableContextAttribute("2")]
public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
    public static JConstructor Load(JsonReader reader, JsonLoadSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Linq.JContainer : JToken {
    [NullableAttribute("2")]
internal ListChangedEventHandler _listChanged;
    [NullableAttribute("2")]
internal AddingNewEventHandler _addingNew;
    [NullableAttribute("2")]
internal NotifyCollectionChangedEventHandler _collectionChanged;
    [NullableAttribute("2")]
private object _syncRoot;
    private bool _busy;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    [NullableAttribute("2")]
public JToken First { get; }
    [NullableAttribute("2")]
public JToken Last { get; }
    private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    [NullableAttribute("2")]
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    internal JContainer(JContainer other, JsonCloneSettings settings);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<ReadTokenFromAsync>d__0")]
internal Task ReadTokenFromAsync(JsonReader reader, JsonLoadSettings options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<ReadContentFromAsync>d__1")]
private Task ReadContentFromAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    internal void CheckReentrancy();
    internal virtual IList`1<JToken> CreateChildrenCollection();
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    [NullableContextAttribute("2")]
public virtual JToken get_First();
    [NullableContextAttribute("2")]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    public IEnumerable`1<JToken> DescendantsAndSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<GetDescendants>d__36")]
internal IEnumerable`1<JToken> GetDescendants(bool self);
    [NullableContextAttribute("2")]
internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck, bool copyAnnotations);
    [NullableContextAttribute("2")]
internal abstract virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    internal virtual void RemoveItemAt(int index);
    [NullableContextAttribute("2")]
internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    [NullableContextAttribute("2")]
internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    [NullableContextAttribute("2")]
internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    [NullableContextAttribute("2")]
public virtual void Add(object content);
    [NullableContextAttribute("2")]
internal bool TryAdd(object content);
    internal void AddAndSkipParentCheck(JToken token);
    [NullableContextAttribute("2")]
public void AddFirst(object content);
    [NullableContextAttribute("2")]
internal bool TryAddInternal(int index, object content, bool skipParentCheck, bool copyAnnotations);
    internal static JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal abstract virtual void MergeItem(object content, JsonMergeSettings settings);
    [NullableContextAttribute("2")]
public void Merge(object content);
    [NullableContextAttribute("2")]
public void Merge(object content, JsonMergeSettings settings);
    private void ValidateContent(object content);
    internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options);
    internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings);
    [NullableContextAttribute("2")]
private static JProperty ReadProperty(JsonReader r, JsonLoadSettings settings, IJsonLineInfo lineInfo, JContainer parent);
    internal int ContentsHashCode();
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item);
    [NullableContextAttribute("2")]
private JToken EnsureValue(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    [NullableContextAttribute("2")]
private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JEnumerable`1<T> Empty;
    private IEnumerable`1<T> _enumerable;
    public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public sealed virtual bool Equals(JEnumerable`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JObject : JContainer {
    private JPropertyKeyedCollection _properties;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    internal JObject(JObject other, JsonCloneSettings settings);
    public JObject(Object[] content);
    public JObject(object content);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JObject> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<LoadAsync>d__2")]
public static Task`1<JObject> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    private static bool IsNull(JToken token);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JProperty Property(string name, StringComparison comparison);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Load(JsonReader reader, JsonLoadSettings settings);
    public static JObject Parse(string json);
    public static JObject Parse(string json, JsonLoadSettings settings);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    [NullableContextAttribute("2")]
public JToken GetValue(string propertyName);
    [NullableContextAttribute("2")]
public JToken GetValue(string propertyName, StringComparison comparison);
    public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value);
    public sealed virtual void Add(string propertyName, JToken value);
    public sealed virtual bool ContainsKey(string propertyName);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<GetEnumerator>d__64")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanging(string propertyName);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    [NullableContextAttribute("2")]
private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    [NullableContextAttribute("2")]
private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    [NullableContextAttribute("2")]
private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    [NullableContextAttribute("2")]
private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    [NullableContextAttribute("2")]
private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<<WriteToAsync>g__AwaitProperties|0_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteToAsync>g__AwaitProperties|0_0(Task task, int i, JsonWriter Writer, CancellationToken CancellationToken, JsonConverter[] Converters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JProperty : JContainer {
    private JPropertyList _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(JProperty other, JsonCloneSettings settings);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JProperty/<WriteToAsync>d__1")]
private Task WriteToAsync(Task task, JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    private Task WriteValueAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JProperty> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JProperty/<LoadAsync>d__4")]
public static Task`1<JProperty> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    [NullableContextAttribute("2")]
internal virtual void SetItem(int index, JToken item);
    [NullableContextAttribute("2")]
internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    [NullableContextAttribute("2")]
internal virtual bool ContainsItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal virtual void ClearItems();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
    public static JProperty Load(JsonReader reader, JsonLoadSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected int NameHashCode { get; }
    public JPropertyDescriptor(string name);
    private static JObject CastInstance(object instance);
    public virtual bool CanResetValue(object component);
    [NullableContextAttribute("2")]
public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    [NullableContextAttribute("2")]
public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    protected virtual int get_NameHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
    private static IEqualityComparer`1<string> Comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, JToken> _dictionary;
    public JToken Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<JToken> Values { get; }
    private static JPropertyKeyedCollection();
    private void AddKey(string key, JToken item);
    protected void ChangeItemKey(JToken item, string newKey);
    protected virtual void ClearItems();
    public bool Contains(string key);
    private bool ContainsItem(JToken item);
    private void EnsureDictionary();
    private string GetKeyForItem(JToken item);
    protected virtual void InsertItem(int index, JToken item);
    public bool Remove(string key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(string key);
    protected virtual void SetItem(int index, JToken item);
    public JToken get_Item(string key);
    public bool TryGetValue(string key, JToken& value);
    public ICollection`1<string> get_Keys();
    public ICollection`1<JToken> get_Values();
    public int IndexOfReference(JToken t);
    public bool Compare(JPropertyKeyedCollection other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    internal JRaw(JRaw other, JsonCloneSettings settings);
    [NullableContextAttribute("2")]
public JRaw(object rawJson);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JRaw/<CreateAsync>d__0")]
public static Task`1<JRaw> CreateAsync(JsonReader reader, CancellationToken cancellationToken);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
}
public class Newtonsoft.Json.Linq.JsonCloneSettings : object {
    [NullableAttribute("1")]
internal static JsonCloneSettings SkipCopyAnnotations;
    [CompilerGeneratedAttribute]
private bool <CopyAnnotations>k__BackingField;
    public bool CopyAnnotations { get; public set; }
    private static JsonCloneSettings();
    [CompilerGeneratedAttribute]
public bool get_CopyAnnotations();
    [CompilerGeneratedAttribute]
public void set_CopyAnnotations(bool value);
}
public class Newtonsoft.Json.Linq.JsonLoadSettings : object {
    private CommentHandling _commentHandling;
    private LineInfoHandling _lineInfoHandling;
    private DuplicatePropertyNameHandling _duplicatePropertyNameHandling;
    public CommentHandling CommentHandling { get; public set; }
    public LineInfoHandling LineInfoHandling { get; public set; }
    public DuplicatePropertyNameHandling DuplicatePropertyNameHandling { get; public set; }
    public CommentHandling get_CommentHandling();
    public void set_CommentHandling(CommentHandling value);
    public LineInfoHandling get_LineInfoHandling();
    public void set_LineInfoHandling(LineInfoHandling value);
    public DuplicatePropertyNameHandling get_DuplicatePropertyNameHandling();
    public void set_DuplicatePropertyNameHandling(DuplicatePropertyNameHandling value);
}
public class Newtonsoft.Json.Linq.JsonMergeSettings : object {
    private MergeArrayHandling _mergeArrayHandling;
    private MergeNullValueHandling _mergeNullValueHandling;
    private StringComparison _propertyNameComparison;
    public MergeArrayHandling MergeArrayHandling { get; public set; }
    public MergeNullValueHandling MergeNullValueHandling { get; public set; }
    public StringComparison PropertyNameComparison { get; public set; }
    public MergeArrayHandling get_MergeArrayHandling();
    public void set_MergeArrayHandling(MergeArrayHandling value);
    public MergeNullValueHandling get_MergeNullValueHandling();
    public void set_MergeNullValueHandling(MergeNullValueHandling value);
    public StringComparison get_PropertyNameComparison();
    public void set_PropertyNameComparison(StringComparison value);
}
internal class Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    public Nullable`1<int> Index { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
    internal List`1<int> Indexes;
    public ArrayMultipleIndexFilter(List`1<int> indexes);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <End>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Step>k__BackingField;
    public Nullable`1<int> Start { get; public set; }
    public Nullable`1<int> End { get; public set; }
    public Nullable`1<int> Step { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(Nullable`1<int> value);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter/<ExecuteFilter>d__12")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
    private bool IsValid(int index, int stopIndex, bool positiveStep);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
    public object Left;
    [NullableAttribute("2")]
public object Right;
    public BooleanQueryExpression(QueryOperator operator, object left, object right);
    private IEnumerable`1<JToken> GetResult(JToken root, JToken t, object o);
    public virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
    private bool MatchTokens(JToken leftResult, JToken rightResult, JsonSelectSettings settings);
    private static bool RegexEquals(JValue input, JValue pattern, JsonSelectSettings settings);
    internal static bool EqualsWithStringCoercion(JValue value, JValue queryValue);
    internal static bool EqualsWithStrictMatch(JValue value, JValue queryValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
    [CompilerGeneratedAttribute]
private List`1<QueryExpression> <Expressions>k__BackingField;
    public List`1<QueryExpression> Expressions { get; public set; }
    public CompositeExpression(QueryOperator operator);
    [CompilerGeneratedAttribute]
public List`1<QueryExpression> get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(List`1<QueryExpression> value);
    public virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.FieldFilter : PathFilter {
    internal string Name;
    public FieldFilter(string name);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.FieldFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
    internal List`1<string> Names;
    public FieldMultipleFilter(List`1<string> names);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.JPath : object {
    private static Char[] FloatCharacters;
    private string _expression;
    [CompilerGeneratedAttribute]
private List`1<PathFilter> <Filters>k__BackingField;
    private int _currentIndex;
    public List`1<PathFilter> Filters { get; }
    public JPath(string expression);
    private static JPath();
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Filters();
    private void ParseMain();
    private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query);
    private static PathFilter CreatePathFilter(string member, bool scan);
    private PathFilter ParseIndexer(char indexerOpenChar, bool scan);
    private PathFilter ParseArrayIndexer(char indexerCloseChar);
    private void EatWhitespace();
    private PathFilter ParseQuery(char indexerCloseChar, bool scan);
    private bool TryParseExpression(List`1& expressionPath);
    private JsonException CreateUnexpectedCharacterException();
    private object ParseSide();
    private QueryExpression ParseExpression();
    [NullableContextAttribute("2")]
private bool TryParseValue(Object& value);
    private string ReadQuotedString();
    private string ReadRegexString();
    private bool Match(string s);
    private QueryOperator ParseOperator();
    private PathFilter ParseQuotedField(char indexerCloseChar, bool scan);
    private void EnsureLength(string message);
    internal IEnumerable`1<JToken> Evaluate(JToken root, JToken t, JsonSelectSettings settings);
    internal static IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken root, JToken t, JsonSelectSettings settings);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Linq.JsonPath.PathFilter : object {
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
    protected static JToken GetTokenIndex(JToken t, JsonSelectSettings settings, int index);
    protected static JToken GetNextScanValue(JToken originalParent, JToken container, JToken value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Linq.JsonPath.QueryExpression : object {
    internal QueryOperator Operator;
    public QueryExpression(QueryOperator operator);
    public bool IsMatch(JToken root, JToken t);
    public abstract virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.QueryFilter : PathFilter {
    internal QueryExpression Expression;
    public QueryFilter(QueryExpression expression);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.QueryFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal enum Newtonsoft.Json.Linq.JsonPath.QueryOperator : Enum {
    public int value__;
    public static QueryOperator None;
    public static QueryOperator Equals;
    public static QueryOperator NotEquals;
    public static QueryOperator Exists;
    public static QueryOperator LessThan;
    public static QueryOperator LessThanOrEquals;
    public static QueryOperator GreaterThan;
    public static QueryOperator GreaterThanOrEquals;
    public static QueryOperator And;
    public static QueryOperator Or;
    public static QueryOperator RegexEquals;
    public static QueryOperator StrictEquals;
    public static QueryOperator StrictNotEquals;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.QueryScanFilter : PathFilter {
    internal QueryExpression Expression;
    public QueryScanFilter(QueryExpression expression);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.QueryScanFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.RootFilter : PathFilter {
    public static RootFilter Instance;
    private static RootFilter();
    public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ScanFilter : PathFilter {
    internal string Name;
    public ScanFilter(string name);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ScanFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ScanMultipleFilter : PathFilter {
    private List`1<string> _names;
    public ScanMultipleFilter(List`1<string> names);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ScanMultipleFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
public class Newtonsoft.Json.Linq.JsonSelectSettings : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RegexMatchTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ErrorWhenNoMatch>k__BackingField;
    public Nullable`1<TimeSpan> RegexMatchTimeout { get; public set; }
    public bool ErrorWhenNoMatch { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RegexMatchTimeout();
    [CompilerGeneratedAttribute]
public void set_RegexMatchTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_ErrorWhenNoMatch();
    [CompilerGeneratedAttribute]
public void set_ErrorWhenNoMatch(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class Newtonsoft.Json.Linq.JToken : object {
    [NullableAttribute("2")]
private static JTokenEqualityComparer _equalityComparer;
    [NullableAttribute("2")]
private JContainer _parent;
    [NullableAttribute("2")]
private JToken _previous;
    [NullableAttribute("2")]
private JToken _next;
    [NullableAttribute("2")]
private object _annotations;
    private static JTokenType[] BooleanTypes;
    private static JTokenType[] NumberTypes;
    private static JTokenType[] BigIntegerTypes;
    private static JTokenType[] StringTypes;
    private static JTokenType[] GuidTypes;
    private static JTokenType[] TimeSpanTypes;
    private static JTokenType[] UriTypes;
    private static JTokenType[] CharTypes;
    private static JTokenType[] DateTimeTypes;
    private static JTokenType[] BytesTypes;
    public static JTokenEqualityComparer EqualityComparer { get; }
    [NullableAttribute("2")]
public JContainer Parent { get; internal set; }
    public JToken Root { get; }
    public JTokenType Type { get; }
    public bool HasValues { get; }
    [NullableAttribute("2")]
public JToken Next { get; internal set; }
    [NullableAttribute("2")]
public JToken Previous { get; internal set; }
    public string Path { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    [NullableAttribute("2")]
public JToken First { get; }
    [NullableAttribute("2")]
public JToken Last { get; }
    private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    private static JToken();
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public Task WriteToAsync(JsonWriter writer, JsonConverter[] converters);
    public static Task`1<JToken> ReadFromAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<ReadFromAsync>d__3")]
public static Task`1<JToken> ReadFromAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public static Task`1<JToken> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    public static Task`1<JToken> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public static JTokenEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public JContainer get_Parent();
    [NullableContextAttribute("2")]
internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken(JsonCloneSettings settings);
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    [NullableContextAttribute("2")]
public static bool DeepEquals(JToken t1, JToken t2);
    [NullableContextAttribute("2")]
public JToken get_Next();
    [NullableContextAttribute("2")]
internal void set_Next(JToken value);
    [NullableContextAttribute("2")]
public JToken get_Previous();
    [NullableContextAttribute("2")]
internal void set_Previous(JToken value);
    public string get_Path();
    [NullableContextAttribute("2")]
public void AddAfterSelf(object content);
    [NullableContextAttribute("2")]
public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AncestorsAndSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<GetAncestors>d__48")]
internal IEnumerable`1<JToken> GetAncestors(bool self);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<AfterSelf>d__49")]
public IEnumerable`1<JToken> AfterSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<BeforeSelf>d__50")]
public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    [NullableContextAttribute("2")]
public virtual T Value(object key);
    [NullableContextAttribute("2")]
public virtual JToken get_First();
    [NullableContextAttribute("2")]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    [NullableContextAttribute("0")]
public JEnumerable`1<T> Children();
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable);
    public static bool op_Explicit(JToken value);
    public static DateTimeOffset op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTime> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTimeOffset> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<decimal> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<double> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<char> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static short op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static char op_Explicit(JToken value);
    public static byte op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<int> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<short> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<byte> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<long> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Byte[] op_Explicit(JToken value);
    public static Guid op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<Guid> op_Explicit(JToken value);
    public static TimeSpan op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<TimeSpan> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Uri op_Explicit(JToken value);
    private static BigInteger ToBigInteger(JToken value);
    private static Nullable`1<BigInteger> ToBigIntegerNullable(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(DateTimeOffset value);
    public static JToken op_Implicit(byte value);
    public static JToken op_Implicit(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<sbyte> value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    public static JToken op_Implicit(Uri value);
    public static JToken op_Implicit(TimeSpan value);
    public static JToken op_Implicit(Nullable`1<TimeSpan> value);
    public static JToken op_Implicit(Guid value);
    public static JToken op_Implicit(Nullable`1<Guid> value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    [NullableContextAttribute("2")]
public T ToObject();
    public object ToObject(Type objectType);
    [NullableContextAttribute("2")]
public T ToObject(JsonSerializer jsonSerializer);
    [NullableContextAttribute("2")]
public object ToObject(Type objectType, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings);
    public static JToken Parse(string json);
    public static JToken Parse(string json, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader);
    [NullableContextAttribute("2")]
internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
    [NullableContextAttribute("2")]
public JToken SelectToken(string path, JsonSelectSettings settings);
    public IEnumerable`1<JToken> SelectTokens(string path);
    public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch);
    public IEnumerable`1<JToken> SelectTokens(string path, JsonSelectSettings settings);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private sealed virtual override object System.ICloneable.Clone();
    public JToken DeepClone();
    public JToken DeepClone(JsonCloneSettings settings);
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<Annotations>d__185`1")]
public IEnumerable`1<T> Annotations();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<Annotations>d__186")]
public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
    internal void CopyAnnotations(JToken target, JToken source);
}
public class Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(JToken x, JToken y);
    [NullableContextAttribute("1")]
public sealed virtual int GetHashCode(JToken obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JTokenReader : JsonReader {
    private JToken _root;
    [NullableAttribute("2")]
private string _initialPath;
    [NullableAttribute("2")]
private JToken _parent;
    [NullableAttribute("2")]
private JToken _current;
    [NullableAttribute("2")]
public JToken CurrentToken { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public string Path { get; }
    public JTokenReader(JToken token);
    public JTokenReader(JToken token, string initialPath);
    [NullableContextAttribute("2")]
public JToken get_CurrentToken();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    [NullableContextAttribute("2")]
private string SafeToString(object value);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public virtual string get_Path();
}
public enum Newtonsoft.Json.Linq.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
    private JContainer _token;
    private JContainer _parent;
    private JValue _value;
    private JToken _current;
    public JToken CurrentToken { get; }
    public JToken Token { get; }
    [NullableContextAttribute("1")]
public JTokenWriter(JContainer container);
    [NullableContextAttribute("1")]
internal virtual Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken);
    public JToken get_CurrentToken();
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    [NullableContextAttribute("1")]
private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    [NullableContextAttribute("1")]
public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    [NullableContextAttribute("1")]
public virtual void WritePropertyName(string name);
    private void AddRawValue(object value, JTokenType type, JsonToken token);
    internal void AddJValue(JValue value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Uri value);
    [NullableContextAttribute("1")]
internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JValue : JToken {
    private JTokenType _valueType;
    private object _value;
    public bool HasValues { get; }
    public JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    [NullableContextAttribute("1")]
internal JValue(JValue other, JsonCloneSettings settings);
    [NullableContextAttribute("1")]
public JValue(JValue other);
    public JValue(long value);
    public JValue(decimal value);
    public JValue(char value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(float value);
    public JValue(DateTime value);
    public JValue(DateTimeOffset value);
    public JValue(bool value);
    public JValue(string value);
    public JValue(Guid value);
    public JValue(Uri value);
    public JValue(TimeSpan value);
    public JValue(object value);
    [NullableContextAttribute("1")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    [NullableContextAttribute("1")]
internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    [NullableContextAttribute("1")]
private static int CompareBigInteger(BigInteger i1, object i2);
    internal static int Compare(JTokenType valueType, object objA, object objB);
    [NullableContextAttribute("1")]
private static int CompareFloat(object objA, object objB);
    private static bool Operation(ExpressionType operation, object objA, object objB, Object& result);
    [NullableContextAttribute("1")]
internal virtual JToken CloneToken(JsonCloneSettings settings);
    [NullableContextAttribute("1")]
public static JValue CreateComment(string value);
    [NullableContextAttribute("1")]
public static JValue CreateString(string value);
    [NullableContextAttribute("1")]
public static JValue CreateNull();
    [NullableContextAttribute("1")]
public static JValue CreateUndefined();
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    [NullableContextAttribute("1")]
public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    [NullableContextAttribute("1")]
private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
}
public enum Newtonsoft.Json.Linq.LineInfoHandling : Enum {
    public int value__;
    public static LineInfoHandling Ignore;
    public static LineInfoHandling Load;
}
public enum Newtonsoft.Json.Linq.MergeArrayHandling : Enum {
    public int value__;
    public static MergeArrayHandling Concat;
    public static MergeArrayHandling Union;
    public static MergeArrayHandling Replace;
    public static MergeArrayHandling Merge;
}
[FlagsAttribute]
public enum Newtonsoft.Json.Linq.MergeNullValueHandling : Enum {
    public int value__;
    public static MergeNullValueHandling Ignore;
    public static MergeNullValueHandling Merge;
}
internal enum Newtonsoft.Json.MemberSerialization : Enum {
    public int value__;
    public static MemberSerialization OptOut;
    public static MemberSerialization OptIn;
    public static MemberSerialization Fields;
}
public enum Newtonsoft.Json.MetadataPropertyHandling : Enum {
    public int value__;
    public static MetadataPropertyHandling Default;
    public static MetadataPropertyHandling ReadAhead;
    public static MetadataPropertyHandling Ignore;
}
public enum Newtonsoft.Json.MissingMemberHandling : Enum {
    public int value__;
    public static MissingMemberHandling Ignore;
    public static MissingMemberHandling Error;
}
public enum Newtonsoft.Json.NullValueHandling : Enum {
    public int value__;
    public static NullValueHandling Include;
    public static NullValueHandling Ignore;
}
public enum Newtonsoft.Json.ObjectCreationHandling : Enum {
    public int value__;
    public static ObjectCreationHandling Auto;
    public static ObjectCreationHandling Reuse;
    public static ObjectCreationHandling Replace;
}
[FlagsAttribute]
public enum Newtonsoft.Json.PreserveReferencesHandling : Enum {
    public int value__;
    public static PreserveReferencesHandling None;
    public static PreserveReferencesHandling Objects;
    public static PreserveReferencesHandling Arrays;
    public static PreserveReferencesHandling All;
}
internal enum Newtonsoft.Json.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsInt64;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDateTimeOffset;
    public static ReadType ReadAsDouble;
    public static ReadType ReadAsBoolean;
}
public enum Newtonsoft.Json.ReferenceLoopHandling : Enum {
    public int value__;
    public static ReferenceLoopHandling Error;
    public static ReferenceLoopHandling Ignore;
    public static ReferenceLoopHandling Serialize;
}
internal enum Newtonsoft.Json.Required : Enum {
    public int value__;
    public static Required Default;
    public static Required AllowNull;
    public static Required Always;
    public static Required DisallowNull;
}
[ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal static class Newtonsoft.Json.Schema.Extensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema, IList`1& errorMessages);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchema : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Transient>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Requires>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Disallow>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Extends>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    private string _internalId;
    [CompilerGeneratedAttribute]
private string <DeferredReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencesResolved>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public Nullable`1<bool> Required { get; public set; }
    public Nullable`1<bool> ReadOnly { get; public set; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Transient { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<JsonSchemaType> Type { get; public set; }
    public string Pattern { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public Nullable`1<bool> ExclusiveMinimum { get; public set; }
    public Nullable`1<bool> ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<JsonSchema> Items { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public JsonSchema AdditionalItems { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IDictionary`2<string, JsonSchema> Properties { get; public set; }
    public JsonSchema AdditionalProperties { get; public set; }
    public IDictionary`2<string, JsonSchema> PatternProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public string Requires { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public Nullable`1<JsonSchemaType> Disallow { get; public set; }
    public JToken Default { get; public set; }
    public IList`1<JsonSchema> Extends { get; public set; }
    public string Format { get; public set; }
    internal string Location { get; internal set; }
    internal string InternalId { get; }
    internal string DeferredReference { get; internal set; }
    internal bool ReferencesResolved { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Transient();
    [CompilerGeneratedAttribute]
public void set_Transient(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchema value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchema value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_Requires();
    [CompilerGeneratedAttribute]
public void set_Requires(string value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public JToken get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(JToken value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Extends();
    [CompilerGeneratedAttribute]
public void set_Extends(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
internal string get_Location();
    [CompilerGeneratedAttribute]
internal void set_Location(string value);
    internal string get_InternalId();
    [CompilerGeneratedAttribute]
internal string get_DeferredReference();
    [CompilerGeneratedAttribute]
internal void set_DeferredReference(string value);
    [CompilerGeneratedAttribute]
internal bool get_ReferencesResolved();
    [CompilerGeneratedAttribute]
internal void set_ReferencesResolved(bool value);
    public static JsonSchema Read(JsonReader reader);
    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver);
    public static JsonSchema Parse(string json);
    public static JsonSchema Parse(string json, JsonSchemaResolver resolver);
    public void WriteTo(JsonWriter writer);
    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver);
    public virtual string ToString();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaBuilder : object {
    private IList`1<JsonSchema> _stack;
    private JsonSchemaResolver _resolver;
    private IDictionary`2<string, JsonSchema> _documentSchemas;
    private JsonSchema _currentSchema;
    private JObject _rootSchema;
    private JsonSchema CurrentSchema { get; }
    public JsonSchemaBuilder(JsonSchemaResolver resolver);
    private void Push(JsonSchema value);
    private JsonSchema Pop();
    private JsonSchema get_CurrentSchema();
    internal JsonSchema Read(JsonReader reader);
    private string UnescapeReference(string reference);
    private JsonSchema ResolveReferences(JsonSchema schema);
    private JsonSchema BuildSchema(JToken token);
    private void ProcessSchemaProperties(JObject schemaObject);
    private void ProcessExtends(JToken token);
    private void ProcessEnum(JToken token);
    private void ProcessAdditionalProperties(JToken token);
    private void ProcessAdditionalItems(JToken token);
    private IDictionary`2<string, JsonSchema> ProcessProperties(JToken token);
    private void ProcessItems(JToken token);
    private Nullable`1<JsonSchemaType> ProcessType(JToken token);
    internal static JsonSchemaType MapType(string type);
    internal static string MapType(JsonSchemaType type);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal static class Newtonsoft.Json.Schema.JsonSchemaConstants : object {
    public static string TypePropertyName;
    public static string PropertiesPropertyName;
    public static string ItemsPropertyName;
    public static string AdditionalItemsPropertyName;
    public static string RequiredPropertyName;
    public static string PatternPropertiesPropertyName;
    public static string AdditionalPropertiesPropertyName;
    public static string RequiresPropertyName;
    public static string MinimumPropertyName;
    public static string MaximumPropertyName;
    public static string ExclusiveMinimumPropertyName;
    public static string ExclusiveMaximumPropertyName;
    public static string MinimumItemsPropertyName;
    public static string MaximumItemsPropertyName;
    public static string PatternPropertyName;
    public static string MaximumLengthPropertyName;
    public static string MinimumLengthPropertyName;
    public static string EnumPropertyName;
    public static string ReadOnlyPropertyName;
    public static string TitlePropertyName;
    public static string DescriptionPropertyName;
    public static string FormatPropertyName;
    public static string DefaultPropertyName;
    public static string TransientPropertyName;
    public static string DivisibleByPropertyName;
    public static string HiddenPropertyName;
    public static string DisallowPropertyName;
    public static string ExtendsPropertyName;
    public static string IdPropertyName;
    public static string UniqueItemsPropertyName;
    public static string OptionValuePropertyName;
    public static string OptionLabelPropertyName;
    public static IDictionary`2<string, JsonSchemaType> JsonSchemaTypeMapping;
    private static JsonSchemaConstants();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Path { get; }
    public JsonSchemaException(string message);
    public JsonSchemaException(string message, Exception innerException);
    public JsonSchemaException(SerializationInfo info, StreamingContext context);
    internal JsonSchemaException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
public string get_Path();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaGenerator : object {
    [CompilerGeneratedAttribute]
private UndefinedSchemaIdHandling <UndefinedSchemaIdHandling>k__BackingField;
    private IContractResolver _contractResolver;
    private JsonSchemaResolver _resolver;
    private IList`1<TypeSchema> _stack;
    private JsonSchema _currentSchema;
    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    private JsonSchema CurrentSchema { get; }
    [CompilerGeneratedAttribute]
public UndefinedSchemaIdHandling get_UndefinedSchemaIdHandling();
    [CompilerGeneratedAttribute]
public void set_UndefinedSchemaIdHandling(UndefinedSchemaIdHandling value);
    public IContractResolver get_ContractResolver();
    public void set_ContractResolver(IContractResolver value);
    private JsonSchema get_CurrentSchema();
    private void Push(TypeSchema typeSchema);
    private TypeSchema Pop();
    public JsonSchema Generate(Type type);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver);
    public JsonSchema Generate(Type type, bool rootSchemaNullable);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable);
    private string GetTitle(Type type);
    private string GetDescription(Type type);
    private string GetTypeId(Type type, bool explicitOnly);
    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required);
    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private void GenerateObjectSchema(Type type, JsonObjectContract contract);
    private void GenerateISerializableContract(Type type, JsonISerializableContract contract);
    internal static bool HasFlag(Nullable`1<JsonSchemaType> value, JsonSchemaType flag);
    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaModel : object {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchemaModel> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Disallow>k__BackingField;
    public bool Required { get; public set; }
    public JsonSchemaType Type { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public bool ExclusiveMinimum { get; public set; }
    public bool ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<string> Patterns { get; public set; }
    public IList`1<JsonSchemaModel> Items { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> Properties { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> PatternProperties { get; public set; }
    public JsonSchemaModel AdditionalProperties { get; public set; }
    public JsonSchemaModel AdditionalItems { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public JsonSchemaType Disallow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(JsonSchemaType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Patterns();
    [CompilerGeneratedAttribute]
public void set_Patterns(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchemaModel> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(JsonSchemaType value);
    public static JsonSchemaModel Create(IList`1<JsonSchema> schemata);
    private static void Combine(JsonSchemaModel model, JsonSchema schema);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaModelBuilder : object {
    private JsonSchemaNodeCollection _nodes;
    private Dictionary`2<JsonSchemaNode, JsonSchemaModel> _nodeModels;
    private JsonSchemaNode _node;
    public JsonSchemaModel Build(JsonSchema schema);
    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema);
    public void AddProperties(IDictionary`2<string, JsonSchema> source, IDictionary`2<string, JsonSchemaNode> target);
    public void AddProperty(IDictionary`2<string, JsonSchemaNode> target, string propertyName, JsonSchema schema);
    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema);
    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema);
    public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema);
    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaNode : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<JsonSchema> <Schemas>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JsonSchemaNode> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalItems>k__BackingField;
    public string Id { get; }
    public ReadOnlyCollection`1<JsonSchema> Schemas { get; }
    public Dictionary`2<string, JsonSchemaNode> Properties { get; }
    public Dictionary`2<string, JsonSchemaNode> PatternProperties { get; }
    public List`1<JsonSchemaNode> Items { get; }
    public JsonSchemaNode AdditionalProperties { get; public set; }
    public JsonSchemaNode AdditionalItems { get; public set; }
    public JsonSchemaNode(JsonSchema schema);
    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<JsonSchema> get_Schemas();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_Properties();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_PatternProperties();
    [CompilerGeneratedAttribute]
public List`1<JsonSchemaNode> get_Items();
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaNode value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaNode value);
    public JsonSchemaNode Combine(JsonSchema schema);
    public static string GetId(IEnumerable`1<JsonSchema> schemata);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaNodeCollection : KeyedCollection`2<string, JsonSchemaNode> {
    protected virtual string GetKeyForItem(JsonSchemaNode item);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaResolver : object {
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <LoadedSchemas>k__BackingField;
    public IList`1<JsonSchema> LoadedSchemas { get; protected set; }
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_LoadedSchemas();
    [CompilerGeneratedAttribute]
protected void set_LoadedSchemas(IList`1<JsonSchema> value);
    public virtual JsonSchema GetSchema(string reference);
}
[FlagsAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal enum Newtonsoft.Json.Schema.JsonSchemaType : Enum {
    public int value__;
    public static JsonSchemaType None;
    public static JsonSchemaType String;
    public static JsonSchemaType Float;
    public static JsonSchemaType Integer;
    public static JsonSchemaType Boolean;
    public static JsonSchemaType Object;
    public static JsonSchemaType Array;
    public static JsonSchemaType Null;
    public static JsonSchemaType Any;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaWriter : object {
    private JsonWriter _writer;
    private JsonSchemaResolver _resolver;
    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver);
    private void ReferenceOrWriteSchema(JsonSchema schema);
    public void WriteSchema(JsonSchema schema);
    private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary`2<string, JsonSchema> properties);
    private void WriteItems(JsonSchema schema);
    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type);
    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal enum Newtonsoft.Json.Schema.UndefinedSchemaIdHandling : Enum {
    public int value__;
    public static UndefinedSchemaIdHandling None;
    public static UndefinedSchemaIdHandling UseTypeName;
    public static UndefinedSchemaIdHandling UseAssemblyQualifiedName;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.ValidationEventArgs : EventArgs {
    private JsonSchemaException _ex;
    public JsonSchemaException Exception { get; }
    public string Path { get; }
    public string Message { get; }
    internal ValidationEventArgs(JsonSchemaException ex);
    public JsonSchemaException get_Exception();
    public string get_Path();
    public string get_Message();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.ValidationEventHandler : MulticastDelegate {
    public ValidationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<object, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    [NullableContextAttribute("1")]
public static T GetAttribute(object type);
}
internal class Newtonsoft.Json.Serialization.CamelCaseNamingStrategy : NamingStrategy {
    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    private static object TypeContractCacheLock;
    private static DefaultJsonNameTable NameTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<StructMultiKey`2<Type, Type>, JsonContract> _contractCache;
    private static CamelCasePropertyNamesContractResolver();
    public virtual JsonContract ResolveContract(Type type);
    internal virtual DefaultJsonNameTable GetNameTable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DefaultContractResolver : object {
    private static IContractResolver _instance;
    private static String[] BlacklistedTypeNames;
    private static JsonConverter[] BuiltInConverters;
    private DefaultJsonNameTable _nameTable;
    private ThreadSafeStore`2<Type, JsonContract> _contractCache;
    [CompilerGeneratedAttribute]
private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreIsSpecifiedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreShouldSerializeMembers>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategy>k__BackingField;
    internal static IContractResolver Instance { get; }
    public bool DynamicCodeGeneration { get; }
    [ObsoleteAttribute("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
public BindingFlags DefaultMembersSearchFlags { get; public set; }
    public bool SerializeCompilerGeneratedMembers { get; public set; }
    public bool IgnoreSerializableInterface { get; public set; }
    public bool IgnoreSerializableAttribute { get; public set; }
    public bool IgnoreIsSpecifiedMembers { get; public set; }
    public bool IgnoreShouldSerializeMembers { get; public set; }
    [NullableAttribute("2")]
public NamingStrategy NamingStrategy { get; public set; }
    private static DefaultContractResolver();
    internal static IContractResolver get_Instance();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableInterface();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableAttribute();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreIsSpecifiedMembers();
    [CompilerGeneratedAttribute]
public void set_IgnoreIsSpecifiedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreShouldSerializeMembers();
    [CompilerGeneratedAttribute]
public void set_IgnoreShouldSerializeMembers(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NamingStrategy get_NamingStrategy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NamingStrategy(NamingStrategy value);
    public virtual JsonContract ResolveContract(Type type);
    private static bool FilterMembers(MemberInfo member);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private static void ThrowUnableToSerializeError(object o, StreamingContext context);
    private MemberInfo GetExtensionDataMemberForType(Type type);
    private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member);
    private ConstructorInfo GetAttributeConstructor(Type objectType);
    private ConstructorInfo GetImmutableConstructor(Type objectType, JsonPropertyCollection memberProperties);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    protected virtual IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    private JsonProperty MatchProperty(JsonPropertyCollection properties, string name, Type type);
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    private void InitializeContract(JsonContract contract);
    private void ResolveCallbackMethods(JsonContract contract, Type t);
    private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError);
    private static bool IsConcurrentOrObservableCollection(Type t);
    private static bool ShouldSkipDeserialized(Type t);
    private static bool ShouldSkipSerializing(Type t);
    private List`1<Type> GetClassHierarchyForType(Type type);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonDynamicContract CreateDynamicContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool IsJsonPrimitiveType(Type t);
    internal static bool IsIConvertible(Type t);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    internal virtual DefaultJsonNameTable GetNameTable();
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess);
    protected virtual string ResolvePropertyName(string propertyName);
    protected virtual string ResolveExtensionDataName(string extensionDataName);
    protected virtual string ResolveDictionaryKey(string dictionaryKey);
    public string GetResolvedPropertyName(string propertyName);
}
internal class Newtonsoft.Json.Serialization.DefaultNamingStrategy : NamingStrategy {
    [NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
    private int _referenceCount;
    private BidirectionalDictionary`2<string, object> GetMappings(object context);
    public sealed virtual object ResolveReference(object context, string reference);
    public sealed virtual string GetReference(object context, object value);
    public sealed virtual void AddReference(object context, string reference, object value);
    public sealed virtual bool IsReferenced(object context, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    internal static DefaultSerializationBinder Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadSafeStore`2<StructMultiKey`2<string, string>, Type> _typeCache;
    private static DefaultSerializationBinder();
    private Type GetTypeFromTypeNameKey(StructMultiKey`2<string, string> typeNameKey);
    private Type GetGenericTypeFromTypeName(string typeName, Assembly assembly);
    private Type GetTypeByName(StructMultiKey`2<string, string> typeNameKey);
    public virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
internal class Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    private TraceEventType GetTraceEventType(TraceLevel level);
    [NullableContextAttribute("1")]
public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DynamicValueProvider : object {
    private MemberInfo _memberInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _getter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _setter;
    public DynamicValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]
private bool <Traced>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <OriginalObject>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    internal bool Traced { get; internal set; }
    public Exception Error { get; }
    [NullableAttribute("2")]
public object OriginalObject { get; }
    [NullableAttribute("2")]
public object Member { get; }
    public string Path { get; }
    public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, string path, Exception error);
    [CompilerGeneratedAttribute]
internal bool get_Traced();
    [CompilerGeneratedAttribute]
internal void set_Traced(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_OriginalObject();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorContext <ErrorContext>k__BackingField;
    [NullableAttribute("2")]
public object CurrentObject { get; }
    public ErrorContext ErrorContext { get; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.ExpressionValueProvider : object {
    private MemberInfo _memberInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _getter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _setter;
    public ExpressionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Newtonsoft.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
    public ExtensionDataGetter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
    public ExtensionDataSetter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object o, string key, object value);
    public virtual IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Serialization.IAttributeProvider {
    public abstract virtual IList`1<Attribute> GetAttributes(bool inherit);
    public abstract virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(object context, string reference);
    public abstract virtual string GetReference(object context, object value);
    public abstract virtual bool IsReferenced(object context, object value);
    public abstract virtual void AddReference(object context, string reference, object value);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.ISerializationBinder {
    public abstract virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public abstract virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.ITraceWriter {
    public TraceLevel LevelFilter { get; }
    public abstract virtual TraceLevel get_LevelFilter();
    public abstract virtual void Trace(TraceLevel level, string message, Exception ex);
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private Type <CollectionItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultidimensionalArray>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _genericWrapperCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _genericTemporaryCollectionCreator;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    public Type CollectionItemType { get; }
    public bool IsMultidimensionalArray { get; }
    internal bool IsArray { get; }
    internal bool ShouldCreateWrapper { get; }
    internal bool CanDeserialize { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    [NullableContextAttribute("1")]
public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensionalArray();
    [CompilerGeneratedAttribute]
internal bool get_IsArray();
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    [NullableContextAttribute("1")]
internal IWrappedCollection CreateWrapper(object list);
    [NullableContextAttribute("1")]
internal IList CreateTemporaryCollection();
    [NullableContextAttribute("1")]
private void StoreFSharpListCreatorIfNecessary(Type underlyingType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
    private JsonContract _itemContract;
    private JsonContract _finalItemContract;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContract FinalItemContract { get; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    [NullableContextAttribute("1")]
internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
    internal JsonContract get_FinalItemContract();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Serialization.JsonContract : object {
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onDeserializedCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onDeserializingCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onSerializedCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onSerializingCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationErrorCallback> _onErrorCallbacks;
    private Type _createdType;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonConverter <InternalConverter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCreatorNonPublic>k__BackingField;
    public Type UnderlyingType { get; }
    public Type CreatedType { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    [NullableAttribute("2")]
public JsonConverter Converter { get; public set; }
    [NullableAttribute("2")]
public JsonConverter InternalConverter { get; internal set; }
    public IList`1<SerializationCallback> OnDeserializedCallbacks { get; }
    public IList`1<SerializationCallback> OnDeserializingCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializedCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializingCallbacks { get; }
    public IList`1<SerializationErrorCallback> OnErrorCallbacks { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<object> DefaultCreator { get; public set; }
    public bool DefaultCreatorNonPublic { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonConverter get_InternalConverter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    public IList`1<SerializationCallback> get_OnDeserializedCallbacks();
    public IList`1<SerializationCallback> get_OnDeserializingCallbacks();
    public IList`1<SerializationCallback> get_OnSerializedCallbacks();
    public IList`1<SerializationCallback> get_OnSerializingCallbacks();
    public IList`1<SerializationErrorCallback> get_OnErrorCallbacks();
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo);
    internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo);
}
internal enum Newtonsoft.Json.Serialization.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <DictionaryKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _genericWrapperCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _genericTemporaryDictionaryCreator;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> DictionaryKeyResolver { get; public set; }
    public Type DictionaryKeyType { get; }
    public Type DictionaryValueType { get; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    [NullableContextAttribute("1")]
public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_DictionaryKeyResolver();
    [CompilerGeneratedAttribute]
public void set_DictionaryKeyResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    [NullableContextAttribute("1")]
internal IWrappedDictionary CreateWrapper(object dictionary);
    [NullableContextAttribute("1")]
internal IDictionary CreateTemporaryDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonDynamicContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <PropertyNameResolver>k__BackingField;
    private ThreadSafeStore`2<string, CallSite`1<Func`3<CallSite, object, object>>> _callSiteGetters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadSafeStore`2<string, CallSite`1<Func`4<CallSite, object, object, object>>> _callSiteSetters;
    public JsonPropertyCollection Properties { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> PropertyNameResolver { get; public set; }
    public JsonDynamicContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_PropertyNameResolver();
    [CompilerGeneratedAttribute]
public void set_PropertyNameResolver(Func`2<string, string> value);
    private static CallSite`1<Func`3<CallSite, object, object>> CreateCallSiteGetter(string name);
    private static CallSite`1<Func`4<CallSite, object, object, object>> CreateCallSiteSetter(string name);
    internal bool TryGetMember(IDynamicMetaObjectProvider dynamicProvider, string name, Object& value);
    internal bool TrySetMember(IDynamicMetaObjectProvider dynamicProvider, string name, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
    private JsonSerializerInternalReader _reader;
    private JsonISerializableContract _contract;
    [NullableAttribute("2")]
private JsonProperty _member;
    public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
internal class Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    [NullableContextAttribute("1")]
public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
internal class Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
    [NullableContextAttribute("1")]
public JsonLinqContract(Type underlyingType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MissingMemberHandling> <MissingMemberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Required> <ItemRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <ItemNullValueHandling>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataGetter <ExtensionDataGetter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <ExtensionDataNameResolver>k__BackingField;
    internal bool ExtensionDataIsJToken;
    private Nullable`1<bool> _hasRequiredOrDefaultValueProperties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    private JsonPropertyCollection _creatorParameters;
    private Type _extensionDataValueType;
    public MemberSerialization MemberSerialization { get; public set; }
    public Nullable`1<MissingMemberHandling> MissingMemberHandling { get; public set; }
    public Nullable`1<Required> ItemRequired { get; public set; }
    public Nullable`1<NullValueHandling> ItemNullValueHandling { get; public set; }
    [NullableAttribute("1")]
public JsonPropertyCollection Properties { get; }
    [NullableAttribute("1")]
public JsonPropertyCollection CreatorParameters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; internal set; }
    public ExtensionDataSetter ExtensionDataSetter { get; public set; }
    public ExtensionDataGetter ExtensionDataGetter { get; public set; }
    public Type ExtensionDataValueType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> ExtensionDataNameResolver { get; public set; }
    internal bool HasRequiredOrDefaultValueProperties { get; }
    [NullableContextAttribute("1")]
public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public Nullable`1<MissingMemberHandling> get_MissingMemberHandling();
    [CompilerGeneratedAttribute]
public void set_MissingMemberHandling(Nullable`1<MissingMemberHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Required> get_ItemRequired();
    [CompilerGeneratedAttribute]
public void set_ItemRequired(Nullable`1<Required> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_ItemNullValueHandling();
    [CompilerGeneratedAttribute]
public void set_ItemNullValueHandling(Nullable`1<NullValueHandling> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [NullableContextAttribute("1")]
public JsonPropertyCollection get_CreatorParameters();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    internal void set_ParameterizedCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public ExtensionDataSetter get_ExtensionDataSetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataSetter(ExtensionDataSetter value);
    [CompilerGeneratedAttribute]
public ExtensionDataGetter get_ExtensionDataGetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataGetter(ExtensionDataGetter value);
    public Type get_ExtensionDataValueType();
    public void set_ExtensionDataValueType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_ExtensionDataNameResolver();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataNameResolver(Func`2<string, string> value);
    internal bool get_HasRequiredOrDefaultValueProperties();
    [NullableContextAttribute("1")]
[SecuritySafeCriticalAttribute]
internal object GetUninitializedObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    private static Dictionary`2<Type, ReadType> ReadTypeMap;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonProperty : object {
    internal Nullable`1<Required> _required;
    internal bool _hasExplicitDefaultValue;
    private object _defaultValue;
    private bool _hasGeneratedDefaultValue;
    private string _propertyName;
    internal bool _skipPropertyNameEscape;
    private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnderlyingName>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IAttributeProvider <AttributeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldSerialize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldDeserialize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <GetIsSpecified>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <SetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Type DeclaringType { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public string UnderlyingName { get; public set; }
    public IValueProvider ValueProvider { get; public set; }
    public IAttributeProvider AttributeProvider { get; public set; }
    public Type PropertyType { get; public set; }
    public JsonConverter Converter { get; public set; }
    [ObsoleteAttribute("MemberConverter is obsolete. Use Converter instead.")]
public JsonConverter MemberConverter { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    public object DefaultValue { get; public set; }
    public Required Required { get; public set; }
    public bool IsRequiredSpecified { get; }
    public Nullable`1<bool> IsReference { get; public set; }
    public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> ShouldSerialize { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> ShouldDeserialize { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> GetIsSpecified { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> SetIsSpecified { get; public set; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UnderlyingName();
    [CompilerGeneratedAttribute]
public void set_UnderlyingName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public IAttributeProvider get_AttributeProvider();
    [CompilerGeneratedAttribute]
public void set_AttributeProvider(IAttributeProvider value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    public JsonConverter get_MemberConverter();
    public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetResolvedDefaultValue();
    public Required get_Required();
    public void set_Required(Required value);
    public bool get_IsRequiredSpecified();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
public void set_ShouldDeserialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_GetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_GetIsSpecified(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_SetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_SetIsSpecified(Action`2<object, object> value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [NullableContextAttribute("1")]
internal void WritePropertyName(JsonWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetProperty(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
    [NullableAttribute("2")]
private ErrorContext _currentErrorContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BidirectionalDictionary`2<string, object> _mappings;
    internal JsonSerializer Serializer;
    [NullableAttribute("2")]
internal ITraceWriter TraceWriter;
    [NullableAttribute("2")]
protected JsonSerializerProxy InternalSerializer;
    internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings { get; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings();
    protected NullValueHandling ResolvedNullValueHandling(JsonObjectContract containerContract, JsonProperty property);
    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error);
    protected void ClearErrorContext();
    [NullableContextAttribute("2")]
protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    [NullableContextAttribute("2")]
private JsonContract GetContractSafe(Type type);
    private JsonContract GetContract(Type type);
    [NullableContextAttribute("2")]
public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent);
    private JsonSerializerProxy GetInternalSerializer();
    [NullableContextAttribute("2")]
private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    [NullableContextAttribute("2")]
private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    [NullableContextAttribute("2")]
private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    [NullableContextAttribute("2")]
private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    [NullableContextAttribute("2")]
private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    [NullableContextAttribute("2")]
private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    [NullableContextAttribute("2")]
private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName);
    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract);
    [NullableContextAttribute("2")]
private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id);
    [NullableContextAttribute("2")]
private bool HasNoDefinedType(JsonContract contract);
    [NullableContextAttribute("2")]
private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target);
    [NullableContextAttribute("2")]
private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue, Boolean& ignoredValue);
    private void AddReference(JsonReader reader, string id, object value);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    [NullableContextAttribute("2")]
private bool ShouldSetPropertyValue(JsonProperty property, JsonObjectContract contract, object value);
    private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator);
    private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator);
    private void OnDeserializing(JsonReader reader, JsonContract contract, object value);
    private void OnDeserialized(JsonReader reader, JsonContract contract, object value);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id);
    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message);
    private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id);
    internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member);
    private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, JsonProperty member, string id);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id);
    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue);
    private List`1<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id);
    private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target);
    private bool CheckPropertyName(JsonReader reader, string memberName);
    private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o);
    private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader);
    private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue);
    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties);
    private void HandleError(JsonReader reader, bool readPastError, int initialDepth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    [NullableAttribute("2")]
private Type _rootType;
    private int _rootLevel;
    private List`1<object> _serializeStack;
    public JsonSerializerInternalWriter(JsonSerializer serializer);
    [NullableContextAttribute("2")]
public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    [NullableContextAttribute("2")]
private JsonContract GetContractSafe(object value);
    private JsonContract GetContract(object value);
    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteProperty(object memberValue, JsonObjectContract containerContract, JsonProperty property);
    [NullableContextAttribute("2")]
private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void WriteReference(JsonWriter writer, object value);
    private string GetReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void OnSerializing(JsonWriter writer, JsonContract contract, object value);
    private void OnSerialized(JsonWriter writer, JsonContract contract, object value);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue);
    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool HasCreatorParameter(JsonContainerContract contract, JsonProperty property);
    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices);
    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [SecuritySafeCriticalAttribute]
private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeDynamic(JsonWriter writer, IDynamicMetaObjectProvider value, JsonDynamicContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteDynamicProperty(object memberValue);
    [NullableContextAttribute("2")]
private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target);
    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    [NullableAttribute("2")]
private JsonSerializerInternalReader _serializerReader;
    [NullableAttribute("2")]
private JsonSerializerInternalWriter _serializerWriter;
    internal JsonSerializer _serializer;
    [NullableAttribute("2")]
public IReferenceResolver ReferenceResolver { get; public set; }
    [NullableAttribute("2")]
public ITraceWriter TraceWriter { get; public set; }
    [NullableAttribute("2")]
public IEqualityComparer EqualityComparer { get; public set; }
    public JsonConverterCollection Converters { get; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [NullableContextAttribute("2")]
public virtual IReferenceResolver get_ReferenceResolver();
    [NullableContextAttribute("2")]
public virtual void set_ReferenceResolver(IReferenceResolver value);
    [NullableContextAttribute("2")]
public virtual ITraceWriter get_TraceWriter();
    [NullableContextAttribute("2")]
public virtual void set_TraceWriter(ITraceWriter value);
    [NullableContextAttribute("2")]
public virtual IEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public virtual void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ISerializationBinder get_SerializationBinder();
    public virtual void set_SerializationBinder(ISerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal JsonSerializerInternalBase GetInternalSerializer();
    [NullableContextAttribute("2")]
internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    [NullableContextAttribute("2")]
internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType);
}
internal class Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
    [NullableContextAttribute("1")]
public JsonStringContract(Type underlyingType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Serialization.JsonTypeReflector : object {
    private static Nullable`1<bool> _dynamicCodeGeneration;
    private static Nullable`1<bool> _fullyTrusted;
    public static string IdPropertyName;
    public static string RefPropertyName;
    public static string TypePropertyName;
    public static string ValuePropertyName;
    public static string ArrayValuesPropertyName;
    public static string ShouldSerializePrefix;
    public static string SpecifiedPostfix;
    public static string ConcurrentDictionaryTypeName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Func`2<Object[], object>> CreatorCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    [NullableAttribute("2")]
private static ReflectionObject _metadataTypeAttributeReflectionObject;
    public static bool DynamicCodeGeneration { get; }
    public static bool FullyTrusted { get; }
    public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static T GetCachedAttribute(object attributeProvider);
    public static bool CanTypeDescriptorConvertString(Type type, TypeConverter& typeConverter);
    public static DataContractAttribute GetDataContractAttribute(Type type);
    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute);
    public static JsonConverter GetJsonConverter(object attributeProvider);
    public static JsonConverter CreateJsonConverterInstance(Type converterType, Object[] args);
    public static NamingStrategy CreateNamingStrategyInstance(Type namingStrategyType, Object[] args);
    public static NamingStrategy GetContainerNamingStrategy(JsonContainerAttribute containerAttribute);
    private static Func`2<Object[], object> GetCreator(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    private static T GetAttribute(Type type);
    private static T GetAttribute(MemberInfo memberInfo);
    public static bool IsNonSerializable(object provider);
    public static bool IsSerializable(object provider);
    public static T GetAttribute(object provider);
    [SecuritySafeCriticalAttribute]
public static bool get_DynamicCodeGeneration();
    public static bool get_FullyTrusted();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
internal class Newtonsoft.Json.Serialization.KebabCaseNamingStrategy : NamingStrategy {
    public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
    private Queue`1<string> _traceMessages;
    private object _lock;
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    public IEnumerable`1<string> GetTraceMessages();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Serialization.NamingStrategy : object {
    [CompilerGeneratedAttribute]
private bool <ProcessDictionaryKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessExtensionDataNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverrideSpecifiedNames>k__BackingField;
    public bool ProcessDictionaryKeys { get; public set; }
    public bool ProcessExtensionDataNames { get; public set; }
    public bool OverrideSpecifiedNames { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ProcessDictionaryKeys();
    [CompilerGeneratedAttribute]
public void set_ProcessDictionaryKeys(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProcessExtensionDataNames();
    [CompilerGeneratedAttribute]
public void set_ProcessExtensionDataNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_OverrideSpecifiedNames();
    [CompilerGeneratedAttribute]
public void set_OverrideSpecifiedNames(bool value);
    public virtual string GetPropertyName(string name, bool hasSpecifiedName);
    public virtual string GetExtensionDataName(string name);
    public virtual string GetDictionaryKey(string key);
    protected abstract virtual string ResolvePropertyName(string name);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
protected bool Equals(NamingStrategy other);
}
internal class Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
internal class Newtonsoft.Json.Serialization.OnErrorAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.ReflectionAttributeProvider : object {
    private object _attributeProvider;
    public ReflectionAttributeProvider(object attributeProvider);
    public sealed virtual IList`1<Attribute> GetAttributes(bool inherit);
    public sealed virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
    private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.SerializationBinderAdapter : object {
    public SerializationBinder SerializationBinder;
    public SerializationBinderAdapter(SerializationBinder serializationBinder);
    public sealed virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public sealed virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
public class Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
    public SerializationCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object o, StreamingContext context);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
    public SerializationErrorCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object o, StreamingContext context, ErrorContext errorContext);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Serialization.SnakeCaseNamingStrategy : NamingStrategy {
    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
    private JsonReader _innerReader;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    [NullableAttribute("2")]
public Type ValueType { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public TraceJsonReader(JsonReader innerReader);
    public string GetDeserializedJsonMessage();
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    [NullableContextAttribute("2")]
public virtual string ReadAsString();
    [NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public void WriteCurrentToken();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    [NullableContextAttribute("2")]
public virtual object get_Value();
    [NullableContextAttribute("2")]
public virtual Type get_ValueType();
    public virtual void Close();
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
    private JsonWriter _innerWriter;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public TraceJsonWriter(JsonWriter innerWriter);
    public string GetSerializedJsonMessage();
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Nullable`1<char> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteUndefined();
    public virtual void WriteNull();
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(Nullable`1<int> value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(Nullable`1<long> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(Nullable`1<short> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Nullable`1<ulong> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteWhitespace(string ws);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    [NullableContextAttribute("2")]
public virtual void WriteRawValue(string json);
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    public virtual void Close();
    public virtual void Flush();
}
public enum Newtonsoft.Json.StringEscapeHandling : Enum {
    public int value__;
    public static StringEscapeHandling Default;
    public static StringEscapeHandling EscapeNonAscii;
    public static StringEscapeHandling EscapeHtml;
}
public enum Newtonsoft.Json.TypeNameAssemblyFormatHandling : Enum {
    public int value__;
    public static TypeNameAssemblyFormatHandling Simple;
    public static TypeNameAssemblyFormatHandling Full;
}
[FlagsAttribute]
public enum Newtonsoft.Json.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Arrays;
    public static TypeNameHandling All;
    public static TypeNameHandling Auto;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.AsyncUtils : object {
    public static Task`1<bool> False;
    public static Task`1<bool> True;
    internal static Task CompletedTask;
    private static AsyncUtils();
    [ExtensionAttribute]
internal static Task`1<bool> ToAsync(bool value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task CancelIfRequestedAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<T> CancelIfRequestedAsync(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task FromCanceled(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> FromCanceled(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, char value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, string value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, Char[] value, int start, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> ReadAsync(TextReader reader, Char[] buffer, int index, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsCompletedSuccessfully(Task task);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.Base64Encoder : object {
    private static int Base64LineSize;
    private static int LineSizeInBytes;
    private Char[] _charsLine;
    private TextWriter _writer;
    [NullableAttribute("2")]
private Byte[] _leftOverBytes;
    private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    private void ValidateEncode(Byte[] buffer, int index, int count);
    public void Encode(Byte[] buffer, int index, int count);
    private void StoreLeftOverBytes(Byte[] buffer, int index, Int32& count);
    private bool FulfillFromLeftover(Byte[] buffer, int index, Int32& count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.Base64Encoder/<EncodeAsync>d__13")]
public Task EncodeAsync(Byte[] buffer, int index, int count, CancellationToken cancellationToken);
    private Task WriteCharsAsync(Char[] chars, int index, int count, CancellationToken cancellationToken);
    public Task FlushAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> _firstToSecond;
    private IDictionary`2<TSecond, TFirst> _secondToFirst;
    private string _duplicateFirstErrorMessage;
    private string _duplicateSecondErrorMessage;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage);
    public void Set(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.BoxedPrimitives : object {
    internal static object BooleanTrue;
    internal static object BooleanFalse;
    internal static object Int32_M1;
    internal static object Int32_0;
    internal static object Int32_1;
    internal static object Int32_2;
    internal static object Int32_3;
    internal static object Int32_4;
    internal static object Int32_5;
    internal static object Int32_6;
    internal static object Int32_7;
    internal static object Int32_8;
    internal static object Int64_M1;
    internal static object Int64_0;
    internal static object Int64_1;
    internal static object Int64_2;
    internal static object Int64_3;
    internal static object Int64_4;
    internal static object Int64_5;
    internal static object Int64_6;
    internal static object Int64_7;
    internal static object Int64_8;
    internal static object DoubleNaN;
    internal static object DoublePositiveInfinity;
    internal static object DoubleNegativeInfinity;
    internal static object DoubleZero;
    internal static object DoubleNegativeZero;
    private static BoxedPrimitives();
    internal static object Get(bool value);
    internal static object Get(int value);
    internal static object Get(long value);
    internal static object Get(decimal value);
    internal static object Get(double value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.BufferUtils : object {
    [NullableContextAttribute("1")]
public static Char[] RentBuffer(IArrayPool`1<char> bufferPool, int minSize);
    public static void ReturnBuffer(IArrayPool`1<char> bufferPool, Char[] buffer);
    public static Char[] EnsureBufferSize(IArrayPool`1<char> bufferPool, int size, Char[] buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.CollectionUtils : object {
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    public static bool IsDictionaryType(Type type);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(List`1<T> list, T value, IEqualityComparer comparer);
    [ExtensionAttribute]
public static int IndexOfReference(List`1<T> list, T item);
    [ExtensionAttribute]
public static void FastReverse(List`1<T> list);
    private static IList`1<int> GetDimensions(IList values, int dimensionsCount);
    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices);
    private static object JaggedArrayGetValue(IList values, Int32[] indices);
    public static Array ToMultidimensionalArray(IList values, Type type, int rank);
    public static T[] ArrayEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
    [NullableAttribute("2")]
private IList _list;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<T> _genericCollection;
    [NullableAttribute("2")]
private object _syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [NullableContextAttribute("2")]
private static void VerifyValueType(object value);
    [NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.ConvertUtils : object {
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static TypeInformation[] PrimitiveTypeCodes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, Type>, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static TypeInformation GetTypeInformation(IConvertible convertable);
    public static bool IsConvertible(Type t);
    public static TimeSpan ParseTimeSpan(string input);
    [NullableContextAttribute("2")]
private static Func`2<object, object> CreateCastConverter(StructMultiKey`2<Type, Type> t);
    internal static BigInteger ToBigInteger(object value);
    public static object FromBigInteger(BigInteger i, Type targetType);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value);
    private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    public static bool VersionTryParse(string input, Version& result);
    public static bool IsInteger(object value);
    public static ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value);
    public static ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value);
    public static ParseResult DecimalTryParse(Char[] chars, int start, int length, Decimal& value);
    public static bool TryConvertGuid(string s, Guid& g);
    public static bool TryHexTextToInt(Char[] text, int start, int end, Int32& value);
}
internal class Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
    public int Year;
    public int Month;
    public int Day;
    public int Hour;
    public int Minute;
    public int Second;
    public int Fraction;
    public int ZoneHour;
    public int ZoneMinute;
    public ParserTimeZone Zone;
    private Char[] _text;
    private int _end;
    private static Int32[] Power10;
    private static int Lzyyyy;
    private static int Lzyyyy_;
    private static int Lzyyyy_MM;
    private static int Lzyyyy_MM_;
    private static int Lzyyyy_MM_dd;
    private static int Lzyyyy_MM_ddT;
    private static int LzHH;
    private static int LzHH_;
    private static int LzHH_mm;
    private static int LzHH_mm_;
    private static int LzHH_mm_ss;
    private static int Lz_;
    private static int Lz_zz;
    private static short MaxFractionDigits;
    private static DateTimeParser();
    public bool Parse(Char[] text, int startIndex, int length);
    private bool ParseDate(int start);
    private bool ParseTimeAndZoneAndWhitespace(int start);
    private bool ParseTime(Int32& start);
    private bool ParseZone(int start);
    private bool Parse4Digit(int start, Int32& num);
    private bool Parse2Digit(int start, Int32& num);
    private bool ParseChar(int start, char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DateTimeUtils : object {
    internal static long InitialJavaScriptDateTicks;
    private static string IsoDateFormat;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysPer4Years;
    private static int DaysPerYear;
    private static long TicksPerDay;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversalTicksToJavaScriptTicks(long universalTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    internal static bool TryParseDateTimeOffsetIso(StringReference text, DateTimeOffset& dt);
    private static DateTime CreateDateTime(DateTimeParser dateTimeParser);
    internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    internal static bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryParseMicrosoftDate(StringReference text, Int64& ticks, TimeSpan& offset, DateTimeKind& kind);
    private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, DateTimeOffset& dt);
    private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryReadOffset(StringReference offsetText, int startIndex, TimeSpan& offset);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
    [NullableAttribute("2")]
private IDictionary _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TKey, TValue> _genericDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<TKey, TValue> _readOnlyDictionary;
    [NullableAttribute("2")]
private object _syncRoot;
    internal IDictionary`2<TKey, TValue> GenericDictionary { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public DictionaryWrapper`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    internal IDictionary`2<TKey, TValue> get_GenericDictionary();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicProxy`1 : object {
    public virtual IEnumerable`1<string> GetDynamicMemberNames(T instance);
    public virtual bool TryBinaryOperation(T instance, BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(T instance, ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(T instance, CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryDeleteIndex(T instance, DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryDeleteMember(T instance, DeleteMemberBinder binder);
    public virtual bool TryGetIndex(T instance, GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(T instance, GetMemberBinder binder, Object& result);
    public virtual bool TryInvoke(T instance, InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(T instance, InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TrySetIndex(T instance, SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(T instance, SetMemberBinder binder, object value);
    public virtual bool TryUnaryOperation(T instance, UnaryOperationBinder binder, Object& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1 : DynamicMetaObject {
    private DynamicProxy`1<T> _proxy;
    private static Expression[] NoArgs { get; }
    internal DynamicProxyMetaObject`1(Expression expression, T value, DynamicProxy`1<T> proxy);
    private bool IsOverridden(string method);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    private static Expression[] get_NoArgs();
    private static IEnumerable`1<Expression> GetArgs(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args, DynamicMetaObject value);
    private static ConstantExpression Constant(DynamicMetaObjectBinder binder);
    private DynamicMetaObject CallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, Fallback<T> fallback, Fallback<T> fallbackInvoke);
    private DynamicMetaObject BuildCallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, DynamicMetaObject fallbackResult, Fallback<T> fallbackInvoke);
    private DynamicMetaObject CallMethodReturnLast(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, Fallback<T> fallback);
    private DynamicMetaObject CallMethodNoResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback);
    private BindingRestrictions GetRestrictions();
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory : ReflectionDelegateFactory {
    [CompilerGeneratedAttribute]
private static DynamicReflectionDelegateFactory <Instance>k__BackingField;
    internal static DynamicReflectionDelegateFactory Instance { get; }
    private static DynamicReflectionDelegateFactory();
    [CompilerGeneratedAttribute]
internal static DynamicReflectionDelegateFactory get_Instance();
    private static DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private void GenerateCreateMethodCallIL(MethodBase method, ILGenerator generator, int argsIndex);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    private void GenerateCreateDefaultConstructorIL(Type type, ILGenerator generator, Type delegateType);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    internal static void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    internal static void GenerateCreateSetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DynamicUtils : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDynamicMemberNames(IDynamicMetaObjectProvider dynamicProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.EnumInfo : object {
    public bool IsFlags;
    public UInt64[] Values;
    public String[] Names;
    public String[] ResolvedNames;
    public EnumInfo(bool isFlags, UInt64[] values, String[] names, String[] resolvedNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.EnumUtils : object {
    private static char EnumSeparatorChar;
    private static string EnumSeparatorString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, NamingStrategy>, EnumInfo> ValuesAndNamesPerEnum;
    private static CamelCaseNamingStrategy _camelCaseNamingStrategy;
    private static EnumUtils();
    private static EnumInfo InitializeValuesAndNames(StructMultiKey`2<Type, NamingStrategy> key);
    [NullableContextAttribute("0")]
public static IList`1<T> GetFlagsValues(T value);
    public static bool TryToString(Type enumType, object value, bool camelCase, String& name);
    public static bool TryToString(Type enumType, object value, NamingStrategy namingStrategy, String& name);
    private static string InternalFlagsFormat(EnumInfo entry, ulong result);
    public static EnumInfo GetEnumValuesAndNames(Type enumType);
    private static ulong ToUInt64(object value);
    public static object ParseEnum(Type enumType, NamingStrategy namingStrategy, string value, bool disallowNumber);
    private static Nullable`1<int> MatchName(string value, String[] enumNames, String[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison);
    private static Nullable`1<int> FindIndexByName(String[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ExpressionReflectionDelegateFactory : ReflectionDelegateFactory {
    private static ExpressionReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static ExpressionReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private Expression BuildMethodCall(MethodBase method, Type type, ParameterExpression targetParameterExpression, ParameterExpression argsParameterExpression);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    private Expression EnsureCastExpression(Expression expression, Type targetType, bool allowWidening);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.FSharpFunction : object {
    private object _instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MethodCall`2<object, object> _invoker;
    public FSharpFunction(object instance, MethodCall`2<object, object> invoker);
    [NullableContextAttribute("1")]
public object Invoke(Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.FSharpUtils : object {
    private static object Lock;
    [NullableAttribute("2")]
private static FSharpUtils _instance;
    private MethodInfo _ofSeq;
    private Type _mapType;
    [CompilerGeneratedAttribute]
private Assembly <FSharpCoreAssembly>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <IsUnion>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <GetUnionCases>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionTagReader>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionReader>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoDeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoTag>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <GetUnionCaseInfoFields>k__BackingField;
    public static string FSharpSetTypeName;
    public static string FSharpListTypeName;
    public static string FSharpMapTypeName;
    public static FSharpUtils Instance { get; }
    public Assembly FSharpCoreAssembly { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> IsUnion { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> GetUnionCases { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionTagReader { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionReader { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionConstructor { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoDeclaringType { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoName { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoTag { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> GetUnionCaseInfoFields { get; private set; }
    private FSharpUtils(Assembly fsharpCoreAssembly);
    private static FSharpUtils();
    public static FSharpUtils get_Instance();
    [CompilerGeneratedAttribute]
public Assembly get_FSharpCoreAssembly();
    [CompilerGeneratedAttribute]
private void set_FSharpCoreAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_IsUnion();
    [CompilerGeneratedAttribute]
private void set_IsUnion(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_GetUnionCases();
    [CompilerGeneratedAttribute]
private void set_GetUnionCases(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionTagReader();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionTagReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionReader();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionConstructor();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionConstructor(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoDeclaringType();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoDeclaringType(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoName();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoName(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoTag();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoTag(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_GetUnionCaseInfoFields();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoFields(MethodCall`2<object, object> value);
    public static void EnsureInitialized(Assembly fsharpCoreAssembly);
    private static MethodInfo GetMethodWithNonPublicFallback(Type type, string methodName, BindingFlags bindingFlags);
    private static MethodCall`2<object, object> CreateFSharpFuncCall(Type type, string methodName);
    public ObjectConstructor`1<object> CreateSeq(Type t);
    public ObjectConstructor`1<object> CreateMap(Type keyType, Type valueType);
    [NullableContextAttribute("2")]
public ObjectConstructor`1<object> BuildMapCreator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void PushInstance(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void PushArrayInstance(ILGenerator generator, int argsIndex, int arrayIndex);
    [ExtensionAttribute]
public static void BoxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void UnboxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void CallMethod(ILGenerator generator, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void Return(ILGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.ImmutableCollectionsUtils : object {
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> ArrayContractImmutableCollectionDefinitions;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> DictionaryContractImmutableCollectionDefinitions;
    private static ImmutableCollectionsUtils();
    internal static bool TryBuildImmutableForArrayContract(Type underlyingType, Type collectionItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
    internal static bool TryBuildImmutableForDictionaryContract(Type underlyingType, Type keyItemType, Type valueItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
}
internal interface Newtonsoft.Json.Utilities.IWrappedCollection {
    [NullableAttribute("1")]
public object UnderlyingCollection { get; }
    [NullableContextAttribute("1")]
public abstract virtual object get_UnderlyingCollection();
}
internal interface Newtonsoft.Json.Utilities.IWrappedDictionary {
    [NullableAttribute("1")]
public object UnderlyingDictionary { get; }
    [NullableContextAttribute("1")]
public abstract virtual object get_UnderlyingDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.JavaScriptUtils : object {
    internal static Boolean[] SingleQuoteCharEscapeFlags;
    internal static Boolean[] DoubleQuoteCharEscapeFlags;
    internal static Boolean[] HtmlCharEscapeFlags;
    private static int UnicodeTextLength;
    private static string EscapedUnicodeText;
    private static JavaScriptUtils();
    public static Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar);
    public static bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags);
    [NullableContextAttribute("2")]
public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool`1<char> bufferPool, Char[]& writeBuffer);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling);
    private static int FirstCharToEscape(string s, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling);
    public static Task WriteEscapedJavaScriptStringAsync(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(TextWriter writer, string s, char delimiter, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteEscapedJavaScriptStringWithDelimitersAsync>d__13")]
private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(Task task, TextWriter writer, string s, char delimiter, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteCharAsync>d__14")]
public static Task WriteCharAsync(Task task, TextWriter writer, char c, CancellationToken cancellationToken);
    private static Task WriteEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync>d__16")]
private static Task WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, int lastWritePosition, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    public static bool TryGetDateFromConstructorJson(JsonReader reader, DateTime& dateTime, String& errorMessage);
    private static bool TryGetDateConstructorValue(JsonReader reader, Nullable`1& integer, String& errorMessage);
}
internal static class Newtonsoft.Json.Utilities.JsonTokenUtils : object {
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    private static LateBoundReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
internal static class Newtonsoft.Json.Utilities.MathUtils : object {
    public static int IntLength(ulong i);
    public static char IntToHex(int n);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
    public static bool ApproxEquals(double d1, double d2);
}
internal class Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [NullableContextAttribute("2")]
public static bool ValueEquals(object objA, object objB);
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
    internal static RegexOptions GetRegexOptions(string optionsText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowExpressionVisitor : ExpressionVisitor {
    internal static object ErrorResult;
    private static NoThrowExpressionVisitor();
    protected virtual Expression VisitConditional(ConditionalExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowGetBinderMember : GetMemberBinder {
    private GetMemberBinder _innerBinder;
    public NoThrowGetBinderMember(GetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowSetBinderMember : SetMemberBinder {
    private SetMemberBinder _innerBinder;
    public NoThrowSetBinderMember(SetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal enum Newtonsoft.Json.Utilities.ParseResult : Enum {
    public int value__;
    public static ParseResult None;
    public static ParseResult Success;
    public static ParseResult Overflow;
    public static ParseResult Invalid;
}
internal enum Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
    public int value__;
    public static ParserTimeZone Unspecified;
    public static ParserTimeZone Utc;
    public static ParserTimeZone LocalWestOfUtc;
    public static ParserTimeZone LocalEastOfUtc;
}
internal enum Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ReflectionMember : object {
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<object, object> <Getter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <Setter>k__BackingField;
    public Type MemberType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> Getter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> Setter { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Action`2<object, object> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ReflectionObject : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> Creator { get; }
    public IDictionary`2<string, ReflectionMember> Members { get; }
    private ReflectionObject(ObjectConstructor`1<object> creator);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_Creator();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ReflectionMember> get_Members();
    public object GetValue(object target, string member);
    public void SetValue(object target, string member, object value);
    public Type GetType(string member);
    public static ReflectionObject Create(Type t, String[] memberNames);
    public static ReflectionObject Create(Type t, MethodBase creator, String[] memberNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ReflectionUtils : object {
    public static Type[] EmptyTypes;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetBaseDefinition(PropertyInfo propertyInfo);
    public static bool IsPublic(PropertyInfo property);
    [NullableContextAttribute("2")]
public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, TypeNameAssemblyFormatHandling assemblyFormat, ISerializationBinder binder);
    private static string GetFullyQualifiedTypeName(Type t, ISerializationBinder binder);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static Type EnsureNotNullableType(Type t);
    public static Type EnsureNotByRefType(Type t);
    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type type, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    [NullableContextAttribute("2")]
public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsByRefLikeType(Type type);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit);
    public static StructMultiKey`2<string, string> SplitFullyQualifiedTypeName(string fullyQualifiedTypeName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type type, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type type, BindingFlags bindingAttr);
    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method);
    public static object GetDefaultValue(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.StringBuffer : ValueType {
    private Char[] _buffer;
    private int _position;
    public int Position { get; public set; }
    public bool IsEmpty { get; }
    public Char[] InternalBuffer { get; }
    public StringBuffer(IArrayPool`1<char> bufferPool, int initalSize);
    [NullableContextAttribute("1")]
private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(IArrayPool`1<char> bufferPool, char value);
    [NullableContextAttribute("1")]
public void Append(IArrayPool`1<char> bufferPool, Char[] buffer, int startIndex, int count);
    public void Clear(IArrayPool`1<char> bufferPool);
    private void EnsureSize(IArrayPool`1<char> bufferPool, int appendLength);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public char Item { get; }
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public char get_Item(int i);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringReferenceExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(StringReference s, char c, int startIndex, int length);
    [ExtensionAttribute]
public static bool StartsWith(StringReference s, string text);
    [ExtensionAttribute]
public static bool EndsWith(StringReference s, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringUtils : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
private static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool IsWhiteSpace(string s);
    public static StringWriter CreateStringWriter(int capacity);
    public static void ToCharAsUnicode(char c, Char[] buffer);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
    public static string ToCamelCase(string s);
    private static char ToLower(char c);
    public static string ToSnakeCase(string s);
    public static string ToKebabCase(string s);
    private static string ToSeparatedCase(string s, char separator);
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
    public static int IndexOf(string s, char c);
    public static string Replace(string s, string oldValue, string newValue);
    [ExtensionAttribute]
public static bool StartsWith(string source, char value);
    [ExtensionAttribute]
public static bool EndsWith(string source, char value);
    [ExtensionAttribute]
public static string Trim(string s, int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Newtonsoft.Json.Utilities.StructMultiKey`2 : ValueType {
    public T1 Value1;
    public T2 Value2;
    public StructMultiKey`2(T1 v1, T2 v2);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StructMultiKey`2<T1, T2> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> _concurrentStore;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.TypeExtensions : object {
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces);
    [ExtensionAttribute]
public static bool ImplementInterface(Type type, Type interfaceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.TypeInformation : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    public Type Type { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public TypeInformation(Type type, PrimitiveTypeCode typeCode);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public PrimitiveTypeCode get_TypeCode();
}
internal static class Newtonsoft.Json.Utilities.ValidationUtils : object {
    [NullableContextAttribute("1")]
public static void ArgumentNotNull(object value, string parameterName);
}
public enum Newtonsoft.Json.WriteState : Enum {
    public int value__;
    public static WriteState Error;
    public static WriteState Closed;
    public static WriteState Object;
    public static WriteState Array;
    public static WriteState Constructor;
    public static WriteState Property;
    public static WriteState Start;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Capturing.MessageTemplateProcessor : object {
    private MessageTemplateCache _parser;
    private PropertyBinder _propertyBinder;
    private PropertyValueConverter _propertyValueConverter;
    public MessageTemplateProcessor(PropertyValueConverter propertyValueConverter);
    public void Process(string messageTemplate, Object[] messageTemplateParameters, MessageTemplate& parsedTemplate, EventProperty[]& properties);
    public sealed virtual LogEventProperty CreateProperty(string name, object value, bool destructureObjects);
    public sealed virtual LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Capturing.PropertyBinder : object {
    private PropertyValueConverter _valueConverter;
    private static EventProperty[] NoProperties;
    public PropertyBinder(PropertyValueConverter valueConverter);
    private static PropertyBinder();
    public EventProperty[] ConstructProperties(MessageTemplate messageTemplate, Object[] messageTemplateParameters);
    private EventProperty[] ConstructPositionalProperties(MessageTemplate template, Object[] messageTemplateParameters, PropertyToken[] positionalProperties);
    private EventProperty[] ConstructNamedProperties(MessageTemplate template, Object[] messageTemplateParameters);
    private EventProperty ConstructProperty(PropertyToken propertyToken, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Capturing.PropertyValueConverter : object {
    private static HashSet`1<Type> BuiltInScalarTypes;
    private IDestructuringPolicy[] _destructuringPolicies;
    private Type[] _dictionaryTypes;
    private IScalarConversionPolicy[] _scalarConversionPolicies;
    private DepthLimiter _depthLimiter;
    private int _maximumStringLength;
    private int _maximumCollectionCount;
    private bool _propagateExceptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static HashSet`1<string> _lastSeenNames;
    public PropertyValueConverter(int maximumDestructuringDepth, int maximumStringLength, int maximumCollectionCount, IEnumerable`1<Type> additionalScalarTypes, IEnumerable`1<Type> additionalDictionaryTypes, IEnumerable`1<IDestructuringPolicy> additionalDestructuringPolicies, bool propagateExceptions);
    private static PropertyValueConverter();
    public sealed virtual LogEventProperty CreateProperty(string name, object value, bool destructureObjects);
    public sealed virtual LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects);
    public LogEventPropertyValue CreatePropertyValue(object value, Destructuring destructuring);
    private LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects, int depth);
    private LogEventPropertyValue CreatePropertyValue(object value, Destructuring destructuring, int depth);
    private bool TryConvertEnumerable(object value, Type type, Destructuring destructuring, LogEventPropertyValue& result);
    private bool TryConvertValueTuple(object value, Type type, Destructuring destructuring, LogEventPropertyValue& result);
    private bool TryConvertStructure(object value, Type type, Destructuring destructuring, StructureValue& result);
    private ScalarValue Stringify(object value);
    private string TruncateIfNecessary(string text);
    private bool TryGetDictionary(object value, Type valueType, IDictionary& dictionary);
    private static bool IsValidDictionaryKeyType(Type valueType);
    internal StructureValue CreateStructureValue(object value, Type type, bool isCompilerGeneratedType);
    internal static bool IsCompilerGeneratedType(Type type);
    [IteratorStateMachineAttribute("Serilog.Capturing.PropertyValueConverter/<<TryConvertEnumerable>g__MapToDictionaryElements|15_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<ScalarValue, LogEventPropertyValue>> <TryConvertEnumerable>g__MapToDictionaryElements|15_0(IDictionary dictionaryEntries, Destructuring destructure);
    [IteratorStateMachineAttribute("Serilog.Capturing.PropertyValueConverter/<<TryConvertEnumerable>g__MapToSequenceElements|15_1>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<LogEventPropertyValue> <TryConvertEnumerable>g__MapToSequenceElements|15_1(IEnumerable sequence, Destructuring destructure);
}
internal static class Serilog.Capturing.TrimConfiguration : object {
    [CompilerGeneratedAttribute]
private static bool <IsCompilerGeneratedCodeSupported>k__BackingField;
    public static bool IsCompilerGeneratedCodeSupported { get; }
    private static TrimConfiguration();
    [CompilerGeneratedAttribute]
public static bool get_IsCompilerGeneratedCodeSupported();
}
public class Serilog.Configuration.BatchingOptions : object {
    [CompilerGeneratedAttribute]
private bool <EagerlyEmitFirstEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BufferingTimeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <QueueLimit>k__BackingField;
    public bool EagerlyEmitFirstEvent { get; public set; }
    public int BatchSizeLimit { get; public set; }
    public TimeSpan BufferingTimeLimit { get; public set; }
    public Nullable`1<int> QueueLimit { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EagerlyEmitFirstEvent();
    [CompilerGeneratedAttribute]
public void set_EagerlyEmitFirstEvent(bool value);
    [CompilerGeneratedAttribute]
public int get_BatchSizeLimit();
    [CompilerGeneratedAttribute]
public void set_BatchSizeLimit(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_BufferingTimeLimit();
    [CompilerGeneratedAttribute]
public void set_BufferingTimeLimit(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_QueueLimit();
    [CompilerGeneratedAttribute]
public void set_QueueLimit(Nullable`1<int> value);
}
[NullableContextAttribute("1")]
public interface Serilog.Configuration.ILoggerSettings {
    public abstract virtual void Configure(LoggerConfiguration loggerConfiguration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Configuration.LoggerAuditSinkConfiguration : object {
    private LoggerSinkConfiguration _sinkConfiguration;
    internal LoggerAuditSinkConfiguration(LoggerConfiguration loggerConfiguration, Action`1<ILogEventSink> addSink);
    public LoggerConfiguration Sink(ILogEventSink logEventSink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Sink(LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Logger(Action`1<LoggerConfiguration> configureLogger, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Logger(ILogger logger, LogEventLevel restrictedToMinimumLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Configuration.LoggerDestructuringConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<Type> _addScalar;
    private Action`1<Type> _addDictionaryType;
    private Action`1<IDestructuringPolicy> _addPolicy;
    private Action`1<int> _setMaximumDepth;
    private Action`1<int> _setMaximumStringLength;
    private Action`1<int> _setMaximumCollectionCount;
    internal LoggerDestructuringConfiguration(LoggerConfiguration loggerConfiguration, Action`1<Type> addScalar, Action`1<Type> addDictionaryType, Action`1<IDestructuringPolicy> addPolicy, Action`1<int> setMaximumDepth, Action`1<int> setMaximumStringLength, Action`1<int> setMaximumCollectionCount);
    public LoggerConfiguration AsScalar(Type scalarType);
    public LoggerConfiguration AsScalar();
    public LoggerConfiguration With(IDestructuringPolicy[] destructuringPolicies);
    public LoggerConfiguration With();
    public LoggerConfiguration AsDictionary();
    public LoggerConfiguration ByTransforming(Func`2<TValue, object> transformation);
    public LoggerConfiguration ByTransformingWhere(Func`2<Type, bool> predicate, Func`2<TValue, object> transformation);
    public LoggerConfiguration ToMaximumDepth(int maximumDestructuringDepth);
    public LoggerConfiguration ToMaximumStringLength(int maximumStringLength);
    public LoggerConfiguration ToMaximumCollectionCount(int maximumCollectionCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Configuration.LoggerEnrichmentConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<ILogEventEnricher> _addEnricher;
    internal LoggerEnrichmentConfiguration(LoggerConfiguration loggerConfiguration, Action`1<ILogEventEnricher> addEnricher);
    public LoggerConfiguration With(ILogEventEnricher[] enrichers);
    public LoggerConfiguration With();
    public LoggerConfiguration WithProperty(string name, object value, bool destructureObjects);
    public LoggerConfiguration FromLogContext();
    public LoggerConfiguration When(Func`2<LogEvent, bool> condition, Action`1<LoggerEnrichmentConfiguration> configureEnricher);
    public LoggerConfiguration AtLevel(LogEventLevel enrichFromLevel, Action`1<LoggerEnrichmentConfiguration> configureEnricher);
    public LoggerConfiguration AtLevel(LoggingLevelSwitch levelSwitch, Action`1<LoggerEnrichmentConfiguration> configureEnricher);
    public static LoggerConfiguration Wrap(LoggerEnrichmentConfiguration loggerEnrichmentConfiguration, Func`2<ILogEventEnricher, ILogEventEnricher> wrapEnricher, Action`1<LoggerEnrichmentConfiguration> configureWrappedEnricher);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Configuration.LoggerFilterConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<ILogEventFilter> _addFilter;
    internal LoggerFilterConfiguration(LoggerConfiguration loggerConfiguration, Action`1<ILogEventFilter> addFilter);
    public LoggerConfiguration With(ILogEventFilter[] filters);
    public LoggerConfiguration With();
    public LoggerConfiguration ByExcluding(Func`2<LogEvent, bool> exclusionPredicate);
    public LoggerConfiguration ByIncludingOnly(Func`2<LogEvent, bool> inclusionPredicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Configuration.LoggerMinimumLevelConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<LogEventLevel> _setMinimum;
    private Action`1<LoggingLevelSwitch> _setLevelSwitch;
    private Action`2<string, LoggingLevelSwitch> _addOverride;
    internal LoggerMinimumLevelConfiguration(LoggerConfiguration loggerConfiguration, Action`1<LogEventLevel> setMinimum, Action`1<LoggingLevelSwitch> setLevelSwitch, Action`2<string, LoggingLevelSwitch> addOverride);
    public LoggerConfiguration Is(LogEventLevel minimumLevel);
    public LoggerConfiguration ControlledBy(LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Verbose();
    public LoggerConfiguration Debug();
    public LoggerConfiguration Information();
    public LoggerConfiguration Warning();
    public LoggerConfiguration Error();
    public LoggerConfiguration Fatal();
    public LoggerConfiguration Override(string source, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Override(string source, LogEventLevel minimumLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Configuration.LoggerSettingsConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    internal LoggerSettingsConfiguration(LoggerConfiguration loggerConfiguration);
    public LoggerConfiguration Settings(ILoggerSettings settings);
    public LoggerConfiguration KeyValuePairs(IEnumerable`1<KeyValuePair`2<string, string>> settings);
    private LoggerConfiguration KeyValuePairs(IReadOnlyDictionary`2<string, string> settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Configuration.LoggerSinkConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<ILogEventSink> _addSink;
    internal LoggerSinkConfiguration(LoggerConfiguration loggerConfiguration, Action`1<ILogEventSink> addSink);
    [EditorBrowsableAttribute("1")]
public LoggerConfiguration Sink(ILogEventSink logEventSink, LogEventLevel restrictedToMinimumLevel);
    public LoggerConfiguration Sink(ILogEventSink logEventSink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Sink(LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Sink(IBatchedLogEventSink batchedLogEventSink, BatchingOptions batchingOptions, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Sink(BatchingOptions batchingOptions, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Logger(Action`1<LoggerConfiguration> configureLogger, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    [EditorBrowsableAttribute("1")]
public LoggerConfiguration Logger(ILogger logger, LogEventLevel restrictedToMinimumLevel);
    public LoggerConfiguration Logger(ILogger logger, bool attemptDispose, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Conditional(Func`2<LogEvent, bool> condition, Action`1<LoggerSinkConfiguration> configureSink);
    [ObsoleteAttribute("Use the two-argument `Wrap()` overload to construct a wrapper, then use `WriteTo.Sink()` to add it to the configuration.")]
public static LoggerConfiguration Wrap(LoggerSinkConfiguration loggerSinkConfiguration, Func`2<ILogEventSink, ILogEventSink> wrapSink, Action`1<LoggerSinkConfiguration> configureWrappedSink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public static ILogEventSink Wrap(Func`2<ILogEventSink, ILogEventSink> wrapSink, Action`1<LoggerSinkConfiguration> configureWrappedSink);
    public static ILogEventSink CreateSink(Action`1<LoggerSinkConfiguration> configure);
}
[ExtensionAttribute]
internal static class Serilog.ConsoleAuditLoggerConfigurationExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static LoggerConfiguration Console(LoggerAuditSinkConfiguration sinkConfiguration, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, LoggingLevelSwitch levelSwitch, Nullable`1<LogEventLevel> standardErrorFromLevel, ConsoleTheme theme, bool applyThemeToRedirectedOutput, object syncRoot);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LoggerConfiguration Console(LoggerAuditSinkConfiguration sinkConfiguration, ITextFormatter formatter, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch, Nullable`1<LogEventLevel> standardErrorFromLevel, object syncRoot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Serilog.ConsoleLoggerConfigurationExtensions : object {
    internal static object DefaultSyncRoot;
    internal static string DefaultConsoleOutputTemplate;
    private static ConsoleLoggerConfigurationExtensions();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static LoggerConfiguration Console(LoggerSinkConfiguration sinkConfiguration, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, LoggingLevelSwitch levelSwitch, Nullable`1<LogEventLevel> standardErrorFromLevel, ConsoleTheme theme, bool applyThemeToRedirectedOutput, object syncRoot);
    [ExtensionAttribute]
public static LoggerConfiguration Console(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch, Nullable`1<LogEventLevel> standardErrorFromLevel, object syncRoot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Context.EnricherStack : object {
    [NullableAttribute("2")]
private EnricherStack _under;
    [NullableAttribute("2")]
private ILogEventEnricher _top;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnricherStack <Empty>k__BackingField;
    public int Count { get; }
    public static EnricherStack Empty { get; }
    public bool IsEmpty { get; }
    public ILogEventEnricher Top { get; }
    private EnricherStack(EnricherStack under, ILogEventEnricher top);
    private static EnricherStack();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ILogEventEnricher> System.Collections.Generic.IEnumerable<Serilog.Core.ILogEventEnricher>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public static EnricherStack get_Empty();
    public bool get_IsEmpty();
    public EnricherStack Push(ILogEventEnricher t);
    public ILogEventEnricher get_Top();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Context.LogContext : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static AsyncLocal`1<EnricherStack> Data;
    [NullableAttribute("2")]
private static EnricherStack Enrichers { get; private set; }
    private static LogContext();
    public static IDisposable PushProperty(string name, object value, bool destructureObjects);
    public static IDisposable Push(ILogEventEnricher enricher);
    public static IDisposable Push(ILogEventEnricher[] enrichers);
    public static ILogEventEnricher Clone();
    public static IDisposable Suspend();
    public static void Reset();
    private static EnricherStack GetOrCreateEnricherStack();
    internal static void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
    [NullableContextAttribute("2")]
private static EnricherStack get_Enrichers();
    [NullableContextAttribute("2")]
private static void set_Enrichers(EnricherStack value);
}
internal class Serilog.Context.LogContextEnricher : object {
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
internal static class Serilog.Core.Constants : object {
    [NullableAttribute("1")]
public static string SourceContextPropertyName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Enrichers.ConditionalEnricher : object {
    private ILogEventEnricher _wrapped;
    private Func`2<LogEvent, bool> _condition;
    public ConditionalEnricher(ILogEventEnricher wrapped, Func`2<LogEvent, bool> condition);
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
    public sealed virtual void Dispose();
}
internal class Serilog.Core.Enrichers.EmptyEnricher : object {
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
internal class Serilog.Core.Enrichers.FixedPropertyEnricher : object {
    private EventProperty _eventProperty;
    public FixedPropertyEnricher(EventProperty& eventProperty);
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Enrichers.PropertyEnricher : object {
    private string _name;
    [NullableAttribute("2")]
private object _value;
    private bool _destructureObjects;
    public PropertyEnricher(string name, object value, bool destructureObjects);
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Enrichers.SafeAggregateEnricher : object {
    private ILogEventEnricher[] _enrichers;
    public SafeAggregateEnricher(IEnumerable`1<ILogEventEnricher> enrichers);
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Filters.DelegateFilter : object {
    private Func`2<LogEvent, bool> _isEnabled;
    public DelegateFilter(Func`2<LogEvent, bool> isEnabled);
    public sealed virtual bool IsEnabled(LogEvent logEvent);
}
[NullableContextAttribute("1")]
public interface Serilog.Core.IBatchedLogEventSink {
    public abstract virtual Task EmitBatchAsync(IReadOnlyCollection`1<LogEvent> batch);
    public abstract virtual Task OnEmptyBatchAsync();
}
[NullableContextAttribute("1")]
public interface Serilog.Core.IDestructuringPolicy {
    public abstract virtual bool TryDestructure(object value, ILogEventPropertyValueFactory propertyValueFactory, LogEventPropertyValue& result);
}
[NullableContextAttribute("1")]
public interface Serilog.Core.ILogEventEnricher {
    public abstract virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
[NullableContextAttribute("1")]
public interface Serilog.Core.ILogEventFilter {
    public abstract virtual bool IsEnabled(LogEvent logEvent);
}
[NullableContextAttribute("1")]
public interface Serilog.Core.ILogEventPropertyFactory {
    public abstract virtual LogEventProperty CreateProperty(string name, object value, bool destructureObjects);
}
[NullableContextAttribute("1")]
public interface Serilog.Core.ILogEventPropertyValueFactory {
    public abstract virtual LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects);
}
[NullableContextAttribute("1")]
public interface Serilog.Core.ILogEventSink {
    public abstract virtual void Emit(LogEvent logEvent);
}
[NullableContextAttribute("1")]
internal interface Serilog.Core.IMessageTemplateParser {
    public abstract virtual MessageTemplate Parse(string messageTemplate);
}
[NullableContextAttribute("1")]
internal interface Serilog.Core.IScalarConversionPolicy {
    public abstract virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.LevelOverrideMap : object {
    private LogEventLevel _defaultMinimumLevel;
    [NullableAttribute("2")]
private LoggingLevelSwitch _defaultLevelSwitch;
    private LevelOverride[] _overrides;
    public LevelOverrideMap(IDictionary`2<string, LoggingLevelSwitch> overrides, LogEventLevel defaultMinimumLevel, LoggingLevelSwitch defaultLevelSwitch);
    public void GetEffectiveLevel(string context, LogEventLevel& minimumLevel, LoggingLevelSwitch& levelSwitch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Core.Logger : object {
    private static Object[] NoPropertyValues;
    private static LogEventProperty[] NoProperties;
    private MessageTemplateProcessor _messageTemplateProcessor;
    private ILogEventSink _sink;
    [NullableAttribute("2")]
private Action _dispose;
    private ILogEventEnricher _enricher;
    private LogEventLevel _minimumLevel;
    [NullableAttribute("2")]
private LoggingLevelSwitch _levelSwitch;
    [NullableAttribute("2")]
private LevelOverrideMap _overrideMap;
    [CompilerGeneratedAttribute]
private static ILogger <None>k__BackingField;
    internal bool HasOverrideMap { get; }
    public static ILogger None { get; }
    internal Logger(MessageTemplateProcessor messageTemplateProcessor, LogEventLevel minimumLevel, LoggingLevelSwitch levelSwitch, ILogEventSink sink, ILogEventEnricher enricher, Action dispose, LevelOverrideMap overrideMap);
    private static Logger();
    internal bool get_HasOverrideMap();
    public sealed virtual ILogger ForContext(ILogEventEnricher enricher);
    public sealed virtual ILogger ForContext(IEnumerable`1<ILogEventEnricher> enrichers);
    public sealed virtual ILogger ForContext(string propertyName, object value, bool destructureObjects);
    public sealed virtual ILogger ForContext(Type source);
    public sealed virtual ILogger ForContext();
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate, Object[] propertyValues);
    public sealed virtual bool IsEnabled(LogEventLevel level);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Write(LogEvent logEvent);
    private sealed virtual override void Serilog.Core.ILogEventSink.Emit(LogEvent logEvent);
    private void Dispatch(LogEvent logEvent);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, Object[] propertyValues);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual bool BindMessageTemplate(string messageTemplate, Object[] propertyValues, MessageTemplate& parsedTemplate, IEnumerable`1& boundProperties);
    [NullableContextAttribute("2")]
public sealed virtual bool BindProperty(string propertyName, object value, bool destructureObjects, LogEventProperty& property);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public static ILogger get_None();
}
public class Serilog.Core.LoggingLevelSwitch : object {
    private LogEventLevel modreq(System.Runtime.CompilerServices.IsVolatile) _minimumLevel;
    [NullableAttribute("1")]
private object _levelUpdateLock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<LoggingLevelSwitchChangedEventArgs> MinimumLevelChanged;
    public LogEventLevel MinimumLevel { get; public set; }
    public LoggingLevelSwitch(LogEventLevel initialMinimumLevel);
    [CompilerGeneratedAttribute]
public void add_MinimumLevelChanged(EventHandler`1<LoggingLevelSwitchChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MinimumLevelChanged(EventHandler`1<LoggingLevelSwitchChangedEventArgs> value);
    public LogEventLevel get_MinimumLevel();
    public void set_MinimumLevel(LogEventLevel value);
}
public class Serilog.Core.LoggingLevelSwitchChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private LogEventLevel <OldLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventLevel <NewLevel>k__BackingField;
    public LogEventLevel OldLevel { get; }
    public LogEventLevel NewLevel { get; }
    public LoggingLevelSwitchChangedEventArgs(LogEventLevel oldLevel, LogEventLevel newLevel);
    [CompilerGeneratedAttribute]
public LogEventLevel get_OldLevel();
    [CompilerGeneratedAttribute]
public LogEventLevel get_NewLevel();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("96")]
internal class Serilog.Core.MessageTemplateFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MessageTemplateParameterName>k__BackingField;
    public string MessageTemplateParameterName { get; private set; }
    public MessageTemplateFormatMethodAttribute(string messageTemplateParameterName);
    [CompilerGeneratedAttribute]
public string get_MessageTemplateParameterName();
    [CompilerGeneratedAttribute]
private void set_MessageTemplateParameterName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Pipeline.ByReferenceStringComparer : object {
    public static ByReferenceStringComparer Instance;
    private static ByReferenceStringComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Pipeline.MessageTemplateCache : object {
    private IMessageTemplateParser _innerParser;
    private object _templatesLock;
    private Hashtable _templates;
    private static int MaxCacheItems;
    private static int MaxCachedTemplateLength;
    public MessageTemplateCache(IMessageTemplateParser innerParser);
    public sealed virtual MessageTemplate Parse(string messageTemplate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Pipeline.SilentLogger : object {
    public sealed virtual ILogger ForContext(ILogEventEnricher enricher);
    public sealed virtual ILogger ForContext(IEnumerable`1<ILogEventEnricher> enrichers);
    public sealed virtual ILogger ForContext(string propertyName, object value, bool destructureObjects);
    public sealed virtual ILogger ForContext();
    public sealed virtual ILogger ForContext(Type source);
    public sealed virtual void Write(LogEvent logEvent);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate, T propertyValue);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual bool IsEnabled(LogEventLevel level);
    public sealed virtual void Verbose(string messageTemplate);
    public sealed virtual void Verbose(string messageTemplate, T propertyValue);
    public sealed virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Verbose(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Verbose(Exception exception, string messageTemplate);
    public sealed virtual void Verbose(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Debug(string messageTemplate);
    public sealed virtual void Debug(string messageTemplate, T propertyValue);
    public sealed virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Debug(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Debug(Exception exception, string messageTemplate);
    public sealed virtual void Debug(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
public sealed virtual void Debug(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Information(string messageTemplate);
    public sealed virtual void Information(string messageTemplate, T propertyValue);
    public sealed virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Information(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Information(Exception exception, string messageTemplate);
    public sealed virtual void Information(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
public sealed virtual void Information(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Warning(string messageTemplate);
    public sealed virtual void Warning(string messageTemplate, T propertyValue);
    public sealed virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Warning(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Warning(Exception exception, string messageTemplate);
    public sealed virtual void Warning(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
public sealed virtual void Warning(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Error(string messageTemplate);
    public sealed virtual void Error(string messageTemplate, T propertyValue);
    public sealed virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Error(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Error(Exception exception, string messageTemplate);
    public sealed virtual void Error(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
public sealed virtual void Error(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Fatal(string messageTemplate);
    public sealed virtual void Fatal(string messageTemplate, T propertyValue);
    public sealed virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Fatal(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Fatal(Exception exception, string messageTemplate);
    public sealed virtual void Fatal(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, Object[] propertyValues);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual bool BindMessageTemplate(string messageTemplate, Object[] propertyValues, MessageTemplate& parsedTemplate, IEnumerable`1& boundProperties);
    [NullableContextAttribute("2")]
public sealed virtual bool BindProperty(string propertyName, object value, bool destructureObjects, LogEventProperty& property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Sinks.AggregateSink : object {
    private ILogEventSink[] _sinks;
    public AggregateSink(IEnumerable`1<ILogEventSink> sinks);
    public sealed virtual void Emit(LogEvent logEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Sinks.Batching.BatchingSink : object {
    private Channel`1<LogEvent> _queue;
    private object _stateLock;
    private CancellationTokenSource _shutdownSignal;
    private Task _runLoop;
    private IBatchedLogEventSink _targetSink;
    private int _batchSizeLimit;
    private bool _eagerlyEmitFirstEvent;
    private FailureAwareBatchScheduler _batchScheduler;
    private Queue`1<LogEvent> _currentBatch;
    private Task _waitForShutdownSignal;
    [NullableAttribute("2")]
private Task`1<bool> _cachedWaitToRead;
    public BatchingSink(IBatchedLogEventSink batchedSink, BatchingOptions options);
    public sealed virtual void Emit(LogEvent logEvent);
    [AsyncStateMachineAttribute("Serilog.Core.Sinks.Batching.BatchingSink/<LoopAsync>d__13")]
private Task LoopAsync();
    [AsyncStateMachineAttribute("Serilog.Core.Sinks.Batching.BatchingSink/<TryWaitToReadAsync>d__14")]
private Task`1<bool> TryWaitToReadAsync(ChannelReader`1<LogEvent> reader, Task timeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void SignalShutdown();
    private void WriteToSelfLog(string message, Exception exception);
}
internal class Serilog.Core.Sinks.Batching.FailureAwareBatchScheduler : object {
    private static TimeSpan MinimumBackoffPeriod;
    private static TimeSpan MaximumBackoffInterval;
    private static int FailuresBeforeDroppingBatch;
    private static int FailuresBeforeDroppingQueue;
    private TimeSpan _period;
    private int _failuresSinceSuccessfulBatch;
    public TimeSpan NextInterval { get; }
    public bool ShouldDropBatch { get; }
    public bool ShouldDropQueue { get; }
    public FailureAwareBatchScheduler(TimeSpan period);
    private static FailureAwareBatchScheduler();
    public void MarkSuccess();
    public void MarkFailure();
    public TimeSpan get_NextInterval();
    public bool get_ShouldDropBatch();
    public bool get_ShouldDropQueue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Sinks.ConditionalSink : object {
    private ILogEventSink _wrapped;
    private Func`2<LogEvent, bool> _condition;
    public ConditionalSink(ILogEventSink wrapped, Func`2<LogEvent, bool> condition);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
}
internal class Serilog.Core.Sinks.DisposeDelegatingSink : object {
    [NullableAttribute("1")]
private ILogEventSink _sink;
    [NullableAttribute("2")]
private IDisposable _disposable;
    [NullableContextAttribute("1")]
public DisposeDelegatingSink(ILogEventSink sink, IDisposable disposable);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public sealed virtual void Emit(LogEvent logEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Sinks.DisposingAggregateSink : object {
    private ILogEventSink[] _sinks;
    public DisposingAggregateSink(IEnumerable`1<ILogEventSink> sinks);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
    private static void ReportDisposingException(ILogEventSink sink, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Sinks.FilteringSink : object {
    private ILogEventSink _sink;
    private bool _propagateExceptions;
    private ILogEventFilter[] _filters;
    public FilteringSink(ILogEventSink sink, IEnumerable`1<ILogEventFilter> filters, bool propagateExceptions);
    public sealed virtual void Emit(LogEvent logEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Sinks.RestrictedSink : object {
    private ILogEventSink _sink;
    private LoggingLevelSwitch _levelSwitch;
    public RestrictedSink(ILogEventSink sink, LoggingLevelSwitch levelSwitch);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Core.Sinks.SafeAggregateSink : object {
    private ILogEventSink[] _sinks;
    public SafeAggregateSink(IEnumerable`1<ILogEventSink> sinks);
    public sealed virtual void Emit(LogEvent logEvent);
}
internal class Serilog.Core.Sinks.SecondaryLoggerSink : object {
    [NullableAttribute("1")]
private ILogger _logger;
    private bool _attemptDispose;
    [NullableContextAttribute("1")]
public SecondaryLoggerSink(ILogger logger, bool attemptDispose);
    [NullableContextAttribute("1")]
public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Serilog.Data.LogEventPropertyValueRewriter`1 : LogEventPropertyValueVisitor`2<TState, LogEventPropertyValue> {
    protected virtual LogEventPropertyValue VisitScalarValue(TState state, ScalarValue scalar);
    protected virtual LogEventPropertyValue VisitSequenceValue(TState state, SequenceValue sequence);
    protected virtual LogEventPropertyValue VisitStructureValue(TState state, StructureValue structure);
    protected virtual LogEventPropertyValue VisitDictionaryValue(TState state, DictionaryValue dictionary);
    protected virtual LogEventPropertyValue VisitUnsupportedValue(TState state, LogEventPropertyValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Serilog.Data.LogEventPropertyValueVisitor`2 : object {
    protected virtual TResult Visit(TState state, LogEventPropertyValue value);
    protected abstract virtual TResult VisitScalarValue(TState state, ScalarValue scalar);
    protected abstract virtual TResult VisitSequenceValue(TState state, SequenceValue sequence);
    protected abstract virtual TResult VisitStructureValue(TState state, StructureValue structure);
    protected abstract virtual TResult VisitDictionaryValue(TState state, DictionaryValue dictionary);
    protected virtual TResult VisitUnsupportedValue(TState state, LogEventPropertyValue value);
}
internal class Serilog.Debugging.LoggingFailedException : Exception {
    [NullableContextAttribute("1")]
public LoggingFailedException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Debugging.SelfLog : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`1<string> _output;
    public static void Enable(TextWriter output);
    public static void Enable(Action`1<string> output);
    public static void Disable();
    [NullableContextAttribute("2")]
public static void WriteLine(string format, object arg0, object arg1, object arg2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Events.DictionaryValue : LogEventPropertyValue {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<ScalarValue, LogEventPropertyValue> <Elements>k__BackingField;
    public IReadOnlyDictionary`2<ScalarValue, LogEventPropertyValue> Elements { get; }
    public DictionaryValue(IEnumerable`1<KeyValuePair`2<ScalarValue, LogEventPropertyValue>> elements);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<ScalarValue, LogEventPropertyValue> get_Elements();
    [NullableContextAttribute("2")]
public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Serilog.Events.EventProperty : ValueType {
    public static EventProperty None;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventPropertyValue <Value>k__BackingField;
    public string Name { get; }
    public LogEventPropertyValue Value { get; }
    public EventProperty(string name, LogEventPropertyValue value);
    private static EventProperty();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public LogEventPropertyValue get_Value();
    public void Deconstruct(String& name, LogEventPropertyValue& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(EventProperty other);
    public virtual int GetHashCode();
}
internal static class Serilog.Events.LevelAlias : object {
    public static LogEventLevel Minimum;
    public static LogEventLevel Maximum;
    public static LogEventLevel Off;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Events.LogEvent : object {
    private Dictionary`2<string, LogEventPropertyValue> _properties;
    private ActivityTraceId _traceId;
    private ActivitySpanId _spanId;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageTemplate <MessageTemplate>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public DateTimeOffset Timestamp { get; }
    public LogEventLevel Level { get; }
    [CLSCompliantAttribute("False")]
public Nullable`1<ActivityTraceId> TraceId { get; }
    [CLSCompliantAttribute("False")]
public Nullable`1<ActivitySpanId> SpanId { get; }
    public MessageTemplate MessageTemplate { get; }
    public IReadOnlyDictionary`2<string, LogEventPropertyValue> Properties { get; }
    [NullableAttribute("2")]
public Exception Exception { get; }
    private LogEvent(DateTimeOffset timestamp, LogEventLevel level, Exception exception, MessageTemplate messageTemplate, Dictionary`2<string, LogEventPropertyValue> properties, ActivityTraceId traceId, ActivitySpanId spanId);
    public LogEvent(DateTimeOffset timestamp, LogEventLevel level, Exception exception, MessageTemplate messageTemplate, IEnumerable`1<LogEventProperty> properties);
    [CLSCompliantAttribute("False")]
public LogEvent(DateTimeOffset timestamp, LogEventLevel level, Exception exception, MessageTemplate messageTemplate, IEnumerable`1<LogEventProperty> properties, ActivityTraceId traceId, ActivitySpanId spanId);
    internal LogEvent(DateTimeOffset timestamp, LogEventLevel level, Exception exception, MessageTemplate messageTemplate, EventProperty[] properties, ActivityTraceId traceId, ActivitySpanId spanId);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public LogEventLevel get_Level();
    public Nullable`1<ActivityTraceId> get_TraceId();
    public Nullable`1<ActivitySpanId> get_SpanId();
    [CompilerGeneratedAttribute]
public MessageTemplate get_MessageTemplate();
    public void RenderMessage(TextWriter output, IFormatProvider formatProvider);
    public string RenderMessage(IFormatProvider formatProvider);
    public IReadOnlyDictionary`2<string, LogEventPropertyValue> get_Properties();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Exception();
    public void AddOrUpdateProperty(LogEventProperty property);
    internal void AddOrUpdateProperty(EventProperty& property);
    public void AddPropertyIfAbsent(LogEventProperty property);
    internal void AddPropertyIfAbsent(EventProperty& property);
    internal void AddPropertyIfAbsent(ILogEventPropertyFactory factory, string name, object value, bool destructureObjects);
    public void RemovePropertyIfPresent(string propertyName);
    [CLSCompliantAttribute("False")]
public static LogEvent UnstableAssembleFromParts(DateTimeOffset timestamp, LogEventLevel level, Exception exception, MessageTemplate messageTemplate, Dictionary`2<string, LogEventPropertyValue> properties, ActivityTraceId traceId, ActivitySpanId spanId);
    internal LogEvent Copy();
}
public enum Serilog.Events.LogEventLevel : Enum {
    public int value__;
    public static LogEventLevel Verbose;
    public static LogEventLevel Debug;
    public static LogEventLevel Information;
    public static LogEventLevel Warning;
    public static LogEventLevel Error;
    public static LogEventLevel Fatal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Events.LogEventProperty : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventPropertyValue <Value>k__BackingField;
    public string Name { get; }
    public LogEventPropertyValue Value { get; }
    public LogEventProperty(string name, LogEventPropertyValue value);
    internal LogEventProperty(EventProperty property);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public LogEventPropertyValue get_Value();
    [NullableContextAttribute("2")]
public static bool IsValidName(string name);
    internal static void EnsureValidName(string name);
}
public abstract class Serilog.Events.LogEventPropertyValue : object {
    [NullableContextAttribute("2")]
public abstract virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Events.MessageTemplate : object {
    [CompilerGeneratedAttribute]
private static MessageTemplate <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageTemplateToken[] <TokenArray>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private PropertyToken[] <NamedProperties>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private PropertyToken[] <PositionalProperties>k__BackingField;
    public static MessageTemplate Empty { get; }
    public string Text { get; }
    public IEnumerable`1<MessageTemplateToken> Tokens { get; }
    internal MessageTemplateToken[] TokenArray { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal PropertyToken[] NamedProperties { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal PropertyToken[] PositionalProperties { get; }
    public MessageTemplate(IEnumerable`1<MessageTemplateToken> tokens);
    public MessageTemplate(string text, IEnumerable`1<MessageTemplateToken> tokens);
    private static MessageTemplate();
    [CompilerGeneratedAttribute]
public static MessageTemplate get_Empty();
    private static TResult[] GetElementsOfTypeToArray(MessageTemplateToken[] tokens);
    [CompilerGeneratedAttribute]
public string get_Text();
    public virtual string ToString();
    public IEnumerable`1<MessageTemplateToken> get_Tokens();
    [CompilerGeneratedAttribute]
internal MessageTemplateToken[] get_TokenArray();
    [CompilerGeneratedAttribute]
internal PropertyToken[] get_NamedProperties();
    [CompilerGeneratedAttribute]
internal PropertyToken[] get_PositionalProperties();
    public string Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, IFormatProvider formatProvider);
    public void Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Serilog.Events.ScalarValue : LogEventPropertyValue {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static ScalarValue <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [NullableAttribute("1")]
public static ScalarValue Null { get; }
    public object Value { get; }
    public ScalarValue(object value);
    private static ScalarValue();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static ScalarValue get_Null();
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
    internal static void Render(object value, TextWriter output, string format, IFormatProvider formatProvider);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Events.SequenceValue : LogEventPropertyValue {
    private LogEventPropertyValue[] _elements;
    [CompilerGeneratedAttribute]
private static SequenceValue <Empty>k__BackingField;
    public static SequenceValue Empty { get; }
    public IReadOnlyList`1<LogEventPropertyValue> Elements { get; }
    public SequenceValue(IEnumerable`1<LogEventPropertyValue> elements);
    internal SequenceValue(LogEventPropertyValue[] elements);
    private static SequenceValue();
    [CompilerGeneratedAttribute]
public static SequenceValue get_Empty();
    public IReadOnlyList`1<LogEventPropertyValue> get_Elements();
    [NullableContextAttribute("2")]
public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Events.StructureValue : LogEventPropertyValue {
    private LogEventProperty[] _properties;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <TypeTag>k__BackingField;
    [NullableAttribute("2")]
public string TypeTag { get; }
    public IReadOnlyList`1<LogEventProperty> Properties { get; }
    public StructureValue(IEnumerable`1<LogEventProperty> properties, string typeTag);
    internal StructureValue(LogEventProperty[] properties, string typeTag);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_TypeTag();
    public IReadOnlyList`1<LogEventProperty> get_Properties();
    [NullableContextAttribute("2")]
public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
    private static void Render(TextWriter output, LogEventProperty property, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Serilog.FileLoggerConfigurationExtensions : object {
    private static int DefaultRetainedFileCountLimit;
    private static long DefaultFileSizeLimitBytes;
    private static string DefaultOutputTemplate;
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, Encoding encoding);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, Encoding encoding);
    [ExtensionAttribute]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, Encoding encoding, FileLifecycleHooks hooks, Nullable`1<TimeSpan> retainedFileTimeLimit);
    [ExtensionAttribute]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, Encoding encoding, FileLifecycleHooks hooks, Nullable`1<TimeSpan> retainedFileTimeLimit);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerAuditSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, LoggingLevelSwitch levelSwitch);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerAuditSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    [ExtensionAttribute]
public static LoggerConfiguration File(LoggerAuditSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, LoggingLevelSwitch levelSwitch, Encoding encoding, FileLifecycleHooks hooks);
    [ExtensionAttribute]
public static LoggerConfiguration File(LoggerAuditSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch, Encoding encoding, FileLifecycleHooks hooks);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureFile(Func`4<ILogEventSink, LogEventLevel, LoggingLevelSwitch, LoggerConfiguration> addSink, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool propagateExceptions, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, Encoding encoding, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, FileLifecycleHooks hooks, Nullable`1<TimeSpan> retainedFileTimeLimit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Filters.Matching : object {
    public static Func`2<LogEvent, bool> FromSource();
    public static Func`2<LogEvent, bool> FromSource(string source);
    public static Func`2<LogEvent, bool> WithProperty(string propertyName);
    public static Func`2<LogEvent, bool> WithProperty(string propertyName, object scalarValue);
    public static Func`2<LogEvent, bool> WithProperty(string propertyName, Func`2<TScalar, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Formatting.Display.LevelOutputFormat : object {
    private static String[][] _titleCaseLevelMap;
    private static String[][] _lowerCaseLevelMap;
    private static String[][] _upperCaseLevelMap;
    private static LevelOutputFormat();
    public static string GetLevelMoniker(LogEventLevel value, string format);
    private static string GetLevelMoniker(String[][] caseLevelMap, LogEventLevel level, int width);
    private static string GetLevelMoniker(String[][] caseLevelMap, LogEventLevel level);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Formatting.Display.MessageTemplateTextFormatter : object {
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    private MessageTemplate _outputTemplate;
    public MessageTemplateTextFormatter(string outputTemplate, IFormatProvider formatProvider);
    public sealed virtual void Format(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Formatting.Display.OutputProperties : object {
    public static string MessagePropertyName;
    public static string TimestampPropertyName;
    public static string UtcTimestampPropertyName;
    public static string LevelPropertyName;
    public static string TraceIdPropertyName;
    public static string SpanIdPropertyName;
    public static string NewLinePropertyName;
    public static string ExceptionPropertyName;
    public static string PropertiesPropertyName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Formatting.Display.PropertiesOutputFormat : object {
    private static JsonValueFormatter JsonValueFormatter;
    private static PropertiesOutputFormat();
    public static void Render(MessageTemplate template, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, MessageTemplate outputTemplate, TextWriter output, string format, IFormatProvider formatProvider);
    private static bool TemplateContainsPropertyName(MessageTemplate template, string propertyName);
}
[NullableContextAttribute("1")]
internal interface Serilog.Formatting.ITextFormatter {
    public abstract virtual void Format(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Formatting.Json.JsonFormatter : object {
    private string _closingDelimiter;
    private bool _renderMessage;
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    private JsonValueFormatter _jsonValueFormatter;
    [NullableContextAttribute("2")]
public JsonFormatter(string closingDelimiter, bool renderMessage, IFormatProvider formatProvider);
    public sealed virtual void Format(LogEvent logEvent, TextWriter output);
    private void WriteRenderingsValues(IEnumerable`1<IGrouping`2<string, PropertyToken>> tokensWithFormat, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    [CompilerGeneratedAttribute]
internal static void <WriteRenderingsValues>g__WriteNameValuePair|6_0(string name, string value, Nullable`1& precedingDelimiter, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Serilog.Formatting.Json.JsonValueFormatter : LogEventPropertyValueVisitor`2<TextWriter, bool> {
    [NullableAttribute("2")]
private string _typeTagName;
    private static string DefaultTypeTagName;
    [NullableContextAttribute("2")]
public JsonValueFormatter(string typeTagName);
    public void Format(LogEventPropertyValue value, TextWriter output);
    protected virtual bool VisitScalarValue(TextWriter state, ScalarValue scalar);
    protected virtual bool VisitSequenceValue(TextWriter state, SequenceValue sequence);
    protected virtual bool VisitStructureValue(TextWriter state, StructureValue structure);
    protected virtual bool VisitDictionaryValue(TextWriter state, DictionaryValue dictionary);
    protected virtual void FormatLiteralValue(object value, TextWriter output);
    private static void FormatBooleanValue(bool value, TextWriter output);
    private static void FormatFloatValue(float value, TextWriter output);
    private static void FormatDoubleValue(double value, TextWriter output);
    private static void FormatExactNumericValue(int value, TextWriter output);
    private static void FormatExactNumericValue(UInt32 value, TextWriter output);
    private static void FormatExactNumericValue(long value, TextWriter output);
    private static void FormatExactNumericValue(ulong value, TextWriter output);
    private static void FormatExactNumericValue(decimal value, TextWriter output);
    private static void FormatExactNumericValue(byte value, TextWriter output);
    private static void FormatExactNumericValue(sbyte value, TextWriter output);
    private static void FormatExactNumericValue(short value, TextWriter output);
    private static void FormatExactNumericValue(ushort value, TextWriter output);
    private static void FormatDateTimeValue(DateTime value, TextWriter output);
    private static void FormatDateTimeOffsetValue(DateTimeOffset value, TextWriter output);
    private static void FormatTimeSpanValue(TimeSpan value, TextWriter output);
    private static void FormatLiteralObjectValue(object value, TextWriter output);
    private static void FormatStringValue(string str, TextWriter output);
    private static void FormatNullValue(TextWriter output);
    public static void WriteQuotedJsonString(string str, TextWriter output);
}
[NullableContextAttribute("1")]
public interface Serilog.ILogger {
    public abstract virtual ILogger ForContext(ILogEventEnricher enricher);
    public abstract virtual ILogger ForContext(IEnumerable`1<ILogEventEnricher> enrichers);
    public abstract virtual ILogger ForContext(string propertyName, object value, bool destructureObjects);
    public abstract virtual ILogger ForContext();
    public abstract virtual ILogger ForContext(Type source);
    public abstract virtual void Write(LogEvent logEvent);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, Object[] propertyValues);
    public abstract virtual bool IsEnabled(LogEventLevel level);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate, Object[] propertyValues);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual bool BindMessageTemplate(string messageTemplate, Object[] propertyValues, MessageTemplate& parsedTemplate, IEnumerable`1& boundProperties);
    [NullableContextAttribute("2")]
public abstract virtual bool BindProperty(string propertyName, object value, bool destructureObjects, LogEventProperty& property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Log : object {
    private static ILogger _logger;
    public static ILogger Logger { get; public set; }
    private static Log();
    public static ILogger get_Logger();
    public static void set_Logger(ILogger value);
    public static void CloseAndFlush();
    public static ILogger ForContext(ILogEventEnricher enricher);
    public static ILogger ForContext(ILogEventEnricher[] enrichers);
    public static ILogger ForContext(string propertyName, object value, bool destructureObjects);
    public static ILogger ForContext();
    public static ILogger ForContext(Type source);
    public static void Write(LogEvent logEvent);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate, Object[] propertyValues);
    public static bool IsEnabled(LogEventLevel level);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [NullableContextAttribute("2")]
[MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static bool BindMessageTemplate(string messageTemplate, Object[] propertyValues, MessageTemplate& parsedTemplate, IEnumerable`1& boundProperties);
    [NullableContextAttribute("2")]
public static bool BindProperty(string propertyName, object value, bool destructureObjects, LogEventProperty& property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.LoggerConfiguration : object {
    private List`1<ILogEventSink> _logEventSinks;
    private List`1<ILogEventSink> _auditSinks;
    private List`1<ILogEventEnricher> _enrichers;
    private List`1<ILogEventFilter> _filters;
    private List`1<Type> _additionalScalarTypes;
    private HashSet`1<Type> _additionalDictionaryTypes;
    private List`1<IDestructuringPolicy> _additionalDestructuringPolicies;
    private Dictionary`2<string, LoggingLevelSwitch> _overrides;
    private LogEventLevel _minimumLevel;
    [NullableAttribute("2")]
private LoggingLevelSwitch _levelSwitch;
    private int _maximumDestructuringDepth;
    private int _maximumStringLength;
    private int _maximumCollectionCount;
    private bool _loggerCreated;
    [CompilerGeneratedAttribute]
private LoggerSinkConfiguration <WriteTo>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerEnrichmentConfiguration <Enrich>k__BackingField;
    public LoggerSinkConfiguration WriteTo { get; internal set; }
    public LoggerAuditSinkConfiguration AuditTo { get; }
    public LoggerMinimumLevelConfiguration MinimumLevel { get; }
    public LoggerEnrichmentConfiguration Enrich { get; internal set; }
    public LoggerFilterConfiguration Filter { get; }
    public LoggerDestructuringConfiguration Destructure { get; }
    public LoggerSettingsConfiguration ReadFrom { get; }
    [CompilerGeneratedAttribute]
public LoggerSinkConfiguration get_WriteTo();
    [CompilerGeneratedAttribute]
internal void set_WriteTo(LoggerSinkConfiguration value);
    public LoggerAuditSinkConfiguration get_AuditTo();
    public LoggerMinimumLevelConfiguration get_MinimumLevel();
    [CompilerGeneratedAttribute]
public LoggerEnrichmentConfiguration get_Enrich();
    [CompilerGeneratedAttribute]
internal void set_Enrich(LoggerEnrichmentConfiguration value);
    public LoggerFilterConfiguration get_Filter();
    public LoggerDestructuringConfiguration get_Destructure();
    public LoggerSettingsConfiguration get_ReadFrom();
    public Logger CreateLogger();
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_0(ILogEventSink s);
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_1(ILogEventEnricher e);
    [CompilerGeneratedAttribute]
private void <get_AuditTo>b__20_0(ILogEventSink s);
    [CompilerGeneratedAttribute]
private void <get_MinimumLevel>b__22_0(LogEventLevel l);
    [CompilerGeneratedAttribute]
private void <get_MinimumLevel>b__22_1(LoggingLevelSwitch sw);
    [CompilerGeneratedAttribute]
private void <get_MinimumLevel>b__22_2(string s, LoggingLevelSwitch lls);
    [CompilerGeneratedAttribute]
private void <get_Filter>b__28_0(ILogEventFilter f);
    [CompilerGeneratedAttribute]
private void <get_Destructure>b__30_0(Type type);
    [CompilerGeneratedAttribute]
private void <get_Destructure>b__30_1(int depth);
    [CompilerGeneratedAttribute]
private void <get_Destructure>b__30_2(int length);
    [CompilerGeneratedAttribute]
private void <get_Destructure>b__30_3(int count);
}
[ExtensionAttribute]
internal static class Serilog.LoggerConfigurationAsyncExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LoggerConfiguration Async(LoggerSinkConfiguration loggerSinkConfiguration, Action`1<LoggerSinkConfiguration> configure, int bufferSize, bool blockWhenFull, IAsyncLogEventSinkMonitor monitor);
}
[ExtensionAttribute]
internal static class Serilog.LoggerConfigurationEventLogExtensions : object {
    private static string DefaultOutputTemplate;
    [ExtensionAttribute]
public static LoggerConfiguration EventLog(LoggerSinkConfiguration loggerConfiguration, string source, string logName, string machineName, bool manageEventSource, string outputTemplate, IFormatProvider formatProvider, LogEventLevel restrictedToMinimumLevel, IEventIdProvider eventIdProvider);
    [ExtensionAttribute]
public static LoggerConfiguration EventLog(LoggerSinkConfiguration loggerConfiguration, ITextFormatter formatter, string source, string logName, string machineName, bool manageEventSource, LogEventLevel restrictedToMinimumLevel, IEventIdProvider eventIdProvider);
}
[ExtensionAttribute]
internal static class Serilog.LoggerExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ILogger ForContext(ILogger logger, LogEventLevel level, string propertyName, TValue value, bool destructureObjects);
}
[ExtensionAttribute]
internal static class Serilog.LoggerSinkConfigurationDebugExtensions : object {
    private static string DefaultDebugOutputTemplate;
    [ExtensionAttribute]
public static LoggerConfiguration Debug(LoggerSinkConfiguration sinkConfiguration, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, LoggingLevelSwitch levelSwitch);
    [ExtensionAttribute]
public static LoggerConfiguration Debug(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
}
[IsReadOnlyAttribute]
internal class Serilog.Parsing.Alignment : ValueType {
    [CompilerGeneratedAttribute]
private AlignmentDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    public AlignmentDirection Direction { get; }
    public int Width { get; }
    public Alignment(AlignmentDirection direction, int width);
    [CompilerGeneratedAttribute]
public AlignmentDirection get_Direction();
    [CompilerGeneratedAttribute]
public int get_Width();
}
internal enum Serilog.Parsing.AlignmentDirection : Enum {
    public int value__;
    public static AlignmentDirection Left;
    public static AlignmentDirection Right;
}
internal enum Serilog.Parsing.Destructuring : Enum {
    public int value__;
    public static Destructuring Default;
    public static Destructuring Stringify;
    public static Destructuring Destructure;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Parsing.MessageTemplateParser : object {
    private static bool DefaultAcceptDottedPropertyNames;
    private static TextToken EmptyTextToken;
    private bool _acceptDottedPropertyNames;
    internal MessageTemplateParser(bool acceptDottedPropertyNames);
    private static MessageTemplateParser();
    public sealed virtual MessageTemplate Parse(string messageTemplate);
    [IteratorStateMachineAttribute("Serilog.Parsing.MessageTemplateParser/<Tokenize>d__6")]
private IEnumerable`1<MessageTemplateToken> Tokenize(string messageTemplate);
    private MessageTemplateToken ParsePropertyToken(int startAt, string messageTemplate, Int32& next);
    [NullableContextAttribute("2")]
private static bool TrySplitTagContent(string tagContent, String& propertyNameAndDestructuring, String& format, String& alignment);
    private bool IsValidInPropertyName(char c);
    private static bool TryGetDestructuringHint(char c, Destructuring& destructuring);
    private static bool IsValidInFormat(char c);
    private static TextToken ParseTextToken(int startAt, string messageTemplate, Int32& next);
}
public abstract class Serilog.Parsing.MessageTemplateToken : object {
    public int Length { get; }
    public abstract virtual int get_Length();
    [NullableContextAttribute("1")]
public abstract virtual void Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Parsing.PropertyToken : MessageTemplateToken {
    private Nullable`1<int> _position;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Destructuring <Destructuring>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Alignment> <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawText>k__BackingField;
    public int Length { get; }
    public string PropertyName { get; }
    public Destructuring Destructuring { get; }
    [NullableAttribute("2")]
public string Format { get; }
    public Nullable`1<Alignment> Alignment { get; }
    public bool IsPositional { get; }
    internal string RawText { get; }
    public PropertyToken(string propertyName, string rawText, string format, Nullable`1& alignment, Destructuring destructuring);
    public virtual int get_Length();
    public virtual void Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public Destructuring get_Destructuring();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public Nullable`1<Alignment> get_Alignment();
    public bool get_IsPositional();
    [CompilerGeneratedAttribute]
internal string get_RawText();
    public bool TryGetPositionalValue(Int32& position);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Parsing.TextToken : MessageTemplateToken {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public int Length { get; }
    public string Text { get; }
    public TextToken(string text);
    public virtual int get_Length();
    public virtual void Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public string get_Text();
}
internal class Serilog.Policies.ByteArrayScalarConversionPolicy : object {
    private static int MaximumByteArrayLength;
    [NullableContextAttribute("1")]
public sealed virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
internal class Serilog.Policies.DelegateDestructuringPolicy : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryDestructure(object value, ILogEventPropertyValueFactory propertyValueFactory, LogEventPropertyValue& result);
}
internal class Serilog.Policies.EnumScalarConversionPolicy : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
internal class Serilog.Policies.PrimitiveScalarConversionPolicy : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Policies.ProjectedDestructuringPolicy : object {
    private Func`2<Type, bool> _canApply;
    private Func`2<object, object> _projection;
    public ProjectedDestructuringPolicy(Func`2<Type, bool> canApply, Func`2<object, object> projection);
    public sealed virtual bool TryDestructure(object value, ILogEventPropertyValueFactory propertyValueFactory, LogEventPropertyValue& result);
}
internal class Serilog.Policies.ReflectionTypesScalarDestructuringPolicy : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryDestructure(object value, ILogEventPropertyValueFactory propertyValueFactory, LogEventPropertyValue& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Policies.SimpleScalarConversionPolicy : object {
    private HashSet`1<Type> _scalarTypes;
    public SimpleScalarConversionPolicy(IEnumerable`1<Type> scalarTypes);
    public sealed virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
internal static class Serilog.Rendering.Casing : object {
    [NullableContextAttribute("1")]
public static string Format(string value, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Rendering.MessageTemplateRenderer : object {
    private static JsonValueFormatter JsonValueFormatter;
    private static MessageTemplateRenderer();
    public static void Render(MessageTemplate messageTemplate, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, string format, IFormatProvider formatProvider);
    public static void RenderTextToken(TextToken tt, TextWriter output);
    public static void RenderPropertyToken(PropertyToken pt, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider, bool isLiteral, bool isJson);
    private static void RenderValue(LogEventPropertyValue propertyValue, bool literal, bool json, TextWriter output, string format, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Rendering.Padding : object {
    private static Char[] PaddingChars;
    private static Padding();
    public static void Apply(TextWriter output, string value, Nullable`1& alignment);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Serilog.Rendering.ReusableStringWriter : StringWriter {
    [ThreadStaticAttribute]
private static ReusableStringWriter _pooledWriter;
    internal static int StringBuilderCapacityThreshold;
    private ReusableStringWriter(IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static StringWriter GetOrCreate(IFormatProvider formatProvider);
    protected virtual void Dispose(bool disposing);
}
internal enum Serilog.RollingInterval : Enum {
    public int value__;
    public static RollingInterval Infinite;
    public static RollingInterval Year;
    public static RollingInterval Month;
    public static RollingInterval Day;
    public static RollingInterval Hour;
    public static RollingInterval Minute;
}
internal static class Serilog.Settings.KeyValuePairs.CallableConfigurationMethodFinder : object {
    [NullableContextAttribute("1")]
internal static IList`1<MethodInfo> FindConfigurationMethods(IEnumerable`1<Assembly> configurationAssemblies, Type configType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Settings.KeyValuePairs.KeyValuePairSettings : object {
    private static string UsingDirective;
    private static string LevelSwitchDirective;
    private static string AuditToDirective;
    private static string WriteToDirective;
    private static string MinimumLevelDirective;
    private static string MinimumLevelControlledByDirective;
    private static string EnrichWithDirective;
    private static string EnrichWithPropertyDirective;
    private static string FilterDirective;
    private static string DestructureDirective;
    private static string UsingDirectiveFullFormPrefix;
    private static string EnrichWithPropertyDirectivePrefix;
    private static string MinimumLevelOverrideDirectivePrefix;
    private static string CallableDirectiveRegex;
    private static string LevelSwitchDeclarationDirectiveRegex;
    private static string LevelSwitchNameRegex;
    private static String[] _supportedDirectives;
    private static Dictionary`2<string, Type> CallableDirectiveReceiverTypes;
    private static Dictionary`2<Type, Func`2<LoggerConfiguration, object>> CallableDirectiveReceivers;
    private IReadOnlyDictionary`2<string, string> _settings;
    public KeyValuePairSettings(IReadOnlyDictionary`2<string, string> settings);
    private static KeyValuePairSettings();
    public sealed virtual void Configure(LoggerConfiguration loggerConfiguration);
    internal static bool IsValidSwitchName(string input);
    private static IReadOnlyDictionary`2<string, LoggingLevelSwitch> ParseNamedLevelSwitchDeclarationDirectives(IReadOnlyDictionary`2<string, string> directives);
    private static LoggingLevelSwitch LookUpSwitchByName(string switchName, IReadOnlyDictionary`2<string, LoggingLevelSwitch> declaredLevelSwitches);
    private static object ConvertOrLookupByName(string valueOrSwitchName, Type type, IReadOnlyDictionary`2<string, LoggingLevelSwitch> declaredSwitches);
    private static void ApplyDirectives(List`1<IGrouping`2<string, ConfigurationMethodCall>> directives, IList`1<MethodInfo> configurationMethods, object loggerConfigMethod, IReadOnlyDictionary`2<string, LoggingLevelSwitch> declaredSwitches);
    internal static MethodInfo SelectConfigurationMethod(IEnumerable`1<MethodInfo> candidateMethods, string name, IEnumerable`1<ConfigurationMethodCall> suppliedArgumentValues);
    internal static IEnumerable`1<Assembly> LoadConfigurationAssemblies(IReadOnlyDictionary`2<string, string> directives);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Settings.KeyValuePairs.SettingValueConversions : object {
    private static Regex StaticMemberAccessorRegex;
    private static Dictionary`2<Type, Func`2<string, object>> ExtendedTypeConversions;
    private static SettingValueConversions();
    public static object ConvertToType(string value, Type toType);
    [NullableContextAttribute("2")]
internal static bool TryParseStaticMemberAccessor(string input, String& accessorTypeName, String& memberName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Settings.KeyValuePairs.SurrogateConfigurationMethods : object {
    private static Dictionary`2<Type, MethodInfo[]> SurrogateMethodCandidates;
    internal static MethodInfo[] WriteTo;
    internal static MethodInfo[] AuditTo;
    internal static MethodInfo[] Enrich;
    internal static MethodInfo[] Destructure;
    internal static MethodInfo[] Filter;
    private static SurrogateConfigurationMethods();
    internal static LoggerConfiguration Sink(LoggerSinkConfiguration loggerSinkConfiguration, ILogEventSink sink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    internal static LoggerConfiguration Sink(LoggerAuditSinkConfiguration auditSinkConfiguration, ILogEventSink sink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    internal static LoggerConfiguration With(LoggerEnrichmentConfiguration loggerEnrichmentConfiguration, ILogEventEnricher enricher);
    internal static LoggerConfiguration FromLogContext(LoggerEnrichmentConfiguration loggerEnrichmentConfiguration);
    internal static LoggerConfiguration With(LoggerDestructuringConfiguration loggerDestructuringConfiguration, IDestructuringPolicy policy);
    internal static LoggerConfiguration AsScalar(LoggerDestructuringConfiguration loggerDestructuringConfiguration, Type scalarType);
    internal static LoggerConfiguration ToMaximumCollectionCount(LoggerDestructuringConfiguration loggerDestructuringConfiguration, int maximumCollectionCount);
    internal static LoggerConfiguration ToMaximumDepth(LoggerDestructuringConfiguration loggerDestructuringConfiguration, int maximumDestructuringDepth);
    internal static LoggerConfiguration ToMaximumStringLength(LoggerDestructuringConfiguration loggerDestructuringConfiguration, int maximumStringLength);
    internal static LoggerConfiguration With(LoggerFilterConfiguration loggerFilterConfiguration, ILogEventFilter filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.Async.BackgroundWorkerSink : object {
    private ILogEventSink _wrappedSink;
    private bool _blockWhenFull;
    private BlockingCollection`1<LogEvent> _queue;
    private Task _worker;
    [NullableAttribute("2")]
private IAsyncLogEventSinkMonitor _monitor;
    private long _droppedMessages;
    private int Serilog.Sinks.Async.IAsyncLogEventSinkInspector.BufferSize { get; }
    private int Serilog.Sinks.Async.IAsyncLogEventSinkInspector.Count { get; }
    private long Serilog.Sinks.Async.IAsyncLogEventSinkInspector.DroppedMessagesCount { get; }
    public BackgroundWorkerSink(ILogEventSink wrappedSink, int bufferCapacity, bool blockWhenFull, IAsyncLogEventSinkMonitor monitor);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
    private void Pump();
    private sealed virtual override int Serilog.Sinks.Async.IAsyncLogEventSinkInspector.get_BufferSize();
    private sealed virtual override int Serilog.Sinks.Async.IAsyncLogEventSinkInspector.get_Count();
    private sealed virtual override long Serilog.Sinks.Async.IAsyncLogEventSinkInspector.get_DroppedMessagesCount();
}
internal interface Serilog.Sinks.Async.IAsyncLogEventSinkInspector {
    public int BufferSize { get; }
    public int Count { get; }
    public long DroppedMessagesCount { get; }
    public abstract virtual int get_BufferSize();
    public abstract virtual int get_Count();
    public abstract virtual long get_DroppedMessagesCount();
}
[NullableContextAttribute("1")]
internal interface Serilog.Sinks.Async.IAsyncLogEventSinkMonitor {
    public abstract virtual void StartMonitoring(IAsyncLogEventSinkInspector inspector);
    public abstract virtual void StopMonitoring(IAsyncLogEventSinkInspector inspector);
}
internal class Serilog.Sinks.Debug.DebugSink : object {
    private ITextFormatter _formatter;
    public DebugSink(ITextFormatter formatter);
    public sealed virtual void Emit(LogEvent logEvent);
}
internal class Serilog.Sinks.EventLog.EventIdHashProvider : object {
    public sealed virtual ushort ComputeEventId(LogEvent logEvent);
    private static int Compute(string messageTemplate);
}
internal class Serilog.Sinks.EventLog.EventLogSink : object {
    private static string ApplicationLogName;
    private static int MaximumPayloadLengthChars;
    private static int MaximumSourceNameLengthChars;
    private static int SourceMovedEventId;
    private IEventIdProvider _eventIdProvider;
    private ITextFormatter _textFormatter;
    private EventLog _log;
    public EventLogSink(string source, string logName, ITextFormatter textFormatter, string machineName, bool manageEventSource);
    public EventLogSink(string source, string logName, ITextFormatter textFormatter, string machineName, bool manageEventSource, IEventIdProvider eventIdProvider);
    private static void ConfigureSource(EventLog log, string source);
    public sealed virtual void Emit(LogEvent logEvent);
    private static EventLogEntryType LevelToEventLogEntryType(LogEventLevel logEventLevel);
}
internal interface Serilog.Sinks.EventLog.IEventIdProvider {
    public abstract virtual ushort ComputeEventId(LogEvent logEvent);
}
internal static class Serilog.Sinks.File.Clock : object {
    [NullableAttribute("1")]
private static Func`1<DateTime> _dateTimeNow;
    [ThreadStaticAttribute]
private static DateTime _testDateTimeNow;
    public static DateTime DateTimeNow { get; }
    private static Clock();
    public static DateTime get_DateTimeNow();
    public static void SetTestDateTimeNow(DateTime now);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.FileLifeCycleHookChain : FileLifecycleHooks {
    private FileLifecycleHooks _first;
    private FileLifecycleHooks _second;
    public FileLifeCycleHookChain(FileLifecycleHooks first, FileLifecycleHooks second);
    public virtual Stream OnFileOpened(string path, Stream underlyingStream, Encoding encoding);
    public virtual void OnFileDeleting(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Serilog.Sinks.File.FileLifecycleHooks : object {
    public virtual Stream OnFileOpened(string path, Stream underlyingStream, Encoding encoding);
    public virtual Stream OnFileOpened(Stream underlyingStream, Encoding encoding);
    public virtual void OnFileDeleting(string path);
    public FileLifecycleHooks Then(FileLifecycleHooks next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.FileSink : object {
    private TextWriter _output;
    private FileStream _underlyingStream;
    private ITextFormatter _textFormatter;
    private Nullable`1<long> _fileSizeLimitBytes;
    private bool _buffered;
    private object _syncRoot;
    [NullableAttribute("2")]
private WriteCountingStream _countingStreamWrapper;
    [ObsoleteAttribute("This type and constructor will be removed from the public API in a future version; use `WriteTo.File()` instead.")]
public FileSink(string path, ITextFormatter textFormatter, Nullable`1<long> fileSizeLimitBytes, Encoding encoding, bool buffered);
    internal FileSink(string path, ITextFormatter textFormatter, Nullable`1<long> fileSizeLimitBytes, Encoding encoding, bool buffered, FileLifecycleHooks hooks);
    private sealed virtual override bool Serilog.Sinks.File.IFileSink.EmitOrOverflow(LogEvent logEvent);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
    public sealed virtual void FlushToDisk();
}
internal interface Serilog.Sinks.File.IFileSink {
    [NullableContextAttribute("1")]
public abstract virtual bool EmitOrOverflow(LogEvent logEvent);
}
internal interface Serilog.Sinks.File.IFlushableFileSink {
    public abstract virtual void FlushToDisk();
}
internal static class Serilog.Sinks.File.IOErrors : object {
    [NullableContextAttribute("1")]
public static bool IsLockedFile(IOException ex);
}
internal class Serilog.Sinks.File.NullSink : object {
    [NullableContextAttribute("1")]
public sealed virtual void Emit(LogEvent logEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.PathRoller : object {
    private static string PeriodMatchGroup;
    private static string SequenceNumberMatchGroup;
    private string _directory;
    private string _filenamePrefix;
    private string _filenameSuffix;
    private Regex _filenameMatcher;
    private RollingInterval _interval;
    private string _periodFormat;
    [CompilerGeneratedAttribute]
private string <DirectorySearchPattern>k__BackingField;
    public string LogFileDirectory { get; }
    public string DirectorySearchPattern { get; }
    public PathRoller(string path, RollingInterval interval);
    public string get_LogFileDirectory();
    [CompilerGeneratedAttribute]
public string get_DirectorySearchPattern();
    public void GetLogFilePath(DateTime date, Nullable`1<int> sequenceNumber, String& path);
    [IteratorStateMachineAttribute("Serilog.Sinks.File.PathRoller/<SelectMatches>d__15")]
public IEnumerable`1<RollingLogFile> SelectMatches(IEnumerable`1<string> filenames);
    public Nullable`1<DateTime> GetCurrentCheckpoint(DateTime instant);
    public Nullable`1<DateTime> GetNextCheckpoint(DateTime instant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This type will be removed from the public API in a future version; use `WriteTo.File(flushToDiskInterval:)` instead.")]
internal class Serilog.Sinks.File.PeriodicFlushToDiskSink : object {
    private ILogEventSink _sink;
    private Timer _timer;
    private int _flushRequired;
    public PeriodicFlushToDiskSink(ILogEventSink sink, TimeSpan flushInterval);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
    private void FlushToDisk(IFlushableFileSink flushable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.RollingFileSink : object {
    private PathRoller _roller;
    private ITextFormatter _textFormatter;
    private Nullable`1<long> _fileSizeLimitBytes;
    private Nullable`1<int> _retainedFileCountLimit;
    private Nullable`1<TimeSpan> _retainedFileTimeLimit;
    [NullableAttribute("2")]
private Encoding _encoding;
    private bool _buffered;
    private bool _shared;
    private bool _rollOnFileSizeLimit;
    [NullableAttribute("2")]
private FileLifecycleHooks _hooks;
    private object _syncRoot;
    private bool _isDisposed;
    private Nullable`1<DateTime> _nextCheckpoint;
    [NullableAttribute("2")]
private IFileSink _currentFile;
    private Nullable`1<int> _currentFileSequence;
    public RollingFileSink(string path, ITextFormatter textFormatter, Nullable`1<long> fileSizeLimitBytes, Nullable`1<int> retainedFileCountLimit, Encoding encoding, bool buffered, bool shared, RollingInterval rollingInterval, bool rollOnFileSizeLimit, FileLifecycleHooks hooks, Nullable`1<TimeSpan> retainedFileTimeLimit);
    public sealed virtual void Emit(LogEvent logEvent);
    private void AlignCurrentFileTo(DateTime now, bool nextSequence);
    private void OpenFile(DateTime now, Nullable`1<int> minSequence);
    private void ApplyRetentionPolicy(string currentFilePath, DateTime now);
    private bool ShouldRetainFile(RollingLogFile file, int index, DateTime now);
    public sealed virtual void Dispose();
    private void CloseFile();
    public sealed virtual void FlushToDisk();
}
[ExtensionAttribute]
internal static class Serilog.Sinks.File.RollingIntervalExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetFormat(RollingInterval interval);
    [ExtensionAttribute]
public static Nullable`1<DateTime> GetCurrentCheckpoint(RollingInterval interval, DateTime instant);
    [ExtensionAttribute]
public static Nullable`1<DateTime> GetNextCheckpoint(RollingInterval interval, DateTime instant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.RollingLogFile : object {
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <DateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SequenceNumber>k__BackingField;
    public string Filename { get; }
    public Nullable`1<DateTime> DateTime { get; }
    public Nullable`1<int> SequenceNumber { get; }
    public RollingLogFile(string filename, Nullable`1<DateTime> dateTime, Nullable`1<int> sequenceNumber);
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_DateTime();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SequenceNumber();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This type will be removed from the public API in a future version; use `WriteTo.File(shared: true)` instead.")]
internal class Serilog.Sinks.File.SharedFileSink : object {
    private TextWriter _output;
    private FileStream _underlyingStream;
    private ITextFormatter _textFormatter;
    private Nullable`1<long> _fileSizeLimitBytes;
    private object _syncRoot;
    private static string MutexNameSuffix;
    private static int MutexWaitTimeout;
    private Mutex _mutex;
    public SharedFileSink(string path, ITextFormatter textFormatter, Nullable`1<long> fileSizeLimitBytes, Encoding encoding);
    private sealed virtual override bool Serilog.Sinks.File.IFileSink.EmitOrOverflow(LogEvent logEvent);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
    public sealed virtual void FlushToDisk();
    private bool TryAcquireMutex();
    private void ReleaseMutex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.WriteCountingStream : Stream {
    private Stream _stream;
    [CompilerGeneratedAttribute]
private long <CountedLength>k__BackingField;
    public long CountedLength { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public WriteCountingStream(Stream stream);
    [CompilerGeneratedAttribute]
public long get_CountedLength();
    [CompilerGeneratedAttribute]
private void set_CountedLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.ConsoleSink : object {
    private Nullable`1<LogEventLevel> _standardErrorFromLevel;
    private ConsoleTheme _theme;
    private ITextFormatter _formatter;
    private object _syncRoot;
    private static int DefaultWriteBufferCapacity;
    private static ConsoleSink();
    public ConsoleSink(ConsoleTheme theme, ITextFormatter formatter, Nullable`1<LogEventLevel> standardErrorFromLevel, object syncRoot);
    public sealed virtual void Emit(LogEvent logEvent);
    private TextWriter SelectOutputStream(LogEventLevel logEventLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Formatting.ThemedDisplayValueFormatter : ThemedValueFormatter {
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    public ThemedDisplayValueFormatter(ConsoleTheme theme, IFormatProvider formatProvider);
    public virtual ThemedValueFormatter SwitchTheme(ConsoleTheme theme);
    protected virtual int VisitScalarValue(ThemedValueFormatterState state, ScalarValue scalar);
    protected virtual int VisitSequenceValue(ThemedValueFormatterState state, SequenceValue sequence);
    protected virtual int VisitStructureValue(ThemedValueFormatterState state, StructureValue structure);
    protected virtual int VisitDictionaryValue(ThemedValueFormatterState state, DictionaryValue dictionary);
    public int FormatLiteralValue(ScalarValue scalar, TextWriter output, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Formatting.ThemedJsonValueFormatter : ThemedValueFormatter {
    private ThemedDisplayValueFormatter _displayFormatter;
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    public ThemedJsonValueFormatter(ConsoleTheme theme, IFormatProvider formatProvider);
    public virtual ThemedValueFormatter SwitchTheme(ConsoleTheme theme);
    protected virtual int VisitScalarValue(ThemedValueFormatterState state, ScalarValue scalar);
    protected virtual int VisitSequenceValue(ThemedValueFormatterState state, SequenceValue sequence);
    protected virtual int VisitStructureValue(ThemedValueFormatterState state, StructureValue structure);
    protected virtual int VisitDictionaryValue(ThemedValueFormatterState state, DictionaryValue dictionary);
    private int FormatLiteralValue(ScalarValue scalar, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Serilog.Sinks.SystemConsole.Formatting.ThemedValueFormatter : LogEventPropertyValueVisitor`2<ThemedValueFormatterState, int> {
    private ConsoleTheme _theme;
    protected ThemedValueFormatter(ConsoleTheme theme);
    protected StyleReset ApplyStyle(TextWriter output, ConsoleThemeStyle style, Int32& invisibleCharacterCount);
    public int Format(LogEventPropertyValue value, TextWriter output, string format, bool literalTopLevel);
    public abstract virtual ThemedValueFormatter SwitchTheme(ConsoleTheme theme);
}
internal class Serilog.Sinks.SystemConsole.Formatting.ThemedValueFormatterState : ValueType {
    [NullableAttribute("1")]
public TextWriter Output;
    [NullableAttribute("2")]
public string Format;
    public bool IsTopLevel;
    public ThemedValueFormatterState Nest();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.EventPropertyTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private PropertyToken _token;
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    public EventPropertyTokenRenderer(ConsoleTheme theme, PropertyToken token, IFormatProvider formatProvider);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.ExceptionTokenRenderer : OutputTemplateTokenRenderer {
    private static string StackFrameLinePrefix;
    private ConsoleTheme _theme;
    public ExceptionTokenRenderer(ConsoleTheme theme, PropertyToken pt);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Output.LevelOutputFormat : object {
    private static String[][] TitleCaseLevelMap;
    private static String[][] LowerCaseLevelMap;
    private static String[][] UpperCaseLevelMap;
    private static LevelOutputFormat();
    public static string GetLevelMoniker(LogEventLevel value, string format);
    private static string GetLevelMoniker(String[][] caseLevelMap, int index, int width);
    private static string GetLevelMoniker(String[][] caseLevelMap, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.LevelTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private PropertyToken _levelToken;
    private static Dictionary`2<LogEventLevel, ConsoleThemeStyle> Levels;
    public LevelTokenRenderer(ConsoleTheme theme, PropertyToken levelToken);
    private static LevelTokenRenderer();
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.MessageTemplateOutputTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private PropertyToken _token;
    private ThemedMessageTemplateRenderer _renderer;
    public MessageTemplateOutputTokenRenderer(ConsoleTheme theme, PropertyToken token, IFormatProvider formatProvider);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
internal class Serilog.Sinks.SystemConsole.Output.NewLineTokenRenderer : OutputTemplateTokenRenderer {
    private Nullable`1<Alignment> _alignment;
    public NewLineTokenRenderer(Nullable`1<Alignment> alignment);
    [NullableContextAttribute("1")]
public virtual void Render(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.OutputTemplateRenderer : object {
    private OutputTemplateTokenRenderer[] _renderers;
    public OutputTemplateRenderer(ConsoleTheme theme, string outputTemplate, IFormatProvider formatProvider);
    public sealed virtual void Format(LogEvent logEvent, TextWriter output);
}
internal abstract class Serilog.Sinks.SystemConsole.Output.OutputTemplateTokenRenderer : object {
    [NullableContextAttribute("1")]
public abstract virtual void Render(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.PropertiesTokenRenderer : OutputTemplateTokenRenderer {
    private MessageTemplate _outputTemplate;
    private ConsoleTheme _theme;
    private PropertyToken _token;
    private ThemedValueFormatter _valueFormatter;
    public PropertiesTokenRenderer(ConsoleTheme theme, PropertyToken token, MessageTemplate outputTemplate, IFormatProvider formatProvider);
    public virtual void Render(LogEvent logEvent, TextWriter output);
    private static bool TemplateContainsPropertyName(MessageTemplate template, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.SpanIdTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private Nullable`1<Alignment> _alignment;
    public SpanIdTokenRenderer(ConsoleTheme theme, PropertyToken spanIdToken);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.TextTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private string _text;
    public TextTokenRenderer(ConsoleTheme theme, string text);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.TimestampTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private PropertyToken _token;
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    public TimestampTokenRenderer(ConsoleTheme theme, PropertyToken token, IFormatProvider formatProvider);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.TraceIdTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private Nullable`1<Alignment> _alignment;
    public TraceIdTokenRenderer(ConsoleTheme theme, PropertyToken traceIdToken);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
internal static class Serilog.Sinks.SystemConsole.Platform.WindowsConsole : object {
    private static int StandardOutputHandleId;
    private static UInt32 EnableVirtualTerminalProcessingMode;
    private static long InvalidHandleValue;
    public static void EnableVirtualTerminalProcessing();
    private static IntPtr GetStdHandle(int handleId);
    private static bool GetConsoleMode(IntPtr handle, UInt32& mode);
    private static bool SetConsoleMode(IntPtr handle, UInt32 mode);
}
[ExtensionAttribute]
internal static class Serilog.Sinks.SystemConsole.Rendering.AlignmentExtensions : object {
    [ExtensionAttribute]
public static Alignment Widen(Alignment alignment, int amount);
}
internal static class Serilog.Sinks.SystemConsole.Rendering.Casing : object {
    [NullableContextAttribute("1")]
public static string Format(string value, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Rendering.Padding : object {
    private static Char[] PaddingChars;
    private static Padding();
    public static void Apply(TextWriter output, string value, Nullable`1<Alignment> alignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Rendering.ThemedMessageTemplateRenderer : object {
    private ConsoleTheme _theme;
    private ThemedValueFormatter _valueFormatter;
    private bool _isLiteral;
    private static ConsoleTheme NoTheme;
    private ThemedValueFormatter _unthemedValueFormatter;
    public ThemedMessageTemplateRenderer(ConsoleTheme theme, ThemedValueFormatter valueFormatter, bool isLiteral);
    private static ThemedMessageTemplateRenderer();
    public int Render(MessageTemplate template, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    private int RenderTextToken(TextToken tt, TextWriter output);
    private int RenderPropertyToken(PropertyToken pt, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    private int RenderAlignedPropertyTokenUnbuffered(PropertyToken pt, TextWriter output, LogEventPropertyValue propertyValue);
    private int RenderValue(ConsoleTheme theme, ThemedValueFormatter valueFormatter, LogEventPropertyValue propertyValue, TextWriter output, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme : ConsoleTheme {
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Sixteen>k__BackingField;
    private IReadOnlyDictionary`2<ConsoleThemeStyle, string> _styles;
    private static string AnsiStyleReset;
    [CompilerGeneratedAttribute]
private int <ResetCharCount>k__BackingField;
    public static AnsiConsoleTheme Code { get; }
    public static AnsiConsoleTheme Grayscale { get; }
    public static AnsiConsoleTheme Literate { get; }
    public static AnsiConsoleTheme Sixteen { get; }
    public bool CanBuffer { get; }
    protected int ResetCharCount { get; }
    public AnsiConsoleTheme(IReadOnlyDictionary`2<ConsoleThemeStyle, string> styles);
    private static AnsiConsoleTheme();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Code();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Literate();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Sixteen();
    public virtual bool get_CanBuffer();
    [CompilerGeneratedAttribute]
protected virtual int get_ResetCharCount();
    public virtual int Set(TextWriter output, ConsoleThemeStyle style);
    public virtual void Reset(TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Themes.AnsiConsoleThemes : object {
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Sixteen>k__BackingField;
    public static AnsiConsoleTheme Literate { get; }
    public static AnsiConsoleTheme Grayscale { get; }
    public static AnsiConsoleTheme Code { get; }
    public static AnsiConsoleTheme Sixteen { get; }
    private static AnsiConsoleThemes();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Literate();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Code();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Sixteen();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Themes.AnsiEscapeSequence : object {
    public static string Unthemed;
    public static string Reset;
    public static string Bold;
    public static string Black;
    public static string Red;
    public static string Green;
    public static string Yellow;
    public static string Blue;
    public static string Magenta;
    public static string Cyan;
    public static string White;
    public static string BrightBlack;
    public static string BrightRed;
    public static string BrightGreen;
    public static string BrightYellow;
    public static string BrightBlue;
    public static string BrightMagenta;
    public static string BrightCyan;
    public static string BrightWhite;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Serilog.Sinks.SystemConsole.Themes.ConsoleTheme : object {
    [CompilerGeneratedAttribute]
private static ConsoleTheme <None>k__BackingField;
    public static ConsoleTheme None { get; }
    public bool CanBuffer { get; }
    protected int ResetCharCount { get; }
    private static ConsoleTheme();
    [CompilerGeneratedAttribute]
public static ConsoleTheme get_None();
    public abstract virtual bool get_CanBuffer();
    public abstract virtual int Set(TextWriter output, ConsoleThemeStyle style);
    public abstract virtual void Reset(TextWriter output);
    protected abstract virtual int get_ResetCharCount();
    internal StyleReset Apply(TextWriter output, ConsoleThemeStyle style, Int32& invisibleCharacterCount);
}
internal enum Serilog.Sinks.SystemConsole.Themes.ConsoleThemeStyle : Enum {
    public int value__;
    public static ConsoleThemeStyle Text;
    public static ConsoleThemeStyle SecondaryText;
    public static ConsoleThemeStyle TertiaryText;
    public static ConsoleThemeStyle Invalid;
    public static ConsoleThemeStyle Null;
    public static ConsoleThemeStyle Name;
    public static ConsoleThemeStyle String;
    public static ConsoleThemeStyle Number;
    public static ConsoleThemeStyle Boolean;
    public static ConsoleThemeStyle Scalar;
    [ObsoleteAttribute("Use ConsoleThemeStyle.Scalar instead")]
[EditorBrowsableAttribute("1")]
public static ConsoleThemeStyle Object;
    public static ConsoleThemeStyle LevelVerbose;
    public static ConsoleThemeStyle LevelDebug;
    public static ConsoleThemeStyle LevelInformation;
    public static ConsoleThemeStyle LevelWarning;
    public static ConsoleThemeStyle LevelError;
    public static ConsoleThemeStyle LevelFatal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Themes.EmptyConsoleTheme : ConsoleTheme {
    [CompilerGeneratedAttribute]
private int <ResetCharCount>k__BackingField;
    public bool CanBuffer { get; }
    protected int ResetCharCount { get; }
    public virtual bool get_CanBuffer();
    [CompilerGeneratedAttribute]
protected virtual int get_ResetCharCount();
    public virtual int Set(TextWriter output, ConsoleThemeStyle style);
    public virtual void Reset(TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Themes.StyleReset : ValueType {
    private ConsoleTheme _theme;
    private TextWriter _output;
    public StyleReset(ConsoleTheme theme, TextWriter output);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Themes.SystemConsoleTheme : ConsoleTheme {
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Colored>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<ConsoleThemeStyle, SystemConsoleThemeStyle> <Styles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResetCharCount>k__BackingField;
    public static SystemConsoleTheme Grayscale { get; }
    public static SystemConsoleTheme Literate { get; }
    public static SystemConsoleTheme Colored { get; }
    public IReadOnlyDictionary`2<ConsoleThemeStyle, SystemConsoleThemeStyle> Styles { get; }
    public bool CanBuffer { get; }
    protected int ResetCharCount { get; }
    public SystemConsoleTheme(IReadOnlyDictionary`2<ConsoleThemeStyle, SystemConsoleThemeStyle> styles);
    private static SystemConsoleTheme();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Literate();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Colored();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<ConsoleThemeStyle, SystemConsoleThemeStyle> get_Styles();
    public virtual bool get_CanBuffer();
    [CompilerGeneratedAttribute]
protected virtual int get_ResetCharCount();
    public virtual int Set(TextWriter output, ConsoleThemeStyle style);
    public virtual void Reset(TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Themes.SystemConsoleThemes : object {
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Colored>k__BackingField;
    public static SystemConsoleTheme Literate { get; }
    public static SystemConsoleTheme Grayscale { get; }
    public static SystemConsoleTheme Colored { get; }
    private static SystemConsoleThemes();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Literate();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Colored();
}
internal class Serilog.Sinks.SystemConsole.Themes.SystemConsoleThemeStyle : ValueType {
    public Nullable`1<ConsoleColor> Foreground;
    public Nullable`1<ConsoleColor> Background;
}
internal static class System.<488ce209-4e5d-40e7-be8c-f81f2b99f13a>SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Argument_EmptyValue { get; }
    internal static string PlatformNotSupported_RuntimeInformation { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Argument_EmptyValue();
    internal static string get_PlatformNotSupported_RuntimeInformation();
    internal static Type get_ResourceType();
}
internal enum System.<805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument : Enum {
    public int value__;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument length;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument start;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument minimumBufferSize;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument elementIndex;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument comparable;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument comparer;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument destination;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument offset;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument startSegment;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument endSegment;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument startIndex;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument endIndex;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument array;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument culture;
    public static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument manager;
}
internal static class System.<805945f3-27b0-47ad-b8f6-389d9d8f82c3>SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string NotSupported_CannotCallEqualsOnSpan { get; }
    internal static string NotSupported_CannotCallGetHashCodeOnSpan { get; }
    internal static string Argument_InvalidTypeWithPointersNotSupported { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string MemoryDisposed { get; }
    internal static string OutstandingReferences { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_GWithPrecisionNotSupported { get; }
    internal static string Argument_CannotParsePrecision { get; }
    internal static string Argument_PrecisionTooLarge { get; }
    internal static string Argument_OverlapAlignmentMismatch { get; }
    internal static string EndPositionNotReached { get; }
    internal static string UnexpectedSegmentType { get; }
    private static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_NotSupported_CannotCallEqualsOnSpan();
    internal static string get_NotSupported_CannotCallGetHashCodeOnSpan();
    internal static string get_Argument_InvalidTypeWithPointersNotSupported();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_MemoryDisposed();
    internal static string get_OutstandingReferences();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_GWithPrecisionNotSupported();
    internal static string get_Argument_CannotParsePrecision();
    internal static string get_Argument_PrecisionTooLarge();
    internal static string get_Argument_OverlapAlignmentMismatch();
    internal static string get_EndPositionNotReached();
    internal static string get_UnexpectedSegmentType();
}
internal static class System.<805945f3-27b0-47ad-b8f6-389d9d8f82c3>ThrowHelper : object {
    internal static void ThrowArgumentNullException(<805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument argument);
    private static Exception CreateArgumentNullException(<805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument argument);
    internal static void ThrowArrayTypeMismatchException();
    private static Exception CreateArrayTypeMismatchException();
    internal static void ThrowArgumentException_InvalidTypeWithPointersNotSupported(Type type);
    private static Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(Type type);
    internal static void ThrowArgumentException_DestinationTooShort();
    private static Exception CreateArgumentException_DestinationTooShort();
    internal static void ThrowIndexOutOfRangeException();
    private static Exception CreateIndexOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException();
    private static Exception CreateArgumentOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException(<805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument argument);
    private static Exception CreateArgumentOutOfRangeException(<805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException_PrecisionTooLarge();
    private static Exception CreateArgumentOutOfRangeException_PrecisionTooLarge();
    internal static void ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
    private static Exception CreateArgumentOutOfRangeException_SymbolDoesNotFit();
    internal static void ThrowInvalidOperationException();
    private static Exception CreateInvalidOperationException();
    internal static void ThrowInvalidOperationException_OutstandingReferences();
    private static Exception CreateInvalidOperationException_OutstandingReferences();
    internal static void ThrowInvalidOperationException_UnexpectedSegmentType();
    private static Exception CreateInvalidOperationException_UnexpectedSegmentType();
    internal static void ThrowInvalidOperationException_EndPositionNotReached();
    private static Exception CreateInvalidOperationException_EndPositionNotReached();
    internal static void ThrowArgumentOutOfRangeException_PositionOutOfRange();
    private static Exception CreateArgumentOutOfRangeException_PositionOutOfRange();
    internal static void ThrowArgumentOutOfRangeException_OffsetOutOfRange();
    private static Exception CreateArgumentOutOfRangeException_OffsetOutOfRange();
    internal static void ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
    private static Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer();
    internal static void ThrowFormatException_BadFormatSpecifier();
    private static Exception CreateFormatException_BadFormatSpecifier();
    internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    private static Exception CreateArgumentException_OverlapAlignmentMismatch();
    internal static void ThrowNotSupportedException();
    private static Exception CreateThrowNotSupportedException();
    public static bool TryFormatThrowFormatException(Int32& bytesWritten);
    public static bool TryParseThrowFormatException(T& value, Int32& bytesConsumed);
    public static void ThrowArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment);
    private static Exception CreateArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment);
    public static void ThrowArgumentValidationException(Array array, int start);
    private static Exception CreateArgumentValidationException(Array array, int start);
    public static void ThrowStartOrEndArgumentValidationException(long start);
    private static Exception CreateStartOrEndArgumentValidationException(long start);
}
internal static class System.<d09c9507-1983-461f-8fce-f8aba78858d6>SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ActivityIdFormatInvalid { get; }
    internal static string ActivityNotRunning { get; }
    internal static string ActivityNotStarted { get; }
    internal static string ActivityStartAlreadyStarted { get; }
    internal static string ActivitySetParentAlreadyStarted { get; }
    internal static string EndTimeNotUtc { get; }
    internal static string OperationNameInvalid { get; }
    internal static string ParentIdAlreadySet { get; }
    internal static string ParentIdInvalid { get; }
    internal static string SetFormatOnStartedActivity { get; }
    internal static string SetParentIdOnActivityWithParent { get; }
    internal static string StartTimeNotUtc { get; }
    internal static string KeyAlreadyExist { get; }
    internal static string InvalidTraceParent { get; }
    internal static string UnableAccessServicePointTable { get; }
    internal static string UnableToInitialize { get; }
    internal static string UnsupportedType { get; }
    internal static string Arg_BufferTooSmall { get; }
    internal static string InvalidInstrumentType { get; }
    private static <d09c9507-1983-461f-8fce-f8aba78858d6>SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    private static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ActivityIdFormatInvalid();
    internal static string get_ActivityNotRunning();
    internal static string get_ActivityNotStarted();
    internal static string get_ActivityStartAlreadyStarted();
    internal static string get_ActivitySetParentAlreadyStarted();
    internal static string get_EndTimeNotUtc();
    internal static string get_OperationNameInvalid();
    internal static string get_ParentIdAlreadySet();
    internal static string get_ParentIdInvalid();
    internal static string get_SetFormatOnStartedActivity();
    internal static string get_SetParentIdOnActivityWithParent();
    internal static string get_StartTimeNotUtc();
    internal static string get_KeyAlreadyExist();
    internal static string get_InvalidTraceParent();
    internal static string get_UnableAccessServicePointTable();
    internal static string get_UnableToInitialize();
    internal static string get_UnsupportedType();
    internal static string get_Arg_BufferTooSmall();
    internal static string get_InvalidInstrumentType();
}
internal static class System.<f389ca43-32bf-4e24-ad8c-a6ed5efddff3>SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string ArgumentException_BufferNotFromPool { get; }
    private static <f389ca43-32bf-4e24-ad8c-a6ed5efddff3>SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_ArgumentException_BufferNotFromPool();
}
internal static class System.<f4f5f2aa-fdc0-4274-94a7-ef43d0100ed5>SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ChannelClosedException_DefaultMessage { get; }
    internal static string InvalidOperation_IncompleteAsyncOperation { get; }
    internal static string InvalidOperation_MultipleContinuations { get; }
    internal static string InvalidOperation_IncorrectToken { get; }
    private static <f4f5f2aa-fdc0-4274-94a7-ef43d0100ed5>SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    private static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ChannelClosedException_DefaultMessage();
    internal static string get_InvalidOperation_IncompleteAsyncOperation();
    internal static string get_InvalidOperation_MultipleContinuations();
    internal static string get_InvalidOperation_IncorrectToken();
}
internal class System.Buffers.ArrayMemoryPool`1 : MemoryPool`1<T> {
    private static int s_maxBufferSize;
    public int MaxBufferSize { get; }
    public sealed virtual int get_MaxBufferSize();
    public sealed virtual IMemoryOwner`1<T> Rent(int minimumBufferSize);
    protected sealed virtual void Dispose(bool disposing);
}
internal abstract class System.Buffers.ArrayPool`1 : object {
    private static ArrayPool`1<T> s_sharedInstance;
    public static ArrayPool`1<T> Shared { get; }
    private static ArrayPool`1();
    public static ArrayPool`1<T> get_Shared();
    private static ArrayPool`1<T> EnsureSharedCreated();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
[EventSourceAttribute]
internal class System.Buffers.ArrayPoolEventSource : EventSource {
    internal static ArrayPoolEventSource Log;
    private static ArrayPoolEventSource();
    [EventAttribute("1")]
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
    [EventAttribute("2")]
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason);
    [EventAttribute("3")]
internal void BufferReturned(int bufferId, int bufferSize, int poolId);
}
internal static class System.Buffers.Binary.BinaryPrimitives : object {
    [CLSCompliantAttribute("False")]
public static sbyte ReverseEndianness(sbyte value);
    public static short ReverseEndianness(short value);
    public static int ReverseEndianness(int value);
    public static long ReverseEndianness(long value);
    public static byte ReverseEndianness(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ReverseEndianness(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ReverseEndianness(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ReverseEndianness(ulong value);
    public static short ReadInt16BigEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32BigEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static short ReadInt16LittleEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32LittleEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static void WriteInt16BigEndian(Span`1<byte> destination, short value);
    public static void WriteInt32BigEndian(Span`1<byte> destination, int value);
    public static void WriteInt64BigEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    public static bool TryWriteInt16BigEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32BigEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64BigEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    public static void WriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static void WriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static void WriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
    public static bool TryWriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
}
[ExtensionAttribute]
internal static class System.Buffers.BuffersExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SequencePosition> PositionOf(ReadOnlySequence`1& source, T value);
    private static Nullable`1<SequencePosition> PositionOfMultiSegment(ReadOnlySequence`1& source, T value);
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySequence`1& source, Span`1<T> destination);
    private static void CopyToMultiSegment(ReadOnlySequence`1& sequence, Span`1<T> destination);
    [ExtensionAttribute]
public static T[] ToArray(ReadOnlySequence`1& sequence);
    [ExtensionAttribute]
public static void Write(IBufferWriter`1<T> writer, ReadOnlySpan`1<T> value);
    private static void WriteMultiSegment(IBufferWriter`1<T> writer, ReadOnlySpan`1& source, Span`1<T> destination);
}
internal class System.Buffers.DefaultArrayPool`1 : ArrayPool`1<T> {
    private static int DefaultMaxArrayLength;
    private static int DefaultMaxNumberOfArraysPerBucket;
    private static T[] s_emptyArray;
    private Bucket[] _buckets;
    private int Id { get; }
    internal DefaultArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
internal interface System.Buffers.IBufferWriter`1 {
    public abstract virtual void Advance(int count);
    public abstract virtual Memory`1<T> GetMemory(int sizeHint);
    public abstract virtual Span`1<T> GetSpan(int sizeHint);
}
internal interface System.Buffers.IMemoryOwner`1 {
    public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
public interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
public class System.Buffers.MemoryHandle : ValueType {
    private Void* _pointer;
    private GCHandle _handle;
    private IPinnable _pinnable;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
internal abstract class System.Buffers.MemoryManager`1 : object {
    public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal abstract class System.Buffers.MemoryPool`1 : object {
    private static MemoryPool`1<T> s_shared;
    public static MemoryPool`1<T> Shared { get; }
    public int MaxBufferSize { get; }
    private static MemoryPool`1();
    public static MemoryPool`1<T> get_Shared();
    public abstract virtual IMemoryOwner`1<T> Rent(int minBufferSize);
    public abstract virtual int get_MaxBufferSize();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal enum System.Buffers.OperationStatus : Enum {
    public int value__;
    public static OperationStatus Done;
    public static OperationStatus DestinationTooSmall;
    public static OperationStatus NeedMoreData;
    public static OperationStatus InvalidData;
}
internal static class System.Buffers.ReadOnlySequence : object {
    public static int FlagBitMask;
    public static int IndexBitMask;
    public static int SegmentStartMask;
    public static int SegmentEndMask;
    public static int ArrayStartMask;
    public static int ArrayEndMask;
    public static int MemoryManagerStartMask;
    public static int MemoryManagerEndMask;
    public static int StringStartMask;
    public static int StringEndMask;
    public static int SegmentToSequenceStart(int startIndex);
    public static int SegmentToSequenceEnd(int endIndex);
    public static int ArrayToSequenceStart(int startIndex);
    public static int ArrayToSequenceEnd(int endIndex);
    public static int MemoryManagerToSequenceStart(int startIndex);
    public static int MemoryManagerToSequenceEnd(int endIndex);
    public static int StringToSequenceStart(int startIndex);
    public static int StringToSequenceEnd(int endIndex);
}
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.Buffers.ReadOnlySequenceDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.Buffers.ReadOnlySequence`1 : ValueType {
    private SequencePosition _sequenceStart;
    private SequencePosition _sequenceEnd;
    public static ReadOnlySequence`1<T> Empty;
    public long Length { get; }
    public bool IsEmpty { get; }
    public bool IsSingleSegment { get; }
    public ReadOnlyMemory`1<T> First { get; }
    public SequencePosition Start { get; }
    public SequencePosition End { get; }
    private ReadOnlySequence`1(object startSegment, int startIndexAndFlags, object endSegment, int endIndexAndFlags);
    public ReadOnlySequence`1(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment, int endIndex);
    public ReadOnlySequence`1(T[] array);
    public ReadOnlySequence`1(T[] array, int start, int length);
    public ReadOnlySequence`1(ReadOnlyMemory`1<T> memory);
    private static ReadOnlySequence`1();
    public long get_Length();
    public bool get_IsEmpty();
    public bool get_IsSingleSegment();
    public ReadOnlyMemory`1<T> get_First();
    public SequencePosition get_Start();
    public SequencePosition get_End();
    public ReadOnlySequence`1<T> Slice(long start, long length);
    public ReadOnlySequence`1<T> Slice(long start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, long length);
    public ReadOnlySequence`1<T> Slice(int start, int length);
    public ReadOnlySequence`1<T> Slice(int start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, int length);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start);
    public ReadOnlySequence`1<T> Slice(long start);
    public virtual string ToString();
    public Enumerator<T> GetEnumerator();
    public SequencePosition GetPosition(long offset);
    public SequencePosition GetPosition(long offset, SequencePosition origin);
    public bool TryGet(SequencePosition& position, ReadOnlyMemory`1& memory, bool advance);
    internal bool TryGetBuffer(SequencePosition& position, ReadOnlyMemory`1& memory, SequencePosition& next);
    private ReadOnlyMemory`1<T> GetFirstBuffer();
    private SequencePosition Seek(SequencePosition& start, SequencePosition& end, long offset, <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument argument);
    private static SequencePosition SeekMultiSegment(ReadOnlySequenceSegment`1<T> currentSegment, object endObject, int endIndex, long offset, <805945f3-27b0-47ad-b8f6-389d9d8f82c3>ExceptionArgument argument);
    private void BoundsCheck(SequencePosition& position);
    private void BoundsCheck(UInt32 sliceStartIndex, object sliceStartObject, UInt32 sliceEndIndex, object sliceEndObject);
    private static SequencePosition GetEndPosition(ReadOnlySequenceSegment`1<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length);
    private SequenceType<T> GetSequenceType();
    private static int GetIndex(SequencePosition& position);
    private ReadOnlySequence`1<T> SliceImpl(SequencePosition& start, SequencePosition& end);
    private long GetLength();
    internal bool TryGetReadOnlySequenceSegment(ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    internal bool TryGetArray(ArraySegment`1& segment);
    internal bool TryGetString(String& text, Int32& start, Int32& length);
    private static bool InRange(UInt32 value, UInt32 start, UInt32 end);
    private static bool InRange(ulong value, ulong start, ulong end);
}
internal class System.Buffers.ReadOnlySequenceDebugView`1 : object {
    private T[] _array;
    private ReadOnlySequenceDebugViewSegments<T> _segments;
    public ReadOnlySequenceDebugViewSegments<T> BufferSegments { get; }
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ReadOnlySequenceDebugView`1(ReadOnlySequence`1<T> sequence);
    public ReadOnlySequenceDebugViewSegments<T> get_BufferSegments();
    public T[] get_Items();
}
public abstract class System.Buffers.ReadOnlySequenceSegment`1 : object {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<T> <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequenceSegment`1<T> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RunningIndex>k__BackingField;
    public ReadOnlyMemory`1<T> Memory { get; protected set; }
    public ReadOnlySequenceSegment`1<T> Next { get; protected set; }
    public long RunningIndex { get; protected set; }
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<T> get_Memory();
    [CompilerGeneratedAttribute]
protected void set_Memory(ReadOnlyMemory`1<T> value);
    [CompilerGeneratedAttribute]
public ReadOnlySequenceSegment`1<T> get_Next();
    [CompilerGeneratedAttribute]
protected void set_Next(ReadOnlySequenceSegment`1<T> value);
    [CompilerGeneratedAttribute]
public long get_RunningIndex();
    [CompilerGeneratedAttribute]
protected void set_RunningIndex(long value);
}
[IsReadOnlyAttribute]
internal class System.Buffers.StandardFormat : ValueType {
    public static byte NoPrecision;
    public static byte MaxPrecision;
    private byte _format;
    private byte _precision;
    public char Symbol { get; }
    public byte Precision { get; }
    public bool HasPrecision { get; }
    public bool IsDefault { get; }
    public StandardFormat(char symbol, byte precision);
    public char get_Symbol();
    public byte get_Precision();
    public bool get_HasPrecision();
    public bool get_IsDefault();
    public static StandardFormat op_Implicit(char symbol);
    public static StandardFormat Parse(ReadOnlySpan`1<char> format);
    public static StandardFormat Parse(string format);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(StandardFormat other);
    public virtual string ToString();
    public static bool op_Equality(StandardFormat left, StandardFormat right);
    public static bool op_Inequality(StandardFormat left, StandardFormat right);
}
internal static class System.Buffers.Text.Base64 : object {
    private static SByte[] s_decodingMap;
    private static Byte[] s_encodingMap;
    private static byte EncodingPad;
    private static int MaximumEncodeLength;
    private static Base64();
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static int GetMaxDecodedFromUtf8Length(int length);
    public static OperationStatus DecodeFromUtf8InPlace(Span`1<byte> buffer, Int32& bytesWritten);
    private static int Decode(Byte& encodedBytes, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
    public static OperationStatus EncodeToUtf8(ReadOnlySpan`1<byte> bytes, Span`1<byte> utf8, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static int GetMaxEncodedToUtf8Length(int length);
    public static OperationStatus EncodeToUtf8InPlace(Span`1<byte> buffer, int dataLength, Int32& bytesWritten);
    private static int Encode(Byte& threeBytes, Byte& encodingMap);
    private static int EncodeAndPadOne(Byte& twoBytes, Byte& encodingMap);
    private static int EncodeAndPadTwo(Byte& oneByte, Byte& encodingMap);
}
internal static class System.Buffers.Text.FormattingHelpers : object {
    internal static string HexTableLower;
    internal static string HexTableUpper;
    public static char GetSymbolOrDefault(StandardFormat& format, char defaultSymbol);
    public static void FillWithAsciiZeros(Span`1<byte> buffer);
    public static void WriteHexByte(byte value, Span`1<byte> buffer, int startingIndex, HexCasing casing);
    public static void WriteDigits(ulong value, Span`1<byte> buffer);
    public static void WriteDigitsWithGroupSeparator(ulong value, Span`1<byte> buffer);
    public static void WriteDigits(UInt32 value, Span`1<byte> buffer);
    public static void WriteFourDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex);
    public static void WriteTwoDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex);
    public static ulong DivMod(ulong numerator, ulong denominator, UInt64& modulo);
    public static UInt32 DivMod(UInt32 numerator, UInt32 denominator, UInt32& modulo);
    public static int CountDecimalTrailingZeros(UInt32 value, UInt32& valueWithoutTrailingZeros);
    public static int CountDigits(ulong value);
    public static int CountDigits(UInt32 value);
    public static int CountHexDigits(ulong value);
}
internal static class System.Buffers.Text.ParserHelpers : object {
    public static int ByteOverflowLength;
    public static int ByteOverflowLengthHex;
    public static int UInt16OverflowLength;
    public static int UInt16OverflowLengthHex;
    public static int UInt32OverflowLength;
    public static int UInt32OverflowLengthHex;
    public static int UInt64OverflowLength;
    public static int UInt64OverflowLengthHex;
    public static int SByteOverflowLength;
    public static int SByteOverflowLengthHex;
    public static int Int16OverflowLength;
    public static int Int16OverflowLengthHex;
    public static int Int32OverflowLength;
    public static int Int32OverflowLengthHex;
    public static int Int64OverflowLength;
    public static int Int64OverflowLengthHex;
    public static Byte[] s_hexLookup;
    private static ParserHelpers();
    public static bool IsDigit(int i);
}
internal static class System.Buffers.Text.Utf8Constants : object {
    public static byte Colon;
    public static byte Comma;
    public static byte Minus;
    public static byte Period;
    public static byte Plus;
    public static byte Slash;
    public static byte Space;
    public static byte Hyphen;
    public static byte Separator;
    public static int GroupSize;
    public static TimeSpan s_nullUtcOffset;
    public static int DateTimeMaxUtcOffsetHours;
    public static int DateTimeNumFractionDigits;
    public static int MaxDateTimeFraction;
    public static ulong BillionMaxUIntValue;
    public static UInt32 Billion;
    private static Utf8Constants();
}
internal static class System.Buffers.Text.Utf8Formatter : object {
    private static byte TimeMarker;
    private static byte UtcMarker;
    private static byte GMT1;
    private static byte GMT2;
    private static byte GMT3;
    private static byte GMT1Lowercase;
    private static byte GMT2Lowercase;
    private static byte GMT3Lowercase;
    private static UInt32[] DayAbbreviations;
    private static UInt32[] DayAbbreviationsLowercase;
    private static UInt32[] MonthAbbreviations;
    private static UInt32[] MonthAbbreviationsLowercase;
    private static byte OpenBrace;
    private static byte CloseBrace;
    private static byte OpenParen;
    private static byte CloseParen;
    private static byte Dash;
    private static Utf8Formatter();
    public static bool TryFormat(bool value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTimeOffset value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTime value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDateTimeG(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeO(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeR(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeL(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(decimal value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDecimalE(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision, byte exponentSymbol);
    private static bool TryFormatDecimalF(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision);
    private static bool TryFormatDecimalG(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(double value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(float value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatFloatingPoint(T value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(Guid value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(byte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(sbyte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ushort value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(short value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(UInt32 value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(int value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(long value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatInt64(long value, ulong mask, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatInt64D(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64Default(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt32Default(int value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt32MultipleDigits(int value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64MultipleDigits(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64MoreThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64LessThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64N(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatUInt64D(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten);
    private static bool TryFormatUInt64Default(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32Default(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32SingleDigit(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32MultipleDigits(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64SingleDigit(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64MultipleDigits(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64LessThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64MoreThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64N(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten);
    private static bool TryFormatUInt64X(ulong value, byte precision, bool useLower, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(TimeSpan value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
}
internal static class System.Buffers.Text.Utf8Parser : object {
    private static UInt32 FlipCase;
    private static UInt32 NoFlipCase;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    private static Utf8Parser();
    public static bool TryParse(ReadOnlySpan`1<byte> source, Boolean& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTime& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseDateTimeOffsetDefault(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed);
    private static bool TryParseDateTimeG(ReadOnlySpan`1<byte> source, DateTime& value, DateTimeOffset& valueAsOffset, Int32& bytesConsumed);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(int year, int month, int day, int hour, int minute, int second, int fraction, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeOffset& value);
    private static bool TryCreateDateTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeKind kind, DateTime& value);
    private static bool TryParseDateTimeOffsetO(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, DateTimeKind& kind);
    private static bool TryParseDateTimeOffsetR(ReadOnlySpan`1<byte> source, UInt32 caseFlipXorMask, DateTimeOffset& dateTimeOffset, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Decimal& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Single& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseNormalAsFloatingPoint(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseAsSpecialFloatingPoint(ReadOnlySpan`1<byte> source, T positiveInfinity, T negativeInfinity, T nan, T& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseGuidN(ReadOnlySpan`1<byte> text, Guid& value, Int32& bytesConsumed);
    private static bool TryParseGuidCore(ReadOnlySpan`1<byte> source, bool ends, char begin, char end, Guid& value, Int32& bytesConsumed);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseSByteD(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16D(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32D(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64D(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    private static bool TryParseSByteN(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16N(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32N(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64N(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseByteD(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16D(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32D(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64D(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteN(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16N(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32N(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64N(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteX(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16X(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32X(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64X(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseNumber(ReadOnlySpan`1<byte> source, NumberBuffer& number, Int32& bytesConsumed, ParseNumberOptions options, Boolean& textUsedExponentNotation);
    private static bool TryParseTimeSpanBigG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    private static bool TryParseTimeSpanC(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseTimeSpanFraction(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryCreateTimeSpan(bool isNegative, UInt32 days, UInt32 hours, UInt32 minutes, UInt32 seconds, UInt32 fraction, TimeSpan& timeSpan);
    private static bool TryParseTimeSpanLittleG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
}
internal interface System.Collections.Concurrent.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual int GetCountSafe(object syncObj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Concurrent.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Collections.Concurrent.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Collections.Concurrent.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Collections.Concurrent.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Collections.Concurrent.IProducerConsumerQueue<T>.get_Count();
    private sealed virtual override int System.Collections.Concurrent.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1 : object {
    private static int InitialSegmentSize;
    private static int MaxSegmentSize;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    public bool TryPeek(T& result);
    private bool TryDequeueSlow(Segment<T> segment, T[] array, bool peek, T& result);
    public bool TryDequeueIf(Predicate`1<T> predicate, T& result);
    private bool TryDequeueIfSlow(Predicate`1<T> predicate, Segment<T> segment, T[] array, T& result);
    public void Clear();
    public sealed virtual bool get_IsEmpty();
    [IteratorStateMachineAttribute("System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1/<GetEnumerator>d__15")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override int System.Collections.Concurrent.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
[DebuggerDisplayAttribute("Count = {_size}")]
internal class System.Collections.Generic.Deque`1 : object {
    private T[] _array;
    private int _head;
    private int _tail;
    private int _size;
    public int Count { get; }
    public bool IsEmpty { get; }
    public int get_Count();
    public bool get_IsEmpty();
    public void EnqueueTail(T item);
    public T DequeueHead();
    public T PeekHead();
    public T PeekTail();
    public T DequeueTail();
    [IteratorStateMachineAttribute("System.Collections.Generic.Deque`1/<GetEnumerator>d__13")]
public IEnumerator`1<T> GetEnumerator();
    private void Grow();
}
internal static class System.DecimalDecCalc : object {
    private static UInt32 D32DivMod1E9(UInt32 hi32, UInt32& lo32);
    internal static UInt32 DecDivMod1E9(MutableDecimal& value);
    internal static void DecAddInt32(MutableDecimal& value, UInt32 i);
    private static bool D32AddCarry(UInt32& value, UInt32 i);
    internal static void DecMul10(MutableDecimal& value);
    private static void DecShiftLeft(MutableDecimal& value);
    private static void DecAdd(MutableDecimal& value, MutableDecimal d);
}
[AttributeUsageAttribute("108")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Diagnostics.<02d5b7fd-c5c5-4143-9044-935b13098f35>StackTraceHiddenAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Diagnostics.Activity : object {
    private static IEnumerable`1<KeyValuePair`2<string, string>> s_emptyBaggageTags;
    private static IEnumerable`1<KeyValuePair`2<string, object>> s_emptyTagObjects;
    private static IEnumerable`1<ActivityLink> s_emptyLinks;
    private static IEnumerable`1<ActivityEvent> s_emptyEvents;
    private static ActivitySource s_defaultSource;
    private static byte ActivityTraceFlagsIsSet;
    private static int RequestIdMaxLength;
    private static string s_uniqSuffix;
    private static long s_currentRootId;
    private static ActivityIdFormat s_defaultIdFormat;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ActivityChangedEventArgs> CurrentChanged;
    [CompilerGeneratedAttribute]
private static bool <ForceDefaultIdFormat>k__BackingField;
    private string _traceState;
    private State _state;
    private int _currentChildId;
    private string _id;
    private string _rootId;
    private string _parentId;
    private string _parentSpanId;
    private string _traceId;
    private string _spanId;
    private byte _w3CIdFlags;
    private byte _parentTraceFlags;
    private TagsLinkedList _tags;
    private BaggageLinkedList _baggage;
    private DiagLinkedList`1<ActivityLink> _links;
    private DiagLinkedList`1<ActivityEvent> _events;
    private Dictionary`2<string, object> _customProperties;
    private string _displayName;
    private ActivityStatusCode _statusCode;
    private string _statusDescription;
    private Activity _previousActiveActivity;
    [CompilerGeneratedAttribute]
private bool <HasRemoteParent>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivitySource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Activity <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAllDataRequested>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`1<ActivityTraceId> <TraceIdGenerator>k__BackingField;
    private static AsyncLocal`1<Activity> s_current;
    private static TimeSync timeSync;
    private static Timer syncTimeUpdater;
    public static bool ForceDefaultIdFormat { get; public set; }
    public ActivityStatusCode Status { get; }
    [NullableAttribute("2")]
public string StatusDescription { get; }
    public bool HasRemoteParent { get; private set; }
    public ActivityKind Kind { get; private set; }
    public string OperationName { get; }
    public string DisplayName { get; public set; }
    public ActivitySource Source { get; private set; }
    [NullableAttribute("2")]
public Activity Parent { get; private set; }
    public TimeSpan Duration { get; private set; }
    public DateTime StartTimeUtc { get; private set; }
    [NullableAttribute("2")]
public string Id { get; }
    [NullableAttribute("2")]
public string ParentId { get; }
    [NullableAttribute("2")]
public string RootId { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> Tags { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> TagObjects { get; }
    public IEnumerable`1<ActivityEvent> Events { get; }
    public IEnumerable`1<ActivityLink> Links { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> Baggage { get; }
    public ActivityContext Context { get; }
    [NullableAttribute("2")]
public string TraceStateString { get; public set; }
    public ActivitySpanId SpanId { get; }
    public ActivityTraceId TraceId { get; }
    public bool Recorded { get; }
    public bool IsAllDataRequested { get; public set; }
    public ActivityTraceFlags ActivityTraceFlags { get; public set; }
    public ActivitySpanId ParentSpanId { get; }
    [NullableAttribute("2")]
public static Func`1<ActivityTraceId> TraceIdGenerator { get; public set; }
    public static ActivityIdFormat DefaultIdFormat { get; public set; }
    private bool W3CIdFlagsSet { get; }
    public bool IsStopped { get; private set; }
    public ActivityIdFormat IdFormat { get; private set; }
    [NullableAttribute("2")]
public static Activity Current { get; public set; }
    public Activity(string operationName);
    private static Activity();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void add_CurrentChanged(EventHandler`1<ActivityChangedEventArgs> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void remove_CurrentChanged(EventHandler`1<ActivityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static bool get_ForceDefaultIdFormat();
    [CompilerGeneratedAttribute]
public static void set_ForceDefaultIdFormat(bool value);
    public ActivityStatusCode get_Status();
    [NullableContextAttribute("2")]
public string get_StatusDescription();
    [CompilerGeneratedAttribute]
public bool get_HasRemoteParent();
    [CompilerGeneratedAttribute]
private void set_HasRemoteParent(bool value);
    public Activity SetStatus(ActivityStatusCode code, string description);
    [CompilerGeneratedAttribute]
public ActivityKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(ActivityKind value);
    [CompilerGeneratedAttribute]
public string get_OperationName();
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public ActivitySource get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(ActivitySource value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Activity get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(Activity value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
private void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTimeUtc();
    [CompilerGeneratedAttribute]
private void set_StartTimeUtc(DateTime value);
    [NullableContextAttribute("2")]
public string get_Id();
    [NullableContextAttribute("2")]
public string get_ParentId();
    [NullableContextAttribute("2")]
public string get_RootId();
    public IEnumerable`1<KeyValuePair`2<string, string>> get_Tags();
    public IEnumerable`1<KeyValuePair`2<string, object>> get_TagObjects();
    public IEnumerable`1<ActivityEvent> get_Events();
    public IEnumerable`1<ActivityLink> get_Links();
    public IEnumerable`1<KeyValuePair`2<string, string>> get_Baggage();
    public Enumerator`1<KeyValuePair`2<string, object>> EnumerateTagObjects();
    [NullableContextAttribute("0")]
public Enumerator`1<ActivityEvent> EnumerateEvents();
    [NullableContextAttribute("0")]
public Enumerator`1<ActivityLink> EnumerateLinks();
    public string GetBaggageItem(string key);
    public object GetTagItem(string key);
    public Activity AddTag(string key, string value);
    public Activity AddTag(string key, object value);
    public Activity SetTag(string key, object value);
    public Activity AddEvent(ActivityEvent e);
    public Activity AddBaggage(string key, string value);
    public Activity SetBaggage(string key, string value);
    public Activity SetParentId(string parentId);
    public Activity SetParentId(ActivityTraceId traceId, ActivitySpanId spanId, ActivityTraceFlags activityTraceFlags);
    public Activity SetStartTime(DateTime startTimeUtc);
    public Activity SetEndTime(DateTime endTimeUtc);
    public ActivityContext get_Context();
    public Activity Start();
    public void Stop();
    [NullableContextAttribute("2")]
public string get_TraceStateString();
    [NullableContextAttribute("2")]
public void set_TraceStateString(string value);
    public ActivitySpanId get_SpanId();
    public ActivityTraceId get_TraceId();
    public bool get_Recorded();
    [CompilerGeneratedAttribute]
public bool get_IsAllDataRequested();
    [CompilerGeneratedAttribute]
public void set_IsAllDataRequested(bool value);
    public ActivityTraceFlags get_ActivityTraceFlags();
    public void set_ActivityTraceFlags(ActivityTraceFlags value);
    public ActivitySpanId get_ParentSpanId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static Func`1<ActivityTraceId> get_TraceIdGenerator();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_TraceIdGenerator(Func`1<ActivityTraceId> value);
    public static ActivityIdFormat get_DefaultIdFormat();
    public static void set_DefaultIdFormat(ActivityIdFormat value);
    public Activity SetIdFormat(ActivityIdFormat format);
    private static bool IsW3CId(string id);
    internal static bool TryConvertIdToContext(string traceParent, string traceState, bool isRemote, ActivityContext& context);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetCustomProperty(string propertyName, object propertyValue);
    public object GetCustomProperty(string propertyName);
    internal static Activity Create(ActivitySource source, string name, ActivityKind kind, string parentId, ActivityContext parentContext, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime, ActivityTagsCollection samplerTags, ActivitySamplingResult request, bool startIt, ActivityIdFormat idFormat, string traceState);
    private void GenerateW3CId();
    private static void NotifyError(Exception exception);
    private string GenerateHierarchicalId();
    private string GetRootId(string id);
    private string AppendSuffix(string parentId, string suffix, char delimiter);
    private static long GetRandomNumber();
    private static bool ValidateSetCurrent(Activity activity);
    private bool TrySetTraceIdFromParent();
    private void TrySetTraceFlagsFromParent();
    private bool get_W3CIdFlagsSet();
    public bool get_IsStopped();
    private void set_IsStopped(bool value);
    public ActivityIdFormat get_IdFormat();
    private void set_IdFormat(ActivityIdFormat value);
    [NullableContextAttribute("2")]
public static Activity get_Current();
    [NullableContextAttribute("2")]
public static void set_Current(Activity value);
    private static void SetCurrent(Activity activity);
    private static string GenerateRootId();
    internal static DateTime GetUtcNow();
    private static void Sync();
    [SecuritySafeCriticalAttribute]
private static Timer InitializeSyncTimer();
    [IteratorStateMachineAttribute("System.Diagnostics.Activity/<<get_Baggage>g__Iterate|87_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<KeyValuePair`2<string, string>> <get_Baggage>g__Iterate|87_0(Activity activity);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.Diagnostics.ActivityChangedEventArgs : ValueType {
    [CompilerGeneratedAttribute]
private Activity <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private Activity <Current>k__BackingField;
    public Activity Previous { get; public set; }
    public Activity Current { get; public set; }
    internal ActivityChangedEventArgs(Activity previous, Activity current);
    [CompilerGeneratedAttribute]
public Activity get_Previous();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Previous(Activity value);
    [CompilerGeneratedAttribute]
public Activity get_Current();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Current(Activity value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.Diagnostics.ActivityContext : ValueType {
    [CompilerGeneratedAttribute]
private ActivityTraceId <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivitySpanId <SpanId>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityTraceFlags <TraceFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRemote>k__BackingField;
    public ActivityTraceId TraceId { get; }
    public ActivitySpanId SpanId { get; }
    public ActivityTraceFlags TraceFlags { get; }
    public string TraceState { get; }
    public bool IsRemote { get; }
    public ActivityContext(ActivityTraceId traceId, ActivitySpanId spanId, ActivityTraceFlags traceFlags, string traceState, bool isRemote);
    [CompilerGeneratedAttribute]
public ActivityTraceId get_TraceId();
    [CompilerGeneratedAttribute]
public ActivitySpanId get_SpanId();
    [CompilerGeneratedAttribute]
public ActivityTraceFlags get_TraceFlags();
    [CompilerGeneratedAttribute]
public string get_TraceState();
    [CompilerGeneratedAttribute]
public bool get_IsRemote();
    public static bool TryParse(string traceParent, string traceState, bool isRemote, ActivityContext& context);
    public static bool TryParse(string traceParent, string traceState, ActivityContext& context);
    [NullableContextAttribute("1")]
public static ActivityContext Parse(string traceParent, string traceState);
    public sealed virtual bool Equals(ActivityContext value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(ActivityContext left, ActivityContext right);
    public static bool op_Inequality(ActivityContext left, ActivityContext right);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.Diagnostics.ActivityCreationOptions`1 : ValueType {
    private ActivityTagsCollection _samplerTags;
    private ActivityContext _context;
    private string _traceState;
    [CompilerGeneratedAttribute]
private ActivitySource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ActivityLink> <Links>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityIdFormat <IdFormat>k__BackingField;
    public ActivitySource Source { get; }
    public string Name { get; }
    public ActivityKind Kind { get; }
    public T Parent { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Tags { get; }
    [NullableAttribute("2")]
public IEnumerable`1<ActivityLink> Links { get; }
    public ActivityTagsCollection SamplingTags { get; }
    public ActivityTraceId TraceId { get; }
    [NullableAttribute("2")]
public string TraceState { get; public set; }
    internal ActivityIdFormat IdFormat { get; }
    internal ActivityCreationOptions`1(ActivitySource source, string name, T parent, ActivityKind kind, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, ActivityIdFormat idFormat);
    [CompilerGeneratedAttribute]
public ActivitySource get_Source();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ActivityKind get_Kind();
    [CompilerGeneratedAttribute]
public T get_Parent();
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IEnumerable`1<ActivityLink> get_Links();
    public ActivityTagsCollection get_SamplingTags();
    public ActivityTraceId get_TraceId();
    [NullableContextAttribute("2")]
public string get_TraceState();
    [NullableContextAttribute("2")]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TraceState(string value);
    internal void SetTraceState(string traceState);
    [CompilerGeneratedAttribute]
internal ActivityIdFormat get_IdFormat();
    internal ActivityTagsCollection GetSamplingTags();
    internal ActivityContext GetContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.Diagnostics.ActivityEvent : ValueType {
    private static IEnumerable`1<KeyValuePair`2<string, object>> s_emptyTags;
    private TagsLinkedList _tags;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    public string Name { get; }
    public DateTimeOffset Timestamp { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Tags { get; }
    public ActivityEvent(string name);
    public ActivityEvent(string name, DateTimeOffset timestamp, ActivityTagsCollection tags);
    private static ActivityEvent();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags();
    public Enumerator`1<KeyValuePair`2<string, object>> EnumerateTagObjects();
}
internal enum System.Diagnostics.ActivityIdFormat : Enum {
    public int value__;
    public static ActivityIdFormat Unknown;
    public static ActivityIdFormat Hierarchical;
    public static ActivityIdFormat W3C;
}
internal enum System.Diagnostics.ActivityKind : Enum {
    public int value__;
    public static ActivityKind Internal;
    public static ActivityKind Server;
    public static ActivityKind Client;
    public static ActivityKind Producer;
    public static ActivityKind Consumer;
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.ActivityLink : ValueType {
    private TagsLinkedList _tags;
    [CompilerGeneratedAttribute]
private ActivityContext <Context>k__BackingField;
    public ActivityContext Context { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Tags { get; }
    [NullableContextAttribute("2")]
public ActivityLink(ActivityContext context, ActivityTagsCollection tags);
    [CompilerGeneratedAttribute]
public ActivityContext get_Context();
    public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ActivityLink value);
    public static bool op_Equality(ActivityLink left, ActivityLink right);
    public static bool op_Inequality(ActivityLink left, ActivityLink right);
    public Enumerator`1<KeyValuePair`2<string, object>> EnumerateTagObjects();
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Diagnostics.ActivityListener : object {
    [CompilerGeneratedAttribute]
private Action`1<Activity> <ActivityStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Activity> <ActivityStopped>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ActivitySource, bool> <ShouldListenTo>k__BackingField;
    [CompilerGeneratedAttribute]
private SampleActivity`1<string> <SampleUsingParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private SampleActivity`1<ActivityContext> <Sample>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<Activity> ActivityStarted { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<Activity> ActivityStopped { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<ActivitySource, bool> ShouldListenTo { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SampleActivity`1<string> SampleUsingParentId { get; public set; }
    public SampleActivity`1<ActivityContext> Sample { get; public set; }
    [CompilerGeneratedAttribute]
public Action`1<Activity> get_ActivityStarted();
    [CompilerGeneratedAttribute]
public void set_ActivityStarted(Action`1<Activity> value);
    [CompilerGeneratedAttribute]
public Action`1<Activity> get_ActivityStopped();
    [CompilerGeneratedAttribute]
public void set_ActivityStopped(Action`1<Activity> value);
    [CompilerGeneratedAttribute]
public Func`2<ActivitySource, bool> get_ShouldListenTo();
    [CompilerGeneratedAttribute]
public void set_ShouldListenTo(Func`2<ActivitySource, bool> value);
    [CompilerGeneratedAttribute]
public SampleActivity`1<string> get_SampleUsingParentId();
    [CompilerGeneratedAttribute]
public void set_SampleUsingParentId(SampleActivity`1<string> value);
    [CompilerGeneratedAttribute]
public SampleActivity`1<ActivityContext> get_Sample();
    [CompilerGeneratedAttribute]
public void set_Sample(SampleActivity`1<ActivityContext> value);
    public sealed virtual void Dispose();
}
internal enum System.Diagnostics.ActivitySamplingResult : Enum {
    public int value__;
    public static ActivitySamplingResult None;
    public static ActivitySamplingResult PropagationData;
    public static ActivitySamplingResult AllData;
    public static ActivitySamplingResult AllDataAndRecorded;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Diagnostics.ActivitySource : object {
    private static SynchronizedList`1<ActivitySource> s_activeSources;
    private static SynchronizedList`1<ActivityListener> s_allListeners;
    private SynchronizedList`1<ActivityListener> _listeners;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; }
    public string Version { get; }
    [NullableContextAttribute("1")]
public ActivitySource(string name, string version);
    private static ActivitySource();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    public bool HasListeners();
    [NullableContextAttribute("1")]
public Activity CreateActivity(string name, ActivityKind kind);
    public Activity CreateActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, ActivityIdFormat idFormat);
    public Activity CreateActivity(string name, ActivityKind kind, string parentId, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, ActivityIdFormat idFormat);
    [NullableContextAttribute("1")]
public Activity StartActivity(string name, ActivityKind kind);
    public Activity StartActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime);
    public Activity StartActivity(string name, ActivityKind kind, string parentId, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime);
    public Activity StartActivity(ActivityKind kind, ActivityContext parentContext, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime, string name);
    private Activity CreateActivity(string name, ActivityKind kind, ActivityContext context, string parentId, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime, bool startIt, ActivityIdFormat idFormat);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public static void AddActivityListener(ActivityListener listener);
    internal void AddListener(ActivityListener listener);
    internal static void DetachListener(ActivityListener listener);
    internal void NotifyActivityStart(Activity activity);
    internal void NotifyActivityStop(Activity activity);
}
[IsReadOnlyAttribute]
public class System.Diagnostics.ActivitySpanId : ValueType {
    private string _hexString;
    internal ActivitySpanId(string hexString);
    private ActivitySpanId(ReadOnlySpan`1<byte> idData);
    public static ActivitySpanId CreateRandom();
    public static ActivitySpanId CreateFromBytes(ReadOnlySpan`1<byte> idData);
    public static ActivitySpanId CreateFromUtf8String(ReadOnlySpan`1<byte> idData);
    public static ActivitySpanId CreateFromString(ReadOnlySpan`1<char> idData);
    [NullableContextAttribute("1")]
public string ToHexString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(ActivitySpanId spanId1, ActivitySpanId spandId2);
    public static bool op_Inequality(ActivitySpanId spanId1, ActivitySpanId spandId2);
    public sealed virtual bool Equals(ActivitySpanId spanId);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void CopyTo(Span`1<byte> destination);
}
internal enum System.Diagnostics.ActivityStatusCode : Enum {
    public int value__;
    public static ActivityStatusCode Unset;
    public static ActivityStatusCode Ok;
    public static ActivityStatusCode Error;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.ActivityTagsCollection : object {
    private List`1<KeyValuePair`2<string, object>> _list;
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ICollection`1<object> Values { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public ActivityTagsCollection(IEnumerable`1<KeyValuePair`2<string, object>> list);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual bool TryGetValue(string key, Object& value);
    private int FindIndex(string key);
}
[FlagsAttribute]
internal enum System.Diagnostics.ActivityTraceFlags : Enum {
    public int value__;
    public static ActivityTraceFlags None;
    public static ActivityTraceFlags Recorded;
}
[IsReadOnlyAttribute]
public class System.Diagnostics.ActivityTraceId : ValueType {
    private string _hexString;
    internal ActivityTraceId(string hexString);
    private ActivityTraceId(ReadOnlySpan`1<byte> idData);
    public static ActivityTraceId CreateRandom();
    public static ActivityTraceId CreateFromBytes(ReadOnlySpan`1<byte> idData);
    public static ActivityTraceId CreateFromUtf8String(ReadOnlySpan`1<byte> idData);
    public static ActivityTraceId CreateFromString(ReadOnlySpan`1<char> idData);
    [NullableContextAttribute("1")]
public string ToHexString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(ActivityTraceId traceId1, ActivityTraceId traceId2);
    public static bool op_Inequality(ActivityTraceId traceId1, ActivityTraceId traceId2);
    public sealed virtual bool Equals(ActivityTraceId traceId);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void CopyTo(Span`1<byte> destination);
    internal static void SetToRandomBytes(Span`1<byte> outBytes);
    internal static void SetSpanFromHexChars(ReadOnlySpan`1<char> charData, Span`1<byte> outBytes);
    internal static byte HexByteFromChars(char char1, char char2);
    internal static bool IsLowerCaseHexAndNotAllZeros(ReadOnlySpan`1<char> idData);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Diagnostics.BitMapper : ValueType {
    private int _maxIndex;
    private Span`1<ulong> _bitMap;
    public int MaxIndex { get; }
    public BitMapper(Span`1<ulong> bitMap);
    public int get_MaxIndex();
    private static void GetIndexAndMask(int index, Int32& bitIndex, UInt64& mask);
    public bool SetBit(int index);
    public bool IsSet(int index);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <00a0ec1c-c599-48a4-a367-558b4bc25c9e>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <00a0ec1c-c599-48a4-a367-558b4bc25c9e>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <00a0ec1c-c599-48a4-a367-558b4bc25c9e>MemberNotNullAttribute(string member);
    public <00a0ec1c-c599-48a4-a367-558b4bc25c9e>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <00a0ec1c-c599-48a4-a367-558b4bc25c9e>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <00a0ec1c-c599-48a4-a367-558b4bc25c9e>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <00a0ec1c-c599-48a4-a367-558b4bc25c9e>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<00a0ec1c-c599-48a4-a367-558b4bc25c9e>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <00a0ec1c-c599-48a4-a367-558b4bc25c9e>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes MemberTypes { get; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMembersAttribute(<02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes None;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes PublicConstructors;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes PublicMethods;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes NonPublicMethods;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes PublicFields;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes NonPublicFields;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes PublicProperties;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes NonPublicProperties;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes PublicEvents;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes NonPublicEvents;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes Interfaces;
    public static <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicDependencyAttribute(<02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicDependencyAttribute(<02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>MemberNotNullAttribute(string member);
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public <02d5b7fd-c5c5-4143-9044-935b13098f35>RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Diagnostics.CodeAnalysis.<02d5b7fd-c5c5-4143-9044-935b13098f35>UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <46479ab8-036d-4c1c-b328-4eb77912d63f>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <46479ab8-036d-4c1c-b328-4eb77912d63f>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <46479ab8-036d-4c1c-b328-4eb77912d63f>MemberNotNullAttribute(string member);
    public <46479ab8-036d-4c1c-b328-4eb77912d63f>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <46479ab8-036d-4c1c-b328-4eb77912d63f>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <46479ab8-036d-4c1c-b328-4eb77912d63f>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <46479ab8-036d-4c1c-b328-4eb77912d63f>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<46479ab8-036d-4c1c-b328-4eb77912d63f>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <46479ab8-036d-4c1c-b328-4eb77912d63f>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("27072")]
internal class System.Diagnostics.CodeAnalysis.<b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes MemberTypes { get; }
    public <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMembersAttribute(<b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.<b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes None;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes PublicConstructors;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes PublicMethods;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes NonPublicMethods;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes PublicFields;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes NonPublicFields;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes PublicProperties;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes NonPublicProperties;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes PublicEvents;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes NonPublicEvents;
    public static <b1ce5518-75a7-49e1-b5f3-55f64e317762>DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <c2fae6d2-080d-4a2c-a14e-9249cd7f7473>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MemberNotNullAttribute(string member);
    public <c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <c2fae6d2-080d-4a2c-a14e-9249cd7f7473>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <c2fae6d2-080d-4a2c-a14e-9249cd7f7473>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<c2fae6d2-080d-4a2c-a14e-9249cd7f7473>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <c2fae6d2-080d-4a2c-a14e-9249cd7f7473>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <d09c9507-1983-461f-8fce-f8aba78858d6>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <d09c9507-1983-461f-8fce-f8aba78858d6>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <d09c9507-1983-461f-8fce-f8aba78858d6>MemberNotNullAttribute(string member);
    public <d09c9507-1983-461f-8fce-f8aba78858d6>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <d09c9507-1983-461f-8fce-f8aba78858d6>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <d09c9507-1983-461f-8fce-f8aba78858d6>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <d09c9507-1983-461f-8fce-f8aba78858d6>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<d09c9507-1983-461f-8fce-f8aba78858d6>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <d09c9507-1983-461f-8fce-f8aba78858d6>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <dd21e087-47d9-4bce-bed8-b56112226337>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("10688")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <dd21e087-47d9-4bce-bed8-b56112226337>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.<e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes MemberTypes { get; }
    public <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMembersAttribute(<e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.<e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes None;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes PublicConstructors;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes PublicMethods;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes NonPublicMethods;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes PublicFields;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes NonPublicFields;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes PublicProperties;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes NonPublicProperties;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes PublicEvents;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes NonPublicEvents;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes Interfaces;
    public static <e3de6295-26f3-406c-9ac2-b57cb0674f61>DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.<e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public <e3de6295-26f3-406c-9ac2-b57cb0674f61>RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.<e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public <e3de6295-26f3-406c-9ac2-b57cb0674f61>UnconditionalSuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    public DynamicDependencyAttribute(string memberSignature);
    public DynamicDependencyAttribute(string memberSignature, Type type);
    public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.ExperimentalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string DiagnosticId { get; }
    [NullableAttribute("2")]
public string UrlFormat { get; public set; }
    public ExperimentalAttribute(string diagnosticId);
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_UrlFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("736")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Diagnostics.CodeAnalysis.RequiresAssemblyFilesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public RequiresAssemblyFilesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("32")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("2240")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
internal class System.Diagnostics.DiagEnumerator`1 : ValueType {
    private static DiagNode`1<T> s_Empty;
    private DiagNode`1<T> _nextNode;
    private DiagNode`1<T> _currentNode;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public DiagEnumerator`1(DiagNode`1<T> head);
    private static DiagEnumerator`1();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
internal class System.Diagnostics.DiagLinkedList`1 : object {
    private DiagNode`1<T> _first;
    private DiagNode`1<T> _last;
    public DiagNode`1<T> First { get; }
    public DiagLinkedList`1(T firstValue);
    public DiagLinkedList`1(IEnumerator`1<T> e);
    public DiagNode`1<T> get_First();
    public void Clear();
    private void UnsafeAdd(DiagNode`1<T> newNode);
    public void Add(T value);
    public bool AddIfNotExist(T value, Func`3<T, T, bool> compare);
    public T Remove(T value, Func`3<T, T, bool> compare);
    public void AddFront(T value);
    public DiagEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Diagnostics.DiagNode`1 : object {
    public T Value;
    public DiagNode`1<T> Next;
    public DiagNode`1(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Diagnostics.DiagnosticListener : DiagnosticSource {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private DiagnosticSubscription modreq(System.Runtime.CompilerServices.IsVolatile) _subscriptions;
    private DiagnosticListener _next;
    private bool _disposed;
    private static DiagnosticListener s_allListeners;
    private static AllListenerObservable modreq(System.Runtime.CompilerServices.IsVolatile) s_allListenerObservable;
    private static object s_allListenersLock;
    public static IObservable`1<DiagnosticListener> AllListeners { get; }
    public string Name { get; private set; }
    public DiagnosticListener(string name);
    private static DiagnosticListener();
    public virtual void OnActivityImport(Activity activity, object payload);
    public virtual void OnActivityExport(Activity activity, object payload);
    public virtual IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer, Func`4<string, object, object, bool> isEnabled, Action`2<Activity, object> onActivityImport, Action`2<Activity, object> onActivityExport);
    public static IObservable`1<DiagnosticListener> get_AllListeners();
    public virtual IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer, Predicate`1<string> isEnabled);
    public virtual IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer, Func`4<string, object, object, bool> isEnabled);
    public virtual IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public virtual string ToString();
    public bool IsEnabled();
    public virtual bool IsEnabled(string name);
    [NullableContextAttribute("2")]
public virtual bool IsEnabled(string name, object arg1, object arg2);
    [RequiresUnreferencedCodeAttribute("The type of object being written to DiagnosticSource cannot be discovered statically.")]
public virtual void Write(string name, object value);
    private DiagnosticSubscription SubscribeInternal(IObserver`1<KeyValuePair`2<string, object>> observer, Predicate`1<string> isEnabled1Arg, Func`4<string, object, object, bool> isEnabled3Arg, Action`2<Activity, object> onActivityImport, Action`2<Activity, object> onActivityExport);
    [CompilerGeneratedAttribute]
private bool <Subscribe>b__2_0(string name);
    [CompilerGeneratedAttribute]
private bool <Subscribe>b__6_0(string name);
}
internal static class System.Diagnostics.DiagnosticsHelper : object {
    internal static bool CompareTags(List`1<KeyValuePair`2<string, object>> sortedTags, IEnumerable`1<KeyValuePair`2<string, object>> tags2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Diagnostics.DiagnosticSource : object {
    internal static string WriteRequiresUnreferencedCode;
    internal static string WriteOfTRequiresUnreferencedCode;
    [RequiresUnreferencedCodeAttribute("The type of object being written to DiagnosticSource cannot be discovered statically.")]
public abstract virtual void Write(string name, object value);
    [RequiresUnreferencedCodeAttribute("Only the properties of the T type will be preserved. Properties of referenced types and properties of derived types may be trimmed.")]
public void Write(string name, T value);
    public abstract virtual bool IsEnabled(string name);
    [NullableContextAttribute("2")]
public virtual bool IsEnabled(string name, object arg1, object arg2);
    [RequiresUnreferencedCodeAttribute("The type of object being written to DiagnosticSource cannot be discovered statically.")]
public Activity StartActivity(Activity activity, object args);
    [RequiresUnreferencedCodeAttribute("Only the properties of the T type will be preserved. Properties of referenced types and properties of derived types may be trimmed.")]
public Activity StartActivity(Activity activity, T args);
    [RequiresUnreferencedCodeAttribute("The type of object being written to DiagnosticSource cannot be discovered statically.")]
public void StopActivity(Activity activity, object args);
    [RequiresUnreferencedCodeAttribute("Only the properties of the T type will be preserved. Properties of referenced types and properties of derived types may be trimmed.")]
public void StopActivity(Activity activity, T args);
    public virtual void OnActivityImport(Activity activity, object payload);
    public virtual void OnActivityExport(Activity activity, object payload);
}
[EventSourceAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2113:ReflectionToRequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2115:ReflectionToDynamicallyAccessedMembers")]
internal class System.Diagnostics.DiagnosticSourceEventSource : EventSource {
    public static DiagnosticSourceEventSource Log;
    private string AspNetCoreHostingKeywordValue;
    private string EntityFrameworkCoreCommandsKeywordValue;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _false;
    private FilterAndTransform _specs;
    private FilterAndTransform _activitySourceSpecs;
    private ActivityListener _activityListener;
    private static DiagnosticSourceEventSource();
    [EventAttribute("1")]
public void Message(string Message);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("2")]
private void Event(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [EventAttribute("3")]
private void EventJson(string SourceName, string EventName, string ArgmentsJson);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("4")]
private void Activity1Start(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("5")]
private void Activity1Stop(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("6")]
private void Activity2Start(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("7")]
private void Activity2Stop(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("8")]
private void RecursiveActivity1Start(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("9")]
private void RecursiveActivity1Stop(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [EventAttribute("10")]
private void NewDiagnosticListener(string SourceName);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("11")]
private void ActivityStart(string SourceName, string ActivityName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Collections.Generic.KeyValuePair`2")]
[EventAttribute("12")]
private void ActivityStop(string SourceName, string ActivityName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments);
    [NonEventAttribute]
protected virtual void OnEventCommand(EventCommandEventArgs command);
    private static string NewLineSeparate(string str1, string str2);
    [NonEventAttribute]
private void BreakPointWithDebuggerFuncEval();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Diagnostics.DistributedContextPropagator : object {
    private static DistributedContextPropagator s_current;
    internal static string TraceParent;
    internal static string RequestId;
    internal static string TraceState;
    internal static string Baggage;
    internal static string CorrelationContext;
    internal static char Space;
    internal static char Tab;
    internal static char Comma;
    internal static char Semicolon;
    internal static string CommaWithSpace;
    internal static Char[] s_trimmingSpaceCharacters;
    public IReadOnlyCollection`1<string> Fields { get; }
    public static DistributedContextPropagator Current { get; public set; }
    private static DistributedContextPropagator();
    public abstract virtual IReadOnlyCollection`1<string> get_Fields();
    [NullableContextAttribute("2")]
public abstract virtual void Inject(Activity activity, object carrier, PropagatorSetterCallback setter);
    [NullableContextAttribute("2")]
public abstract virtual void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, String& traceId, String& traceState);
    [NullableContextAttribute("2")]
public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter);
    public static DistributedContextPropagator get_Current();
    public static void set_Current(DistributedContextPropagator value);
    public static DistributedContextPropagator CreateDefaultPropagator();
    public static DistributedContextPropagator CreatePassThroughPropagator();
    public static DistributedContextPropagator CreateNoOutputPropagator();
    internal static void InjectBaggage(object carrier, IEnumerable`1<KeyValuePair`2<string, string>> baggage, PropagatorSetterCallback setter);
}
internal class System.Diagnostics.HttpHandlerDiagnosticListener : DiagnosticListener {
    internal static HttpHandlerDiagnosticListener s_instance;
    private static string DiagnosticListenerName;
    private static string ActivityName;
    private static string RequestStartName;
    private static string RequestStopName;
    private static string RequestStopExName;
    private static string InitializationFailed;
    private static string RequestIdHeaderName;
    private static string CorrelationContextHeaderName;
    private static string TraceParentHeaderName;
    private static string TraceStateHeaderName;
    private bool initialized;
    private static FieldInfo s_connectionGroupListField;
    private static Type s_connectionGroupType;
    private static FieldInfo s_connectionListField;
    private static Type s_connectionType;
    private static FieldInfo s_writeListField;
    private static Func`2<HttpWebRequest, HttpWebResponse> s_httpResponseAccessor;
    private static Func`2<HttpWebRequest, int> s_autoRedirectsAccessor;
    private static Func`2<HttpWebRequest, object> s_coreResponseAccessor;
    private static Func`2<object, HttpStatusCode> s_coreStatusCodeAccessor;
    private static Func`2<object, WebHeaderCollection> s_coreHeadersAccessor;
    private static Type s_coreResponseDataType;
    private static HttpHandlerDiagnosticListener();
    public virtual IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer, Predicate`1<string> isEnabled);
    public virtual IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer, Func`4<string, object, object, bool> isEnabled);
    public virtual IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer);
    private void Initialize();
    private void RaiseRequestEvent(HttpWebRequest request);
    private void RaiseResponseEvent(HttpWebRequest request, HttpWebResponse response);
    private void RaiseResponseEvent(HttpWebRequest request, HttpStatusCode statusCode, WebHeaderCollection headers);
    private static bool IsLastResponse(HttpWebRequest request, HttpStatusCode statusCode);
    private static void PrepareReflectionObjects();
    private static void PerformInjection();
    private static Func`2<TClass, TField> CreateFieldGetter(string fieldName, BindingFlags flags);
    private static Func`2<object, TField> CreateFieldGetter(Type classType, string fieldName, BindingFlags flags);
}
internal class System.Diagnostics.LegacyPropagator : DistributedContextPropagator {
    [CompilerGeneratedAttribute]
private static DistributedContextPropagator <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Fields>k__BackingField;
    internal static DistributedContextPropagator Instance { get; }
    public IReadOnlyCollection`1<string> Fields { get; }
    private static LegacyPropagator();
    [CompilerGeneratedAttribute]
internal static DistributedContextPropagator get_Instance();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyCollection`1<string> get_Fields();
    public virtual void Inject(Activity activity, object carrier, PropagatorSetterCallback setter);
    public virtual void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, String& traceId, String& traceState);
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter);
    internal static bool TryExtractBaggage(string baggageString, IEnumerable`1& baggage);
}
[UnsupportedOSPlatformAttribute("browser")]
[SecuritySafeCriticalAttribute]
internal class System.Diagnostics.Metrics.AggregationManager : object {
    public static double MinCollectionTimeSecs;
    private static QuantileAggregation s_defaultHistogramConfig;
    private List`1<Predicate`1<Instrument>> _instrumentConfigFuncs;
    [CompilerGeneratedAttribute]
private TimeSpan <CollectionPeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTimeSeries>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxHistograms>k__BackingField;
    private Dictionary`2<Instrument, bool> _instruments;
    private ConcurrentDictionary`2<Instrument, InstrumentState> _instrumentStates;
    private CancellationTokenSource _cts;
    private Thread _collectThread;
    private MeterListener _listener;
    private int _currentTimeSeries;
    private int _currentHistograms;
    private Action`2<Instrument, LabeledAggregationStatistics> _collectMeasurement;
    private Action`2<DateTime, DateTime> _beginCollection;
    private Action`2<DateTime, DateTime> _endCollection;
    private Action`1<Instrument> _beginInstrumentMeasurements;
    private Action`1<Instrument> _endInstrumentMeasurements;
    private Action`1<Instrument> _instrumentPublished;
    private Action _initialInstrumentEnumerationComplete;
    private Action`1<Exception> _collectionError;
    private Action _timeSeriesLimitReached;
    private Action _histogramLimitReached;
    private Action`1<Exception> _observableInstrumentCallbackError;
    public TimeSpan CollectionPeriod { get; private set; }
    public int MaxTimeSeries { get; }
    public int MaxHistograms { get; }
    public AggregationManager(int maxTimeSeries, int maxHistograms, Action`2<Instrument, LabeledAggregationStatistics> collectMeasurement, Action`2<DateTime, DateTime> beginCollection, Action`2<DateTime, DateTime> endCollection, Action`1<Instrument> beginInstrumentMeasurements, Action`1<Instrument> endInstrumentMeasurements, Action`1<Instrument> instrumentPublished, Action initialInstrumentEnumerationComplete, Action`1<Exception> collectionError, Action timeSeriesLimitReached, Action histogramLimitReached, Action`1<Exception> observableInstrumentCallbackError);
    private static AggregationManager();
    [CompilerGeneratedAttribute]
public TimeSpan get_CollectionPeriod();
    [CompilerGeneratedAttribute]
private void set_CollectionPeriod(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxTimeSeries();
    [CompilerGeneratedAttribute]
public int get_MaxHistograms();
    public void Include(string meterName);
    public void Include(string meterName, string instrumentName);
    private void Include(Predicate`1<Instrument> instrumentFilter);
    public AggregationManager SetCollectionPeriod(TimeSpan collectionPeriod);
    private void CompletedMeasurements(Instrument instrument, object cookie);
    private void PublishedInstrument(Instrument instrument, MeterListener _);
    public void Start();
    public void Update();
    private void CollectWorker(CancellationToken cancelToken);
    public void Dispose();
    private void RemoveInstrumentState(Instrument instrument);
    private InstrumentState GetInstrumentState(Instrument instrument);
    [UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
internal InstrumentState BuildInstrumentState(Instrument instrument);
    private Func`1<Aggregator> GetAggregatorFactory(Instrument instrument);
    private bool CheckTimeSeriesAllowed();
    private bool CheckHistogramAllowed();
    internal void Collect();
    [CompilerGeneratedAttribute]
private void <Start>b__38_0();
    [CompilerGeneratedAttribute]
private Aggregator <GetAggregatorFactory>b__45_0();
    [CompilerGeneratedAttribute]
private Aggregator <GetAggregatorFactory>b__45_1();
    [CompilerGeneratedAttribute]
private Aggregator <GetAggregatorFactory>b__45_2();
    [CompilerGeneratedAttribute]
private Aggregator <GetAggregatorFactory>b__45_3();
    [CompilerGeneratedAttribute]
private Aggregator <GetAggregatorFactory>b__45_4();
    [CompilerGeneratedAttribute]
private Aggregator <GetAggregatorFactory>b__45_5();
}
internal abstract class System.Diagnostics.Metrics.Aggregator : object {
    public abstract virtual void Update(double measurement);
    public abstract virtual IAggregationStatistics Collect();
}
internal class System.Diagnostics.Metrics.AggregatorLookupFunc`1 : MulticastDelegate {
    public AggregatorLookupFunc`1(object object, IntPtr method);
    public virtual bool Invoke(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels, TAggregator& aggregator);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels, TAggregator& aggregator, AsyncCallback callback, object object);
    public virtual bool EndInvoke(TAggregator& aggregator, IAsyncResult result);
}
[SecuritySafeCriticalAttribute]
internal class System.Diagnostics.Metrics.AggregatorStore`1 : ValueType {
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) _stateUnion;
    private AggregatorLookupFunc`1 modreq(System.Runtime.CompilerServices.IsVolatile) _cachedLookupFunc;
    private Func`1<TAggregator> _createAggregatorFunc;
    public AggregatorStore`1(Func`1<TAggregator> createAggregator);
    public TAggregator GetAggregator(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels);
    private TAggregator GetAggregatorSlow(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels);
    public void Collect(Action`1<LabeledAggregationStatistics> visitFunc);
    public TAggregator GetAggregator();
    public ConcurrentDictionary`2<TObjectSequence, TAggregator> GetLabelValuesDictionary(TStringSequence& names);
}
internal class System.Diagnostics.Metrics.Counter`1 : Instrument`1<T> {
    internal Counter`1(Meter meter, string name, string unit, string description);
    internal Counter`1(Meter meter, string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public void Add(T delta);
    public void Add(T delta, KeyValuePair`2<string, object> tag);
    public void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public void Add(T delta, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    public void Add(T delta, KeyValuePair`2[] tags);
    public void Add(T delta, TagList& tagList);
}
internal class System.Diagnostics.Metrics.CounterAggregator : Aggregator {
    private bool _isMonotonic;
    private double _delta;
    private double _aggregatedValue;
    public CounterAggregator(bool isMonotonic);
    public virtual void Update(double value);
    public virtual IAggregationStatistics Collect();
}
internal class System.Diagnostics.Metrics.CounterStatistics : object {
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMonotonic>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public Nullable`1<double> Delta { get; }
    public bool IsMonotonic { get; }
    public double Value { get; }
    public CounterStatistics(Nullable`1<double> delta, bool isMonotonic, double value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Delta();
    [CompilerGeneratedAttribute]
public bool get_IsMonotonic();
    [CompilerGeneratedAttribute]
public double get_Value();
}
internal class System.Diagnostics.Metrics.ExponentialHistogramAggregator : Aggregator {
    private static int ExponentArraySize;
    private static int ExponentShift;
    private static double MinRelativeError;
    private static int PositiveIntAndNan;
    private static int NegativeIntAndNan;
    private QuantileAggregation _config;
    private Int32[][] _counters;
    private int _count;
    private double _sum;
    private int _mantissaMax;
    private int _mantissaMask;
    private int _mantissaShift;
    public ExponentialHistogramAggregator(QuantileAggregation config);
    public virtual IAggregationStatistics Collect();
    [IteratorStateMachineAttribute("System.Diagnostics.Metrics.ExponentialHistogramAggregator/<IterateBuckets>d__15")]
private IEnumerable`1<Bucket> IterateBuckets(Int32[][] counters);
    public virtual void Update(double measurement);
    private static int QuantileToRank(double quantile, int count);
    private double GetBucketCanonicalValue(int exponent, int mantissa);
}
internal class System.Diagnostics.Metrics.FixedSizeLabelNameDictionary`3 : ConcurrentDictionary`2<TStringSequence, ConcurrentDictionary`2<TObjectSequence, TAggregator>> {
    public void Collect(Action`1<LabeledAggregationStatistics> visitFunc);
    public ConcurrentDictionary`2<TObjectSequence, TAggregator> GetValuesDictionary(TStringSequence& names);
}
internal class System.Diagnostics.Metrics.Histogram`1 : Instrument`1<T> {
    internal Histogram`1(Meter meter, string name, string unit, string description);
    internal Histogram`1(Meter meter, string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public void Record(T value);
    public void Record(T value, KeyValuePair`2<string, object> tag);
    public void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public void Record(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    public void Record(T value, KeyValuePair`2[] tags);
    public void Record(T value, TagList& tagList);
}
internal class System.Diagnostics.Metrics.HistogramStatistics : object {
    [CompilerGeneratedAttribute]
private QuantileValue[] <Quantiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Sum>k__BackingField;
    public QuantileValue[] Quantiles { get; }
    public int Count { get; }
    public double Sum { get; }
    internal HistogramStatistics(QuantileValue[] quantiles, int count, double sum);
    [CompilerGeneratedAttribute]
public QuantileValue[] get_Quantiles();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public double get_Sum();
}
internal interface System.Diagnostics.Metrics.IAggregationStatistics {
}
internal interface System.Diagnostics.Metrics.IMeterFactory {
    [NullableContextAttribute("1")]
public abstract virtual Meter Create(MeterOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Diagnostics.Metrics.Instrument : object {
    [CompilerGeneratedAttribute]
private static object <SyncObject>k__BackingField;
    internal DiagLinkedList`1<ListenerSubscription> _subscriptions;
    [CompilerGeneratedAttribute]
private Meter <Meter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Unit>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <Tags>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static KeyValuePair`2[] EmptyTags { get; }
    internal static object SyncObject { get; }
    public Meter Meter { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string Description { get; }
    [NullableAttribute("2")]
public string Unit { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Tags { get; }
    public bool Enabled { get; }
    public bool IsObservable { get; }
    protected Instrument(Meter meter, string name, string unit, string description);
    protected Instrument(Meter meter, string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    private static Instrument();
    internal static KeyValuePair`2[] get_EmptyTags();
    [CompilerGeneratedAttribute]
internal static object get_SyncObject();
    protected void Publish();
    [CompilerGeneratedAttribute]
public Meter get_Meter();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Unit();
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags();
    public bool get_Enabled();
    public virtual bool get_IsObservable();
    internal void NotifyForUnpublishedInstrument();
    internal static void ValidateTypeParameter();
    internal object EnableMeasurement(ListenerSubscription subscription, Boolean& oldStateStored);
    internal object DisableMeasurements(MeterListener listener);
    internal virtual void Observe(MeterListener listener);
    internal object GetSubscriptionState(MeterListener listener);
}
internal abstract class System.Diagnostics.Metrics.Instrument`1 : Instrument {
    [ThreadStaticAttribute]
private static KeyValuePair`2[] ts_tags;
    private static int MaxTagsCount;
    [NullableContextAttribute("1")]
protected Instrument`1(Meter meter, string name, string unit, string description);
    [NullableContextAttribute("1")]
protected Instrument`1(Meter meter, string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    protected void RecordMeasurement(T measurement);
    protected void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    protected void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag);
    protected void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    protected void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    protected void RecordMeasurement(T measurement, TagList& tagList);
}
internal abstract class System.Diagnostics.Metrics.InstrumentState : object {
    [SecuritySafeCriticalAttribute]
public abstract virtual void Update(double measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> labels);
    public abstract virtual void Collect(Instrument instrument, Action`1<LabeledAggregationStatistics> aggregationVisitFunc);
}
internal class System.Diagnostics.Metrics.InstrumentState`1 : InstrumentState {
    private AggregatorStore`1<TAggregator> _aggregatorStore;
    public InstrumentState`1(Func`1<TAggregator> createAggregatorFunc);
    public virtual void Collect(Instrument instrument, Action`1<LabeledAggregationStatistics> aggregationVisitFunc);
    [SecuritySafeCriticalAttribute]
public virtual void Update(double measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> labels);
}
[DefaultMemberAttribute("Item")]
internal interface System.Diagnostics.Metrics.IObjectSequence {
    public object Item { get; public set; }
    public abstract virtual object get_Item(int i);
    public abstract virtual void set_Item(int i, object value);
}
[DefaultMemberAttribute("Item")]
internal interface System.Diagnostics.Metrics.IStringSequence {
    public string Item { get; public set; }
    public int Length { get; }
    public abstract virtual string get_Item(int i);
    public abstract virtual void set_Item(int i, string value);
    public abstract virtual int get_Length();
}
internal class System.Diagnostics.Metrics.LabeledAggregationStatistics : object {
    [CompilerGeneratedAttribute]
private KeyValuePair`2[] <Labels>k__BackingField;
    [CompilerGeneratedAttribute]
private IAggregationStatistics <AggregationStatistics>k__BackingField;
    public KeyValuePair`2[] Labels { get; }
    public IAggregationStatistics AggregationStatistics { get; }
    public LabeledAggregationStatistics(IAggregationStatistics stats, KeyValuePair`2[] labels);
    [CompilerGeneratedAttribute]
public KeyValuePair`2[] get_Labels();
    [CompilerGeneratedAttribute]
public IAggregationStatistics get_AggregationStatistics();
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Metrics.LabelInstruction : ValueType {
    [CompilerGeneratedAttribute]
private int <SourceIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LabelName>k__BackingField;
    public int SourceIndex { get; }
    public string LabelName { get; }
    public LabelInstruction(int sourceIndex, string labelName);
    [CompilerGeneratedAttribute]
public int get_SourceIndex();
    [CompilerGeneratedAttribute]
public string get_LabelName();
}
[SecurityCriticalAttribute]
internal static class System.Diagnostics.Metrics.LabelInstructionCompiler : object {
    public static AggregatorLookupFunc`1<TAggregator> Create(AggregatorStore`1& aggregatorStore, Func`1<TAggregator> createAggregatorFunc, ReadOnlySpan`1<KeyValuePair`2<string, object>> labels);
    private static LabelInstruction[] Compile(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels);
}
[SecurityCriticalAttribute]
internal class System.Diagnostics.Metrics.LabelInstructionInterpreter`2 : object {
    private int _expectedLabelCount;
    private LabelInstruction[] _instructions;
    private ConcurrentDictionary`2<TObjectSequence, TAggregator> _valuesDict;
    private Func`2<TObjectSequence, TAggregator> _createAggregator;
    public LabelInstructionInterpreter`2(int expectedLabelCount, LabelInstruction[] instructions, ConcurrentDictionary`2<TObjectSequence, TAggregator> valuesDict, Func`1<TAggregator> createAggregator);
    public bool GetAggregator(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels, TAggregator& aggregator);
}
internal class System.Diagnostics.Metrics.LastValue : Aggregator {
    private Nullable`1<double> _lastValue;
    public virtual void Update(double value);
    public virtual IAggregationStatistics Collect();
}
internal class System.Diagnostics.Metrics.LastValueStatistics : object {
    [CompilerGeneratedAttribute]
private Nullable`1<double> <LastValue>k__BackingField;
    public Nullable`1<double> LastValue { get; }
    internal LastValueStatistics(Nullable`1<double> lastValue);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_LastValue();
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Metrics.ListenerSubscription : ValueType {
    [CompilerGeneratedAttribute]
private MeterListener <Listener>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    internal MeterListener Listener { get; }
    internal object State { get; }
    internal ListenerSubscription(MeterListener listener, object state);
    [CompilerGeneratedAttribute]
internal MeterListener get_Listener();
    [CompilerGeneratedAttribute]
internal object get_State();
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Metrics.Measurement`1 : ValueType {
    private KeyValuePair`2[] _tags;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<KeyValuePair`2<string, object>> Tags { get; }
    public T Value { get; }
    public Measurement`1(T value);
    public Measurement`1(T value, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public Measurement`1(T value, KeyValuePair`2[] tags);
    public Measurement`1(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    public ReadOnlySpan`1<KeyValuePair`2<string, object>> get_Tags();
    [CompilerGeneratedAttribute]
public T get_Value();
    private static KeyValuePair`2[] ToArray(IEnumerable`1<KeyValuePair`2<string, object>> tags);
}
internal class System.Diagnostics.Metrics.MeasurementCallback`1 : MulticastDelegate {
    public MeasurementCallback`1(object object, IntPtr method);
    public virtual void Invoke(Instrument instrument, T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, object state);
    public virtual IAsyncResult BeginInvoke(Instrument instrument, T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Diagnostics.Metrics.Meter : object {
    private static List`1<Meter> s_allMeters;
    private List`1<Instrument> _instruments;
    private Dictionary`2<string, List`1<Instrument>> _nonObservableInstrumentsCache;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Scope>k__BackingField;
    internal bool Disposed { get; private set; }
    internal static bool IsSupported { get; }
    [NullableAttribute("1")]
public string Name { get; private set; }
    public string Version { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Tags { get; private set; }
    public object Scope { get; private set; }
    [NullableContextAttribute("1")]
public Meter(MeterOptions options);
    [NullableContextAttribute("1")]
public Meter(string name);
    [NullableContextAttribute("1")]
public Meter(string name, string version);
    public Meter(string name, string version, IEnumerable`1<KeyValuePair`2<string, object>> tags, object scope);
    private static Meter();
    [CompilerGeneratedAttribute]
internal bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsSupported();
    private static bool InitializeIsSupported();
    private void Initialize(string name, string version, IEnumerable`1<KeyValuePair`2<string, object>> tags, object scope);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(IEnumerable`1<KeyValuePair`2<string, object>> value);
    [CompilerGeneratedAttribute]
public object get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(object value);
    public Counter`1<T> CreateCounter(string name, string unit, string description);
    public Counter`1<T> CreateCounter(string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public Histogram`1<T> CreateHistogram(string name, string unit, string description);
    public Histogram`1<T> CreateHistogram(string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public UpDownCounter`1<T> CreateUpDownCounter(string name, string unit, string description);
    public UpDownCounter`1<T> CreateUpDownCounter(string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableUpDownCounter`1<T> CreateObservableUpDownCounter(string name, Func`1<T> observeValue, string unit, string description);
    public ObservableUpDownCounter`1<T> CreateObservableUpDownCounter(string name, Func`1<T> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableUpDownCounter`1<T> CreateObservableUpDownCounter(string name, Func`1<Measurement`1<T>> observeValue, string unit, string description);
    public ObservableUpDownCounter`1<T> CreateObservableUpDownCounter(string name, Func`1<Measurement`1<T>> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableUpDownCounter`1<T> CreateObservableUpDownCounter(string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description);
    public ObservableUpDownCounter`1<T> CreateObservableUpDownCounter(string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<T> observeValue, string unit, string description);
    public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<T> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<Measurement`1<T>> observeValue, string unit, string description);
    public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<Measurement`1<T>> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description);
    public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<T> observeValue, string unit, string description);
    public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<T> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<Measurement`1<T>> observeValue, string unit, string description);
    public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<Measurement`1<T>> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description);
    public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static Instrument GetCachedInstrument(List`1<Instrument> instrumentList, Type instrumentType, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    private Instrument GetOrCreateInstrument(Type instrumentType, string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags, Func`1<Instrument> instrumentCreator);
    internal bool AddInstrument(Instrument instrument);
    internal static List`1<Instrument> GetPublishedInstruments();
}
[ExtensionAttribute]
internal static class System.Diagnostics.Metrics.MeterFactoryExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Meter Create(IMeterFactory meterFactory, string name, string version, IEnumerable`1<KeyValuePair`2<string, object>> tags);
}
internal class System.Diagnostics.Metrics.MeterListener : object {
    private static List`1<MeterListener> s_allStartedListeners;
    private DiagLinkedList`1<Instrument> _enabledMeasurementInstruments;
    private bool _disposed;
    private MeasurementCallback`1<byte> _byteMeasurementCallback;
    private MeasurementCallback`1<short> _shortMeasurementCallback;
    private MeasurementCallback`1<int> _intMeasurementCallback;
    private MeasurementCallback`1<long> _longMeasurementCallback;
    private MeasurementCallback`1<float> _floatMeasurementCallback;
    private MeasurementCallback`1<double> _doubleMeasurementCallback;
    private MeasurementCallback`1<decimal> _decimalMeasurementCallback;
    [CompilerGeneratedAttribute]
private Action`2<Instrument, MeterListener> <InstrumentPublished>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Instrument, object> <MeasurementsCompleted>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Instrument, MeterListener> InstrumentPublished { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Instrument, object> MeasurementsCompleted { get; public set; }
    private static MeterListener();
    [CompilerGeneratedAttribute]
public Action`2<Instrument, MeterListener> get_InstrumentPublished();
    [CompilerGeneratedAttribute]
public void set_InstrumentPublished(Action`2<Instrument, MeterListener> value);
    [CompilerGeneratedAttribute]
public Action`2<Instrument, object> get_MeasurementsCompleted();
    [CompilerGeneratedAttribute]
public void set_MeasurementsCompleted(Action`2<Instrument, object> value);
    [NullableContextAttribute("1")]
public void EnableMeasurementEvents(Instrument instrument, object state);
    [NullableContextAttribute("1")]
public object DisableMeasurementEvents(Instrument instrument);
    public void SetMeasurementEventCallback(MeasurementCallback`1<T> measurementCallback);
    public void Start();
    public void RecordObservableInstruments();
    public sealed virtual void Dispose();
    internal static List`1<MeterListener> GetAllListeners();
    internal void NotifyMeasurement(Instrument instrument, T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, object state);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Diagnostics.Metrics.MeterOptions : object {
    private string _name;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Scope>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; public set; }
    public string Version { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Tags { get; public set; }
    public object Scope { get; public set; }
    [NullableContextAttribute("1")]
public MeterOptions(string name);
    [NullableContextAttribute("1")]
public string get_Name();
    [NullableContextAttribute("1")]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IEnumerable`1<KeyValuePair`2<string, object>> value);
    [CompilerGeneratedAttribute]
public object get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(object value);
}
[EventSourceAttribute]
internal class System.Diagnostics.Metrics.MetricsEventSource : EventSource {
    public static MetricsEventSource Log;
    private static string SharedSessionId;
    private static string ClientIdKey;
    private static string MaxHistogramsKey;
    private static string MaxTimeSeriesKey;
    private static string RefreshIntervalKey;
    private static string DefaultValueDescription;
    private static string SharedValueDescription;
    private CommandHandler _handler;
    private CommandHandler Handler { get; }
    private static MetricsEventSource();
    private CommandHandler get_Handler();
    [EventAttribute("1")]
public void Message(string Message);
    [EventAttribute("2")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void CollectionStart(string sessionId, DateTime intervalStartTime, DateTime intervalEndTime);
    [EventAttribute("3")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void CollectionStop(string sessionId, DateTime intervalStartTime, DateTime intervalEndTime);
    [EventAttribute("4")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void CounterRateValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string rate, string value);
    [EventAttribute("5")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void GaugeValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string lastValue);
    [EventAttribute("6")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void HistogramValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string quantiles, int count, double sum);
    [EventAttribute("7")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void BeginInstrumentReporting(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description, string instrumentTags, string meterTags, string meterScopeHash);
    [EventAttribute("8")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void EndInstrumentReporting(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description, string instrumentTags, string meterTags, string meterScopeHash);
    [EventAttribute("9")]
public void Error(string sessionId, string errorMessage);
    [EventAttribute("10")]
public void InitialInstrumentEnumerationComplete(string sessionId);
    [EventAttribute("11")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void InstrumentPublished(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description, string instrumentTags, string meterTags, string meterScopeHash);
    [EventAttribute("12")]
public void TimeSeriesLimitReached(string sessionId);
    [EventAttribute("13")]
public void HistogramLimitReached(string sessionId);
    [EventAttribute("14")]
public void ObservableInstrumentCallbackError(string sessionId, string errorMessage);
    [EventAttribute("15")]
public void MultipleSessionsNotSupportedError(string runningSessionId);
    [EventAttribute("16")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void UpDownCounterRateValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string rate, string value);
    [EventAttribute("17")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public void MultipleSessionsConfiguredIncorrectlyError(string clientId, string expectedMaxHistograms, string actualMaxHistograms, string expectedMaxTimeSeries, string actualMaxTimeSeries, string expectedRefreshInterval, string actualRefreshInterval);
    [NonEventAttribute]
protected virtual void OnEventCommand(EventCommandEventArgs command);
}
internal class System.Diagnostics.Metrics.MultiSizeLabelNameDictionary`1 : object {
    private TAggregator NoLabelAggregator;
    private FixedSizeLabelNameDictionary`3<StringSequence1, ObjectSequence1, TAggregator> Label1;
    private FixedSizeLabelNameDictionary`3<StringSequence2, ObjectSequence2, TAggregator> Label2;
    private FixedSizeLabelNameDictionary`3<StringSequence3, ObjectSequence3, TAggregator> Label3;
    private FixedSizeLabelNameDictionary`3<StringSequenceMany, ObjectSequenceMany, TAggregator> LabelMany;
    public MultiSizeLabelNameDictionary`1(object initialLabelNameDict);
    public TAggregator GetNoLabelAggregator(Func`1<TAggregator> createFunc);
    public FixedSizeLabelNameDictionary`3<TStringSequence, TObjectSequence, TAggregator> GetFixedSizeLabelNameDictionary();
    public void Collect(Action`1<LabeledAggregationStatistics> visitFunc);
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Metrics.ObjectSequence1 : ValueType {
    public object Value1;
    public object Item { get; public set; }
    public ObjectSequence1(object value1);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ObjectSequence1 other);
    public virtual bool Equals(object obj);
    public sealed virtual object get_Item(int i);
    public sealed virtual void set_Item(int i, object value);
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Metrics.ObjectSequence2 : ValueType {
    public object Value1;
    public object Value2;
    public object Item { get; public set; }
    public ObjectSequence2(object value1, object value2);
    public sealed virtual bool Equals(ObjectSequence2 other);
    public virtual bool Equals(object obj);
    public sealed virtual object get_Item(int i);
    public sealed virtual void set_Item(int i, object value);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Metrics.ObjectSequence3 : ValueType {
    public object Value1;
    public object Value2;
    public object Value3;
    public object Item { get; public set; }
    public ObjectSequence3(object value1, object value2, object value3);
    public sealed virtual bool Equals(ObjectSequence3 other);
    public virtual bool Equals(object obj);
    public sealed virtual object get_Item(int i);
    public sealed virtual void set_Item(int i, object value);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Metrics.ObjectSequenceMany : ValueType {
    private Object[] _values;
    public object Item { get; public set; }
    public ObjectSequenceMany(Object[] values);
    public sealed virtual bool Equals(ObjectSequenceMany other);
    public virtual bool Equals(object obj);
    public sealed virtual object get_Item(int i);
    public sealed virtual void set_Item(int i, object value);
    public virtual int GetHashCode();
}
internal class System.Diagnostics.Metrics.ObservableCounter`1 : ObservableInstrument`1<T> {
    private object _callback;
    internal ObservableCounter`1(Meter meter, string name, Func`1<T> observeValue, string unit, string description);
    internal ObservableCounter`1(Meter meter, string name, Func`1<T> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    internal ObservableCounter`1(Meter meter, string name, Func`1<Measurement`1<T>> observeValue, string unit, string description);
    internal ObservableCounter`1(Meter meter, string name, Func`1<Measurement`1<T>> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    internal ObservableCounter`1(Meter meter, string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description);
    internal ObservableCounter`1(Meter meter, string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    protected virtual IEnumerable`1<Measurement`1<T>> Observe();
}
internal class System.Diagnostics.Metrics.ObservableCounterAggregator : Aggregator {
    private bool _isMonotonic;
    private Nullable`1<double> _prevValue;
    private double _currValue;
    public ObservableCounterAggregator(bool isMonotonic);
    public virtual void Update(double value);
    public virtual IAggregationStatistics Collect();
}
internal class System.Diagnostics.Metrics.ObservableGauge`1 : ObservableInstrument`1<T> {
    private object _callback;
    internal ObservableGauge`1(Meter meter, string name, Func`1<T> observeValue, string unit, string description);
    internal ObservableGauge`1(Meter meter, string name, Func`1<T> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    internal ObservableGauge`1(Meter meter, string name, Func`1<Measurement`1<T>> observeValue, string unit, string description);
    internal ObservableGauge`1(Meter meter, string name, Func`1<Measurement`1<T>> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    internal ObservableGauge`1(Meter meter, string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description);
    internal ObservableGauge`1(Meter meter, string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    protected virtual IEnumerable`1<Measurement`1<T>> Observe();
}
internal abstract class System.Diagnostics.Metrics.ObservableInstrument`1 : Instrument {
    public bool IsObservable { get; }
    [NullableContextAttribute("1")]
protected ObservableInstrument`1(Meter meter, string name, string unit, string description);
    [NullableContextAttribute("1")]
protected ObservableInstrument`1(Meter meter, string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    protected abstract virtual IEnumerable`1<Measurement`1<T>> Observe();
    public virtual bool get_IsObservable();
    internal virtual void Observe(MeterListener listener);
    internal static IEnumerable`1<Measurement`1<T>> Observe(object callback);
}
internal class System.Diagnostics.Metrics.ObservableUpDownCounter`1 : ObservableInstrument`1<T> {
    private object _callback;
    internal ObservableUpDownCounter`1(Meter meter, string name, Func`1<T> observeValue, string unit, string description);
    internal ObservableUpDownCounter`1(Meter meter, string name, Func`1<T> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    internal ObservableUpDownCounter`1(Meter meter, string name, Func`1<Measurement`1<T>> observeValue, string unit, string description);
    internal ObservableUpDownCounter`1(Meter meter, string name, Func`1<Measurement`1<T>> observeValue, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    internal ObservableUpDownCounter`1(Meter meter, string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description);
    internal ObservableUpDownCounter`1(Meter meter, string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    protected virtual IEnumerable`1<Measurement`1<T>> Observe();
}
internal class System.Diagnostics.Metrics.QuantileAggregation : object {
    [CompilerGeneratedAttribute]
private Double[] <Quantiles>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxRelativeError>k__BackingField;
    public Double[] Quantiles { get; public set; }
    public double MaxRelativeError { get; public set; }
    public QuantileAggregation(Double[] quantiles);
    [CompilerGeneratedAttribute]
public Double[] get_Quantiles();
    [CompilerGeneratedAttribute]
public void set_Quantiles(Double[] value);
    [CompilerGeneratedAttribute]
public double get_MaxRelativeError();
    [CompilerGeneratedAttribute]
public void set_MaxRelativeError(double value);
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Metrics.QuantileValue : ValueType {
    [CompilerGeneratedAttribute]
private double <Quantile>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public double Quantile { get; }
    public double Value { get; }
    public QuantileValue(double quantile, double value);
    [CompilerGeneratedAttribute]
public double get_Quantile();
    [CompilerGeneratedAttribute]
public double get_Value();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Metrics.StringSequence1 : ValueType {
    public string Value1;
    public string Item { get; public set; }
    public int Length { get; }
    public StringSequence1(string value1);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(StringSequence1 other);
    public virtual bool Equals(object obj);
    public sealed virtual string get_Item(int i);
    public sealed virtual void set_Item(int i, string value);
    public sealed virtual int get_Length();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Metrics.StringSequence2 : ValueType {
    public string Value1;
    public string Value2;
    public string Item { get; public set; }
    public int Length { get; }
    public StringSequence2(string value1, string value2);
    public sealed virtual bool Equals(StringSequence2 other);
    public virtual bool Equals(object obj);
    public sealed virtual string get_Item(int i);
    public sealed virtual void set_Item(int i, string value);
    public sealed virtual int get_Length();
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Metrics.StringSequence3 : ValueType {
    public string Value1;
    public string Value2;
    public string Value3;
    public string Item { get; public set; }
    public int Length { get; }
    public StringSequence3(string value1, string value2, string value3);
    public sealed virtual bool Equals(StringSequence3 other);
    public virtual bool Equals(object obj);
    public sealed virtual string get_Item(int i);
    public sealed virtual void set_Item(int i, string value);
    public sealed virtual int get_Length();
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Metrics.StringSequenceMany : ValueType {
    private String[] _values;
    public string Item { get; public set; }
    public int Length { get; }
    public StringSequenceMany(String[] values);
    public Span`1<string> AsSpan();
    public sealed virtual bool Equals(StringSequenceMany other);
    public virtual bool Equals(object obj);
    public sealed virtual string get_Item(int i);
    public sealed virtual void set_Item(int i, string value);
    public sealed virtual int get_Length();
    public virtual int GetHashCode();
}
internal class System.Diagnostics.Metrics.UpDownCounter`1 : Instrument`1<T> {
    internal UpDownCounter`1(Meter meter, string name, string unit, string description);
    internal UpDownCounter`1(Meter meter, string name, string unit, string description, IEnumerable`1<KeyValuePair`2<string, object>> tags);
    public void Add(T delta);
    public void Add(T delta, KeyValuePair`2<string, object> tag);
    public void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public void Add(T delta, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    public void Add(T delta, KeyValuePair`2[] tags);
    public void Add(T delta, TagList& tagList);
}
internal class System.Diagnostics.NoOutputPropagator : DistributedContextPropagator {
    [CompilerGeneratedAttribute]
private static DistributedContextPropagator <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Fields>k__BackingField;
    internal static DistributedContextPropagator Instance { get; }
    public IReadOnlyCollection`1<string> Fields { get; }
    private static NoOutputPropagator();
    [CompilerGeneratedAttribute]
internal static DistributedContextPropagator get_Instance();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyCollection`1<string> get_Fields();
    public virtual void Inject(Activity activity, object carrier, PropagatorSetterCallback setter);
    public virtual void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, String& traceId, String& traceState);
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter);
}
internal class System.Diagnostics.PassThroughPropagator : DistributedContextPropagator {
    [CompilerGeneratedAttribute]
private static DistributedContextPropagator <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Fields>k__BackingField;
    internal static DistributedContextPropagator Instance { get; }
    public IReadOnlyCollection`1<string> Fields { get; }
    private static PassThroughPropagator();
    [CompilerGeneratedAttribute]
internal static DistributedContextPropagator get_Instance();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyCollection`1<string> get_Fields();
    public virtual void Inject(Activity activity, object carrier, PropagatorSetterCallback setter);
    public virtual void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, String& traceId, String& traceState);
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter);
    private static void GetRootId(String& parentId, String& traceState, Boolean& isW3c, IEnumerable`1& baggage);
}
internal class System.Diagnostics.RandomNumberGenerator : object {
    [ThreadStaticAttribute]
private static RandomNumberGenerator t_random;
    private ulong _s0;
    private ulong _s1;
    private ulong _s2;
    private ulong _s3;
    public static RandomNumberGenerator Current { get; }
    public static RandomNumberGenerator get_Current();
    private static ulong Rol64(ulong x, int k);
    public long Next();
}
internal class System.Diagnostics.SampleActivity`1 : MulticastDelegate {
    public SampleActivity`1(object object, IntPtr method);
    public virtual ActivitySamplingResult Invoke(ActivityCreationOptions`1& options);
    public virtual IAsyncResult BeginInvoke(ActivityCreationOptions`1& options, AsyncCallback callback, object object);
    public virtual ActivitySamplingResult EndInvoke(ActivityCreationOptions`1& options, IAsyncResult result);
}
[AttributeUsageAttribute("108")]
internal class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
internal class System.Diagnostics.SynchronizedList`1 : object {
    private List`1<T> _list;
    private UInt32 _version;
    public int Count { get; }
    public void Add(T item);
    public bool AddIfNotExist(T item);
    public bool Remove(T item);
    public int get_Count();
    public void EnumWithFunc(Function`2<T, TParent> func, ActivityCreationOptions`1& data, ActivitySamplingResult& samplingResult, ActivityCreationOptions`1& dataWithContext);
    public void EnumWithAction(Action`2<T, object> action, object arg);
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.TagList : ValueType {
    internal KeyValuePair`2<string, object> Tag1;
    internal KeyValuePair`2<string, object> Tag2;
    internal KeyValuePair`2<string, object> Tag3;
    internal KeyValuePair`2<string, object> Tag4;
    internal KeyValuePair`2<string, object> Tag5;
    internal KeyValuePair`2<string, object> Tag6;
    internal KeyValuePair`2<string, object> Tag7;
    internal KeyValuePair`2<string, object> Tag8;
    private int _tagsCount;
    private KeyValuePair`2[] _overflowTags;
    private static int OverflowAdditionalCapacity;
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<string, object> Item { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal KeyValuePair`2[] Tags { get; }
    public TagList(ReadOnlySpan`1<KeyValuePair`2<string, object>> tagList);
    [IsReadOnlyAttribute]
public sealed virtual int get_Count();
    [IsReadOnlyAttribute]
public sealed virtual bool get_IsReadOnly();
    [IsReadOnlyAttribute]
public sealed virtual KeyValuePair`2<string, object> get_Item(int index);
    public sealed virtual void set_Item(int index, KeyValuePair`2<string, object> value);
    [NullableContextAttribute("1")]
public void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> tag);
    [IsReadOnlyAttribute]
public void CopyTo(Span`1<KeyValuePair`2<string, object>> tags);
    [IsReadOnlyAttribute]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual void Insert(int index, KeyValuePair`2<string, object> item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    [IsReadOnlyAttribute]
public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    [IsReadOnlyAttribute]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    [IsReadOnlyAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IsReadOnlyAttribute]
public sealed virtual int IndexOf(KeyValuePair`2<string, object> item);
    [IsReadOnlyAttribute]
internal KeyValuePair`2[] get_Tags();
    private static bool TagsEqual(KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    private void MoveTagsToTheArray();
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument task;
    public static ExceptionArgument source;
    public static ExceptionArgument state;
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
private string ToStringFromEnd();
}
internal interface System.ITupleInternal {
    public int Size { get; }
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual int get_Size();
    public abstract virtual string ToStringEnd();
}
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.Memory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    private static int RemoveFlagsBitMask;
    public static Memory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    internal Memory`1(T[] array, int start);
    public Memory`1(T[] array, int start, int length);
    internal Memory`1(MemoryManager`1<T> manager, int length);
    internal Memory`1(MemoryManager`1<T> manager, int start, int length);
    internal Memory`1(object obj, int start, int length);
    public static Memory`1<T> op_Implicit(T[] array);
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(Memory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
}
internal class System.MemoryDebugView`1 : object {
    private ReadOnlyMemory`1<T> _memory;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public MemoryDebugView`1(Memory`1<T> memory);
    public MemoryDebugView`1(ReadOnlyMemory`1<T> memory);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.MemoryExtensions : object {
    internal static IntPtr StringAdjustment;
    private static MemoryExtensions();
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    private static bool IsTypeComparableAsBytes(NUInt& size);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    private static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    private static int CompareToOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
    private static IntPtr MeasureStringAdjustment();
}
internal class System.MutableDecimal : ValueType {
    public UInt32 Flags;
    public UInt32 High;
    public UInt32 Low;
    public UInt32 Mid;
    private static UInt32 SignMask;
    private static UInt32 ScaleMask;
    private static int ScaleShift;
    public bool IsNegative { get; public set; }
    public int Scale { get; public set; }
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public int get_Scale();
    public void set_Scale(int value);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
internal class System.NUInt : ValueType {
    private Void* _value;
    private NUInt(UInt32 value);
    private NUInt(ulong value);
    public static NUInt op_Implicit(UInt32 value);
    public static IntPtr op_Implicit(NUInt value);
    public static NUInt op_Explicit(int value);
    public static Void* op_Explicit(NUInt value);
    public static NUInt op_Multiply(NUInt left, NUInt right);
}
internal static class System.Number : object {
    internal static int DECIMAL_PRECISION;
    private static UInt64[] s_rgval64Power10;
    private static SByte[] s_rgexp64Power10;
    private static UInt64[] s_rgval64Power10By16;
    private static Int16[] s_rgexp64Power10By16;
    private static Number();
    public static void RoundNumber(NumberBuffer& number, int pos);
    internal static bool NumberBufferToDouble(NumberBuffer& number, Double& value);
    public static bool NumberBufferToDecimal(NumberBuffer& number, Decimal& value);
    public static void DecimalToNumber(decimal value, NumberBuffer& number);
    private static UInt32 DigitsToInt(ReadOnlySpan`1<byte> digits, int count);
    private static ulong Mul32x32To64(UInt32 a, UInt32 b);
    private static ulong Mul64Lossy(ulong a, ulong b, Int32& pexp);
    private static int abs(int value);
    private static double NumberToDouble(NumberBuffer& number);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.NumberBuffer : ValueType {
    public int Scale;
    public bool IsNegative;
    public static int BufferSize;
    private byte _b0;
    private byte _b1;
    private byte _b2;
    private byte _b3;
    private byte _b4;
    private byte _b5;
    private byte _b6;
    private byte _b7;
    private byte _b8;
    private byte _b9;
    private byte _b10;
    private byte _b11;
    private byte _b12;
    private byte _b13;
    private byte _b14;
    private byte _b15;
    private byte _b16;
    private byte _b17;
    private byte _b18;
    private byte _b19;
    private byte _b20;
    private byte _b21;
    private byte _b22;
    private byte _b23;
    private byte _b24;
    private byte _b25;
    private byte _b26;
    private byte _b27;
    private byte _b28;
    private byte _b29;
    private byte _b30;
    private byte _b31;
    private byte _b32;
    private byte _b33;
    private byte _b34;
    private byte _b35;
    private byte _b36;
    private byte _b37;
    private byte _b38;
    private byte _b39;
    private byte _b40;
    private byte _b41;
    private byte _b42;
    private byte _b43;
    private byte _b44;
    private byte _b45;
    private byte _b46;
    private byte _b47;
    private byte _b48;
    private byte _b49;
    private byte _b50;
    public Span`1<byte> Digits { get; }
    public Byte* UnsafeDigits { get; }
    public int NumDigits { get; }
    public Span`1<byte> get_Digits();
    public Byte* get_UnsafeDigits();
    public int get_NumDigits();
    [ConditionalAttribute("DEBUG")]
public void CheckConsistency();
    public virtual string ToString();
}
internal static class System.Numerics.Hashing.<805945f3-27b0-47ad-b8f6-389d9d8f82c3>HashHelpers : object {
    public static int RandomSeed;
    private static <805945f3-27b0-47ad-b8f6-389d9d8f82c3>HashHelpers();
    public static int Combine(int h1, int h2);
}
internal static class System.Numerics.Hashing.HashHelpers : object {
    public static int RandomSeed;
    private static HashHelpers();
    public static int Combine(int h1, int h2);
}
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string SystemTextEncodingUTF7Message;
    internal static string SystemTextEncodingUTF7DiagId;
    internal static string PrincipalPermissionAttributeMessage;
    internal static string PrincipalPermissionAttributeDiagId;
    internal static string CodeAccessSecurityMessage;
    internal static string CodeAccessSecurityDiagId;
    internal static string ConstrainedExecutionRegionMessage;
    internal static string ConstrainedExecutionRegionDiagId;
    internal static string GlobalAssemblyCacheMessage;
    internal static string GlobalAssemblyCacheDiagId;
    internal static string ThreadAbortMessage;
    internal static string ThreadResetAbortMessage;
    internal static string ThreadAbortDiagId;
    internal static string DefaultCryptoAlgorithmsMessage;
    internal static string DefaultCryptoAlgorithmsDiagId;
    internal static string CreatePdbGeneratorMessage;
    internal static string CreatePdbGeneratorDiagId;
    internal static string AuthenticationManagerMessage;
    internal static string AuthenticationManagerDiagId;
    internal static string RemotingApisMessage;
    internal static string RemotingApisDiagId;
    internal static string BinaryFormatterMessage;
    internal static string BinaryFormatterDiagId;
    internal static string CodeBaseMessage;
    internal static string CodeBaseDiagId;
    internal static string EscapeUriStringMessage;
    internal static string EscapeUriStringDiagId;
    internal static string WebRequestMessage;
    internal static string WebRequestDiagId;
    internal static string DisablePrivateReflectionAttributeMessage;
    internal static string DisablePrivateReflectionAttributeDiagId;
    internal static string GetContextInfoMessage;
    internal static string GetContextInfoDiagId;
    internal static string StrongNameKeyPairMessage;
    internal static string StrongNameKeyPairDiagId;
    internal static string ReflectionOnlyLoadingMessage;
    internal static string ReflectionOnlyLoadingDiagId;
    internal static string RuntimeEnvironmentMessage;
    internal static string RuntimeEnvironmentDiagId;
    internal static string JsonSerializerOptionsIgnoreNullValuesMessage;
    internal static string JsonSerializerOptionsIgnoreNullValuesDiagId;
    internal static string DerivedCryptographicTypesMessage;
    internal static string DerivedCryptographicTypesDiagId;
    internal static string RijndaelMessage;
    internal static string RijndaelDiagId;
    internal static string RNGCryptoServiceProviderMessage;
    internal static string RNGCryptoServiceProviderDiagId;
    internal static string AppDomainCreateUnloadMessage;
    internal static string AppDomainCreateUnloadDiagId;
    internal static string SuppressIldasmAttributeMessage;
    internal static string SuppressIldasmAttributeDiagId;
    internal static string X509CertificateImmutableMessage;
    internal static string X509CertificateImmutableDiagId;
    internal static string PublicKeyPropertyMessage;
    internal static string PublicKeyPropertyDiagId;
    internal static string X509CertificatePrivateKeyMessage;
    internal static string X509CertificatePrivateKeyDiagId;
    internal static string ProduceLegacyHmacValuesMessage;
    internal static string ProduceLegacyHmacValuesDiagId;
    internal static string UseManagedSha1Message;
    internal static string UseManagedSha1DiagId;
    internal static string CryptoConfigEncodeOIDMessage;
    internal static string CryptoConfigEncodeOIDDiagId;
    internal static string CorruptedStateRecoveryMessage;
    internal static string CorruptedStateRecoveryDiagId;
    internal static string Rfc2898CryptDeriveKeyMessage;
    internal static string Rfc2898CryptDeriveKeyDiagId;
    internal static string CmsSignerCspParamsCtorMessage;
    internal static string CmsSignerCspParamsCtorDiagId;
    internal static string SignerInfoCounterSigMessage;
    internal static string SignerInfoCounterSigDiagId;
    internal static string RegexCompileToAssemblyMessage;
    internal static string RegexCompileToAssemblyDiagId;
    internal static string AssemblyNameMembersMessage;
    internal static string AssemblyNameMembersDiagId;
    internal static string SystemDataSerializationFormatBinaryMessage;
    internal static string SystemDataSerializationFormatBinaryDiagId;
    internal static string TlsVersion10and11Message;
    internal static string TlsVersion10and11DiagId;
    internal static string EncryptionPolicyMessage;
    internal static string EncryptionPolicyDiagId;
    internal static string Rfc2898OutdatedCtorMessage;
    internal static string Rfc2898OutdatedCtorDiagId;
    internal static string EccXmlExportImportMessage;
    internal static string EccXmlExportImportDiagId;
    internal static string EcDhPublicKeyBlobMessage;
    internal static string EcDhPublicKeyBlobDiagId;
    internal static string AssemblyNameCodeBaseMessage;
    internal static string AssemblyNameCodeBaseDiagId;
    internal static string CryptoStringFactoryMessage;
    internal static string CryptoStringFactoryDiagId;
    internal static string ControlledExecutionRunMessage;
    internal static string ControlledExecutionRunDiagId;
    internal static string XmlSecureResolverMessage;
    internal static string XmlSecureResolverDiagId;
    internal static string RsaEncryptDecryptValueMessage;
    internal static string RsaEncryptDecryptDiagId;
    internal static string JsonSerializerOptionsAddContextMessage;
    internal static string JsonSerializerOptionsAddContextDiagId;
    internal static string LegacyFormatterMessage;
    internal static string LegacyFormatterDiagId;
    internal static string LegacyFormatterImplMessage;
    internal static string LegacyFormatterImplDiagId;
    internal static string RegexExtensibilityImplMessage;
    internal static string RegexExtensibilityDiagId;
    internal static string AesGcmTagConstructorMessage;
    internal static string AesGcmTagConstructorDiagId;
}
internal class System.Pinnable`1 : object {
    public T Data;
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.ReadOnlyMemory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    internal static int RemoveFlagsBitMask;
    public static ReadOnlyMemory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    internal ReadOnlyMemory`1(object obj, int start, int length);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
    internal object GetObjectStartLength(Int32& start, Int32& length);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
public class System.ReadOnlySpan`1 : ValueType {
    private Pinnable`1<T> _pinnable;
    private IntPtr _byteOffset;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public static ReadOnlySpan`1<T> Empty { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    internal Pinnable`1<T> Pinnable { get; }
    internal IntPtr ByteOffset { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    internal ReadOnlySpan`1(Pinnable`1<T> pinnable, IntPtr byteOffset, int length);
    public int get_Length();
    public bool get_IsEmpty();
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public virtual string ToString();
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
internal T& DangerousGetPinnableReference();
    internal Pinnable`1<T> get_Pinnable();
    internal IntPtr get_ByteOffset();
}
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
internal static class System.Runtime.CompilerServices.<02d5b7fd-c5c5-4143-9044-935b13098f35>IsExternalInit : object {
}
[AttributeUsageAttribute("5148")]
internal class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
}
internal class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask Task { get; }
    public static AsyncValueTaskMethodBuilder Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
internal class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    private AsyncTaskMethodBuilder`1<TResult> _methodBuilder;
    private TResult _result;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask`1<TResult> Task { get; }
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CollectionBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public Type BuilderType { get; }
    public string MethodName { get; }
    public CollectionBuilderAttribute(Type builderType, string methodName);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
    [CompilerGeneratedAttribute]
public string get_MethodName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
}
[IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private ValueTask _value;
    internal ConfiguredValueTaskAwaitable(ValueTask value);
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private ValueTask`1<TResult> _value;
    internal ConfiguredValueTaskAwaitable`1(ValueTask`1<TResult> value);
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
[AttributeUsageAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[AttributeUsageAttribute("27524")]
[EmbeddedAttribute]
[CompilerGeneratedAttribute]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] A_0);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiresLocationAttribute : Attribute {
}
[AttributeUsageAttribute("1774")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("11148")]
internal class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    private String[] _transformNames;
    public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
internal static class System.Runtime.CompilerServices.Unsafe : object {
    [NonVersionableAttribute]
public static T Read(Void* source);
    [NonVersionableAttribute]
public static T ReadUnaligned(Void* source);
    [NonVersionableAttribute]
public static T ReadUnaligned(Byte& source);
    [NonVersionableAttribute]
public static void Write(Void* destination, T value);
    [NonVersionableAttribute]
public static void WriteUnaligned(Void* destination, T value);
    [NonVersionableAttribute]
public static void WriteUnaligned(Byte& destination, T value);
    [NonVersionableAttribute]
public static void Copy(Void* destination, T& source);
    [NonVersionableAttribute]
public static void Copy(T& destination, Void* source);
    [NonVersionableAttribute]
public static Void* AsPointer(T& value);
    [NonVersionableAttribute]
public static void SkipInit(T& value);
    [NonVersionableAttribute]
public static int SizeOf();
    [NonVersionableAttribute]
public static void CopyBlock(Void* destination, Void* source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlock(Byte& destination, Byte& source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlockUnaligned(Void* destination, Void* source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlockUnaligned(Byte& destination, Byte& source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlock(Void* startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlock(Byte& startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlockUnaligned(Void* startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static T As(object o);
    [NonVersionableAttribute]
public static T& AsRef(Void* source);
    [NonVersionableAttribute]
public static T& AsRef(T& source);
    [NonVersionableAttribute]
public static TTo& As(TFrom& source);
    [NonVersionableAttribute]
public static T& Unbox(object box);
    [NonVersionableAttribute]
public static T& Add(T& source, int elementOffset);
    [NonVersionableAttribute]
public static Void* Add(Void* source, int elementOffset);
    [NonVersionableAttribute]
public static T& Add(T& source, IntPtr elementOffset);
    public static T& Add(T& source, UIntPtr elementOffset);
    [NonVersionableAttribute]
public static T& AddByteOffset(T& source, IntPtr byteOffset);
    public static T& AddByteOffset(T& source, UIntPtr byteOffset);
    [NonVersionableAttribute]
public static T& Subtract(T& source, int elementOffset);
    [NonVersionableAttribute]
public static Void* Subtract(Void* source, int elementOffset);
    [NonVersionableAttribute]
public static T& Subtract(T& source, IntPtr elementOffset);
    public static T& Subtract(T& source, UIntPtr elementOffset);
    [NonVersionableAttribute]
public static T& SubtractByteOffset(T& source, IntPtr byteOffset);
    public static T& SubtractByteOffset(T& source, UIntPtr byteOffset);
    [NonVersionableAttribute]
public static IntPtr ByteOffset(T& origin, T& target);
    [NonVersionableAttribute]
public static bool AreSame(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsAddressGreaterThan(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsAddressLessThan(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsNullRef(T& source);
    [NonVersionableAttribute]
public static T& NullRef();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.CompilerServices.UnsafeAccessorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UnsafeAccessorKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public UnsafeAccessorKind Kind { get; }
    public string Name { get; public set; }
    public UnsafeAccessorAttribute(UnsafeAccessorKind kind);
    [CompilerGeneratedAttribute]
public UnsafeAccessorKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal enum System.Runtime.CompilerServices.UnsafeAccessorKind : Enum {
    public int value__;
    public static UnsafeAccessorKind Constructor;
    public static UnsafeAccessorKind Method;
    public static UnsafeAccessorKind StaticMethod;
    public static UnsafeAccessorKind Field;
    public static UnsafeAccessorKind StaticField;
}
[IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    internal static Action`1<object> s_invokeActionDelegate;
    private ValueTask _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter(ValueTask value);
    private static ValueTaskAwaiter();
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private ValueTask`1<TResult> _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter`1(ValueTask`1<TResult> value);
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public TResult GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("8")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.CompilerServices2.InlineArrayAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public InlineArrayAttribute(int length);
    [CompilerGeneratedAttribute]
public int get_Length();
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.<d09c9507-1983-461f-8fce-f8aba78858d6>LibraryImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private <d09c9507-1983-461f-8fce-f8aba78858d6>StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public <d09c9507-1983-461f-8fce-f8aba78858d6>StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    public bool SetLastError { get; public set; }
    public <d09c9507-1983-461f-8fce-f8aba78858d6>LibraryImportAttribute(string libraryName);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public <d09c9507-1983-461f-8fce-f8aba78858d6>StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public void set_StringMarshalling(<d09c9507-1983-461f-8fce-f8aba78858d6>StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public void set_StringMarshallingCustomType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public void set_SetLastError(bool value);
}
internal enum System.Runtime.InteropServices.<d09c9507-1983-461f-8fce-f8aba78858d6>StringMarshalling : Enum {
    public int value__;
    public static <d09c9507-1983-461f-8fce-f8aba78858d6>StringMarshalling Custom;
    public static <d09c9507-1983-461f-8fce-f8aba78858d6>StringMarshalling Utf8;
    public static <d09c9507-1983-461f-8fce-f8aba78858d6>StringMarshalling Utf16;
}
internal enum System.Runtime.InteropServices.Architecture : Enum {
    public int value__;
    public static Architecture X86;
    public static Architecture X64;
    public static Architecture Arm;
    public static Architecture Arm64;
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.LibraryImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    public bool SetLastError { get; public set; }
    public LibraryImportAttribute(string libraryName);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public void set_StringMarshalling(StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public void set_StringMarshallingCustomType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public void set_SetLastError(bool value);
}
internal static class System.Runtime.InteropServices.MemoryMarshal : object {
    public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<ToEnumerable>d__3`1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static void Write(Span`1<byte> destination, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    public static T& GetReference(Span`1<T> span);
    public static T& GetReference(ReadOnlySpan`1<T> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
}
internal class System.Runtime.InteropServices.OSPlatform : ValueType {
    private string _osPlatform;
    [CompilerGeneratedAttribute]
private static OSPlatform <Linux>k__BackingField;
    [CompilerGeneratedAttribute]
private static OSPlatform <OSX>k__BackingField;
    [CompilerGeneratedAttribute]
private static OSPlatform <Windows>k__BackingField;
    public static OSPlatform Linux { get; }
    public static OSPlatform OSX { get; }
    public static OSPlatform Windows { get; }
    private OSPlatform(string osPlatform);
    private static OSPlatform();
    [CompilerGeneratedAttribute]
public static OSPlatform get_Linux();
    [CompilerGeneratedAttribute]
public static OSPlatform get_OSX();
    [CompilerGeneratedAttribute]
public static OSPlatform get_Windows();
    public static OSPlatform Create(string osPlatform);
    public sealed virtual bool Equals(OSPlatform other);
    internal bool Equals(string other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(OSPlatform left, OSPlatform right);
    public static bool op_Inequality(OSPlatform left, OSPlatform right);
}
internal static class System.Runtime.InteropServices.RuntimeInformation : object {
    private static string s_osDescription;
    private static object s_osLock;
    private static object s_processLock;
    private static Nullable`1<Architecture> s_osArch;
    private static Nullable`1<Architecture> s_processArch;
    private static string FrameworkName;
    private static string s_frameworkDescription;
    public static string OSDescription { get; }
    public static Architecture OSArchitecture { get; }
    public static Architecture ProcessArchitecture { get; }
    public static string FrameworkDescription { get; }
    private static RuntimeInformation();
    public static bool IsOSPlatform(OSPlatform osPlatform);
    public static string get_OSDescription();
    public static Architecture get_OSArchitecture();
    public static Architecture get_ProcessArchitecture();
    public static string get_FrameworkDescription();
}
internal static class System.Runtime.InteropServices.SequenceMarshal : object {
    public static bool TryGetReadOnlySequenceSegment(ReadOnlySequence`1<T> sequence, ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    public static bool TryGetArray(ReadOnlySequence`1<T> sequence, ArraySegment`1& segment);
    public static bool TryGetReadOnlyMemory(ReadOnlySequence`1<T> sequence, ReadOnlyMemory`1& memory);
    internal static bool TryGetString(ReadOnlySequence`1<char> sequence, String& text, Int32& start, Int32& length);
}
internal enum System.Runtime.InteropServices.StringMarshalling : Enum {
    public int value__;
    public static StringMarshalling Custom;
    public static StringMarshalling Utf8;
    public static StringMarshalling Utf16;
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.InteropServices.SuppressGCTransitionAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute : Attribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Type[] CallConvs;
    [NullableAttribute("2")]
public string EntryPoint;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2047")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.Versioning.<02d5b7fd-c5c5-4143-9044-935b13098f35>ObsoletedOSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>ObsoletedOSPlatformAttribute(string platformName);
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>ObsoletedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("2047")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.Versioning.<02d5b7fd-c5c5-4143-9044-935b13098f35>SupportedOSPlatformAttribute : Attribute {
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>SupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.Versioning.<02d5b7fd-c5c5-4143-9044-935b13098f35>SupportedOSPlatformGuardAttribute : Attribute {
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>SupportedOSPlatformGuardAttribute(string platformName);
}
[AttributeUsageAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.Versioning.<02d5b7fd-c5c5-4143-9044-935b13098f35>TargetPlatformAttribute : Attribute {
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>TargetPlatformAttribute(string platformName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2047")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.Versioning.<02d5b7fd-c5c5-4143-9044-935b13098f35>UnsupportedOSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>UnsupportedOSPlatformAttribute(string platformName);
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>UnsupportedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
[AttributeUsageAttribute("448")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.Versioning.<02d5b7fd-c5c5-4143-9044-935b13098f35>UnsupportedOSPlatformGuardAttribute : Attribute {
    [NullableContextAttribute("1")]
public <02d5b7fd-c5c5-4143-9044-935b13098f35>UnsupportedOSPlatformGuardAttribute(string platformName);
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.ObsoletedOSPlatformAttribute : OSPlatformAttribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public ObsoletedOSPlatformAttribute(string platformName);
    public ObsoletedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
internal abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public string PlatformName { get; }
    private protected OSPlatformAttribute(string platformName);
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresPreviewFeaturesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
    public SupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public SupportedOSPlatformGuardAttribute(string platformName);
}
[AttributeUsageAttribute("1")]
internal class System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
    public TargetPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public UnsupportedOSPlatformAttribute(string platformName);
    public UnsupportedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformGuardAttribute(string platformName);
}
[IsReadOnlyAttribute]
public class System.SequencePosition : ValueType {
    private object _object;
    private int _integer;
    public SequencePosition(object object, int integer);
    [EditorBrowsableAttribute("1")]
public object GetObject();
    [EditorBrowsableAttribute("1")]
public int GetInteger();
    public sealed virtual bool Equals(SequencePosition other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
public class System.Span`1 : ValueType {
    private Pinnable`1<T> _pinnable;
    private IntPtr _byteOffset;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public static Span`1<T> Empty { get; }
    public T& Item { get; }
    internal Pinnable`1<T> Pinnable { get; }
    internal IntPtr ByteOffset { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    internal Span`1(Pinnable`1<T> pinnable, IntPtr byteOffset, int length);
    public int get_Length();
    public bool get_IsEmpty();
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static Span`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
    internal static Span`1<T> Create(T[] array, int start);
    public T& get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public virtual string ToString();
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
internal T& DangerousGetPinnableReference();
    internal Pinnable`1<T> get_Pinnable();
    internal IntPtr get_ByteOffset();
}
internal class System.SpanDebugView`1 : object {
    private T[] _array;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SpanDebugView`1(Span`1<T> span);
    public SpanDebugView`1(ReadOnlySpan`1<T> span);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.SpanHelpers : object {
    private static ulong XorPowerOfTwoToHighByte;
    private static ulong XorPowerOfTwoToHighChar;
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    public static int BinarySearch(T& spanStart, int length, TComparable comparable);
    public static int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOf(Byte& searchSpace, byte value, int length);
    public static int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOf(Byte& searchSpace, byte value, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static bool SequenceEqual(Byte& first, Byte& second, NUInt length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    public static int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength);
    private static int LocateLastFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    private static int LocateLastFoundByte(ulong match);
    private static Vector`1<byte> GetVector(byte vectorByte);
    public static int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength);
    public static int IndexOf(Char& searchSpace, char value, int length);
    public static int LastIndexOf(Char& searchSpace, char value, int length);
    private static int LocateFirstFoundChar(Vector`1<ushort> match);
    private static int LocateFirstFoundChar(ulong match);
    private static int LocateLastFoundChar(Vector`1<ushort> match);
    private static int LocateLastFoundChar(ulong match);
    public static int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int IndexOf(T& searchSpace, T value, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, T value, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool SequenceEqual(T& first, T& second, int length);
    public static int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength);
    public static void CopyTo(T& dst, int dstLength, T& src, int srcLength);
    [ExtensionAttribute]
public static IntPtr Add(IntPtr start, int index);
    public static bool IsReferenceOrContainsReferences();
    private static bool IsReferenceOrContainsReferencesCore(Type type);
    public static void ClearLessThanPointerSized(Byte* ptr, UIntPtr byteLength);
    public static void ClearLessThanPointerSized(Byte& b, UIntPtr byteLength);
    public static void ClearPointerSizedWithoutReferences(Byte& b, UIntPtr byteLength);
    public static void ClearPointerSizedWithReferences(IntPtr& ip, UIntPtr pointerSizeLength);
    [ExtensionAttribute]
private static bool LessThanEqual(IntPtr index, UIntPtr length);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string ArgumentException_ValueTupleIncorrectType { get; }
    internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_ArgumentException_ValueTupleIncorrectType();
    internal static string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple();
}
internal abstract class System.Threading.Channels.AsyncOperation : object {
    protected static Action`1<object> s_availableSentinel;
    protected static Action`1<object> s_completedSentinel;
    private static AsyncOperation();
    private static void AvailableSentinel(object s);
    private static void CompletedSentinel(object s);
    protected static void ThrowIncompleteOperationException();
    protected static void ThrowMultipleContinuations();
    protected static void ThrowIncorrectCurrentIdException();
}
internal class System.Threading.Channels.AsyncOperation`1 : AsyncOperation {
    private CancellationTokenRegistration _registration;
    private bool _pooled;
    private bool _runContinuationsAsynchronously;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _completionReserved;
    private TResult _result;
    private ExceptionDispatchInfo _error;
    private Action`1<object> _continuation;
    private object _continuationState;
    private object _schedulingContext;
    private ExecutionContext _executionContext;
    private short _currentId;
    [CompilerGeneratedAttribute]
private AsyncOperation`1<TResult> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public AsyncOperation`1<TResult> Next { get; public set; }
    public CancellationToken CancellationToken { get; }
    public ValueTask ValueTask { get; }
    public ValueTask`1<TResult> ValueTaskOfT { get; }
    internal bool IsCompleted { get; }
    public AsyncOperation`1(bool runContinuationsAsynchronously, CancellationToken cancellationToken, bool pooled);
    [CompilerGeneratedAttribute]
public AsyncOperation`1<TResult> get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(AsyncOperation`1<TResult> value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    public ValueTask get_ValueTask();
    public ValueTask`1<TResult> get_ValueTaskOfT();
    public sealed virtual ValueTaskSourceStatus GetStatus(short token);
    internal bool get_IsCompleted();
    public sealed virtual TResult GetResult(short token);
    private sealed virtual override void System.Threading.Tasks.Sources.IValueTaskSource.GetResult(short token);
    public bool TryOwnAndReset();
    public sealed virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public bool UnregisterCancellation();
    public bool TrySetResult(TResult item);
    public bool TrySetException(Exception exception);
    public bool TrySetCanceled(CancellationToken cancellationToken);
    private bool TryReserveCompletionIfCancelable();
    private void SignalCompletion();
    private void SetCompletionAndInvokeContinuation();
    private void UnsafeQueueSetCompletionAndInvokeContinuation();
    private static void UnsafeQueueUserWorkItem(Action`1<object> action, object state);
    private static void QueueUserWorkItem(Action`1<object> action, object state);
    private static CancellationTokenRegistration UnsafeRegister(CancellationToken cancellationToken, Action`1<object> action, object state);
}
[DebuggerDisplayAttribute("Items = {ItemsCountForDebugger}, Capacity = {_bufferedCapacity}, Mode = {_mode}, Closed = {ChannelIsClosedForDebugger}")]
[DebuggerTypeProxyAttribute("System.Threading.Channels.DebugEnumeratorDebugView`1")]
internal class System.Threading.Channels.BoundedChannel`1 : Channel`1<T> {
    private BoundedChannelFullMode _mode;
    private Action`1<T> _itemDropped;
    private TaskCompletionSource _completion;
    private int _bufferedCapacity;
    private Deque`1<T> _items;
    private Deque`1<AsyncOperation`1<T>> _blockedReaders;
    private Deque`1<VoidAsyncOperationWithData`1<T>> _blockedWriters;
    private AsyncOperation`1<bool> _waitingReadersTail;
    private AsyncOperation`1<bool> _waitingWritersTail;
    private bool _runContinuationsAsynchronously;
    private Exception _doneWriting;
    private object SyncObj { get; }
    private int ItemsCountForDebugger { get; }
    private bool ChannelIsClosedForDebugger { get; }
    internal BoundedChannel`1(int bufferedCapacity, BoundedChannelFullMode mode, bool runContinuationsAsynchronously, Action`1<T> itemDropped);
    private object get_SyncObj();
    [ConditionalAttribute("DEBUG")]
private void AssertInvariants();
    private int get_ItemsCountForDebugger();
    private bool get_ChannelIsClosedForDebugger();
    private sealed virtual override IEnumerator`1<T> System.Threading.Channels.IDebugEnumerable<T>.GetEnumerator();
}
internal enum System.Threading.Channels.BoundedChannelFullMode : Enum {
    public int value__;
    public static BoundedChannelFullMode Wait;
    public static BoundedChannelFullMode DropNewest;
    public static BoundedChannelFullMode DropOldest;
    public static BoundedChannelFullMode DropWrite;
}
internal class System.Threading.Channels.BoundedChannelOptions : ChannelOptions {
    private int _capacity;
    private BoundedChannelFullMode _mode;
    public int Capacity { get; public set; }
    public BoundedChannelFullMode FullMode { get; public set; }
    public BoundedChannelOptions(int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public BoundedChannelFullMode get_FullMode();
    public void set_FullMode(BoundedChannelFullMode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Threading.Channels.Channel : object {
    public static Channel`1<T> CreateUnbounded();
    public static Channel`1<T> CreateUnbounded(UnboundedChannelOptions options);
    public static Channel`1<T> CreateBounded(int capacity);
    public static Channel`1<T> CreateBounded(BoundedChannelOptions options);
    public static Channel`1<T> CreateBounded(BoundedChannelOptions options, Action`1<T> itemDropped);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class System.Threading.Channels.Channel`1 : Channel`2<T, T> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Threading.Channels.Channel`2 : object {
    [CompilerGeneratedAttribute]
private ChannelReader`1<TRead> <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelWriter`1<TWrite> <Writer>k__BackingField;
    public ChannelReader`1<TRead> Reader { get; protected set; }
    public ChannelWriter`1<TWrite> Writer { get; protected set; }
    [CompilerGeneratedAttribute]
public ChannelReader`1<TRead> get_Reader();
    [CompilerGeneratedAttribute]
protected void set_Reader(ChannelReader`1<TRead> value);
    [CompilerGeneratedAttribute]
public ChannelWriter`1<TWrite> get_Writer();
    [CompilerGeneratedAttribute]
protected void set_Writer(ChannelWriter`1<TWrite> value);
    public static ChannelReader`1<TRead> op_Implicit(Channel`2<TWrite, TRead> channel);
    public static ChannelWriter`1<TWrite> op_Implicit(Channel`2<TWrite, TRead> channel);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Threading.Channels.ChannelClosedException : InvalidOperationException {
    public ChannelClosedException(string message);
    public ChannelClosedException(Exception innerException);
    public ChannelClosedException(string message, Exception innerException);
}
internal abstract class System.Threading.Channels.ChannelOptions : object {
    [CompilerGeneratedAttribute]
private bool <SingleWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SingleReader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousContinuations>k__BackingField;
    public bool SingleWriter { get; public set; }
    public bool SingleReader { get; public set; }
    public bool AllowSynchronousContinuations { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SingleWriter();
    [CompilerGeneratedAttribute]
public void set_SingleWriter(bool value);
    [CompilerGeneratedAttribute]
public bool get_SingleReader();
    [CompilerGeneratedAttribute]
public void set_SingleReader(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowSynchronousContinuations();
    [CompilerGeneratedAttribute]
public void set_AllowSynchronousContinuations(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Threading.Channels.ChannelReader`1 : object {
    public Task Completion { get; }
    public bool CanCount { get; }
    public bool CanPeek { get; }
    public int Count { get; }
    public virtual Task get_Completion();
    public virtual bool get_CanCount();
    public virtual bool get_CanPeek();
    public virtual int get_Count();
    public abstract virtual bool TryRead(T& item);
    public virtual bool TryPeek(T& item);
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<bool> WaitToReadAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<T> ReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Threading.Channels.ChannelReader`1/<<ReadAsync>g__ReadAsyncCore|11_0>d")]
[CompilerGeneratedAttribute]
private ValueTask`1<T> <ReadAsync>g__ReadAsyncCore|11_0(CancellationToken ct);
}
internal static class System.Threading.Channels.ChannelUtilities : object {
    internal static Exception s_doneWritingSentinel;
    internal static Task`1<bool> s_trueTask;
    internal static Task`1<bool> s_falseTask;
    internal static Task s_neverCompletingTask;
    private static ChannelUtilities();
    internal static void Complete(TaskCompletionSource tcs, Exception error);
    internal static ValueTask`1<T> GetInvalidCompletionValueTask(Exception error);
    internal static void QueueWaiter(AsyncOperation`1& tail, AsyncOperation`1<bool> waiter);
    internal static void WakeUpWaiters(AsyncOperation`1& listTail, bool result, Exception error);
    internal static void FailOperations(Deque`1<T> operations, Exception error);
    internal static Exception CreateInvalidCompletionException(Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class System.Threading.Channels.ChannelWriter`1 : object {
    public virtual bool TryComplete(Exception error);
    [NullableContextAttribute("1")]
public abstract virtual bool TryWrite(T item);
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<bool> WaitToWriteAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual ValueTask WriteAsync(T item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Threading.Channels.ChannelWriter`1/<WriteAsyncCore>d__4")]
private ValueTask WriteAsyncCore(T innerItem, CancellationToken ct);
    public void Complete(Exception error);
}
internal class System.Threading.Channels.DebugEnumeratorDebugView`1 : object {
    [CompilerGeneratedAttribute]
private T[] <Items>k__BackingField;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public DebugEnumeratorDebugView`1(IDebugEnumerable`1<T> enumerable);
    [CompilerGeneratedAttribute]
public T[] get_Items();
}
internal interface System.Threading.Channels.IDebugEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
[DebuggerDisplayAttribute("Items = {ItemsCountForDebugger}, Closed = {ChannelIsClosedForDebugger}")]
[DebuggerTypeProxyAttribute("System.Threading.Channels.DebugEnumeratorDebugView`1")]
internal class System.Threading.Channels.SingleConsumerUnboundedChannel`1 : Channel`1<T> {
    private TaskCompletionSource _completion;
    private SingleProducerSingleConsumerQueue`1<T> _items;
    private bool _runContinuationsAsynchronously;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _doneWriting;
    private AsyncOperation`1<T> _blockedReader;
    private AsyncOperation`1<bool> _waitingReader;
    private object SyncObj { get; }
    private int ItemsCountForDebugger { get; }
    private bool ChannelIsClosedForDebugger { get; }
    internal SingleConsumerUnboundedChannel`1(bool runContinuationsAsynchronously);
    private object get_SyncObj();
    private int get_ItemsCountForDebugger();
    private bool get_ChannelIsClosedForDebugger();
    private sealed virtual override IEnumerator`1<T> System.Threading.Channels.IDebugEnumerable<T>.GetEnumerator();
}
internal class System.Threading.Channels.TaskCompletionSource : TaskCompletionSource`1<VoidResult> {
    public TaskCompletionSource(TaskCreationOptions creationOptions);
    public bool TrySetResult();
}
[DebuggerDisplayAttribute("Items = {ItemsCountForDebugger}, Closed = {ChannelIsClosedForDebugger}")]
[DebuggerTypeProxyAttribute("System.Threading.Channels.DebugEnumeratorDebugView`1")]
internal class System.Threading.Channels.UnboundedChannel`1 : Channel`1<T> {
    private TaskCompletionSource _completion;
    private ConcurrentQueue`1<T> _items;
    private Deque`1<AsyncOperation`1<T>> _blockedReaders;
    private bool _runContinuationsAsynchronously;
    private AsyncOperation`1<bool> _waitingReadersTail;
    private Exception _doneWriting;
    private object SyncObj { get; }
    private int ItemsCountForDebugger { get; }
    private bool ChannelIsClosedForDebugger { get; }
    internal UnboundedChannel`1(bool runContinuationsAsynchronously);
    private object get_SyncObj();
    [ConditionalAttribute("DEBUG")]
private void AssertInvariants();
    private int get_ItemsCountForDebugger();
    private bool get_ChannelIsClosedForDebugger();
    private sealed virtual override IEnumerator`1<T> System.Threading.Channels.IDebugEnumerable<T>.GetEnumerator();
}
internal class System.Threading.Channels.UnboundedChannelOptions : ChannelOptions {
}
internal class System.Threading.Channels.VoidAsyncOperationWithData`1 : AsyncOperation`1<VoidResult> {
    [CompilerGeneratedAttribute]
private TData <Item>k__BackingField;
    public TData Item { get; public set; }
    public VoidAsyncOperationWithData`1(bool runContinuationsAsynchronously, CancellationToken cancellationToken, bool pooled);
    [CompilerGeneratedAttribute]
public TData get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(TData value);
}
internal interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual void GetResult(short token);
}
internal interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual TResult GetResult(short token);
}
[FlagsAttribute]
internal enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
}
internal enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Canceled;
}
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
internal class System.Threading.Tasks.ValueTask : ValueType {
    private static Task s_canceledTask;
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    internal object _obj;
    internal short _token;
    internal bool _continueOnCapturedContext;
    internal static Task CompletedTask { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public ValueTask(Task task);
    public ValueTask(IValueTaskSource source, short token);
    private ValueTask(object obj, short token, bool continueOnCapturedContext);
    private static ValueTask();
    [CompilerGeneratedAttribute]
internal static Task get_CompletedTask();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public Task AsTask();
    public ValueTask Preserve();
    private Task GetTaskForValueTaskSource(IValueTaskSource t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    [StackTraceHiddenAttribute]
internal void ThrowIfCompletedUnsuccessfully();
    public ValueTaskAwaiter GetAwaiter();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
}
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
internal class System.Threading.Tasks.ValueTask`1 : ValueType {
    private static Task`1<TResult> s_canceledTask;
    internal object _obj;
    internal TResult _result;
    internal short _token;
    internal bool _continueOnCapturedContext;
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public TResult Result { get; }
    public ValueTask`1(TResult result);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    private ValueTask`1(object obj, TResult result, short token, bool continueOnCapturedContext);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public Task`1<TResult> AsTask();
    public ValueTask`1<TResult> Preserve();
    private Task`1<TResult> GetTaskForValueTaskSource(IValueTaskSource`1<TResult> t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    public TResult get_Result();
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public virtual string ToString();
}
internal static class System.ThrowHelper : object {
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument);
    private static string GetArgumentName(ExceptionArgument argument);
}
[ExtensionAttribute]
internal static class System.TupleExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    private static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private static Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
}
internal class System.ValueTuple : ValueType {
    private int System.ITupleInternal.Size { get; }
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
internal class System.ValueTuple`1 : ValueType {
    private static EqualityComparer`1<T1> s_t1Comparer;
    public T1 Item1;
    private int System.ITupleInternal.Size { get; }
    public ValueTuple`1(T1 item1);
    private static ValueTuple`1();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
}
public class System.ValueTuple`2 : ValueType {
    private static EqualityComparer`1<T1> s_t1Comparer;
    private static EqualityComparer`1<T2> s_t2Comparer;
    public T1 Item1;
    public T2 Item2;
    private int System.ITupleInternal.Size { get; }
    public ValueTuple`2(T1 item1, T2 item2);
    private static ValueTuple`2();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
}
internal class System.ValueTuple`3 : ValueType {
    private static EqualityComparer`1<T1> s_t1Comparer;
    private static EqualityComparer`1<T2> s_t2Comparer;
    private static EqualityComparer`1<T3> s_t3Comparer;
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    private int System.ITupleInternal.Size { get; }
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    private static ValueTuple`3();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
}
internal class System.ValueTuple`4 : ValueType {
    private static EqualityComparer`1<T1> s_t1Comparer;
    private static EqualityComparer`1<T2> s_t2Comparer;
    private static EqualityComparer`1<T3> s_t3Comparer;
    private static EqualityComparer`1<T4> s_t4Comparer;
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    private int System.ITupleInternal.Size { get; }
    public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    private static ValueTuple`4();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
}
internal class System.ValueTuple`5 : ValueType {
    private static EqualityComparer`1<T1> s_t1Comparer;
    private static EqualityComparer`1<T2> s_t2Comparer;
    private static EqualityComparer`1<T3> s_t3Comparer;
    private static EqualityComparer`1<T4> s_t4Comparer;
    private static EqualityComparer`1<T5> s_t5Comparer;
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private int System.ITupleInternal.Size { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    private static ValueTuple`5();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
}
internal class System.ValueTuple`6 : ValueType {
    private static EqualityComparer`1<T1> s_t1Comparer;
    private static EqualityComparer`1<T2> s_t2Comparer;
    private static EqualityComparer`1<T3> s_t3Comparer;
    private static EqualityComparer`1<T4> s_t4Comparer;
    private static EqualityComparer`1<T5> s_t5Comparer;
    private static EqualityComparer`1<T6> s_t6Comparer;
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private int System.ITupleInternal.Size { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    private static ValueTuple`6();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
}
internal class System.ValueTuple`7 : ValueType {
    private static EqualityComparer`1<T1> s_t1Comparer;
    private static EqualityComparer`1<T2> s_t2Comparer;
    private static EqualityComparer`1<T3> s_t3Comparer;
    private static EqualityComparer`1<T4> s_t4Comparer;
    private static EqualityComparer`1<T5> s_t5Comparer;
    private static EqualityComparer`1<T6> s_t6Comparer;
    private static EqualityComparer`1<T7> s_t7Comparer;
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private int System.ITupleInternal.Size { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    private static ValueTuple`7();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
}
internal class System.ValueTuple`8 : ValueType {
    private static EqualityComparer`1<T1> s_t1Comparer;
    private static EqualityComparer`1<T2> s_t2Comparer;
    private static EqualityComparer`1<T3> s_t3Comparer;
    private static EqualityComparer`1<T4> s_t4Comparer;
    private static EqualityComparer`1<T5> s_t5Comparer;
    private static EqualityComparer`1<T6> s_t6Comparer;
    private static EqualityComparer`1<T7> s_t7Comparer;
    private static EqualityComparer`1<TRest> s_tRestComparer;
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    public TRest Rest;
    private int System.ITupleInternal.Size { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private static ValueTuple`8();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToStringEnd();
    private sealed virtual override int System.ITupleInternal.get_Size();
}
[IsReadOnlyAttribute]
internal class System.VoidResult : ValueType {
}
