public class NGraphics.ArcTo : PathOp {
    public Size Radius;
    public bool LargeArc;
    public bool SweepClockwise;
    public Point Point;
    public ArcTo(Size radius, bool largeArc, bool sweepClockwise, Point point);
    protected virtual void AcceptVisitor(IPathOpVisitor visitor);
    public virtual PathOp Clone();
    public virtual Point GetContinueCurveControlPoint();
    public virtual Point GetEndPoint(Point startPoint);
    public void GetCircles(Point prevPoint, Point& circle1Center, Point& circle2Center);
    public virtual EdgeSamples[] GetEdgeSamples(Point startPoint, Point prevPoint, double tolerance, int minSamples, int maxSamples);
    public virtual void TransformGeometry(Point prevPoint, Transform transform);
    public virtual double DistanceTo(Point startPoint, Point prevPoint, Point point);
    public virtual string ToString();
}
public class NGraphics.BaseElementVisitor : object {
    public virtual void VisitElement(Element element);
    public virtual void EndVisitElement(Element element);
    public virtual void Visit(Rectangle rectangle);
    public virtual void Visit(Ellipse ellipse);
    public virtual void Visit(Group group);
    public virtual void Visit(Path path);
    public virtual void Visit(Text text);
    public virtual void Visit(ForeignObject foreignObject);
    public virtual void EndVisit(Rectangle rectangle);
    public virtual void EndVisit(Ellipse ellipse);
    public virtual void EndVisit(Group group);
    public virtual void EndVisit(Path path);
    public virtual void EndVisit(Text text);
    public virtual void EndVisit(ForeignObject foreignObject);
}
public class NGraphics.BoundingBoxBuilder : object {
    private Rect bb;
    private int nbb;
    public Rect BoundingBox { get; }
    public int Count { get; }
    public Rect get_BoundingBox();
    public int get_Count();
    public void Add(Point point);
    public void Add(IEnumerable`1<Point> points);
}
public abstract class NGraphics.Brush : object {
}
public static class NGraphics.Brushes : object {
    public static SolidBrush Black;
    public static SolidBrush DarkGray;
    public static SolidBrush Gray;
    public static SolidBrush LightGray;
    public static SolidBrush White;
    public static SolidBrush Red;
    public static SolidBrush Yellow;
    public static SolidBrush Green;
    public static SolidBrush Blue;
    private static Brushes();
}
[ExtensionAttribute]
public static class NGraphics.CanvasEx : object {
    [ExtensionAttribute]
public static void Translate(ICanvas canvas, double dx, double dy);
    [ExtensionAttribute]
public static void Translate(ICanvas canvas, Size translation);
    [ExtensionAttribute]
public static void Translate(ICanvas canvas, Point translation);
    [ExtensionAttribute]
public static void Rotate(ICanvas canvas, double angle);
    [ExtensionAttribute]
public static void Rotate(ICanvas canvas, double angle, Point point);
    [ExtensionAttribute]
public static void Rotate(ICanvas canvas, double angle, double x, double y);
    [ExtensionAttribute]
public static void Scale(ICanvas canvas, double sx, double sy);
    [ExtensionAttribute]
public static void Scale(ICanvas canvas, double scale);
    [ExtensionAttribute]
public static void Scale(ICanvas canvas, Size scale);
    [ExtensionAttribute]
public static void Scale(ICanvas canvas, Size scale, Point point);
    [ExtensionAttribute]
public static void Scale(ICanvas canvas, double scale, Point point);
    [ExtensionAttribute]
public static void Scale(ICanvas canvas, double sx, double sy, double x, double y);
    [ExtensionAttribute]
public static void Scale(ICanvas canvas, double scale, double x, double y);
    [ExtensionAttribute]
public static void DrawRectangle(ICanvas canvas, Rect frame, Color color, double width);
    [ExtensionAttribute]
public static void DrawRectangle(ICanvas canvas, Rect frame, Size corner, Color color, double width);
    [ExtensionAttribute]
public static void DrawRectangle(ICanvas canvas, Rect frame, Pen pen, Brush brush);
    [ExtensionAttribute]
public static void DrawRectangle(ICanvas canvas, double x, double y, double width, double height, Pen pen, Brush brush);
    [ExtensionAttribute]
public static void DrawRectangle(ICanvas canvas, double x, double y, double width, double height, double rx, double ry, Pen pen, Brush brush);
    [ExtensionAttribute]
public static void DrawRectangle(ICanvas canvas, double x, double y, double width, double height, double rx, double ry, Color color, double penWidth);
    [ExtensionAttribute]
public static void DrawRectangle(ICanvas canvas, Point position, Size size, Pen pen, Brush brush);
    [ExtensionAttribute]
public static void FillRectangle(ICanvas canvas, Rect frame, Color color);
    [ExtensionAttribute]
public static void FillRectangle(ICanvas canvas, Rect frame, Size corner, Color color);
    [ExtensionAttribute]
public static void FillRectangle(ICanvas canvas, double x, double y, double width, double height, Color color);
    [ExtensionAttribute]
public static void FillRectangle(ICanvas canvas, double x, double y, double width, double height, double rx, double ry, Color color);
    [ExtensionAttribute]
public static void FillRectangle(ICanvas canvas, double x, double y, double width, double height, Brush brush);
    [ExtensionAttribute]
public static void FillRectangle(ICanvas canvas, Rect frame, Brush brush);
    [ExtensionAttribute]
public static void FillRectangle(ICanvas canvas, Rect frame, Size corner, Brush brush);
    [ExtensionAttribute]
public static void DrawEllipse(ICanvas canvas, Rect frame, Color color, double width);
    [ExtensionAttribute]
public static void DrawEllipse(ICanvas canvas, double x, double y, double width, double height, Pen pen, Brush brush);
    [ExtensionAttribute]
public static void DrawEllipse(ICanvas canvas, Point position, Size size, Pen pen, Brush brush);
    [ExtensionAttribute]
public static void FillEllipse(ICanvas canvas, Point position, Size size, Brush brush);
    [ExtensionAttribute]
public static void FillEllipse(ICanvas canvas, Point position, Size size, Color color);
    [ExtensionAttribute]
public static void FillEllipse(ICanvas canvas, double x, double y, double width, double height, Color color);
    [ExtensionAttribute]
public static void FillEllipse(ICanvas canvas, double x, double y, double width, double height, Brush brush);
    [ExtensionAttribute]
public static void FillEllipse(ICanvas canvas, Rect frame, Color color);
    [ExtensionAttribute]
public static void FillEllipse(ICanvas canvas, Rect frame, Brush brush);
    [ExtensionAttribute]
public static void StrokeEllipse(ICanvas canvas, Rect frame, Color color, double width);
    [ExtensionAttribute]
public static void StrokeEllipse(ICanvas canvas, Point position, Size size, Color color, double width);
    [ExtensionAttribute]
public static void DrawPath(ICanvas canvas, Action`1<Path> draw, Pen pen, Brush brush);
    [ExtensionAttribute]
public static void FillPath(ICanvas canvas, IEnumerable`1<PathOp> ops, Brush brush);
    [ExtensionAttribute]
public static void FillPath(ICanvas canvas, IEnumerable`1<PathOp> ops, Color color);
    [ExtensionAttribute]
public static void FillPath(ICanvas canvas, Action`1<Path> draw, Brush brush);
    [ExtensionAttribute]
public static void FillPath(ICanvas canvas, Action`1<Path> draw, Color color);
    [ExtensionAttribute]
public static void DrawLine(ICanvas canvas, Point start, Point end, Pen pen);
    [ExtensionAttribute]
public static void DrawLine(ICanvas canvas, Point start, Point end, Color color, double width);
    [ExtensionAttribute]
public static void DrawLine(ICanvas canvas, double x1, double y1, double x2, double y2, Color color, double width);
    [ExtensionAttribute]
public static void DrawImage(ICanvas canvas, IImage image);
    [ExtensionAttribute]
public static void DrawImage(ICanvas canvas, IImage image, double x, double y, double width, double height, double alpha);
    [ExtensionAttribute]
public static void DrawText(ICanvas canvas, string text, Point point, Font font, Brush brush);
    [ExtensionAttribute]
public static void DrawText(ICanvas canvas, string text, Point point, Font font, Color color);
    [ExtensionAttribute]
public static void DrawText(ICanvas canvas, string text, Rect frame, Font font, TextAlignment alignment, Color color);
}
public class NGraphics.ClosePath : PathOp {
    protected virtual void AcceptVisitor(IPathOpVisitor visitor);
    public virtual PathOp Clone();
    public virtual Point GetContinueCurveControlPoint();
    public virtual Point GetEndPoint(Point startPoint);
    public virtual EdgeSamples[] GetEdgeSamples(Point startPoint, Point prevPoint, double tolerance, int minSamples, int maxSamples);
    public virtual void TransformGeometry(Point prevPoint, Transform transform);
    public virtual double DistanceTo(Point startPoint, Point prevPoint, Point point);
    public virtual string ToString();
}
public class NGraphics.CodeWriter : object {
    private IFormatProvider icult;
    private TextWriter w;
    private string indentText;
    private int indentLevel;
    private bool needsIndent;
    public Encoding Encoding { get; }
    public CodeWriter(TextWriter writer, string indentText);
    public Encoding get_Encoding();
    public void WriteLine(string format, Object[] args);
    public void WriteLine(string text);
    public void WriteLine();
    public void Write(string format, Object[] args);
    public void Write(string text);
    public void Write();
    public void Indent();
    public void Outdent();
    private void WriteIndent();
}
public class NGraphics.Color : ValueType {
    public byte B;
    public byte G;
    public byte R;
    public byte A;
    [IgnoreDataMemberAttribute]
public double Red { get; public set; }
    [IgnoreDataMemberAttribute]
public double Green { get; public set; }
    [IgnoreDataMemberAttribute]
public double Blue { get; public set; }
    [IgnoreDataMemberAttribute]
public double Alpha { get; public set; }
    [IgnoreDataMemberAttribute]
public double Hue { get; public set; }
    [IgnoreDataMemberAttribute]
public double Saturation { get; public set; }
    [IgnoreDataMemberAttribute]
public double Brightness { get; public set; }
    [IgnoreDataMemberAttribute]
public double Value { get; public set; }
    [IgnoreDataMemberAttribute]
public int Argb { get; }
    [IgnoreDataMemberAttribute]
public int Rgba { get; }
    [IgnoreDataMemberAttribute]
public int Abgr { get; }
    public string HtmlString { get; }
    private Color(byte r, byte g, byte b, byte a);
    public Color(double red, double green, double blue, double alpha);
    public Color(double red, double green, double blue);
    public Color(double white, double alpha);
    public Color(string colorString);
    public double get_Red();
    public void set_Red(double value);
    public double get_Green();
    public void set_Green(double value);
    public double get_Blue();
    public void set_Blue(double value);
    public double get_Alpha();
    public void set_Alpha(double value);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Brightness();
    public void set_Brightness(double value);
    public double get_Value();
    public void set_Value(double value);
    private static byte Round(double c);
    public int get_Argb();
    public int get_Rgba();
    public int get_Abgr();
    public static Color op_Implicit(string colorString);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Color a, Color b);
    public static bool op_Inequality(Color a, Color b);
    public Color BlendWith(Color other, double otherWeight);
    public Color WithAlpha(double alpha);
    public Color WithHue(double hue);
    public Color WithSaturation(double saturation);
    public Color WithBrightness(double brightness);
    public Color WithValue(double value);
    public static Color FromRGB(double red, double green, double blue, double alpha);
    public static Color FromWhite(double white, double alpha);
    public static Color FromRGB(int rgb);
    public static Color FromHSL(double hue, double saturation, double lightness, double alpha);
    public static Color FromHSB(double hue, double saturation, double brightness, double alpha);
    public Double[] ToHSB();
    public Double[] ToHSV();
    public static Color FromHSV(double hue, double saturation, double value, double alpha);
    public string get_HtmlString();
    public virtual string ToString();
}
public static class NGraphics.Colors : object {
    public static Color Clear;
    public static Color Black;
    public static Color DarkGray;
    public static Color Gray;
    public static Color LightGray;
    public static Color White;
    public static Color Red;
    public static Color Orange;
    public static Color Yellow;
    public static Color Green;
    public static Color Blue;
    private static Dictionary`2<string, Color> names;
    private static Colors();
    public static bool TryParse(string colorString, Color& color);
}
public class NGraphics.CurveTo : PathOp {
    public Point Control1;
    public Point Control2;
    public Point Point;
    public CurveTo(Point control1, Point control2, Point point);
    protected virtual void AcceptVisitor(IPathOpVisitor visitor);
    public virtual PathOp Clone();
    public virtual Point GetContinueCurveControlPoint();
    public virtual Point GetEndPoint(Point startPoint);
    public virtual EdgeSamples[] GetEdgeSamples(Point startPoint, Point prevPoint, double tolerance, int minSamples, int maxSamples);
    public virtual void TransformGeometry(Point prevPoint, Transform transform);
    public Point GetPoint(Point prevPoint, double t);
    public virtual double DistanceTo(Point startPoint, Point prevPoint, Point point);
    public virtual string ToString();
}
public class NGraphics.DrawImageCache`1 : object {
    private IPlatform platform;
    private double scale;
    private bool transparency;
    private int maxNumEntries;
    private Dictionary`2<Tuple`3<Size, double, TKey>, Entry<TKey>> cache;
    public DrawImageCache`1(int maxNumEntries, IPlatform platform, double scale, bool transparency);
    public void Clear();
    public IImage GetImage(TKey key, Size size, Action`1<ICanvas> draw);
}
public class NGraphics.Drawing : object {
    private Size size;
    private DrawingFunc func;
    private IPlatform textPlatform;
    private Graphic graphic;
    public Graphic Graphic { get; }
    public Drawing(Size size, DrawingFunc func, IPlatform textPlatform);
    public Graphic get_Graphic();
    public void Invalidate();
    private void DrawGraphic();
}
public class NGraphics.DrawingFunc : MulticastDelegate {
    public DrawingFunc(object object, IntPtr method);
    public virtual void Invoke(ICanvas canvas);
    public virtual IAsyncResult BeginInvoke(ICanvas canvas, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NGraphics.EdgeSamples : ValueType {
    public Point[] Points;
    public double DistanceTo(Point p);
}
public abstract class NGraphics.Element : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Transform <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private Pen <Pen>k__BackingField;
    [CompilerGeneratedAttribute]
private Brush <Brush>k__BackingField;
    public string Id { get; public set; }
    public Transform Transform { get; public set; }
    public Pen Pen { get; public set; }
    public Brush Brush { get; public set; }
    [IgnoreDataMemberAttribute]
public Nullable`1<Rect> BoundingBox { get; }
    [IgnoreDataMemberAttribute]
public Rect SampleableBox { get; }
    protected Element(Pen pen, Brush brush);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Transform get_Transform();
    [CompilerGeneratedAttribute]
public void set_Transform(Transform value);
    [CompilerGeneratedAttribute]
public virtual Pen get_Pen();
    [CompilerGeneratedAttribute]
public virtual void set_Pen(Pen value);
    [CompilerGeneratedAttribute]
public virtual Brush get_Brush();
    [CompilerGeneratedAttribute]
public virtual void set_Brush(Brush value);
    protected abstract virtual void DrawElement(ICanvas canvas);
    protected virtual void SetCloneData(Element clone);
    protected abstract virtual Element CreateUninitializedClone();
    public Element Clone();
    public abstract virtual Element TransformGeometry(Transform transform);
    public abstract virtual bool Contains(Point localPoint);
    public abstract virtual Nullable`1<Rect> get_BoundingBox();
    public sealed virtual void Draw(ICanvas canvas);
    public static Point[] SampleLine(Point begin, Point end, bool includeEnd, double tolerance, int minSamples, int maxSamples);
    public abstract virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
    public abstract virtual Rect get_SampleableBox();
    public bool HitTest(Point worldPoint);
    protected abstract virtual void AcceptVisitor(IElementVisitor visitor);
    public void Accept(IElementVisitor visitor);
}
public class NGraphics.Ellipse : Element {
    private Rect frame;
    public Rect Frame { get; }
    public Nullable`1<Rect> BoundingBox { get; }
    public Rect SampleableBox { get; }
    public Ellipse(Rect frame, Pen pen, Brush brush);
    public Ellipse(Point position, Size size, Pen pen, Brush brush);
    public Ellipse(Point position, double diameter);
    public Ellipse(double diameter);
    public Rect get_Frame();
    protected virtual void AcceptVisitor(IElementVisitor visitor);
    protected virtual void DrawElement(ICanvas canvas);
    public virtual string ToString();
    protected virtual Element CreateUninitializedClone();
    public virtual Element TransformGeometry(Transform transform);
    public virtual bool Contains(Point localPoint);
    public virtual Nullable`1<Rect> get_BoundingBox();
    public virtual Rect get_SampleableBox();
    public virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
}
public class NGraphics.FilterCanvas : object {
    public ICanvas NextCanvas;
    public FilterCanvas(ICanvas nextCanvas);
    public virtual Pen GetPen(Pen pen);
    public virtual Brush GetBrush(Brush brush);
    public virtual void SaveState();
    public virtual void Transform(Transform transform);
    public virtual void RestoreState();
    public virtual TextMetrics MeasureText(string text, Font font);
    public virtual void DrawText(string text, Rect frame, Font font, TextAlignment alignment, Pen pen, Brush brush);
    public virtual void DrawPath(IEnumerable`1<PathOp> ops, Pen pen, Brush brush);
    public virtual void DrawRectangle(Rect frame, Size corner, Pen pen, Brush brush);
    public virtual void DrawEllipse(Rect frame, Pen pen, Brush brush);
    public virtual void DrawImage(IImage image, Rect frame, double alpha);
}
public class NGraphics.Font : object {
    private string name;
    [CompilerGeneratedAttribute]
private double <Size>k__BackingField;
    public string Name { get; public set; }
    public string Family { get; public set; }
    public double Size { get; public set; }
    public Font(string name, double size);
    public Font Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Name();
    public void set_Name(string value);
    public string get_Family();
    public void set_Family(string value);
    [CompilerGeneratedAttribute]
public double get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(double value);
    public Font WithFamily(string family);
    public Font WithStyle(string style);
    public Font WithWeight(string weight);
    public Font WithSize(double newSize);
    public virtual string ToString();
}
public class NGraphics.ForeignObject : Element {
    protected Point pos;
    protected Size size;
    public Nullable`1<Rect> BoundingBox { get; }
    public Rect SampleableBox { get; }
    public ForeignObject(Point pos, Size size);
    protected virtual void AcceptVisitor(IElementVisitor visitor);
    protected virtual Element CreateUninitializedClone();
    public virtual Element TransformGeometry(Transform transform);
    public virtual Nullable`1<Rect> get_BoundingBox();
    public virtual bool Contains(Point localPoint);
    protected virtual void DrawElement(ICanvas canvas);
    public virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
    public virtual Rect get_SampleableBox();
}
public abstract class NGraphics.GradientBrush : Brush {
    public List`1<GradientStop> Stops;
    public void AddStop(double offset, Color color);
    public void AddStops(IEnumerable`1<GradientStop> stops);
}
public class NGraphics.GradientStop : object {
    public double Offset;
    public Color Color;
    public GradientStop(double offset, Color color);
}
public class NGraphics.Graphic : object {
    public List`1<Element> Children;
    public Size Size;
    public Rect ViewBox;
    public string Title;
    public string Description;
    public Transform Transform { get; }
    [IgnoreDataMemberAttribute]
public Rect SampleableBox { get; }
    public Graphic(Size size, Rect viewBox);
    public Graphic(Size size);
    public Graphic Clone();
    public Transform get_Transform();
    public Graphic TransformGeometry(Transform transform);
    public sealed virtual void Draw(ICanvas canvas);
    public static Graphic LoadSvg(TextReader reader, double pixelsPerInch, Brush defaultBrush, Font defaultFont);
    public static Graphic ParseSvg(string svg, double pixelsPerInch, Brush defaultBrush, Font defaultFont);
    public void WriteSvg(TextWriter writer);
    public string GetSvg();
    public virtual string ToString();
    public Element[] HitTest(Point worldPoint);
    public sealed virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
    public sealed virtual Rect get_SampleableBox();
}
public class NGraphics.GraphicCanvas : object {
    private Stack`1<Transform> states;
    private IPlatform textPlatform;
    [CompilerGeneratedAttribute]
private Graphic <Graphic>k__BackingField;
    public Graphic Graphic { get; private set; }
    private Transform CurrentTransform { get; }
    public GraphicCanvas(Size size, IPlatform textPlatform);
    [CompilerGeneratedAttribute]
public Graphic get_Graphic();
    [CompilerGeneratedAttribute]
private void set_Graphic(Graphic value);
    private Transform get_CurrentTransform();
    public sealed virtual void SaveState();
    public sealed virtual void Transform(Transform transform);
    public sealed virtual void RestoreState();
    public sealed virtual TextMetrics MeasureText(string text, Font font);
    public sealed virtual void DrawText(string text, Rect frame, Font font, TextAlignment alignment, Pen pen, Brush brush);
    public sealed virtual void DrawPath(IEnumerable`1<PathOp> commands, Pen pen, Brush brush);
    public sealed virtual void DrawRectangle(Rect frame, Size corner, Pen pen, Brush brush);
    public sealed virtual void DrawEllipse(Rect frame, Pen pen, Brush brush);
    public sealed virtual void DrawImage(IImage image, Rect frame, double alpha);
}
public class NGraphics.Group : Element {
    public List`1<Element> Children;
    private double _opacity;
    private double _resetOpacityMultiplier;
    public double Opacity { get; public set; }
    public Pen Pen { get; public set; }
    public Brush Brush { get; public set; }
    public Nullable`1<Rect> BoundingBox { get; }
    [IgnoreDataMemberAttribute]
public Rect SampleableBox { get; }
    protected virtual void AcceptVisitor(IElementVisitor visitor);
    public double get_Opacity();
    public void set_Opacity(double value);
    public virtual Pen get_Pen();
    public virtual void set_Pen(Pen value);
    public virtual Brush get_Brush();
    public virtual void set_Brush(Brush value);
    protected virtual void DrawElement(ICanvas canvas);
    public virtual string ToString();
    protected virtual Element CreateUninitializedClone();
    protected virtual void SetCloneData(Element clone);
    public virtual Element TransformGeometry(Transform transform);
    public virtual bool Contains(Point localPoint);
    public virtual Nullable`1<Rect> get_BoundingBox();
    public virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
    public virtual Rect get_SampleableBox();
}
public interface NGraphics.ICanvas {
    public abstract virtual void SaveState();
    public abstract virtual void Transform(Transform transform);
    public abstract virtual void RestoreState();
    public abstract virtual TextMetrics MeasureText(string text, Font font);
    public abstract virtual void DrawText(string text, Rect frame, Font font, TextAlignment alignment, Pen pen, Brush brush);
    public abstract virtual void DrawPath(IEnumerable`1<PathOp> ops, Pen pen, Brush brush);
    public abstract virtual void DrawRectangle(Rect frame, Size corner, Pen pen, Brush brush);
    public abstract virtual void DrawEllipse(Rect frame, Pen pen, Brush brush);
    public abstract virtual void DrawImage(IImage image, Rect frame, double alpha);
}
public interface NGraphics.IDrawable {
    public abstract virtual void Draw(ICanvas canvas);
}
public interface NGraphics.IEdgeSampleable {
    public Rect SampleableBox { get; }
    public abstract virtual Rect get_SampleableBox();
    public abstract virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
}
public interface NGraphics.IElementVisitor {
    public abstract virtual void Visit(Rectangle rectangle);
    public abstract virtual void Visit(Ellipse ellipse);
    public abstract virtual void Visit(Group group);
    public abstract virtual void Visit(Path path);
    public abstract virtual void Visit(Text text);
    public abstract virtual void Visit(ForeignObject foreignObject);
    public abstract virtual void EndVisit(Rectangle rectangle);
    public abstract virtual void EndVisit(Ellipse ellipse);
    public abstract virtual void EndVisit(Group group);
    public abstract virtual void EndVisit(Path path);
    public abstract virtual void EndVisit(Text text);
    public abstract virtual void EndVisit(ForeignObject foreignObject);
}
public interface NGraphics.IImage {
    public Size Size { get; }
    public double Scale { get; }
    public abstract virtual Size get_Size();
    public abstract virtual double get_Scale();
    public abstract virtual void SaveAsPng(string path);
    public abstract virtual void SaveAsPng(Stream stream);
}
public interface NGraphics.IImageCanvas {
    public Size Size { get; }
    public double Scale { get; }
    public abstract virtual IImage GetImage();
    public abstract virtual Size get_Size();
    public abstract virtual double get_Scale();
}
public interface NGraphics.IPathOpVisitor {
    public abstract virtual void Visit(MoveTo moveTo);
    public abstract virtual void Visit(LineTo lineTo);
    public abstract virtual void Visit(CurveTo curveTo);
    public abstract virtual void Visit(ArcTo arcTo);
    public abstract virtual void Visit(ClosePath closePath);
}
public interface NGraphics.IPlatform {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual IImageCanvas CreateImageCanvas(Size size, double scale, bool transparency);
    public abstract virtual IImage LoadImage(string path);
    public abstract virtual IImage LoadImage(Stream stream);
    public abstract virtual IImage CreateImage(Color[] colors, int pixelWidth, double scale);
    public abstract virtual TextMetrics MeasureText(string text, Font font);
    public abstract virtual Task`1<Stream> OpenFileStreamForWritingAsync(string path);
}
public class NGraphics.LinearGradientBrush : GradientBrush {
    public Point Start;
    public Point End;
    public bool Absolute;
    public LinearGradientBrush(Point relStart, Point relEnd, GradientStop[] stops);
    public LinearGradientBrush(Point relStart, Point relEnd, Color startColor, Color endColor);
    public LinearGradientBrush(Point relStart, Point relEnd, Color startColor, Color midColor, Color endColor);
    public Point GetAbsoluteStart(Rect frame);
    public Point GetAbsoluteEnd(Rect frame);
}
public class NGraphics.LineTo : PathOp {
    public Point Point;
    public LineTo(Point point);
    public LineTo(double x, double y);
    protected virtual void AcceptVisitor(IPathOpVisitor visitor);
    public virtual PathOp Clone();
    public virtual Point GetContinueCurveControlPoint();
    public virtual Point GetEndPoint(Point startPoint);
    public virtual EdgeSamples[] GetEdgeSamples(Point startPoint, Point prevPoint, double tolerance, int minSamples, int maxSamples);
    public virtual void TransformGeometry(Point prevPoint, Transform transform);
    public virtual double DistanceTo(Point startPoint, Point prevPoint, Point point);
    public virtual string ToString();
}
internal static class NGraphics.Log : object {
    public static void Error(Exception ex);
}
public class NGraphics.MoveTo : PathOp {
    public Point Point;
    public MoveTo(Point point);
    public MoveTo(double x, double y);
    protected virtual void AcceptVisitor(IPathOpVisitor visitor);
    public virtual PathOp Clone();
    public virtual Point GetContinueCurveControlPoint();
    public virtual Point GetEndPoint(Point startPoint);
    public virtual EdgeSamples[] GetEdgeSamples(Point startPoint, Point prevPoint, double tolerance, int minSamples, int maxSamples);
    public virtual void TransformGeometry(Point prevPoint, Transform transform);
    public virtual double DistanceTo(Point startPoint, Point prevPoint, Point point);
    public virtual string ToString();
}
public class NGraphics.NullPlatform : object {
    private static Double[] CharacterProportions;
    private static double AverageCharProportion;
    private static Double[] BoldCharacterProportions;
    private static double BoldAverageCharProportion;
    public string Name { get; }
    private static NullPlatform();
    public sealed virtual string get_Name();
    public sealed virtual TextMetrics MeasureText(string text, Font font);
    public sealed virtual Task`1<Stream> OpenFileStreamForWritingAsync(string path);
    public sealed virtual IImageCanvas CreateImageCanvas(Size size, double scale, bool transparency);
    public sealed virtual IImage CreateImage(Color[] colors, int width, double scale);
    public sealed virtual IImage LoadImage(Stream stream);
    public sealed virtual IImage LoadImage(string path);
    public static TextMetrics GlobalMeasureText(string text, Font font);
    public static Size GetTextSize(string text, Font font, Int32& lines);
}
internal class NGraphics.OpacityVisitor : BaseElementVisitor {
    public double Opacity;
    public virtual void VisitElement(Element element);
}
public class NGraphics.Path : Element {
    public List`1<PathOp> Operations;
    public Nullable`1<Rect> BoundingBox { get; }
    public Rect SampleableBox { get; }
    public Path(IEnumerable`1<PathOp> operations, Pen pen, Brush brush);
    public Path(Pen pen, Brush brush);
    protected virtual void AcceptVisitor(IElementVisitor visitor);
    public void AcceptPathOpVisitor(IPathOpVisitor visitor);
    protected virtual void DrawElement(ICanvas canvas);
    private void Add(PathOp op);
    public void MoveTo(Point point);
    public void MoveTo(double x, double y);
    public void LineTo(Point point);
    public void LineTo(double x, double y);
    public void ArcTo(Size radius, bool largeArc, bool sweepClockwise, Point point);
    public void CurveTo(Point control1, Point control2, Point point);
    public void CurveTo(double c1x, double c1y, double c2x, double c2y, double x, double y);
    public void ContinueCurveTo(Point control2, Point point);
    public void ContinueCurveTo(double c2x, double c2y, double x, double y);
    public void Close();
    public virtual bool Contains(Point localPoint);
    public virtual Nullable`1<Rect> get_BoundingBox();
    public double DistanceToLocal(Point localPoint);
    public double DistanceTo(Point worldPoint);
    public virtual string ToString();
    protected virtual Element CreateUninitializedClone();
    protected virtual void SetCloneData(Element clone);
    public virtual Element TransformGeometry(Transform transform);
    public virtual Rect get_SampleableBox();
    public virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
}
public abstract class NGraphics.PathOp : object {
    public Point EndPoint { get; }
    public abstract virtual Point GetContinueCurveControlPoint();
    public abstract virtual Point GetEndPoint(Point startPoint);
    public Point get_EndPoint();
    public abstract virtual EdgeSamples[] GetEdgeSamples(Point startPoint, Point prevPoint, double tolerance, int minSamples, int maxSamples);
    public abstract virtual PathOp Clone();
    public abstract virtual void TransformGeometry(Point prevPoint, Transform transform);
    public abstract virtual double DistanceTo(Point startPoint, Point prevPoint, Point point);
    protected abstract virtual void AcceptVisitor(IPathOpVisitor visitor);
    public void Accept(IPathOpVisitor visitor);
}
public class NGraphics.Pen : object {
    public Color Color;
    public double Width;
    public IEnumerable`1<float> DashPattern;
    public Pen(Color color, double width);
    public Pen(string colorString, double width);
    public Pen WithWidth(double width);
    public Pen WithColor(Color color);
    public virtual string ToString();
}
public static class NGraphics.Pens : object {
    public static Pen Black;
    public static Pen LightGray;
    public static Pen Gray;
    public static Pen DarkGray;
    public static Pen White;
    public static Pen Red;
    public static Pen Yellow;
    public static Pen Green;
    public static Pen Blue;
    private static Pens();
}
[ExtensionAttribute]
public static class NGraphics.PlatformEx : object {
    [ExtensionAttribute]
public static GraphicCanvas CreateGraphicCanvas(IPlatform platform, Size size);
    [ExtensionAttribute]
public static IImage CreateImage(IPlatform platform, Func`3<int, int, Color> colorFunc, Size size, double scale);
}
public class NGraphics.Point : ValueType {
    public static Point Zero;
    public static Point OneX;
    public static Point OneY;
    public double X;
    public double Y;
    [IgnoreDataMemberAttribute]
public Point Normalized { get; }
    [IgnoreDataMemberAttribute]
public double Distance { get; }
    [IgnoreDataMemberAttribute]
public double DistanceSquared { get; }
    public Point(double x, double y);
    private static Point();
    public Point WithX(double x);
    public Point WithY(double y);
    public Point ReflectedAround(Point point);
    public Point get_Normalized();
    public double DistanceTo(Point p);
    public double get_Distance();
    public double get_DistanceSquared();
    public double DistanceToLineSegment(Point lineStart, Point lineEnd);
    public double Dot(Point b);
    public Point MoveInto(Rect rect);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Point a, Point b);
    public static bool op_Inequality(Point a, Point b);
    public static Point op_Multiply(Point a, Size v);
    public static Point op_Multiply(Size v, Point a);
    public static Point op_Division(Point a, Size v);
    public static Point op_Multiply(Point a, double v);
    public static Point op_Division(Point a, double v);
    public static Point op_Multiply(double v, Point a);
    public static Point op_UnaryNegation(Point a);
    public static Point op_Subtraction(Point a, Point v);
    public static Point op_Addition(Point a, Point v);
    public static Point op_Subtraction(Point a, Size v);
    public static Point op_Addition(Point a, Size v);
    public static Point op_Subtraction(Point a, double v);
    public static Point op_Addition(Point a, double v);
    public virtual string ToString();
}
public class NGraphics.RadialGradientBrush : GradientBrush {
    public Point Center;
    public Point Focus;
    public Size Radius;
    public bool Absolute;
    public RadialGradientBrush(Point relCenter, Size relRadius, GradientStop[] stops);
    public RadialGradientBrush(Point relCenter, Size relRadius, Color startColor, Color endColor);
    public RadialGradientBrush(Color startColor, Color endColor);
    public RadialGradientBrush(Point relCenter, Size relRadius, Color startColor, Color midColor, Color endColor);
    public RadialGradientBrush(Color startColor, Color midColor, Color endColor);
    public Point GetAbsoluteCenter(Rect frame);
    public Size GetAbsoluteRadius(Rect frame);
    public Point GetAbsoluteFocus(Rect frame);
}
public class NGraphics.Rect : ValueType {
    public double X;
    public double Y;
    public double Width;
    public double Height;
    [IgnoreDataMemberAttribute]
public double Left { get; }
    [IgnoreDataMemberAttribute]
public double Top { get; }
    [IgnoreDataMemberAttribute]
public double Right { get; }
    [IgnoreDataMemberAttribute]
public double Bottom { get; }
    [IgnoreDataMemberAttribute]
public Point Position { get; }
    [IgnoreDataMemberAttribute]
public Size Size { get; }
    [IgnoreDataMemberAttribute]
public Point TopLeft { get; }
    [IgnoreDataMemberAttribute]
public Point BottomLeft { get; }
    [IgnoreDataMemberAttribute]
public Point Center { get; }
    [IgnoreDataMemberAttribute]
public Point TopRight { get; }
    [IgnoreDataMemberAttribute]
public Point BottomRight { get; }
    public Rect(double x, double y, double width, double height);
    public Rect(Point position, Size size);
    public Rect(Size size);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public Point get_Position();
    public Size get_Size();
    public Point get_TopLeft();
    public Point get_BottomLeft();
    public Point get_Center();
    public Point get_TopRight();
    public Point get_BottomRight();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Rect a, Rect b);
    public static bool op_Inequality(Rect a, Rect b);
    public static Rect op_Addition(Rect a, Point offset);
    public static Rect op_Subtraction(Rect a, Point offset);
    public static Rect op_Addition(Rect a, Size offset);
    public static Rect op_Subtraction(Rect a, Size offset);
    public static Rect op_Multiply(Rect a, Size s);
    public static Rect op_Multiply(Size s, Rect a);
    public Rect GetInflated(double dx, double dy);
    public Rect GetInflated(double d);
    public Rect GetInflated(Size padding);
    public void Inflate(Size padding);
    public void Inflate(double dx, double dy);
    public Rect Union(Rect p);
    public Rect Union(Point p);
    public static Rect Union(Rect p, Rect o);
    public static Rect Union(IEnumerable`1<Rect> rects);
    public Rect MoveInto(Rect frame);
    public bool Contains(Point point);
    public bool Intersects(Rect other);
    public double DistanceTo(Point point);
    public virtual string ToString();
}
public class NGraphics.Rectangle : Element {
    private Rect frame;
    private Size corner;
    public Rect Frame { get; }
    public Size Corner { get; }
    public Nullable`1<Rect> BoundingBox { get; }
    [IgnoreDataMemberAttribute]
public Rect SampleableBox { get; }
    public Rectangle(Rect frame, Size corner, Pen pen, Brush brush);
    public Rectangle(Rect frame, Pen pen, Brush brush);
    public Rectangle(Point position, Size size, Pen pen, Brush brush);
    public Rectangle(Point position, double size);
    public Rectangle(double size);
    public Rect get_Frame();
    public Size get_Corner();
    protected virtual void AcceptVisitor(IElementVisitor visitor);
    protected virtual void DrawElement(ICanvas canvas);
    public virtual string ToString();
    protected virtual Element CreateUninitializedClone();
    public virtual Element TransformGeometry(Transform transform);
    public virtual bool Contains(Point localPoint);
    public virtual Nullable`1<Rect> get_BoundingBox();
    public virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
    public virtual Rect get_SampleableBox();
}
[ExtensionAttribute]
public static class NGraphics.Sampling : object {
    [ExtensionAttribute]
public static EdgeSamples[] SampleEdges(IEdgeSampleable s);
}
public class NGraphics.Size : ValueType {
    public static Size Zero;
    public static Size One;
    public static Size MinValue;
    public static Size MaxValue;
    public double Width;
    public double Height;
    [IgnoreDataMemberAttribute]
public double Max { get; }
    [IgnoreDataMemberAttribute]
public double Min { get; }
    [IgnoreDataMemberAttribute]
public double Diagonal { get; }
    [IgnoreDataMemberAttribute]
public Point Center { get; }
    public Size(double width, double height);
    public Size(double size);
    private static Size();
    public double get_Max();
    public double get_Min();
    public double get_Diagonal();
    public Point get_Center();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Size a, Size b);
    public static bool op_Inequality(Size a, Size b);
    public static Size op_UnaryNegation(Size a);
    public static Size op_Addition(Size a, Size b);
    public static Size op_Subtraction(Size a, Size b);
    public static Size op_Addition(Size a, Point b);
    public static Size op_Subtraction(Size a, Point b);
    public static Size op_Multiply(Size a, Size b);
    public static Size op_Multiply(Size a, double v);
    public static Size op_Multiply(double v, Size a);
    public static Size op_Division(Size a, Size b);
    public static Size op_Division(Size a, double v);
    public static Size op_Division(double v, Size a);
    public virtual string ToString();
}
public class NGraphics.SolidBrush : Brush {
    public Color Color;
    public SolidBrush(Color color);
}
public class NGraphics.SvgReader : object {
    private IFormatProvider icult;
    [CompilerGeneratedAttribute]
private double <PixelsPerInch>k__BackingField;
    [CompilerGeneratedAttribute]
private Graphic <Graphic>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Exception> <Errors>k__BackingField;
    private Dictionary`2<string, XElement> defs;
    private static XmlReaderSettings readerSettings;
    public static double DefaultPixelsPerInch;
    private Regex keyValueRe;
    private static Regex fillUrlRe;
    private Regex rgbRe;
    private Regex unitRe;
    private Regex percRe;
    private static Char[] WS;
    public double PixelsPerInch { get; private set; }
    public Graphic Graphic { get; private set; }
    public List`1<Exception> Errors { get; }
    public SvgReader(TextReader textReader, double pixelsPerInch, Brush defaultBrush, Font defaultFont);
    public SvgReader(string svgString, double pixelsPerInch, Brush defaultBrush, Font defaultFont);
    public SvgReader(Stream stream, double pixelsPerInch, Brush defaultBrush, Font defaultFont);
    private SvgReader(XmlReader xmlReader, double pixelsPerInch, Brush defaultBrush, Font defaultFont);
    private static SvgReader();
    [CompilerGeneratedAttribute]
public double get_PixelsPerInch();
    [CompilerGeneratedAttribute]
private void set_PixelsPerInch(double value);
    [CompilerGeneratedAttribute]
public Graphic get_Graphic();
    [CompilerGeneratedAttribute]
private void set_Graphic(Graphic value);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_Errors();
    private void Read(XDocument doc, Brush defaultBrush, Font defaultFont);
    private void AddElements(IList`1<Element> list, IEnumerable`1<XElement> es, Pen inheritPen, Brush inheritBrush, Font inheritFont);
    private void GetPenAndBrush(XElement e, Pen inheritPen, Brush inheritBrush, Pen& pen, Brush& brush);
    private void AddElement(IList`1<Element> list, XElement e, Pen inheritPen, Brush inheritBrush, Font inheritFont);
    private void ApplyStyle(string style, Pen& pen, Boolean& hasPen, Brush& brush, Boolean& hasBrush);
    private Dictionary`2<string, string> ParseStyle(string style);
    private string GetString(Dictionary`2<string, string> style, string name, string defaultValue);
    private void ApplyStyle(Dictionary`2<string, string> style, Pen& pen, Boolean& hasPen, Brush& brush, Boolean& hasBrush);
    protected GradientBrush GetGradientBrush(string fill, GradientBrush child);
    private Transform ReadTransform(string raw);
    private void ReadTextSpans(Text txt, XElement e, Pen inheritPen, Brush inheritBrush);
    private List`1<PathToken> LexPath(string p);
    private void ReadPath(Path p, string pathDescriptor);
    private void ReadPoints(Path p, string pathDescriptor, bool closePath);
    private string ReadString(XElement e, string defaultValue);
    private string ReadString(XAttribute a, string defaultValue);
    private RadialGradientBrush CreateRadialGradientBrush(XElement e);
    private LinearGradientBrush CreateLinearGradientBrush(XElement e);
    private void ReadStops(XElement e, List`1<GradientStop> stops);
    private Color ReadColor(XElement e, string attrib);
    private Color ReadColor(string raw);
    private string ReadTextFontAttr(XElement element, string attr);
    private string ReadTextFontFamily(XElement element);
    private string ReadTextFontWeight(XElement element);
    private string ReadTextFontStyle(XElement element);
    private double ReadTextFontSize(XElement element);
    private TextAlignment ReadTextAlignment(XElement element);
    private double ReadNumber(XAttribute a);
    private Nullable`1<double> ReadOptionalNumber(XAttribute a);
    private double ReadNumber(string raw);
    private Rect ReadRectangle(string s);
    [CompilerGeneratedAttribute]
internal static double <ReadPath>g__Arg|34_0(int index, <>c__DisplayClass34_0& );
}
public class NGraphics.SvgWriter : object {
    [CompilerGeneratedAttribute]
private Graphic <Graphic>k__BackingField;
    private CodeWriter w;
    private Dictionary`2<object, string> defs;
    private bool wrote;
    public Graphic Graphic { get; private set; }
    public SvgWriter(Graphic graphic, TextWriter writer);
    [CompilerGeneratedAttribute]
public Graphic get_Graphic();
    [CompilerGeneratedAttribute]
private void set_Graphic(Graphic value);
    public void Write();
    private void WriteElement(Element c);
    private string Escape(string text);
    private void WriteStartElement(string name, Element element);
    public sealed virtual void Visit(Group group);
    public sealed virtual void EndVisit(Group group);
    public sealed virtual void Visit(Rectangle rectangle);
    public sealed virtual void EndVisit(Rectangle rectangle);
    public sealed virtual void Visit(Ellipse ellipse);
    public sealed virtual void EndVisit(Ellipse e);
    public sealed virtual void Visit(Path path);
    public sealed virtual void EndVisit(Path e);
    public sealed virtual void Visit(Text text);
    public sealed virtual void EndVisit(Text e);
    public sealed virtual void Visit(ForeignObject foreignObject);
    public sealed virtual void EndVisit(ForeignObject e);
}
public class NGraphics.Text : Element {
    public Rect Frame;
    public TextAlignment Alignment;
    public Font Font;
    public List`1<TextSpan> Spans;
    public string String { get; }
    public Nullable`1<Rect> BoundingBox { get; }
    public Rect SampleableBox { get; }
    public Text(string text, Rect frame, Font font, TextAlignment alignment, Pen pen, Brush brush);
    public Text(Rect frame, Font font, TextAlignment alignment, Pen pen, Brush brush);
    public string get_String();
    protected virtual void AcceptVisitor(IElementVisitor visitor);
    protected virtual Element CreateUninitializedClone();
    public virtual Element TransformGeometry(Transform transform);
    public virtual bool Contains(Point localPoint);
    public virtual Nullable`1<Rect> get_BoundingBox();
    protected virtual void DrawElement(ICanvas canvas);
    public virtual EdgeSamples[] GetEdgeSamples(double tolerance, int minSamples, int maxSamples);
    public virtual Rect get_SampleableBox();
    public void Trim();
}
public enum NGraphics.TextAlignment : Enum {
    public int value__;
    public static TextAlignment Left;
    public static TextAlignment Center;
    public static TextAlignment Right;
}
public class NGraphics.TextMetrics : ValueType {
    public double Width;
    public double Ascent;
    public double Descent;
    public Size Size { get; }
    public Size get_Size();
}
public class NGraphics.TextSpan : object {
    public Nullable`1<Point> Position;
    public Font Font;
    public string Text;
    public Pen Pen;
    public Brush Brush;
    public TextSpan(string text);
}
public class NGraphics.Transform : ValueType {
    public double A;
    public double B;
    public double C;
    public double D;
    public double E;
    public double F;
    public static Transform Identity;
    public Transform(double a, double b, double c, double d, double e, double f);
    private static Transform();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Transform x, Transform y);
    public static bool op_Inequality(Transform x, Transform y);
    public virtual string ToString();
    public Point TransformPoint(Point point);
    public Rect TransformRect(Rect rect);
    public static Transform op_Multiply(Transform x, Transform y);
    public static Transform Translate(double x, double y);
    public static Transform Translate(Size size);
    public static Transform Translate(Point point);
    public static Transform Scale(double sx, double sy);
    public static Transform ScaleAt(double sx, double sy, double x, double y);
    public static Transform ScaleAt(double sx, double sy, Point p);
    public static Transform ScaleAt(double scale, Point p);
    public static Transform Scale(double scale);
    public static Transform Scale(Size size);
    public static Transform Scale(Point point);
    public static Transform Rotate(double angleInDegrees);
    public static Transform StretchFillRect(Rect sourceRect, Rect destRect);
    public static Transform AspectFillRect(Rect sourceRect, Rect destRect);
    public Transform GetInverse();
}
