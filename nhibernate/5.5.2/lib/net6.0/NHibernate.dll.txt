[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class NHibernate.Action.AbstractEntityInsertAction : EntityAction {
    [CompilerGeneratedAttribute]
private Object[] <State>k__BackingField;
    public Object[] State { get; }
    protected internal AbstractEntityInsertAction(object id, Object[] state, object instance, IEntityPersister persister, ISessionImplementor session);
    [CompilerGeneratedAttribute]
public Object[] get_State();
}
[ObsoleteAttribute("This delegate is not used and will be removed in a future version.")]
public class NHibernate.Action.AfterTransactionCompletionProcessDelegate : MulticastDelegate {
    public AfterTransactionCompletionProcessDelegate(object object, IntPtr method);
    public virtual void Invoke(bool success);
    public virtual IAsyncResult BeginInvoke(bool success, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("This delegate is not used and will be removed in a future version.")]
public class NHibernate.Action.BeforeTransactionCompletionProcessDelegate : MulticastDelegate {
    public BeforeTransactionCompletionProcessDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Action.BulkOperationCleanupAction : object {
    private ISessionImplementor session;
    private HashSet`1<string> affectedEntityNames;
    private HashSet`1<string> affectedCollectionRoles;
    private String[] spaces;
    private String[] queryCacheSpaces;
    public String[] QueryCacheSpaces { get; }
    public String[] PropertySpaces { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public BeforeTransactionCompletionProcessDelegate BeforeTransactionCompletionProcess { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public AfterTransactionCompletionProcessDelegate AfterTransactionCompletionProcess { get; }
    private IBeforeTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.BeforeTransactionCompletionProcess { get; }
    private IAfterTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.AfterTransactionCompletionProcess { get; }
    public BulkOperationCleanupAction(ISessionImplementor session, IQueryable[] affectedQueryables);
    public BulkOperationCleanupAction(ISessionImplementor session, ISet`1<string> querySpaces);
    public sealed virtual String[] get_QueryCacheSpaces();
    public sealed virtual String[] get_PropertySpaces();
    public sealed virtual void BeforeExecutions();
    public sealed virtual void Execute();
    public sealed virtual BeforeTransactionCompletionProcessDelegate get_BeforeTransactionCompletionProcess();
    public sealed virtual AfterTransactionCompletionProcessDelegate get_AfterTransactionCompletionProcess();
    private sealed virtual override IBeforeTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.get_BeforeTransactionCompletionProcess();
    private sealed virtual override IAfterTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.get_AfterTransactionCompletionProcess();
    public sealed virtual void ExecuteAfterTransactionCompletion(bool success);
    private void EvictCollectionRegions();
    private void EvictEntityRegions();
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public virtual void Init();
    [AsyncStateMachineAttribute("NHibernate.Action.BulkOperationCleanupAction/<InitAsync>d__25")]
[ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public virtual Task InitAsync(CancellationToken cancellationToken);
    public sealed virtual Task BeforeExecutionsAsync(CancellationToken cancellationToken);
    public sealed virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.BulkOperationCleanupAction/<ExecuteAfterTransactionCompletionAsync>d__28")]
public sealed virtual Task ExecuteAfterTransactionCompletionAsync(bool success, CancellationToken cancellationToken);
    private Task EvictCollectionRegionsAsync(CancellationToken cancellationToken);
    private Task EvictEntityRegionsAsync(CancellationToken cancellationToken);
}
public abstract class NHibernate.Action.CollectionAction : object {
    private object key;
    private ICollectionPersister persister;
    private ISessionImplementor session;
    private string collectionRole;
    private IPersistentCollection collection;
    private ISoftLock softLock;
    protected internal IPersistentCollection Collection { get; }
    protected internal ICollectionPersister Persister { get; }
    [ObsoleteAttribute("Please use GetKey() instead.")]
protected internal object Key { get; }
    protected internal ISessionImplementor Session { get; }
    public String[] QueryCacheSpaces { get; }
    public String[] PropertySpaces { get; }
    private IBeforeTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.BeforeTransactionCompletionProcess { get; }
    private IAfterTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.AfterTransactionCompletionProcess { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public BeforeTransactionCompletionProcessDelegate BeforeTransactionCompletionProcess { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public AfterTransactionCompletionProcessDelegate AfterTransactionCompletionProcess { get; }
    public ISoftLock Lock { get; }
    protected CollectionAction(ICollectionPersister persister, IPersistentCollection collection, object key, ISessionImplementor session);
    protected internal IPersistentCollection get_Collection();
    protected internal ICollectionPersister get_Persister();
    protected internal object get_Key();
    protected object GetKey();
    protected internal ISessionImplementor get_Session();
    public sealed virtual String[] get_QueryCacheSpaces();
    public sealed virtual String[] get_PropertySpaces();
    public virtual void BeforeExecutions();
    public abstract virtual void Execute();
    private sealed virtual override IBeforeTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.get_BeforeTransactionCompletionProcess();
    private sealed virtual override IAfterTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.get_AfterTransactionCompletionProcess();
    public virtual BeforeTransactionCompletionProcessDelegate get_BeforeTransactionCompletionProcess();
    public virtual AfterTransactionCompletionProcessDelegate get_AfterTransactionCompletionProcess();
    public virtual void ExecuteAfterTransactionCompletion(bool success);
    public ISoftLock get_Lock();
    protected internal void Evict();
    public virtual int CompareTo(CollectionAction other);
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionAction/<GetKeyAsync>d__37")]
protected Task`1<object> GetKeyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionAction/<BeforeExecutionsAsync>d__38")]
public virtual Task BeforeExecutionsAsync(CancellationToken cancellationToken);
    public abstract virtual Task ExecuteAsync(CancellationToken cancellationToken);
    public virtual Task ExecuteAfterTransactionCompletionAsync(bool success, CancellationToken cancellationToken);
    protected internal Task EvictAsync(CancellationToken cancellationToken);
}
public class NHibernate.Action.CollectionRecreateAction : CollectionAction {
    public CollectionRecreateAction(IPersistentCollection collection, ICollectionPersister persister, object key, ISessionImplementor session);
    public virtual void Execute();
    private void PreRecreate();
    private void PostRecreate();
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionRecreateAction/<ExecuteAsync>d__4")]
public virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionRecreateAction/<PreRecreateAsync>d__5")]
private Task PreRecreateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionRecreateAction/<PostRecreateAsync>d__6")]
private Task PostRecreateAsync(CancellationToken cancellationToken);
}
public class NHibernate.Action.CollectionRemoveAction : CollectionAction {
    private bool emptySnapshot;
    private object affectedOwner;
    public CollectionRemoveAction(IPersistentCollection collection, ICollectionPersister persister, object id, bool emptySnapshot, ISessionImplementor session);
    public CollectionRemoveAction(object affectedOwner, ICollectionPersister persister, object id, bool emptySnapshot, ISessionImplementor session);
    public virtual void Execute();
    private void PreRemove();
    private void PostRemove();
    public virtual int CompareTo(CollectionAction other);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionRemoveAction/<ExecuteAsync>d__8")]
public virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionRemoveAction/<PreRemoveAsync>d__9")]
private Task PreRemoveAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionRemoveAction/<PostRemoveAsync>d__10")]
private Task PostRemoveAsync(CancellationToken cancellationToken);
}
public class NHibernate.Action.CollectionUpdateAction : CollectionAction {
    private bool emptySnapshot;
    public CollectionUpdateAction(IPersistentCollection collection, ICollectionPersister persister, object key, bool emptySnapshot, ISessionImplementor session);
    public virtual void Execute();
    private void PreUpdate();
    private void PostUpdate();
    public virtual void ExecuteAfterTransactionCompletion(bool success);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionUpdateAction/<ExecuteAsync>d__6")]
public virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionUpdateAction/<PreUpdateAsync>d__7")]
private Task PreUpdateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionUpdateAction/<PostUpdateAsync>d__8")]
private Task PostUpdateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.CollectionUpdateAction/<ExecuteAfterTransactionCompletionAsync>d__9")]
public virtual Task ExecuteAfterTransactionCompletionAsync(bool success, CancellationToken cancellationToken);
}
public class NHibernate.Action.DelayedPostInsertIdentifier : object {
    private static long GlobalSequence;
    private long sequence;
    [CompilerGeneratedAttribute]
private object <ActualId>k__BackingField;
    public object ActualId { get; public set; }
    public virtual bool Equals(object obj);
    public bool Equals(DelayedPostInsertIdentifier that);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public object get_ActualId();
    [CompilerGeneratedAttribute]
public void set_ActualId(object value);
}
public abstract class NHibernate.Action.EntityAction : object {
    private string entityName;
    private object id;
    private object instance;
    private ISessionImplementor session;
    private IEntityPersister persister;
    public string EntityName { get; }
    public object Id { get; }
    public object Instance { get; }
    public ISessionImplementor Session { get; }
    public IEntityPersister Persister { get; }
    protected internal bool HasPostCommitEventListeners { get; }
    public String[] QueryCacheSpaces { get; }
    public String[] PropertySpaces { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public BeforeTransactionCompletionProcessDelegate BeforeTransactionCompletionProcess { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public AfterTransactionCompletionProcessDelegate AfterTransactionCompletionProcess { get; }
    private IBeforeTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.BeforeTransactionCompletionProcess { get; }
    private IAfterTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.AfterTransactionCompletionProcess { get; }
    protected internal EntityAction(ISessionImplementor session, object id, object instance, IEntityPersister persister);
    public string get_EntityName();
    public object get_Id();
    public object get_Instance();
    public ISessionImplementor get_Session();
    public IEntityPersister get_Persister();
    protected internal abstract virtual bool get_HasPostCommitEventListeners();
    public sealed virtual String[] get_QueryCacheSpaces();
    public sealed virtual String[] get_PropertySpaces();
    public sealed virtual void BeforeExecutions();
    public abstract virtual void Execute();
    public virtual BeforeTransactionCompletionProcessDelegate get_BeforeTransactionCompletionProcess();
    public virtual AfterTransactionCompletionProcessDelegate get_AfterTransactionCompletionProcess();
    private sealed virtual override IBeforeTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.get_BeforeTransactionCompletionProcess();
    private sealed virtual override IAfterTransactionCompletionProcess NHibernate.Action.IAsyncExecutable.get_AfterTransactionCompletionProcess();
    protected virtual bool NeedsAfterTransactionCompletion();
    protected virtual bool NeedsBeforeTransactionCompletion();
    protected virtual void BeforeTransactionCompletionProcessImpl();
    protected virtual void AfterTransactionCompletionProcessImpl(bool success);
    public virtual int CompareTo(EntityAction other);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual string ToString();
    public sealed virtual void ExecuteBeforeTransactionCompletion();
    public sealed virtual void ExecuteAfterTransactionCompletion(bool success);
    public sealed virtual Task BeforeExecutionsAsync(CancellationToken cancellationToken);
    public abstract virtual Task ExecuteAsync(CancellationToken cancellationToken);
    protected virtual Task BeforeTransactionCompletionProcessImplAsync(CancellationToken cancellationToken);
    protected virtual Task AfterTransactionCompletionProcessImplAsync(bool success, CancellationToken cancellationToken);
    public sealed virtual Task ExecuteBeforeTransactionCompletionAsync(CancellationToken cancellationToken);
    public sealed virtual Task ExecuteAfterTransactionCompletionAsync(bool success, CancellationToken cancellationToken);
}
public class NHibernate.Action.EntityDeleteAction : EntityAction {
    private Object[] state;
    private object version;
    private bool isCascadeDeleteEnabled;
    private ISoftLock sLock;
    protected internal bool HasPostCommitEventListeners { get; }
    public EntityDeleteAction(object id, Object[] state, object version, object instance, IEntityPersister persister, bool isCascadeDeleteEnabled, ISessionImplementor session);
    protected internal virtual bool get_HasPostCommitEventListeners();
    public virtual void Execute();
    private void PostDelete();
    private bool PreDelete();
    protected virtual void AfterTransactionCompletionProcessImpl(bool success);
    private void PostCommitDelete();
    public virtual int CompareTo(EntityAction other);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityDeleteAction/<ExecuteAsync>d__13")]
public virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityDeleteAction/<PostDeleteAsync>d__14")]
private Task PostDeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityDeleteAction/<PreDeleteAsync>d__15")]
private Task`1<bool> PreDeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityDeleteAction/<AfterTransactionCompletionProcessImplAsync>d__16")]
protected virtual Task AfterTransactionCompletionProcessImplAsync(bool success, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityDeleteAction/<PostCommitDeleteAsync>d__17")]
private Task PostCommitDeleteAsync(CancellationToken cancellationToken);
}
public class NHibernate.Action.EntityIdentityInsertAction : AbstractEntityInsertAction {
    private bool isDelayed;
    private EntityKey delayedEntityKey;
    private object generatedId;
    public object GeneratedId { get; }
    public EntityKey DelayedEntityKey { get; }
    protected internal bool HasPostCommitEventListeners { get; }
    public EntityIdentityInsertAction(Object[] state, object instance, IEntityPersister persister, ISessionImplementor session, bool isDelayed);
    public object get_GeneratedId();
    public EntityKey get_DelayedEntityKey();
    protected internal virtual bool get_HasPostCommitEventListeners();
    public virtual void Execute();
    private void PostInsert();
    private void PostCommitInsert();
    private bool PreInsert();
    protected virtual void AfterTransactionCompletionProcessImpl(bool success);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityIdentityInsertAction/<ExecuteAsync>d__15")]
public virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityIdentityInsertAction/<PostInsertAsync>d__16")]
private Task PostInsertAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityIdentityInsertAction/<PostCommitInsertAsync>d__17")]
private Task PostCommitInsertAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityIdentityInsertAction/<PreInsertAsync>d__18")]
private Task`1<bool> PreInsertAsync(CancellationToken cancellationToken);
    protected virtual Task AfterTransactionCompletionProcessImplAsync(bool success, CancellationToken cancellationToken);
}
public class NHibernate.Action.EntityInsertAction : AbstractEntityInsertAction {
    private object version;
    private object cacheEntry;
    protected internal bool HasPostCommitEventListeners { get; }
    public EntityInsertAction(object id, Object[] state, object instance, object version, IEntityPersister persister, ISessionImplementor session);
    protected internal virtual bool get_HasPostCommitEventListeners();
    public virtual void Execute();
    protected virtual void AfterTransactionCompletionProcessImpl(bool success);
    private void PostInsert();
    private void PostCommitInsert();
    private bool PreInsert();
    private bool IsCachePutEnabled(IEntityPersister persister);
    public virtual int CompareTo(EntityAction other);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityInsertAction/<ExecuteAsync>d__12")]
public virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityInsertAction/<AfterTransactionCompletionProcessImplAsync>d__13")]
protected virtual Task AfterTransactionCompletionProcessImplAsync(bool success, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityInsertAction/<PostInsertAsync>d__14")]
private Task PostInsertAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityInsertAction/<PostCommitInsertAsync>d__15")]
private Task PostCommitInsertAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityInsertAction/<PreInsertAsync>d__16")]
private Task`1<bool> PreInsertAsync(CancellationToken cancellationToken);
}
public class NHibernate.Action.EntityUpdateAction : EntityAction {
    private Object[] state;
    private Object[] previousState;
    private object previousVersion;
    private object nextVersion;
    private Int32[] dirtyFields;
    private bool hasDirtyCollection;
    private object cacheEntry;
    private ISoftLock slock;
    protected internal bool HasPostCommitEventListeners { get; }
    public EntityUpdateAction(object id, Object[] state, Int32[] dirtyProperties, bool hasDirtyCollection, Object[] previousState, object previousVersion, object nextVersion, object instance, IEntityPersister persister, ISessionImplementor session);
    protected internal virtual bool get_HasPostCommitEventListeners();
    public virtual void Execute();
    protected virtual void AfterTransactionCompletionProcessImpl(bool success);
    private void PostUpdate();
    private void PostCommitUpdate();
    private bool PreUpdate();
    [AsyncStateMachineAttribute("NHibernate.Action.EntityUpdateAction/<ExecuteAsync>d__16")]
public virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityUpdateAction/<AfterTransactionCompletionProcessImplAsync>d__17")]
protected virtual Task AfterTransactionCompletionProcessImplAsync(bool success, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityUpdateAction/<PostUpdateAsync>d__18")]
private Task PostUpdateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityUpdateAction/<PostCommitUpdateAsync>d__19")]
private Task PostCommitUpdateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Action.EntityUpdateAction/<PreUpdateAsync>d__20")]
private Task`1<bool> PreUpdateAsync(CancellationToken cancellationToken);
}
public interface NHibernate.Action.IAfterTransactionCompletionProcess {
    public abstract virtual void ExecuteAfterTransactionCompletion(bool success);
    public abstract virtual Task ExecuteAfterTransactionCompletionAsync(bool success, CancellationToken cancellationToken);
}
public interface NHibernate.Action.IAsyncExecutable {
    public IBeforeTransactionCompletionProcess BeforeTransactionCompletionProcess { get; }
    public IAfterTransactionCompletionProcess AfterTransactionCompletionProcess { get; }
    public abstract virtual IBeforeTransactionCompletionProcess get_BeforeTransactionCompletionProcess();
    public abstract virtual IAfterTransactionCompletionProcess get_AfterTransactionCompletionProcess();
}
public interface NHibernate.Action.IBeforeTransactionCompletionProcess {
    public abstract virtual void ExecuteBeforeTransactionCompletion();
    public abstract virtual Task ExecuteBeforeTransactionCompletionAsync(CancellationToken cancellationToken);
}
public interface NHibernate.Action.ICacheableExecutable {
    public String[] QueryCacheSpaces { get; }
    public abstract virtual String[] get_QueryCacheSpaces();
}
public interface NHibernate.Action.IExecutable {
    public String[] PropertySpaces { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version. Please implement IAsyncExecutable.")]
public BeforeTransactionCompletionProcessDelegate BeforeTransactionCompletionProcess { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version. Please implement IAsyncExecutable.")]
public AfterTransactionCompletionProcessDelegate AfterTransactionCompletionProcess { get; }
    public abstract virtual String[] get_PropertySpaces();
    public abstract virtual void BeforeExecutions();
    public abstract virtual void Execute();
    public abstract virtual BeforeTransactionCompletionProcessDelegate get_BeforeTransactionCompletionProcess();
    public abstract virtual AfterTransactionCompletionProcessDelegate get_AfterTransactionCompletionProcess();
    public abstract virtual Task BeforeExecutionsAsync(CancellationToken cancellationToken);
    public abstract virtual Task ExecuteAsync(CancellationToken cancellationToken);
}
public class NHibernate.ADOException : HibernateException {
    private string sql;
    public string SqlString { get; }
    public ADOException(string message, Exception innerException);
    public ADOException(string message, Exception innerException, string sql);
    protected ADOException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_SqlString();
}
public abstract class NHibernate.AdoNet.AbstractBatcher : object {
    protected static INHibernateLogger Log;
    private static int _openCommandCount;
    private static int _openReaderCount;
    private ConnectionManager _connectionManager;
    private ISessionFactoryImplementor _factory;
    private IInterceptor _interceptor;
    private DbCommand _batchCommand;
    private SqlString _batchCommandSql;
    private SqlType[] _batchCommandParameterTypes;
    private HashSet`1<DbCommand> _commandsToClose;
    private HashSet`1<DbDataReader> _readersToClose;
    private Dictionary`2<DbDataReader, Stopwatch> _readersDuration;
    private DbCommand _lastQuery;
    private bool _releasing;
    private bool _isAlreadyDisposed;
    protected IDriver Driver { get; }
    protected DbCommand CurrentCommand { get; }
    protected SqlString CurrentCommandSql { get; }
    protected SqlType[] CurrentCommandParameterTypes { get; }
    protected int CountOfStatementsInCurrentBatch { get; }
    public int BatchSize { get; public set; }
    protected ISessionFactoryImplementor Factory { get; }
    protected ConnectionManager ConnectionManager { get; }
    public bool HasOpenResources { get; }
    protected AbstractBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
    private static AbstractBatcher();
    protected IDriver get_Driver();
    protected DbCommand get_CurrentCommand();
    protected SqlString get_CurrentCommandSql();
    protected SqlType[] get_CurrentCommandParameterTypes();
    public DbCommand Generate(CommandType type, SqlString sqlString, SqlType[] parameterTypes);
    private DbCommand Generate(CommandType type, SqlString sqlString, SqlType[] parameterTypes, bool batch);
    protected void Prepare(DbCommand cmd);
    public virtual DbCommand PrepareBatchCommand(CommandType type, SqlString sql, SqlType[] parameterTypes);
    public sealed virtual DbCommand PrepareCommand(CommandType type, SqlString sql, SqlType[] parameterTypes);
    private DbCommand PrepareCommand(CommandType type, SqlString sql, SqlType[] parameterTypes, bool batch);
    protected virtual void OnPreparedCommand();
    internal virtual void OnPreparedBatchStatement(SqlString sqlString);
    public sealed virtual DbCommand PrepareQueryCommand(CommandType type, SqlString sql, SqlType[] parameterTypes);
    public sealed virtual void AbortBatch(Exception e);
    private void InvalidateBatchCommand();
    public sealed virtual int ExecuteNonQuery(DbCommand cmd);
    public virtual DbDataReader ExecuteReader(DbCommand cmd);
    private DbDataReader DoExecuteReader(DbCommand cmd);
    protected void CheckReaders();
    public virtual void CloseCommands();
    private void CloseCommand(DbCommand cmd);
    public sealed virtual void CloseCommand(DbCommand st, DbDataReader reader);
    public sealed virtual void CloseReader(DbDataReader reader);
    public sealed virtual void ExecuteBatch();
    protected void ExecuteBatchWithTiming(DbCommand ps);
    protected abstract virtual void DoExecuteBatch(DbCommand ps);
    protected abstract virtual int get_CountOfStatementsInCurrentBatch();
    public abstract virtual int get_BatchSize();
    public abstract virtual void set_BatchSize(int value);
    public abstract virtual void AddToBatch(IExpectation expectation);
    protected ISessionFactoryImplementor get_Factory();
    protected ConnectionManager get_ConnectionManager();
    protected void LogCommand(DbCommand command);
    private void LogOpenPreparedCommand(SqlString sql);
    private void LogClosePreparedCommand();
    private void LogOpenReader(Stopwatch duration, DbDataReader reader);
    private static void LogCloseReader(Stopwatch duration);
    public sealed virtual void CancelLastQuery();
    public sealed virtual bool get_HasOpenResources();
    protected Exception Convert(Exception sqlException, string message);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    protected SqlString GetSQL(SqlString sql);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<PrepareAsync>d__69")]
protected Task PrepareAsync(DbCommand cmd, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<PrepareBatchCommandAsync>d__70")]
public virtual Task`1<DbCommand> PrepareBatchCommandAsync(CommandType type, SqlString sql, SqlType[] parameterTypes, CancellationToken cancellationToken);
    public sealed virtual Task`1<DbCommand> PrepareCommandAsync(CommandType type, SqlString sql, SqlType[] parameterTypes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<PrepareCommandAsync>d__72")]
private Task`1<DbCommand> PrepareCommandAsync(CommandType type, SqlString sql, SqlType[] parameterTypes, bool batch, CancellationToken cancellationToken);
    protected virtual Task OnPreparedCommandAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<ExecuteNonQueryAsync>d__74")]
public sealed virtual Task`1<int> ExecuteNonQueryAsync(DbCommand cmd, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<ExecuteReaderAsync>d__75")]
public virtual Task`1<DbDataReader> ExecuteReaderAsync(DbCommand cmd, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<DoExecuteReaderAsync>d__76")]
private Task`1<DbDataReader> DoExecuteReaderAsync(DbCommand cmd, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<CheckReadersAsync>d__77")]
protected Task CheckReadersAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<ExecuteBatchAsync>d__78")]
public sealed virtual Task ExecuteBatchAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.AbstractBatcher/<ExecuteBatchWithTimingAsync>d__79")]
protected Task ExecuteBatchWithTimingAsync(DbCommand ps, CancellationToken cancellationToken);
    protected abstract virtual Task DoExecuteBatchAsync(DbCommand ps, CancellationToken cancellationToken);
    public abstract virtual Task AddToBatchAsync(IExpectation expectation, CancellationToken cancellationToken);
}
public class NHibernate.AdoNet.ColumnNameCache : object {
    private ReaderWriterLockSlim _cacheLock;
    private Dictionary`2<string, int> _columnNameToIndexCache;
    public ColumnNameCache(int columnCount);
    public int GetIndexForColumnName(string columnName, ResultSetWrapper rs);
    private bool TryRead(string key, Int32& value);
    private void Insert(string key, int value);
}
public class NHibernate.AdoNet.ConnectionManager : object {
    private IConnectionAccess _connectionAccess;
    private static INHibernateLogger _log;
    private DbConnection _connection;
    private DbConnection _backupConnection;
    private Transaction _currentSystemTransaction;
    private Transaction _backupCurrentSystemTransaction;
    private bool _ownConnection;
    private ITransaction _transaction;
    private IBatcher _batcher;
    private ConnectionReleaseMode _connectionReleaseMode;
    private IInterceptor _interceptor;
    private List`1<ISessionImplementor> _dependentSessions;
    [CompilerGeneratedAttribute]
private ISessionImplementor <Session>k__BackingField;
    private bool _releasesEnabled;
    private bool _processingFromSystemTransaction;
    private bool _allowConnectionUsage;
    private bool _connectionReleaseRequired;
    private bool _connectionEnlistmentRequired;
    [CompilerGeneratedAttribute]
private bool <ShouldAutoJoinTransaction>k__BackingField;
    private int _flushDepth;
    public ISessionImplementor Session { get; }
    public IReadOnlyCollection`1<ISessionImplementor> DependentSessions { get; }
    public bool ProcessingFromSystemTransaction { get; }
    public bool IsInActiveExplicitTransaction { get; }
    public bool IsInActiveTransaction { get; }
    public bool IsConnected { get; }
    public bool ShouldAutoJoinTransaction { get; }
    [ObsoleteAttribute("Use CurrentTransaction instead, and check for null.")]
public ITransaction Transaction { get; }
    public ITransaction CurrentTransaction { get; }
    private bool IsAfterTransactionRelease { get; }
    private bool IsOnCloseRelease { get; }
    private bool IsAggressiveRelease { get; }
    public ISessionFactoryImplementor Factory { get; }
    public bool IsReadyForSerialization { get; }
    public IBatcher Batcher { get; }
    public ConnectionManager(ISessionImplementor session, DbConnection suppliedConnection, ConnectionReleaseMode connectionReleaseMode, IInterceptor interceptor, bool shouldAutoJoinTransaction, IConnectionAccess connectionAccess);
    [ObsoleteAttribute("Use overload with connectionAccess parameter")]
public ConnectionManager(ISessionImplementor session, DbConnection suppliedConnection, ConnectionReleaseMode connectionReleaseMode, IInterceptor interceptor, bool shouldAutoJoinTransaction);
    private ConnectionManager(SerializationInfo info, StreamingContext context);
    private static ConnectionManager();
    [CompilerGeneratedAttribute]
public ISessionImplementor get_Session();
    public IReadOnlyCollection`1<ISessionImplementor> get_DependentSessions();
    public bool get_ProcessingFromSystemTransaction();
    public void AddDependentSession(ISessionImplementor session);
    public void RemoveDependentSession(ISessionImplementor session);
    public bool get_IsInActiveExplicitTransaction();
    public bool get_IsInActiveTransaction();
    public bool get_IsConnected();
    [CompilerGeneratedAttribute]
public bool get_ShouldAutoJoinTransaction();
    public void Reconnect();
    public void Reconnect(DbConnection suppliedConnection);
    public DbConnection Close();
    private DbConnection DisconnectSuppliedConnection();
    private void DisconnectOwnConnection();
    public DbConnection Disconnect();
    private void CloseConnection();
    public DbConnection GetNewConnection();
    public DbConnection GetConnection();
    public void AfterTransaction();
    public void AfterStatement();
    private void AggressiveRelease();
    public void FlushBeginning();
    public void FlushEnding();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public ITransaction BeginTransaction(IsolationLevel isolationLevel);
    public ITransaction BeginTransaction();
    private void EnsureTransactionIsCreated();
    public ITransaction get_Transaction();
    public ITransaction get_CurrentTransaction();
    public void AfterNonTransactionalQuery(bool success);
    private bool get_IsAfterTransactionRelease();
    private bool get_IsOnCloseRelease();
    private bool get_IsAggressiveRelease();
    public ISessionFactoryImplementor get_Factory();
    public bool get_IsReadyForSerialization();
    public IBatcher get_Batcher();
    public DbCommand CreateCommand();
    public void EnlistInTransaction(DbCommand command);
    public void EnlistIfRequired(Transaction transaction);
    public IDisposable BeginProcessingFromSystemTransaction(bool allowConnectionUsage);
    public Task`1<DbConnection> GetNewConnectionAsync(CancellationToken cancellationToken);
    public Task`1<DbConnection> GetConnectionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.ConnectionManager/<CreateCommandAsync>d__82")]
public Task`1<DbCommand> CreateCommandAsync(CancellationToken cancellationToken);
}
internal class NHibernate.AdoNet.DbCommandWrapper : DbCommand {
    [CompilerGeneratedAttribute]
private DbCommand <Command>k__BackingField;
    public DbCommand Command { get; }
    public string CommandText { get; public set; }
    public int CommandTimeout { get; public set; }
    public CommandType CommandType { get; public set; }
    public UpdateRowSource UpdatedRowSource { get; public set; }
    protected DbConnection DbConnection { get; protected set; }
    protected DbParameterCollection DbParameterCollection { get; }
    protected DbTransaction DbTransaction { get; protected set; }
    public bool DesignTimeVisible { get; public set; }
    public DbCommandWrapper(DbCommand command);
    [CompilerGeneratedAttribute]
public DbCommand get_Command();
    public virtual void Cancel();
    public virtual int ExecuteNonQuery();
    public virtual object ExecuteScalar();
    public virtual void Prepare();
    public virtual string get_CommandText();
    public virtual void set_CommandText(string value);
    public virtual int get_CommandTimeout();
    public virtual void set_CommandTimeout(int value);
    public virtual CommandType get_CommandType();
    public virtual void set_CommandType(CommandType value);
    public virtual UpdateRowSource get_UpdatedRowSource();
    public virtual void set_UpdatedRowSource(UpdateRowSource value);
    protected virtual DbConnection get_DbConnection();
    protected virtual void set_DbConnection(DbConnection value);
    protected virtual DbParameterCollection get_DbParameterCollection();
    protected virtual DbTransaction get_DbTransaction();
    protected virtual void set_DbTransaction(DbTransaction value);
    public virtual bool get_DesignTimeVisible();
    public virtual void set_DesignTimeVisible(bool value);
    protected virtual DbParameter CreateDbParameter();
    protected virtual DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
    public virtual Task`1<int> ExecuteNonQueryAsync(CancellationToken cancellationToken);
    public virtual Task`1<object> ExecuteScalarAsync(CancellationToken cancellationToken);
    protected virtual Task`1<DbDataReader> ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
}
public class NHibernate.AdoNet.Expectations : object {
    private static int UsualExpectedCount;
    public static IExpectation None;
    public static IExpectation Basic;
    private static Expectations();
    public static IExpectation AppropriateExpectation(ExecuteUpdateResultCheckStyle style);
    [ObsoleteAttribute]
public static void VerifyOutcomeBatched(int expectedRowCount, int rowCount);
    public static void VerifyOutcomeBatched(int expectedRowCount, int rowCount, DbCommand statement);
}
public class NHibernate.AdoNet.GenericBatchingBatcher : AbstractBatcher {
    private Nullable`1<int> _maxNumberOfParameters;
    private BatchingCommandSet _currentBatch;
    private int _totalExpectedRowsAffected;
    private StringBuilder _currentBatchCommandsLog;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    public int BatchSize { get; public set; }
    protected int CountOfStatementsInCurrentBatch { get; }
    public GenericBatchingBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
    [CompilerGeneratedAttribute]
public sealed virtual int get_BatchSize();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BatchSize(int value);
    protected virtual int get_CountOfStatementsInCurrentBatch();
    public virtual void AddToBatch(IExpectation expectation);
    protected virtual void DoExecuteBatch(DbCommand ps);
    private void LogBatchCommand(DbCommand batchCommand);
    private void ClearCurrentBatch();
    public virtual void CloseCommands();
    protected virtual void Dispose(bool isDisposing);
    internal virtual void OnPreparedBatchStatement(SqlString sqlString);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.GenericBatchingBatcher/<AddToBatchAsync>d__19")]
public virtual Task AddToBatchAsync(IExpectation expectation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.GenericBatchingBatcher/<DoExecuteBatchAsync>d__20")]
protected virtual Task DoExecuteBatchAsync(DbCommand ps, CancellationToken cancellationToken);
}
public class NHibernate.AdoNet.GenericBatchingBatcherFactory : object {
    public virtual IBatcher CreateBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
}
public class NHibernate.AdoNet.HanaBatchingBatcher : AbstractBatcher {
    private int _batchSize;
    private int _countOfCommands;
    private int _totalExpectedRowsAffected;
    private DbCommand _currentBatch;
    private List`1<DbCommand> _currentBatchCommands;
    private StringBuilder _currentBatchCommandsLog;
    protected int CountOfStatementsInCurrentBatch { get; }
    public int BatchSize { get; public set; }
    public HanaBatchingBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
    public virtual void AddToBatch(IExpectation expectation);
    protected virtual void DoExecuteBatch(DbCommand ps);
    protected virtual int get_CountOfStatementsInCurrentBatch();
    public virtual int get_BatchSize();
    public virtual void set_BatchSize(int value);
    public virtual void CloseCommands();
    protected virtual void Dispose(bool isDisposing);
    private void CloseBatchCommands();
    public virtual Task AddToBatchAsync(IExpectation expectation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.HanaBatchingBatcher/<DoExecuteBatchAsync>d__18")]
protected virtual Task DoExecuteBatchAsync(DbCommand ps, CancellationToken cancellationToken);
}
public class NHibernate.AdoNet.HanaBatchingBatcherFactory : object {
    public virtual IBatcher CreateBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
}
public interface NHibernate.AdoNet.IBatcherFactory {
    public abstract virtual IBatcher CreateBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
}
public interface NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider {
    public Type BatcherFactoryClass { get; }
    public abstract virtual Type get_BatcherFactoryClass();
}
public interface NHibernate.AdoNet.IExpectation {
    public bool CanBeBatched { get; }
    public int ExpectedRowCount { get; }
    public abstract virtual void VerifyOutcomeNonBatched(int rowCount, DbCommand statement);
    public abstract virtual bool get_CanBeBatched();
    public abstract virtual int get_ExpectedRowCount();
}
public interface NHibernate.AdoNet.IParameterAdjuster {
    public abstract virtual void AdjustParameterForValue(DbParameter parameter, SqlType sqlType, object value);
}
public class NHibernate.AdoNet.MySqlClientBatchingBatcher : AbstractBatcher {
    private int batchSize;
    private int totalExpectedRowsAffected;
    private MySqlClientSqlCommandSet currentBatch;
    private StringBuilder currentBatchCommandsLog;
    public int BatchSize { get; public set; }
    protected int CountOfStatementsInCurrentBatch { get; }
    public MySqlClientBatchingBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
    public virtual int get_BatchSize();
    public virtual void set_BatchSize(int value);
    protected virtual int get_CountOfStatementsInCurrentBatch();
    public virtual void AddToBatch(IExpectation expectation);
    protected virtual void DoExecuteBatch(DbCommand ps);
    private MySqlClientSqlCommandSet CreateConfiguredBatch();
    private void ClearCurrentBatch();
    public virtual void CloseCommands();
    protected virtual void Dispose(bool isDisposing);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.MySqlClientBatchingBatcher/<AddToBatchAsync>d__16")]
public virtual Task AddToBatchAsync(IExpectation expectation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.MySqlClientBatchingBatcher/<DoExecuteBatchAsync>d__17")]
protected virtual Task DoExecuteBatchAsync(DbCommand ps, CancellationToken cancellationToken);
}
public class NHibernate.AdoNet.MySqlClientBatchingBatcherFactory : object {
    public virtual IBatcher CreateBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
}
public class NHibernate.AdoNet.MySqlClientSqlCommandSet : object {
    private static Type adapterType;
    private static Action`1<object> doInitialise;
    private static Action`2<object, int> batchSizeSetter;
    private static Action`2<object, DbCommand> doAppend;
    private static Func`2<object, int> doExecuteNonQuery;
    private static Action`1<object> doDispose;
    private object instance;
    private int countOfCommands;
    public int CountOfCommands { get; }
    private static MySqlClientSqlCommandSet();
    public MySqlClientSqlCommandSet(int batchSize);
    public void Append(DbCommand command);
    public sealed virtual void Dispose();
    public int ExecuteNonQuery();
    public int get_CountOfCommands();
}
public class NHibernate.AdoNet.NonBatchingBatcher : AbstractBatcher {
    protected int CountOfStatementsInCurrentBatch { get; }
    public int BatchSize { get; public set; }
    public NonBatchingBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
    public virtual void AddToBatch(IExpectation expectation);
    protected virtual void DoExecuteBatch(DbCommand ps);
    protected virtual int get_CountOfStatementsInCurrentBatch();
    public virtual int get_BatchSize();
    public virtual void set_BatchSize(int value);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.NonBatchingBatcher/<AddToBatchAsync>d__8")]
public virtual Task AddToBatchAsync(IExpectation expectation, CancellationToken cancellationToken);
    protected virtual Task DoExecuteBatchAsync(DbCommand ps, CancellationToken cancellationToken);
}
public class NHibernate.AdoNet.NonBatchingBatcherFactory : object {
    public virtual IBatcher CreateBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
}
public class NHibernate.AdoNet.OracleDataClientBatchingBatcher : AbstractBatcher {
    private int _batchSize;
    private int _countOfCommands;
    private int _totalExpectedRowsAffected;
    private DbCommand _currentBatch;
    private Dictionary`2<string, List`1<object>> _parameterValueListHashTable;
    private Dictionary`2<string, bool> _parameterIsAllNullsHashTable;
    private StringBuilder _currentBatchCommandsLog;
    protected int CountOfStatementsInCurrentBatch { get; }
    public int BatchSize { get; public set; }
    public OracleDataClientBatchingBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
    public virtual void AddToBatch(IExpectation expectation);
    protected virtual void DoExecuteBatch(DbCommand ps);
    protected virtual int get_CountOfStatementsInCurrentBatch();
    private void SetArrayBindCount(int arraySize);
    public virtual int get_BatchSize();
    public virtual void set_BatchSize(int value);
    public virtual Task AddToBatchAsync(IExpectation expectation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.AdoNet.OracleDataClientBatchingBatcher/<DoExecuteBatchAsync>d__17")]
protected virtual Task DoExecuteBatchAsync(DbCommand ps, CancellationToken cancellationToken);
}
public class NHibernate.AdoNet.OracleDataClientBatchingBatcherFactory : object {
    public virtual IBatcher CreateBatcher(ConnectionManager connectionManager, IInterceptor interceptor);
}
[DefaultMemberAttribute("Item")]
public class NHibernate.AdoNet.ResultSetWrapper : DbDataReader {
    private DbDataReader rs;
    private ColumnNameCache columnNameCache;
    private bool disposed;
    internal DbDataReader Target { get; }
    public int Depth { get; }
    public bool HasRows { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public int FieldCount { get; }
    public object Item { get; }
    public object Item { get; }
    public ResultSetWrapper(DbDataReader resultSet, ColumnNameCache columnNameCache);
    internal DbDataReader get_Target();
    public virtual void Close();
    public virtual DataTable GetSchemaTable();
    public virtual bool NextResult();
    public virtual bool Read();
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
    public virtual int get_Depth();
    public virtual bool get_HasRows();
    public virtual bool get_IsClosed();
    public virtual int get_RecordsAffected();
    protected virtual void Dispose(bool disposing);
    public virtual string GetName(int i);
    public virtual string GetDataTypeName(int i);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int i);
    public virtual object GetValue(int i);
    public virtual int GetValues(Object[] values);
    public virtual int GetOrdinal(string name);
    public virtual bool GetBoolean(int i);
    public virtual byte GetByte(int i);
    public virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public virtual char GetChar(int i);
    public virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public virtual Guid GetGuid(int i);
    public virtual short GetInt16(int i);
    public virtual int GetInt32(int i);
    public virtual long GetInt64(int i);
    public virtual float GetFloat(int i);
    public virtual double GetDouble(int i);
    public virtual string GetString(int i);
    public virtual decimal GetDecimal(int i);
    public virtual DateTime GetDateTime(int i);
    protected virtual DbDataReader GetDbDataReader(int ordinal);
    public virtual bool IsDBNull(int i);
    public virtual int get_FieldCount();
    public virtual object get_Item(int i);
    public virtual object get_Item(string name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NHibernate.AdoNet.TooManyRowsAffectedException : HibernateException {
    private int expectedRowCount;
    private int actualRowCount;
    public int ExpectedRowCount { get; }
    public int ActualRowCount { get; }
    public TooManyRowsAffectedException(string message, int expectedRowCount, int actualRowCount);
    protected TooManyRowsAffectedException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_ExpectedRowCount();
    public int get_ActualRowCount();
}
public class NHibernate.AdoNet.Util.BasicFormatter : object {
    private static INHibernateLogger Logger;
    protected static string IndentString;
    protected static string Initial;
    protected static HashSet`1<string> beginClauses;
    protected static HashSet`1<string> dml;
    protected static HashSet`1<string> endClauses;
    protected static HashSet`1<string> logical;
    protected static HashSet`1<string> misc;
    protected static HashSet`1<string> quantifiers;
    private static BasicFormatter();
    public virtual string Format(string source);
}
public class NHibernate.AdoNet.Util.DdlFormatter : object {
    private static INHibernateLogger Logger;
    private static string Indent1;
    private static string Indent2;
    private static string Indent3;
    private static DdlFormatter();
    public virtual string Format(string sql);
    protected virtual string FormatCommentOn(string sql);
    protected virtual string FormatAlterTable(string sql);
    protected virtual string FormatCreateTable(string sql);
    private static bool IsBreak(string token);
    private static bool IsQuote(string token);
}
public class NHibernate.AdoNet.Util.FormatStyle : object {
    public static FormatStyle Basic;
    public static FormatStyle Ddl;
    public static FormatStyle None;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatter <Formatter>k__BackingField;
    public string Name { get; private set; }
    public IFormatter Formatter { get; private set; }
    private FormatStyle(string name, IFormatter formatter);
    private static FormatStyle();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public IFormatter get_Formatter();
    [CompilerGeneratedAttribute]
private void set_Formatter(IFormatter value);
    public virtual bool Equals(object obj);
    public bool Equals(FormatStyle other);
    public virtual int GetHashCode();
}
public interface NHibernate.AdoNet.Util.IFormatter {
    public abstract virtual string Format(string source);
}
public class NHibernate.AdoNet.Util.SqlStatementLogger : object {
    private static INHibernateLogger Logger;
    [CompilerGeneratedAttribute]
private bool <LogToStdout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatSql>k__BackingField;
    public bool LogToStdout { get; public set; }
    public bool FormatSql { get; public set; }
    public bool IsDebugEnabled { get; }
    public SqlStatementLogger(bool logToStdout, bool formatSql);
    private static SqlStatementLogger();
    [CompilerGeneratedAttribute]
public bool get_LogToStdout();
    [CompilerGeneratedAttribute]
public void set_LogToStdout(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatSql();
    [CompilerGeneratedAttribute]
public void set_FormatSql(bool value);
    public bool get_IsDebugEnabled();
    public virtual void LogCommand(string message, DbCommand command, FormatStyle style);
    public virtual void LogCommand(DbCommand command, FormatStyle style);
    public string GetCommandLineWithParameters(DbCommand command);
    private static string GetParameterLoggableType(DbParameter dataParameter);
    public string GetParameterLoggableValue(DbParameter parameter);
    private static string GetBufferAsHexString(Byte[] buffer);
    private static bool IsStringType(DbType dbType);
    public FormatStyle DetermineActualStyle(FormatStyle style);
    public void LogBatchCommand(string batchCommand);
    private string TruncateWithEllipsis(string source, int length);
}
public class NHibernate.AssertionFailure : Exception {
    private static string DefaultMessage;
    public AssertionFailure(string message);
    public AssertionFailure(string message, Exception innerException);
    protected AssertionFailure(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.Bytecode.AbstractBytecodeProvider : object {
    protected Type proxyFactoryFactory;
    private ICollectionTypeFactory collectionTypeFactory;
    private Type collectionTypeFactoryClass;
    public IProxyFactoryFactory ProxyFactoryFactory { get; }
    [ObsoleteAttribute("Please use NHibernate.Cfg.Environment.ObjectsFactory instead")]
public IObjectsFactory ObjectsFactory { get; }
    public ICollectionTypeFactory CollectionTypeFactory { get; }
    public virtual IProxyFactoryFactory get_ProxyFactoryFactory();
    public abstract virtual IReflectionOptimizer GetReflectionOptimizer(Type clazz, IGetter[] getters, ISetter[] setters);
    public virtual IObjectsFactory get_ObjectsFactory();
    public virtual ICollectionTypeFactory get_CollectionTypeFactory();
    public virtual void SetProxyFactoryFactory(string typeName);
    public sealed virtual void SetCollectionTypeFactoryClass(string typeAssemblyQualifiedName);
    public sealed virtual void SetCollectionTypeFactoryClass(Type type);
}
[ExtensionAttribute]
public static class NHibernate.Bytecode.AccessOptimizerExtensions : object {
    [ExtensionAttribute]
public static object GetPropertyValue(IAccessOptimizer optimizer, object target, int i);
    [ExtensionAttribute]
public static void SetPropertyValue(IAccessOptimizer optimizer, object target, int i, object value);
    [ExtensionAttribute]
internal static object GetSpecializedPropertyValue(IAccessOptimizer optimizer, object target);
    [ExtensionAttribute]
internal static void SetSpecializedPropertyValue(IAccessOptimizer optimizer, object target, object value);
}
public class NHibernate.Bytecode.ActivatorObjectsFactory : object {
    public sealed virtual object CreateInstance(Type type);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public sealed virtual object CreateInstance(Type type, bool nonPublic);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public sealed virtual object CreateInstance(Type type, Object[] ctorArgs);
}
[ExtensionAttribute]
public static class NHibernate.Bytecode.BytecodeProviderExtensions : object {
    [ExtensionAttribute]
public static IReflectionOptimizer GetReflectionOptimizer(IBytecodeProvider bytecodeProvider, Type clazz, IGetter[] getters, ISetter[] setters, IGetter specializedGetter, ISetter specializedSetter);
}
[ObsoleteAttribute("Use StaticProxyFactoryFactory instead")]
public class NHibernate.Bytecode.DefaultProxyFactoryFactory : object {
    public IProxyValidator ProxyValidator { get; }
    public sealed virtual IProxyFactory BuildProxyFactory();
    public sealed virtual IProxyValidator get_ProxyValidator();
    public sealed virtual bool IsInstrumented(Type entityClass);
    public sealed virtual bool IsProxy(object entity);
}
internal static class NHibernate.Bytecode.EmitUtil : object {
    private static Dictionary`2<Type, OpCode> typeToOpcode;
    private static EmitUtil();
    public static void EmitBoxIfNeeded(ILGenerator il, Type type);
    public static void PreparePropertyForSet(ILGenerator il, Type propertyType);
}
public class NHibernate.Bytecode.HibernateByteCodeException : HibernateException {
    public HibernateByteCodeException(string message);
    public HibernateByteCodeException(string message, Exception inner);
    protected HibernateByteCodeException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.Bytecode.HibernateObjectsFactoryException : HibernateException {
    public HibernateObjectsFactoryException(string message);
    public HibernateObjectsFactoryException(string message, Exception inner);
    protected HibernateObjectsFactoryException(SerializationInfo info, StreamingContext context);
}
public interface NHibernate.Bytecode.IAccessOptimizer {
    public abstract virtual Object[] GetPropertyValues(object target);
    public abstract virtual void SetPropertyValues(object target, Object[] values);
}
public interface NHibernate.Bytecode.IBytecodeEnhancementMetadata {
    public string EntityName { get; }
    public bool EnhancedForLazyLoading { get; }
    public LazyPropertiesMetadata LazyPropertiesMetadata { get; }
    public UnwrapProxyPropertiesMetadata UnwrapProxyPropertiesMetadata { get; }
    public abstract virtual string get_EntityName();
    public abstract virtual bool get_EnhancedForLazyLoading();
    public abstract virtual LazyPropertiesMetadata get_LazyPropertiesMetadata();
    public abstract virtual UnwrapProxyPropertiesMetadata get_UnwrapProxyPropertiesMetadata();
    public abstract virtual IFieldInterceptor InjectInterceptor(object entity, ISessionImplementor session);
    public abstract virtual IFieldInterceptor ExtractInterceptor(object entity);
    public abstract virtual ISet`1<string> GetUninitializedLazyProperties(object entity);
    public abstract virtual ISet`1<string> GetUninitializedLazyProperties(Object[] entityState);
    public abstract virtual bool HasAnyUninitializedLazyProperties(object entity);
}
public interface NHibernate.Bytecode.IBytecodeProvider {
    public IProxyFactoryFactory ProxyFactoryFactory { get; }
    [ObsoleteAttribute("Please use NHibernate.Cfg.Environment.ObjectsFactory instead")]
public IObjectsFactory ObjectsFactory { get; }
    public ICollectionTypeFactory CollectionTypeFactory { get; }
    public abstract virtual IProxyFactoryFactory get_ProxyFactoryFactory();
    [ObsoleteAttribute("Please use NHibernate.Bytecode.BytecodeProviderExtensions.GetReflectionOptimizer instead")]
public abstract virtual IReflectionOptimizer GetReflectionOptimizer(Type clazz, IGetter[] getters, ISetter[] setters);
    public abstract virtual IObjectsFactory get_ObjectsFactory();
    public abstract virtual ICollectionTypeFactory get_CollectionTypeFactory();
}
public interface NHibernate.Bytecode.ICollectionTypeFactory {
    public abstract virtual CollectionType Array(string role, string propertyRef, Type elementClass);
    public abstract virtual CollectionType Bag(string role, string propertyRef);
    public abstract virtual CollectionType List(string role, string propertyRef);
    public abstract virtual CollectionType IdBag(string role, string propertyRef);
    public abstract virtual CollectionType Set(string role, string propertyRef);
    public abstract virtual CollectionType SortedSet(string role, string propertyRef, IComparer`1<T> comparer);
    public abstract virtual CollectionType OrderedSet(string role, string propertyRef);
    public abstract virtual CollectionType Map(string role, string propertyRef);
    public abstract virtual CollectionType SortedDictionary(string role, string propertyRef, IComparer`1<TKey> comparer);
    public abstract virtual CollectionType SortedList(string role, string propertyRef, IComparer`1<TKey> comparer);
}
public interface NHibernate.Bytecode.IInjectableCollectionTypeFactoryClass {
    public abstract virtual void SetCollectionTypeFactoryClass(string typeAssemblyQualifiedName);
    public abstract virtual void SetCollectionTypeFactoryClass(Type type);
}
public interface NHibernate.Bytecode.IInjectableProxyFactoryFactory {
    public abstract virtual void SetProxyFactoryFactory(string typeName);
}
public interface NHibernate.Bytecode.IInstantiationOptimizer {
    public abstract virtual object CreateInstance();
}
public interface NHibernate.Bytecode.IObjectsFactory {
    public abstract virtual object CreateInstance(Type type);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public abstract virtual object CreateInstance(Type type, bool nonPublic);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public abstract virtual object CreateInstance(Type type, Object[] ctorArgs);
}
public interface NHibernate.Bytecode.IProxyFactoryFactory {
    public IProxyValidator ProxyValidator { get; }
    public abstract virtual IProxyFactory BuildProxyFactory();
    public abstract virtual IProxyValidator get_ProxyValidator();
    public abstract virtual bool IsInstrumented(Type entityClass);
    public abstract virtual bool IsProxy(object entity);
}
public interface NHibernate.Bytecode.IReflectionOptimizer {
    public IAccessOptimizer AccessOptimizer { get; }
    public IInstantiationOptimizer InstantiationOptimizer { get; }
    public abstract virtual IAccessOptimizer get_AccessOptimizer();
    public abstract virtual IInstantiationOptimizer get_InstantiationOptimizer();
}
public class NHibernate.Bytecode.LazyPropertiesMetadata : object {
    private IDictionary`2<string, LazyPropertyDescriptor> _lazyPropertyDescriptors;
    private IDictionary`2<string, ISet`1<string>> _fetchGroups;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLazyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <LazyPropertyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <FetchGroupNames>k__BackingField;
    public string EntityName { get; }
    public bool HasLazyProperties { get; }
    public ISet`1<string> LazyPropertyNames { get; }
    public ISet`1<string> FetchGroupNames { get; }
    public IEnumerable`1<LazyPropertyDescriptor> LazyPropertyDescriptors { get; }
    public LazyPropertiesMetadata(string entityName, IDictionary`2<string, LazyPropertyDescriptor> lazyPropertyDescriptors, IDictionary`2<string, ISet`1<string>> fetchGroups);
    public static LazyPropertiesMetadata NonEnhanced(string entityName);
    public static LazyPropertiesMetadata From(string entityName, IEnumerable`1<LazyPropertyDescriptor> lazyPropertyDescriptors);
    [CompilerGeneratedAttribute]
public string get_EntityName();
    [CompilerGeneratedAttribute]
public bool get_HasLazyProperties();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_LazyPropertyNames();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_FetchGroupNames();
    public IEnumerable`1<LazyPropertyDescriptor> get_LazyPropertyDescriptors();
    public LazyPropertyDescriptor GetLazyPropertyDescriptor(string propertyName);
    public string GetFetchGroupName(string propertyName);
    public ISet`1<string> GetPropertiesInFetchGroup(string groupName);
    [IteratorStateMachineAttribute("NHibernate.Bytecode.LazyPropertiesMetadata/<GetFetchGroupPropertyDescriptors>d__22")]
public IEnumerable`1<LazyPropertyDescriptor> GetFetchGroupPropertyDescriptors(string groupName);
}
public class NHibernate.Bytecode.LazyPropertyDescriptor : object {
    [CompilerGeneratedAttribute]
private int <PropertyIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LazyIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FetchGroupName>k__BackingField;
    public int PropertyIndex { get; }
    public int LazyIndex { get; }
    public string Name { get; }
    public IType Type { get; }
    public string FetchGroupName { get; }
    private LazyPropertyDescriptor(int propertyIndex, int lazyIndex, string name, IType type, string fetchGroupName);
    public static LazyPropertyDescriptor From(Property property, int propertyIndex, int lazyIndex);
    [CompilerGeneratedAttribute]
public int get_PropertyIndex();
    [CompilerGeneratedAttribute]
public int get_LazyIndex();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public string get_FetchGroupName();
}
public class NHibernate.Bytecode.Lightweight.AccessOptimizer : object {
    private GetPropertyValuesInvoker getDelegate;
    private SetPropertyValuesInvoker setDelegate;
    private GetterCallback getterCallback;
    private SetterCallback setterCallback;
    private GetPropertyValueInvoker[] _getters;
    private SetPropertyValueInvoker[] _setters;
    private GetPropertyValueInvoker _specializedGetter;
    private SetPropertyValueInvoker _specializedSetter;
    [ObsoleteAttribute("This constructor has no usages and will be removed in a future version")]
public AccessOptimizer(GetPropertyValuesInvoker getDelegate, SetPropertyValuesInvoker setDelegate, IGetter[] getters, ISetter[] setters);
    public AccessOptimizer(GetPropertyValuesInvoker getDelegate, SetPropertyValuesInvoker setDelegate, GetPropertyValueInvoker[] getters, SetPropertyValueInvoker[] setters, GetPropertyValueInvoker specializedGetter, SetPropertyValueInvoker specializedSetter);
    public sealed virtual Object[] GetPropertyValues(object target);
    public sealed virtual void SetPropertyValues(object target, Object[] values);
    public void SetPropertyValue(object target, int i, object value);
    public object GetPropertyValue(object target, int i);
    internal void SetSpecializedPropertyValue(object target, object value);
    internal object GetSpecializedPropertyValue(object target);
}
public class NHibernate.Bytecode.Lightweight.BytecodeProviderImpl : AbstractBytecodeProvider {
    public virtual IReflectionOptimizer GetReflectionOptimizer(Type mappedClass, IGetter[] getters, ISetter[] setters);
    internal IReflectionOptimizer GetReflectionOptimizer(Type mappedClass, IGetter[] getters, ISetter[] setters, IGetter specializedGetter, ISetter specializedSetter);
}
public class NHibernate.Bytecode.Lightweight.CreateInstanceInvoker : MulticastDelegate {
    public CreateInstanceInvoker(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class NHibernate.Bytecode.Lightweight.GetPropertyValueInvoker : MulticastDelegate {
    public GetPropertyValueInvoker(object object, IntPtr method);
    public virtual object Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class NHibernate.Bytecode.Lightweight.GetPropertyValuesInvoker : MulticastDelegate {
    public GetPropertyValuesInvoker(object object, IntPtr method);
    public virtual Object[] Invoke(object obj, GetterCallback callback);
    public virtual IAsyncResult BeginInvoke(object obj, GetterCallback callback, AsyncCallback __callback, object object);
    public virtual Object[] EndInvoke(IAsyncResult result);
}
public class NHibernate.Bytecode.Lightweight.GetterCallback : MulticastDelegate {
    public GetterCallback(object object, IntPtr method);
    public virtual object Invoke(object obj, int index);
    public virtual IAsyncResult BeginInvoke(object obj, int index, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class NHibernate.Bytecode.Lightweight.ReflectionOptimizer : object {
    private IAccessOptimizer accessOptimizer;
    private CreateInstanceInvoker createInstanceMethod;
    protected Type mappedType;
    private Type typeOfThis;
    private static MethodInfo GetterCallbackInvoke;
    private static MethodInfo SetterCallbackInvoke;
    public IAccessOptimizer AccessOptimizer { get; }
    public IInstantiationOptimizer InstantiationOptimizer { get; }
    [ObsoleteAttribute("This constructor has no usages and will be removed in a future version")]
public ReflectionOptimizer(Type mappedType, IGetter[] getters, ISetter[] setters);
    public ReflectionOptimizer(Type mappedType, IGetter[] getters, ISetter[] setters, IGetter specializedGetter, ISetter specializedSetter);
    private static ReflectionOptimizer();
    public sealed virtual IAccessOptimizer get_AccessOptimizer();
    public sealed virtual IInstantiationOptimizer get_InstantiationOptimizer();
    public virtual object CreateInstance();
    protected virtual CreateInstanceInvoker CreateCreateInstanceMethod(Type type);
    protected virtual void ThrowExceptionForNoDefaultCtor(Type type);
    protected DynamicMethod CreateDynamicMethod(Type returnType, Type[] argumentTypes);
    private static bool CanSkipVisibilityChecks();
    private static void EmitCastToReference(ILGenerator il, Type type);
    private GetPropertyValueInvoker GenerateGetPropertyValueMethod(IGetter getter);
    private SetPropertyValueInvoker GenerateSetPropertyValueMethod(ISetter setter);
    private GetPropertyValuesInvoker GenerateGetPropertyValuesMethod(IGetter[] getters);
    private SetPropertyValuesInvoker GenerateSetPropertyValuesMethod(ISetter[] setters);
}
public class NHibernate.Bytecode.Lightweight.SetPropertyValueInvoker : MulticastDelegate {
    public SetPropertyValueInvoker(object object, IntPtr method);
    public virtual void Invoke(object obj, object value);
    public virtual IAsyncResult BeginInvoke(object obj, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Bytecode.Lightweight.SetPropertyValuesInvoker : MulticastDelegate {
    public SetPropertyValuesInvoker(object object, IntPtr method);
    public virtual void Invoke(object obj, Object[] values, SetterCallback callback);
    public virtual IAsyncResult BeginInvoke(object obj, Object[] values, SetterCallback callback, AsyncCallback __callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Bytecode.Lightweight.SetterCallback : MulticastDelegate {
    public SetterCallback(object object, IntPtr method);
    public virtual void Invoke(object obj, int index, object value);
    public virtual IAsyncResult BeginInvoke(object obj, int index, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Bytecode.NotInstrumentedException : HibernateException {
    public NotInstrumentedException(string message);
    protected NotInstrumentedException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.Bytecode.NullBytecodeProvider : AbstractBytecodeProvider {
    public virtual IReflectionOptimizer GetReflectionOptimizer(Type clazz, IGetter[] getters, ISetter[] setters);
}
public class NHibernate.Bytecode.StaticProxyFactoryFactory : object {
    internal static StaticProxyFactoryFactory Instance;
    public IProxyValidator ProxyValidator { get; }
    private static StaticProxyFactoryFactory();
    public sealed virtual IProxyFactory BuildProxyFactory();
    public sealed virtual IProxyValidator get_ProxyValidator();
    public sealed virtual bool IsInstrumented(Type entityClass);
    public sealed virtual bool IsProxy(object entity);
}
public class NHibernate.Bytecode.UnableToLoadProxyFactoryFactoryException : HibernateByteCodeException {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; }
    public string Message { get; }
    public UnableToLoadProxyFactoryFactoryException(string typeName, Exception inner);
    protected UnableToLoadProxyFactoryFactoryException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    public virtual string get_Message();
}
public class NHibernate.Bytecode.UnwrapProxyPropertiesMetadata : object {
    private IDictionary`2<string, UnwrapProxyPropertyDescriptor> _unwrapProxyPropertyDescriptors;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnwrapProxyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <UnwrapProxyPropertyNames>k__BackingField;
    public string EntityName { get; }
    public bool HasUnwrapProxyProperties { get; }
    public ISet`1<string> UnwrapProxyPropertyNames { get; }
    public IEnumerable`1<UnwrapProxyPropertyDescriptor> UnwrapProxyPropertyDescriptors { get; }
    public UnwrapProxyPropertiesMetadata(string entityName, IDictionary`2<string, UnwrapProxyPropertyDescriptor> unwrapProxyPropertyDescriptors);
    public static UnwrapProxyPropertiesMetadata NonEnhanced(string entityName);
    public static UnwrapProxyPropertiesMetadata From(string entityName, IEnumerable`1<UnwrapProxyPropertyDescriptor> unwrapProxyPropertyDescriptors);
    [CompilerGeneratedAttribute]
public string get_EntityName();
    [CompilerGeneratedAttribute]
public bool get_HasUnwrapProxyProperties();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_UnwrapProxyPropertyNames();
    public IEnumerable`1<UnwrapProxyPropertyDescriptor> get_UnwrapProxyPropertyDescriptors();
    public int GetUnwrapProxyPropertyIndex(string propertyName);
}
public class NHibernate.Bytecode.UnwrapProxyPropertyDescriptor : object {
    [CompilerGeneratedAttribute]
private int <PropertyIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public int PropertyIndex { get; }
    public string Name { get; }
    public IType Type { get; }
    private UnwrapProxyPropertyDescriptor(int propertyIndex, string name, IType type);
    public static UnwrapProxyPropertyDescriptor From(Property property, int propertyIndex);
    [CompilerGeneratedAttribute]
public int get_PropertyIndex();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IType get_Type();
}
internal abstract class NHibernate.Cache.AbstractCacheBatch : object {
    [CompilerGeneratedAttribute]
private ISessionImplementor <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private ICacheConcurrencyStrategy <CacheConcurrencyStrategy>k__BackingField;
    protected ISessionImplementor Session { get; }
    public ICacheConcurrencyStrategy CacheConcurrencyStrategy { get; }
    public int BatchSize { get; }
    public AbstractCacheBatch(ISessionImplementor session, ICacheConcurrencyStrategy cacheConcurrencyStrategy);
    public abstract virtual Task ExecuteAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
protected ISessionImplementor get_Session();
    [CompilerGeneratedAttribute]
public ICacheConcurrencyStrategy get_CacheConcurrencyStrategy();
    public abstract virtual int get_BatchSize();
    public abstract virtual void Execute();
}
internal abstract class NHibernate.Cache.AbstractCacheBatch`1 : AbstractCacheBatch {
    private List`1<TData> _batch;
    public int BatchSize { get; }
    public AbstractCacheBatch`1(ISessionImplementor session, ICacheConcurrencyStrategy cacheConcurrencyStrategy);
    public sealed virtual Task ExecuteAsync(CancellationToken cancellationToken);
    protected abstract virtual Task ExecuteAsync(TData[] data, CancellationToken cancellationToken);
    public void Add(TData data);
    public virtual int get_BatchSize();
    public sealed virtual void Execute();
    protected abstract virtual void Execute(TData[] data);
}
public interface NHibernate.Cache.Access.ISoftLock {
}
internal class NHibernate.Cache.AsyncCacheReadWriteLockFactory : object {
    public sealed virtual ICacheLock Create();
}
public abstract class NHibernate.Cache.CacheBase : object {
    public int Timeout { get; }
    public string RegionName { get; }
    public bool PreferMultipleGet { get; }
    public virtual Task`1<Object[]> GetManyAsync(Object[] keys, CancellationToken cancellationToken);
    public virtual Task PutManyAsync(Object[] keys, Object[] values, CancellationToken cancellationToken);
    public virtual Task`1<object> LockManyAsync(Object[] keys, CancellationToken cancellationToken);
    public virtual Task UnlockManyAsync(Object[] keys, object lockValue, CancellationToken cancellationToken);
    private sealed virtual override Task NHibernate.Cache.ICache.UnlockAsync(object key, CancellationToken cancellationToken);
    public abstract virtual int get_Timeout();
    public abstract virtual string get_RegionName();
    public virtual bool get_PreferMultipleGet();
    public abstract virtual object Get(object key);
    public abstract virtual void Put(object key, object value);
    public abstract virtual void Remove(object key);
    public abstract virtual void Clear();
    public abstract virtual void Destroy();
    public abstract virtual object Lock(object key);
    public abstract virtual void Unlock(object key, object lockValue);
    public abstract virtual long NextTimestamp();
    public virtual Object[] GetMany(Object[] keys);
    public virtual void PutMany(Object[] keys, Object[] values);
    public virtual object LockMany(Object[] keys);
    public virtual void UnlockMany(Object[] keys, object lockValue);
    public virtual Task`1<object> GetAsync(object key, CancellationToken cancellationToken);
    public virtual Task PutAsync(object key, object value, CancellationToken cancellationToken);
    public virtual Task RemoveAsync(object key, CancellationToken cancellationToken);
    public virtual Task ClearAsync(CancellationToken cancellationToken);
    public virtual Task`1<object> LockAsync(object key, CancellationToken cancellationToken);
    public virtual Task UnlockAsync(object key, object lockValue, CancellationToken cancellationToken);
    private sealed virtual override void NHibernate.Cache.ICache.Lock(object key);
    private sealed virtual override void NHibernate.Cache.ICache.Unlock(object key);
    private sealed virtual override Task NHibernate.Cache.ICache.LockAsync(object key, CancellationToken cancellationToken);
}
public class NHibernate.Cache.CacheBatcher : object {
    private Dictionary`2<ICacheConcurrencyStrategy, CachePutBatch> _putBatches;
    private ISessionImplementor _session;
    private static INHibernateLogger Log;
    internal CacheBatcher(ISessionImplementor session);
    private static CacheBatcher();
    [AsyncStateMachineAttribute("NHibernate.Cache.CacheBatcher/<ExecuteBatchAsync>d__0")]
internal Task ExecuteBatchAsync(CancellationToken cancellationToken);
    internal void AddToBatch(IEntityPersister persister, CachePutData data);
    internal void AddToBatch(ICollectionPersister persister, CachePutData data);
    private void AddToBatch(ICacheConcurrencyStrategy cache, CachePutData data);
    internal void ExecuteBatch();
    internal void Cleanup();
}
[ExtensionAttribute]
internal static class NHibernate.Cache.CacheConcurrencyStrategyExtensions : object {
    [ExtensionAttribute]
public static Task`1<Object[]> GetManyAsync(ICacheConcurrencyStrategy cache, CacheKey[] keys, long timestamp, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.CacheConcurrencyStrategyExtensions/<PutManyAsync>d__1")]
[ExtensionAttribute]
public static Task`1<Boolean[]> PutManyAsync(ICacheConcurrencyStrategy cache, CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Object[] GetMany(ICacheConcurrencyStrategy cache, CacheKey[] keys, long timestamp);
    [ExtensionAttribute]
public static Boolean[] PutMany(ICacheConcurrencyStrategy cache, CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts);
    [ExtensionAttribute]
internal static bool PreferMultipleGet(ICacheConcurrencyStrategy cache);
    [ExtensionAttribute]
internal static CacheBase GetCacheBase(ICacheConcurrencyStrategy cache);
}
[DataContractAttribute]
public class NHibernate.Cache.CachedItem : object {
    private long freshTimestamp;
    private object value;
    private object version;
    [DataMemberAttribute]
public long FreshTimestamp { get; public set; }
    [DataMemberAttribute]
public object Value { get; public set; }
    [DataMemberAttribute]
public object Version { get; public set; }
    public bool IsLock { get; }
    [ObsoleteAttribute("Use object initializer instead.")]
public CachedItem(object value, long currentTimestamp, object version);
    internal static CachedItem Create(object value, long currentTimestamp, object version);
    public long get_FreshTimestamp();
    public void set_FreshTimestamp(long value);
    public object get_Value();
    public void set_Value(object value);
    public object get_Version();
    public void set_Version(object value);
    public sealed virtual CacheLock Lock(long timeout, int id);
    public sealed virtual bool get_IsLock();
    public sealed virtual bool IsGettable(long txTimestamp);
    public sealed virtual bool IsPuttable(long txTimestamp, object newVersion, IComparer comparator, bool minimalPut);
    public sealed virtual bool IsPuttable(long txTimestamp, object newVersion, IComparer comparator);
    public virtual string ToString();
}
public class NHibernate.Cache.CacheException : HibernateException {
    public CacheException(string message);
    public CacheException(Exception innerException);
    public CacheException(string message, Exception innerException);
    protected CacheException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class NHibernate.Cache.CacheExtensions : object {
    [ExtensionAttribute]
public static CacheBase AsCacheBase(ICache cache);
}
public static class NHibernate.Cache.CacheFactory : object {
    private static INHibernateLogger log;
    public static string ReadOnly;
    public static string ReadWrite;
    public static string NonstrictReadWrite;
    public static string Transactional;
    public static string Never;
    private static CacheFactory();
    [ObsoleteAttribute("Please use overload with a CacheBase parameter.")]
public static ICacheConcurrencyStrategy CreateCache(string usage, string name, bool mutable, Settings settings, IDictionary`2<string, string> properties);
    public static ICacheConcurrencyStrategy CreateCache(string usage, CacheBase cache);
    public static ICacheConcurrencyStrategy CreateCache(string usage, CacheBase cache, Settings settings);
    internal static CacheBase BuildCacheBase(string name, Settings settings, IDictionary`2<string, string> properties);
}
public class NHibernate.Cache.CacheKey : object {
    private object key;
    private IType type;
    private string entityOrRoleName;
    private Nullable`1<int> _hashCode;
    private ISessionFactoryImplementor _factory;
    private string _tenantIdentifier;
    public object Key { get; }
    public string EntityOrRoleName { get; }
    public CacheKey(object id, IType type, string entityOrRoleName, ISessionFactoryImplementor factory, string tenantIdentifier);
    [ObsoleteAttribute("Use constructor with tenantIdentifier")]
public CacheKey(object id, IType type, string entityOrRoleName, ISessionFactoryImplementor factory);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void OnDeserialization(object sender);
    private int GenerateHashCode();
    public object get_Key();
    public string get_EntityOrRoleName();
}
[DataContractAttribute]
public class NHibernate.Cache.CacheLock : object {
    private long unlockTimestamp;
    private int multiplicity;
    private bool concurrentLock;
    private long timeout;
    private int id;
    private object version;
    [DataMemberAttribute]
public bool WasLockedConcurrently { get; public set; }
    public bool IsLock { get; }
    [DataMemberAttribute]
public int Id { get; public set; }
    [DataMemberAttribute]
public object Version { get; public set; }
    [DataMemberAttribute]
public long UnlockTimestamp { get; public set; }
    [DataMemberAttribute]
public int Multiplicity { get; public set; }
    [DataMemberAttribute]
public long Timeout { get; public set; }
    [ObsoleteAttribute("Use object initializer instead.")]
public CacheLock(long timeout, int id, object version);
    internal static CacheLock Create(long timeout, int id, object version);
    public sealed virtual CacheLock Lock(long timeout, int id);
    public void Unlock(long currentTimestamp);
    public sealed virtual bool IsPuttable(long txTimestamp, object newVersion, IComparer comparator, bool minimalPut);
    public sealed virtual bool IsPuttable(long txTimestamp, object newVersion, IComparer comparator);
    public bool get_WasLockedConcurrently();
    public void set_WasLockedConcurrently(bool value);
    public sealed virtual bool get_IsLock();
    public sealed virtual bool IsGettable(long txTimestamp);
    public int get_Id();
    public void set_Id(int value);
    public object get_Version();
    public void set_Version(object value);
    public long get_UnlockTimestamp();
    public void set_UnlockTimestamp(long value);
    public int get_Multiplicity();
    public void set_Multiplicity(int value);
    public long get_Timeout();
    public void set_Timeout(long value);
    public virtual string ToString();
}
internal class NHibernate.Cache.CachePutBatch : AbstractCacheBatch`1<CachePutData> {
    public CachePutBatch(ISessionImplementor session, ICacheConcurrencyStrategy cacheConcurrencyStrategy);
    [AsyncStateMachineAttribute("NHibernate.Cache.CachePutBatch/<ExecuteAsync>d__0")]
protected virtual Task ExecuteAsync(CachePutData[] data, CancellationToken cancellationToken);
    protected virtual void Execute(CachePutData[] data);
}
public class NHibernate.Cache.CachePutData : object {
    [CompilerGeneratedAttribute]
private CacheKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer <VersionComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MinimalPut>k__BackingField;
    public CacheKey Key { get; }
    public object Value { get; }
    public object Version { get; }
    public IComparer VersionComparer { get; }
    public bool MinimalPut { get; }
    public CachePutData(CacheKey key, object value, object version, IComparer versionComparer, bool minimalPut);
    [CompilerGeneratedAttribute]
public CacheKey get_Key();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public object get_Version();
    [CompilerGeneratedAttribute]
public IComparer get_VersionComparer();
    [CompilerGeneratedAttribute]
public bool get_MinimalPut();
}
[DataContractAttribute]
public class NHibernate.Cache.Entry.CacheEntry : object {
    private Object[] disassembledState;
    private string subclass;
    private bool lazyPropertiesAreUnfetched;
    private object version;
    [DataMemberAttribute]
public object Version { get; public set; }
    [DataMemberAttribute]
public string Subclass { get; public set; }
    [DataMemberAttribute]
[ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public bool AreLazyPropertiesUnfetched { get; public set; }
    [DataMemberAttribute]
public Object[] DisassembledState { get; public set; }
    [ObsoleteAttribute("Please use CacheEntry.Create method instead.")]
public CacheEntry(Object[] state, IEntityPersister persister, bool unfetched, object version, ISessionImplementor session, object owner);
    [AsyncStateMachineAttribute("NHibernate.Cache.Entry.CacheEntry/<CreateAsync>d__0")]
[ObsoleteAttribute("Use the overload without unfetched parameter instead.")]
public static Task`1<CacheEntry> CreateAsync(Object[] state, IEntityPersister persister, bool unfetched, object version, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.Entry.CacheEntry/<CreateAsync>d__1")]
public static Task`1<CacheEntry> CreateAsync(Object[] state, IEntityPersister persister, object version, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public Task`1<Object[]> AssembleAsync(object instance, object id, IEntityPersister persister, IInterceptor interceptor, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.Entry.CacheEntry/<AssembleAsync>d__3")]
private static Task`1<Object[]> AssembleAsync(Object[] values, object result, object id, IEntityPersister persister, IInterceptor interceptor, ISessionImplementor session, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use the overload without unfetched parameter instead.")]
public static CacheEntry Create(Object[] state, IEntityPersister persister, bool unfetched, object version, ISessionImplementor session, object owner);
    public static CacheEntry Create(Object[] state, IEntityPersister persister, object version, ISessionImplementor session, object owner);
    public object get_Version();
    public void set_Version(object value);
    public string get_Subclass();
    public void set_Subclass(string value);
    public bool get_AreLazyPropertiesUnfetched();
    public void set_AreLazyPropertiesUnfetched(bool value);
    public Object[] get_DisassembledState();
    public void set_DisassembledState(Object[] value);
    public Object[] Assemble(object instance, object id, IEntityPersister persister, IInterceptor interceptor, ISessionImplementor session);
    private static Object[] Assemble(Object[] values, object result, object id, IEntityPersister persister, IInterceptor interceptor, ISessionImplementor session);
}
[DataContractAttribute]
public class NHibernate.Cache.Entry.CollectionCacheEntry : object {
    private object state;
    [DataMemberAttribute]
public Object[] State { get; public set; }
    [ObsoleteAttribute("Use CollectionCacheEntry.Create method instead.")]
public CollectionCacheEntry(IPersistentCollection collection, ICollectionPersister persister);
    [AsyncStateMachineAttribute("NHibernate.Cache.Entry.CollectionCacheEntry/<CreateAsync>d__0")]
public static Task`1<CollectionCacheEntry> CreateAsync(IPersistentCollection collection, ICollectionPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.Entry.CollectionCacheEntry/<AssembleAsync>d__1")]
public virtual Task AssembleAsync(IPersistentCollection collection, ICollectionPersister persister, object owner, CancellationToken cancellationToken);
    public static CollectionCacheEntry Create(IPersistentCollection collection, ICollectionPersister persister);
    public virtual Object[] get_State();
    public virtual void set_State(Object[] value);
    public virtual void Assemble(IPersistentCollection collection, ICollectionPersister persister, object owner);
    public virtual string ToString();
}
public interface NHibernate.Cache.Entry.ICacheEntryStructure {
    public abstract virtual object Structure(object item);
    public abstract virtual object Destructure(object map, ISessionFactoryImplementor factory);
}
public class NHibernate.Cache.Entry.StructuredCacheEntry : object {
    private IEntityPersister persister;
    public StructuredCacheEntry(IEntityPersister persister);
    public sealed virtual object Destructure(object item, ISessionFactoryImplementor factory);
    public sealed virtual object Structure(object item);
}
public class NHibernate.Cache.Entry.StructuredCollectionCacheEntry : object {
    public virtual object Structure(object item);
    public virtual object Destructure(object item, ISessionFactoryImplementor factory);
}
public class NHibernate.Cache.Entry.StructuredMapCacheEntry : object {
    public sealed virtual object Structure(object item);
    public sealed virtual object Destructure(object item, ISessionFactoryImplementor factory);
}
public class NHibernate.Cache.Entry.UnstructuredCacheEntry : object {
    public sealed virtual object Structure(object item);
    public sealed virtual object Destructure(object map, ISessionFactoryImplementor factory);
}
public class NHibernate.Cache.FakeCache : CacheBase {
    [CompilerGeneratedAttribute]
private string <RegionName>k__BackingField;
    public bool PreferMultipleGet { get; }
    public int Timeout { get; }
    public string RegionName { get; }
    public FakeCache(string regionName);
    public virtual Task`1<object> GetAsync(object key, CancellationToken cancellationToken);
    public virtual Task PutAsync(object key, object value, CancellationToken cancellationToken);
    public virtual Task RemoveAsync(object key, CancellationToken cancellationToken);
    public virtual Task ClearAsync(CancellationToken cancellationToken);
    public virtual Task`1<object> LockAsync(object key, CancellationToken cancellationToken);
    public virtual Task UnlockAsync(object key, object lockValue, CancellationToken cancellationToken);
    public virtual bool get_PreferMultipleGet();
    public virtual object Get(object key);
    public virtual void Put(object key, object value);
    public virtual void Remove(object key);
    public virtual void Clear();
    public virtual void Destroy();
    public virtual object Lock(object key);
    public virtual void Unlock(object key, object lockValue);
    public virtual long NextTimestamp();
    public virtual int get_Timeout();
    [CompilerGeneratedAttribute]
public virtual string get_RegionName();
}
public class NHibernate.Cache.FilterKey : object {
    private string _filterName;
    private KeyValuePair`2[] _filterParameters;
    [ObsoleteAttribute("Use overload taking a FilterImpl")]
public FilterKey(string name, IEnumerable`1<KeyValuePair`2<string, object>> params, IDictionary`2<string, IType> types);
    public FilterKey(FilterImpl filter);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public virtual string ToString();
    public static ISet`1<FilterKey> CreateFilterKeys(IDictionary`2<string, IFilter> enabledFilters);
}
public class NHibernate.Cache.HashtableCache : CacheBase {
    private IDictionary hashtable;
    private string regionName;
    public int Timeout { get; }
    public string RegionName { get; }
    public bool PreferMultipleGet { get; }
    public HashtableCache(string regionName);
    public virtual Task`1<object> GetAsync(object key, CancellationToken cancellationToken);
    public virtual Task PutAsync(object key, object value, CancellationToken cancellationToken);
    public virtual Task RemoveAsync(object key, CancellationToken cancellationToken);
    public virtual Task ClearAsync(CancellationToken cancellationToken);
    public virtual Task`1<object> LockAsync(object key, CancellationToken cancellationToken);
    public virtual Task UnlockAsync(object key, object lockValue, CancellationToken cancellationToken);
    public virtual object Get(object key);
    public virtual void Put(object key, object value);
    public virtual void Remove(object key);
    public virtual void Clear();
    public virtual void Destroy();
    public virtual object Lock(object key);
    public virtual void Unlock(object key, object lockValue);
    public virtual long NextTimestamp();
    public virtual int get_Timeout();
    public virtual string get_RegionName();
    public virtual bool get_PreferMultipleGet();
}
public class NHibernate.Cache.HashtableCacheProvider : object {
    [ObsoleteAttribute]
private sealed virtual override ICache NHibernate.Cache.ICacheProvider.BuildCache(string regionName, IDictionary`2<string, string> properties);
    public CacheBase BuildCache(string regionName, IDictionary`2<string, string> properties);
    public sealed virtual long NextTimestamp();
    public sealed virtual void Start(IDictionary`2<string, string> properties);
    public sealed virtual void Stop();
}
public interface NHibernate.Cache.IBatchableCacheConcurrencyStrategy {
    public CacheBase Cache { get; public set; }
    public abstract virtual Task`1<Object[]> GetManyAsync(CacheKey[] keys, long timestamp, CancellationToken cancellationToken);
    public abstract virtual Task`1<Boolean[]> PutManyAsync(CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts, CancellationToken cancellationToken);
    public abstract virtual Object[] GetMany(CacheKey[] keys, long timestamp);
    public abstract virtual Boolean[] PutMany(CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts);
    public abstract virtual CacheBase get_Cache();
    public abstract virtual void set_Cache(CacheBase value);
}
public interface NHibernate.Cache.IBatchableQueryCache {
    public abstract virtual Task`1<IList> GetAsync(QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, ISet`1<string> spaces, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> PutAsync(QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, IList result, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList[]> GetManyAsync(QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, ISet`1[] spaces, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<Boolean[]> PutManyAsync(QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, IList[] results, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual IList Get(QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, ISet`1<string> spaces, ISessionImplementor session);
    public abstract virtual bool Put(QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, IList result, ISessionImplementor session);
    public abstract virtual IList[] GetMany(QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, ISet`1[] spaces, ISessionImplementor session);
    public abstract virtual Boolean[] PutMany(QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, IList[] results, ISessionImplementor session);
}
[ObsoleteAttribute("Derive from CacheBase instead. NHibernate members using this type will switch to CacheBase in a future version.")]
public interface NHibernate.Cache.ICache {
    public int Timeout { get; }
    public string RegionName { get; }
    public abstract virtual Task`1<object> GetAsync(object key, CancellationToken cancellationToken);
    public abstract virtual Task PutAsync(object key, object value, CancellationToken cancellationToken);
    public abstract virtual Task RemoveAsync(object key, CancellationToken cancellationToken);
    public abstract virtual Task ClearAsync(CancellationToken cancellationToken);
    public abstract virtual Task LockAsync(object key, CancellationToken cancellationToken);
    public abstract virtual Task UnlockAsync(object key, CancellationToken cancellationToken);
    public abstract virtual object Get(object key);
    public abstract virtual void Put(object key, object value);
    public abstract virtual void Remove(object key);
    public abstract virtual void Clear();
    public abstract virtual void Destroy();
    public abstract virtual void Lock(object key);
    public abstract virtual void Unlock(object key);
    public abstract virtual long NextTimestamp();
    public abstract virtual int get_Timeout();
    public abstract virtual string get_RegionName();
}
public interface NHibernate.Cache.ICacheConcurrencyStrategy {
    public string RegionName { get; }
    public ICache Cache { get; public set; }
    public abstract virtual Task`1<object> GetAsync(CacheKey key, long txTimestamp, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> PutAsync(CacheKey key, object value, long txTimestamp, object version, IComparer versionComparer, bool minimalPut, CancellationToken cancellationToken);
    public abstract virtual Task`1<ISoftLock> LockAsync(CacheKey key, object version, CancellationToken cancellationToken);
    public abstract virtual Task EvictAsync(CacheKey key, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> UpdateAsync(CacheKey key, object value, object currentVersion, object previousVersion, CancellationToken cancellationToken);
    public abstract virtual Task ReleaseAsync(CacheKey key, ISoftLock lock, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> AfterUpdateAsync(CacheKey key, object value, object version, ISoftLock lock, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> AfterInsertAsync(CacheKey key, object value, object version, CancellationToken cancellationToken);
    public abstract virtual Task RemoveAsync(CacheKey key, CancellationToken cancellationToken);
    public abstract virtual Task ClearAsync(CancellationToken cancellationToken);
    public abstract virtual object Get(CacheKey key, long txTimestamp);
    public abstract virtual bool Put(CacheKey key, object value, long txTimestamp, object version, IComparer versionComparer, bool minimalPut);
    public abstract virtual ISoftLock Lock(CacheKey key, object version);
    public abstract virtual void Evict(CacheKey key);
    public abstract virtual bool Update(CacheKey key, object value, object currentVersion, object previousVersion);
    public abstract virtual bool Insert(CacheKey key, object value, object currentVersion);
    public abstract virtual void Release(CacheKey key, ISoftLock lock);
    public abstract virtual bool AfterUpdate(CacheKey key, object value, object version, ISoftLock lock);
    public abstract virtual bool AfterInsert(CacheKey key, object value, object version);
    public abstract virtual void Remove(CacheKey key);
    public abstract virtual void Clear();
    public abstract virtual void Destroy();
    public abstract virtual string get_RegionName();
    public abstract virtual ICache get_Cache();
    public abstract virtual void set_Cache(ICache value);
}
public interface NHibernate.Cache.ICacheLock {
    public abstract virtual IDisposable ReadLock();
    public abstract virtual IDisposable WriteLock();
    public abstract virtual Task`1<IDisposable> ReadLockAsync();
    public abstract virtual Task`1<IDisposable> WriteLockAsync();
}
public interface NHibernate.Cache.ICacheProvider {
    public abstract virtual ICache BuildCache(string regionName, IDictionary`2<string, string> properties);
    public abstract virtual long NextTimestamp();
    public abstract virtual void Start(IDictionary`2<string, string> properties);
    public abstract virtual void Stop();
}
public interface NHibernate.Cache.ICacheReadWriteLockFactory {
    public abstract virtual ICacheLock Create();
}
public interface NHibernate.Cache.IOptimisticCacheSource {
    public bool IsVersioned { get; }
    public IComparer VersionComparator { get; }
    public abstract virtual bool get_IsVersioned();
    public abstract virtual IComparer get_VersionComparator();
}
public interface NHibernate.Cache.IQueryCache {
    public ICache Cache { get; }
    public string RegionName { get; }
    public abstract virtual Task ClearAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("Have the query cache implement IBatchableQueryCache, and use IBatchableQueryCache.Put")]
public abstract virtual Task`1<bool> PutAsync(QueryKey key, ICacheAssembler[] returnTypes, IList result, bool isNaturalKeyLookup, ISessionImplementor session, CancellationToken cancellationToken);
    [ObsoleteAttribute("Have the query cache implement IBatchableQueryCache, and use IBatchableQueryCache.Get")]
public abstract virtual Task`1<IList> GetAsync(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISet`1<string> spaces, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual ICache get_Cache();
    public abstract virtual string get_RegionName();
    public abstract virtual void Clear();
    [ObsoleteAttribute("Have the query cache implement IBatchableQueryCache, and use IBatchableQueryCache.Put")]
public abstract virtual bool Put(QueryKey key, ICacheAssembler[] returnTypes, IList result, bool isNaturalKeyLookup, ISessionImplementor session);
    [ObsoleteAttribute("Have the query cache implement IBatchableQueryCache, and use IBatchableQueryCache.Get")]
public abstract virtual IList Get(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISet`1<string> spaces, ISessionImplementor session);
    public abstract virtual void Destroy();
}
public interface NHibernate.Cache.IQueryCacheFactory {
    [ObsoleteAttribute("Please use extension overload with a CacheBase parameter.")]
public abstract virtual IQueryCache GetQueryCache(string regionName, UpdateTimestampsCache updateTimestampsCache, Settings settings, IDictionary`2<string, string> props);
}
[ExtensionAttribute]
public static class NHibernate.Cache.LocableExtension : object {
    [ExtensionAttribute]
internal static bool IsPuttable(ILockable lockable, long txTimestamp, object newVersion, IComparer comparator, bool minimalPut);
}
internal class NHibernate.Cache.NamedParameterComparer : object {
    public static NamedParameterComparer Instance;
    private static NamedParameterComparer();
    public sealed virtual bool Equals(KeyValuePair`2<string, TypedValue> x, KeyValuePair`2<string, TypedValue> y);
    public sealed virtual int GetHashCode(KeyValuePair`2<string, TypedValue> obj);
}
public class NHibernate.Cache.NoCacheProvider : object {
    private static INHibernateLogger log;
    public static string WarnMessage;
    private static NoCacheProvider();
    [ObsoleteAttribute]
private sealed virtual override ICache NHibernate.Cache.ICacheProvider.BuildCache(string regionName, IDictionary`2<string, string> properties);
    public CacheBase BuildCache(string regionName, IDictionary`2<string, string> properties);
    public sealed virtual long NextTimestamp();
    public sealed virtual void Start(IDictionary`2<string, string> properties);
    public sealed virtual void Stop();
}
public class NHibernate.Cache.NonstrictReadWriteCache : object {
    private static INHibernateLogger log;
    private CacheBase _cache;
    public string RegionName { get; }
    public ICache Cache { get; public set; }
    private CacheBase NHibernate.Cache.IBatchableCacheConcurrencyStrategy.Cache { get; private set; }
    private static NonstrictReadWriteCache();
    [AsyncStateMachineAttribute("NHibernate.Cache.NonstrictReadWriteCache/<GetAsync>d__0")]
public sealed virtual Task`1<object> GetAsync(CacheKey key, long txTimestamp, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.NonstrictReadWriteCache/<GetManyAsync>d__1")]
public sealed virtual Task`1<Object[]> GetManyAsync(CacheKey[] keys, long timestamp, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.NonstrictReadWriteCache/<PutManyAsync>d__2")]
public sealed virtual Task`1<Boolean[]> PutManyAsync(CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.NonstrictReadWriteCache/<PutAsync>d__3")]
public sealed virtual Task`1<bool> PutAsync(CacheKey key, object value, long txTimestamp, object version, IComparer versionComparator, bool minimalPut, CancellationToken cancellationToken);
    public sealed virtual Task`1<ISoftLock> LockAsync(CacheKey key, object version, CancellationToken cancellationToken);
    public sealed virtual Task RemoveAsync(CacheKey key, CancellationToken cancellationToken);
    public sealed virtual Task ClearAsync(CancellationToken cancellationToken);
    public sealed virtual Task EvictAsync(CacheKey key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.NonstrictReadWriteCache/<UpdateAsync>d__8")]
public sealed virtual Task`1<bool> UpdateAsync(CacheKey key, object value, object currentVersion, object previousVersion, CancellationToken cancellationToken);
    public sealed virtual Task ReleaseAsync(CacheKey key, ISoftLock lock, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.NonstrictReadWriteCache/<AfterUpdateAsync>d__10")]
public sealed virtual Task`1<bool> AfterUpdateAsync(CacheKey key, object value, object version, ISoftLock lock, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> AfterInsertAsync(CacheKey key, object value, object version, CancellationToken cancellationToken);
    public sealed virtual string get_RegionName();
    public sealed virtual ICache get_Cache();
    public sealed virtual void set_Cache(ICache value);
    private sealed virtual override CacheBase NHibernate.Cache.IBatchableCacheConcurrencyStrategy.get_Cache();
    private sealed virtual override void NHibernate.Cache.IBatchableCacheConcurrencyStrategy.set_Cache(CacheBase value);
    public sealed virtual object Get(CacheKey key, long txTimestamp);
    public sealed virtual Object[] GetMany(CacheKey[] keys, long timestamp);
    public sealed virtual Boolean[] PutMany(CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts);
    public sealed virtual bool Put(CacheKey key, object value, long txTimestamp, object version, IComparer versionComparator, bool minimalPut);
    public sealed virtual ISoftLock Lock(CacheKey key, object version);
    public sealed virtual void Remove(CacheKey key);
    public sealed virtual void Clear();
    public sealed virtual void Destroy();
    public sealed virtual void Evict(CacheKey key);
    public sealed virtual bool Update(CacheKey key, object value, object currentVersion, object previousVersion);
    public sealed virtual bool Insert(CacheKey key, object value, object currentVersion);
    public sealed virtual void Release(CacheKey key, ISoftLock lock);
    public sealed virtual bool AfterUpdate(CacheKey key, object value, object version, ISoftLock lock);
    public sealed virtual bool AfterInsert(CacheKey key, object value, object version);
}
internal class NHibernate.Cache.ObsoleteCacheWrapper : CacheBase {
    private ICache _cache;
    public int Timeout { get; }
    public string RegionName { get; }
    public bool PreferMultipleGet { get; }
    internal ObsoleteCacheWrapper(ICache cache);
    public virtual Task`1<object> GetAsync(object key, CancellationToken cancellationToken);
    public virtual Task PutAsync(object key, object value, CancellationToken cancellationToken);
    public virtual Task RemoveAsync(object key, CancellationToken cancellationToken);
    public virtual Task ClearAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ObsoleteCacheWrapper/<LockAsync>d__4")]
public virtual Task`1<object> LockAsync(object key, CancellationToken cancellationToken);
    public virtual Task UnlockAsync(object key, object lockValue, CancellationToken cancellationToken);
    public virtual long NextTimestamp();
    public virtual int get_Timeout();
    public virtual string get_RegionName();
    public virtual bool get_PreferMultipleGet();
    public virtual object Get(object key);
    public virtual void Put(object key, object value);
    public virtual void Remove(object key);
    public virtual void Clear();
    public virtual void Destroy();
    public virtual object Lock(object key);
    public virtual void Unlock(object key, object lockValue);
}
[ExtensionAttribute]
internal static class NHibernate.Cache.QueryCacheExtensions : object {
    private static INHibernateLogger Log;
    private static bool _hasWarnForObsoleteQueryCache;
    private static QueryCacheExtensions();
    [AsyncStateMachineAttribute("NHibernate.Cache.QueryCacheExtensions/<GetAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IList> GetAsync(IQueryCache queryCache, QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, ISet`1<string> spaces, ISessionImplementor session, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> PutAsync(IQueryCache queryCache, QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, IList result, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.QueryCacheExtensions/<GetManyAsync>d__2")]
[ExtensionAttribute]
public static Task`1<IList[]> GetManyAsync(IQueryCache queryCache, QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, ISet`1[] spaces, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.QueryCacheExtensions/<PutManyAsync>d__3")]
[ExtensionAttribute]
public static Task`1<Boolean[]> PutManyAsync(IQueryCache queryCache, QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, IList[] results, ISessionImplementor session, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList Get(IQueryCache queryCache, QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, ISet`1<string> spaces, ISessionImplementor session);
    [ExtensionAttribute]
public static bool Put(IQueryCache queryCache, QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, IList result, ISessionImplementor session);
    [ExtensionAttribute]
public static IList[] GetMany(IQueryCache queryCache, QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, ISet`1[] spaces, ISessionImplementor session);
    [ExtensionAttribute]
public static Boolean[] PutMany(IQueryCache queryCache, QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, IList[] results, ISessionImplementor session);
}
[ExtensionAttribute]
public static class NHibernate.Cache.QueryCacheFactoryExtension : object {
    private static INHibernateLogger Logger;
    private static QueryCacheFactoryExtension();
    [ExtensionAttribute]
public static IQueryCache GetQueryCache(IQueryCacheFactory factory, UpdateTimestampsCache updateTimestampsCache, IDictionary`2<string, string> props, CacheBase regionCache);
}
public class NHibernate.Cache.QueryCacheResultBuilder : object {
    private IType[] _resultTypes;
    private QueryCacheInfo _cacheInfo;
    [CompilerGeneratedAttribute]
private IList <Result>k__BackingField;
    internal IList Result { get; }
    internal QueryCacheResultBuilder(ILoader loader);
    [ObsoleteAttribute("Use overload taking an ILoader instead.")]
public static bool IsCacheWithFetches(Loader loader);
    public static bool IsCacheWithFetches(ILoader loader);
    [CompilerGeneratedAttribute]
internal IList get_Result();
    internal void AddRow(object result, Object[] entities, IPersistentCollection[] collections);
    internal IList GetResultList(IList cacheList);
}
public class NHibernate.Cache.QueryKey : object {
    private ISessionFactoryImplementor _factory;
    private SqlString _sqlQueryString;
    private IType[] _types;
    private Object[] _values;
    private int _firstRow;
    private int _maxRows;
    private string _tenantIdentifier;
    private KeyValuePair`2[] _namedParameters;
    private FilterKey[] _filters;
    private CacheableResultTransformer _customTransformer;
    private Nullable`1<int> _hashCode;
    private Int32[] _multiQueriesFirstRows;
    private Int32[] _multiQueriesMaxRows;
    public CacheableResultTransformer ResultTransformer { get; }
    public QueryKey(ISessionFactoryImplementor factory, SqlString queryString, QueryParameters queryParameters, ISet`1<FilterKey> filters, CacheableResultTransformer customTransformer, string tenantIdentifier);
    [ObsoleteAttribute("Please use overload with tenantIdentifier")]
public QueryKey(ISessionFactoryImplementor factory, SqlString queryString, QueryParameters queryParameters, ISet`1<FilterKey> filters, CacheableResultTransformer customTransformer);
    public CacheableResultTransformer get_ResultTransformer();
    public QueryKey SetFirstRows(Int32[] firstRows);
    public QueryKey SetMaxRows(Int32[] maxRows);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(QueryKey other);
    public virtual int GetHashCode();
    public sealed virtual void OnDeserialization(object sender);
    public int ComputeHashCode();
    public virtual string ToString();
}
public class NHibernate.Cache.ReadOnlyCache : object {
    private static INHibernateLogger log;
    private CacheBase _cache;
    public string RegionName { get; }
    public ICache Cache { get; public set; }
    private CacheBase NHibernate.Cache.IBatchableCacheConcurrencyStrategy.Cache { get; private set; }
    private static ReadOnlyCache();
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadOnlyCache/<GetAsync>d__0")]
public sealed virtual Task`1<object> GetAsync(CacheKey key, long timestamp, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadOnlyCache/<GetManyAsync>d__1")]
public sealed virtual Task`1<Object[]> GetManyAsync(CacheKey[] keys, long timestamp, CancellationToken cancellationToken);
    public sealed virtual Task`1<ISoftLock> LockAsync(CacheKey key, object version, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadOnlyCache/<PutManyAsync>d__3")]
public sealed virtual Task`1<Boolean[]> PutManyAsync(CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadOnlyCache/<PutAsync>d__4")]
public sealed virtual Task`1<bool> PutAsync(CacheKey key, object value, long timestamp, object version, IComparer versionComparator, bool minimalPut, CancellationToken cancellationToken);
    public sealed virtual Task ReleaseAsync(CacheKey key, ISoftLock lock, CancellationToken cancellationToken);
    public sealed virtual Task ClearAsync(CancellationToken cancellationToken);
    public sealed virtual Task RemoveAsync(CacheKey key, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> AfterUpdateAsync(CacheKey key, object value, object version, ISoftLock lock, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> AfterInsertAsync(CacheKey key, object value, object version, CancellationToken cancellationToken);
    public sealed virtual Task EvictAsync(CacheKey key, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> UpdateAsync(CacheKey key, object value, object currentVersion, object previousVersion, CancellationToken cancellationToken);
    public sealed virtual string get_RegionName();
    public sealed virtual ICache get_Cache();
    public sealed virtual void set_Cache(ICache value);
    private sealed virtual override CacheBase NHibernate.Cache.IBatchableCacheConcurrencyStrategy.get_Cache();
    private sealed virtual override void NHibernate.Cache.IBatchableCacheConcurrencyStrategy.set_Cache(CacheBase value);
    public sealed virtual object Get(CacheKey key, long timestamp);
    public sealed virtual Object[] GetMany(CacheKey[] keys, long timestamp);
    public sealed virtual ISoftLock Lock(CacheKey key, object version);
    public sealed virtual Boolean[] PutMany(CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts);
    public sealed virtual bool Put(CacheKey key, object value, long timestamp, object version, IComparer versionComparator, bool minimalPut);
    public sealed virtual void Release(CacheKey key, ISoftLock lock);
    public sealed virtual void Clear();
    public sealed virtual void Remove(CacheKey key);
    public sealed virtual void Destroy();
    public sealed virtual bool AfterUpdate(CacheKey key, object value, object version, ISoftLock lock);
    public sealed virtual bool AfterInsert(CacheKey key, object value, object version);
    public sealed virtual void Evict(CacheKey key);
    public sealed virtual bool Insert(CacheKey key, object value, object currentVersion);
    public sealed virtual bool Update(CacheKey key, object value, object currentVersion, object previousVersion);
}
public class NHibernate.Cache.ReadWriteCache : object {
    private static INHibernateLogger log;
    private CacheBase _cache;
    private int _nextLockId;
    private ICacheLock _asyncReaderWriterLock;
    public string RegionName { get; }
    public ICache Cache { get; public set; }
    private CacheBase NHibernate.Cache.IBatchableCacheConcurrencyStrategy.Cache { get; private set; }
    public ReadWriteCache(ICacheLock locker);
    private static ReadWriteCache();
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadWriteCache/<GetAsync>d__0")]
public sealed virtual Task`1<object> GetAsync(CacheKey key, long txTimestamp, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadWriteCache/<GetManyAsync>d__1")]
public sealed virtual Task`1<Object[]> GetManyAsync(CacheKey[] keys, long timestamp, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadWriteCache/<LockAsync>d__2")]
public sealed virtual Task`1<ISoftLock> LockAsync(CacheKey key, object version, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadWriteCache/<PutManyAsync>d__3")]
public sealed virtual Task`1<Boolean[]> PutManyAsync(CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadWriteCache/<PutAsync>d__4")]
public sealed virtual Task`1<bool> PutAsync(CacheKey key, object value, long txTimestamp, object version, IComparer versionComparator, bool minimalPut, CancellationToken cancellationToken);
    private Task DecrementLockAsync(object key, CacheLock lock, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadWriteCache/<ReleaseAsync>d__6")]
public sealed virtual Task ReleaseAsync(CacheKey key, ISoftLock clientLock, CancellationToken cancellationToken);
    internal Task HandleLockExpiryAsync(object key, CancellationToken cancellationToken);
    public sealed virtual Task ClearAsync(CancellationToken cancellationToken);
    public sealed virtual Task RemoveAsync(CacheKey key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadWriteCache/<AfterUpdateAsync>d__10")]
public sealed virtual Task`1<bool> AfterUpdateAsync(CacheKey key, object value, object version, ISoftLock clientLock, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.ReadWriteCache/<AfterInsertAsync>d__11")]
public sealed virtual Task`1<bool> AfterInsertAsync(CacheKey key, object value, object version, CancellationToken cancellationToken);
    public sealed virtual Task EvictAsync(CacheKey key, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> UpdateAsync(CacheKey key, object value, object currentVersion, object previousVersion, CancellationToken cancellationToken);
    public sealed virtual string get_RegionName();
    public sealed virtual ICache get_Cache();
    public sealed virtual void set_Cache(ICache value);
    private sealed virtual override CacheBase NHibernate.Cache.IBatchableCacheConcurrencyStrategy.get_Cache();
    private sealed virtual override void NHibernate.Cache.IBatchableCacheConcurrencyStrategy.set_Cache(CacheBase value);
    private int NextLockId();
    public sealed virtual object Get(CacheKey key, long txTimestamp);
    public sealed virtual Object[] GetMany(CacheKey[] keys, long timestamp);
    private static object GetValue(long timestamp, CacheKey key, ILockable lockable);
    public sealed virtual ISoftLock Lock(CacheKey key, object version);
    public sealed virtual Boolean[] PutMany(CacheKey[] keys, Object[] values, long timestamp, Object[] versions, IComparer[] versionComparers, Boolean[] minimalPuts);
    public sealed virtual bool Put(CacheKey key, object value, long txTimestamp, object version, IComparer versionComparator, bool minimalPut);
    private void DecrementLock(object key, CacheLock lock);
    public sealed virtual void Release(CacheKey key, ISoftLock clientLock);
    internal void HandleLockExpiry(object key);
    public sealed virtual void Clear();
    public sealed virtual void Remove(CacheKey key);
    public sealed virtual void Destroy();
    public sealed virtual bool AfterUpdate(CacheKey key, object value, object version, ISoftLock clientLock);
    public sealed virtual bool AfterInsert(CacheKey key, object value, object version);
    public sealed virtual void Evict(CacheKey key);
    public sealed virtual bool Insert(CacheKey key, object value, object currentVersion);
    public sealed virtual bool Update(CacheKey key, object value, object currentVersion, object previousVersion);
    private bool IsUnlockable(ISoftLock clientLock, ILockable myLock);
}
public class NHibernate.Cache.StandardQueryCache : object {
    private static INHibernateLogger Log;
    private string _regionName;
    private UpdateTimestampsCache _updateTimestampsCache;
    private CacheBase _cache;
    public ICache Cache { get; }
    public string RegionName { get; }
    [ObsoleteAttribute("Please use overload with a CacheBase parameter.")]
public StandardQueryCache(Settings settings, IDictionary`2<string, string> props, UpdateTimestampsCache updateTimestampsCache, string regionName);
    public StandardQueryCache(UpdateTimestampsCache updateTimestampsCache, CacheBase regionCache);
    private static StandardQueryCache();
    public sealed virtual Task ClearAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> PutAsync(QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, IList result, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<PutAsync>d__2")]
[ObsoleteAttribute]
public sealed virtual Task`1<bool> PutAsync(QueryKey key, ICacheAssembler[] returnTypes, IList result, bool isNaturalKeyLookup, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<GetAsync>d__3")]
public sealed virtual Task`1<IList> GetAsync(QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, ISet`1<string> spaces, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<GetAsync>d__4")]
[ObsoleteAttribute]
public sealed virtual Task`1<IList> GetAsync(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISet`1<string> spaces, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<PutManyAsync>d__5")]
public sealed virtual Task`1<Boolean[]> PutManyAsync(QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, IList[] results, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<GetManyAsync>d__6")]
public sealed virtual Task`1<IList[]> GetManyAsync(QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, ISet`1[] spaces, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<GetCacheableResultAsync>d__7")]
private static Task`1<List`1<object>> GetCacheableResultAsync(ICacheAssembler[] returnTypes, ISessionImplementor session, IList result, long ts, String[] aliases, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<PerformBeforeAssembleAsync>d__8")]
private static Task PerformBeforeAssembleAsync(ICacheAssembler[] returnTypes, ISessionImplementor session, IList cacheable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<PerformAssembleAsync>d__9")]
private Task`1<IList> PerformAssembleAsync(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISessionImplementor session, IList cacheable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<InitializeCollectionsAsync>d__10")]
private static Task InitializeCollectionsAsync(ICacheAssembler[] returnTypes, ISessionImplementor session, IList assembleResult, IList cacheResult, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<GetResultFromCacheableAsync>d__11")]
private Task`1<IList> GetResultFromCacheableAsync(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISessionImplementor session, IList cacheable, CancellationToken cancellationToken);
    protected virtual Task`1<bool> IsUpToDateAsync(ISet`1<string> spaces, long timestamp, CancellationToken cancellationToken);
    public sealed virtual ICache get_Cache();
    public sealed virtual string get_RegionName();
    public sealed virtual void Clear();
    public sealed virtual bool Put(QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, IList result, ISessionImplementor session);
    [ObsoleteAttribute]
public sealed virtual bool Put(QueryKey key, ICacheAssembler[] returnTypes, IList result, bool isNaturalKeyLookup, ISessionImplementor session);
    public sealed virtual IList Get(QueryKey key, QueryParameters queryParameters, ICacheAssembler[] returnTypes, ISet`1<string> spaces, ISessionImplementor session);
    [ObsoleteAttribute]
public sealed virtual IList Get(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISet`1<string> spaces, ISessionImplementor session);
    public sealed virtual Boolean[] PutMany(QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, IList[] results, ISessionImplementor session);
    private static String[] GetAutoDiscoveredAliases(QueryKey key);
    public sealed virtual IList[] GetMany(QueryKey[] keys, QueryParameters[] queryParameters, ICacheAssembler[][] returnTypes, ISet`1[] spaces, ISessionImplementor session);
    public sealed virtual void Destroy();
    private static List`1<object> GetCacheableResult(ICacheAssembler[] returnTypes, ISessionImplementor session, IList result, long ts, String[] aliases);
    private static long GetResultsMetadata(IList cacheable, String[]& aliases);
    private static bool IsEmpty(IList cacheable);
    [IteratorStateMachineAttribute("NHibernate.Cache.StandardQueryCache/<GetResultsEnumerable>d__35")]
private static IEnumerable`1<object> GetResultsEnumerable(IList cacheable);
    private static ICacheAssembler[] GetReturnTypes(QueryKey key, ICacheAssembler[] returnTypes, IList cacheable);
    private static void PerformBeforeAssemble(ICacheAssembler[] returnTypes, ISessionImplementor session, IList cacheable);
    private IList PerformAssemble(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISessionImplementor session, IList cacheable);
    private static void InitializeCollections(ICacheAssembler[] returnTypes, ISessionImplementor session, IList assembleResult, IList cacheResult);
    private IList GetResultFromCacheable(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISessionImplementor session, IList cacheable);
    private static ICacheAssembler[] GuessTypes(IList cacheable);
    protected virtual bool IsUpToDate(ISet`1<string> spaces, long timestamp);
}
public class NHibernate.Cache.StandardQueryCacheFactory : object {
    [ObsoleteAttribute("Please use overload with a CacheBase parameter.")]
public sealed virtual IQueryCache GetQueryCache(string regionName, UpdateTimestampsCache updateTimestampsCache, Settings settings, IDictionary`2<string, string> props);
    public virtual IQueryCache GetQueryCache(UpdateTimestampsCache updateTimestampsCache, IDictionary`2<string, string> props, CacheBase regionCache);
}
internal class NHibernate.Cache.SyncCacheLock : object {
    private MonitorLock _monitorLock;
    public sealed virtual void Dispose();
    public sealed virtual IDisposable ReadLock();
    public sealed virtual IDisposable WriteLock();
    public sealed virtual Task`1<IDisposable> ReadLockAsync();
    public sealed virtual Task`1<IDisposable> WriteLockAsync();
    private static InvalidOperationException AsyncNotSupporteException();
}
internal class NHibernate.Cache.SyncCacheReadWriteLockFactory : object {
    public sealed virtual ICacheLock Create();
}
public static class NHibernate.Cache.Timestamper : object {
    private static object lockObject;
    private static long baseDateMs;
    private static short counter;
    private static long time;
    private static int BinDigits;
    public static short OneMs;
    private static Timestamper();
    public static long Next();
}
public class NHibernate.Cache.UpdateTimestampsCache : object {
    private static INHibernateLogger log;
    private CacheBase _updateTimestamps;
    [ObsoleteAttribute("Please use overload with a CacheBase parameter.")]
public UpdateTimestampsCache(Settings settings, IDictionary`2<string, string> props);
    public UpdateTimestampsCache(CacheBase cache);
    private static UpdateTimestampsCache();
    public virtual Task ClearAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("Please use PreInvalidate(IReadOnlyCollection<string>) instead.")]
public Task PreInvalidateAsync(Object[] spaces, CancellationToken cancellationToken);
    public virtual Task PreInvalidateAsync(IReadOnlyCollection`1<string> spaces, CancellationToken cancellationToken);
    [ObsoleteAttribute("Please use Invalidate(IReadOnlyCollection<string>) instead.")]
public Task InvalidateAsync(Object[] spaces, CancellationToken cancellationToken);
    public virtual Task InvalidateAsync(IReadOnlyCollection`1<string> spaces, CancellationToken cancellationToken);
    private Task SetSpacesTimestampAsync(IReadOnlyCollection`1<string> spaces, long ts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.UpdateTimestampsCache/<IsUpToDateAsync>d__6")]
public virtual Task`1<bool> IsUpToDateAsync(ISet`1<string> spaces, long timestamp, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Cache.UpdateTimestampsCache/<AreUpToDateAsync>d__7")]
public virtual Task`1<Boolean[]> AreUpToDateAsync(ISet`1[] spaces, Int64[] timestamps, CancellationToken cancellationToken);
    public virtual void Clear();
    [ObsoleteAttribute("Please use PreInvalidate(IReadOnlyCollection<string>) instead.")]
public void PreInvalidate(Object[] spaces);
    public virtual void PreInvalidate(IReadOnlyCollection`1<string> spaces);
    [ObsoleteAttribute("Please use Invalidate(IReadOnlyCollection<string>) instead.")]
public void Invalidate(Object[] spaces);
    public virtual void Invalidate(IReadOnlyCollection`1<string> spaces);
    private void SetSpacesTimestamp(IReadOnlyCollection`1<string> spaces, long ts);
    public virtual bool IsUpToDate(ISet`1<string> spaces, long timestamp);
    public virtual Boolean[] AreUpToDate(ISet`1[] spaces, Int64[] timestamps);
    [ObsoleteAttribute("This method has no usages anymore")]
public virtual void Destroy();
    private static bool IsOutdated(Nullable`1<long> lastUpdate, long timestamp);
}
[FlagsAttribute]
public enum NHibernate.CacheMode : Enum {
    public int value__;
    public static CacheMode Ignore;
    public static CacheMode Put;
    public static CacheMode Get;
    public static CacheMode Normal;
    public static CacheMode Refresh;
}
public class NHibernate.CallbackException : HibernateException {
    public CallbackException(Exception innerException);
    public CallbackException(string message);
    public CallbackException(string message, Exception innerException);
    protected CallbackException(SerializationInfo info, StreamingContext context);
}
public static class NHibernate.Cfg.AppSettings : object {
    public static string LoggerFactoryClassName;
}
public class NHibernate.Cfg.BindMappingEventArgs : EventArgs {
    internal Lazy`1<Dialect> LazyDialect;
    [CompilerGeneratedAttribute]
private HbmMapping <Mapping>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [ObsoleteAttribute("This property will be removed in a future version.")]
public Dialect Dialect { get; }
    public HbmMapping Mapping { get; }
    public string FileName { get; }
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
public BindMappingEventArgs(Dialect dialect, HbmMapping mapping, string fileName);
    public BindMappingEventArgs(HbmMapping mapping, string fileName);
    public Dialect get_Dialect();
    [CompilerGeneratedAttribute]
public HbmMapping get_Mapping();
    [CompilerGeneratedAttribute]
public string get_FileName();
}
public class NHibernate.Cfg.ClassExtractor : object {
    public static ICollection`1<ClassEntry> GetClassEntries(HbmMapping document);
    [IteratorStateMachineAttribute("NHibernate.Cfg.ClassExtractor/<GetRootClassesEntries>d__2")]
private static IEnumerable`1<ClassEntry> GetRootClassesEntries(string assembly, string namespace, IEnumerable`1<HbmClass> rootClasses);
    [IteratorStateMachineAttribute("NHibernate.Cfg.ClassExtractor/<GetSubclassesEntries>d__3")]
private static IEnumerable`1<ClassEntry> GetSubclassesEntries(string assembly, string namespace, string defaultExtends, IEnumerable`1<HbmSubclass> hbmSubclasses);
    [IteratorStateMachineAttribute("NHibernate.Cfg.ClassExtractor/<GetJoinedSubclassesEntries>d__4")]
private static IEnumerable`1<ClassEntry> GetJoinedSubclassesEntries(string assembly, string namespace, string defaultExtends, IEnumerable`1<HbmJoinedSubclass> hbmJoinedSubclasses);
    [IteratorStateMachineAttribute("NHibernate.Cfg.ClassExtractor/<GetUnionSubclassesEntries>d__5")]
private static IEnumerable`1<ClassEntry> GetUnionSubclassesEntries(string assembly, string namespace, string defaultExtends, IEnumerable`1<HbmUnionSubclass> hbmUnionSubclasses);
}
public class NHibernate.Cfg.Configuration : object {
    public static string DefaultHibernateCfgFileName;
    private string currentDocumentName;
    private bool preMappingBuildProcessed;
    protected IDictionary`2<string, PersistentClass> classes;
    protected IDictionary`2<string, Collection> collections;
    protected IDictionary`2<string, Table> tables;
    protected IList`1<SecondPassCommand> secondPasses;
    protected Queue`1<FilterSecondPassArgs> filtersSecondPasses;
    protected IList`1<PropertyReference> propertyReferences;
    private IInterceptor interceptor;
    private IDictionary`2<string, string> properties;
    protected IList`1<IAuxiliaryDatabaseObject> auxiliaryDatabaseObjects;
    private INamingStrategy namingStrategy;
    private MappingsQueue mappingsQueue;
    private EventListeners eventListeners;
    protected IDictionary`2<string, TypeDef> typeDefs;
    protected ISet`1<ExtendsQueueEntry> extendsQueue;
    protected IDictionary`2<string, TableDescription> tableNameBinding;
    protected IDictionary`2<Table, ColumnNames> columnNameBindingPerTable;
    private static INHibernateLogger log;
    protected internal SettingsFactory settingsFactory;
    [CompilerGeneratedAttribute]
private EventHandler`1<BindMappingEventArgs> BeforeBindMapping;
    [CompilerGeneratedAttribute]
private EventHandler`1<BindMappingEventArgs> AfterBindMapping;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, NamedQueryDefinition> <NamedQueries>k__BackingField;
    [CompilerGeneratedAttribute]
private IEntityNotFoundDelegate <EntityNotFoundDelegate>k__BackingField;
    private string defaultAssembly;
    private string defaultNamespace;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, NamedSQLQueryDefinition> <NamedSQLQueries>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ResultSetMappingDefinition> <SqlResultSetMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FilterDefinition> <FilterDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ISQLFunction> <SqlFunctions>k__BackingField;
    private XmlSchemas schemas;
    public ICollection`1<PersistentClass> ClassMappings { get; }
    public ICollection`1<Collection> CollectionMappings { get; }
    private ICollection`1<Table> TableMappings { get; }
    public IDictionary`2<string, NamedQueryDefinition> NamedQueries { get; protected set; }
    public IEntityNotFoundDelegate EntityNotFoundDelegate { get; public set; }
    public EventListeners EventListeners { get; }
    public IInterceptor Interceptor { get; public set; }
    public IDictionary`2<string, string> Properties { get; public set; }
    public IDictionary`2<string, string> Imports { get; protected set; }
    public IDictionary`2<string, NamedSQLQueryDefinition> NamedSQLQueries { get; protected set; }
    public INamingStrategy NamingStrategy { get; }
    public IDictionary`2<string, ResultSetMappingDefinition> SqlResultSetMappings { get; protected set; }
    public IDictionary`2<string, FilterDefinition> FilterDefinitions { get; protected set; }
    public IDictionary`2<string, ISQLFunction> SqlFunctions { get; protected set; }
    private XmlSchemas Schemas { get; private set; }
    public Configuration(SerializationInfo info, StreamingContext context);
    protected Configuration(SettingsFactory settingsFactory);
    private static Configuration();
    private T GetSerialedObject(SerializationInfo info, string name);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected void Reset();
    [ObsoleteAttribute("Use BuildMapping(Dialect.Dialect) instead.")]
public virtual IMapping BuildMapping();
    public virtual IMapping BuildMapping(Dialect dialect);
    public ICollection`1<PersistentClass> get_ClassMappings();
    public ICollection`1<Collection> get_CollectionMappings();
    private ICollection`1<Table> get_TableMappings();
    public PersistentClass GetClassMapping(Type persistentClass);
    public PersistentClass GetClassMapping(string entityName);
    public Collection GetCollectionMapping(string role);
    public Configuration AddFile(string xmlFile);
    public Configuration AddFile(FileInfo xmlFile);
    private static void LogAndThrow(Exception exception);
    public Configuration AddXmlFile(string xmlFile);
    public Configuration AddXml(string xml);
    public Configuration AddXml(string xml, string name);
    public Configuration AddXmlString(string xml);
    public Configuration AddUrl(string url);
    public Configuration AddUrl(Uri url);
    public Configuration AddDocument(XmlDocument doc);
    public Configuration AddDocument(XmlDocument doc, string name);
    private void AddValidatedDocument(NamedXmlDocument doc);
    [CompilerGeneratedAttribute]
public void add_BeforeBindMapping(EventHandler`1<BindMappingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeBindMapping(EventHandler`1<BindMappingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AfterBindMapping(EventHandler`1<BindMappingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AfterBindMapping(EventHandler`1<BindMappingEventArgs> value);
    public void AddDeserializedMapping(HbmMapping mappingDocument, string documentFileName);
    public void AddMapping(HbmMapping mappingDocument);
    private void OnAfterBindMapping(BindMappingEventArgs bindMappingEventArgs);
    private void OnBeforeBindMapping(BindMappingEventArgs bindMappingEventArgs);
    [ObsoleteAttribute("Please use overload without a dialect parameter.")]
public Mappings CreateMappings(Dialect dialect);
    public Mappings CreateMappings();
    private void ProcessPreMappingBuildProperties();
    private void ConfigureCollectionTypeFactory();
    public Configuration AddInputStream(Stream xmlInputStream);
    public Configuration AddInputStream(Stream xmlInputStream, string name);
    public Configuration AddResource(string path, Assembly assembly);
    public Configuration AddResources(IEnumerable`1<string> paths, Assembly assembly);
    public Configuration AddClass(Type persistentClass);
    public Configuration AddAssembly(string assemblyName);
    public Configuration AddAssembly(Assembly assembly);
    private static List`1<string> GetAllHbmXmlResourceNames(Assembly assembly);
    public Configuration AddDirectory(DirectoryInfo dir);
    public String[] GenerateDropSchemaScript(Dialect dialect);
    public static bool IncludeAction(SchemaAction actionsSource, SchemaAction includedAction);
    public String[] GenerateSchemaCreationScript(Dialect dialect);
    private void Validate(IMapping mapping);
    private void ValidateFilterDefs();
    private void ValidateCollections(IMapping mapping);
    private void ValidateEntities(IMapping mapping);
    private static ICollection`1<string> ValidateProxyInterface(PersistentClass persistentClass, IProxyValidator validator);
    public virtual void BuildMappings();
    private void SecondPassCompile();
    private void SecondPassCompileForeignKeys(Table table, ISet`1<ForeignKey> done);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, NamedQueryDefinition> get_NamedQueries();
    [CompilerGeneratedAttribute]
protected void set_NamedQueries(IDictionary`2<string, NamedQueryDefinition> value);
    private EventListeners GetInitializedEventListeners();
    [CompilerGeneratedAttribute]
public IEntityNotFoundDelegate get_EntityNotFoundDelegate();
    [CompilerGeneratedAttribute]
public void set_EntityNotFoundDelegate(IEntityNotFoundDelegate value);
    public EventListeners get_EventListeners();
    protected virtual void ConfigureProxyFactoryFactory();
    public ISessionFactory BuildSessionFactory();
    public IInterceptor get_Interceptor();
    public void set_Interceptor(IInterceptor value);
    public IDictionary`2<string, string> get_Properties();
    public void set_Properties(IDictionary`2<string, string> value);
    public IDictionary`2<string, string> GetDerivedProperties();
    public Configuration SetDefaultAssembly(string newDefaultAssembly);
    public Configuration SetDefaultNamespace(string newDefaultNamespace);
    public Configuration SetInterceptor(IInterceptor newInterceptor);
    public Configuration SetProperties(IDictionary`2<string, string> newProperties);
    public Configuration AddProperties(IDictionary`2<string, string> additionalProperties);
    public Configuration SetProperty(string name, string value);
    public string GetProperty(string name);
    private void AddProperties(ISessionFactoryConfiguration factoryConfiguration);
    public Configuration Configure();
    public Configuration Configure(string fileName);
    public Configuration Configure(Assembly assembly, string resourceName);
    public Configuration Configure(XmlReader textReader);
    protected Configuration DoConfigure(ISessionFactoryConfiguration factoryConfiguration);
    internal RootClass GetRootClassMapping(string clazz);
    internal RootClass GetRootClassMapping(Type clazz);
    public Configuration SetCacheConcurrencyStrategy(string clazz, string concurrencyStrategy);
    public void SetCacheConcurrencyStrategy(string clazz, string concurrencyStrategy, string region);
    internal void SetCacheConcurrencyStrategy(string clazz, string concurrencyStrategy, string region, bool includeLazy);
    public Configuration SetCollectionCacheConcurrencyStrategy(string collectionRole, string concurrencyStrategy);
    internal void SetCollectionCacheConcurrencyStrategy(string collectionRole, string concurrencyStrategy, string region);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Imports();
    [CompilerGeneratedAttribute]
protected void set_Imports(IDictionary`2<string, string> value);
    private Settings BuildSettings();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, NamedSQLQueryDefinition> get_NamedSQLQueries();
    [CompilerGeneratedAttribute]
protected void set_NamedSQLQueries(IDictionary`2<string, NamedSQLQueryDefinition> value);
    public INamingStrategy get_NamingStrategy();
    public Configuration SetNamingStrategy(INamingStrategy newNamingStrategy);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ResultSetMappingDefinition> get_SqlResultSetMappings();
    [CompilerGeneratedAttribute]
protected void set_SqlResultSetMappings(IDictionary`2<string, ResultSetMappingDefinition> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, FilterDefinition> get_FilterDefinitions();
    [CompilerGeneratedAttribute]
protected void set_FilterDefinitions(IDictionary`2<string, FilterDefinition> value);
    public void AddFilterDefinition(FilterDefinition definition);
    public void AddAuxiliaryDatabaseObject(IAuxiliaryDatabaseObject obj);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ISQLFunction> get_SqlFunctions();
    [CompilerGeneratedAttribute]
protected void set_SqlFunctions(IDictionary`2<string, ISQLFunction> value);
    public void AddSqlFunction(string functionName, ISQLFunction sqlFunction);
    public NamedXmlDocument LoadMappingDocument(XmlReader hbmReader, string name);
    public Configuration AddXmlReader(XmlReader hbmReader);
    public Configuration AddXmlReader(XmlReader hbmReader, string name);
    private void AddDocumentThroughQueue(NamedXmlDocument document);
    private void ProcessMappingsQueue();
    private void ValidationHandler(object o, ValidationEventArgs args);
    protected virtual string GetDefaultConfigurationFilePath();
    private XmlSchemas get_Schemas();
    private void set_Schemas(XmlSchemas value);
    public void SetListeners(ListenerType type, String[] listenerClasses);
    public void SetListener(ListenerType type, object listener);
    private void ClearListeners(ListenerType type);
    public void SetListeners(ListenerType type, Object[] listeners);
    public void AppendListeners(ListenerType type, Object[] listeners);
    private static T[] AppendListeners(T[] existing, T[] listenersToAdd);
    public String[] GenerateSchemaUpdateScript(Dialect dialect, IDatabaseMetadata databaseMetadata);
    public void ValidateSchema(Dialect dialect, IDatabaseMetadata databaseMetadata);
    private IEnumerable`1<IPersistentIdentifierGenerator> IterateGenerators(Dialect dialect);
    private string GetQuotedDefaultCatalog(Dialect dialect);
    private string GetQuotedDefaultSchema(Dialect dialect);
    public FluentSessionFactoryConfiguration SessionFactory();
    public Configuration SessionFactory(Action`1<FluentSessionFactoryConfiguration> configure);
    public Configuration SessionFactoryName(string sessionFactoryName);
    public Configuration Cache(Action`1<CacheConfigurationProperties> cacheProperties);
    public Configuration CollectionTypeFactory();
    public Configuration Proxy(Action`1<ProxyConfigurationProperties> proxyProperties);
    public Configuration HqlQueryTranslator();
    public Configuration LinqQueryProvider();
    public Configuration LinqToHqlGeneratorsRegistry();
    public Configuration CurrentSessionContext();
    public Configuration Mappings(Action`1<MappingsConfigurationProperties> mappingsProperties);
    public Configuration DataBaseIntegration(Action`1<DbIntegrationConfigurationProperties> dataBaseIntegration);
    public Configuration EntityCache(Action`1<EntityCacheConfigurationProperties`1<TEntity>> entityCacheConfiguration);
    public Configuration TypeDefinition(Action`1<TypeDefConfigurationProperties> typeDefConfiguration);
    public Configuration AddNamedQuery(string queryIdentifier, Action`1<NamedQueryDefinitionBuilder> namedQueryDefinition);
    [CompilerGeneratedAttribute]
private Dialect <AddDeserializedMapping>b__58_0();
    [CompilerGeneratedAttribute]
private Dialect <TypeDefinition>b__190_0();
}
[ExtensionAttribute]
[ObsoleteAttribute]
public static class NHibernate.Cfg.ConfigurationExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static IFluentSessionFactoryConfiguration SessionFactory(Configuration configuration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration SessionFactoryName(Configuration configuration, string sessionFactoryName);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration Cache(Configuration configuration, Action`1<ICacheConfigurationProperties> cacheProperties);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration CollectionTypeFactory(Configuration configuration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration Proxy(Configuration configuration, Action`1<IProxyConfigurationProperties> proxyProperties);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration HqlQueryTranslator(Configuration configuration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration LinqQueryProvider(Configuration configuration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration LinqToHqlGeneratorsRegistry(Configuration configuration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration CurrentSessionContext(Configuration configuration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration Mappings(Configuration configuration, Action`1<IMappingsConfigurationProperties> mappingsProperties);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration DataBaseIntegration(Configuration configuration, Action`1<IDbIntegrationConfigurationProperties> dataBaseIntegration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration EntityCache(Configuration configuration, Action`1<IEntityCacheConfigurationProperties`1<TEntity>> entityCacheConfiguration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration TypeDefinition(Configuration configuration, Action`1<ITypeDefConfigurationProperties> typeDefConfiguration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Configuration instance method instead")]
public static Configuration AddNamedQuery(Configuration configuration, string queryIdentifier, Action`1<INamedQueryDefinitionBuilder> namedQueryDefinition);
}
public abstract class NHibernate.Cfg.ConfigurationProvider : object {
    private static ConfigurationProvider _current;
    public static ConfigurationProvider Current { get; public set; }
    private static ConfigurationProvider();
    public static ConfigurationProvider get_Current();
    public static void set_Current(ConfigurationProvider value);
    public abstract virtual IHibernateConfiguration GetConfiguration();
    public abstract virtual string GetNamedConnectionString(string name);
    public abstract virtual string GetLoggerFactoryClassName();
}
public enum NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType : Enum {
    public int value__;
    public static BytecodeProviderType Lcg;
    public static BytecodeProviderType Null;
}
[ExtensionAttribute]
public static class NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper : object {
    public static string CfgSectionName;
    public static string CfgSchemaXMLNS;
    public static string CfgNamespacePrefix;
    private static string RootPrefixPath;
    private static string ChildPrefixPath;
    private static XmlNamespaceManager nsMgr;
    public static XPathExpression ByteCodeProviderExpression;
    public static XPathExpression ObjectsFactoryExpression;
    public static XPathExpression ReflectionOptimizerExpression;
    public static XPathExpression SessionFactoryExpression;
    public static XPathExpression SessionFactoryPropertiesExpression;
    public static XPathExpression SessionFactoryMappingsExpression;
    public static XPathExpression SessionFactoryClassesCacheExpression;
    public static XPathExpression SessionFactoryCollectionsCacheExpression;
    public static XPathExpression SessionFactoryEventsExpression;
    public static XPathExpression SessionFactoryListenersExpression;
    private static CfgXmlHelper();
    [ExtensionAttribute]
internal static string ToConfigurationString(BytecodeProviderType source);
    public static ClassCacheInclude ClassCacheIncludeConvertFrom(string include);
    internal static string ClassCacheIncludeConvertToString(ClassCacheInclude include);
    public static ListenerType ListenerTypeConvertFrom(string listenerType);
    internal static string ListenerTypeConvertToString(ListenerType listenerType);
}
public class NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration : object {
    private string clazz;
    private string region;
    private EntityCacheUsage usage;
    private ClassCacheInclude include;
    public string Class { get; }
    public string Region { get; }
    public EntityCacheUsage Usage { get; }
    public ClassCacheInclude Include { get; }
    internal ClassCacheConfiguration(XPathNavigator classCacheElement);
    public ClassCacheConfiguration(string clazz, EntityCacheUsage usage);
    public ClassCacheConfiguration(string clazz, EntityCacheUsage usage, ClassCacheInclude include);
    public ClassCacheConfiguration(string clazz, EntityCacheUsage usage, string region);
    public ClassCacheConfiguration(string clazz, EntityCacheUsage usage, ClassCacheInclude include, string region);
    private void Parse(XPathNavigator classCacheElement);
    public string get_Class();
    public string get_Region();
    public EntityCacheUsage get_Usage();
    public ClassCacheInclude get_Include();
}
public enum NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude : Enum {
    public int value__;
    public static ClassCacheInclude All;
    public static ClassCacheInclude NonLazy;
}
public class NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration : object {
    private string collection;
    private string region;
    private EntityCacheUsage usage;
    public string Collection { get; }
    public string Region { get; }
    public EntityCacheUsage Usage { get; }
    internal CollectionCacheConfiguration(XPathNavigator collectionCacheElement);
    public CollectionCacheConfiguration(string collection, EntityCacheUsage usage);
    public CollectionCacheConfiguration(string collection, EntityCacheUsage usage, string region);
    private void Parse(XPathNavigator collectionCacheElement);
    public string get_Collection();
    public string get_Region();
    public EntityCacheUsage get_Usage();
}
public class NHibernate.Cfg.ConfigurationSchema.EventConfiguration : object {
    private ListenerType type;
    private List`1<ListenerConfiguration> listeners;
    public ListenerType Type { get; }
    public IList`1<ListenerConfiguration> Listeners { get; }
    internal EventConfiguration(XPathNavigator eventElement);
    public EventConfiguration(ListenerConfiguration listener, ListenerType type);
    private void Parse(XPathNavigator eventElement);
    public ListenerType get_Type();
    public IList`1<ListenerConfiguration> get_Listeners();
}
public class NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration : object {
    private static INHibernateLogger log;
    private string byteCodeProviderType;
    [CompilerGeneratedAttribute]
private string <ObjectsFactoryType>k__BackingField;
    private bool useReflectionOptimizer;
    private SessionFactoryConfiguration sessionFactory;
    public string ByteCodeProviderType { get; }
    public string ObjectsFactoryType { get; private set; }
    public bool UseReflectionOptimizer { get; }
    public ISessionFactoryConfiguration SessionFactory { get; }
    public HibernateConfiguration(XmlReader hbConfigurationReader);
    private HibernateConfiguration(XmlReader hbConfigurationReader, bool fromAppSetting);
    private static HibernateConfiguration();
    public static HibernateConfiguration FromAppConfig(XmlNode node);
    public static HibernateConfiguration FromAppConfig(string xml);
    private XmlReaderSettings GetSettings();
    private void Parse(XPathNavigator navigator, bool fromAppConfig);
    private void ParseByteCodeProvider(XPathNavigator navigator, bool fromAppConfig);
    private void ParseObjectsFactory(XPathNavigator navigator, bool fromAppConfig);
    private static void LogWarnIgnoredProperty(string propName);
    private void ParseReflectionOptimizer(XPathNavigator navigator, bool fromAppConfig);
    public sealed virtual string get_ByteCodeProviderType();
    [CompilerGeneratedAttribute]
public string get_ObjectsFactoryType();
    [CompilerGeneratedAttribute]
private void set_ObjectsFactoryType(string value);
    public sealed virtual bool get_UseReflectionOptimizer();
    public sealed virtual ISessionFactoryConfiguration get_SessionFactory();
}
public class NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration : object {
    private string clazz;
    private ListenerType type;
    public string Class { get; }
    public ListenerType Type { get; }
    internal ListenerConfiguration(XPathNavigator listenerElement);
    internal ListenerConfiguration(XPathNavigator listenerElement, ListenerType defaultType);
    public ListenerConfiguration(string clazz);
    public ListenerConfiguration(string clazz, ListenerType type);
    private void Parse(XPathNavigator listenerElement);
    public string get_Class();
    public ListenerType get_Type();
}
public class NHibernate.Cfg.ConfigurationSchema.MappingConfiguration : object {
    private string file;
    private string assembly;
    private string resource;
    public string File { get; }
    public string Assembly { get; }
    public string Resource { get; }
    internal MappingConfiguration(XPathNavigator mappingElement);
    public MappingConfiguration(string file);
    public MappingConfiguration(string assembly, string resource);
    private bool IsValid();
    private void Parse(XPathNavigator mappingElement);
    public bool IsEmpty();
    public string get_File();
    public string get_Assembly();
    public string get_Resource();
    public sealed virtual bool Equals(MappingConfiguration other);
    public virtual string ToString();
}
public class NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration : SessionFactoryConfigurationBase {
    internal SessionFactoryConfiguration(XPathNavigator hbConfigurationSection);
    public SessionFactoryConfiguration(string name);
    private void Parse(XPathNavigator navigator);
    private void ParseName(XPathNavigator navigator);
    private void ParseProperties(XPathNavigator navigator);
    private void ParseMappings(XPathNavigator navigator);
    private void ParseClassesCache(XPathNavigator navigator);
    private void ParseCollectionsCache(XPathNavigator navigator);
    private void ParseListeners(XPathNavigator navigator);
    private void ParseEvents(XPathNavigator navigator);
}
public class NHibernate.Cfg.ConfigurationSectionHandler : object {
    private sealed virtual override object System.Configuration.IConfigurationSectionHandler.Create(object parent, object configContext, XmlNode section);
}
public class NHibernate.Cfg.DefaultNamingStrategy : object {
    public static INamingStrategy Instance;
    private static DefaultNamingStrategy();
    public sealed virtual string ClassToTableName(string className);
    public sealed virtual string PropertyToColumnName(string propertyName);
    public sealed virtual string TableName(string tableName);
    public sealed virtual string ColumnName(string columnName);
    public sealed virtual string PropertyToTableName(string className, string propertyName);
    public sealed virtual string LogicalColumnName(string columnName, string propertyName);
}
public enum NHibernate.Cfg.EntityCacheUsage : Enum {
    public int value__;
    public static EntityCacheUsage Readonly;
    public static EntityCacheUsage ReadWrite;
    public static EntityCacheUsage NonStrictReadWrite;
    public static EntityCacheUsage Transactional;
    public static EntityCacheUsage Never;
}
public static class NHibernate.Cfg.EntityCacheUsageParser : object {
    private static string ReadOnlyXmlValue;
    private static string ReadWriteXmlValue;
    private static string NonstrictReadWriteXmlValue;
    private static string TransactionalXmlValue;
    private static string NeverXmlValue;
    public static string ToString(EntityCacheUsage value);
    public static EntityCacheUsage Parse(string value);
}
public static class NHibernate.Cfg.Environment : object {
    private static string cachedVersion;
    public static string ConnectionProvider;
    public static string ConnectionDriver;
    public static string ConnectionString;
    public static string Isolation;
    public static string ReleaseConnections;
    public static string ConnectionStringName;
    public static string SessionFactoryName;
    public static string Dialect;
    public static string DefaultSchema;
    public static string DefaultCatalog;
    [ObsoleteAttribute("DefaultEntityMode is deprecated.")]
public static string DefaultEntityMode;
    public static string DefaultFlushMode;
    public static string PreferPooledValuesLo;
    public static string ShowSql;
    public static string MaxFetchDepth;
    public static string CurrentSessionContextClass;
    public static string UseSqlComments;
    public static string DetectFetchLoops;
    public static string FormatSql;
    public static string EscapeBackslashInStrings;
    [ObsoleteAttribute("This setting has no usages and will be removed in a future version")]
public static string UseGetGeneratedKeys;
    [ObsoleteAttribute("This setting has no usages and will be removed in a future version")]
public static string StatementFetchSize;
    [ObsoleteAttribute("This setting has no usages and will be removed in a future version")]
public static string OutputStylesheet;
    public static string TransactionStrategy;
    public static string SystemTransactionCompletionLockTimeout;
    public static string UseConnectionOnSystemTransactionPrepare;
    public static string AutoJoinTransaction;
    [ObsoleteAttribute("This setting has no usages and will be removed in a future version")]
public static string TransactionManagerStrategy;
    public static string CacheProvider;
    public static string UseQueryCache;
    public static string QueryCacheFactory;
    public static string CacheReadWriteLockFactory;
    public static string UseSecondLevelCache;
    public static string CacheRegionPrefix;
    public static string UseMinimalPuts;
    public static string CacheDefaultExpiration;
    public static string QuerySubstitutions;
    public static string QueryStartupChecking;
    public static string QueryThrowNeverCached;
    public static string GenerateStatistics;
    public static string UseIdentifierRollBack;
    public static string QueryTranslator;
    public static string QueryLinqProvider;
    [ObsoleteAttribute("This setting has no usages and will be removed in a future version")]
public static string QueryImports;
    public static string Hbm2ddlAuto;
    public static string Hbm2ddlThrowOnUpdate;
    public static string Hbm2ddlKeyWords;
    public static string SqlExceptionConverter;
    public static string BatchVersionedData;
    public static string WrapResultSets;
    public static string BatchSize;
    public static string BatchStrategy;
    public static string PrepareSql;
    public static string CommandTimeout;
    public static string PropertyBytecodeProvider;
    public static string PropertyUseReflectionOptimizer;
    public static string PropertyObjectsFactory;
    public static string UseProxyValidator;
    public static string ProxyFactoryFactoryClass;
    public static string DefaultBatchFetchSize;
    public static string BatchFetchStyle;
    public static string CollectionTypeFactoryClass;
    public static string LinqToHqlGeneratorsRegistry;
    public static string LinqToHqlLegacyPreEvaluation;
    public static string LinqToHqlFallbackOnPreEvaluation;
    public static string OrderInserts;
    public static string OrderUpdates;
    public static string QueryModelRewriterFactory;
    public static string PreTransformerRegistrar;
    public static string QueryDefaultCastLength;
    public static string QueryDefaultCastPrecision;
    public static string QueryDefaultCastScale;
    public static string OdbcDateTimeScale;
    public static string SqlTypesKeepDateTime;
    public static string OracleUseNPrefixedTypesForUnicode;
    public static string OracleUseBinaryFloatingPointTypes;
    public static string OracleSuppressDecimalInvalidCastException;
    public static string FirebirdDisableParameterCasting;
    public static string SqliteBinaryGuid;
    public static string TrackSessionId;
    private static Dictionary`2<string, string> GlobalProperties;
    public static string MultiTenancy;
    public static string MultiTenancyConnectionProvider;
    public static string QueryPlanCacheMaxSize;
    public static string QueryPlanCacheParameterMetadataMaxSize;
    private static IBytecodeProvider BytecodeProviderInstance;
    private static bool EnableReflectionOptimizer;
    private static INHibernateLogger log;
    [CompilerGeneratedAttribute]
private static IHibernateConfiguration <HibernateConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private static IObjectsFactory <ObjectsFactory>k__BackingField;
    public static string Version { get; }
    internal static IHibernateConfiguration HibernateConfiguration { get; private set; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public static IDictionary`2<string, string> Properties { get; }
    public static IBytecodeProvider BytecodeProvider { get; public set; }
    public static IObjectsFactory ObjectsFactory { get; public set; }
    public static bool UseReflectionOptimizer { get; public set; }
    private static Environment();
    public static string get_Version();
    public static void VerifyProperties(IDictionary`2<string, string> props);
    public static void InitializeGlobalProperties(IHibernateConfiguration config);
    [CompilerGeneratedAttribute]
internal static IHibernateConfiguration get_HibernateConfiguration();
    [CompilerGeneratedAttribute]
private static void set_HibernateConfiguration(IHibernateConfiguration value);
    private static IHibernateConfiguration GetHibernateConfiguration();
    public static IDictionary`2<string, string> get_Properties();
    public static IBytecodeProvider get_BytecodeProvider();
    public static void set_BytecodeProvider(IBytecodeProvider value);
    [CompilerGeneratedAttribute]
public static IObjectsFactory get_ObjectsFactory();
    [CompilerGeneratedAttribute]
public static void set_ObjectsFactory(IObjectsFactory value);
    public static bool get_UseReflectionOptimizer();
    public static void set_UseReflectionOptimizer(bool value);
    public static IBytecodeProvider BuildBytecodeProvider(IDictionary`2<string, string> properties);
    private static IBytecodeProvider BuildBytecodeProvider(string providerName);
    public static IObjectsFactory BuildObjectsFactory(IDictionary`2<string, string> properties);
    private static IBytecodeProvider CreateCustomBytecodeProvider(string assemblyQualifiedName);
    private static IObjectsFactory CreateCustomObjectsFactory(string assemblyQualifiedName);
    internal static string GetNamedConnectionString(IDictionary`2<string, string> settings);
    internal static string GetConfiguredConnectionString(IDictionary`2<string, string> settings);
}
public class NHibernate.Cfg.ExtendsQueueEntry : object {
    private string explicitName;
    private string mappingPackage;
    private XmlDocument document;
    public string ExplicitName { get; }
    public string MappingPackage { get; }
    public XmlDocument Document { get; }
    public ExtendsQueueEntry(string explicitName, string mappingPackage, XmlDocument document);
    public string get_ExplicitName();
    public string get_MappingPackage();
    public XmlDocument get_Document();
}
public class NHibernate.Cfg.FilterSecondPassArgs : object {
    [CompilerGeneratedAttribute]
private IFilterable <Filterable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterName>k__BackingField;
    public IFilterable Filterable { get; private set; }
    public string FilterName { get; private set; }
    public FilterSecondPassArgs(IFilterable filterable, string filterName);
    [CompilerGeneratedAttribute]
public IFilterable get_Filterable();
    [CompilerGeneratedAttribute]
private void set_Filterable(IFilterable value);
    [CompilerGeneratedAttribute]
public string get_FilterName();
    [CompilerGeneratedAttribute]
private void set_FilterName(string value);
}
public class NHibernate.Cfg.Hbm2DDLKeyWords : object {
    private string value;
    public static Hbm2DDLKeyWords None;
    public static Hbm2DDLKeyWords Keywords;
    public static Hbm2DDLKeyWords AutoQuote;
    private Hbm2DDLKeyWords(string value);
    private static Hbm2DDLKeyWords();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public bool Equals(string other);
    public bool Equals(Hbm2DDLKeyWords other);
    public virtual int GetHashCode();
    public static bool op_Equality(string a, Hbm2DDLKeyWords b);
    public static bool op_Equality(Hbm2DDLKeyWords a, string b);
    public static bool op_Inequality(Hbm2DDLKeyWords a, string b);
    public static bool op_Inequality(string a, Hbm2DDLKeyWords b);
}
public class NHibernate.Cfg.HbmConstants : object {
    public static string nsPrefix;
    public static string nsKey;
    public static string nsColumn;
    public static string nsFormula;
    public static string nsOneToMany;
    public static string nsParam;
    public static string nsIndex;
    public static string nsListIndex;
    public static string nsGenerator;
    public static string nsType;
    public static string nsCollectionId;
    public static string nsClass;
    public static string nsSubclass;
    public static string nsJoinedSubclass;
    public static string nsQuery;
    public static string nsSqlQuery;
    public static string nsSynchronize;
    public static string nsImport;
    public static string nsMeta;
    public static string nsMetaValue;
    public static string nsQueryParam;
    public static string nsReturnDiscriminator;
    public static string nsReturnProperty;
    public static string nsReturnColumn;
    public static string nsLoader;
    public static string nsSqlInsert;
    public static string nsSqlUpdate;
    public static string nsSqlDelete;
    public static string nsSqlDeleteAll;
    public static string nsFilterDef;
    public static string nsFilterParam;
    public static string nsFilter;
    public static string nsDatabaseObject;
    public static string nsDefinition;
    public static string nsCreate;
    public static string nsDrop;
    public static string nsDialectScope;
    public static string nsResultset;
    public static string nsUnionSubclass;
    public static string nsTuplizer;
}
public class NHibernate.Cfg.HibernateConfigException : MappingException {
    private static string baseMessage;
    public HibernateConfigException(Exception innerException);
    public HibernateConfigException(string message);
    public HibernateConfigException(string message, Exception innerException);
    protected HibernateConfigException(SerializationInfo info, StreamingContext context);
}
public interface NHibernate.Cfg.IHibernateConfiguration {
    public string ByteCodeProviderType { get; }
    public bool UseReflectionOptimizer { get; }
    public ISessionFactoryConfiguration SessionFactory { get; }
    public abstract virtual string get_ByteCodeProviderType();
    public abstract virtual bool get_UseReflectionOptimizer();
    public abstract virtual ISessionFactoryConfiguration get_SessionFactory();
}
public class NHibernate.Cfg.ImprovedNamingStrategy : object {
    public static INamingStrategy Instance;
    private static ImprovedNamingStrategy();
    public sealed virtual string ClassToTableName(string className);
    public sealed virtual string PropertyToColumnName(string propertyName);
    public sealed virtual string TableName(string tableName);
    public sealed virtual string ColumnName(string columnName);
    public sealed virtual string PropertyToTableName(string className, string propertyName);
    public sealed virtual string LogicalColumnName(string columnName, string propertyName);
    private string AddUnderscores(string name);
}
public interface NHibernate.Cfg.INamingStrategy {
    public abstract virtual string ClassToTableName(string className);
    public abstract virtual string PropertyToColumnName(string propertyName);
    public abstract virtual string TableName(string tableName);
    public abstract virtual string ColumnName(string columnName);
    public abstract virtual string PropertyToTableName(string className, string propertyName);
    public abstract virtual string LogicalColumnName(string columnName, string propertyName);
}
public interface NHibernate.Cfg.ISessionFactoryConfiguration {
    public string Name { get; }
    public IDictionary`2<string, string> Properties { get; }
    public IList`1<MappingConfiguration> Mappings { get; }
    public IList`1<ClassCacheConfiguration> ClassesCache { get; }
    public IList`1<CollectionCacheConfiguration> CollectionsCache { get; }
    public IList`1<EventConfiguration> Events { get; }
    public IList`1<ListenerConfiguration> Listeners { get; }
    public abstract virtual string get_Name();
    public abstract virtual IDictionary`2<string, string> get_Properties();
    public abstract virtual IList`1<MappingConfiguration> get_Mappings();
    public abstract virtual IList`1<ClassCacheConfiguration> get_ClassesCache();
    public abstract virtual IList`1<CollectionCacheConfiguration> get_CollectionsCache();
    public abstract virtual IList`1<EventConfiguration> get_Events();
    public abstract virtual IList`1<ListenerConfiguration> get_Listeners();
}
public class NHibernate.Cfg.Loquacious.BatcherConfiguration : object {
    private DbIntegrationConfiguration dbc;
    public BatcherConfiguration(DbIntegrationConfiguration dbc);
    public BatcherConfiguration Through();
    public DbIntegrationConfiguration Each(short batchSize);
    public BatcherConfiguration OrderingInserts();
    public BatcherConfiguration DisablingInsertsOrdering();
    private sealed virtual override IBatcherConfiguration NHibernate.Cfg.Loquacious.IBatcherConfiguration.Through();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IBatcherConfiguration.Each(short batchSize);
    private sealed virtual override IBatcherConfiguration NHibernate.Cfg.Loquacious.IBatcherConfiguration.OrderingInserts();
    private sealed virtual override IBatcherConfiguration NHibernate.Cfg.Loquacious.IBatcherConfiguration.DisablingInsertsOrdering();
}
public class NHibernate.Cfg.Loquacious.CacheConfiguration : object {
    private FluentSessionFactoryConfiguration fc;
    [CompilerGeneratedAttribute]
private QueryCacheConfiguration <Queries>k__BackingField;
    internal Configuration Configuration { get; }
    public QueryCacheConfiguration Queries { get; }
    private IQueryCacheConfiguration NHibernate.Cfg.Loquacious.ICacheConfiguration.Queries { get; }
    public CacheConfiguration(FluentSessionFactoryConfiguration parent);
    internal Configuration get_Configuration();
    public CacheConfiguration Through();
    public CacheConfiguration PrefixingRegionsWith(string regionPrefix);
    public CacheConfiguration UsingMinimalPuts();
    public FluentSessionFactoryConfiguration WithDefaultExpiration(int seconds);
    [CompilerGeneratedAttribute]
public QueryCacheConfiguration get_Queries();
    private sealed virtual override ICacheConfiguration NHibernate.Cfg.Loquacious.ICacheConfiguration.Through();
    private sealed virtual override ICacheConfiguration NHibernate.Cfg.Loquacious.ICacheConfiguration.PrefixingRegionsWith(string regionPrefix);
    private sealed virtual override ICacheConfiguration NHibernate.Cfg.Loquacious.ICacheConfiguration.UsingMinimalPuts();
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.ICacheConfiguration.WithDefaultExpiration(int seconds);
    private sealed virtual override IQueryCacheConfiguration NHibernate.Cfg.Loquacious.ICacheConfiguration.get_Queries();
}
public class NHibernate.Cfg.Loquacious.CacheConfigurationProperties : object {
    private Configuration cfg;
    unknown bool UseMinimalPuts {public set; }
    unknown bool UseQueryCache {public set; }
    unknown string RegionsPrefix {public set; }
    unknown int DefaultExpiration {public set; }
    unknown bool UseSecondLevelCache {private set; }
    public CacheConfigurationProperties(Configuration cfg);
    public sealed virtual void set_UseMinimalPuts(bool value);
    public sealed virtual void set_UseQueryCache(bool value);
    public sealed virtual void set_RegionsPrefix(string value);
    public sealed virtual void set_DefaultExpiration(int value);
    public sealed virtual void Provider();
    [ObsoleteAttribute("This method is invalid and should not be used. Use QueryCacheFactory method instead.", "True")]
public sealed virtual void QueryCache();
    public void QueryCacheFactory();
    private void set_UseSecondLevelCache(bool value);
}
[ExtensionAttribute]
public static class NHibernate.Cfg.Loquacious.CacheConfigurationPropertiesExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by direct class usage")]
public static void QueryCacheFactory(ICacheConfigurationProperties config);
}
public class NHibernate.Cfg.Loquacious.CollectionFactoryConfiguration : object {
    private FluentSessionFactoryConfiguration fc;
    public CollectionFactoryConfiguration(FluentSessionFactoryConfiguration parent);
    public FluentSessionFactoryConfiguration Through();
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.ICollectionFactoryConfiguration.Through();
}
public class NHibernate.Cfg.Loquacious.CommandsConfiguration : object {
    private DbIntegrationConfiguration dbc;
    public CommandsConfiguration(DbIntegrationConfiguration dbc);
    public CommandsConfiguration Preparing();
    public CommandsConfiguration WithTimeout(byte seconds);
    public CommandsConfiguration ConvertingExceptionsThrough();
    public CommandsConfiguration AutoCommentingSql();
    public DbIntegrationConfiguration WithHqlToSqlSubstitutions(string csvQuerySubstitutions);
    public DbIntegrationConfiguration WithDefaultHqlToSqlSubstitutions();
    public CommandsConfiguration WithMaximumDepthOfOuterJoinFetching(byte maxFetchDepth);
    private sealed virtual override ICommandsConfiguration NHibernate.Cfg.Loquacious.ICommandsConfiguration.Preparing();
    private sealed virtual override ICommandsConfiguration NHibernate.Cfg.Loquacious.ICommandsConfiguration.WithTimeout(byte seconds);
    private sealed virtual override ICommandsConfiguration NHibernate.Cfg.Loquacious.ICommandsConfiguration.ConvertingExceptionsThrough();
    private sealed virtual override ICommandsConfiguration NHibernate.Cfg.Loquacious.ICommandsConfiguration.AutoCommentingSql();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.ICommandsConfiguration.WithHqlToSqlSubstitutions(string csvQuerySubstitutions);
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.ICommandsConfiguration.WithDefaultHqlToSqlSubstitutions();
    private sealed virtual override ICommandsConfiguration NHibernate.Cfg.Loquacious.ICommandsConfiguration.WithMaximumDepthOfOuterJoinFetching(byte maxFetchDepth);
}
public class NHibernate.Cfg.Loquacious.ConnectionConfiguration : object {
    private DbIntegrationConfiguration dbc;
    public ConnectionConfiguration(DbIntegrationConfiguration dbc);
    public ConnectionConfiguration Through();
    public ConnectionConfiguration By();
    public ConnectionConfiguration With(IsolationLevel level);
    public ConnectionConfiguration Releasing(ConnectionReleaseMode releaseMode);
    public DbIntegrationConfiguration Using(string connectionString);
    public DbIntegrationConfiguration Using(DbConnectionStringBuilder connectionStringBuilder);
    public DbIntegrationConfiguration ByAppConfing(string connectionStringName);
    private sealed virtual override IConnectionConfiguration NHibernate.Cfg.Loquacious.IConnectionConfiguration.Through();
    private sealed virtual override IConnectionConfiguration NHibernate.Cfg.Loquacious.IConnectionConfiguration.By();
    private sealed virtual override IConnectionConfiguration NHibernate.Cfg.Loquacious.IConnectionConfiguration.With(IsolationLevel level);
    private sealed virtual override IConnectionConfiguration NHibernate.Cfg.Loquacious.IConnectionConfiguration.Releasing(ConnectionReleaseMode releaseMode);
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IConnectionConfiguration.Using(string connectionString);
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IConnectionConfiguration.Using(DbConnectionStringBuilder connectionStringBuilder);
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IConnectionConfiguration.ByAppConfing(string connectionStringName);
}
public class NHibernate.Cfg.Loquacious.DbIntegrationConfiguration : object {
    private Configuration configuration;
    [CompilerGeneratedAttribute]
private ConnectionConfiguration <Connected>k__BackingField;
    [CompilerGeneratedAttribute]
private BatcherConfiguration <BatchingQueries>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionConfiguration <Transactions>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandsConfiguration <CreateCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private DbSchemaIntegrationConfiguration <Schema>k__BackingField;
    public Configuration Configuration { get; }
    public ConnectionConfiguration Connected { get; }
    public BatcherConfiguration BatchingQueries { get; }
    public TransactionConfiguration Transactions { get; }
    public CommandsConfiguration CreateCommands { get; }
    public DbSchemaIntegrationConfiguration Schema { get; }
    private IConnectionConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.Connected { get; }
    private IBatcherConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.BatchingQueries { get; }
    private ITransactionConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.Transactions { get; }
    private ICommandsConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.CreateCommands { get; }
    private IDbSchemaIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.Schema { get; }
    public DbIntegrationConfiguration(Configuration configuration);
    public Configuration get_Configuration();
    public DbIntegrationConfiguration Using();
    public DbIntegrationConfiguration DisableKeywordsAutoImport();
    public DbIntegrationConfiguration AutoQuoteKeywords();
    public DbIntegrationConfiguration LogSqlInConsole();
    public DbIntegrationConfiguration EnableLogFormattedSql();
    [CompilerGeneratedAttribute]
public ConnectionConfiguration get_Connected();
    [CompilerGeneratedAttribute]
public BatcherConfiguration get_BatchingQueries();
    [CompilerGeneratedAttribute]
public TransactionConfiguration get_Transactions();
    [CompilerGeneratedAttribute]
public CommandsConfiguration get_CreateCommands();
    [CompilerGeneratedAttribute]
public DbSchemaIntegrationConfiguration get_Schema();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.Using();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.DisableKeywordsAutoImport();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.AutoQuoteKeywords();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.LogSqlInConsole();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.EnableLogFormattedSql();
    private sealed virtual override IConnectionConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.get_Connected();
    private sealed virtual override IBatcherConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.get_BatchingQueries();
    private sealed virtual override ITransactionConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.get_Transactions();
    private sealed virtual override ICommandsConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.get_CreateCommands();
    private sealed virtual override IDbSchemaIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.get_Schema();
}
public class NHibernate.Cfg.Loquacious.DbIntegrationConfigurationProperties : object {
    private Configuration configuration;
    unknown Hbm2DDLKeyWords KeywordsAutoImport {public set; }
    unknown bool LogSqlInConsole {public set; }
    unknown bool LogFormattedSql {public set; }
    unknown IsolationLevel IsolationLevel {public set; }
    unknown ConnectionReleaseMode ConnectionReleaseMode {public set; }
    unknown string ConnectionString {public set; }
    unknown string ConnectionStringName {public set; }
    unknown short BatchSize {public set; }
    unknown bool OrderInserts {public set; }
    unknown bool PrepareCommands {public set; }
    unknown byte Timeout {public set; }
    unknown bool AutoCommentSql {public set; }
    unknown string HqlToSqlSubstitutions {public set; }
    unknown byte MaximumDepthOfOuterJoinFetching {public set; }
    unknown SchemaAutoAction SchemaAction {public set; }
    unknown bool ThrowOnSchemaUpdate {public set; }
    unknown MultiTenancyStrategy MultiTenancy {public set; }
    public DbIntegrationConfigurationProperties(Configuration configuration);
    public sealed virtual void Dialect();
    public sealed virtual void set_KeywordsAutoImport(Hbm2DDLKeyWords value);
    public sealed virtual void set_LogSqlInConsole(bool value);
    public sealed virtual void set_LogFormattedSql(bool value);
    public sealed virtual void ConnectionProvider();
    public sealed virtual void Driver();
    public sealed virtual void set_IsolationLevel(IsolationLevel value);
    public sealed virtual void set_ConnectionReleaseMode(ConnectionReleaseMode value);
    public sealed virtual void set_ConnectionString(string value);
    public sealed virtual void set_ConnectionStringName(string value);
    public sealed virtual void Batcher();
    public sealed virtual void set_BatchSize(short value);
    public sealed virtual void set_OrderInserts(bool value);
    public sealed virtual void TransactionFactory();
    public sealed virtual void set_PrepareCommands(bool value);
    public sealed virtual void set_Timeout(byte value);
    public sealed virtual void ExceptionConverter();
    public sealed virtual void set_AutoCommentSql(bool value);
    public sealed virtual void set_HqlToSqlSubstitutions(string value);
    public sealed virtual void set_MaximumDepthOfOuterJoinFetching(byte value);
    public sealed virtual void set_SchemaAction(SchemaAutoAction value);
    public void set_ThrowOnSchemaUpdate(bool value);
    public sealed virtual void QueryModelRewriterFactory();
    public void PreTransformerRegistrar();
    public void set_MultiTenancy(MultiTenancyStrategy value);
    public void MultiTenancyConnectionProvider();
}
public class NHibernate.Cfg.Loquacious.DbSchemaIntegrationConfiguration : object {
    private DbIntegrationConfiguration dbc;
    public DbSchemaIntegrationConfiguration(DbIntegrationConfiguration dbc);
    public DbIntegrationConfiguration Recreating();
    public DbIntegrationConfiguration Creating();
    public DbIntegrationConfiguration Updating();
    public DbIntegrationConfiguration Validating();
    public DbIntegrationConfiguration ThrowOnSchemaUpdate(bool throw);
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbSchemaIntegrationConfiguration.Recreating();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbSchemaIntegrationConfiguration.Creating();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbSchemaIntegrationConfiguration.Updating();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IDbSchemaIntegrationConfiguration.Validating();
}
public class NHibernate.Cfg.Loquacious.EntityCacheConfigurationProperties`1 : object {
    private Dictionary`2<string, EntityCollectionCacheConfigurationProperties> collections;
    [CompilerGeneratedAttribute]
private Nullable`1<EntityCacheUsage> <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionName>k__BackingField;
    public Nullable`1<EntityCacheUsage> Strategy { get; public set; }
    public string RegionName { get; public set; }
    internal IDictionary`2<string, EntityCollectionCacheConfigurationProperties> Collections { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void set_Strategy(Nullable`1<EntityCacheUsage> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<EntityCacheUsage> get_Strategy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RegionName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RegionName();
    public void Collection(Expression`1<Func`2<TEntity, TCollection>> collectionProperty, Action`1<EntityCollectionCacheConfigurationProperties> collectionCacheConfiguration);
    private sealed virtual override void NHibernate.Cfg.Loquacious.IEntityCacheConfigurationProperties<TEntity>.Collection(Expression`1<Func`2<TEntity, TCollection>> collectionProperty, Action`1<IEntityCollectionCacheConfigurationProperties> collectionCacheConfiguration);
    internal IDictionary`2<string, EntityCollectionCacheConfigurationProperties> get_Collections();
}
public class NHibernate.Cfg.Loquacious.EntityCollectionCacheConfigurationProperties : object {
    [CompilerGeneratedAttribute]
private EntityCacheUsage <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionName>k__BackingField;
    public EntityCacheUsage Strategy { get; public set; }
    public string RegionName { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual EntityCacheUsage get_Strategy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Strategy(EntityCacheUsage value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RegionName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RegionName(string value);
}
public class NHibernate.Cfg.Loquacious.FluentSessionFactoryConfiguration : object {
    private Configuration configuration;
    [CompilerGeneratedAttribute]
private DbIntegrationConfiguration <Integrate>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheConfiguration <Caching>k__BackingField;
    [CompilerGeneratedAttribute]
private ProxyConfiguration <Proxy>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionFactoryConfiguration <GeneratingCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private MappingsConfiguration <Mapping>k__BackingField;
    internal Configuration Configuration { get; }
    public DbIntegrationConfiguration Integrate { get; }
    public CacheConfiguration Caching { get; }
    public ProxyConfiguration Proxy { get; }
    public CollectionFactoryConfiguration GeneratingCollections { get; }
    public MappingsConfiguration Mapping { get; }
    private IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.Integrate { get; }
    private ICacheConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.Caching { get; }
    private IProxyConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.Proxy { get; }
    private ICollectionFactoryConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.GeneratingCollections { get; }
    private IMappingsConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.Mapping { get; }
    public FluentSessionFactoryConfiguration(Configuration configuration);
    internal Configuration get_Configuration();
    public FluentSessionFactoryConfiguration Named(string sessionFactoryName);
    [CompilerGeneratedAttribute]
public DbIntegrationConfiguration get_Integrate();
    [CompilerGeneratedAttribute]
public CacheConfiguration get_Caching();
    public FluentSessionFactoryConfiguration GenerateStatistics();
    public FluentSessionFactoryConfiguration DefaultFlushMode(FlushMode flushMode);
    public FluentSessionFactoryConfiguration ParsingHqlThrough();
    public FluentSessionFactoryConfiguration ParsingLinqThrough();
    [CompilerGeneratedAttribute]
public ProxyConfiguration get_Proxy();
    [CompilerGeneratedAttribute]
public CollectionFactoryConfiguration get_GeneratingCollections();
    [CompilerGeneratedAttribute]
public MappingsConfiguration get_Mapping();
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.Named(string sessionFactoryName);
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.get_Integrate();
    private sealed virtual override ICacheConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.get_Caching();
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.GenerateStatistics();
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.DefaultFlushMode(FlushMode flushMode);
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.ParsingHqlThrough();
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.ParsingLinqThrough();
    private sealed virtual override IProxyConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.get_Proxy();
    private sealed virtual override ICollectionFactoryConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.get_GeneratingCollections();
    private sealed virtual override IMappingsConfiguration NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.get_Mapping();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IBatcherConfiguration {
    public abstract virtual IBatcherConfiguration Through();
    public abstract virtual IDbIntegrationConfiguration Each(short batchSize);
    public abstract virtual IBatcherConfiguration OrderingInserts();
    public abstract virtual IBatcherConfiguration DisablingInsertsOrdering();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.ICacheConfiguration {
    public IQueryCacheConfiguration Queries { get; }
    public abstract virtual ICacheConfiguration Through();
    public abstract virtual ICacheConfiguration PrefixingRegionsWith(string regionPrefix);
    public abstract virtual ICacheConfiguration UsingMinimalPuts();
    public abstract virtual IFluentSessionFactoryConfiguration WithDefaultExpiration(int seconds);
    public abstract virtual IQueryCacheConfiguration get_Queries();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.ICacheConfigurationProperties {
    unknown bool UseMinimalPuts {public set; }
    unknown bool UseQueryCache {public set; }
    unknown string RegionsPrefix {public set; }
    unknown int DefaultExpiration {public set; }
    public abstract virtual void set_UseMinimalPuts(bool value);
    public abstract virtual void set_UseQueryCache(bool value);
    public abstract virtual void set_RegionsPrefix(string value);
    public abstract virtual void set_DefaultExpiration(int value);
    public abstract virtual void Provider();
    [ObsoleteAttribute("This method is invalid and should not be used. Use the QueryCacheFactory extension method instead.", "True")]
public abstract virtual void QueryCache();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.ICollectionFactoryConfiguration {
    public abstract virtual IFluentSessionFactoryConfiguration Through();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.ICommandsConfiguration {
    public abstract virtual ICommandsConfiguration Preparing();
    public abstract virtual ICommandsConfiguration WithTimeout(byte seconds);
    public abstract virtual ICommandsConfiguration ConvertingExceptionsThrough();
    public abstract virtual ICommandsConfiguration AutoCommentingSql();
    public abstract virtual IDbIntegrationConfiguration WithHqlToSqlSubstitutions(string csvQuerySubstitutions);
    public abstract virtual IDbIntegrationConfiguration WithDefaultHqlToSqlSubstitutions();
    public abstract virtual ICommandsConfiguration WithMaximumDepthOfOuterJoinFetching(byte maxFetchDepth);
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IConnectionConfiguration {
    public abstract virtual IConnectionConfiguration Through();
    public abstract virtual IConnectionConfiguration By();
    public abstract virtual IConnectionConfiguration With(IsolationLevel level);
    public abstract virtual IConnectionConfiguration Releasing(ConnectionReleaseMode releaseMode);
    public abstract virtual IDbIntegrationConfiguration Using(string connectionString);
    public abstract virtual IDbIntegrationConfiguration Using(DbConnectionStringBuilder connectionStringBuilder);
    public abstract virtual IDbIntegrationConfiguration ByAppConfing(string connectionStringName);
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration {
    public IConnectionConfiguration Connected { get; }
    public IBatcherConfiguration BatchingQueries { get; }
    public ITransactionConfiguration Transactions { get; }
    public ICommandsConfiguration CreateCommands { get; }
    public IDbSchemaIntegrationConfiguration Schema { get; }
    public abstract virtual IDbIntegrationConfiguration Using();
    public abstract virtual IDbIntegrationConfiguration DisableKeywordsAutoImport();
    public abstract virtual IDbIntegrationConfiguration AutoQuoteKeywords();
    public abstract virtual IDbIntegrationConfiguration LogSqlInConsole();
    public abstract virtual IDbIntegrationConfiguration EnableLogFormattedSql();
    public abstract virtual IConnectionConfiguration get_Connected();
    public abstract virtual IBatcherConfiguration get_BatchingQueries();
    public abstract virtual ITransactionConfiguration get_Transactions();
    public abstract virtual ICommandsConfiguration get_CreateCommands();
    public abstract virtual IDbSchemaIntegrationConfiguration get_Schema();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IDbIntegrationConfigurationProperties {
    unknown Hbm2DDLKeyWords KeywordsAutoImport {public set; }
    unknown bool LogSqlInConsole {public set; }
    unknown bool LogFormattedSql {public set; }
    unknown IsolationLevel IsolationLevel {public set; }
    unknown ConnectionReleaseMode ConnectionReleaseMode {public set; }
    unknown string ConnectionString {public set; }
    unknown string ConnectionStringName {public set; }
    unknown short BatchSize {public set; }
    unknown bool OrderInserts {public set; }
    unknown bool PrepareCommands {public set; }
    unknown byte Timeout {public set; }
    unknown bool AutoCommentSql {public set; }
    unknown string HqlToSqlSubstitutions {public set; }
    unknown byte MaximumDepthOfOuterJoinFetching {public set; }
    unknown SchemaAutoAction SchemaAction {public set; }
    public abstract virtual void Dialect();
    public abstract virtual void set_KeywordsAutoImport(Hbm2DDLKeyWords value);
    public abstract virtual void set_LogSqlInConsole(bool value);
    public abstract virtual void set_LogFormattedSql(bool value);
    public abstract virtual void ConnectionProvider();
    public abstract virtual void Driver();
    public abstract virtual void set_IsolationLevel(IsolationLevel value);
    public abstract virtual void set_ConnectionReleaseMode(ConnectionReleaseMode value);
    public abstract virtual void set_ConnectionString(string value);
    public abstract virtual void set_ConnectionStringName(string value);
    public abstract virtual void Batcher();
    public abstract virtual void set_BatchSize(short value);
    public abstract virtual void set_OrderInserts(bool value);
    public abstract virtual void TransactionFactory();
    public abstract virtual void set_PrepareCommands(bool value);
    public abstract virtual void set_Timeout(byte value);
    public abstract virtual void ExceptionConverter();
    public abstract virtual void set_AutoCommentSql(bool value);
    public abstract virtual void set_HqlToSqlSubstitutions(string value);
    public abstract virtual void set_MaximumDepthOfOuterJoinFetching(byte value);
    public abstract virtual void set_SchemaAction(SchemaAutoAction value);
    public abstract virtual void QueryModelRewriterFactory();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IDbSchemaIntegrationConfiguration {
    public abstract virtual IDbIntegrationConfiguration Recreating();
    public abstract virtual IDbIntegrationConfiguration Creating();
    public abstract virtual IDbIntegrationConfiguration Updating();
    public abstract virtual IDbIntegrationConfiguration Validating();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IEntityCacheConfigurationProperties`1 {
    public Nullable`1<EntityCacheUsage> Strategy { get; public set; }
    public string RegionName { get; public set; }
    public abstract virtual Nullable`1<EntityCacheUsage> get_Strategy();
    public abstract virtual void set_Strategy(Nullable`1<EntityCacheUsage> value);
    public abstract virtual string get_RegionName();
    public abstract virtual void set_RegionName(string value);
    public abstract virtual void Collection(Expression`1<Func`2<TEntity, TCollection>> collectionProperty, Action`1<IEntityCollectionCacheConfigurationProperties> collectionCacheConfiguration);
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IEntityCollectionCacheConfigurationProperties {
    public EntityCacheUsage Strategy { get; public set; }
    public string RegionName { get; public set; }
    public abstract virtual EntityCacheUsage get_Strategy();
    public abstract virtual void set_Strategy(EntityCacheUsage value);
    public abstract virtual string get_RegionName();
    public abstract virtual void set_RegionName(string value);
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration {
    public IDbIntegrationConfiguration Integrate { get; }
    public ICacheConfiguration Caching { get; }
    public IProxyConfiguration Proxy { get; }
    public ICollectionFactoryConfiguration GeneratingCollections { get; }
    public IMappingsConfiguration Mapping { get; }
    public abstract virtual IFluentSessionFactoryConfiguration Named(string sessionFactoryName);
    public abstract virtual IDbIntegrationConfiguration get_Integrate();
    public abstract virtual ICacheConfiguration get_Caching();
    public abstract virtual IFluentSessionFactoryConfiguration GenerateStatistics();
    public abstract virtual IFluentSessionFactoryConfiguration DefaultFlushMode(FlushMode flushMode);
    public abstract virtual IFluentSessionFactoryConfiguration ParsingHqlThrough();
    public abstract virtual IFluentSessionFactoryConfiguration ParsingLinqThrough();
    public abstract virtual IProxyConfiguration get_Proxy();
    public abstract virtual ICollectionFactoryConfiguration get_GeneratingCollections();
    public abstract virtual IMappingsConfiguration get_Mapping();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IMappingsConfiguration {
    public abstract virtual IMappingsConfiguration UsingDefaultCatalog(string defaultCatalogName);
    public abstract virtual IFluentSessionFactoryConfiguration UsingDefaultSchema(string defaultSchemaName);
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IMappingsConfigurationProperties {
    unknown string DefaultCatalog {public set; }
    unknown string DefaultSchema {public set; }
    public abstract virtual void set_DefaultCatalog(string value);
    public abstract virtual void set_DefaultSchema(string value);
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.INamedQueryDefinitionBuilder {
    public bool IsCacheable { get; public set; }
    public string CacheRegion { get; public set; }
    public int FetchSize { get; public set; }
    public int Timeout { get; public set; }
    public FlushMode FlushMode { get; public set; }
    public string Query { get; public set; }
    public bool IsReadOnly { get; public set; }
    public string Comment { get; public set; }
    public Nullable`1<CacheMode> CacheMode { get; public set; }
    public abstract virtual bool get_IsCacheable();
    public abstract virtual void set_IsCacheable(bool value);
    public abstract virtual string get_CacheRegion();
    public abstract virtual void set_CacheRegion(string value);
    public abstract virtual int get_FetchSize();
    public abstract virtual void set_FetchSize(int value);
    public abstract virtual int get_Timeout();
    public abstract virtual void set_Timeout(int value);
    public abstract virtual FlushMode get_FlushMode();
    public abstract virtual void set_FlushMode(FlushMode value);
    public abstract virtual string get_Query();
    public abstract virtual void set_Query(string value);
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void set_IsReadOnly(bool value);
    public abstract virtual string get_Comment();
    public abstract virtual void set_Comment(string value);
    public abstract virtual Nullable`1<CacheMode> get_CacheMode();
    public abstract virtual void set_CacheMode(Nullable`1<CacheMode> value);
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IProxyConfiguration {
    public abstract virtual IProxyConfiguration DisableValidation();
    public abstract virtual IFluentSessionFactoryConfiguration Through();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IProxyConfigurationProperties {
    unknown bool Validation {public set; }
    public abstract virtual void set_Validation(bool value);
    public abstract virtual void ProxyFactoryFactory();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.IQueryCacheConfiguration {
    public abstract virtual ICacheConfiguration Through();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.ITransactionConfiguration {
    public abstract virtual IDbIntegrationConfiguration Through();
}
[ObsoleteAttribute("Replaced by direct class usage")]
public interface NHibernate.Cfg.Loquacious.ITypeDefConfigurationProperties {
    public string Alias { get; public set; }
    public object Properties { get; public set; }
    public abstract virtual string get_Alias();
    public abstract virtual void set_Alias(string value);
    public abstract virtual object get_Properties();
    public abstract virtual void set_Properties(object value);
}
public class NHibernate.Cfg.Loquacious.MappingsConfiguration : object {
    private FluentSessionFactoryConfiguration fc;
    public MappingsConfiguration(FluentSessionFactoryConfiguration parent);
    public MappingsConfiguration UsingDefaultCatalog(string defaultCatalogName);
    public FluentSessionFactoryConfiguration UsingDefaultSchema(string defaultSchemaName);
    private sealed virtual override IMappingsConfiguration NHibernate.Cfg.Loquacious.IMappingsConfiguration.UsingDefaultCatalog(string defaultCatalogName);
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.IMappingsConfiguration.UsingDefaultSchema(string defaultSchemaName);
}
public class NHibernate.Cfg.Loquacious.MappingsConfigurationProperties : object {
    private Configuration configuration;
    unknown string DefaultCatalog {public set; }
    unknown string DefaultSchema {public set; }
    public MappingsConfigurationProperties(Configuration configuration);
    public sealed virtual void set_DefaultCatalog(string value);
    public sealed virtual void set_DefaultSchema(string value);
}
public class NHibernate.Cfg.Loquacious.NamedQueryDefinitionBuilder : object {
    private int fetchSize;
    private int timeout;
    [CompilerGeneratedAttribute]
private bool <IsCacheable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private FlushMode <FlushMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CacheMode> <CacheMode>k__BackingField;
    public bool IsCacheable { get; public set; }
    public string CacheRegion { get; public set; }
    public int FetchSize { get; public set; }
    public int Timeout { get; public set; }
    public FlushMode FlushMode { get; public set; }
    public string Query { get; public set; }
    public bool IsReadOnly { get; public set; }
    public string Comment { get; public set; }
    public Nullable`1<CacheMode> CacheMode { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCacheable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsCacheable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CacheRegion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CacheRegion(string value);
    public sealed virtual int get_FetchSize();
    public sealed virtual void set_FetchSize(int value);
    public sealed virtual int get_Timeout();
    public sealed virtual void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public sealed virtual FlushMode get_FlushMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FlushMode(FlushMode value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Query();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Query(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Comment();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Comment(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<CacheMode> get_CacheMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CacheMode(Nullable`1<CacheMode> value);
    internal NamedQueryDefinition Build();
}
public class NHibernate.Cfg.Loquacious.ProxyConfiguration : object {
    private FluentSessionFactoryConfiguration fc;
    public ProxyConfiguration(FluentSessionFactoryConfiguration parent);
    public ProxyConfiguration DisableValidation();
    public FluentSessionFactoryConfiguration Through();
    private sealed virtual override IProxyConfiguration NHibernate.Cfg.Loquacious.IProxyConfiguration.DisableValidation();
    private sealed virtual override IFluentSessionFactoryConfiguration NHibernate.Cfg.Loquacious.IProxyConfiguration.Through();
}
public class NHibernate.Cfg.Loquacious.ProxyConfigurationProperties : object {
    private Configuration configuration;
    unknown bool Validation {public set; }
    public ProxyConfigurationProperties(Configuration configuration);
    public sealed virtual void set_Validation(bool value);
    public sealed virtual void ProxyFactoryFactory();
}
public class NHibernate.Cfg.Loquacious.QueryCacheConfiguration : object {
    private CacheConfiguration cc;
    public QueryCacheConfiguration(CacheConfiguration cc);
    public CacheConfiguration Through();
    private sealed virtual override ICacheConfiguration NHibernate.Cfg.Loquacious.IQueryCacheConfiguration.Through();
}
public class NHibernate.Cfg.Loquacious.TransactionConfiguration : object {
    private DbIntegrationConfiguration dbc;
    public TransactionConfiguration(DbIntegrationConfiguration dbc);
    public DbIntegrationConfiguration Through();
    private sealed virtual override IDbIntegrationConfiguration NHibernate.Cfg.Loquacious.ITransactionConfiguration.Through();
}
public class NHibernate.Cfg.Loquacious.TypeDefConfigurationProperties : object {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Properties>k__BackingField;
    public string Alias { get; public set; }
    public object Properties { get; public set; }
    internal static TypeDefConfigurationProperties Create();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Alias();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Alias(string value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Properties(object value);
}
public class NHibernate.Cfg.Mappings : object {
    private static INHibernateLogger log;
    private IDictionary`2<string, PersistentClass> classes;
    private IDictionary`2<string, Collection> collections;
    private IDictionary`2<string, Table> tables;
    private IDictionary`2<string, NamedQueryDefinition> queries;
    private IDictionary`2<string, NamedSQLQueryDefinition> sqlqueries;
    private IDictionary`2<string, ResultSetMappingDefinition> resultSetMappings;
    private IList`1<SecondPassCommand> secondPasses;
    private IDictionary`2<string, string> imports;
    private string schemaName;
    private string catalogName;
    private string defaultCascade;
    private string defaultNamespace;
    private string defaultAssembly;
    private string defaultAccess;
    private bool autoImport;
    private bool defaultLazy;
    private IList`1<PropertyReference> propertyReferences;
    private IDictionary`2<string, FilterDefinition> filterDefinitions;
    private IList`1<IAuxiliaryDatabaseObject> auxiliaryDatabaseObjects;
    private Queue`1<FilterSecondPassArgs> filtersSecondPasses;
    private INamingStrategy namingStrategy;
    protected internal IDictionary`2<string, TypeDef> typeDefs;
    protected internal ISet`1<ExtendsQueueEntry> extendsQueue;
    protected internal IDictionary`2<Table, ColumnNames> columnNameBindingPerTable;
    protected internal IDictionary`2<string, TableDescription> tableNameBinding;
    internal Lazy`1<Dialect> LazyDialect;
    [CompilerGeneratedAttribute]
private string <DefaultCatalog>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreferPooledValuesLo>k__BackingField;
    [ObsoleteAttribute("This property will be removed in a future version.")]
public Dialect Dialect { get; }
    public INamingStrategy NamingStrategy { get; }
    public string DefaultNamespace { get; public set; }
    public string DefaultAssembly { get; public set; }
    public string DefaultCatalog { get; public set; }
    public string DefaultSchema { get; public set; }
    public string PreferPooledValuesLo { get; public set; }
    public string SchemaName { get; public set; }
    public string CatalogName { get; public set; }
    public string DefaultCascade { get; public set; }
    public string DefaultAccess { get; public set; }
    public bool IsAutoImport { get; public set; }
    public bool DefaultLazy { get; public set; }
    public IDictionary`2<string, FilterDefinition> FilterDefinitions { get; }
    public IEnumerable`1<Collection> IterateCollections { get; }
    public IEnumerable`1<Table> IterateTables { get; }
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
protected internal Mappings(IDictionary`2<string, PersistentClass> classes, IDictionary`2<string, Collection> collections, IDictionary`2<string, Table> tables, IDictionary`2<string, NamedQueryDefinition> queries, IDictionary`2<string, NamedSQLQueryDefinition> sqlqueries, IDictionary`2<string, ResultSetMappingDefinition> resultSetMappings, IDictionary`2<string, string> imports, IList`1<SecondPassCommand> secondPasses, Queue`1<FilterSecondPassArgs> filtersSecondPasses, IList`1<PropertyReference> propertyReferences, INamingStrategy namingStrategy, IDictionary`2<string, TypeDef> typeDefs, IDictionary`2<string, FilterDefinition> filterDefinitions, ISet`1<ExtendsQueueEntry> extendsQueue, IList`1<IAuxiliaryDatabaseObject> auxiliaryDatabaseObjects, IDictionary`2<string, TableDescription> tableNameBinding, IDictionary`2<Table, ColumnNames> columnNameBindingPerTable, string defaultAssembly, string defaultNamespace, string defaultCatalog, string defaultSchema, string preferPooledValuesLo, Dialect dialect);
    protected internal Mappings(IDictionary`2<string, PersistentClass> classes, IDictionary`2<string, Collection> collections, IDictionary`2<string, Table> tables, IDictionary`2<string, NamedQueryDefinition> queries, IDictionary`2<string, NamedSQLQueryDefinition> sqlqueries, IDictionary`2<string, ResultSetMappingDefinition> resultSetMappings, IDictionary`2<string, string> imports, IList`1<SecondPassCommand> secondPasses, Queue`1<FilterSecondPassArgs> filtersSecondPasses, IList`1<PropertyReference> propertyReferences, INamingStrategy namingStrategy, IDictionary`2<string, TypeDef> typeDefs, IDictionary`2<string, FilterDefinition> filterDefinitions, ISet`1<ExtendsQueueEntry> extendsQueue, IList`1<IAuxiliaryDatabaseObject> auxiliaryDatabaseObjects, IDictionary`2<string, TableDescription> tableNameBinding, IDictionary`2<Table, ColumnNames> columnNameBindingPerTable, string defaultAssembly, string defaultNamespace, string defaultCatalog, string defaultSchema, string preferPooledValuesLo);
    private static Mappings();
    public void AddClass(PersistentClass persistentClass);
    public void AddCollection(Collection collection);
    public void AddUniquePropertyReference(string referencedClass, string propertyName);
    public void AddPropertyReference(string referencedClass, string propertyName);
    public PersistentClass GetClass(string className);
    public Dialect get_Dialect();
    public INamingStrategy get_NamingStrategy();
    public string get_DefaultNamespace();
    public void set_DefaultNamespace(string value);
    public string get_DefaultAssembly();
    public void set_DefaultAssembly(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultCatalog();
    [CompilerGeneratedAttribute]
public void set_DefaultCatalog(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultSchema();
    [CompilerGeneratedAttribute]
public void set_DefaultSchema(string value);
    [CompilerGeneratedAttribute]
public string get_PreferPooledValuesLo();
    [CompilerGeneratedAttribute]
public void set_PreferPooledValuesLo(string value);
    public Collection GetCollection(string role);
    public void AddImport(string className, string rename);
    public Table AddTable(string schema, string catalog, string name, string subselect, bool isAbstract, string schemaAction);
    private static SchemaAction GetSchemaActions(string schemaAction);
    public Table AddDenormalizedTable(string schema, string catalog, string name, bool isAbstract, string subselect, Table includedTable);
    public void AddTableBinding(string schema, string catalog, string logicalName, string physicalName, Table denormalizedSuperTable);
    public Table GetTable(string schema, string catalog, string name);
    public string get_SchemaName();
    public void set_SchemaName(string value);
    public string get_CatalogName();
    public void set_CatalogName(string value);
    public string get_DefaultCascade();
    public void set_DefaultCascade(string value);
    public string get_DefaultAccess();
    public void set_DefaultAccess(string value);
    private void CheckQueryExists(string name);
    public void AddQuery(string name, NamedQueryDefinition query);
    public void AddSQLQuery(string name, NamedSQLQueryDefinition query);
    public NamedQueryDefinition GetQuery(string name);
    public void AddSecondPass(SecondPassCommand command);
    public void AddSecondPass(SecondPassCommand command, bool onTopOfTheQueue);
    public bool get_IsAutoImport();
    public void set_IsAutoImport(bool value);
    public bool get_DefaultLazy();
    public void set_DefaultLazy(bool value);
    public IDictionary`2<string, FilterDefinition> get_FilterDefinitions();
    public void AddFilterDefinition(FilterDefinition definition);
    public FilterDefinition GetFilterDefinition(string name);
    public void AddAuxiliaryDatabaseObject(IAuxiliaryDatabaseObject auxiliaryDatabaseObject);
    public void AddResultSetMapping(ResultSetMappingDefinition sqlResultSetMapping);
    public void AddToExtendsQueue(ExtendsQueueEntry entry);
    public void AddTypeDef(string typeName, string typeClass, IDictionary`2<string, string> paramMap);
    public TypeDef GetTypeDef(string typeName);
    public void AddColumnBinding(string logicalName, Column finalColumn, Table table);
    public string GetLogicalColumnName(string physicalName, Table table);
    public string GetPhysicalColumnName(string logicalName, Table table);
    private static string BuildTableNameKey(string schema, string catalog, string name);
    private string GetLogicalTableName(string schema, string catalog, string physicalName);
    public string GetLogicalTableName(Table table);
    public ResultSetMappingDefinition GetResultSetMapping(string name);
    public IEnumerable`1<Collection> get_IterateCollections();
    public IEnumerable`1<Table> get_IterateTables();
    public PersistentClass LocatePersistentClassByEntityName(string entityName);
    public void ExpectedFilterDefinition(IFilterable filterable, string filterName, string condition);
}
public abstract class NHibernate.Cfg.MappingSchema.AbstractDecoratable : object {
    private static IDictionary`2<string, MetaAttribute> EmptyMetaData;
    [XmlIgnoreAttribute]
private IDictionary`2<string, MetaAttribute> mappedMetaData;
    [XmlIgnoreAttribute]
private IDictionary`2<string, MetaAttribute> inheritableMetaData;
    [XmlIgnoreAttribute]
public IDictionary`2<string, MetaAttribute> MappedMetaData { get; }
    [XmlIgnoreAttribute]
public IDictionary`2<string, MetaAttribute> InheritableMetaData { get; }
    protected HbmMeta[] Metadatas { get; }
    private static AbstractDecoratable();
    public virtual IDictionary`2<string, MetaAttribute> get_MappedMetaData();
    public sealed virtual IDictionary`2<string, MetaAttribute> get_InheritableMetaData();
    protected void CreateMappedMetadata(HbmMeta[] metadatas);
    protected abstract virtual HbmMeta[] get_Metadatas();
}
public class NHibernate.Cfg.MappingSchema.EndsWithHbmXmlFilter : object {
    public sealed virtual bool ShouldParse(string resourceName);
}
[ExtensionAttribute]
internal static class NHibernate.Cfg.MappingSchema.EntityPropertyMappingExtensiosns : object {
    [ExtensionAttribute]
public static string GetLazyGroup(IEntityPropertyMapping mapping);
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("any")]
public class NHibernate.Cfg.MappingSchema.HbmAny : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("meta-value")]
public HbmMetaValue[] metavalue;
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute("id-type")]
public string idtype;
    [XmlAttributeAttribute("meta-type")]
public string metatype;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool insert;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool update;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute]
public string index;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool lazy;
    [XmlAttributeAttribute]
public string node;
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    public bool IsLazyProperty { get; }
    protected HbmMeta[] Metadatas { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    public string MetaType { get; }
    public ICollection`1<HbmMetaValue> MetaValues { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual bool get_IsLazyProperty();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmAny/<AsColumns>d__28")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual string get_MetaType();
    public sealed virtual ICollection`1<HbmMetaValue> get_MetaValues();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("array")]
public class NHibernate.Cfg.MappingSchema.HbmArray : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    public HbmCache cache;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    public HbmKey key;
    [XmlElementAttribute("index", "NHibernate.Cfg.MappingSchema.HbmIndex")]
[XmlElementAttribute("list-index", "NHibernate.Cfg.MappingSchema.HbmListIndex")]
public object Item;
    [XmlElementAttribute("composite-element", "NHibernate.Cfg.MappingSchema.HbmCompositeElement")]
[XmlElementAttribute("element", "NHibernate.Cfg.MappingSchema.HbmElement")]
[XmlElementAttribute("many-to-any", "NHibernate.Cfg.MappingSchema.HbmManyToAny")]
[XmlElementAttribute("many-to-many", "NHibernate.Cfg.MappingSchema.HbmManyToMany")]
[XmlElementAttribute("one-to-many", "NHibernate.Cfg.MappingSchema.HbmOneToMany")]
public object Item1;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("sql-delete-all")]
public HbmCustomSQL sqldeleteall;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool inverse;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool mutable;
    [XmlAttributeAttribute("element-class")]
public string elementclass;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute("batch-size")]
public int batchsize;
    [XmlIgnoreAttribute]
public bool batchsizeSpecified;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmCollectionFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("collection-type")]
public string collectiontype;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    public string Name { get; }
    public string Access { get; }
    public bool IsLazyProperty { get; }
    public bool OptimisticLock { get; }
    public string Cascade { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public HbmCustomSQL SqlDeleteAll { get; }
    public string Subselect { get; }
    public bool Inverse { get; }
    public bool Mutable { get; }
    public string OrderBy { get; }
    public string Where { get; }
    public Nullable`1<int> BatchSize { get; }
    public string PersisterQualifiedName { get; }
    public string CollectionType { get; }
    public Nullable`1<HbmCollectionFetchMode> FetchMode { get; }
    public Nullable`1<HbmOuterJoinStrategy> OuterJoin { get; }
    public Nullable`1<HbmCollectionLazy> Lazy { get; }
    public string Table { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Check { get; }
    public object ElementRelationship { get; }
    public string Sort { get; }
    public Nullable`1<bool> Generic { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFilter> Filters { get; }
    public HbmKey Key { get; }
    public HbmCache Cache { get; }
    public HbmListIndex ListIndex { get; }
    public HbmIndex Index { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual string get_Cascade();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual HbmCustomSQL get_SqlDeleteAll();
    public sealed virtual string get_Subselect();
    public sealed virtual bool get_Inverse();
    public sealed virtual bool get_Mutable();
    public sealed virtual string get_OrderBy();
    public sealed virtual string get_Where();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual string get_PersisterQualifiedName();
    public sealed virtual string get_CollectionType();
    public sealed virtual Nullable`1<HbmCollectionFetchMode> get_FetchMode();
    public sealed virtual Nullable`1<HbmOuterJoinStrategy> get_OuterJoin();
    public sealed virtual Nullable`1<HbmCollectionLazy> get_Lazy();
    public sealed virtual string get_Table();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Catalog();
    public sealed virtual string get_Check();
    public sealed virtual object get_ElementRelationship();
    public sealed virtual string get_Sort();
    public sealed virtual Nullable`1<bool> get_Generic();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmArray/<get_Filters>d__95")]
public sealed virtual IEnumerable`1<HbmFilter> get_Filters();
    public sealed virtual HbmKey get_Key();
    public sealed virtual HbmCache get_Cache();
    public sealed virtual HbmListIndex get_ListIndex();
    public sealed virtual HbmIndex get_Index();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("bag")]
public class NHibernate.Cfg.MappingSchema.HbmBag : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    public HbmCache cache;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    public HbmKey key;
    [XmlElementAttribute("composite-element", "NHibernate.Cfg.MappingSchema.HbmCompositeElement")]
[XmlElementAttribute("element", "NHibernate.Cfg.MappingSchema.HbmElement")]
[XmlElementAttribute("many-to-any", "NHibernate.Cfg.MappingSchema.HbmManyToAny")]
[XmlElementAttribute("many-to-many", "NHibernate.Cfg.MappingSchema.HbmManyToMany")]
[XmlElementAttribute("one-to-many", "NHibernate.Cfg.MappingSchema.HbmOneToMany")]
public object Item;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("sql-delete-all")]
public HbmCustomSQL sqldeleteall;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute]
public HbmCollectionLazy lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool inverse;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool mutable;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute("order-by")]
public string orderby;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute("batch-size")]
public int batchsize;
    [XmlIgnoreAttribute]
public bool batchsizeSpecified;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmCollectionFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("collection-type")]
public string collectiontype;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public bool generic;
    [XmlIgnoreAttribute]
public bool genericSpecified;
    public string Name { get; }
    public string Access { get; }
    public bool IsLazyProperty { get; }
    public bool OptimisticLock { get; }
    public string Cascade { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public HbmCustomSQL SqlDeleteAll { get; }
    public string Subselect { get; }
    public bool Inverse { get; }
    public bool Mutable { get; }
    public string OrderBy { get; }
    public string Where { get; }
    public Nullable`1<int> BatchSize { get; }
    public string PersisterQualifiedName { get; }
    public string CollectionType { get; }
    public Nullable`1<HbmCollectionFetchMode> FetchMode { get; }
    public Nullable`1<HbmOuterJoinStrategy> OuterJoin { get; }
    public Nullable`1<HbmCollectionLazy> Lazy { get; }
    public string Table { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Check { get; }
    public object ElementRelationship { get; }
    public string Sort { get; }
    public Nullable`1<bool> Generic { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFilter> Filters { get; }
    public HbmKey Key { get; }
    public HbmCache Cache { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual string get_Cascade();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual HbmCustomSQL get_SqlDeleteAll();
    public sealed virtual string get_Subselect();
    public sealed virtual bool get_Inverse();
    public sealed virtual bool get_Mutable();
    public sealed virtual string get_OrderBy();
    public sealed virtual string get_Where();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual string get_PersisterQualifiedName();
    public sealed virtual string get_CollectionType();
    public sealed virtual Nullable`1<HbmCollectionFetchMode> get_FetchMode();
    public sealed virtual Nullable`1<HbmOuterJoinStrategy> get_OuterJoin();
    public sealed virtual Nullable`1<HbmCollectionLazy> get_Lazy();
    public sealed virtual string get_Table();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Catalog();
    public sealed virtual string get_Check();
    public sealed virtual object get_ElementRelationship();
    public sealed virtual string get_Sort();
    public sealed virtual Nullable`1<bool> get_Generic();
    public sealed virtual IEnumerable`1<HbmFilter> get_Filters();
    public sealed virtual HbmKey get_Key();
    public sealed virtual HbmCache get_Cache();
}
public abstract class NHibernate.Cfg.MappingSchema.HbmBase : object {
    protected static T Find(Object[] array);
    protected static T[] FindAll(Object[] array);
    protected static string JoinString(String[] text);
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("cache")]
public class NHibernate.Cfg.MappingSchema.HbmCache : object {
    [XmlAttributeAttribute]
public HbmCacheUsage usage;
    [XmlAttributeAttribute]
public string region;
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmCacheInclude include;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmCacheInclude : Enum {
    public int value__;
    [XmlEnumAttribute("all")]
public static HbmCacheInclude All;
    [XmlEnumAttribute("non-lazy")]
public static HbmCacheInclude NonLazy;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmCacheMode : Enum {
    public int value__;
    [XmlEnumAttribute("get")]
public static HbmCacheMode Get;
    [XmlEnumAttribute("ignore")]
public static HbmCacheMode Ignore;
    [XmlEnumAttribute("normal")]
public static HbmCacheMode Normal;
    [XmlEnumAttribute("put")]
public static HbmCacheMode Put;
    [XmlEnumAttribute("refresh")]
public static HbmCacheMode Refresh;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmCacheUsage : Enum {
    public int value__;
    [XmlEnumAttribute("read-only")]
public static HbmCacheUsage ReadOnly;
    [XmlEnumAttribute("read-write")]
public static HbmCacheUsage ReadWrite;
    [XmlEnumAttribute("nonstrict-read-write")]
public static HbmCacheUsage NonstrictReadWrite;
    [XmlEnumAttribute("transactional")]
public static HbmCacheUsage Transactional;
    [XmlEnumAttribute("never")]
public static HbmCacheUsage Never;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("class")]
public class NHibernate.Cfg.MappingSchema.HbmClass : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    public HbmCache cache;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    [XmlElementAttribute("tuplizer")]
public HbmTuplizer[] tuplizer;
    [XmlElementAttribute("composite-id", "NHibernate.Cfg.MappingSchema.HbmCompositeId")]
[XmlElementAttribute("id", "NHibernate.Cfg.MappingSchema.HbmId")]
public object Item;
    public HbmDiscriminator discriminator;
    [XmlElementAttribute("natural-id")]
public HbmNaturalId naturalid;
    [XmlElementAttribute("timestamp", "NHibernate.Cfg.MappingSchema.HbmTimestamp")]
[XmlElementAttribute("version", "NHibernate.Cfg.MappingSchema.HbmVersion")]
public object Item1;
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("array", "NHibernate.Cfg.MappingSchema.HbmArray")]
[XmlElementAttribute("bag", "NHibernate.Cfg.MappingSchema.HbmBag")]
[XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("idbag", "NHibernate.Cfg.MappingSchema.HbmIdbag")]
[XmlElementAttribute("list", "NHibernate.Cfg.MappingSchema.HbmList")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("map", "NHibernate.Cfg.MappingSchema.HbmMap")]
[XmlElementAttribute("one-to-one", "NHibernate.Cfg.MappingSchema.HbmOneToOne")]
[XmlElementAttribute("primitive-array", "NHibernate.Cfg.MappingSchema.HbmPrimitiveArray")]
[XmlElementAttribute("properties", "NHibernate.Cfg.MappingSchema.HbmProperties")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
[XmlElementAttribute("set", "NHibernate.Cfg.MappingSchema.HbmSet")]
public Object[] Items;
    [XmlElementAttribute("join", "NHibernate.Cfg.MappingSchema.HbmJoin")]
[XmlElementAttribute("joined-subclass", "NHibernate.Cfg.MappingSchema.HbmJoinedSubclass")]
[XmlElementAttribute("subclass", "NHibernate.Cfg.MappingSchema.HbmSubclass")]
[XmlElementAttribute("union-subclass", "NHibernate.Cfg.MappingSchema.HbmUnionSubclass")]
public Object[] Items1;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlElementAttribute("resultset")]
public HbmResultSet[] resultset;
    [XmlElementAttribute("query", "NHibernate.Cfg.MappingSchema.HbmQuery")]
[XmlElementAttribute("sql-query", "NHibernate.Cfg.MappingSchema.HbmSqlQuery")]
public Object[] Items2;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string proxy;
    [XmlAttributeAttribute]
public bool lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute("schema-action")]
public string schemaaction;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute("discriminator-value")]
public string discriminatorvalue;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool mutable;
    [XmlAttributeAttribute]
public bool abstract;
    [XmlIgnoreAttribute]
public bool abstractSpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmPolymorphismType polymorphism;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("dynamic-update")]
[DefaultValueAttribute("False")]
public bool dynamicupdate;
    [XmlAttributeAttribute("dynamic-insert")]
[DefaultValueAttribute("False")]
public bool dynamicinsert;
    [XmlAttributeAttribute("batch-size")]
public int batchsize;
    [XmlIgnoreAttribute]
public bool batchsizeSpecified;
    [XmlAttributeAttribute("select-before-update")]
[DefaultValueAttribute("False")]
public bool selectbeforeupdate;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmOptimisticLockMode optimisticlock;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute]
public string rowid;
    [XmlAttributeAttribute]
public string node;
    public HbmId Id { get; }
    public HbmCompositeId CompositeId { get; }
    public HbmVersion Version { get; }
    public HbmTimestamp Timestamp { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmJoin> Joins { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmSubclass> Subclasses { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmJoinedSubclass> JoinedSubclasses { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmUnionSubclass> UnionSubclasses { get; }
    protected HbmMeta[] Metadatas { get; }
    public string EntityName { get; }
    public string Name { get; }
    public string Node { get; }
    public string Proxy { get; }
    public Nullable`1<bool> UseLazy { get; }
    public HbmTuplizer[] Tuplizers { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public Nullable`1<int> BatchSize { get; }
    public bool SelectBeforeUpdate { get; }
    public string Persister { get; }
    public Nullable`1<bool> IsAbstract { get; }
    public HbmSynchronize[] Synchronize { get; }
    public string DiscriminatorValue { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public string Subselect { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public HbmId get_Id();
    public HbmCompositeId get_CompositeId();
    public HbmVersion get_Version();
    public HbmTimestamp get_Timestamp();
    public IEnumerable`1<HbmJoin> get_Joins();
    public IEnumerable`1<HbmSubclass> get_Subclasses();
    public IEnumerable`1<HbmJoinedSubclass> get_JoinedSubclasses();
    public IEnumerable`1<HbmUnionSubclass> get_UnionSubclasses();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Name();
    public sealed virtual string get_Node();
    public sealed virtual string get_Proxy();
    public sealed virtual Nullable`1<bool> get_UseLazy();
    public sealed virtual HbmTuplizer[] get_Tuplizers();
    public sealed virtual bool get_DynamicUpdate();
    public sealed virtual bool get_DynamicInsert();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual bool get_SelectBeforeUpdate();
    public sealed virtual string get_Persister();
    public sealed virtual Nullable`1<bool> get_IsAbstract();
    public sealed virtual HbmSynchronize[] get_Synchronize();
    public sealed virtual string get_DiscriminatorValue();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual string get_Subselect();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode : Enum {
    public int value__;
    [XmlEnumAttribute("select")]
public static HbmCollectionFetchMode Select;
    [XmlEnumAttribute("join")]
public static HbmCollectionFetchMode Join;
    [XmlEnumAttribute("subselect")]
public static HbmCollectionFetchMode Subselect;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("collection-id")]
public class NHibernate.Cfg.MappingSchema.HbmCollectionId : object {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    public HbmGenerator generator;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute]
public string type;
    [XmlAttributeAttribute]
public string length;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    public HbmType Type { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmCollectionId/<AsColumns>d__8")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual HbmType get_Type();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmCollectionLazy : Enum {
    public int value__;
    [XmlEnumAttribute("true")]
public static HbmCollectionLazy True;
    [XmlEnumAttribute("false")]
public static HbmCollectionLazy False;
    [XmlEnumAttribute("extra")]
public static HbmCollectionLazy Extra;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("column")]
public class NHibernate.Cfg.MappingSchema.HbmColumn : object {
    public HbmComment comment;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string length;
    [XmlAttributeAttribute]
public string precision;
    [XmlAttributeAttribute]
public string scale;
    [XmlAttributeAttribute("not-null")]
public bool notnull;
    [XmlIgnoreAttribute]
public bool notnullSpecified;
    [XmlAttributeAttribute]
public bool unique;
    [XmlIgnoreAttribute]
public bool uniqueSpecified;
    [XmlAttributeAttribute("unique-key")]
public string uniquekey;
    [XmlAttributeAttribute("sql-type")]
public string sqltype;
    [XmlAttributeAttribute]
public string index;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute]
public string default;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("comment")]
public class NHibernate.Cfg.MappingSchema.HbmComment : object {
    [XmlTextAttribute]
public String[] Text;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("component")]
public class NHibernate.Cfg.MappingSchema.HbmComponent : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("tuplizer")]
public HbmTuplizer[] tuplizer;
    public HbmParent parent;
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("array", "NHibernate.Cfg.MappingSchema.HbmArray")]
[XmlElementAttribute("bag", "NHibernate.Cfg.MappingSchema.HbmBag")]
[XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("idbag", "NHibernate.Cfg.MappingSchema.HbmIdbag")]
[XmlElementAttribute("list", "NHibernate.Cfg.MappingSchema.HbmList")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("map", "NHibernate.Cfg.MappingSchema.HbmMap")]
[XmlElementAttribute("one-to-one", "NHibernate.Cfg.MappingSchema.HbmOneToOne")]
[XmlElementAttribute("primitive-array", "NHibernate.Cfg.MappingSchema.HbmPrimitiveArray")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
[XmlElementAttribute("set", "NHibernate.Cfg.MappingSchema.HbmSet")]
public Object[] Items;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool unique;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool update;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool insert;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool lazy;
    [XmlAttributeAttribute("lazy-group")]
public string lazygroup;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    public string Class { get; }
    public HbmParent Parent { get; }
    public string EmbeddedNode { get; }
    public bool IsLazyProperty { get; }
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    protected HbmMeta[] Metadatas { get; }
    public sealed virtual string get_Class();
    public sealed virtual HbmParent get_Parent();
    public sealed virtual string get_EmbeddedNode();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
    protected virtual HbmMeta[] get_Metadatas();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("composite-element")]
public class NHibernate.Cfg.MappingSchema.HbmCompositeElement : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmParent parent;
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("nested-composite-element", "NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
public Object[] Items;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute]
public string node;
    public string Class { get; }
    public HbmParent Parent { get; }
    public string EmbeddedNode { get; }
    public string Name { get; }
    protected HbmMeta[] Metadatas { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public sealed virtual string get_Class();
    public sealed virtual HbmParent get_Parent();
    public sealed virtual string get_EmbeddedNode();
    public sealed virtual string get_Name();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("composite-id")]
public class NHibernate.Cfg.MappingSchema.HbmCompositeId : object {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("key-many-to-one", "NHibernate.Cfg.MappingSchema.HbmKeyManyToOne")]
[XmlElementAttribute("key-property", "NHibernate.Cfg.MappingSchema.HbmKeyProperty")]
public Object[] Items;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool mapped;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute("unsaved-value")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmUnsavedValueType unsavedvalue;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("composite-index")]
public class NHibernate.Cfg.MappingSchema.HbmCompositeIndex : object {
    [XmlElementAttribute("key-many-to-one", "NHibernate.Cfg.MappingSchema.HbmKeyManyToOne")]
[XmlElementAttribute("key-property", "NHibernate.Cfg.MappingSchema.HbmKeyProperty")]
public Object[] Items;
    [XmlAttributeAttribute]
public string class;
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public string Class { get; }
    public HbmParent Parent { get; }
    public string EmbeddedNode { get; }
    public string Name { get; }
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
    public sealed virtual string get_Class();
    public sealed virtual HbmParent get_Parent();
    public sealed virtual string get_EmbeddedNode();
    public sealed virtual string get_Name();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("composite-map-key")]
public class NHibernate.Cfg.MappingSchema.HbmCompositeMapKey : object {
    [XmlElementAttribute("key-many-to-one", "NHibernate.Cfg.MappingSchema.HbmKeyManyToOne")]
[XmlElementAttribute("key-property", "NHibernate.Cfg.MappingSchema.HbmKeyProperty")]
public Object[] Items;
    [XmlAttributeAttribute]
public string class;
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public string Class { get; }
    public HbmParent Parent { get; }
    public string EmbeddedNode { get; }
    public string Name { get; }
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
    public sealed virtual string get_Class();
    public sealed virtual HbmParent get_Parent();
    public sealed virtual string get_EmbeddedNode();
    public sealed virtual string get_Name();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("create")]
public class NHibernate.Cfg.MappingSchema.HbmCreate : object {
    [XmlTextAttribute]
public String[] Text;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("sql-delete")]
public class NHibernate.Cfg.MappingSchema.HbmCustomSQL : object {
    [XmlAttributeAttribute]
public bool callable;
    [XmlIgnoreAttribute]
public bool callableSpecified;
    [XmlAttributeAttribute]
public HbmCustomSQLCheck check;
    [XmlIgnoreAttribute]
public bool checkSpecified;
    [XmlTextAttribute]
public String[] Text;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck : Enum {
    public int value__;
    [XmlEnumAttribute("none")]
public static HbmCustomSQLCheck None;
    [XmlEnumAttribute("rowcount")]
public static HbmCustomSQLCheck Rowcount;
    [XmlEnumAttribute("param")]
public static HbmCustomSQLCheck Param;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("database-object")]
public class NHibernate.Cfg.MappingSchema.HbmDatabaseObject : HbmBase {
    [XmlElementAttribute("create", "NHibernate.Cfg.MappingSchema.HbmCreate")]
[XmlElementAttribute("definition", "NHibernate.Cfg.MappingSchema.HbmDefinition")]
[XmlElementAttribute("drop", "NHibernate.Cfg.MappingSchema.HbmDrop")]
public Object[] Items;
    [XmlElementAttribute("dialect-scope")]
public HbmDialectScope[] dialectscope;
    public string FindCreateText();
    public HbmDefinition FindDefinition();
    public IList`1<string> FindDialectScopeNames();
    public string FindDropText();
    public bool HasDefinition();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("definition")]
public class NHibernate.Cfg.MappingSchema.HbmDefinition : HbmBase {
    [XmlElementAttribute("param")]
public HbmParam[] param;
    [XmlAttributeAttribute]
public string class;
    public IDictionary`2<string, string> FindParameterValues();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("dialect-scope")]
public class NHibernate.Cfg.MappingSchema.HbmDialectScope : object {
    [XmlAttributeAttribute]
public string name;
    [XmlTextAttribute]
public String[] Text;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("discriminator")]
public class NHibernate.Cfg.MappingSchema.HbmDiscriminator : object {
    [XmlElementAttribute("column", "NHibernate.Cfg.MappingSchema.HbmColumn")]
[XmlElementAttribute("formula", "NHibernate.Cfg.MappingSchema.HbmFormula")]
public object Item;
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute]
public string formula;
    [XmlAttributeAttribute]
[DefaultValueAttribute("string")]
public string type;
    [XmlAttributeAttribute("not-null")]
[DefaultValueAttribute("True")]
public bool notnull;
    [XmlAttributeAttribute]
public string length;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool force;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool insert;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFormula> Formulas { get; }
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmDiscriminator/<get_Columns>d__10")]
public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmDiscriminator/<get_Formulas>d__12")]
public sealed virtual IEnumerable`1<HbmFormula> get_Formulas();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("drop")]
public class NHibernate.Cfg.MappingSchema.HbmDrop : object {
    [XmlTextAttribute]
public String[] Text;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("dynamic-component")]
public class NHibernate.Cfg.MappingSchema.HbmDynamicComponent : AbstractDecoratable {
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("array", "NHibernate.Cfg.MappingSchema.HbmArray")]
[XmlElementAttribute("bag", "NHibernate.Cfg.MappingSchema.HbmBag")]
[XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("list", "NHibernate.Cfg.MappingSchema.HbmList")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("map", "NHibernate.Cfg.MappingSchema.HbmMap")]
[XmlElementAttribute("one-to-one", "NHibernate.Cfg.MappingSchema.HbmOneToOne")]
[XmlElementAttribute("primitive-array", "NHibernate.Cfg.MappingSchema.HbmPrimitiveArray")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
[XmlElementAttribute("set", "NHibernate.Cfg.MappingSchema.HbmSet")]
public Object[] Items;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool unique;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool update;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool insert;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    public string Class { get; }
    public HbmParent Parent { get; }
    public bool IsLazyProperty { get; }
    public string EmbeddedNode { get; }
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    protected HbmMeta[] Metadatas { get; }
    public sealed virtual string get_Class();
    public sealed virtual HbmParent get_Parent();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual string get_EmbeddedNode();
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
    protected virtual HbmMeta[] get_Metadatas();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("element")]
public class NHibernate.Cfg.MappingSchema.HbmElement : object {
    [XmlElementAttribute("column", "NHibernate.Cfg.MappingSchema.HbmColumn")]
[XmlElementAttribute("formula", "NHibernate.Cfg.MappingSchema.HbmFormula")]
public Object[] Items;
    public HbmType type;
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public string formula;
    [XmlAttributeAttribute("type")]
public string type1;
    [XmlAttributeAttribute]
public string length;
    [XmlAttributeAttribute]
public string precision;
    [XmlAttributeAttribute]
public string scale;
    [XmlAttributeAttribute("not-null")]
[DefaultValueAttribute("False")]
public bool notnull;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool unique;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFormula> Formulas { get; }
    public HbmType Type { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<object> ColumnsAndFormulas { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmElement/<AsColumns>d__14")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual IEnumerable`1<HbmFormula> get_Formulas();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmElement/<AsFormulas>d__17")]
private IEnumerable`1<HbmFormula> AsFormulas();
    public sealed virtual HbmType get_Type();
    public IEnumerable`1<object> get_ColumnsAndFormulas();
}
[ExtensionAttribute]
public static class NHibernate.Cfg.MappingSchema.HbmExtensions : object {
    [ExtensionAttribute]
public static OptimisticLock ToOptimisticLock(HbmOptimisticLockMode hbmOptimisticLockMode);
    [ExtensionAttribute]
public static string ToNullValue(HbmUnsavedValueType unsavedValueType);
    [ExtensionAttribute]
public static string ToCacheConcurrencyStrategy(HbmCacheUsage cacheUsage);
    [ExtensionAttribute]
public static Nullable`1<CacheMode> ToCacheMode(HbmCacheMode cacheMode);
    [ExtensionAttribute]
public static string JoinString(String[] source);
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmFetchMode : Enum {
    public int value__;
    [XmlEnumAttribute("select")]
public static HbmFetchMode Select;
    [XmlEnumAttribute("join")]
public static HbmFetchMode Join;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("filter")]
public class NHibernate.Cfg.MappingSchema.HbmFilter : object {
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string condition;
    [XmlTextAttribute]
public String[] Text;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("filter-def")]
public class NHibernate.Cfg.MappingSchema.HbmFilterDef : HbmBase {
    [XmlElementAttribute("filter-param")]
public HbmFilterParam[] Items;
    [XmlTextAttribute]
public String[] Text;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string condition;
    [XmlAttributeAttribute("use-many-to-one")]
[DefaultValueAttribute("True")]
public bool usemanytoone;
    public string GetDefaultCondition();
    public HbmFilterParam[] ListParameters();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("filter-param")]
public class NHibernate.Cfg.MappingSchema.HbmFilterParam : object {
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string type;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmFlushMode : Enum {
    public int value__;
    [XmlEnumAttribute("auto")]
public static HbmFlushMode Auto;
    [XmlEnumAttribute("manual")]
public static HbmFlushMode Manual;
    [XmlEnumAttribute("always")]
public static HbmFlushMode Always;
    [XmlEnumAttribute("never")]
public static HbmFlushMode Never;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("formula")]
public class NHibernate.Cfg.MappingSchema.HbmFormula : object {
    [XmlTextAttribute]
public String[] Text;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("generator")]
public class NHibernate.Cfg.MappingSchema.HbmGenerator : object {
    [XmlElementAttribute("param")]
public HbmParam[] param;
    [XmlAttributeAttribute]
public string class;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("id")]
public class NHibernate.Cfg.MappingSchema.HbmId : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    public HbmType type;
    public HbmGenerator generator;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute("type")]
public string type1;
    [XmlAttributeAttribute]
public string length;
    [XmlAttributeAttribute("unsaved-value")]
public string unsavedvalue;
    [XmlAttributeAttribute("generator")]
public string generator1;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmType Type { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmId/<AsColumns>d__14")]
private IEnumerable`1<HbmColumn> AsColumns();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual HbmType get_Type();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("idbag")]
public class NHibernate.Cfg.MappingSchema.HbmIdbag : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    public HbmCache cache;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    [XmlElementAttribute("collection-id")]
public HbmCollectionId collectionid;
    public HbmKey key;
    [XmlElementAttribute("composite-element", "NHibernate.Cfg.MappingSchema.HbmCompositeElement")]
[XmlElementAttribute("element", "NHibernate.Cfg.MappingSchema.HbmElement")]
[XmlElementAttribute("many-to-any", "NHibernate.Cfg.MappingSchema.HbmManyToAny")]
[XmlElementAttribute("many-to-many", "NHibernate.Cfg.MappingSchema.HbmManyToMany")]
public object Item;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("sql-delete-all")]
public HbmCustomSQL sqldeleteall;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute]
public HbmCollectionLazy lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool inverse;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool mutable;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute("order-by")]
public string orderby;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute("batch-size")]
public int batchsize;
    [XmlIgnoreAttribute]
public bool batchsizeSpecified;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmCollectionFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("collection-type")]
public string collectiontype;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public bool generic;
    [XmlIgnoreAttribute]
public bool genericSpecified;
    public string Name { get; }
    public string Access { get; }
    public bool IsLazyProperty { get; }
    public bool OptimisticLock { get; }
    public string Cascade { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public HbmCustomSQL SqlDeleteAll { get; }
    public string Subselect { get; }
    public bool Inverse { get; }
    public bool Mutable { get; }
    public string OrderBy { get; }
    public string Where { get; }
    public Nullable`1<int> BatchSize { get; }
    public string PersisterQualifiedName { get; }
    public string CollectionType { get; }
    public Nullable`1<HbmCollectionFetchMode> FetchMode { get; }
    public Nullable`1<HbmOuterJoinStrategy> OuterJoin { get; }
    public Nullable`1<HbmCollectionLazy> Lazy { get; }
    public string Table { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Check { get; }
    public object ElementRelationship { get; }
    public string Sort { get; }
    public Nullable`1<bool> Generic { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFilter> Filters { get; }
    public HbmKey Key { get; }
    public HbmCache Cache { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual string get_Cascade();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual HbmCustomSQL get_SqlDeleteAll();
    public sealed virtual string get_Subselect();
    public sealed virtual bool get_Inverse();
    public sealed virtual bool get_Mutable();
    public sealed virtual string get_OrderBy();
    public sealed virtual string get_Where();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual string get_PersisterQualifiedName();
    public sealed virtual string get_CollectionType();
    public sealed virtual Nullable`1<HbmCollectionFetchMode> get_FetchMode();
    public sealed virtual Nullable`1<HbmOuterJoinStrategy> get_OuterJoin();
    public sealed virtual Nullable`1<HbmCollectionLazy> get_Lazy();
    public sealed virtual string get_Table();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Catalog();
    public sealed virtual string get_Check();
    public sealed virtual object get_ElementRelationship();
    public sealed virtual string get_Sort();
    public sealed virtual Nullable`1<bool> get_Generic();
    public sealed virtual IEnumerable`1<HbmFilter> get_Filters();
    public sealed virtual HbmKey get_Key();
    public sealed virtual HbmCache get_Cache();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("import")]
public class NHibernate.Cfg.MappingSchema.HbmImport : object {
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute]
public string rename;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("index")]
public class NHibernate.Cfg.MappingSchema.HbmIndex : object {
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute]
public string type;
    [XmlAttributeAttribute]
public string length;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    public HbmType Type { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmIndex/<AsColumns>d__6")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual HbmType get_Type();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("index-many-to-any")]
public class NHibernate.Cfg.MappingSchema.HbmIndexManyToAny : object {
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    [XmlAttributeAttribute("id-type")]
public string idtype;
    [XmlAttributeAttribute("meta-type")]
public string metatype;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    public string MetaType { get; }
    public ICollection`1<HbmMetaValue> MetaValues { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmIndexManyToAny/<AsColumns>d__6")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual string get_MetaType();
    public sealed virtual ICollection`1<HbmMetaValue> get_MetaValues();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("index-many-to-many")]
public class NHibernate.Cfg.MappingSchema.HbmIndexManyToMany : object {
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute("foreign-key")]
public string foreignkey;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    public string EntityName { get; }
    public string Class { get; }
    public HbmNotFoundMode NotFoundMode { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmIndexManyToMany/<AsColumns>d__7")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Class();
    public sealed virtual HbmNotFoundMode get_NotFoundMode();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("join")]
public class NHibernate.Cfg.MappingSchema.HbmJoin : object {
    public HbmSubselect subselect;
    public HbmComment comment;
    public HbmKey key;
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("array", "NHibernate.Cfg.MappingSchema.HbmArray")]
[XmlElementAttribute("bag", "NHibernate.Cfg.MappingSchema.HbmBag")]
[XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("idbag", "NHibernate.Cfg.MappingSchema.HbmIdbag")]
[XmlElementAttribute("list", "NHibernate.Cfg.MappingSchema.HbmList")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("map", "NHibernate.Cfg.MappingSchema.HbmMap")]
[XmlElementAttribute("primitive-array", "NHibernate.Cfg.MappingSchema.HbmPrimitiveArray")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
[XmlElementAttribute("set", "NHibernate.Cfg.MappingSchema.HbmSet")]
public Object[] Items;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmJoinFetch fetch;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool inverse;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool optional;
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public string Subselect { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual string get_Subselect();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("joined-subclass")]
public class NHibernate.Cfg.MappingSchema.HbmJoinedSubclass : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    [XmlElementAttribute("tuplizer")]
public HbmTuplizer[] tuplizer;
    public HbmKey key;
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("array", "NHibernate.Cfg.MappingSchema.HbmArray")]
[XmlElementAttribute("bag", "NHibernate.Cfg.MappingSchema.HbmBag")]
[XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("idbag", "NHibernate.Cfg.MappingSchema.HbmIdbag")]
[XmlElementAttribute("list", "NHibernate.Cfg.MappingSchema.HbmList")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("map", "NHibernate.Cfg.MappingSchema.HbmMap")]
[XmlElementAttribute("one-to-one", "NHibernate.Cfg.MappingSchema.HbmOneToOne")]
[XmlElementAttribute("primitive-array", "NHibernate.Cfg.MappingSchema.HbmPrimitiveArray")]
[XmlElementAttribute("properties", "NHibernate.Cfg.MappingSchema.HbmProperties")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
[XmlElementAttribute("set", "NHibernate.Cfg.MappingSchema.HbmSet")]
public Object[] Items;
    [XmlElementAttribute("joined-subclass")]
public HbmJoinedSubclass[] joinedsubclass1;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("resultset")]
public HbmResultSet[] resultset;
    [XmlElementAttribute("query", "NHibernate.Cfg.MappingSchema.HbmQuery")]
[XmlElementAttribute("sql-query", "NHibernate.Cfg.MappingSchema.HbmSqlQuery")]
public Object[] Items1;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string proxy;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute("schema-action")]
public string schemaaction;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute("dynamic-update")]
[DefaultValueAttribute("False")]
public bool dynamicupdate;
    [XmlAttributeAttribute("dynamic-insert")]
[DefaultValueAttribute("False")]
public bool dynamicinsert;
    [XmlAttributeAttribute("select-before-update")]
[DefaultValueAttribute("False")]
public bool selectbeforeupdate;
    [XmlAttributeAttribute]
public string extends;
    [XmlAttributeAttribute]
public bool lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
public bool abstract;
    [XmlIgnoreAttribute]
public bool abstractSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("batch-size")]
public string batchsize;
    [XmlAttributeAttribute]
public string node;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmJoinedSubclass> JoinedSubclasses { get; }
    protected HbmMeta[] Metadatas { get; }
    public string EntityName { get; }
    public string Name { get; }
    public string Node { get; }
    public string Proxy { get; }
    public Nullable`1<bool> UseLazy { get; }
    public HbmTuplizer[] Tuplizers { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public Nullable`1<int> BatchSize { get; }
    public bool SelectBeforeUpdate { get; }
    public string Persister { get; }
    public Nullable`1<bool> IsAbstract { get; }
    public HbmSynchronize[] Synchronize { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public string Subselect { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public IEnumerable`1<HbmJoinedSubclass> get_JoinedSubclasses();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Name();
    public sealed virtual string get_Node();
    public sealed virtual string get_Proxy();
    public sealed virtual Nullable`1<bool> get_UseLazy();
    public sealed virtual HbmTuplizer[] get_Tuplizers();
    public sealed virtual bool get_DynamicUpdate();
    public sealed virtual bool get_DynamicInsert();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual bool get_SelectBeforeUpdate();
    public sealed virtual string get_Persister();
    public sealed virtual Nullable`1<bool> get_IsAbstract();
    public sealed virtual HbmSynchronize[] get_Synchronize();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual string get_Subselect();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmJoinFetch : Enum {
    public int value__;
    [XmlEnumAttribute("join")]
public static HbmJoinFetch Join;
    [XmlEnumAttribute("select")]
public static HbmJoinFetch Select;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("key")]
public class NHibernate.Cfg.MappingSchema.HbmKey : object {
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute("property-ref")]
public string propertyref;
    [XmlAttributeAttribute("foreign-key")]
public string foreignkey;
    [XmlAttributeAttribute("on-delete")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmOndelete ondelete;
    [XmlAttributeAttribute("not-null")]
public bool notnull;
    [XmlIgnoreAttribute]
public bool notnullSpecified;
    [XmlAttributeAttribute]
public bool update;
    [XmlIgnoreAttribute]
public bool updateSpecified;
    [XmlAttributeAttribute]
public bool unique;
    [XmlIgnoreAttribute]
public bool uniqueSpecified;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    public Nullable`1<bool> IsNullable { get; }
    public Nullable`1<bool> IsUpdatable { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmKey/<AsColumns>d__14")]
private IEnumerable`1<HbmColumn> AsColumns();
    public Nullable`1<bool> get_IsNullable();
    public Nullable`1<bool> get_IsUpdatable();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("key-many-to-one")]
public class NHibernate.Cfg.MappingSchema.HbmKeyManyToOne : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute("foreign-key")]
public string foreignkey;
    [XmlAttributeAttribute]
public HbmRestrictedLaziness lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute("not-found")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmNotFoundMode notfound;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    protected HbmMeta[] Metadatas { get; }
    public Nullable`1<HbmRestrictedLaziness> Lazy { get; }
    public string EntityName { get; }
    public string Class { get; }
    public HbmNotFoundMode NotFoundMode { get; }
    public string Name { get; }
    public bool IsLazyProperty { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmKeyManyToOne/<AsColumns>d__14")]
private IEnumerable`1<HbmColumn> AsColumns();
    protected virtual HbmMeta[] get_Metadatas();
    public Nullable`1<HbmRestrictedLaziness> get_Lazy();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Class();
    public sealed virtual HbmNotFoundMode get_NotFoundMode();
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("key-property")]
public class NHibernate.Cfg.MappingSchema.HbmKeyProperty : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    public HbmType type;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute("type")]
public string type1;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute]
public string length;
    [XmlAttributeAttribute]
public string node;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    public HbmType Type { get; }
    protected HbmMeta[] Metadatas { get; }
    public string Name { get; }
    public bool IsLazyProperty { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmKeyProperty/<AsColumns>d__11")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual HbmType get_Type();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmLaziness : Enum {
    public int value__;
    [XmlEnumAttribute("false")]
public static HbmLaziness False;
    [XmlEnumAttribute("proxy")]
public static HbmLaziness Proxy;
    [XmlEnumAttribute("no-proxy")]
public static HbmLaziness NoProxy;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("list")]
public class NHibernate.Cfg.MappingSchema.HbmList : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    public HbmCache cache;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    public HbmKey key;
    [XmlElementAttribute("index", "NHibernate.Cfg.MappingSchema.HbmIndex")]
[XmlElementAttribute("list-index", "NHibernate.Cfg.MappingSchema.HbmListIndex")]
public object Item;
    [XmlElementAttribute("composite-element", "NHibernate.Cfg.MappingSchema.HbmCompositeElement")]
[XmlElementAttribute("element", "NHibernate.Cfg.MappingSchema.HbmElement")]
[XmlElementAttribute("many-to-any", "NHibernate.Cfg.MappingSchema.HbmManyToAny")]
[XmlElementAttribute("many-to-many", "NHibernate.Cfg.MappingSchema.HbmManyToMany")]
[XmlElementAttribute("one-to-many", "NHibernate.Cfg.MappingSchema.HbmOneToMany")]
public object Item1;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("sql-delete-all")]
public HbmCustomSQL sqldeleteall;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute]
public HbmCollectionLazy lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool inverse;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool mutable;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute("order-by")]
public string orderby;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute("batch-size")]
public int batchsize;
    [XmlIgnoreAttribute]
public bool batchsizeSpecified;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmCollectionFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("collection-type")]
public string collectiontype;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public bool generic;
    [XmlIgnoreAttribute]
public bool genericSpecified;
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    public bool IsLazyProperty { get; }
    public string Cascade { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public HbmCustomSQL SqlDeleteAll { get; }
    public string Subselect { get; }
    public HbmListIndex ListIndex { get; }
    public HbmIndex Index { get; }
    public bool Inverse { get; }
    public bool Mutable { get; }
    public string OrderBy { get; }
    public string Where { get; }
    public Nullable`1<int> BatchSize { get; }
    public string PersisterQualifiedName { get; }
    public string CollectionType { get; }
    public Nullable`1<HbmCollectionFetchMode> FetchMode { get; }
    public Nullable`1<HbmOuterJoinStrategy> OuterJoin { get; }
    public Nullable`1<HbmCollectionLazy> Lazy { get; }
    public string Table { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Check { get; }
    public object ElementRelationship { get; }
    public string Sort { get; }
    public Nullable`1<bool> Generic { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFilter> Filters { get; }
    public HbmKey Key { get; }
    public HbmCache Cache { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual string get_Cascade();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual HbmCustomSQL get_SqlDeleteAll();
    public sealed virtual string get_Subselect();
    public sealed virtual HbmListIndex get_ListIndex();
    public sealed virtual HbmIndex get_Index();
    public sealed virtual bool get_Inverse();
    public sealed virtual bool get_Mutable();
    public sealed virtual string get_OrderBy();
    public sealed virtual string get_Where();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual string get_PersisterQualifiedName();
    public sealed virtual string get_CollectionType();
    public sealed virtual Nullable`1<HbmCollectionFetchMode> get_FetchMode();
    public sealed virtual Nullable`1<HbmOuterJoinStrategy> get_OuterJoin();
    public sealed virtual Nullable`1<HbmCollectionLazy> get_Lazy();
    public sealed virtual string get_Table();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Catalog();
    public sealed virtual string get_Check();
    public sealed virtual object get_ElementRelationship();
    public sealed virtual string get_Sort();
    public sealed virtual Nullable`1<bool> get_Generic();
    public sealed virtual IEnumerable`1<HbmFilter> get_Filters();
    public sealed virtual HbmKey get_Key();
    public sealed virtual HbmCache get_Cache();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("list-index")]
public class NHibernate.Cfg.MappingSchema.HbmListIndex : object {
    public HbmColumn column;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute]
public string base;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmListIndex/<get_Columns>d__4")]
public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("load-collection")]
public class NHibernate.Cfg.MappingSchema.HbmLoadCollection : object {
    [XmlElementAttribute("return-property")]
public HbmReturnProperty[] returnproperty;
    [XmlAttributeAttribute]
public string alias;
    [XmlAttributeAttribute]
public string role;
    [XmlAttributeAttribute("lock-mode")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmLockMode lockmode;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("loader")]
public class NHibernate.Cfg.MappingSchema.HbmLoader : object {
    [XmlAttributeAttribute("query-ref")]
public string queryref;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmLockMode : Enum {
    public int value__;
    [XmlEnumAttribute("none")]
public static HbmLockMode None;
    [XmlEnumAttribute("read")]
public static HbmLockMode Read;
    [XmlEnumAttribute("upgrade")]
public static HbmLockMode Upgrade;
    [XmlEnumAttribute("upgrade-nowait")]
public static HbmLockMode UpgradeNowait;
    [XmlEnumAttribute("write")]
public static HbmLockMode Write;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("many-to-any")]
public class NHibernate.Cfg.MappingSchema.HbmManyToAny : object {
    [XmlElementAttribute("meta-value")]
public HbmMetaValue[] metavalue;
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute("id-type")]
public string idtype;
    [XmlAttributeAttribute("meta-type")]
public string metatype;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    public string MetaType { get; }
    public ICollection`1<HbmMetaValue> MetaValues { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmManyToAny/<AsColumns>d__7")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual string get_MetaType();
    public sealed virtual ICollection`1<HbmMetaValue> get_MetaValues();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("many-to-many")]
public class NHibernate.Cfg.MappingSchema.HbmManyToMany : object {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("column", "NHibernate.Cfg.MappingSchema.HbmColumn")]
[XmlElementAttribute("formula", "NHibernate.Cfg.MappingSchema.HbmFormula")]
public Object[] Items;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute]
public string formula;
    [XmlAttributeAttribute("not-found")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmNotFoundMode notfound;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
public HbmRestrictedLaziness lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute("foreign-key")]
public string foreignkey;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool unique;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute("order-by")]
public string orderby;
    [XmlAttributeAttribute("property-ref")]
public string propertyref;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFormula> Formulas { get; }
    public string EntityName { get; }
    public string Class { get; }
    public HbmNotFoundMode NotFoundMode { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<object> ColumnsAndFormulas { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmManyToMany/<AsColumns>d__23")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual IEnumerable`1<HbmFormula> get_Formulas();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmManyToMany/<AsFormulas>d__26")]
private IEnumerable`1<HbmFormula> AsFormulas();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Class();
    public sealed virtual HbmNotFoundMode get_NotFoundMode();
    public IEnumerable`1<object> get_ColumnsAndFormulas();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("many-to-one")]
public class NHibernate.Cfg.MappingSchema.HbmManyToOne : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("column", "NHibernate.Cfg.MappingSchema.HbmColumn")]
[XmlElementAttribute("formula", "NHibernate.Cfg.MappingSchema.HbmFormula")]
public Object[] Items;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute("not-null")]
public bool notnull;
    [XmlIgnoreAttribute]
public bool notnullSpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool unique;
    [XmlAttributeAttribute("unique-key")]
public string uniquekey;
    [XmlAttributeAttribute]
public string index;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool update;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool insert;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute("foreign-key")]
public string foreignkey;
    [XmlAttributeAttribute("property-ref")]
public string propertyref;
    [XmlAttributeAttribute]
public string formula;
    [XmlAttributeAttribute]
public HbmLaziness lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute("not-found")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmNotFoundMode notfound;
    [XmlAttributeAttribute]
public string node;
    public string Name { get; }
    public string Access { get; }
    public bool IsLazyProperty { get; }
    public bool OptimisticLock { get; }
    protected HbmMeta[] Metadatas { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFormula> Formulas { get; }
    public string EntityName { get; }
    public string Class { get; }
    public HbmNotFoundMode NotFoundMode { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<object> ColumnsAndFormulas { get; }
    public Nullable`1<HbmLaziness> Lazy { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual bool get_OptimisticLock();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmManyToOne/<AsColumns>d__40")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual IEnumerable`1<HbmFormula> get_Formulas();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmManyToOne/<AsFormulas>d__43")]
private IEnumerable`1<HbmFormula> AsFormulas();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Class();
    public sealed virtual HbmNotFoundMode get_NotFoundMode();
    public IEnumerable`1<object> get_ColumnsAndFormulas();
    public Nullable`1<HbmLaziness> get_Lazy();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("map")]
public class NHibernate.Cfg.MappingSchema.HbmMap : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    public HbmCache cache;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    public HbmKey key;
    [XmlElementAttribute("composite-index", "NHibernate.Cfg.MappingSchema.HbmCompositeIndex")]
[XmlElementAttribute("composite-map-key", "NHibernate.Cfg.MappingSchema.HbmCompositeMapKey")]
[XmlElementAttribute("index", "NHibernate.Cfg.MappingSchema.HbmIndex")]
[XmlElementAttribute("index-many-to-any", "NHibernate.Cfg.MappingSchema.HbmIndexManyToAny")]
[XmlElementAttribute("index-many-to-many", "NHibernate.Cfg.MappingSchema.HbmIndexManyToMany")]
[XmlElementAttribute("map-key", "NHibernate.Cfg.MappingSchema.HbmMapKey")]
[XmlElementAttribute("map-key-many-to-many", "NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany")]
public object Item;
    [XmlElementAttribute("composite-element", "NHibernate.Cfg.MappingSchema.HbmCompositeElement")]
[XmlElementAttribute("element", "NHibernate.Cfg.MappingSchema.HbmElement")]
[XmlElementAttribute("many-to-any", "NHibernate.Cfg.MappingSchema.HbmManyToAny")]
[XmlElementAttribute("many-to-many", "NHibernate.Cfg.MappingSchema.HbmManyToMany")]
[XmlElementAttribute("one-to-many", "NHibernate.Cfg.MappingSchema.HbmOneToMany")]
public object Item1;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("sql-delete-all")]
public HbmCustomSQL sqldeleteall;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute]
public HbmCollectionLazy lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool inverse;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool mutable;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute("order-by")]
public string orderby;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute("batch-size")]
public int batchsize;
    [XmlIgnoreAttribute]
public bool batchsizeSpecified;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmCollectionFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("collection-type")]
public string collectiontype;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public bool generic;
    [XmlIgnoreAttribute]
public bool genericSpecified;
    [XmlAttributeAttribute]
public string sort;
    public string Name { get; }
    public string Access { get; }
    public bool IsLazyProperty { get; }
    public bool OptimisticLock { get; }
    public string Cascade { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public HbmCustomSQL SqlDeleteAll { get; }
    public string Subselect { get; }
    public bool Inverse { get; }
    public bool Mutable { get; }
    public string OrderBy { get; }
    public string Where { get; }
    public Nullable`1<int> BatchSize { get; }
    public string PersisterQualifiedName { get; }
    public string CollectionType { get; }
    public Nullable`1<HbmCollectionFetchMode> FetchMode { get; }
    public Nullable`1<HbmOuterJoinStrategy> OuterJoin { get; }
    public Nullable`1<HbmCollectionLazy> Lazy { get; }
    public string Table { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Check { get; }
    public object ElementRelationship { get; }
    public string Sort { get; }
    public Nullable`1<bool> Generic { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFilter> Filters { get; }
    public HbmKey Key { get; }
    public HbmCache Cache { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual string get_Cascade();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual HbmCustomSQL get_SqlDeleteAll();
    public sealed virtual string get_Subselect();
    public sealed virtual bool get_Inverse();
    public sealed virtual bool get_Mutable();
    public sealed virtual string get_OrderBy();
    public sealed virtual string get_Where();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual string get_PersisterQualifiedName();
    public sealed virtual string get_CollectionType();
    public sealed virtual Nullable`1<HbmCollectionFetchMode> get_FetchMode();
    public sealed virtual Nullable`1<HbmOuterJoinStrategy> get_OuterJoin();
    public sealed virtual Nullable`1<HbmCollectionLazy> get_Lazy();
    public sealed virtual string get_Table();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Catalog();
    public sealed virtual string get_Check();
    public sealed virtual object get_ElementRelationship();
    public sealed virtual string get_Sort();
    public sealed virtual Nullable`1<bool> get_Generic();
    public sealed virtual IEnumerable`1<HbmFilter> get_Filters();
    public sealed virtual HbmKey get_Key();
    public sealed virtual HbmCache get_Cache();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("map-key")]
public class NHibernate.Cfg.MappingSchema.HbmMapKey : object {
    [XmlElementAttribute("column", "NHibernate.Cfg.MappingSchema.HbmColumn")]
[XmlElementAttribute("formula", "NHibernate.Cfg.MappingSchema.HbmFormula")]
public Object[] Items;
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute]
public string formula;
    [XmlAttributeAttribute]
public string type;
    [XmlAttributeAttribute]
public string length;
    [XmlAttributeAttribute]
public string node;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFormula> Formulas { get; }
    public HbmType Type { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<object> ColumnsAndFormulas { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmMapKey/<AsColumns>d__8")]
private IEnumerable`1<HbmColumn> AsColumns();
    public IEnumerable`1<HbmFormula> get_Formulas();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmMapKey/<AsFormulas>d__11")]
private IEnumerable`1<HbmFormula> AsFormulas();
    public sealed virtual HbmType get_Type();
    public IEnumerable`1<object> get_ColumnsAndFormulas();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("map-key-many-to-many")]
public class NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany : object {
    [XmlElementAttribute("column", "NHibernate.Cfg.MappingSchema.HbmColumn")]
[XmlElementAttribute("formula", "NHibernate.Cfg.MappingSchema.HbmFormula")]
public Object[] Items;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute]
public string formula;
    [XmlAttributeAttribute("foreign-key")]
public string foreignkey;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFormula> Formulas { get; }
    public string EntityName { get; }
    public string Class { get; }
    public HbmNotFoundMode NotFoundMode { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<object> ColumnsAndFormulas { get; }
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany/<AsColumns>d__8")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual IEnumerable`1<HbmFormula> get_Formulas();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany/<AsFormulas>d__11")]
private IEnumerable`1<HbmFormula> AsFormulas();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Class();
    public sealed virtual HbmNotFoundMode get_NotFoundMode();
    public IEnumerable`1<object> get_ColumnsAndFormulas();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("hibernate-mapping")]
public class NHibernate.Cfg.MappingSchema.HbmMapping : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("typedef")]
public HbmTypedef[] typedef;
    [XmlElementAttribute("import")]
public HbmImport[] import;
    [XmlElementAttribute("class", "NHibernate.Cfg.MappingSchema.HbmClass")]
[XmlElementAttribute("joined-subclass", "NHibernate.Cfg.MappingSchema.HbmJoinedSubclass")]
[XmlElementAttribute("subclass", "NHibernate.Cfg.MappingSchema.HbmSubclass")]
[XmlElementAttribute("union-subclass", "NHibernate.Cfg.MappingSchema.HbmUnionSubclass")]
public Object[] Items;
    [XmlElementAttribute("resultset")]
public HbmResultSet[] resultset;
    [XmlElementAttribute("query", "NHibernate.Cfg.MappingSchema.HbmQuery")]
[XmlElementAttribute("sql-query", "NHibernate.Cfg.MappingSchema.HbmSqlQuery")]
public Object[] Items1;
    [XmlElementAttribute("filter-def")]
public HbmFilterDef[] filterdef;
    [XmlElementAttribute("database-object")]
public HbmDatabaseObject[] databaseobject;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("default-cascade")]
[DefaultValueAttribute("none")]
public string defaultcascade;
    [XmlAttributeAttribute("default-access")]
[DefaultValueAttribute("property")]
public string defaultaccess;
    [XmlAttributeAttribute("default-lazy")]
[DefaultValueAttribute("True")]
public bool defaultlazy;
    [XmlAttributeAttribute("auto-import")]
[DefaultValueAttribute("True")]
public bool autoimport;
    [XmlAttributeAttribute]
public string namespace;
    [XmlAttributeAttribute]
public string assembly;
    public HbmDatabaseObject[] DatabaseObjects { get; }
    public HbmFilterDef[] FilterDefinitions { get; }
    public HbmResultSet[] ResultSets { get; }
    public HbmTypedef[] TypeDefinitions { get; }
    public HbmImport[] Imports { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmClass[] RootClasses { get; }
    public HbmSubclass[] SubClasses { get; }
    public HbmJoinedSubclass[] JoinedSubclasses { get; }
    public HbmUnionSubclass[] UnionSubclasses { get; }
    public HbmQuery[] HqlQueries { get; }
    public HbmSqlQuery[] SqlQueries { get; }
    public HbmDatabaseObject[] get_DatabaseObjects();
    public HbmFilterDef[] get_FilterDefinitions();
    public HbmResultSet[] get_ResultSets();
    public HbmTypedef[] get_TypeDefinitions();
    public HbmImport[] get_Imports();
    protected virtual HbmMeta[] get_Metadatas();
    public HbmClass[] get_RootClasses();
    public HbmSubclass[] get_SubClasses();
    public HbmJoinedSubclass[] get_JoinedSubclasses();
    public HbmUnionSubclass[] get_UnionSubclasses();
    public HbmQuery[] get_HqlQueries();
    public HbmSqlQuery[] get_SqlQueries();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("meta")]
public class NHibernate.Cfg.MappingSchema.HbmMeta : HbmBase {
    [XmlAttributeAttribute]
public string attribute;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool inherit;
    [XmlTextAttribute]
public String[] Text;
    public string GetText();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("meta-value")]
public class NHibernate.Cfg.MappingSchema.HbmMetaValue : object {
    [XmlAttributeAttribute]
public string value;
    [XmlAttributeAttribute]
public string class;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("natural-id")]
public class NHibernate.Cfg.MappingSchema.HbmNaturalId : object {
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
public Object[] Items;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool mutable;
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("nested-composite-element")]
public class NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement : AbstractDecoratable {
    public HbmParent parent;
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("nested-composite-element", "NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
public Object[] Items;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string node;
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public string Class { get; }
    public HbmParent Parent { get; }
    public string EmbeddedNode { get; }
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    protected HbmMeta[] Metadatas { get; }
    public bool IsLazyProperty { get; }
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
    public sealed virtual string get_Class();
    public sealed virtual HbmParent get_Parent();
    public sealed virtual string get_EmbeddedNode();
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual bool get_IsLazyProperty();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmNotFoundMode : Enum {
    public int value__;
    [XmlEnumAttribute("ignore")]
public static HbmNotFoundMode Ignore;
    [XmlEnumAttribute("exception")]
public static HbmNotFoundMode Exception;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmOndelete : Enum {
    public int value__;
    [XmlEnumAttribute("cascade")]
public static HbmOndelete Cascade;
    [XmlEnumAttribute("noaction")]
public static HbmOndelete Noaction;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("one-to-many")]
public class NHibernate.Cfg.MappingSchema.HbmOneToMany : object {
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute("not-found")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmNotFoundMode notfound;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    public string EntityName { get; }
    public string Class { get; }
    public HbmNotFoundMode NotFoundMode { get; }
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Class();
    public sealed virtual HbmNotFoundMode get_NotFoundMode();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("one-to-one")]
public class NHibernate.Cfg.MappingSchema.HbmOneToOne : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("formula")]
public HbmFormula[] formula;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute("formula")]
public string formula1;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool constrained;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute("foreign-key")]
public string foreignkey;
    [XmlAttributeAttribute("property-ref")]
public string propertyref;
    [XmlAttributeAttribute]
public HbmLaziness lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
public string node;
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; public set; }
    protected HbmMeta[] Metadatas { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFormula> Formulas { get; }
    public string EntityName { get; }
    public string Class { get; }
    public HbmNotFoundMode NotFoundMode { get; }
    public Nullable`1<HbmLaziness> Lazy { get; }
    public bool IsLazyProperty { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public void set_OptimisticLock(bool value);
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual IEnumerable`1<HbmFormula> get_Formulas();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmOneToOne/<AsFormulas>d__31")]
private IEnumerable`1<HbmFormula> AsFormulas();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Class();
    public sealed virtual HbmNotFoundMode get_NotFoundMode();
    public Nullable`1<HbmLaziness> get_Lazy();
    public sealed virtual bool get_IsLazyProperty();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode : Enum {
    public int value__;
    [XmlEnumAttribute("none")]
public static HbmOptimisticLockMode None;
    [XmlEnumAttribute("version")]
public static HbmOptimisticLockMode Version;
    [XmlEnumAttribute("dirty")]
public static HbmOptimisticLockMode Dirty;
    [XmlEnumAttribute("all")]
public static HbmOptimisticLockMode All;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy : Enum {
    public int value__;
    [XmlEnumAttribute("auto")]
public static HbmOuterJoinStrategy Auto;
    [XmlEnumAttribute("true")]
public static HbmOuterJoinStrategy True;
    [XmlEnumAttribute("false")]
public static HbmOuterJoinStrategy False;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("param")]
public class NHibernate.Cfg.MappingSchema.HbmParam : HbmBase {
    [XmlAttributeAttribute]
public string name;
    [XmlTextAttribute]
public String[] Text;
    public string GetText();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("parent")]
public class NHibernate.Cfg.MappingSchema.HbmParent : object {
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmPolymorphismType : Enum {
    public int value__;
    [XmlEnumAttribute("implicit")]
public static HbmPolymorphismType Implicit;
    [XmlEnumAttribute("explicit")]
public static HbmPolymorphismType Explicit;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("primitive-array")]
public class NHibernate.Cfg.MappingSchema.HbmPrimitiveArray : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    public HbmCache cache;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    public HbmKey key;
    [XmlElementAttribute("index", "NHibernate.Cfg.MappingSchema.HbmIndex")]
[XmlElementAttribute("list-index", "NHibernate.Cfg.MappingSchema.HbmListIndex")]
public object Item;
    public HbmElement element;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("sql-delete-all")]
public HbmCustomSQL sqldeleteall;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool mutable;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute("batch-size")]
public string batchsize;
    [XmlAttributeAttribute("outer-join")]
public HbmPrimitivearrayOuterjoin outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmPrimitivearrayFetch fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("collection-type")]
public string collectiontype;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    public bool IsLazyProperty { get; }
    public string Cascade { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public HbmCustomSQL SqlDeleteAll { get; }
    public string Subselect { get; }
    public bool Inverse { get; }
    public bool Mutable { get; }
    public string OrderBy { get; }
    public string Where { get; }
    public Nullable`1<int> BatchSize { get; }
    public string PersisterQualifiedName { get; }
    public string CollectionType { get; }
    public Nullable`1<HbmCollectionFetchMode> FetchMode { get; }
    public Nullable`1<HbmOuterJoinStrategy> OuterJoin { get; }
    public Nullable`1<HbmCollectionLazy> Lazy { get; }
    public string Table { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Check { get; }
    public object ElementRelationship { get; }
    public string Sort { get; }
    public Nullable`1<bool> Generic { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFilter> Filters { get; }
    public HbmKey Key { get; }
    public HbmCache Cache { get; }
    public HbmListIndex ListIndex { get; }
    public HbmIndex Index { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual string get_Cascade();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual HbmCustomSQL get_SqlDeleteAll();
    public sealed virtual string get_Subselect();
    public sealed virtual bool get_Inverse();
    public sealed virtual bool get_Mutable();
    public sealed virtual string get_OrderBy();
    public sealed virtual string get_Where();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual string get_PersisterQualifiedName();
    public sealed virtual string get_CollectionType();
    public sealed virtual Nullable`1<HbmCollectionFetchMode> get_FetchMode();
    public sealed virtual Nullable`1<HbmOuterJoinStrategy> get_OuterJoin();
    public sealed virtual Nullable`1<HbmCollectionLazy> get_Lazy();
    public sealed virtual string get_Table();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Catalog();
    public sealed virtual string get_Check();
    public sealed virtual object get_ElementRelationship();
    public sealed virtual string get_Sort();
    public sealed virtual Nullable`1<bool> get_Generic();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmPrimitiveArray/<get_Filters>d__91")]
public sealed virtual IEnumerable`1<HbmFilter> get_Filters();
    public sealed virtual HbmKey get_Key();
    public sealed virtual HbmCache get_Cache();
    public sealed virtual HbmListIndex get_ListIndex();
    public sealed virtual HbmIndex get_Index();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch : Enum {
    public int value__;
    [XmlEnumAttribute("join")]
public static HbmPrimitivearrayFetch Join;
    [XmlEnumAttribute("select")]
public static HbmPrimitivearrayFetch Select;
    [XmlEnumAttribute("subselect")]
public static HbmPrimitivearrayFetch Subselect;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin : Enum {
    public int value__;
    [XmlEnumAttribute("true")]
public static HbmPrimitivearrayOuterjoin True;
    [XmlEnumAttribute("false")]
public static HbmPrimitivearrayOuterjoin False;
    [XmlEnumAttribute("auto")]
public static HbmPrimitivearrayOuterjoin Auto;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("properties")]
public class NHibernate.Cfg.MappingSchema.HbmProperties : AbstractDecoratable {
    [XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
public Object[] Items;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool unique;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool insert;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool update;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    public bool IsLazyProperty { get; }
    public string Class { get; }
    public HbmParent Parent { get; }
    public string EmbeddedNode { get; }
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    protected HbmMeta[] Metadatas { get; }
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual string get_Class();
    public sealed virtual HbmParent get_Parent();
    public sealed virtual string get_EmbeddedNode();
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
    protected virtual HbmMeta[] get_Metadatas();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("property")]
public class NHibernate.Cfg.MappingSchema.HbmProperty : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("column", "NHibernate.Cfg.MappingSchema.HbmColumn")]
[XmlElementAttribute("formula", "NHibernate.Cfg.MappingSchema.HbmFormula")]
public Object[] Items;
    public HbmType type;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute("type")]
public string type1;
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute]
public string length;
    [XmlAttributeAttribute]
public string precision;
    [XmlAttributeAttribute]
public string scale;
    [XmlAttributeAttribute("not-null")]
public bool notnull;
    [XmlIgnoreAttribute]
public bool notnullSpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool unique;
    [XmlAttributeAttribute("unique-key")]
public string uniquekey;
    [XmlAttributeAttribute]
public string index;
    [XmlAttributeAttribute]
public bool update;
    [XmlIgnoreAttribute]
public bool updateSpecified;
    [XmlAttributeAttribute]
public bool insert;
    [XmlIgnoreAttribute]
public bool insertSpecified;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string formula;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool lazy;
    [XmlAttributeAttribute("lazy-group")]
public string lazygroup;
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmPropertyGeneration generated;
    public string Name { get; }
    public bool IsLazyProperty { get; }
    public string FetchGroup { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    protected HbmMeta[] Metadatas { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFormula> Formulas { get; }
    public HbmType Type { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<object> ColumnsAndFormulas { get; }
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsLazyProperty();
    public string get_FetchGroup();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmProperty/<AsColumns>d__40")]
private IEnumerable`1<HbmColumn> AsColumns();
    public sealed virtual IEnumerable`1<HbmFormula> get_Formulas();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmProperty/<AsFormulas>d__43")]
private IEnumerable`1<HbmFormula> AsFormulas();
    public sealed virtual HbmType get_Type();
    public IEnumerable`1<object> get_ColumnsAndFormulas();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmPropertyGeneration : Enum {
    public int value__;
    [XmlEnumAttribute("never")]
public static HbmPropertyGeneration Never;
    [XmlEnumAttribute("insert")]
public static HbmPropertyGeneration Insert;
    [XmlEnumAttribute("always")]
public static HbmPropertyGeneration Always;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("query")]
public class NHibernate.Cfg.MappingSchema.HbmQuery : HbmBase {
    [XmlElementAttribute("query-param")]
public HbmQueryParam[] Items;
    [XmlTextAttribute]
public String[] Text;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute("flush-mode")]
public HbmFlushMode flushmode;
    [XmlIgnoreAttribute]
public bool flushmodeSpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool cacheable;
    [XmlAttributeAttribute("cache-region")]
public string cacheregion;
    [XmlAttributeAttribute("fetch-size")]
public int fetchsize;
    [XmlIgnoreAttribute]
public bool fetchsizeSpecified;
    [XmlAttributeAttribute]
public string timeout;
    [XmlAttributeAttribute("cache-mode")]
public HbmCacheMode cachemode;
    [XmlIgnoreAttribute]
public bool cachemodeSpecified;
    [XmlAttributeAttribute("read-only")]
public bool readonly;
    [XmlIgnoreAttribute]
public bool readonlySpecified;
    [XmlAttributeAttribute]
public string comment;
    public string GetText();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("query-param")]
public class NHibernate.Cfg.MappingSchema.HbmQueryParam : object {
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string type;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmRestrictedLaziness : Enum {
    public int value__;
    [XmlEnumAttribute("false")]
public static HbmRestrictedLaziness False;
    [XmlEnumAttribute("proxy")]
public static HbmRestrictedLaziness Proxy;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("resultset")]
public class NHibernate.Cfg.MappingSchema.HbmResultSet : object {
    [XmlElementAttribute("load-collection", "NHibernate.Cfg.MappingSchema.HbmLoadCollection")]
[XmlElementAttribute("return", "NHibernate.Cfg.MappingSchema.HbmReturn")]
[XmlElementAttribute("return-join", "NHibernate.Cfg.MappingSchema.HbmReturnJoin")]
[XmlElementAttribute("return-scalar", "NHibernate.Cfg.MappingSchema.HbmReturnScalar")]
public Object[] Items;
    [XmlAttributeAttribute]
public string name;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("return")]
public class NHibernate.Cfg.MappingSchema.HbmReturn : object {
    [XmlElementAttribute("return-discriminator")]
public HbmReturnDiscriminator returndiscriminator;
    [XmlElementAttribute("return-property")]
public HbmReturnProperty[] returnproperty;
    [XmlAttributeAttribute]
public string alias;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute("lock-mode")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmLockMode lockmode;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("return-column")]
public class NHibernate.Cfg.MappingSchema.HbmReturnColumn : object {
    [XmlAttributeAttribute]
public string name;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("return-discriminator")]
public class NHibernate.Cfg.MappingSchema.HbmReturnDiscriminator : object {
    [XmlAttributeAttribute]
public string column;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("return-join")]
public class NHibernate.Cfg.MappingSchema.HbmReturnJoin : object {
    [XmlElementAttribute("return-property")]
public HbmReturnProperty[] returnproperty;
    [XmlAttributeAttribute]
public string alias;
    [XmlAttributeAttribute]
public string property;
    [XmlAttributeAttribute("lock-mode")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmLockMode lockmode;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("return-property")]
public class NHibernate.Cfg.MappingSchema.HbmReturnProperty : object {
    [XmlElementAttribute("return-column")]
public HbmReturnColumn[] returncolumn;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string column;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("return-scalar")]
public class NHibernate.Cfg.MappingSchema.HbmReturnScalar : object {
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute]
public string type;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("set")]
public class NHibernate.Cfg.MappingSchema.HbmSet : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    public HbmCache cache;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    public HbmKey key;
    [XmlElementAttribute("composite-element", "NHibernate.Cfg.MappingSchema.HbmCompositeElement")]
[XmlElementAttribute("element", "NHibernate.Cfg.MappingSchema.HbmElement")]
[XmlElementAttribute("many-to-any", "NHibernate.Cfg.MappingSchema.HbmManyToAny")]
[XmlElementAttribute("many-to-many", "NHibernate.Cfg.MappingSchema.HbmManyToMany")]
[XmlElementAttribute("one-to-many", "NHibernate.Cfg.MappingSchema.HbmOneToMany")]
public object Item;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("sql-delete-all")]
public HbmCustomSQL sqldeleteall;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute]
public HbmCollectionLazy lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool inverse;
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool mutable;
    [XmlAttributeAttribute]
public string cascade;
    [XmlAttributeAttribute("order-by")]
public string orderby;
    [XmlAttributeAttribute]
public string where;
    [XmlAttributeAttribute("batch-size")]
public int batchsize;
    [XmlIgnoreAttribute]
public bool batchsizeSpecified;
    [XmlAttributeAttribute("outer-join")]
public HbmOuterJoinStrategy outerjoin;
    [XmlIgnoreAttribute]
public bool outerjoinSpecified;
    [XmlAttributeAttribute]
public HbmCollectionFetchMode fetch;
    [XmlIgnoreAttribute]
public bool fetchSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("collection-type")]
public string collectiontype;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("optimistic-lock")]
[DefaultValueAttribute("True")]
public bool optimisticlock;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public bool generic;
    [XmlIgnoreAttribute]
public bool genericSpecified;
    [XmlAttributeAttribute]
public string sort;
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    public bool IsLazyProperty { get; }
    public string Cascade { get; }
    protected HbmMeta[] Metadatas { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public HbmCustomSQL SqlDeleteAll { get; }
    public string Subselect { get; }
    public bool Inverse { get; }
    public bool Mutable { get; }
    public string OrderBy { get; }
    public string Where { get; }
    public Nullable`1<int> BatchSize { get; }
    public string PersisterQualifiedName { get; }
    public string CollectionType { get; }
    public Nullable`1<HbmCollectionFetchMode> FetchMode { get; }
    public Nullable`1<HbmOuterJoinStrategy> OuterJoin { get; }
    public Nullable`1<HbmCollectionLazy> Lazy { get; }
    public string Table { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Check { get; }
    public object ElementRelationship { get; }
    public string Sort { get; }
    public Nullable`1<bool> Generic { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmFilter> Filters { get; }
    public HbmKey Key { get; }
    public HbmCache Cache { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual bool get_IsLazyProperty();
    public sealed virtual string get_Cascade();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual HbmCustomSQL get_SqlDeleteAll();
    public sealed virtual string get_Subselect();
    public sealed virtual bool get_Inverse();
    public sealed virtual bool get_Mutable();
    public sealed virtual string get_OrderBy();
    public sealed virtual string get_Where();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual string get_PersisterQualifiedName();
    public sealed virtual string get_CollectionType();
    public sealed virtual Nullable`1<HbmCollectionFetchMode> get_FetchMode();
    public sealed virtual Nullable`1<HbmOuterJoinStrategy> get_OuterJoin();
    public sealed virtual Nullable`1<HbmCollectionLazy> get_Lazy();
    public sealed virtual string get_Table();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Catalog();
    public sealed virtual string get_Check();
    public sealed virtual object get_ElementRelationship();
    public sealed virtual string get_Sort();
    public sealed virtual Nullable`1<bool> get_Generic();
    public sealed virtual IEnumerable`1<HbmFilter> get_Filters();
    public sealed virtual HbmKey get_Key();
    public sealed virtual HbmCache get_Cache();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("sql-query")]
public class NHibernate.Cfg.MappingSchema.HbmSqlQuery : HbmBase {
    [XmlElementAttribute("load-collection", "NHibernate.Cfg.MappingSchema.HbmLoadCollection")]
[XmlElementAttribute("query-param", "NHibernate.Cfg.MappingSchema.HbmQueryParam")]
[XmlElementAttribute("return", "NHibernate.Cfg.MappingSchema.HbmReturn")]
[XmlElementAttribute("return-join", "NHibernate.Cfg.MappingSchema.HbmReturnJoin")]
[XmlElementAttribute("return-scalar", "NHibernate.Cfg.MappingSchema.HbmReturnScalar")]
[XmlElementAttribute("synchronize", "NHibernate.Cfg.MappingSchema.HbmSynchronize")]
public Object[] Items;
    [XmlTextAttribute]
public String[] Text;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute("resultset-ref")]
public string resultsetref;
    [XmlAttributeAttribute("flush-mode")]
public HbmFlushMode flushmode;
    [XmlIgnoreAttribute]
public bool flushmodeSpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool cacheable;
    [XmlAttributeAttribute("cache-region")]
public string cacheregion;
    [XmlAttributeAttribute("fetch-size")]
public int fetchsize;
    [XmlIgnoreAttribute]
public bool fetchsizeSpecified;
    [XmlAttributeAttribute]
public string timeout;
    [XmlAttributeAttribute("cache-mode")]
public HbmCacheMode cachemode;
    [XmlIgnoreAttribute]
public bool cachemodeSpecified;
    [XmlAttributeAttribute("read-only")]
public bool readonly;
    [XmlIgnoreAttribute]
public bool readonlySpecified;
    [XmlAttributeAttribute]
public string comment;
    [XmlAttributeAttribute]
[DefaultValueAttribute("False")]
public bool callable;
    public string GetText();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("subclass")]
public class NHibernate.Cfg.MappingSchema.HbmSubclass : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("tuplizer")]
public HbmTuplizer[] tuplizer;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("array", "NHibernate.Cfg.MappingSchema.HbmArray")]
[XmlElementAttribute("bag", "NHibernate.Cfg.MappingSchema.HbmBag")]
[XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("idbag", "NHibernate.Cfg.MappingSchema.HbmIdbag")]
[XmlElementAttribute("list", "NHibernate.Cfg.MappingSchema.HbmList")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("map", "NHibernate.Cfg.MappingSchema.HbmMap")]
[XmlElementAttribute("one-to-one", "NHibernate.Cfg.MappingSchema.HbmOneToOne")]
[XmlElementAttribute("primitive-array", "NHibernate.Cfg.MappingSchema.HbmPrimitiveArray")]
[XmlElementAttribute("properties", "NHibernate.Cfg.MappingSchema.HbmProperties")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
[XmlElementAttribute("set", "NHibernate.Cfg.MappingSchema.HbmSet")]
public Object[] Items;
    [XmlElementAttribute("join")]
public HbmJoin[] join;
    [XmlElementAttribute("subclass")]
public HbmSubclass[] subclass1;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("resultset")]
public HbmResultSet[] resultset;
    [XmlElementAttribute("query", "NHibernate.Cfg.MappingSchema.HbmQuery")]
[XmlElementAttribute("sql-query", "NHibernate.Cfg.MappingSchema.HbmSqlQuery")]
public Object[] Items1;
    [XmlElementAttribute("filter")]
public HbmFilter[] filter;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string proxy;
    [XmlAttributeAttribute("discriminator-value")]
public string discriminatorvalue;
    [XmlAttributeAttribute("dynamic-update")]
[DefaultValueAttribute("False")]
public bool dynamicupdate;
    [XmlAttributeAttribute("dynamic-insert")]
[DefaultValueAttribute("False")]
public bool dynamicinsert;
    [XmlAttributeAttribute("select-before-update")]
[DefaultValueAttribute("False")]
public bool selectbeforeupdate;
    [XmlAttributeAttribute]
public string extends;
    [XmlAttributeAttribute]
public bool lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
public bool abstract;
    [XmlIgnoreAttribute]
public bool abstractSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute("batch-size")]
public string batchsize;
    [XmlAttributeAttribute]
public string node;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmJoin> Joins { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmSubclass> Subclasses { get; }
    protected HbmMeta[] Metadatas { get; }
    public string EntityName { get; }
    public string Name { get; }
    public string Node { get; }
    public string Proxy { get; }
    public Nullable`1<bool> UseLazy { get; }
    public HbmTuplizer[] Tuplizers { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public Nullable`1<int> BatchSize { get; }
    public bool SelectBeforeUpdate { get; }
    public string Persister { get; }
    public Nullable`1<bool> IsAbstract { get; }
    public HbmSynchronize[] Synchronize { get; }
    public string DiscriminatorValue { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public string Subselect { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public IEnumerable`1<HbmJoin> get_Joins();
    public IEnumerable`1<HbmSubclass> get_Subclasses();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Name();
    public sealed virtual string get_Node();
    public sealed virtual string get_Proxy();
    public sealed virtual Nullable`1<bool> get_UseLazy();
    public sealed virtual HbmTuplizer[] get_Tuplizers();
    public sealed virtual bool get_DynamicUpdate();
    public sealed virtual bool get_DynamicInsert();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual bool get_SelectBeforeUpdate();
    public sealed virtual string get_Persister();
    public sealed virtual Nullable`1<bool> get_IsAbstract();
    public sealed virtual HbmSynchronize[] get_Synchronize();
    public sealed virtual string get_DiscriminatorValue();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual string get_Subselect();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("subselect")]
public class NHibernate.Cfg.MappingSchema.HbmSubselect : object {
    [XmlTextAttribute]
public String[] Text;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("synchronize")]
public class NHibernate.Cfg.MappingSchema.HbmSynchronize : object {
    [XmlAttributeAttribute]
public string table;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("timestamp")]
public class NHibernate.Cfg.MappingSchema.HbmTimestamp : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public string column;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute("unsaved-value")]
public HbmTimestampUnsavedvalue unsavedvalue;
    [XmlIgnoreAttribute]
public bool unsavedvalueSpecified;
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmTimestampSource source;
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmVersionGeneration generated;
    protected HbmMeta[] Metadatas { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    protected virtual HbmMeta[] get_Metadatas();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmTimestamp/<get_Columns>d__13")]
public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmTimestampSource : Enum {
    public int value__;
    [XmlEnumAttribute("vm")]
public static HbmTimestampSource Vm;
    [XmlEnumAttribute("db")]
public static HbmTimestampSource Db;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmTimestampUnsavedvalue : Enum {
    public int value__;
    [XmlEnumAttribute("null")]
public static HbmTimestampUnsavedvalue Null;
    [XmlEnumAttribute("undefined")]
public static HbmTimestampUnsavedvalue Undefined;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("tuplizer")]
public class NHibernate.Cfg.MappingSchema.HbmTuplizer : object {
    [XmlAttributeAttribute("entity-mode")]
public HbmTuplizerEntitymode entitymode;
    [XmlIgnoreAttribute]
public bool entitymodeSpecified;
    [XmlAttributeAttribute]
public string class;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode : Enum {
    public int value__;
    [XmlEnumAttribute("poco")]
public static HbmTuplizerEntitymode Poco;
    [XmlEnumAttribute("dynamic-map")]
public static HbmTuplizerEntitymode DynamicMap;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("type")]
public class NHibernate.Cfg.MappingSchema.HbmType : object {
    [XmlElementAttribute("param")]
public HbmParam[] param;
    [XmlAttributeAttribute]
public string name;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("typedef")]
public class NHibernate.Cfg.MappingSchema.HbmTypedef : object {
    [XmlElementAttribute("param")]
public HbmParam[] param;
    [XmlAttributeAttribute]
public string class;
    [XmlAttributeAttribute]
public string name;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("union-subclass")]
public class NHibernate.Cfg.MappingSchema.HbmUnionSubclass : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    public HbmSubselect subselect;
    [XmlElementAttribute("synchronize")]
public HbmSynchronize[] synchronize;
    public HbmComment comment;
    [XmlElementAttribute("tuplizer")]
public HbmTuplizer[] tuplizer;
    [XmlElementAttribute("any", "NHibernate.Cfg.MappingSchema.HbmAny")]
[XmlElementAttribute("array", "NHibernate.Cfg.MappingSchema.HbmArray")]
[XmlElementAttribute("bag", "NHibernate.Cfg.MappingSchema.HbmBag")]
[XmlElementAttribute("component", "NHibernate.Cfg.MappingSchema.HbmComponent")]
[XmlElementAttribute("dynamic-component", "NHibernate.Cfg.MappingSchema.HbmDynamicComponent")]
[XmlElementAttribute("idbag", "NHibernate.Cfg.MappingSchema.HbmIdbag")]
[XmlElementAttribute("list", "NHibernate.Cfg.MappingSchema.HbmList")]
[XmlElementAttribute("many-to-one", "NHibernate.Cfg.MappingSchema.HbmManyToOne")]
[XmlElementAttribute("map", "NHibernate.Cfg.MappingSchema.HbmMap")]
[XmlElementAttribute("one-to-one", "NHibernate.Cfg.MappingSchema.HbmOneToOne")]
[XmlElementAttribute("primitive-array", "NHibernate.Cfg.MappingSchema.HbmPrimitiveArray")]
[XmlElementAttribute("properties", "NHibernate.Cfg.MappingSchema.HbmProperties")]
[XmlElementAttribute("property", "NHibernate.Cfg.MappingSchema.HbmProperty")]
[XmlElementAttribute("set", "NHibernate.Cfg.MappingSchema.HbmSet")]
public Object[] Items;
    [XmlElementAttribute("union-subclass")]
public HbmUnionSubclass[] unionsubclass1;
    public HbmLoader loader;
    [XmlElementAttribute("sql-insert")]
public HbmCustomSQL sqlinsert;
    [XmlElementAttribute("sql-update")]
public HbmCustomSQL sqlupdate;
    [XmlElementAttribute("sql-delete")]
public HbmCustomSQL sqldelete;
    [XmlElementAttribute("resultset")]
public HbmResultSet[] resultset;
    [XmlElementAttribute("query", "NHibernate.Cfg.MappingSchema.HbmQuery")]
[XmlElementAttribute("sql-query", "NHibernate.Cfg.MappingSchema.HbmSqlQuery")]
public Object[] Items1;
    [XmlAttributeAttribute("entity-name")]
public string entityname;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string proxy;
    [XmlAttributeAttribute]
public string table;
    [XmlAttributeAttribute]
public string schema;
    [XmlAttributeAttribute]
public string catalog;
    [XmlAttributeAttribute("subselect")]
public string subselect1;
    [XmlAttributeAttribute("dynamic-update")]
[DefaultValueAttribute("False")]
public bool dynamicupdate;
    [XmlAttributeAttribute("dynamic-insert")]
[DefaultValueAttribute("False")]
public bool dynamicinsert;
    [XmlAttributeAttribute("select-before-update")]
[DefaultValueAttribute("False")]
public bool selectbeforeupdate;
    [XmlAttributeAttribute]
public string extends;
    [XmlAttributeAttribute]
public bool lazy;
    [XmlIgnoreAttribute]
public bool lazySpecified;
    [XmlAttributeAttribute]
public bool abstract;
    [XmlIgnoreAttribute]
public bool abstractSpecified;
    [XmlAttributeAttribute]
public string persister;
    [XmlAttributeAttribute]
public string check;
    [XmlAttributeAttribute("batch-size")]
public string batchsize;
    [XmlAttributeAttribute]
public string node;
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmUnionSubclass> UnionSubclasses { get; }
    protected HbmMeta[] Metadatas { get; }
    public string EntityName { get; }
    public string Name { get; }
    public string Node { get; }
    public string Proxy { get; }
    public Nullable`1<bool> UseLazy { get; }
    public HbmTuplizer[] Tuplizers { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public Nullable`1<int> BatchSize { get; }
    public bool SelectBeforeUpdate { get; }
    public string Persister { get; }
    public Nullable`1<bool> IsAbstract { get; }
    public HbmSynchronize[] Synchronize { get; }
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public string Subselect { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public IEnumerable`1<HbmUnionSubclass> get_UnionSubclasses();
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual string get_EntityName();
    public sealed virtual string get_Name();
    public sealed virtual string get_Node();
    public sealed virtual string get_Proxy();
    public sealed virtual Nullable`1<bool> get_UseLazy();
    public sealed virtual HbmTuplizer[] get_Tuplizers();
    public sealed virtual bool get_DynamicUpdate();
    public sealed virtual bool get_DynamicInsert();
    public sealed virtual Nullable`1<int> get_BatchSize();
    public sealed virtual bool get_SelectBeforeUpdate();
    public sealed virtual string get_Persister();
    public sealed virtual Nullable`1<bool> get_IsAbstract();
    public sealed virtual HbmSynchronize[] get_Synchronize();
    public sealed virtual HbmLoader get_SqlLoader();
    public sealed virtual HbmCustomSQL get_SqlInsert();
    public sealed virtual HbmCustomSQL get_SqlUpdate();
    public sealed virtual HbmCustomSQL get_SqlDelete();
    public sealed virtual string get_Subselect();
    public sealed virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmUnsavedValueType : Enum {
    public int value__;
    [XmlEnumAttribute("undefined")]
public static HbmUnsavedValueType Undefined;
    [XmlEnumAttribute("any")]
public static HbmUnsavedValueType Any;
    [XmlEnumAttribute("none")]
public static HbmUnsavedValueType None;
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute("version")]
public class NHibernate.Cfg.MappingSchema.HbmVersion : AbstractDecoratable {
    [XmlElementAttribute("meta")]
public HbmMeta[] meta;
    [XmlElementAttribute("column")]
public HbmColumn[] column;
    [XmlAttributeAttribute]
public string name;
    [XmlAttributeAttribute]
public string node;
    [XmlAttributeAttribute]
public string access;
    [XmlAttributeAttribute("column")]
public string column1;
    [XmlAttributeAttribute]
[DefaultValueAttribute("Int32")]
public string type;
    [XmlAttributeAttribute("unsaved-value")]
public string unsavedvalue;
    [XmlAttributeAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HbmVersionGeneration generated;
    [XmlAttributeAttribute]
public bool insert;
    [XmlIgnoreAttribute]
public bool insertSpecified;
    protected HbmMeta[] Metadatas { get; }
    [XmlIgnoreAttribute]
public IEnumerable`1<HbmColumn> Columns { get; }
    protected virtual HbmMeta[] get_Metadatas();
    public sealed virtual IEnumerable`1<HbmColumn> get_Columns();
    [IteratorStateMachineAttribute("NHibernate.Cfg.MappingSchema.HbmVersion/<AsColumns>d__16")]
private IEnumerable`1<HbmColumn> AsColumns();
}
[GeneratedCodeAttribute("HbmXsd", "5.4.0-dev")]
[XmlTypeAttribute]
public enum NHibernate.Cfg.MappingSchema.HbmVersionGeneration : Enum {
    public int value__;
    [XmlEnumAttribute("never")]
public static HbmVersionGeneration Never;
    [XmlEnumAttribute("always")]
public static HbmVersionGeneration Always;
}
public interface NHibernate.Cfg.MappingSchema.IAnyMapping {
    public string MetaType { get; }
    public ICollection`1<HbmMetaValue> MetaValues { get; }
    public abstract virtual string get_MetaType();
    public abstract virtual ICollection`1<HbmMetaValue> get_MetaValues();
}
public interface NHibernate.Cfg.MappingSchema.IAssemblyResourceFilter {
    public abstract virtual bool ShouldParse(string resourceName);
}
public interface NHibernate.Cfg.MappingSchema.ICollectionPropertiesMapping {
    public bool Inverse { get; }
    public bool Mutable { get; }
    public string OrderBy { get; }
    public string Where { get; }
    public Nullable`1<int> BatchSize { get; }
    public string PersisterQualifiedName { get; }
    public string CollectionType { get; }
    public Nullable`1<HbmCollectionFetchMode> FetchMode { get; }
    public Nullable`1<HbmOuterJoinStrategy> OuterJoin { get; }
    public Nullable`1<HbmCollectionLazy> Lazy { get; }
    public string Table { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Check { get; }
    public object ElementRelationship { get; }
    public string Sort { get; }
    public Nullable`1<bool> Generic { get; }
    public IEnumerable`1<HbmFilter> Filters { get; }
    public HbmKey Key { get; }
    public HbmCache Cache { get; }
    public abstract virtual bool get_Inverse();
    public abstract virtual bool get_Mutable();
    public abstract virtual string get_OrderBy();
    public abstract virtual string get_Where();
    public abstract virtual Nullable`1<int> get_BatchSize();
    public abstract virtual string get_PersisterQualifiedName();
    public abstract virtual string get_CollectionType();
    public abstract virtual Nullable`1<HbmCollectionFetchMode> get_FetchMode();
    public abstract virtual Nullable`1<HbmOuterJoinStrategy> get_OuterJoin();
    public abstract virtual Nullable`1<HbmCollectionLazy> get_Lazy();
    public abstract virtual string get_Table();
    public abstract virtual string get_Schema();
    public abstract virtual string get_Catalog();
    public abstract virtual string get_Check();
    public abstract virtual object get_ElementRelationship();
    public abstract virtual string get_Sort();
    public abstract virtual Nullable`1<bool> get_Generic();
    public abstract virtual IEnumerable`1<HbmFilter> get_Filters();
    public abstract virtual HbmKey get_Key();
    public abstract virtual HbmCache get_Cache();
}
public interface NHibernate.Cfg.MappingSchema.ICollectionSqlsMapping {
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public HbmCustomSQL SqlDeleteAll { get; }
    public string Subselect { get; }
    public abstract virtual HbmLoader get_SqlLoader();
    public abstract virtual HbmCustomSQL get_SqlInsert();
    public abstract virtual HbmCustomSQL get_SqlUpdate();
    public abstract virtual HbmCustomSQL get_SqlDelete();
    public abstract virtual HbmCustomSQL get_SqlDeleteAll();
    public abstract virtual string get_Subselect();
}
public interface NHibernate.Cfg.MappingSchema.IColumnsMapping {
    public IEnumerable`1<HbmColumn> Columns { get; }
    public abstract virtual IEnumerable`1<HbmColumn> get_Columns();
}
public interface NHibernate.Cfg.MappingSchema.IComponentMapping {
    public string Class { get; }
    public HbmParent Parent { get; }
    public string EmbeddedNode { get; }
    public string Name { get; }
    public abstract virtual string get_Class();
    public abstract virtual HbmParent get_Parent();
    public abstract virtual string get_EmbeddedNode();
    public abstract virtual string get_Name();
}
public interface NHibernate.Cfg.MappingSchema.IDecoratable {
    public IDictionary`2<string, MetaAttribute> MappedMetaData { get; }
    public IDictionary`2<string, MetaAttribute> InheritableMetaData { get; }
    public abstract virtual IDictionary`2<string, MetaAttribute> get_MappedMetaData();
    public abstract virtual IDictionary`2<string, MetaAttribute> get_InheritableMetaData();
}
public interface NHibernate.Cfg.MappingSchema.IEntityDiscriminableMapping {
    public string DiscriminatorValue { get; }
    public abstract virtual string get_DiscriminatorValue();
}
public interface NHibernate.Cfg.MappingSchema.IEntityMapping {
    public string EntityName { get; }
    public string Name { get; }
    public string Node { get; }
    public string Proxy { get; }
    public Nullable`1<bool> UseLazy { get; }
    public HbmTuplizer[] Tuplizers { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public Nullable`1<int> BatchSize { get; }
    public bool SelectBeforeUpdate { get; }
    public string Persister { get; }
    public Nullable`1<bool> IsAbstract { get; }
    public HbmSynchronize[] Synchronize { get; }
    public abstract virtual string get_EntityName();
    public abstract virtual string get_Name();
    public abstract virtual string get_Node();
    public abstract virtual string get_Proxy();
    public abstract virtual Nullable`1<bool> get_UseLazy();
    public abstract virtual HbmTuplizer[] get_Tuplizers();
    public abstract virtual bool get_DynamicUpdate();
    public abstract virtual bool get_DynamicInsert();
    public abstract virtual Nullable`1<int> get_BatchSize();
    public abstract virtual bool get_SelectBeforeUpdate();
    public abstract virtual string get_Persister();
    public abstract virtual Nullable`1<bool> get_IsAbstract();
    public abstract virtual HbmSynchronize[] get_Synchronize();
}
public interface NHibernate.Cfg.MappingSchema.IEntityPropertyMapping {
    public string Name { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    public bool IsLazyProperty { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Access();
    public abstract virtual bool get_OptimisticLock();
    public abstract virtual bool get_IsLazyProperty();
}
public interface NHibernate.Cfg.MappingSchema.IEntitySqlsMapping {
    public HbmLoader SqlLoader { get; }
    public HbmCustomSQL SqlInsert { get; }
    public HbmCustomSQL SqlUpdate { get; }
    public HbmCustomSQL SqlDelete { get; }
    public string Subselect { get; }
    public abstract virtual HbmLoader get_SqlLoader();
    public abstract virtual HbmCustomSQL get_SqlInsert();
    public abstract virtual HbmCustomSQL get_SqlUpdate();
    public abstract virtual HbmCustomSQL get_SqlDelete();
    public abstract virtual string get_Subselect();
}
public interface NHibernate.Cfg.MappingSchema.IFormulasMapping {
    public IEnumerable`1<HbmFormula> Formulas { get; }
    public abstract virtual IEnumerable`1<HbmFormula> get_Formulas();
}
public interface NHibernate.Cfg.MappingSchema.IIndexedCollectionMapping {
    public HbmListIndex ListIndex { get; }
    public HbmIndex Index { get; }
    public abstract virtual HbmListIndex get_ListIndex();
    public abstract virtual HbmIndex get_Index();
}
public interface NHibernate.Cfg.MappingSchema.IMappingDocumentParser {
    public abstract virtual HbmMapping Parse(Stream stream);
}
public interface NHibernate.Cfg.MappingSchema.IPropertiesContainerMapping {
    public IEnumerable`1<IEntityPropertyMapping> Properties { get; }
    public abstract virtual IEnumerable`1<IEntityPropertyMapping> get_Properties();
}
public interface NHibernate.Cfg.MappingSchema.IReferencePropertyMapping {
    public string Cascade { get; }
    public abstract virtual string get_Cascade();
}
public interface NHibernate.Cfg.MappingSchema.IRelationship {
    public string EntityName { get; }
    public string Class { get; }
    public HbmNotFoundMode NotFoundMode { get; }
    public abstract virtual string get_EntityName();
    public abstract virtual string get_Class();
    public abstract virtual HbmNotFoundMode get_NotFoundMode();
}
public interface NHibernate.Cfg.MappingSchema.ITypeMapping {
    public HbmType Type { get; }
    public abstract virtual HbmType get_Type();
}
public class NHibernate.Cfg.MappingSchema.MappingDocumentAggregator : object {
    private IAssemblyResourceFilter defaultFilter;
    private List`1<HbmMapping> documents;
    private IMappingDocumentParser parser;
    public MappingDocumentAggregator(IMappingDocumentParser parser, IAssemblyResourceFilter defaultFilter);
    public void Add(HbmMapping document);
    public void Add(Stream stream);
    public void Add(Assembly assembly, string resourceName);
    public void Add(Assembly assembly, IAssemblyResourceFilter filter);
    public void Add(Assembly assembly);
    public void Add(FileInfo file);
    public void Add(string fileName);
    public IList`1<HbmMapping> List();
}
public class NHibernate.Cfg.MappingSchema.MappingDocumentParser : object {
    private XmlSerializer serializer;
    public sealed virtual HbmMapping Parse(Stream stream);
}
[ExtensionAttribute]
public static class NHibernate.Cfg.MappingSchema.MappingExtensions : object {
    [ExtensionAttribute]
public static EntityMode ToEntityMode(HbmTuplizerEntitymode source);
}
public class NHibernate.Cfg.MappingsQueue : object {
    private Queue availableEntries;
    private HashSet`1<string> processedClassNames;
    private List`1<MappingsQueueEntry> unavailableEntries;
    public void AddDocument(NamedXmlDocument document);
    public NamedXmlDocument GetNextAvailableResource();
    public void CheckNoUnavailableEntries();
    private void AddProcessedClassNames(ICollection`1<string> classNames);
    private void AddEntry(MappingsQueueEntry re);
    private void ProcessUnavailableEntries();
    private MappingsQueueEntry FindAvailableResourceEntry();
    private bool CanProcess(MappingsQueueEntry ce);
    private static string FormatExceptionMessage(IEnumerable`1<MappingsQueueEntry> resourceEntries);
    [CompilerGeneratedAttribute]
private bool <CanProcess>b__10_0(RequiredEntityName c);
}
public class NHibernate.Cfg.MappingsQueueEntry : object {
    private HashSet`1<string> containedClassNames;
    private NamedXmlDocument document;
    private HashSet`1<RequiredEntityName> requiredClassNames;
    public NamedXmlDocument Document { get; }
    public ICollection`1<RequiredEntityName> RequiredClassNames { get; }
    public ICollection`1<string> ContainedClassNames { get; }
    public MappingsQueueEntry(NamedXmlDocument document, IEnumerable`1<ClassEntry> classEntries);
    public NamedXmlDocument get_Document();
    public ICollection`1<RequiredEntityName> get_RequiredClassNames();
    public ICollection`1<string> get_ContainedClassNames();
    private static HashSet`1<string> GetClassNames(IEnumerable`1<ClassEntry> classEntries);
    private static HashSet`1<RequiredEntityName> GetRequiredClassNames(IEnumerable`1<ClassEntry> classEntries, ICollection`1<string> containedNames);
}
public class NHibernate.Cfg.NamedXmlDocument : object {
    private static XmlSerializer mappingDocumentSerializer;
    private string name;
    private HbmMapping document;
    public string Name { get; }
    public HbmMapping Document { get; }
    private static NamedXmlDocument();
    public NamedXmlDocument(string name, XmlDocument document);
    public NamedXmlDocument(string name, XmlDocument document, XmlSerializer serializer);
    public string get_Name();
    public HbmMapping get_Document();
}
internal class NHibernate.Cfg.NullConfigurationProvider : ConfigurationProvider {
    public virtual IHibernateConfiguration GetConfiguration();
    public virtual string GetNamedConnectionString(string name);
    public virtual string GetLoggerFactoryClassName();
}
public class NHibernate.Cfg.SchemaAutoAction : object {
    private string value;
    public static SchemaAutoAction Recreate;
    public static SchemaAutoAction Create;
    public static SchemaAutoAction Update;
    public static SchemaAutoAction Validate;
    private SchemaAutoAction(string value);
    private static SchemaAutoAction();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public bool Equals(string other);
    public bool Equals(SchemaAutoAction other);
    public virtual int GetHashCode();
    public static bool op_Equality(string a, SchemaAutoAction b);
    public static bool op_Equality(SchemaAutoAction a, string b);
    public static bool op_Inequality(SchemaAutoAction a, string b);
    public static bool op_Inequality(string a, SchemaAutoAction b);
}
public class NHibernate.Cfg.SecondPassCommand : MulticastDelegate {
    public SecondPassCommand(object object, IntPtr method);
    public virtual void Invoke(IDictionary`2<string, PersistentClass> persistentClasses);
    public virtual IAsyncResult BeginInvoke(IDictionary`2<string, PersistentClass> persistentClasses, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Cfg.SessionFactoryConfigurationBase : object {
    private string name;
    private Dictionary`2<string, string> properties;
    private List`1<MappingConfiguration> mappings;
    private List`1<ClassCacheConfiguration> classesCache;
    private List`1<CollectionCacheConfiguration> collectionsCache;
    private List`1<EventConfiguration> events;
    private List`1<ListenerConfiguration> listeners;
    public string Name { get; protected set; }
    public IDictionary`2<string, string> Properties { get; }
    public IList`1<MappingConfiguration> Mappings { get; }
    public IList`1<ClassCacheConfiguration> ClassesCache { get; }
    public IList`1<CollectionCacheConfiguration> CollectionsCache { get; }
    public IList`1<EventConfiguration> Events { get; }
    public IList`1<ListenerConfiguration> Listeners { get; }
    public sealed virtual string get_Name();
    protected void set_Name(string value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public sealed virtual IList`1<MappingConfiguration> get_Mappings();
    public sealed virtual IList`1<ClassCacheConfiguration> get_ClassesCache();
    public sealed virtual IList`1<CollectionCacheConfiguration> get_CollectionsCache();
    public sealed virtual IList`1<EventConfiguration> get_Events();
    public sealed virtual IList`1<ListenerConfiguration> get_Listeners();
}
public class NHibernate.Cfg.Settings : object {
    [CompilerGeneratedAttribute]
private SqlStatementLogger <SqlStatementLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumFetchDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetectFetchLoops>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <QuerySubstitutions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dialect <Dialect>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AdoBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultBatchFetchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsScrollableResultSetsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGetGeneratedKeysEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultSchemaName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultCatalogName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionFactoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoJoinTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoCreateSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoDropSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoUpdateSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoValidateSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoQuoteEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKeywordsImportEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsQueryCacheEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStructuredCacheEntriesEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSecondLevelCacheEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheRegionPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMinimalPutsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCommentsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatisticsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIdentifierRollbackEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFlushBeforeCompletionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoCloseSessionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionReleaseMode <ConnectionReleaseMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ICacheProvider <CacheProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ICacheReadWriteLockFactory <CacheReadWriteLockFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryCacheFactory <QueryCacheFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IConnectionProvider <ConnectionProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransactionFactory <TransactionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IBatcherFactory <BatcherFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryTranslatorFactory <QueryTranslatorFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <LinqQueryProviderType>k__BackingField;
    [CompilerGeneratedAttribute]
private ISQLExceptionConverter <SqlExceptionConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWrapResultSetsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOrderUpdatesEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOrderInsertsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private FlushMode <DefaultFlushMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDataDefinitionImplicitCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDataDefinitionInTransactionSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamedQueryStartupCheckingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBatchVersionedDataEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnSchemaUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QueryThrowNeverCached>k__BackingField;
    [CompilerGeneratedAttribute]
private IsolationLevel <IsolationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOuterJoinFetchEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackSessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ILinqToHqlGeneratorsRegistry <LinqToHqlGeneratorsRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LinqToHqlLegacyPreEvaluation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LinqToHqlFallbackOnPreEvaluation>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryModelRewriterFactory <QueryModelRewriterFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionTransformerRegistrar <PreTransformerRegistrar>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Expression, Expression> <LinqPreTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private MultiTenancyStrategy <MultiTenancyStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IMultiTenancyConnectionProvider <MultiTenancyConnectionProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueryPlanCacheParameterMetadataMaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueryPlanCacheMaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchFetchStyle <BatchFetchStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchingEntityLoaderBuilder <BatchingEntityLoaderBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchingCollectionInitializerBuilder <BatchingCollectionInitializationBuilder>k__BackingField;
    public SqlStatementLogger SqlStatementLogger { get; internal set; }
    public int MaximumFetchDepth { get; internal set; }
    public bool DetectFetchLoops { get; internal set; }
    public IDictionary`2<string, string> QuerySubstitutions { get; internal set; }
    public Dialect Dialect { get; internal set; }
    public int AdoBatchSize { get; internal set; }
    public int DefaultBatchFetchSize { get; internal set; }
    public bool IsScrollableResultSetsEnabled { get; internal set; }
    public bool IsGetGeneratedKeysEnabled { get; internal set; }
    public string DefaultSchemaName { get; public set; }
    public string DefaultCatalogName { get; internal set; }
    public string SessionFactoryName { get; internal set; }
    public bool AutoJoinTransaction { get; internal set; }
    public bool IsAutoCreateSchema { get; internal set; }
    public bool IsAutoDropSchema { get; internal set; }
    public bool IsAutoUpdateSchema { get; internal set; }
    public bool IsAutoValidateSchema { get; internal set; }
    public bool IsAutoQuoteEnabled { get; internal set; }
    public bool IsKeywordsImportEnabled { get; internal set; }
    public bool IsQueryCacheEnabled { get; internal set; }
    public bool IsStructuredCacheEntriesEnabled { get; internal set; }
    public bool IsSecondLevelCacheEnabled { get; internal set; }
    public string CacheRegionPrefix { get; internal set; }
    public bool IsMinimalPutsEnabled { get; internal set; }
    public bool IsCommentsEnabled { get; internal set; }
    public bool IsStatisticsEnabled { get; internal set; }
    public bool IsIdentifierRollbackEnabled { get; internal set; }
    [ObsoleteAttribute("Please use DefaultFlushMode instead.")]
public bool IsFlushBeforeCompletionEnabled { get; internal set; }
    public bool IsAutoCloseSessionEnabled { get; internal set; }
    public ConnectionReleaseMode ConnectionReleaseMode { get; internal set; }
    public ICacheProvider CacheProvider { get; internal set; }
    public ICacheReadWriteLockFactory CacheReadWriteLockFactory { get; internal set; }
    public IQueryCacheFactory QueryCacheFactory { get; internal set; }
    public IConnectionProvider ConnectionProvider { get; internal set; }
    public ITransactionFactory TransactionFactory { get; internal set; }
    public IBatcherFactory BatcherFactory { get; internal set; }
    public IQueryTranslatorFactory QueryTranslatorFactory { get; internal set; }
    public Type LinqQueryProviderType { get; internal set; }
    public ISQLExceptionConverter SqlExceptionConverter { get; internal set; }
    public bool IsWrapResultSetsEnabled { get; internal set; }
    public bool IsOrderUpdatesEnabled { get; internal set; }
    public bool IsOrderInsertsEnabled { get; internal set; }
    public FlushMode DefaultFlushMode { get; internal set; }
    public bool IsDataDefinitionImplicitCommit { get; internal set; }
    public bool IsDataDefinitionInTransactionSupported { get; internal set; }
    public bool IsNamedQueryStartupCheckingEnabled { get; internal set; }
    public bool IsBatchVersionedDataEnabled { get; internal set; }
    public bool ThrowOnSchemaUpdate { get; internal set; }
    public bool QueryThrowNeverCached { get; internal set; }
    public IsolationLevel IsolationLevel { get; internal set; }
    public bool IsOuterJoinFetchEnabled { get; internal set; }
    public bool TrackSessionId { get; internal set; }
    public ILinqToHqlGeneratorsRegistry LinqToHqlGeneratorsRegistry { get; internal set; }
    public bool LinqToHqlLegacyPreEvaluation { get; internal set; }
    public bool LinqToHqlFallbackOnPreEvaluation { get; internal set; }
    public IQueryModelRewriterFactory QueryModelRewriterFactory { get; internal set; }
    public IExpressionTransformerRegistrar PreTransformerRegistrar { get; internal set; }
    internal Func`2<Expression, Expression> LinqPreTransformer { get; internal set; }
    public MultiTenancyStrategy MultiTenancyStrategy { get; internal set; }
    public IMultiTenancyConnectionProvider MultiTenancyConnectionProvider { get; internal set; }
    public int QueryPlanCacheParameterMetadataMaxSize { get; internal set; }
    public int QueryPlanCacheMaxSize { get; internal set; }
    public BatchFetchStyle BatchFetchStyle { get; internal set; }
    public BatchingEntityLoaderBuilder BatchingEntityLoaderBuilder { get; internal set; }
    public BatchingCollectionInitializerBuilder BatchingCollectionInitializationBuilder { get; internal set; }
    [CompilerGeneratedAttribute]
public SqlStatementLogger get_SqlStatementLogger();
    [CompilerGeneratedAttribute]
internal void set_SqlStatementLogger(SqlStatementLogger value);
    [CompilerGeneratedAttribute]
public int get_MaximumFetchDepth();
    [CompilerGeneratedAttribute]
internal void set_MaximumFetchDepth(int value);
    [CompilerGeneratedAttribute]
public bool get_DetectFetchLoops();
    [CompilerGeneratedAttribute]
internal void set_DetectFetchLoops(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_QuerySubstitutions();
    [CompilerGeneratedAttribute]
internal void set_QuerySubstitutions(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dialect get_Dialect();
    [CompilerGeneratedAttribute]
internal void set_Dialect(Dialect value);
    [CompilerGeneratedAttribute]
public int get_AdoBatchSize();
    [CompilerGeneratedAttribute]
internal void set_AdoBatchSize(int value);
    [CompilerGeneratedAttribute]
public int get_DefaultBatchFetchSize();
    [CompilerGeneratedAttribute]
internal void set_DefaultBatchFetchSize(int value);
    [CompilerGeneratedAttribute]
public bool get_IsScrollableResultSetsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsScrollableResultSetsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsGetGeneratedKeysEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsGetGeneratedKeysEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_DefaultSchemaName();
    [CompilerGeneratedAttribute]
public void set_DefaultSchemaName(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultCatalogName();
    [CompilerGeneratedAttribute]
internal void set_DefaultCatalogName(string value);
    [CompilerGeneratedAttribute]
public string get_SessionFactoryName();
    [CompilerGeneratedAttribute]
internal void set_SessionFactoryName(string value);
    [CompilerGeneratedAttribute]
public bool get_AutoJoinTransaction();
    [CompilerGeneratedAttribute]
internal void set_AutoJoinTransaction(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoCreateSchema();
    [CompilerGeneratedAttribute]
internal void set_IsAutoCreateSchema(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoDropSchema();
    [CompilerGeneratedAttribute]
internal void set_IsAutoDropSchema(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoUpdateSchema();
    [CompilerGeneratedAttribute]
internal void set_IsAutoUpdateSchema(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoValidateSchema();
    [CompilerGeneratedAttribute]
internal void set_IsAutoValidateSchema(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoQuoteEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsAutoQuoteEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsKeywordsImportEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsKeywordsImportEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsQueryCacheEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsQueryCacheEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStructuredCacheEntriesEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsStructuredCacheEntriesEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSecondLevelCacheEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsSecondLevelCacheEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_CacheRegionPrefix();
    [CompilerGeneratedAttribute]
internal void set_CacheRegionPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_IsMinimalPutsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsMinimalPutsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCommentsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsCommentsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStatisticsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsStatisticsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsIdentifierRollbackEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsIdentifierRollbackEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFlushBeforeCompletionEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsFlushBeforeCompletionEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoCloseSessionEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsAutoCloseSessionEnabled(bool value);
    [CompilerGeneratedAttribute]
public ConnectionReleaseMode get_ConnectionReleaseMode();
    [CompilerGeneratedAttribute]
internal void set_ConnectionReleaseMode(ConnectionReleaseMode value);
    [CompilerGeneratedAttribute]
public ICacheProvider get_CacheProvider();
    [CompilerGeneratedAttribute]
internal void set_CacheProvider(ICacheProvider value);
    [CompilerGeneratedAttribute]
public ICacheReadWriteLockFactory get_CacheReadWriteLockFactory();
    [CompilerGeneratedAttribute]
internal void set_CacheReadWriteLockFactory(ICacheReadWriteLockFactory value);
    [CompilerGeneratedAttribute]
public IQueryCacheFactory get_QueryCacheFactory();
    [CompilerGeneratedAttribute]
internal void set_QueryCacheFactory(IQueryCacheFactory value);
    [CompilerGeneratedAttribute]
public IConnectionProvider get_ConnectionProvider();
    [CompilerGeneratedAttribute]
internal void set_ConnectionProvider(IConnectionProvider value);
    [CompilerGeneratedAttribute]
public ITransactionFactory get_TransactionFactory();
    [CompilerGeneratedAttribute]
internal void set_TransactionFactory(ITransactionFactory value);
    [CompilerGeneratedAttribute]
public IBatcherFactory get_BatcherFactory();
    [CompilerGeneratedAttribute]
internal void set_BatcherFactory(IBatcherFactory value);
    [CompilerGeneratedAttribute]
public IQueryTranslatorFactory get_QueryTranslatorFactory();
    [CompilerGeneratedAttribute]
internal void set_QueryTranslatorFactory(IQueryTranslatorFactory value);
    [CompilerGeneratedAttribute]
public Type get_LinqQueryProviderType();
    [CompilerGeneratedAttribute]
internal void set_LinqQueryProviderType(Type value);
    [CompilerGeneratedAttribute]
public ISQLExceptionConverter get_SqlExceptionConverter();
    [CompilerGeneratedAttribute]
internal void set_SqlExceptionConverter(ISQLExceptionConverter value);
    [CompilerGeneratedAttribute]
public bool get_IsWrapResultSetsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsWrapResultSetsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOrderUpdatesEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsOrderUpdatesEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOrderInsertsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsOrderInsertsEnabled(bool value);
    [CompilerGeneratedAttribute]
public FlushMode get_DefaultFlushMode();
    [CompilerGeneratedAttribute]
internal void set_DefaultFlushMode(FlushMode value);
    [CompilerGeneratedAttribute]
public bool get_IsDataDefinitionImplicitCommit();
    [CompilerGeneratedAttribute]
internal void set_IsDataDefinitionImplicitCommit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDataDefinitionInTransactionSupported();
    [CompilerGeneratedAttribute]
internal void set_IsDataDefinitionInTransactionSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNamedQueryStartupCheckingEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsNamedQueryStartupCheckingEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsBatchVersionedDataEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsBatchVersionedDataEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnSchemaUpdate();
    [CompilerGeneratedAttribute]
internal void set_ThrowOnSchemaUpdate(bool value);
    [CompilerGeneratedAttribute]
public bool get_QueryThrowNeverCached();
    [CompilerGeneratedAttribute]
internal void set_QueryThrowNeverCached(bool value);
    [CompilerGeneratedAttribute]
public IsolationLevel get_IsolationLevel();
    [CompilerGeneratedAttribute]
internal void set_IsolationLevel(IsolationLevel value);
    [CompilerGeneratedAttribute]
public bool get_IsOuterJoinFetchEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsOuterJoinFetchEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_TrackSessionId();
    [CompilerGeneratedAttribute]
internal void set_TrackSessionId(bool value);
    [CompilerGeneratedAttribute]
public ILinqToHqlGeneratorsRegistry get_LinqToHqlGeneratorsRegistry();
    [CompilerGeneratedAttribute]
internal void set_LinqToHqlGeneratorsRegistry(ILinqToHqlGeneratorsRegistry value);
    [CompilerGeneratedAttribute]
public bool get_LinqToHqlLegacyPreEvaluation();
    [CompilerGeneratedAttribute]
internal void set_LinqToHqlLegacyPreEvaluation(bool value);
    [CompilerGeneratedAttribute]
public bool get_LinqToHqlFallbackOnPreEvaluation();
    [CompilerGeneratedAttribute]
internal void set_LinqToHqlFallbackOnPreEvaluation(bool value);
    [CompilerGeneratedAttribute]
public IQueryModelRewriterFactory get_QueryModelRewriterFactory();
    [CompilerGeneratedAttribute]
internal void set_QueryModelRewriterFactory(IQueryModelRewriterFactory value);
    [CompilerGeneratedAttribute]
public IExpressionTransformerRegistrar get_PreTransformerRegistrar();
    [CompilerGeneratedAttribute]
internal void set_PreTransformerRegistrar(IExpressionTransformerRegistrar value);
    [CompilerGeneratedAttribute]
internal Func`2<Expression, Expression> get_LinqPreTransformer();
    [CompilerGeneratedAttribute]
internal void set_LinqPreTransformer(Func`2<Expression, Expression> value);
    internal string GetFullCacheRegionName(string name);
    [CompilerGeneratedAttribute]
public MultiTenancyStrategy get_MultiTenancyStrategy();
    [CompilerGeneratedAttribute]
internal void set_MultiTenancyStrategy(MultiTenancyStrategy value);
    [CompilerGeneratedAttribute]
public IMultiTenancyConnectionProvider get_MultiTenancyConnectionProvider();
    [CompilerGeneratedAttribute]
internal void set_MultiTenancyConnectionProvider(IMultiTenancyConnectionProvider value);
    [CompilerGeneratedAttribute]
public int get_QueryPlanCacheParameterMetadataMaxSize();
    [CompilerGeneratedAttribute]
internal void set_QueryPlanCacheParameterMetadataMaxSize(int value);
    [CompilerGeneratedAttribute]
public int get_QueryPlanCacheMaxSize();
    [CompilerGeneratedAttribute]
internal void set_QueryPlanCacheMaxSize(int value);
    [CompilerGeneratedAttribute]
public BatchFetchStyle get_BatchFetchStyle();
    [CompilerGeneratedAttribute]
internal void set_BatchFetchStyle(BatchFetchStyle value);
    [CompilerGeneratedAttribute]
public BatchingEntityLoaderBuilder get_BatchingEntityLoaderBuilder();
    [CompilerGeneratedAttribute]
internal void set_BatchingEntityLoaderBuilder(BatchingEntityLoaderBuilder value);
    [CompilerGeneratedAttribute]
public BatchingCollectionInitializerBuilder get_BatchingCollectionInitializationBuilder();
    [CompilerGeneratedAttribute]
internal void set_BatchingCollectionInitializationBuilder(BatchingCollectionInitializerBuilder value);
}
public class NHibernate.Cfg.SettingsFactory : object {
    private static INHibernateLogger log;
    private static string DefaultCacheProvider;
    private static SettingsFactory();
    public Settings BuildSettings(IDictionary`2<string, string> properties);
    private ICacheReadWriteLockFactory GetReadWriteLockFactory(string lockFactory);
    private BatchingCollectionInitializerBuilder GetBatchingCollectionInitializationBuilder(BatchFetchStyle batchFetchStyle);
    private BatchingEntityLoaderBuilder GetBatchingEntityLoaderBuilder(BatchFetchStyle batchFetchStyle);
    private static IBatcherFactory CreateBatcherFactory(IDictionary`2<string, string> properties, int batchSize, IConnectionProvider connectionProvider);
    private static string EnabledDisabled(bool value);
    private static ICacheProvider CreateCacheProvider(IDictionary`2<string, string> properties);
    private static IQueryTranslatorFactory CreateQueryTranslatorFactory(IDictionary`2<string, string> properties);
    private static Type CreateLinqQueryProviderType(IDictionary`2<string, string> properties);
    private static IMultiTenancyConnectionProvider CreateMultiTenancyConnectionProvider(IDictionary`2<string, string> properties);
    private static ITransactionFactory CreateTransactionFactory(IDictionary`2<string, string> properties);
    private static IQueryModelRewriterFactory CreateQueryModelRewriterFactory(IDictionary`2<string, string> properties);
    private static IExpressionTransformerRegistrar CreatePreTransformerRegistrar(IDictionary`2<string, string> properties);
}
internal class NHibernate.Cfg.StaticConfigurationManagerProvider : ConfigurationProvider {
    public virtual IHibernateConfiguration GetConfiguration();
    public virtual string GetNamedConnectionString(string name);
    public virtual string GetLoggerFactoryClassName();
    private static string GetAppSettingIgnoreCase(string name);
}
public class NHibernate.Cfg.SystemConfigurationProvider : ConfigurationProvider {
    private Configuration _configuration;
    public SystemConfigurationProvider(Configuration configuration);
    public virtual IHibernateConfiguration GetConfiguration();
    public virtual string GetNamedConnectionString(string name);
    public virtual string GetLoggerFactoryClassName();
    private string GetAppSetting(string name);
}
internal class NHibernate.Cfg.XmlHbmBinding.AuxiliaryDatabaseObjectFactory : object {
    public static IAuxiliaryDatabaseObject Create(Mappings mappings, HbmDatabaseObject databaseObjectSchema);
    private static IAuxiliaryDatabaseObject CreateSimpleObject(HbmDatabaseObject databaseObjectSchema);
    private static IAuxiliaryDatabaseObject CreateCustomObject(Mappings mappings, HbmDatabaseObject databaseObjectSchema);
}
public abstract class NHibernate.Cfg.XmlHbmBinding.Binder : object {
    protected static INHibernateLogger log;
    protected static IDictionary`2<string, MetaAttribute> EmptyMeta;
    protected Mappings mappings;
    public Mappings Mappings { get; }
    protected Binder(Mappings mappings);
    private static Binder();
    public Mappings get_Mappings();
    protected static string FullQualifiedClassName(string className, Mappings mappings);
    protected static string FullClassName(string className, Mappings mappings);
    protected static bool NeedQualifiedClassName(string className);
    protected static Type ClassForFullNameChecked(string fullName, string errorMessage);
    protected static Type ClassForNameChecked(string name, Mappings mappings, string errorMessage);
    protected static string GetClassName(string unqualifiedName, Mappings mappings);
    protected static string GetQualifiedClassName(string unqualifiedName, Mappings mappings);
    public static IDictionary`2<string, MetaAttribute> GetMetas(IDecoratable decoratable, IDictionary`2<string, MetaAttribute> inheritedMeta);
    public static IDictionary`2<string, MetaAttribute> GetMetas(IDecoratable decoratable, IDictionary`2<string, MetaAttribute> inheritedMeta, bool onlyInheritable);
}
public abstract class NHibernate.Cfg.XmlHbmBinding.ClassBinder : Binder {
    [ObsoleteAttribute("This field will be removed in a future version.")]
protected Dialect dialect;
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
protected ClassBinder(Mappings mappings, Dialect dialect);
    [ObsoleteAttribute("Please use constructor that accepts mappings parameter instead.")]
protected ClassBinder(ClassBinder parent);
    protected ClassBinder(Mappings mappings);
    protected void BindClass(IEntityMapping classMapping, PersistentClass model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    protected void BindUnionSubclasses(IEnumerable`1<HbmUnionSubclass> unionSubclasses, PersistentClass persistentClass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    protected void BindJoinedSubclasses(IEnumerable`1<HbmJoinedSubclass> joinedSubclasses, PersistentClass persistentClass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    protected void BindSubclasses(IEnumerable`1<HbmSubclass> subclasses, PersistentClass persistentClass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindPersistentClassCommonValues(IEntityMapping classMapping, PersistentClass model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindMapRepresentation(IEntityMapping classMapping, PersistentClass entity);
    private void BindPocoRepresentation(IEntityMapping classMapping, PersistentClass entity);
    protected void BindJoins(IEnumerable`1<HbmJoin> joins, PersistentClass persistentClass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindJoin(HbmJoin joinMapping, Join join, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void HandleCustomSQL(IEntitySqlsMapping sqlsMapping, ISqlCustomizable model);
    protected PersistentClass GetSuperclass(string extendsName);
    protected string GetClassTableName(PersistentClass model, string mappedTableName);
    protected void BindComponent(IComponentMapping componentMapping, Component model, Type reflectedClass, string className, string path, bool isNullable, IDictionary`2<string, MetaAttribute> inheritedMetas);
    protected void BindForeignKey(string foreignKey, SimpleValue value);
    protected void BindAny(HbmAny node, Any model, bool isNullable);
    protected void BindAnyMeta(IAnyMapping anyMapping, Any model);
    protected void BindOneToOne(HbmOneToOne oneToOneMapping, OneToOne model);
    protected static ExecuteUpdateResultCheckStyle GetResultCheckStyle(HbmCustomSQL customSQL);
    protected static void InitLaziness(Nullable`1<HbmRestrictedLaziness> restrictedLaziness, ToOne fetchable, bool defaultLazy);
    protected static void InitLaziness(Nullable`1<HbmLaziness> laziness, ToOne fetchable, bool defaultLazy);
    protected void InitOuterJoinFetchSetting(HbmManyToMany manyToMany, IFetchable model);
    protected FetchMode GetFetchStyle(HbmFetchMode fetchModeMapping);
    protected FetchMode GetFetchStyle(HbmOuterJoinStrategy outerJoinStrategyMapping);
    protected void InitOuterJoinFetchSetting(HbmOneToOne oneToOne, OneToOne model);
    protected static string GetEntityName(IRelationship relationship, Mappings mappings);
}
public class NHibernate.Cfg.XmlHbmBinding.ClassCompositeIdBinder : ClassBinder {
    private Component compositeId;
    [ObsoleteAttribute("Please use constructor that accepts mappings parameter instead.")]
public ClassCompositeIdBinder(ClassBinder parent);
    public ClassCompositeIdBinder(Mappings mappings);
    public void BindCompositeId(HbmCompositeId idSchema, PersistentClass rootClass);
    private void CheckEqualsAndGetHashCodeOverride();
    private void BindComponent(Type reflectedClass, string path, HbmCompositeId idSchema);
    private void BindProperty(Property property, HbmCompositeId idSchema);
    private Type GetPropertyType(Type containingType, string propertyName, HbmCompositeId idSchema);
    private void BindManyToOne(HbmKeyManyToOne keyManyToOneSchema, ManyToOne manyToOne, string defaultColumnName, bool isNullable);
    private Property CreateProperty(ToOne value, string propertyName, Type parentClass, HbmKeyManyToOne keyManyToOneSchema);
    private void BindProperty(HbmKeyManyToOne keyManyToOneSchema, Property property);
    private void BindSimpleValue(HbmKeyProperty keyPropertySchema, SimpleValue model, bool isNullable, string path);
    private Property CreateProperty(SimpleValue value, string propertyName, Type parentClass, HbmKeyProperty keyPropertySchema);
    private void BindProperty(HbmKeyProperty keyPropertySchema, Property property);
}
public class NHibernate.Cfg.XmlHbmBinding.ClassDiscriminatorBinder : Binder {
    private PersistentClass rootClass;
    public ClassDiscriminatorBinder(PersistentClass rootClass, Mappings mappings);
    public void BindDiscriminator(HbmDiscriminator discriminatorSchema, Table table);
    private void BindSimpleValue(HbmDiscriminator discriminatorSchema, SimpleValue discriminator);
}
public class NHibernate.Cfg.XmlHbmBinding.ClassIdBinder : ClassBinder {
    [ObsoleteAttribute("Please use constructor that accepts mappings parameter instead.")]
public ClassIdBinder(ClassBinder parent);
    public ClassIdBinder(Mappings mappings);
    public void BindId(HbmId idSchema, PersistentClass rootClass, Table table);
    private void CreateIdentifierProperty(HbmId idSchema, PersistentClass rootClass, SimpleValue id);
    private HbmGenerator GetIdGenerator(HbmId idSchema);
    private static void VerifiyIdTypeIsValid(IType idType, string className);
    private static void BindUnsavedValue(HbmId idSchema, SimpleValue id);
}
public class NHibernate.Cfg.XmlHbmBinding.CollectionBinder : ClassBinder {
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
public CollectionBinder(Mappings mappings, Dialect dialect);
    public CollectionBinder(Mappings mappings);
    public Collection Create(ICollectionPropertiesMapping collectionMapping, string className, string propertyFullPath, PersistentClass owner, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private Collection CreateMap(HbmMap mapMapping, string prefix, string path, PersistentClass owner, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private Collection CreateSet(HbmSet setMapping, string prefix, string path, PersistentClass owner, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private Collection CreateList(HbmList listMapping, string prefix, string path, PersistentClass owner, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private Collection CreateBag(HbmBag bagMapping, string prefix, string path, PersistentClass owner, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private Collection CreateIdentifierBag(HbmIdbag idbagMapping, string prefix, string path, PersistentClass owner, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private Collection CreateArray(HbmArray arrayMapping, string prefix, string path, PersistentClass owner, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private Collection CreatePrimitiveArray(HbmPrimitiveArray primitiveArrayMapping, string prefix, string path, PersistentClass owner, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindPrimitiveArray(HbmPrimitiveArray arrayMapping, PrimitiveArray model, string prefix, string path, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindCollection(ICollectionPropertiesMapping collectionMapping, Collection model, string className, string path, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void InitLaziness(ICollectionPropertiesMapping collectionMapping, Collection fetchable);
    private void InitOuterJoinFetchSetting(ICollectionPropertiesMapping collectionMapping, Collection model);
    private void BindArray(HbmArray arrayMapping, Array model, string prefix, string path, Type containingType, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddListSecondPass(HbmList listMapping, List model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddArraySecondPass(HbmArray arrayMapping, Array model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddPrimitiveArraySecondPass(HbmPrimitiveArray primitiveArrayMapping, Array model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddMapSecondPass(HbmMap mapMapping, Map model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddSetSecondPass(HbmSet setMapping, Set model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddIdentifierCollectionSecondPass(HbmIdbag idbagMapping, IdentifierCollection model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddCollectionSecondPass(ICollectionPropertiesMapping collectionMapping, Collection model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void HandleCustomSQL(ICollectionSqlsMapping collection, Collection model);
    private static void PreCollectionSecondPass(Collection collection);
    private static void PostCollectionSecondPass(Collection collection);
    private void BindListSecondPass(HbmList listMapping, List model, IDictionary`2<string, PersistentClass> persistentClasses, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindArraySecondPass(HbmArray arrayMapping, List model, IDictionary`2<string, PersistentClass> persistentClasses, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindPrimitiveArraySecondPass(HbmPrimitiveArray primitiveArrayMapping, List model, IDictionary`2<string, PersistentClass> persistentClasses, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindCollectionIndex(IIndexedCollectionMapping listMapping, IndexedCollection model);
    private void BindOneToMany(HbmOneToMany oneToManyMapping, OneToMany model);
    private void BindIdentifierCollectionSecondPass(HbmIdbag idbagMapping, IdentifierCollection model, IDictionary`2<string, PersistentClass> persitentClasses, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindSetSecondPass(HbmSet setMapping, Set model, IDictionary`2<string, PersistentClass> persistentClasses, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindMapSecondPass(HbmMap mapMapping, Map model, IDictionary`2<string, PersistentClass> persistentClasses, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindIndexManyToAny(HbmIndexManyToAny indexManyToAnyMapping, Any any, bool isNullable);
    private void BindMapKeyManyToMany(HbmMapKeyManyToMany mapKeyManyToManyMapping, ManyToOne model, string defaultColumnName, bool isNullable);
    private void BindIndexManyToMany(HbmIndexManyToMany indexManyToManyMapping, ManyToOne model, string defaultColumnName, bool isNullable);
    private void BindCollectionSecondPass(ICollectionPropertiesMapping collectionMapping, Collection model, IDictionary`2<string, PersistentClass> persistentClasses, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindManyToMany(HbmManyToMany manyToManyMapping, Collection model);
    private void BindCompositeElement(HbmCompositeElement compositeElementMapping, Collection model, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindManyToAny(HbmManyToAny manyToAnyMapping, Collection model);
    private void BindElement(HbmElement elementMapping, Collection model);
    private static void BindCache(HbmCache cacheSchema, Collection collection);
    private void BindKey(HbmKey keyMapping, Collection model);
    private void BindManyToManySubelements(HbmManyToMany manyToManyMapping, Collection collection);
    private Type GetPropertyType(Type containingType, string propertyName, string propertyAccess);
    private static bool NeedBackref(Collection model);
}
public class NHibernate.Cfg.XmlHbmBinding.ColumnsBinder : Binder {
    private SimpleValue value;
    public ColumnsBinder(SimpleValue value, Mappings mappings);
    public void Bind(HbmColumn column, bool isNullable);
    public void Bind(IEnumerable`1<HbmColumn> columns, bool isNullable, Func`1<HbmColumn> defaultColumnDelegate);
    private void BindColumn(HbmColumn hbmColumn, Table table, bool isNullable);
    private void BindColumn(HbmColumn columnMapping, Column column, bool isNullable);
    private static void BindIndex(string indexAttribute, Table table, Column column);
    private static void BindUniqueKey(string uniqueKeyAttribute, Table table, Column column);
}
public class NHibernate.Cfg.XmlHbmBinding.FilterDefinitionFactory : object {
    private static INHibernateLogger log;
    private static FilterDefinitionFactory();
    public static FilterDefinition CreateFilterDefinition(HbmFilterDef filterDefSchema);
    private static IDictionary`2<string, IType> GetFilterParameterTypes(HbmFilterDef filterDefSchema);
}
public class NHibernate.Cfg.XmlHbmBinding.FiltersBinder : Binder {
    private IFilterable filterable;
    public FiltersBinder(IFilterable filterable, Mappings mappings);
    public void Bind(IEnumerable`1<HbmFilter> filters);
    public void Bind(IEnumerable`1<HbmFilter> filters, Action`2<string, string> addFilterDelegate);
    [CompilerGeneratedAttribute]
private void <Bind>b__2_0(string name, string condition);
}
internal static class NHibernate.Cfg.XmlHbmBinding.FlushModeConverter : object {
    public static FlushMode GetFlushMode(HbmQuery querySchema);
    public static FlushMode GetFlushMode(HbmSqlQuery querySchema);
    private static FlushMode GetFlushMode(bool flushModeSpecified, HbmFlushMode flushMode);
}
public class NHibernate.Cfg.XmlHbmBinding.IdGeneratorBinder : Binder {
    public IdGeneratorBinder(Mappings mappings);
    public void BindGenerator(SimpleValue id, HbmGenerator generatorMapping);
    private IDictionary`2<string, string> GetGeneratorProperties(HbmGenerator generatorMapping, string schema);
}
public class NHibernate.Cfg.XmlHbmBinding.JoinedSubclassBinder : ClassBinder {
    public JoinedSubclassBinder(Mappings mappings);
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
public JoinedSubclassBinder(Mappings mappings, Dialect dialect);
    [ObsoleteAttribute("Please use constructor that accepts mappings parameter instead.")]
public JoinedSubclassBinder(ClassBinder parent);
    public void Bind(HbmJoinedSubclass joinedSubclassMapping, IDictionary`2<string, MetaAttribute> inheritedMetas);
    public void HandleJoinedSubclass(PersistentClass model, HbmJoinedSubclass joinedSubclassMapping, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindKey(JoinedSubclass subclass, HbmKey keyMapping, Table mytable);
}
[ExtensionAttribute]
public static class NHibernate.Cfg.XmlHbmBinding.MappingLogExtensions : object {
    [ExtensionAttribute]
public static void LogMapped(Property property, INHibernateLogger log);
    private static string SafeGetPropertyTypeName(Property property);
}
public class NHibernate.Cfg.XmlHbmBinding.MappingRootBinder : Binder {
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
public MappingRootBinder(Mappings mappings, Dialect dialect);
    public MappingRootBinder(Mappings mappings);
    public void Bind(HbmMapping mappingSchema);
    private void AddEntitiesMappings(HbmMapping mappingSchema, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void SetMappingsProperties(HbmMapping mappingSchema);
    private void AddFilterDefinitions(HbmMapping mappingSchema);
    private void AddRootClasses(HbmClass rootClass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddUnionSubclasses(HbmUnionSubclass unionSubclass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddJoinedSubclasses(HbmJoinedSubclass joinedSubclass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddSubclasses(HbmSubclass subClass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void AddQueries(HbmMapping mappingSchema);
    private void AddSqlQueries(HbmMapping mappingSchema);
    public void AddImports(HbmMapping mappingSchema);
    public void AddTypeDefs(HbmMapping mappingSchema);
    private void AddAuxiliaryDatabaseObjects(HbmMapping mappingSchema);
    private void AddResultSetMappingDefinitions(HbmMapping mappingSchema);
}
public class NHibernate.Cfg.XmlHbmBinding.NamedQueryBinder : Binder {
    public NamedQueryBinder(Mappings mappings);
    public void AddQuery(HbmQuery querySchema);
}
public class NHibernate.Cfg.XmlHbmBinding.NamedSQLQueryBinder : Binder {
    public NamedSQLQueryBinder(Mappings mappings);
    public void AddSqlQuery(HbmSqlQuery querySchema);
    private static List`1<string> GetSynchronizedTables(HbmSqlQuery querySchema);
}
public class NHibernate.Cfg.XmlHbmBinding.PropertiesBinder : ClassBinder {
    private PersistentClass persistentClass;
    private Component component;
    private string entityName;
    private Type mappedClass;
    private string className;
    private bool componetDefaultNullable;
    private string propertyBasePath;
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
public PropertiesBinder(Mappings mappings, PersistentClass persistentClass, Dialect dialect);
    [ObsoleteAttribute("Please use constructor without dialect parameter")]
public PropertiesBinder(Mappings mappings, Component component, string className, string path, bool isNullable, Dialect dialect);
    public PropertiesBinder(Mappings mappings, PersistentClass persistentClass);
    public PropertiesBinder(Mappings mappings, Component component, string className, string path, bool isNullable);
    public void Bind(IEnumerable`1<IEntityPropertyMapping> properties, IDictionary`2<string, MetaAttribute> inheritedMetas);
    public void Bind(IEnumerable`1<IEntityPropertyMapping> properties, IDictionary`2<string, MetaAttribute> inheritedMetas, Action`1<Property> modifier);
    public void Bind(IEnumerable`1<IEntityPropertyMapping> properties, Table table, IDictionary`2<string, MetaAttribute> inheritedMetas, Action`1<Property> modifier, Action`1<Property> addToModelAction);
    private Component CreateNewComponent(Table table);
    private Type GetPropertyType(string classMapping, Type containingType, string propertyName, string propertyAccess);
    private void BindKeyManyToOne(HbmKeyManyToOne keyManyToOneMapping, ManyToOne model, string defaultColumnName, bool isNullable);
    private void BindManyToOne(HbmManyToOne manyToOneMapping, ManyToOne model, string defaultColumnName, bool isNullable);
    private void InitOuterJoinFetchSetting(HbmManyToOne manyToOneMapping, ManyToOne model);
    private void AddManyToOneSecondPass(ManyToOne manyToOne);
    private void BindValueProperty(HbmProperty propertyMapping, Property property);
    private void BindAnyProperty(HbmAny anyMapping, Property property);
    private void BindOneToOneProperty(HbmOneToOne oneToOneMapping, Property property);
    private void BindComponentProperty(HbmDynamicComponent dynamicComponentMapping, Property property, Component model);
    private void BindComponentProperty(HbmProperties propertiesMapping, Property property, Component model);
    private void BindComponentProperty(HbmComponent componentMapping, Property property, Component model);
    private void BindManyToOneProperty(HbmManyToOne manyToOneMapping, Property property);
    private void BindCollectionProperty(ICollectionPropertiesMapping collectionMapping, Property property);
    private Property CreateProperty(IEntityPropertyMapping propertyMapping, string propertyOwnerClassName, IValue value, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private string GetPropertyAccessorName(string propertyMappedAccessor);
    [CompilerGeneratedAttribute]
private void <Bind>b__12_0(Property p);
}
public class NHibernate.Cfg.XmlHbmBinding.ResultSetMappingBinder : Binder {
    public ResultSetMappingBinder(Mappings mappings);
    public ResultSetMappingDefinition Create(HbmResultSet resultSetSchema);
    public ResultSetMappingDefinition Create(HbmSqlQuery sqlQuerySchema);
    private ResultSetMappingDefinition Create(string name, Object[] items);
    private INativeSQLQueryReturn CreateQueryReturn(object item, int count);
    private INativeSQLQueryReturn CreateScalarReturn(HbmReturnScalar returnScalarSchema);
    private NativeSQLQueryRootReturn CreateReturn(HbmReturn returnSchema, int count);
    private NativeSQLQueryJoinReturn CreateJoinReturn(HbmReturnJoin returnJoinSchema);
    private NativeSQLQueryCollectionReturn CreateLoadCollectionReturn(HbmLoadCollection loadCollectionSchema);
    private IDictionary`2<string, String[]> BindPropertyResults(string alias, HbmReturnDiscriminator discriminatorSchema, HbmReturnProperty[] returnProperties, PersistentClass pc);
    private static List`1<string> GetResultColumns(HbmReturnProperty returnPropertySchema);
    private static List`1<string> GetResultColumns(HbmReturnDiscriminator discriminatorSchema);
    private static LockMode GetLockMode(HbmLockMode lockMode);
    private static int GetIndexOfFirstMatchingProperty(IList propertyNames, string follower);
    private static string Unquote(string name);
    private string GetClassNameWithoutAssembly(string unqualifiedName);
}
public class NHibernate.Cfg.XmlHbmBinding.RootClassBinder : ClassBinder {
    public RootClassBinder(Mappings mappings);
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
public RootClassBinder(Mappings mappings, Dialect dialect);
    public void Bind(HbmClass classSchema, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindNaturalId(HbmNaturalId naturalid, PersistentClass rootClass, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private string GetClassTableName(PersistentClass model, HbmClass classSchema);
    private void BindTimestamp(HbmTimestamp timestampSchema, PersistentClass rootClass, Table table, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindProperty(HbmTimestamp timestampSchema, Property property, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private static PropertyGeneration Convert(HbmVersionGeneration versionGeneration);
    private void BindVersion(HbmVersion versionSchema, PersistentClass rootClass, Table table, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private void BindProperty(HbmVersion versionSchema, Property property, IDictionary`2<string, MetaAttribute> inheritedMetas);
    private static void BindCache(HbmCache cacheSchema, RootClass rootClass);
}
public class NHibernate.Cfg.XmlHbmBinding.SubclassBinder : ClassBinder {
    public SubclassBinder(Binder parent);
    public SubclassBinder(Mappings mappings);
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
public SubclassBinder(Binder parent, Dialect dialect);
    [ObsoleteAttribute("Please use constructor that accepts mappings parameter instead.")]
public SubclassBinder(ClassBinder parent);
    public void Bind(HbmSubclass subClassMapping, IDictionary`2<string, MetaAttribute> inheritedMetas);
    public void HandleSubclass(PersistentClass model, HbmSubclass subClassMapping, IDictionary`2<string, MetaAttribute> inheritedMetas);
}
public class NHibernate.Cfg.XmlHbmBinding.TypeBinder : Binder {
    private SimpleValue value;
    public TypeBinder(SimpleValue value, Mappings mappings);
    public void Bind(string typeName);
    public void Bind(HbmType typeMapping);
    private void BindThroughTypeDefOrType(string originalTypeName, IDictionary`2<string, string> parameters);
}
public class NHibernate.Cfg.XmlHbmBinding.UnionSubclassBinder : ClassBinder {
    [ObsoleteAttribute("Please use constructor without a dialect parameter.")]
public UnionSubclassBinder(Mappings mappings, Dialect dialect);
    public UnionSubclassBinder(Mappings mappings);
    [ObsoleteAttribute("Please use constructor that accepts mappings parameter instead.")]
public UnionSubclassBinder(ClassBinder parent);
    public void Bind(HbmUnionSubclass unionSubclassMapping, IDictionary`2<string, MetaAttribute> inheritedMetas);
    public void HandleUnionSubclass(PersistentClass model, HbmUnionSubclass unionSubclassMapping, IDictionary`2<string, MetaAttribute> inheritedMetas);
}
public class NHibernate.Cfg.XmlHbmBinding.ValuePropertyBinder : Binder {
    private SimpleValue value;
    public ValuePropertyBinder(SimpleValue value, Mappings mappings);
    public void BindSimpleValue(HbmProperty propertyMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmElement element, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmKey propertyMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmManyToMany manyToManyMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmCollectionId collectionIdMapping, string propertyPath);
    public void BindSimpleValue(HbmListIndex listIndexMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmIndex indexMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmMapKey mapKeyMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmManyToOne manyToOneMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmIndexManyToMany indexManyToManyMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmMapKeyManyToMany mapKeyManyToManyMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmKeyProperty mapKeyManyToManyMapping, string propertyPath, bool isNullable);
    public void BindSimpleValue(HbmKeyManyToOne mapKeyManyToManyMapping, string propertyPath, bool isNullable);
    private void BindColumnsAndFormulas(Object[] columnsAndFormulas, bool isNullable, Func`1<HbmColumn> defaultColumnDelegate);
    private void BindFormula(HbmFormula formula);
}
internal class NHibernate.Cfg.XmlSchemas : object {
    private static string CfgSchemaResource;
    private static string MappingSchemaResource;
    private static XmlSchemaSet ConfigSchemaSet;
    private static XmlSchemas();
    public XmlReaderSettings CreateConfigReaderSettings();
    public XmlReaderSettings CreateMappingReaderSettings();
    private static XmlSchemaSet ReadXmlSchemaFromEmbeddedResource(string resourceName);
    private static XmlReaderSettings CreateXmlReaderSettings(XmlSchemaSet xmlSchemaSet);
    private static void ConfigSettingsValidationEventHandler(object sender, ValidationEventArgs e);
}
public interface NHibernate.Classic.ILifecycle {
    public abstract virtual LifecycleVeto OnSave(ISession s);
    public abstract virtual LifecycleVeto OnUpdate(ISession s);
    public abstract virtual LifecycleVeto OnDelete(ISession s);
    public abstract virtual void OnLoad(ISession s, object id);
}
public interface NHibernate.Classic.IValidatable {
    public abstract virtual void Validate();
}
public enum NHibernate.Classic.LifecycleVeto : Enum {
    public int value__;
    public static LifecycleVeto Veto;
    public static LifecycleVeto NoVeto;
}
public class NHibernate.Classic.ValidationFailure : HibernateException {
    public ValidationFailure(string message);
    public ValidationFailure(Exception innerException);
    public ValidationFailure(string message, Exception innerException);
    protected ValidationFailure(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.Collection.AbstractPersistentCollection : object {
    [ObsoleteAttribute("This field has no more usages in NHibernate and will be removed in a future version.")]
protected internal static object Unknown;
    [ObsoleteAttribute("This field has no more usages in NHibernate and will be removed in a future version.")]
protected internal static object NotFound;
    private ISessionImplementor session;
    private bool initialized;
    private List`1<IDelayedOperation> operationQueue;
    private bool directlyAccessible;
    private bool initializing;
    private AbstractQueueOperationTracker _queueOperationTracker;
    private object owner;
    private int cachedSize;
    private string role;
    private object key;
    private bool dirty;
    private object storedSnapshot;
    public string Role { get; }
    public object Key { get; }
    public bool IsUnreferenced { get; }
    public bool IsDirty { get; }
    public object StoredSnapshot { get; }
    protected int CachedSize { get; protected set; }
    protected bool IsConnectedToSession { get; }
    protected bool IsOperationQueueEnabled { get; }
    protected bool PutQueueEnabled { get; }
    protected bool ClearQueueEnabled { get; }
    protected bool IsInverseCollection { get; }
    protected bool InverseCollectionNoOrphanDelete { get; }
    protected bool InverseOneToManyOrNoOrphanDelete { get; }
    public bool RowUpdatePossible { get; }
    protected ISessionImplementor Session { get; }
    public object Owner { get; public set; }
    public bool Empty { get; }
    internal AbstractQueueOperationTracker QueueOperationTracker { get; internal set; }
    public bool IsDirectlyAccessible { get; protected set; }
    public bool WasInitialized { get; }
    public bool HasQueuedOperations { get; }
    public IEnumerable QueuedAdditionIterator { get; }
    protected AbstractPersistentCollection(ISessionImplementor session);
    private static AbstractPersistentCollection();
    [AsyncStateMachineAttribute("NHibernate.Collection.AbstractPersistentCollection/<ReadKeyExistenceAsync>d__0`2")]
protected virtual Task`1<Nullable`1<bool>> ReadKeyExistenceAsync(TKey elementKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.AbstractPersistentCollection/<CanSkipElementExistenceCheckAsync>d__1")]
internal Task`1<bool> CanSkipElementExistenceCheckAsync(object element, CancellationToken cancellationToken);
    protected virtual Task InitializeAsync(bool writing, CancellationToken cancellationToken);
    public virtual Task ForceInitializationAsync(CancellationToken cancellationToken);
    public virtual Task PreInsertAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.AbstractPersistentCollection/<IdentityRemoveAsync>d__5")]
[ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public Task IdentityRemoveAsync(IList list, object obj, string entityName, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> DisassembleAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> GetDeletesAsync(ICollectionPersister persister, bool indexIsFormula, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> EqualsSnapshotAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public abstract virtual Task InitializeFromCacheAsync(ICollectionPersister persister, object disassembled, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> NeedsUpdatingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReadFromAsync(DbDataReader reader, ICollectionPersister role, ICollectionAliases descriptor, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> NeedsInsertingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    public sealed virtual string get_Role();
    public sealed virtual object get_Key();
    public sealed virtual bool get_IsUnreferenced();
    public sealed virtual bool get_IsDirty();
    public sealed virtual object get_StoredSnapshot();
    protected int get_CachedSize();
    protected void set_CachedSize(int value);
    protected bool get_IsConnectedToSession();
    protected bool get_IsOperationQueueEnabled();
    protected bool get_PutQueueEnabled();
    protected bool get_ClearQueueEnabled();
    protected bool get_IsInverseCollection();
    protected bool get_InverseCollectionNoOrphanDelete();
    protected bool get_InverseOneToManyOrNoOrphanDelete();
    public virtual object GetValue();
    public virtual bool get_RowUpdatePossible();
    protected virtual ISessionImplementor get_Session();
    public virtual object get_Owner();
    public virtual void set_Owner(object value);
    public sealed virtual void ClearDirty();
    public sealed virtual void Dirty();
    public abstract virtual bool get_Empty();
    public virtual void Read();
    protected virtual bool ReadSize();
    [ObsoleteAttribute("This method has no more usages in NHibernate and will be removed in a future version.")]
protected virtual Nullable`1<bool> ReadIndexExistence(object index);
    [ObsoleteAttribute("This method has no more usages in NHibernate and will be removed in a future version.")]
protected virtual Nullable`1<bool> ReadElementExistence(object element);
    [ObsoleteAttribute("This method has no more usages in NHibernate and will be removed in a future version.")]
protected virtual object ReadElementByIndex(object index);
    protected virtual Nullable`1<bool> ReadKeyExistence(TKey elementKey);
    protected virtual Nullable`1<bool> ReadElementExistence(T element, Nullable`1& existsInDb);
    protected virtual Nullable`1<bool> TryReadElementByKey(TKey elementKey, TValue& element, Nullable`1& existsInDb);
    protected virtual Nullable`1<bool> TryReadElementAtIndex(int index, T& element);
    protected virtual void Write();
    internal virtual AbstractQueueOperationTracker CreateQueueOperationTracker();
    internal AbstractQueueOperationTracker get_QueueOperationTracker();
    internal void set_QueueOperationTracker(AbstractQueueOperationTracker value);
    internal AbstractQueueOperationTracker GetOrCreateQueueOperationTracker();
    [ObsoleteAttribute("This method has no more usages in NHibernate and will be removed in a future version.")]
protected virtual void QueueOperation(IDelayedOperation element);
    protected bool QueueAddElement(T element);
    protected void QueueRemoveExistingElement(T element, Nullable`1<bool> existsInDb);
    protected void QueueRemoveElementAtIndex(int index, T element);
    protected void QueueAddElementAtIndex(int index, T element);
    protected void QueueSetElementAtIndex(int index, T element, T oldElement);
    protected void QueueClearCollection();
    protected void QueueAddElementByKey(TKey elementKey, TValue element);
    protected void QueueSetElementByKey(TKey elementKey, TValue element, TValue oldElement, Nullable`1<bool> existsInDb);
    protected bool QueueRemoveElementByKey(TKey elementKey, TValue oldElement, Nullable`1<bool> existsInDb);
    private AbstractMapQueueOperationTracker`2<TKey, TValue> TryFlushAndGetQueueOperationTracker(string operationName);
    private AbstractCollectionQueueOperationTracker`1<T> TryFlushAndGetQueueOperationTracker(string operationName);
    private AbstractCollectionQueueOperationTracker`1<T> TryFlushAndGetQueueOperationTracker(string operationName, Boolean& wasFlushed);
    private AbstractQueueOperationTracker TryFlushAndGetQueueOperationTracker(string operationName, Boolean& wasFlushed);
    internal bool CanSkipElementExistenceCheck(object element);
    [ObsoleteAttribute("Use or override ApplyQueuedOperations instead")]
protected virtual void PerformQueuedOperations();
    public virtual void ApplyQueuedOperations();
    public sealed virtual void SetSnapshot(object key, string role, object snapshot);
    public virtual void PostAction();
    public virtual void BeginRead();
    public virtual bool EndRead(ICollectionPersister persister);
    public virtual bool AfterInitialize(ICollectionPersister persister);
    protected virtual void Initialize(bool writing);
    protected void ThrowLazyInitializationExceptionIfNotConnected();
    protected void ThrowLazyInitializationException(string message);
    protected virtual void SetInitialized();
    public virtual bool get_IsDirectlyAccessible();
    protected virtual void set_IsDirectlyAccessible(bool value);
    public sealed virtual bool UnsetSession(ISessionImplementor currentSession);
    public virtual bool SetCurrentSession(ISessionImplementor session);
    public virtual bool NeedsRecreate(ICollectionPersister persister);
    public virtual void ForceInitialization();
    protected virtual object GetSnapshot();
    public sealed virtual bool get_WasInitialized();
    public sealed virtual bool get_HasQueuedOperations();
    public sealed virtual IEnumerable get_QueuedAdditionIterator();
    public sealed virtual ICollection GetQueuedOrphans(string entityName);
    public virtual void PreInsert(ICollectionPersister persister);
    public virtual void AfterRowInsert(ICollectionPersister persister, object entry, int i, object id);
    public abstract virtual ICollection GetOrphans(object snapshot, string entityName);
    protected virtual ICollection GetOrphans(ICollection oldElements, ICollection currentElements, string entityName, ISessionImplementor session);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
protected virtual Task`1<ICollection> GetOrphansAsync(ICollection oldElements, ICollection currentElements, string entityName, ISessionImplementor session, CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public void IdentityRemove(IList list, object obj, string entityName, ISessionImplementor session);
    public virtual object GetIdentifier(object entry, int i);
    public abstract virtual object Disassemble(ICollectionPersister persister);
    public abstract virtual bool IsWrapper(object collection);
    public abstract virtual bool EntryExists(object entry, int i);
    public abstract virtual IEnumerable GetDeletes(ICollectionPersister persister, bool indexIsFormula);
    public abstract virtual bool IsSnapshotEmpty(object snapshot);
    public abstract virtual IEnumerable Entries(ICollectionPersister persister);
    public abstract virtual object GetSnapshot(ICollectionPersister persister);
    public abstract virtual bool EqualsSnapshot(ICollectionPersister persister);
    public abstract virtual object GetElement(object entry);
    public abstract virtual void InitializeFromCache(ICollectionPersister persister, object disassembled, object owner);
    public abstract virtual bool NeedsUpdating(object entry, int i, IType elemType);
    public abstract virtual object ReadFrom(DbDataReader reader, ICollectionPersister role, ICollectionAliases descriptor, object owner);
    public abstract virtual object GetSnapshotElement(object entry, int i);
    public abstract virtual bool NeedsInserting(object entry, int i, IType elemType);
    public abstract virtual object GetIndex(object entry, int i, ICollectionPersister persister);
    public abstract virtual void BeforeInitialize(ICollectionPersister persister, int anticipatedSize);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public sealed virtual Task`1<ICollection> GetQueuedOrphansAsync(string entityName, CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public abstract virtual Task`1<ICollection> GetOrphansAsync(object snapshot, string entityName, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.CollectionProxy`1")]
public class NHibernate.Collection.Generic.PersistentGenericBag`1 : AbstractPersistentCollection {
    private IList`1<T> _gbag;
    private bool _isOneToMany;
    private IQueryable`1<T> _queryable;
    protected IList`1<T> InternalBag { get; protected set; }
    public bool Empty { get; }
    public bool RowUpdatePossible { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    private Expression System.Linq.IQueryable.Expression { get; }
    private Type System.Linq.IQueryable.ElementType { get; }
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    private IQueryable`1<T> InnerQueryable { get; }
    public PersistentGenericBag`1(ISessionImplementor session);
    public PersistentGenericBag`1(ISessionImplementor session, IEnumerable`1<T> coll);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericBag`1/<DisassembleAsync>d__0")]
public virtual Task`1<object> DisassembleAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public virtual Task`1<bool> EqualsSnapshotAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> GetDeletesAsync(ICollectionPersister persister, bool indexIsFormula, CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public virtual Task`1<ICollection> GetOrphansAsync(object snapshot, string entityName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericBag`1/<InitializeFromCacheAsync>d__4")]
public virtual Task InitializeFromCacheAsync(ICollectionPersister persister, object disassembled, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericBag`1/<BeforeAssembleAsync>d__5")]
private Task BeforeAssembleAsync(IType elementType, Object[] array, CancellationToken cancellationToken);
    public virtual Task`1<bool> NeedsInsertingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    public virtual Task`1<bool> NeedsUpdatingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericBag`1/<ReadFromAsync>d__8")]
public virtual Task`1<object> ReadFromAsync(DbDataReader reader, ICollectionPersister role, ICollectionAliases descriptor, object owner, CancellationToken cancellationToken);
    internal virtual AbstractQueueOperationTracker CreateQueueOperationTracker();
    public virtual void ApplyQueuedOperations();
    protected IList`1<T> get_InternalBag();
    protected void set_InternalBag(IList`1<T> value);
    public virtual bool get_Empty();
    public virtual bool get_RowUpdatePossible();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public virtual void BeforeInitialize(ICollectionPersister persister, int anticipatedSize);
    public virtual object Disassemble(ICollectionPersister persister);
    public virtual IEnumerable Entries(ICollectionPersister persister);
    public virtual bool EntryExists(object entry, int i);
    public virtual bool EqualsSnapshot(ICollectionPersister persister);
    public virtual IEnumerable GetDeletes(ICollectionPersister persister, bool indexIsFormula);
    public virtual object GetElement(object entry);
    public virtual object GetIndex(object entry, int i, ICollectionPersister persister);
    public virtual ICollection GetOrphans(object snapshot, string entityName);
    public virtual object GetSnapshot(ICollectionPersister persister);
    public virtual object GetSnapshotElement(object entry, int i);
    public virtual void InitializeFromCache(ICollectionPersister persister, object disassembled, object owner);
    private void BeforeAssemble(IType elementType, Object[] array);
    public virtual bool IsSnapshotEmpty(object snapshot);
    public virtual bool IsWrapper(object collection);
    public virtual bool NeedsInserting(object entry, int i, IType elemType);
    public virtual bool NeedsRecreate(ICollectionPersister persister);
    public virtual bool NeedsUpdating(object entry, int i, IType elemType);
    public virtual object ReadFrom(DbDataReader reader, ICollectionPersister role, ICollectionAliases descriptor, object owner);
    public virtual string ToString();
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    private IQueryable`1<T> get_InnerQueryable();
    private static int CountOccurrences(object element, IEnumerable list, IType elementType);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.CollectionProxy`1")]
public class NHibernate.Collection.Generic.PersistentGenericList`1 : AbstractPersistentCollection {
    protected IList`1<T> WrappedList;
    private IQueryable`1<T> _queryable;
    protected T DefaultForType { get; }
    public bool Empty { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public T Item { get; public set; }
    public int Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private Expression System.Linq.IQueryable.Expression { get; }
    private Type System.Linq.IQueryable.ElementType { get; }
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    private IQueryable`1<T> InnerQueryable { get; }
    public PersistentGenericList`1(ISessionImplementor session);
    public PersistentGenericList`1(ISessionImplementor session, IList`1<T> list);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public virtual Task`1<ICollection> GetOrphansAsync(object snapshot, string entityName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericList`1/<EqualsSnapshotAsync>d__1")]
public virtual Task`1<bool> EqualsSnapshotAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericList`1/<ReadFromAsync>d__2")]
public virtual Task`1<object> ReadFromAsync(DbDataReader rs, ICollectionPersister role, ICollectionAliases descriptor, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericList`1/<InitializeFromCacheAsync>d__3")]
public virtual Task InitializeFromCacheAsync(ICollectionPersister persister, object disassembled, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericList`1/<BeforeAssembleAsync>d__4")]
private Task BeforeAssembleAsync(IType elementType, Object[] array, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericList`1/<DisassembleAsync>d__5")]
public virtual Task`1<object> DisassembleAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> GetDeletesAsync(ICollectionPersister persister, bool indexIsFormula, CancellationToken cancellationToken);
    public virtual Task`1<bool> NeedsInsertingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericList`1/<NeedsUpdatingAsync>d__8")]
public virtual Task`1<bool> NeedsUpdatingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    protected virtual T get_DefaultForType();
    internal virtual AbstractQueueOperationTracker CreateQueueOperationTracker();
    public virtual object GetSnapshot(ICollectionPersister persister);
    public virtual ICollection GetOrphans(object snapshot, string entityName);
    public virtual bool EqualsSnapshot(ICollectionPersister persister);
    public virtual bool IsSnapshotEmpty(object snapshot);
    public virtual void BeforeInitialize(ICollectionPersister persister, int anticipatedSize);
    public virtual void ApplyQueuedOperations();
    public virtual bool IsWrapper(object collection);
    public virtual bool get_Empty();
    public virtual string ToString();
    public virtual object ReadFrom(DbDataReader rs, ICollectionPersister role, ICollectionAliases descriptor, object owner);
    public virtual IEnumerable Entries(ICollectionPersister persister);
    public virtual void InitializeFromCache(ICollectionPersister persister, object disassembled, object owner);
    private void BeforeAssemble(IType elementType, Object[] array);
    public virtual object Disassemble(ICollectionPersister persister);
    public virtual IEnumerable GetDeletes(ICollectionPersister persister, bool indexIsFormula);
    public virtual bool NeedsInserting(object entry, int i, IType elemType);
    public virtual bool NeedsUpdating(object entry, int i, IType elemType);
    public virtual object GetIndex(object entry, int i, ICollectionPersister persister);
    public virtual object GetElement(object entry);
    public virtual object GetSnapshotElement(object entry, int i);
    public virtual bool EntryExists(object entry, int i);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual void Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public sealed virtual int get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    private IQueryable`1<T> get_InnerQueryable();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.DictionaryProxy`2")]
public class NHibernate.Collection.Generic.PersistentGenericMap`2 : AbstractPersistentCollection {
    protected IDictionary`2<TKey, TValue> WrappedMap;
    private ICollection`1<TValue> _wrappedValues;
    public bool Empty { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public PersistentGenericMap`2(ISessionImplementor session);
    public PersistentGenericMap`2(ISessionImplementor session, IDictionary`2<TKey, TValue> map);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public virtual Task`1<ICollection> GetOrphansAsync(object snapshot, string entityName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericMap`2/<EqualsSnapshotAsync>d__1")]
public virtual Task`1<bool> EqualsSnapshotAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericMap`2/<ReadFromAsync>d__2")]
public virtual Task`1<object> ReadFromAsync(DbDataReader rs, ICollectionPersister role, ICollectionAliases descriptor, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericMap`2/<InitializeFromCacheAsync>d__3")]
public virtual Task InitializeFromCacheAsync(ICollectionPersister persister, object disassembled, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericMap`2/<BeforeAssembleAsync>d__4")]
private Task BeforeAssembleAsync(IType indexType, IType elementType, Object[] array, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericMap`2/<DisassembleAsync>d__5")]
public virtual Task`1<object> DisassembleAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> GetDeletesAsync(ICollectionPersister persister, bool indexIsFormula, CancellationToken cancellationToken);
    public virtual Task`1<bool> NeedsInsertingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericMap`2/<NeedsUpdatingAsync>d__8")]
public virtual Task`1<bool> NeedsUpdatingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    internal virtual AbstractQueueOperationTracker CreateQueueOperationTracker();
    public virtual object GetSnapshot(ICollectionPersister persister);
    public virtual ICollection GetOrphans(object snapshot, string entityName);
    public virtual bool EqualsSnapshot(ICollectionPersister persister);
    public virtual bool IsSnapshotEmpty(object snapshot);
    public virtual bool IsWrapper(object collection);
    public virtual void BeforeInitialize(ICollectionPersister persister, int anticipatedSize);
    public virtual void ApplyQueuedOperations();
    public virtual bool get_Empty();
    public virtual string ToString();
    public virtual object ReadFrom(DbDataReader rs, ICollectionPersister role, ICollectionAliases descriptor, object owner);
    protected virtual void AddDuringInitialize(object index, object element);
    public virtual IEnumerable Entries(ICollectionPersister persister);
    public virtual void InitializeFromCache(ICollectionPersister persister, object disassembled, object owner);
    private void BeforeAssemble(IType indexType, IType elementType, Object[] array);
    public virtual object Disassemble(ICollectionPersister persister);
    public virtual IEnumerable GetDeletes(ICollectionPersister persister, bool indexIsFormula);
    public virtual bool NeedsInserting(object entry, int i, IType elemType);
    public virtual bool NeedsUpdating(object entry, int i, IType elemType);
    public virtual object GetIndex(object entry, int i, ICollectionPersister persister);
    public virtual object GetElement(object entry);
    public virtual object GetSnapshotElement(object entry, int i);
    public virtual bool EntryExists(object entry, int i);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.CollectionProxy`1")]
public class NHibernate.Collection.Generic.PersistentGenericSet`1 : AbstractPersistentCollection {
    protected ISet`1<T> WrappedSet;
    private List`1<T> _tempList;
    private IQueryable`1<T> _queryable;
    public bool RowUpdatePossible { get; }
    public bool Empty { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    private Expression System.Linq.IQueryable.Expression { get; }
    private Type System.Linq.IQueryable.ElementType { get; }
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    private IQueryable`1<T> InnerQueryable { get; }
    public PersistentGenericSet`1(ISessionImplementor session);
    public PersistentGenericSet`1(ISessionImplementor session, ISet`1<T> original);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public virtual Task`1<ICollection> GetOrphansAsync(object snapshot, string entityName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericSet`1/<EqualsSnapshotAsync>d__1")]
public virtual Task`1<bool> EqualsSnapshotAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericSet`1/<InitializeFromCacheAsync>d__2")]
public virtual Task InitializeFromCacheAsync(ICollectionPersister persister, object disassembled, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericSet`1/<BeforeAssembleAsync>d__3")]
private Task BeforeAssembleAsync(IType elementType, Object[] array, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericSet`1/<ReadFromAsync>d__4")]
public virtual Task`1<object> ReadFromAsync(DbDataReader rs, ICollectionPersister role, ICollectionAliases descriptor, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericSet`1/<DisassembleAsync>d__5")]
public virtual Task`1<object> DisassembleAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericSet`1/<GetDeletesAsync>d__6")]
public virtual Task`1<IEnumerable> GetDeletesAsync(ICollectionPersister persister, bool indexIsFormula, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentGenericSet`1/<NeedsInsertingAsync>d__7")]
public virtual Task`1<bool> NeedsInsertingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    public virtual Task`1<bool> NeedsUpdatingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    internal virtual AbstractQueueOperationTracker CreateQueueOperationTracker();
    public virtual bool get_RowUpdatePossible();
    public virtual object GetSnapshot(ICollectionPersister persister);
    public virtual ICollection GetOrphans(object snapshot, string entityName);
    public virtual bool EqualsSnapshot(ICollectionPersister persister);
    public virtual bool IsSnapshotEmpty(object snapshot);
    public virtual void BeforeInitialize(ICollectionPersister persister, int anticipatedSize);
    public virtual void ApplyQueuedOperations();
    public virtual void InitializeFromCache(ICollectionPersister persister, object disassembled, object owner);
    private void BeforeAssemble(IType elementType, Object[] array);
    public virtual bool get_Empty();
    public virtual string ToString();
    public virtual object ReadFrom(DbDataReader rs, ICollectionPersister role, ICollectionAliases descriptor, object owner);
    public virtual void BeginRead();
    public virtual bool EndRead(ICollectionPersister persister);
    public virtual IEnumerable Entries(ICollectionPersister persister);
    public virtual object Disassemble(ICollectionPersister persister);
    public virtual IEnumerable GetDeletes(ICollectionPersister persister, bool indexIsFormula);
    public virtual bool NeedsInserting(object entry, int i, IType elemType);
    public virtual bool NeedsUpdating(object entry, int i, IType elemType);
    public virtual object GetIndex(object entry, int i, ICollectionPersister persister);
    public virtual object GetElement(object entry);
    public virtual object GetSnapshotElement(object entry, int i);
    public virtual bool EntryExists(object entry, int i);
    public virtual bool IsWrapper(object collection);
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Add(T o);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Remove(T o);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public object get_SyncRoot();
    public bool get_IsSynchronized();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    private IQueryable`1<T> get_InnerQueryable();
    [CompilerGeneratedAttribute]
private bool <GetDeletesAsync>b__6_0(T obj);
    [CompilerGeneratedAttribute]
private bool <GetDeletes>b__33_0(T obj);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.CollectionProxy`1")]
public class NHibernate.Collection.Generic.PersistentIdentifierBag`1 : AbstractPersistentCollection {
    private Dictionary`2<int, object> _identifiers;
    private IList`1<T> _values;
    private IQueryable`1<T> _queryable;
    protected IList`1<T> InternalValues { get; protected set; }
    public bool Empty { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public int Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private Expression System.Linq.IQueryable.Expression { get; }
    private Type System.Linq.IQueryable.ElementType { get; }
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    private IQueryable`1<T> InnerQueryable { get; }
    public PersistentIdentifierBag`1(ISessionImplementor session);
    public PersistentIdentifierBag`1(ISessionImplementor session, IEnumerable`1<T> coll);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentIdentifierBag`1/<InitializeFromCacheAsync>d__0")]
public virtual Task InitializeFromCacheAsync(ICollectionPersister persister, object disassembled, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentIdentifierBag`1/<BeforeAssembleAsync>d__1")]
private Task BeforeAssembleAsync(IType identifierType, IType elementType, Object[] array, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentIdentifierBag`1/<DisassembleAsync>d__2")]
public virtual Task`1<object> DisassembleAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentIdentifierBag`1/<EqualsSnapshotAsync>d__3")]
public virtual Task`1<bool> EqualsSnapshotAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> GetDeletesAsync(ICollectionPersister persister, bool indexIsFormula, CancellationToken cancellationToken);
    public virtual Task`1<bool> NeedsInsertingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentIdentifierBag`1/<NeedsUpdatingAsync>d__6")]
public virtual Task`1<bool> NeedsUpdatingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentIdentifierBag`1/<ReadFromAsync>d__7")]
public virtual Task`1<object> ReadFromAsync(DbDataReader reader, ICollectionPersister persister, ICollectionAliases descriptor, object owner, CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public virtual Task`1<ICollection> GetOrphansAsync(object snapshot, string entityName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.Generic.PersistentIdentifierBag`1/<PreInsertAsync>d__9")]
public virtual Task PreInsertAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    protected IList`1<T> get_InternalValues();
    protected void set_InternalValues(IList`1<T> value);
    public virtual void InitializeFromCache(ICollectionPersister persister, object disassembled, object owner);
    private void BeforeAssemble(IType identifierType, IType elementType, Object[] array);
    private object GetIdentifier(int index);
    public virtual object GetIdentifier(object entry, int i);
    public virtual bool IsWrapper(object collection);
    public virtual object Disassemble(ICollectionPersister persister);
    public virtual bool get_Empty();
    public virtual IEnumerable Entries(ICollectionPersister persister);
    public virtual bool EntryExists(object entry, int i);
    public virtual bool EqualsSnapshot(ICollectionPersister persister);
    public virtual bool IsSnapshotEmpty(object snapshot);
    public virtual IEnumerable GetDeletes(ICollectionPersister persister, bool indexIsFormula);
    public virtual object GetIndex(object entry, int i, ICollectionPersister persister);
    public virtual object GetElement(object entry);
    public virtual object GetSnapshotElement(object entry, int i);
    public virtual bool NeedsInserting(object entry, int i, IType elemType);
    public virtual bool NeedsUpdating(object entry, int i, IType elemType);
    public virtual object ReadFrom(DbDataReader reader, ICollectionPersister persister, ICollectionAliases descriptor, object owner);
    public virtual object GetSnapshot(ICollectionPersister persister);
    public virtual ICollection GetOrphans(object snapshot, string entityName);
    public virtual void PreInsert(ICollectionPersister persister);
    public virtual void AfterRowInsert(ICollectionPersister persister, object entry, int i, object id);
    protected void BeforeRemove(int index);
    protected void BeforeInsert(int index);
    public virtual void BeforeInitialize(ICollectionPersister persister, int anticipatedSize);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual int get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    private IQueryable`1<T> get_InnerQueryable();
}
internal class NHibernate.Collection.Generic.SetHelpers.SetSnapShot`1 : HashSet`1<T> {
    private object _syncRoot;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public SetSnapShot`1(int capacity);
    public SetSnapShot`1(IEnumerable`1<T> collection);
    protected SetSnapShot`1(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
public interface NHibernate.Collection.ILazyInitializedCollection {
    public bool WasInitialized { get; }
    public abstract virtual Task ForceInitializationAsync(CancellationToken cancellationToken);
    public abstract virtual bool get_WasInitialized();
    public abstract virtual void ForceInitialization();
}
public interface NHibernate.Collection.IPersistentCollection {
    public object Owner { get; public set; }
    public bool RowUpdatePossible { get; }
    public object Key { get; }
    public string Role { get; }
    public bool IsUnreferenced { get; }
    public bool IsDirty { get; }
    public object StoredSnapshot { get; }
    public bool Empty { get; }
    public bool IsDirectlyAccessible { get; }
    public bool WasInitialized { get; }
    public bool HasQueuedOperations { get; }
    public IEnumerable QueuedAdditionIterator { get; }
    public abstract virtual Task InitializeFromCacheAsync(ICollectionPersister persister, object disassembled, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReadFromAsync(DbDataReader reader, ICollectionPersister role, ICollectionAliases descriptor, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> EqualsSnapshotAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> DisassembleAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public abstract virtual Task ForceInitializationAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> NeedsInsertingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> NeedsUpdatingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> GetDeletesAsync(ICollectionPersister persister, bool indexIsFormula, CancellationToken cancellationToken);
    public abstract virtual Task PreInsertAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public abstract virtual object get_Owner();
    public abstract virtual void set_Owner(object value);
    public abstract virtual object GetValue();
    public abstract virtual bool get_RowUpdatePossible();
    public abstract virtual object get_Key();
    public abstract virtual string get_Role();
    public abstract virtual bool get_IsUnreferenced();
    public abstract virtual bool get_IsDirty();
    public abstract virtual object get_StoredSnapshot();
    public abstract virtual bool get_Empty();
    public abstract virtual void SetSnapshot(object key, string role, object snapshot);
    public abstract virtual void PostAction();
    public abstract virtual void BeginRead();
    public abstract virtual bool EndRead(ICollectionPersister persister);
    public abstract virtual bool AfterInitialize(ICollectionPersister persister);
    public abstract virtual bool get_IsDirectlyAccessible();
    public abstract virtual bool UnsetSession(ISessionImplementor currentSession);
    public abstract virtual bool SetCurrentSession(ISessionImplementor session);
    public abstract virtual void InitializeFromCache(ICollectionPersister persister, object disassembled, object owner);
    public abstract virtual IEnumerable Entries(ICollectionPersister persister);
    public abstract virtual object ReadFrom(DbDataReader reader, ICollectionPersister role, ICollectionAliases descriptor, object owner);
    public abstract virtual object GetIdentifier(object entry, int i);
    public abstract virtual object GetIndex(object entry, int i, ICollectionPersister persister);
    public abstract virtual object GetElement(object entry);
    public abstract virtual object GetSnapshotElement(object entry, int i);
    public abstract virtual void BeforeInitialize(ICollectionPersister persister, int anticipatedSize);
    public abstract virtual bool EqualsSnapshot(ICollectionPersister persister);
    public abstract virtual bool IsSnapshotEmpty(object snapshot);
    public abstract virtual object Disassemble(ICollectionPersister persister);
    public abstract virtual bool NeedsRecreate(ICollectionPersister persister);
    public abstract virtual object GetSnapshot(ICollectionPersister persister);
    public abstract virtual void ForceInitialization();
    public abstract virtual bool EntryExists(object entry, int i);
    public abstract virtual bool NeedsInserting(object entry, int i, IType elemType);
    public abstract virtual bool NeedsUpdating(object entry, int i, IType elemType);
    public abstract virtual IEnumerable GetDeletes(ICollectionPersister persister, bool indexIsFormula);
    public abstract virtual bool IsWrapper(object collection);
    public abstract virtual bool get_WasInitialized();
    public abstract virtual bool get_HasQueuedOperations();
    public abstract virtual IEnumerable get_QueuedAdditionIterator();
    public abstract virtual ICollection GetQueuedOrphans(string entityName);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public abstract virtual Task`1<ICollection> GetQueuedOrphansAsync(string entityName, CancellationToken cancellationToken);
    public abstract virtual void ClearDirty();
    public abstract virtual void Dirty();
    public abstract virtual void PreInsert(ICollectionPersister persister);
    public abstract virtual void AfterRowInsert(ICollectionPersister persister, object entry, int i, object id);
    public abstract virtual ICollection GetOrphans(object snapshot, string entityName);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public abstract virtual Task`1<ICollection> GetOrphansAsync(object snapshot, string entityName, CancellationToken cancellationToken);
}
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.CollectionProxy")]
public class NHibernate.Collection.PersistentArrayHolder : AbstractPersistentCollection {
    private static INHibernateLogger log;
    private Array array;
    private Type elementClass;
    private List`1<object> tempList;
    public object Array { get; protected set; }
    public bool Empty { get; }
    public bool IsDirectlyAccessible { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public PersistentArrayHolder(ISessionImplementor session, object array);
    public PersistentArrayHolder(ISessionImplementor session, ICollectionPersister persister);
    private static PersistentArrayHolder();
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public virtual Task`1<ICollection> GetOrphansAsync(object snapshot, string entityName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.PersistentArrayHolder/<EqualsSnapshotAsync>d__1")]
public virtual Task`1<bool> EqualsSnapshotAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.PersistentArrayHolder/<ReadFromAsync>d__2")]
public virtual Task`1<object> ReadFromAsync(DbDataReader rs, ICollectionPersister role, ICollectionAliases descriptor, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.PersistentArrayHolder/<InitializeFromCacheAsync>d__3")]
public virtual Task InitializeFromCacheAsync(ICollectionPersister persister, object disassembled, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.PersistentArrayHolder/<BeforeAssembleAsync>d__4")]
private Task BeforeAssembleAsync(IType elementType, Object[] cached, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.PersistentArrayHolder/<DisassembleAsync>d__5")]
public virtual Task`1<object> DisassembleAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> GetDeletesAsync(ICollectionPersister persister, bool indexIsFormula, CancellationToken cancellationToken);
    public virtual Task`1<bool> NeedsInsertingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Collection.PersistentArrayHolder/<NeedsUpdatingAsync>d__8")]
public virtual Task`1<bool> NeedsUpdatingAsync(object entry, int i, IType elemType, CancellationToken cancellationToken);
    public object get_Array();
    protected void set_Array(object value);
    public virtual object GetValue();
    public virtual object GetSnapshot(ICollectionPersister persister);
    public virtual bool IsSnapshotEmpty(object snapshot);
    public virtual ICollection GetOrphans(object snapshot, string entityName);
    public virtual bool IsWrapper(object collection);
    public virtual bool EqualsSnapshot(ICollectionPersister persister);
    public ICollection Elements();
    public virtual bool get_Empty();
    public virtual object ReadFrom(DbDataReader rs, ICollectionPersister role, ICollectionAliases descriptor, object owner);
    public virtual IEnumerable Entries(ICollectionPersister persister);
    public virtual void BeginRead();
    public virtual bool EndRead(ICollectionPersister persister);
    public virtual void BeforeInitialize(ICollectionPersister persister, int anticipatedSize);
    public virtual bool get_IsDirectlyAccessible();
    public virtual void InitializeFromCache(ICollectionPersister persister, object disassembled, object owner);
    private void BeforeAssemble(IType elementType, Object[] cached);
    public virtual object Disassemble(ICollectionPersister persister);
    public virtual IEnumerable GetDeletes(ICollectionPersister persister, bool indexIsFormula);
    public virtual bool NeedsInserting(object entry, int i, IType elemType);
    public virtual bool NeedsUpdating(object entry, int i, IType elemType);
    public virtual object GetIndex(object entry, int i, ICollectionPersister persister);
    public virtual object GetElement(object entry);
    public virtual object GetSnapshotElement(object entry, int i);
    public virtual bool EntryExists(object entry, int i);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class NHibernate.Collection.PersistentCollectionExtensions : object {
    private static INHibernateLogger Logger;
    private static PersistentCollectionExtensions();
    [ExtensionAttribute]
public static void ApplyQueuedOperations(IPersistentCollection collection);
}
internal abstract class NHibernate.Collection.Trackers.AbstractCollectionQueueOperationTracker`1 : AbstractQueueOperationTracker {
    public abstract virtual bool AddElement(T element);
    public abstract virtual void RemoveExistingElement(T element, Nullable`1<bool> existsInDb);
    public abstract virtual bool ContainsElement(T element);
    public abstract virtual bool IsElementQueuedForDelete(T element);
    public abstract virtual void RemoveElementAtIndex(int index, T element);
    public abstract virtual void AddElementAtIndex(int index, T element);
    public abstract virtual void SetElementAtIndex(int index, T element, T oldElement);
    public abstract virtual bool TryGetElementAtIndex(int index, T& element);
    public abstract virtual Nullable`1<int> GetDatabaseElementIndex(int index);
}
internal abstract class NHibernate.Collection.Trackers.AbstractCollectionQueueOperationTracker`2 : AbstractCollectionQueueOperationTracker`1<T> {
    public abstract virtual void ApplyChanges(TCollection loadedCollection);
}
internal abstract class NHibernate.Collection.Trackers.AbstractMapQueueOperationTracker`2 : AbstractQueueOperationTracker {
    public abstract virtual bool TryGetElementByKey(TKey elementKey, TValue& element);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void AddElementByKey(TKey elementKey, TValue element);
    public abstract virtual void SetElementByKey(TKey elementKey, TValue element, TValue oldElement, Nullable`1<bool> existsInDb);
    public abstract virtual bool RemoveElementByKey(TKey elementKey, TValue oldElement, Nullable`1<bool> existsInDb);
    public abstract virtual bool IsElementKeyQueuedForDelete(TKey elementKey);
    public abstract virtual void ApplyChanges(IDictionary`2<TKey, TValue> loadedMap);
}
internal abstract class NHibernate.Collection.Trackers.AbstractQueueOperationTracker : object {
    internal static HashSet`1<string> IndexOperations;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DatabaseCollectionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cleared>k__BackingField;
    public Nullable`1<int> DatabaseCollectionSize { get; protected internal set; }
    public bool Cleared { get; protected set; }
    private static AbstractQueueOperationTracker();
    [CompilerGeneratedAttribute]
public virtual Nullable`1<int> get_DatabaseCollectionSize();
    [CompilerGeneratedAttribute]
protected internal virtual void set_DatabaseCollectionSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public virtual bool get_Cleared();
    [CompilerGeneratedAttribute]
protected virtual void set_Cleared(bool value);
    public abstract virtual int GetQueueSize();
    public int GetCollectionSize();
    public virtual bool RequiresDatabaseCollectionSize(string operationName);
    public virtual bool RequiresFlushing(string operationName);
    public abstract virtual void AfterFlushing();
    public virtual void BeforeOperation(string operationName);
    public virtual void ClearCollection();
    public abstract virtual IEnumerable GetAddedElements();
    public abstract virtual IEnumerable GetOrphans();
    public abstract virtual bool HasChanges();
}
internal class NHibernate.Collection.Trackers.BagQueueOperationTracker`1 : CollectionQueueOperationTracker`2<T, IList`1<T>> {
    public BagQueueOperationTracker`1(ICollectionPersister collectionPersister);
    public virtual void AfterFlushing();
    public virtual void ApplyChanges(IList`1<T> loadedCollection);
}
internal class NHibernate.Collection.Trackers.ClearedListQueueOperationTracker`1 : AbstractCollectionQueueOperationTracker`2<T, IList`1<T>> {
    protected IList`1<T> Collection;
    private ICollectionPersister _collectionPersister;
    public bool Cleared { get; protected set; }
    public ClearedListQueueOperationTracker`1(ICollectionPersister collectionPersister);
    public virtual bool AddElement(T element);
    public virtual void RemoveExistingElement(T element, Nullable`1<bool> existsInDb);
    public virtual bool get_Cleared();
    protected virtual void set_Cleared(bool value);
    public virtual void AfterFlushing();
    public virtual void ClearCollection();
    public virtual bool ContainsElement(T element);
    public virtual int GetQueueSize();
    public virtual bool IsElementQueuedForDelete(T element);
    public virtual bool HasChanges();
    public virtual void ApplyChanges(IList`1<T> loadedCollection);
    public virtual Nullable`1<int> GetDatabaseElementIndex(int index);
    public virtual bool TryGetElementAtIndex(int index, T& element);
    public virtual void RemoveElementAtIndex(int index, T element);
    public virtual void AddElementAtIndex(int index, T element);
    public virtual void SetElementAtIndex(int index, T element, T oldElement);
    public virtual IEnumerable GetAddedElements();
    public virtual IEnumerable GetOrphans();
    private IList`1<T> GetOrCreateQueue();
}
internal abstract class NHibernate.Collection.Trackers.CollectionQueueOperationTracker`2 : AbstractCollectionQueueOperationTracker`2<T, TCollection> {
    protected TCollection Queue;
    protected ISet`1<T> RemovalQueue;
    protected int QueueSize;
    protected ISet`1<T> Orphans;
    protected ICollectionPersister CollectionPersister;
    protected CollectionQueueOperationTracker`2(ICollectionPersister collectionPersister);
    public virtual bool AddElement(T element);
    protected virtual bool Add(T element);
    public virtual void AfterFlushing();
    public virtual bool HasChanges();
    public virtual void ApplyChanges(TCollection loadedCollection);
    public virtual bool RequiresFlushing(string operationName);
    public virtual void RemoveExistingElement(T element, Nullable`1<bool> existsInDb);
    public virtual void ClearCollection();
    public virtual bool ContainsElement(T element);
    public virtual int GetQueueSize();
    public virtual bool IsElementQueuedForDelete(T element);
    public virtual IEnumerable GetAddedElements();
    public virtual IEnumerable GetOrphans();
    public virtual void RemoveElementAtIndex(int index, T element);
    public virtual void AddElementAtIndex(int index, T element);
    public virtual void SetElementAtIndex(int index, T element, T oldElement);
    public virtual bool TryGetElementAtIndex(int index, T& element);
    public virtual Nullable`1<int> GetDatabaseElementIndex(int index);
    protected ISet`1<T> GetOrCreateRemovalQueue();
    protected ISet`1<T> GetOrCreateOrphansSet();
    private void InitializeQueue();
}
internal class NHibernate.Collection.Trackers.IndexedListQueueOperationTracker`1 : AbstractCollectionQueueOperationTracker`2<T, IList`1<T>> {
    private static KeyValuePairComparer<T> Comparer;
    private List`1<KeyValuePair`2<int, T>> _queue;
    private int _queueSize;
    private List`1<KeyValuePair`2<int, T>> _removedDbIndexes;
    private ISet`1<T> _removalQueue;
    public bool Cleared { get; protected set; }
    private static IndexedListQueueOperationTracker`1();
    public virtual bool RequiresFlushing(string operationName);
    public virtual bool RequiresDatabaseCollectionSize(string operationName);
    public virtual bool ContainsElement(T element);
    public virtual bool IsElementQueuedForDelete(T element);
    public virtual bool HasChanges();
    public virtual void ApplyChanges(IList`1<T> loadedCollection);
    public virtual bool AddElement(T element);
    public virtual void RemoveExistingElement(T element, Nullable`1<bool> existsInDb);
    public virtual void ClearCollection();
    public virtual void AfterFlushing();
    public virtual IEnumerable GetAddedElements();
    public virtual IEnumerable GetOrphans();
    public virtual bool get_Cleared();
    protected virtual void set_Cleared(bool value);
    public virtual int GetQueueSize();
    public virtual Nullable`1<int> GetDatabaseElementIndex(int index);
    public virtual bool TryGetElementAtIndex(int index, T& element);
    public virtual void RemoveElementAtIndex(int index, T element);
    public virtual void AddElementAtIndex(int index, T element);
    public virtual void SetElementAtIndex(int index, T element, T oldElement);
    private static int GetQueueIndex(List`1& queue, KeyValuePair`2<int, T> pair, bool rawResult);
    private static int GetQueueIndex(List`1& queue, TType item, bool rawResult, IComparer`1<TType> comparer);
    private ISet`1<T> GetOrCreateRemovalQueue();
}
internal class NHibernate.Collection.Trackers.ListQueueOperationTracker`1 : AbstractCollectionQueueOperationTracker`2<T, IList`1<T>> {
    private ICollectionPersister _collectionPersister;
    private AbstractCollectionQueueOperationTracker`2<T, IList`1<T>> _tracker;
    public Nullable`1<int> DatabaseCollectionSize { get; protected internal set; }
    public ListQueueOperationTracker`1(ICollectionPersister collectionPersister);
    public virtual Nullable`1<int> get_DatabaseCollectionSize();
    protected internal virtual void set_DatabaseCollectionSize(Nullable`1<int> value);
    public virtual bool RequiresDatabaseCollectionSize(string operationName);
    public virtual int GetQueueSize();
    public virtual void ClearCollection();
    public virtual IEnumerable GetAddedElements();
    public virtual IEnumerable GetOrphans();
    public virtual bool RequiresFlushing(string operationName);
    public virtual void AfterFlushing();
    public virtual void BeforeOperation(string operationName);
    public virtual bool AddElement(T element);
    public virtual void RemoveExistingElement(T element, Nullable`1<bool> existsInDb);
    public virtual bool ContainsElement(T element);
    public virtual bool IsElementQueuedForDelete(T element);
    public virtual void RemoveElementAtIndex(int index, T element);
    public virtual void AddElementAtIndex(int index, T element);
    public virtual void SetElementAtIndex(int index, T element, T oldElement);
    public virtual bool TryGetElementAtIndex(int index, T& element);
    public virtual Nullable`1<int> GetDatabaseElementIndex(int index);
    public virtual void ApplyChanges(IList`1<T> loadedCollection);
    private AbstractCollectionQueueOperationTracker`2<T, IList`1<T>> GetOrCreateStrategy();
    private AbstractCollectionQueueOperationTracker`2<T, IList`1<T>> GetOrCreateIndexedStrategy();
    public virtual bool HasChanges();
}
internal class NHibernate.Collection.Trackers.MapQueueOperationTracker`2 : AbstractMapQueueOperationTracker`2<TKey, TValue> {
    private ICollectionPersister _collectionPersister;
    private IDictionary`2<TKey, TValue> _queue;
    private IDictionary`2<TKey, TValue> _orphanMap;
    private ISet`1<TKey> _removalQueue;
    private int _queueSize;
    public MapQueueOperationTracker`2(ICollectionPersister collectionPersister);
    public virtual void AfterFlushing();
    public virtual void ClearCollection();
    public virtual IEnumerable GetAddedElements();
    public virtual IEnumerable GetOrphans();
    public virtual void AddElementByKey(TKey elementKey, TValue element);
    public virtual bool ContainsKey(TKey key);
    public virtual int GetQueueSize();
    public virtual bool IsElementKeyQueuedForDelete(TKey elementKey);
    public virtual bool RemoveElementByKey(TKey elementKey, TValue oldElement, Nullable`1<bool> existsInDb);
    public virtual void SetElementByKey(TKey elementKey, TValue element, TValue oldElement, Nullable`1<bool> existsInDb);
    public virtual bool TryGetElementByKey(TKey elementKey, TValue& element);
    public virtual bool HasChanges();
    public virtual void ApplyChanges(IDictionary`2<TKey, TValue> loadedMap);
    private IDictionary`2<TKey, TValue> GetOrCreateQueue();
    private IDictionary`2<TKey, TValue> GetOrCreateOrphanMap();
    private ISet`1<TKey> GetOrCreateRemovalQueue();
}
internal class NHibernate.Collection.Trackers.NonIndexedListQueueOperationTracker`1 : CollectionQueueOperationTracker`2<T, IList`1<T>> {
    public NonIndexedListQueueOperationTracker`1(ICollectionPersister collectionPersister);
}
internal class NHibernate.Collection.Trackers.SetQueueOperationTracker`1 : CollectionQueueOperationTracker`2<T, ISet`1<T>> {
    public SetQueueOperationTracker`1(ICollectionPersister collectionPersister);
    protected virtual bool Add(T element);
}
public abstract class NHibernate.Connection.ConnectionProvider : object {
    private static INHibernateLogger log;
    private string connString;
    private IDriver driver;
    private bool _isAlreadyDisposed;
    protected internal string ConnectionString { get; }
    public IDriver Driver { get; }
    private static ConnectionProvider();
    public virtual Task`1<DbConnection> GetConnectionAsync(CancellationToken cancellationToken);
    public virtual Task`1<DbConnection> GetConnectionAsync(string connectionString, CancellationToken cancellationToken);
    public virtual void CloseConnection(DbConnection conn);
    public virtual void Configure(IDictionary`2<string, string> settings);
    protected virtual string GetNamedConnectionString(IDictionary`2<string, string> settings);
    protected virtual void ConfigureDriver(IDictionary`2<string, string> settings);
    protected internal virtual string get_ConnectionString();
    public sealed virtual IDriver get_Driver();
    public virtual DbConnection GetConnection();
    public virtual DbConnection GetConnection(string connectionString);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
}
[ExtensionAttribute]
public static class NHibernate.Connection.ConnectionProviderExtensions : object {
    [ExtensionAttribute]
internal static Task`1<DbConnection> GetConnectionAsync(IConnectionProvider connectionProvider, string connectionString, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static DbConnection GetConnection(IConnectionProvider connectionProvider, string connectionString);
    [ExtensionAttribute]
public static string GetConnectionString(IConnectionProvider connectionProvider);
}
public static class NHibernate.Connection.ConnectionProviderFactory : object {
    private static INHibernateLogger log;
    private static ConnectionProviderFactory();
    public static IConnectionProvider NewConnectionProvider(IDictionary`2<string, string> settings);
}
public class NHibernate.Connection.DriverConnectionProvider : ConnectionProvider {
    private static INHibernateLogger log;
    private static DriverConnectionProvider();
    [AsyncStateMachineAttribute("NHibernate.Connection.DriverConnectionProvider/<GetConnectionAsync>d__0")]
public virtual Task`1<DbConnection> GetConnectionAsync(string connectionString, CancellationToken cancellationToken);
    public virtual void CloseConnection(DbConnection conn);
    public virtual DbConnection GetConnection(string connectionString);
}
public interface NHibernate.Connection.IConnectionAccess {
    public string ConnectionString { get; }
    public abstract virtual Task`1<DbConnection> GetConnectionAsync(CancellationToken cancellationToken);
    public abstract virtual string get_ConnectionString();
    public abstract virtual DbConnection GetConnection();
    public abstract virtual void CloseConnection(DbConnection connection);
}
public interface NHibernate.Connection.IConnectionProvider {
    public IDriver Driver { get; }
    public abstract virtual Task`1<DbConnection> GetConnectionAsync(CancellationToken cancellationToken);
    public abstract virtual void Configure(IDictionary`2<string, string> settings);
    public abstract virtual void CloseConnection(DbConnection conn);
    public abstract virtual IDriver get_Driver();
    public abstract virtual DbConnection GetConnection();
}
public class NHibernate.Connection.UserSuppliedConnectionProvider : ConnectionProvider {
    private static INHibernateLogger log;
    private static UserSuppliedConnectionProvider();
    public virtual Task`1<DbConnection> GetConnectionAsync(string connectionString, CancellationToken cancellationToken);
    public virtual void CloseConnection(DbConnection conn);
    public virtual DbConnection GetConnection(string connectionString);
    public virtual void Configure(IDictionary`2<string, string> settings);
}
public enum NHibernate.ConnectionReleaseMode : Enum {
    public int value__;
    public static ConnectionReleaseMode AfterStatement;
    public static ConnectionReleaseMode AfterTransaction;
    public static ConnectionReleaseMode OnClose;
}
public static class NHibernate.ConnectionReleaseModeParser : object {
    public static ConnectionReleaseMode Convert(string value);
    public static string ToString(ConnectionReleaseMode value);
}
public class NHibernate.Context.AsyncLocalSessionContext : CurrentSessionContext {
    private AsyncLocal`1<ISession> _session;
    protected ISession Session { get; protected set; }
    public AsyncLocalSessionContext(ISessionFactoryImplementor factory);
    protected virtual ISession get_Session();
    protected virtual void set_Session(ISession value);
}
public class NHibernate.Context.CallSessionContext : MapBasedSessionContext {
    private static AsyncLocal`1<IDictionary> SessionFactoryMap;
    public CallSessionContext(ISessionFactoryImplementor factory);
    private static CallSessionContext();
    protected virtual void SetMap(IDictionary value);
    protected virtual IDictionary GetMap();
}
public abstract class NHibernate.Context.CurrentSessionContext : object {
    protected ISession Session { get; protected set; }
    protected abstract virtual ISession get_Session();
    protected abstract virtual void set_Session(ISession value);
    public virtual ISession CurrentSession();
    public static void Bind(ISession session);
    public static bool HasBind(ISessionFactory factory);
    public static ISession Unbind(ISessionFactory factory);
    private static CurrentSessionContext GetCurrentSessionContext(ISessionFactory factory);
}
public interface NHibernate.Context.ICurrentSessionContext {
    public abstract virtual ISession CurrentSession();
}
public interface NHibernate.Context.ISessionFactoryAwareCurrentSessionContext {
    public abstract virtual void SetFactory(ISessionFactoryImplementor factory);
}
public abstract class NHibernate.Context.MapBasedSessionContext : CurrentSessionContext {
    private ISessionFactoryImplementor _factory;
    private static object _locker;
    protected ISession Session { get; protected set; }
    protected MapBasedSessionContext(ISessionFactoryImplementor factory);
    private static MapBasedSessionContext();
    protected virtual ISession get_Session();
    protected virtual void set_Session(ISession value);
    private ConcurrentDictionary`2<ISessionFactoryImplementor, ISession> GetConcreteMap();
    protected abstract virtual IDictionary GetMap();
    protected abstract virtual void SetMap(IDictionary value);
}
public static class NHibernate.Context.ReflectiveHttpContext : object {
    [CompilerGeneratedAttribute]
private static Func`1<object> <HttpContextCurrentGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<object, IDictionary> <HttpContextItemsGetter>k__BackingField;
    public static Func`1<object> HttpContextCurrentGetter { get; private set; }
    public static Func`2<object, IDictionary> HttpContextItemsGetter { get; private set; }
    public static IDictionary HttpContextCurrentItems { get; }
    private static Type HttpContextType { get; }
    private static ReflectiveHttpContext();
    [CompilerGeneratedAttribute]
public static Func`1<object> get_HttpContextCurrentGetter();
    [CompilerGeneratedAttribute]
private static void set_HttpContextCurrentGetter(Func`1<object> value);
    [CompilerGeneratedAttribute]
public static Func`2<object, IDictionary> get_HttpContextItemsGetter();
    [CompilerGeneratedAttribute]
private static void set_HttpContextItemsGetter(Func`2<object, IDictionary> value);
    public static IDictionary get_HttpContextCurrentItems();
    private static Type get_HttpContextType();
    private static void CreateCurrentHttpContextGetter();
    private static void CreateHttpContextItemsGetter();
}
public class NHibernate.Context.ThreadLocalSessionContext : object {
    private static INHibernateLogger log;
    [ThreadStaticAttribute]
protected static IDictionary`2<ISessionFactory, ISession> context;
    protected ISessionFactoryImplementor factory;
    public ThreadLocalSessionContext(ISessionFactoryImplementor factory);
    private static ThreadLocalSessionContext();
    [AsyncStateMachineAttribute("NHibernate.Context.ThreadLocalSessionContext/<CleanupAnyOrphanedSessionAsync>d__0")]
private static Task CleanupAnyOrphanedSessionAsync(ISessionFactory factory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Context.ThreadLocalSessionContext/<BindAsync>d__1")]
public static Task BindAsync(ISession session, CancellationToken cancellationToken);
    public sealed virtual ISession CurrentSession();
    private static void CleanupAnyOrphanedSession(ISessionFactory factory);
    public static void Bind(ISession session);
    public static ISession Unbind(ISessionFactory factory);
    private static void DoBind(ISession current, ISessionFactory factory);
    private static ISession DoUnbind(ISessionFactory factory, bool releaseMapIfEmpty);
    private ISession Wrap(ISession current);
    private bool NeedsWrapping(ISession current);
    protected ISession BuildOrObtainSession();
    private ConnectionReleaseMode GetConnectionReleaseMode();
    protected virtual bool IsAutoCloseEnabled();
    [ObsoleteAttribute("Had never any implementation, has always had no effect.")]
protected virtual bool IsAutoFlushEnabled();
    private static ISession ExistingSession(ISessionFactory factory);
}
public class NHibernate.Context.ThreadStaticSessionContext : MapBasedSessionContext {
    [ThreadStaticAttribute]
private static IDictionary _map;
    public ThreadStaticSessionContext(ISessionFactoryImplementor factory);
    protected virtual IDictionary GetMap();
    protected virtual void SetMap(IDictionary value);
}
[ObsoleteAttribute("Not supported in this platform", "True")]
public class NHibernate.Context.WcfOperationSessionContext : MapBasedSessionContext {
    public WcfOperationSessionContext(ISessionFactoryImplementor factory);
    protected virtual IDictionary GetMap();
    protected virtual void SetMap(IDictionary value);
}
public class NHibernate.Context.WebSessionContext : MapBasedSessionContext {
    private static string SessionFactoryMapKey;
    public WebSessionContext(ISessionFactoryImplementor factory);
    protected virtual IDictionary GetMap();
    protected virtual void SetMap(IDictionary value);
}
public static class NHibernate.CriteriaTransformer : object {
    public static DetachedCriteria TransformToRowCount(DetachedCriteria criteria);
    public static ICriteria TransformToRowCount(ICriteria criteria);
    private static CriteriaImpl TransformToRowCount(CriteriaImpl criteria);
    public static DetachedCriteria Clone(DetachedCriteria criteria);
    public static ICriteria Clone(ICriteria criteria);
}
public abstract class NHibernate.Criterion.AbstractCriterion : object {
    public abstract virtual string ToString();
    public abstract virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual IProjection[] GetProjections();
    public static AbstractCriterion op_BitwiseAnd(AbstractCriterion lhs, AbstractCriterion rhs);
    public static AbstractCriterion op_BitwiseOr(AbstractCriterion lhs, AbstractCriterion rhs);
    public static AbstractCriterion op_BitwiseAnd(AbstractCriterion lhs, AbstractEmptinessExpression rhs);
    public static AbstractCriterion op_BitwiseOr(AbstractCriterion lhs, AbstractEmptinessExpression rhs);
    public static AbstractCriterion op_LogicalNot(AbstractCriterion crit);
    public static bool op_False(AbstractCriterion criteria);
    public static bool op_True(AbstractCriterion criteria);
}
public abstract class NHibernate.Criterion.AbstractEmptinessExpression : AbstractCriterion {
    private TypedValue[] NO_VALUES;
    private string propertyName;
    protected bool ExcludeEmpty { get; }
    protected AbstractEmptinessExpression(string propertyName);
    protected abstract virtual bool get_ExcludeEmpty();
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual string ToString();
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    protected IQueryableCollection GetQueryableCollection(string entityName, string actualPropertyName, ISessionFactoryImplementor factory);
}
public class NHibernate.Criterion.AggregateProjection : SimpleProjection {
    protected string aggregate;
    protected IProjection projection;
    protected string propertyName;
    public bool IsAggregate { get; }
    public bool IsGrouped { get; }
    protected internal AggregateProjection(string aggregate, string propertyName);
    protected internal AggregateProjection(string aggregate, IProjection projection);
    public virtual bool get_IsAggregate();
    public virtual string ToString();
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToSqlString(ICriteria criteria, int loc, ICriteriaQuery criteriaQuery);
    public virtual bool get_IsGrouped();
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.AliasedProjection : object {
    private IProjection projection;
    private string alias;
    public String[] Aliases { get; }
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    protected internal AliasedProjection(IProjection projection, string alias);
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(string alias, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] GetColumnAliases(int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] GetColumnAliases(string alias, int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual String[] get_Aliases();
    public virtual bool get_IsGrouped();
    public sealed virtual bool get_IsAggregate();
    public sealed virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
}
public class NHibernate.Criterion.AndExpression : LogicalExpression {
    protected string Op { get; }
    public AndExpression(ICriterion lhs, ICriterion rhs);
    protected virtual string get_Op();
}
public class NHibernate.Criterion.AvgProjection : AggregateProjection {
    public AvgProjection(IProjection projection);
    public AvgProjection(string propertyName);
    public virtual SqlString ToSqlString(ICriteria criteria, int loc, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.BetweenExpression : AbstractCriterion {
    private object _hi;
    private object _lo;
    private IProjection _projection;
    private string _propertyName;
    public BetweenExpression(IProjection projection, object lo, object hi);
    public BetweenExpression(string propertyName, object lo, object hi);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual string ToString();
}
public class NHibernate.Criterion.CastProjection : SimpleProjection {
    private IType type;
    private IProjection projection;
    public bool IsAggregate { get; }
    public bool IsGrouped { get; }
    public CastProjection(IType type, IProjection projection);
    public virtual bool get_IsAggregate();
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual bool get_IsGrouped();
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.ConditionalProjection : SimpleProjection {
    private ConditionalProjectionCase[] _cases;
    private IProjection _elseProjection;
    public bool IsAggregate { get; }
    public bool IsGrouped { get; }
    public ConditionalProjection(ICriterion criterion, IProjection whenTrue, IProjection whenFalse);
    public ConditionalProjection(ConditionalProjectionCase[] cases, IProjection elseProjection);
    public virtual bool get_IsAggregate();
    public virtual bool get_IsGrouped();
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private static bool AreTypesEqual(IType[] types1, IType[] types2);
    private void AddToGroupedSql(SqlStringBuilder sqlBuilder, IProjection[] projections, ICriteria criteria, ICriteriaQuery criteriaQuery);
    private void AddToGroupedSql(SqlStringBuilder sqlBuilder, IProjection projection, ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.ConditionalProjectionCase : object {
    [CompilerGeneratedAttribute]
private ICriterion <Criterion>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjection <Projection>k__BackingField;
    public ICriterion Criterion { get; }
    public IProjection Projection { get; }
    public ConditionalProjectionCase(ICriterion criterion, IProjection projection);
    [CompilerGeneratedAttribute]
public ICriterion get_Criterion();
    [CompilerGeneratedAttribute]
public IProjection get_Projection();
}
public class NHibernate.Criterion.Conjunction : Junction {
    protected string Op { get; }
    protected SqlString EmptyExpression { get; }
    protected virtual string get_Op();
    protected virtual SqlString get_EmptyExpression();
}
public class NHibernate.Criterion.ConstantProjection : SimpleProjection {
    private object value;
    [CompilerGeneratedAttribute]
private TypedValue <TypedValue>k__BackingField;
    public TypedValue TypedValue { get; }
    public bool IsAggregate { get; }
    public bool IsGrouped { get; }
    public ConstantProjection(object value);
    public ConstantProjection(object value, IType type);
    [CompilerGeneratedAttribute]
public TypedValue get_TypedValue();
    public virtual bool get_IsAggregate();
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual bool get_IsGrouped();
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.CountProjection : AggregateProjection {
    private bool distinct;
    protected internal CountProjection(string prop);
    protected internal CountProjection(IProjection projection);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public CountProjection SetDistinct();
}
[ExtensionAttribute]
internal static class NHibernate.Criterion.CriteriaQueryExtensions : object {
    [ExtensionAttribute]
public static SqlString RenderSQLAliases(ICriteriaQuery criteriaQuery, SqlString sqlTemplate);
}
public static class NHibernate.Criterion.CriteriaSpecification : object {
    public static string RootAlias;
    public static IResultTransformer AliasToEntityMap;
    public static IResultTransformer RootEntity;
    public static IResultTransformer DistinctRootEntity;
    public static IResultTransformer Projection;
    public static JoinType InnerJoin;
    public static JoinType FullJoin;
    public static JoinType LeftJoin;
    private static CriteriaSpecification();
}
public static class NHibernate.Criterion.CriterionUtil : object {
    public static SqlString[] GetColumnNames(string propertyName, IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria);
    public static SqlString[] GetColumnNamesForSimpleExpression(string propertyName, IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria, ICriterion criterion, object value);
    internal static SqlString[] GetColumnNamesUsingProjection(IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria);
    internal static Object[] GetColumnNamesAsSqlStringParts(string propertyName, IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria);
    internal static Object[] GetColumnNamesAsSqlStringParts(IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria);
    internal static object GetColumnNameAsSqlStringPart(string propertyName, IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria);
    internal static object GetColumnNameAsSqlStringPart(IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria);
    private static SqlString[] GetProjectionColumns(IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria);
    private static SqlString[] GetColumnNamesUsingPropertyName(ICriteriaQuery criteriaQuery, ICriteria criteria, string propertyName);
    private static SqlString[] GetColumnNamesUsingPropertyName(ICriteriaQuery criteriaQuery, ICriteria criteria, string propertyName, object value, ICriterion critertion);
    public static TypedValue[] GetTypedValues(ICriteriaQuery criteriaQuery, ICriteria criteria, IProjection projection, string propertyName, Object[] values);
    public static TypedValue GetTypedValue(ICriteriaQuery criteriaQuery, ICriteria criteria, IProjection projection, string propertyName, object value);
}
public class NHibernate.Criterion.DetachedCriteria : object {
    private CriteriaImpl impl;
    private ICriteria criteria;
    public string Alias { get; }
    public string EntityOrClassName { get; }
    protected DetachedCriteria(Type entityType);
    protected DetachedCriteria(Type entityType, string alias);
    protected DetachedCriteria(string entityName);
    protected DetachedCriteria(string entityName, string alias);
    protected internal DetachedCriteria(CriteriaImpl impl, ICriteria criteria);
    internal DetachedCriteria(CriteriaImpl impl);
    public ICriteria GetExecutableCriteria(ISession session);
    public ICriteria GetExecutableCriteria(IStatelessSession session);
    public static DetachedCriteria For(Type entityType);
    public static DetachedCriteria For();
    public static DetachedCriteria For(string alias);
    public static DetachedCriteria For(Type entityType, string alias);
    public static DetachedCriteria ForEntityName(string entityName);
    public static DetachedCriteria ForEntityName(string entityName, string alias);
    public DetachedCriteria Add(ICriterion criterion);
    public DetachedCriteria AddOrder(Order order);
    public DetachedCriteria CreateAlias(string associationPath, string alias);
    public DetachedCriteria CreateAlias(string associationPath, string alias, JoinType joinType);
    public DetachedCriteria CreateAlias(string associationPath, string alias, JoinType joinType, ICriterion withClause);
    public DetachedCriteria CreateCriteria(string associationPath, string alias);
    public DetachedCriteria CreateCriteria(string associationPath);
    public DetachedCriteria CreateCriteria(string associationPath, JoinType joinType);
    public DetachedCriteria CreateCriteria(string associationPath, string alias, JoinType joinType);
    public DetachedCriteria CreateCriteria(string associationPath, string alias, JoinType joinType, ICriterion withClause);
    public string get_Alias();
    public string get_EntityOrClassName();
    protected internal CriteriaImpl GetCriteriaImpl();
    [ObsoleteAttribute("Use Fetch instead")]
public DetachedCriteria SetFetchMode(string associationPath, FetchMode mode);
    public DetachedCriteria SetLockMode(LockMode lockMode);
    public DetachedCriteria SetLockMode(string alias, LockMode lockMode);
    public DetachedCriteria SetCacheMode(CacheMode cacheMode);
    public DetachedCriteria SetCacheRegion(string region);
    public DetachedCriteria SetCacheable(bool cacheable);
    public DetachedCriteria SetProjection(IProjection projection);
    public DetachedCriteria SetResultTransformer(IResultTransformer resultTransformer);
    public DetachedCriteria SetFirstResult(int firstResult);
    public DetachedCriteria SetMaxResults(int maxResults);
    public virtual string ToString();
    public DetachedCriteria GetCriteriaByPath(string path);
    public DetachedCriteria GetCriteriaByAlias(string alias);
    public Type GetRootEntityTypeIfAvailable();
    public void ClearOrders();
}
public class NHibernate.Criterion.Disjunction : Junction {
    protected string Op { get; }
    protected SqlString EmptyExpression { get; }
    protected virtual string get_Op();
    protected virtual SqlString get_EmptyExpression();
}
public class NHibernate.Criterion.Distinct : object {
    private IProjection projection;
    public String[] Aliases { get; }
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    public Distinct(IProjection proj);
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(string alias, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual String[] GetColumnAliases(int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual String[] GetColumnAliases(string alias, int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual String[] get_Aliases();
    public virtual bool get_IsGrouped();
    public sealed virtual bool get_IsAggregate();
    public sealed virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
}
public class NHibernate.Criterion.EntityProjection : object {
    private string _entityAlias;
    private Type _entityType;
    private IType[] _types;
    private String[] _identifierColumnAliases;
    [CompilerGeneratedAttribute]
private bool <FetchLazyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <FetchLazyPropertyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Lazy>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryable <Persister>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnAliasSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableAlias>k__BackingField;
    public bool FetchLazyProperties { get; public set; }
    public ICollection`1<string> FetchLazyPropertyGroups { get; public set; }
    public bool Lazy { get; public set; }
    internal IQueryable Persister { get; private set; }
    internal string ColumnAliasSuffix { get; private set; }
    internal string TableAlias { get; private set; }
    private String[] NHibernate.Criterion.IProjection.Aliases { get; }
    private bool NHibernate.Criterion.IProjection.IsAggregate { get; }
    private bool NHibernate.Criterion.IProjection.IsGrouped { get; }
    public EntityProjection(Type entityType, string entityAlias);
    [CompilerGeneratedAttribute]
public bool get_FetchLazyProperties();
    [CompilerGeneratedAttribute]
public void set_FetchLazyProperties(bool value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_FetchLazyPropertyGroups();
    [CompilerGeneratedAttribute]
public void set_FetchLazyPropertyGroups(ICollection`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_Lazy();
    [CompilerGeneratedAttribute]
public void set_Lazy(bool value);
    [CompilerGeneratedAttribute]
internal IQueryable get_Persister();
    [CompilerGeneratedAttribute]
private void set_Persister(IQueryable value);
    [CompilerGeneratedAttribute]
internal string get_ColumnAliasSuffix();
    [CompilerGeneratedAttribute]
private void set_ColumnAliasSuffix(string value);
    [CompilerGeneratedAttribute]
internal string get_TableAlias();
    [CompilerGeneratedAttribute]
private void set_TableAlias(string value);
    public EntityProjection SetLazy(bool lazy);
    public EntityProjection SetFetchLazyProperties(bool fetchLazyProperties);
    public EntityProjection SetFetchLazyPropertyGroups(String[] lazyPropertyGroups);
    private sealed virtual override String[] NHibernate.Criterion.IProjection.get_Aliases();
    private sealed virtual override bool NHibernate.Criterion.IProjection.get_IsAggregate();
    private sealed virtual override bool NHibernate.Criterion.IProjection.get_IsGrouped();
    private sealed virtual override IType[] NHibernate.Criterion.IProjection.GetTypes(string alias, ICriteria criteria, ICriteriaQuery criteriaQuery);
    private sealed virtual override String[] NHibernate.Criterion.IProjection.GetColumnAliases(string alias, int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    private sealed virtual override IType[] NHibernate.Criterion.IProjection.GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private sealed virtual override String[] NHibernate.Criterion.IProjection.GetColumnAliases(int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    private sealed virtual override SqlString NHibernate.Criterion.IProjection.ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    private SelectFragment GetPropertySelectFragment();
    private sealed virtual override SqlString NHibernate.Criterion.IProjection.ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private sealed virtual override TypedValue[] NHibernate.Criterion.IProjection.GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private void SetFields(ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.EqPropertyExpression : PropertyExpression {
    protected string Op { get; }
    public EqPropertyExpression(string lhsPropertyName, IProjection rhsProjection);
    public EqPropertyExpression(IProjection lhsProjection, IProjection rhsProjection);
    public EqPropertyExpression(IProjection lhsProjection, string rhsPropertyName);
    public EqPropertyExpression(string lhsPropertyName, string rhsPropertyName);
    protected virtual string get_Op();
}
public class NHibernate.Criterion.Example : AbstractCriterion {
    private object _entity;
    private HashSet`1<string> _excludedProperties;
    private IPropertySelector _selector;
    private bool _isLikeEnabled;
    private Nullable`1<char> escapeCharacter;
    private bool _isIgnoreCaseEnabled;
    private MatchMode _matchMode;
    protected static IPropertySelector NotNullOrEmptyString;
    protected static IPropertySelector All;
    protected static IPropertySelector NotNullOrZero;
    protected Example(object entity, IPropertySelector selector);
    private static Example();
    public virtual Example SetEscapeCharacter(Nullable`1<char> escapeCharacter);
    public Example SetPropertySelector(IPropertySelector selector);
    public Example ExcludeZeroes();
    public Example ExcludeNone();
    public Example ExcludeNulls();
    public Example EnableLike(MatchMode matchMode);
    public Example EnableLike();
    public Example IgnoreCase();
    public Example ExcludeProperty(string name);
    public static Example Create(object entity);
    public virtual string ToString();
    private bool IsPropertyIncluded(object value, string name, IType type);
    private Object[] GetPropertyValues(IEntityPersister persister, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    protected void AddPropertyTypedValue(object value, IType type, IList list);
    protected void AddComponentTypedValues(string path, object component, IAbstractComponentType type, IList list, ICriteria criteria, ICriteriaQuery criteriaQuery);
    protected void AppendPropertyCondition(string propertyName, object propertyValue, ICriteria criteria, ICriteriaQuery cq, SqlStringBuilder builder);
    protected virtual ICriterion GetNotNullPropertyCriterion(object propertyValue, string propertyName);
    protected void AppendComponentCondition(string path, object component, IAbstractComponentType type, ICriteria criteria, ICriteriaQuery criteriaQuery, SqlStringBuilder builder);
}
public class NHibernate.Criterion.ExistsSubqueryExpression : SubqueryExpression {
    internal ExistsSubqueryExpression(string quantifier, DetachedCriteria dc);
    protected virtual SqlString ToLeftSqlString(ICriteria criteria, ICriteriaQuery outerQuery);
}
public class NHibernate.Criterion.Expression : Restrictions {
    public static AbstractCriterion Sql(SqlString sql, Object[] values, IType[] types);
    public static AbstractCriterion Sql(SqlString sql, object value, IType type);
    public static AbstractCriterion Sql(string sql, object value, IType type);
    public static AbstractCriterion Sql(string sql, Object[] values, IType[] types);
    public static AbstractCriterion Sql(SqlString sql);
    public static AbstractCriterion Sql(string sql);
}
public class NHibernate.Criterion.GePropertyExpression : PropertyExpression {
    protected string Op { get; }
    public GePropertyExpression(string lhsPropertyName, IProjection rhsProjection);
    public GePropertyExpression(IProjection lhsProjection, IProjection rhsProjection);
    public GePropertyExpression(IProjection lhsProjection, string rhsPropertyName);
    public GePropertyExpression(string lhsPropertyName, string rhsPropertyName);
    protected virtual string get_Op();
}
public class NHibernate.Criterion.GroupedProjection : object {
    private IProjection projection;
    private SqlString renderedProjection;
    public String[] Aliases { get; }
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    public GroupedProjection(IProjection projection);
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IType[] GetTypes(string alias, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] GetColumnAliases(int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] GetColumnAliases(string alias, int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual String[] get_Aliases();
    public virtual bool get_IsGrouped();
    public sealed virtual bool get_IsAggregate();
    public sealed virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
}
public class NHibernate.Criterion.GtPropertyExpression : PropertyExpression {
    protected string Op { get; }
    public GtPropertyExpression(string lhsPropertyName, IProjection rhsProjection);
    public GtPropertyExpression(IProjection lhsProjection, IProjection rhsProjection);
    public GtPropertyExpression(IProjection lhsProjection, string rhsPropertyName);
    public GtPropertyExpression(string lhsPropertyName, string rhsPropertyName);
    protected virtual string get_Op();
}
public interface NHibernate.Criterion.ICriteriaQuery {
    public ISessionFactoryImplementor Factory { get; }
    public ICollection`1<IParameterSpecification> CollectedParameterSpecifications { get; }
    public ICollection`1<NamedParameter> CollectedParameters { get; }
    public abstract virtual ISessionFactoryImplementor get_Factory();
    public abstract virtual string GetColumn(ICriteria criteria, string propertyPath);
    public abstract virtual String[] GetColumns(ICriteria criteria, string propertyPath);
    public abstract virtual IType GetType(ICriteria criteria, string propertyPath);
    public abstract virtual String[] GetColumnAliasesUsingProjection(ICriteria criteria, string propertyPath);
    public abstract virtual String[] GetColumnsUsingProjection(ICriteria criteria, string propertyPath);
    public abstract virtual IType GetTypeUsingProjection(ICriteria criteria, string propertyPath);
    public abstract virtual TypedValue GetTypedValue(ICriteria criteria, string propertyPath, object value);
    public abstract virtual string GetEntityName(ICriteria criteria);
    public abstract virtual string GetEntityName(ICriteria criteria, string propertyPath);
    public abstract virtual string GetSQLAlias(ICriteria subcriteria);
    public abstract virtual string GetSQLAlias(ICriteria criteria, string propertyPath);
    public abstract virtual string GetPropertyName(string propertyName);
    public abstract virtual String[] GetIdentifierColumns(ICriteria subcriteria);
    public abstract virtual IType GetIdentifierType(ICriteria subcriteria);
    public abstract virtual TypedValue GetTypedIdentifierValue(ICriteria subcriteria, object value);
    public abstract virtual string GenerateSQLAlias();
    public abstract virtual int GetIndexForAlias();
    public abstract virtual IEnumerable`1<Parameter> NewQueryParameter(TypedValue parameter);
    public abstract virtual ICollection`1<IParameterSpecification> get_CollectedParameterSpecifications();
    public abstract virtual ICollection`1<NamedParameter> get_CollectedParameters();
    public abstract virtual Parameter CreateSkipParameter(int value);
    public abstract virtual Parameter CreateTakeParameter(int value);
}
public interface NHibernate.Criterion.ICriterion {
    public abstract virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual IProjection[] GetProjections();
}
public class NHibernate.Criterion.IdentifierEqExpression : AbstractCriterion {
    private object value;
    private IProjection _projection;
    public IdentifierEqExpression(IProjection projection);
    public IdentifierEqExpression(object value);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private void AddValueOrProjection(Parameter[] parameters, int paramIndex, ICriteria criteria, ICriteriaQuery criteriaQuery, SqlStringBuilder result);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual string ToString();
}
public class NHibernate.Criterion.IdentifierProjection : SimpleProjection {
    private bool grouped;
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    public string PropertyName { get; }
    protected internal IdentifierProjection(bool grouped);
    public virtual string ToString();
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public virtual bool get_IsGrouped();
    public virtual bool get_IsAggregate();
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual string get_PropertyName();
}
public class NHibernate.Criterion.InExpression : AbstractCriterion {
    private IProjection _projection;
    private string _propertyName;
    private Object[] _values;
    public Object[] Values { get; protected set; }
    public InExpression(IProjection projection, Object[] values);
    public InExpression(string propertyName, Object[] values);
    public virtual IProjection[] GetProjections();
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    internal static SqlString GetSqlString(Object[] columns, int paramsCount, IReadOnlyList`1<Parameter> parameters, Dialect dialect);
    private static SqlString GetSqlString(Object[] columns, int paramsCount, Parameter bogusParam, Dialect dialect);
    private void AssertPropertyIsNotCollection(ICriteriaQuery criteriaQuery, ICriteria criteria);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private List`1<TypedValue> GetParameterTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private IType GetElementType(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public Object[] get_Values();
    protected void set_Values(Object[] value);
    public virtual string ToString();
}
public class NHibernate.Criterion.InsensitiveLikeExpression : AbstractCriterion {
    private string propertyName;
    private object value;
    private IProjection projection;
    public InsensitiveLikeExpression(IProjection projection, string value, MatchMode matchMode);
    public InsensitiveLikeExpression(IProjection projection, object value);
    public InsensitiveLikeExpression(string propertyName, object value);
    public InsensitiveLikeExpression(string propertyName, string value, MatchMode matchMode);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public TypedValue GetParameterTypedValue(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual string ToString();
}
public interface NHibernate.Criterion.IProjection {
    public String[] Aliases { get; }
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    public abstract virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public abstract virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual IType[] GetTypes(string alias, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual String[] get_Aliases();
    public abstract virtual bool get_IsGrouped();
    public abstract virtual bool get_IsAggregate();
    public abstract virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual String[] GetColumnAliases(int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual String[] GetColumnAliases(string alias, int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public interface NHibernate.Criterion.IPropertyProjection {
    public string PropertyName { get; }
    public abstract virtual string get_PropertyName();
}
public class NHibernate.Criterion.IsEmptyExpression : AbstractEmptinessExpression {
    protected bool ExcludeEmpty { get; }
    public IsEmptyExpression(string propertyName);
    protected virtual bool get_ExcludeEmpty();
    public virtual IProjection[] GetProjections();
}
public class NHibernate.Criterion.IsNotEmptyExpression : AbstractEmptinessExpression {
    protected bool ExcludeEmpty { get; }
    public IsNotEmptyExpression(string propertyName);
    protected virtual bool get_ExcludeEmpty();
    public virtual IProjection[] GetProjections();
}
public interface NHibernate.Criterion.ISupportEntityJoinQueryOver`1 {
    public abstract virtual IQueryOver`2<TRoot, U> JoinEntityQueryOver(Expression`1<Func`1<U>> alias, ICriterion withClause, JoinType joinType, string entityName);
}
public interface NHibernate.Criterion.ISupportSelectModeQueryOver`2 {
    public abstract virtual IQueryOver`2<TRoot, TSubType> Fetch(SelectMode mode, Expression`1<Func`2<TSubType, object>> path);
}
public abstract class NHibernate.Criterion.Junction : AbstractCriterion {
    private List`1<ICriterion> criteria;
    protected string Op { get; }
    protected SqlString EmptyExpression { get; }
    public Junction Add(ICriterion criterion);
    public Junction Add(Expression`1<Func`2<T, bool>> expression);
    public Junction Add(Expression`1<Func`1<bool>> expression);
    protected abstract virtual string get_Op();
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    protected abstract virtual SqlString get_EmptyExpression();
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
    public virtual IProjection[] GetProjections();
}
[ObsoleteAttribute]
public class NHibernate.Criterion.Lambda.IQueryOverFetchBuilder`2 : QueryOverFetchBuilderBase`3<IQueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public IQueryOverFetchBuilder`2(IQueryOver`2<TRoot, TSubType> root, Expression`1<Func`2<TRoot, object>> path);
}
public class NHibernate.Criterion.Lambda.IQueryOverJoinBuilder`2 : QueryOverJoinBuilderBase`3<IQueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public IQueryOverJoinBuilder`2(IQueryOver`2<TRoot, TSubType> root, JoinType joinType);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
}
public class NHibernate.Criterion.Lambda.IQueryOverLockBuilder`2 : QueryOverLockBuilderBase`3<IQueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public IQueryOverLockBuilder`2(IQueryOver`2<TRoot, TSubType> root, Expression`1<Func`1<object>> alias);
}
public class NHibernate.Criterion.Lambda.IQueryOverOrderBuilder`2 : QueryOverOrderBuilderBase`3<IQueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public IQueryOverOrderBuilder`2(IQueryOver`2<TRoot, TSubType> root, Expression`1<Func`2<TSubType, object>> path);
    public IQueryOverOrderBuilder`2(IQueryOver`2<TRoot, TSubType> root, Expression`1<Func`1<object>> path, bool isAlias);
    public IQueryOverOrderBuilder`2(IQueryOver`2<TRoot, TSubType> root, ProjectionInfo projection);
}
public class NHibernate.Criterion.Lambda.IQueryOverRestrictionBuilder`2 : QueryOverRestrictionBuilderBase`3<IQueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public IQueryOverRestrictionBuilder`2<TRoot, TSubType> Not { get; }
    public IQueryOverRestrictionBuilder`2(IQueryOver`2<TRoot, TSubType> root, ProjectionInfo projection);
    public IQueryOverRestrictionBuilder`2<TRoot, TSubType> get_Not();
}
public class NHibernate.Criterion.Lambda.IQueryOverSubqueryBuilder`2 : QueryOverSubqueryBuilderBase`4<IQueryOver`2<TRoot, TSubType>, TRoot, TSubType, IQueryOverSubqueryPropertyBuilder`2<TRoot, TSubType>> {
    public IQueryOverSubqueryBuilder`2(IQueryOver`2<TRoot, TSubType> root);
}
public class NHibernate.Criterion.Lambda.IQueryOverSubqueryPropertyBuilder`2 : QueryOverSubqueryPropertyBuilderBase`3<IQueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
}
public class NHibernate.Criterion.Lambda.LambdaNaturalIdentifierBuilder : object {
    private NaturalIdentifier naturalIdentifier;
    private string propertyName;
    public LambdaNaturalIdentifierBuilder(NaturalIdentifier naturalIdentifier, string propertyName);
    public NaturalIdentifier Is(object value);
}
public class NHibernate.Criterion.Lambda.LambdaRestrictionBuilder : object {
    private ProjectionInfo projection;
    private bool isNot;
    public LambdaRestrictionBuilder Not { get; }
    public AbstractCriterion IsEmpty { get; }
    public AbstractCriterion IsNotEmpty { get; }
    public AbstractCriterion IsNull { get; }
    public AbstractCriterion IsNotNull { get; }
    public LambdaRestrictionBuilder(ProjectionInfo projection);
    private AbstractCriterion Process(AbstractCriterion criterion);
    public LambdaBetweenBuilder IsBetween(object lo);
    public LambdaRestrictionBuilder get_Not();
    public AbstractCriterion IsIn(ICollection values);
    public AbstractCriterion IsIn(Object[] values);
    public AbstractCriterion IsInG(IEnumerable`1<T> values);
    public AbstractCriterion IsInsensitiveLike(object value);
    public AbstractCriterion IsInsensitiveLike(string value, MatchMode matchMode);
    public AbstractCriterion get_IsEmpty();
    public AbstractCriterion get_IsNotEmpty();
    public AbstractCriterion get_IsNull();
    public AbstractCriterion get_IsNotNull();
    public AbstractCriterion IsLike(object value);
    public AbstractCriterion IsLike(string value, MatchMode matchMode);
    public AbstractCriterion IsLike(string value, MatchMode matchMode, Nullable`1<char> escapeChar);
}
public class NHibernate.Criterion.Lambda.LambdaSubqueryBuilder : object {
    private string propertyName;
    private object value;
    public LambdaSubqueryBuilder(string propertyName, object value);
    private AbstractCriterion CreatePropertyCriterion(Func`3<string, DetachedCriteria, AbstractCriterion> propertyFactoryMethod, Func`3<object, DetachedCriteria, AbstractCriterion> valueFactoryMethod, QueryOver`1<U> detachedCriteria);
    public AbstractCriterion Eq(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion EqAll(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion Ge(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion GeAll(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion GeSome(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion Gt(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion GtAll(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion GtSome(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion In(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion Le(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion LeAll(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion LeSome(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion Lt(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion LtAll(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion LtSome(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion Ne(QueryOver`1<U> detachedCriteria);
    public AbstractCriterion NotIn(QueryOver`1<U> detachedCriteria);
}
[ObsoleteAttribute]
public class NHibernate.Criterion.Lambda.QueryOverFetchBuilder`2 : QueryOverFetchBuilderBase`3<QueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public QueryOverFetchBuilder`2(QueryOver`2<TRoot, TSubType> root, Expression`1<Func`2<TRoot, object>> path);
}
[ObsoleteAttribute]
public class NHibernate.Criterion.Lambda.QueryOverFetchBuilderBase`3 : object {
    protected TReturn root;
    protected string path;
    public TReturn Eager { get; }
    public TReturn Lazy { get; }
    public TReturn Default { get; }
    protected QueryOverFetchBuilderBase`3(TReturn root, Expression`1<Func`2<TRoot, object>> path);
    public TReturn get_Eager();
    public TReturn get_Lazy();
    public TReturn get_Default();
}
public class NHibernate.Criterion.Lambda.QueryOverJoinBuilder`2 : QueryOverJoinBuilderBase`3<QueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public QueryOverJoinBuilder`2(QueryOver`2<TRoot, TSubType> root, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
}
public class NHibernate.Criterion.Lambda.QueryOverJoinBuilderBase`3 : object {
    protected TReturn root;
    protected JoinType joinType;
    public QueryOverJoinBuilderBase`3(TReturn root, JoinType joinType);
    public TReturn JoinAlias(Expression`1<Func`2<TSubType, object>> path, Expression`1<Func`1<object>> alias);
    public TReturn JoinAlias(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public TReturn JoinAlias(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public TReturn JoinAlias(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public TReturn JoinAlias(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public TReturn JoinAlias(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public TReturn JoinAlias(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public TReturn JoinAlias(Expression`1<Func`1<object>> path, Expression`1<Func`1<object>> alias);
    public TReturn JoinAlias(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public TReturn JoinAlias(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public TReturn JoinAlias(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
    public TReturn JoinAlias(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`2<U, bool>> withClause);
    public TReturn JoinAlias(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause);
    public TReturn JoinAlias(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, ICriterion withClause);
}
public class NHibernate.Criterion.Lambda.QueryOverLockBuilder`2 : QueryOverLockBuilderBase`3<QueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public QueryOverLockBuilder`2(QueryOver`2<TRoot, TSubType> root, Expression`1<Func`1<object>> alias);
}
public class NHibernate.Criterion.Lambda.QueryOverLockBuilderBase`3 : object {
    protected TReturn root;
    protected string alias;
    public TReturn Force { get; }
    public TReturn None { get; }
    public TReturn Read { get; }
    public TReturn Upgrade { get; }
    public TReturn UpgradeNoWait { get; }
    public TReturn Write { get; }
    protected QueryOverLockBuilderBase`3(TReturn root, Expression`1<Func`1<object>> alias);
    private void SetLockMode(LockMode lockMode);
    public TReturn get_Force();
    public TReturn get_None();
    public TReturn get_Read();
    public TReturn get_Upgrade();
    public TReturn get_UpgradeNoWait();
    public TReturn get_Write();
}
public class NHibernate.Criterion.Lambda.QueryOverOrderBuilder`2 : QueryOverOrderBuilderBase`3<QueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public QueryOverOrderBuilder`2(QueryOver`2<TRoot, TSubType> root, Expression`1<Func`2<TSubType, object>> path);
    public QueryOverOrderBuilder`2(QueryOver`2<TRoot, TSubType> root, Expression`1<Func`1<object>> path, bool isAlias);
    public QueryOverOrderBuilder`2(QueryOver`2<TRoot, TSubType> root, ProjectionInfo projection);
}
public class NHibernate.Criterion.Lambda.QueryOverOrderBuilderBase`3 : object {
    protected TReturn root;
    protected LambdaExpression path;
    protected bool isAlias;
    protected ProjectionInfo projection;
    public TReturn Asc { get; }
    public TReturn Desc { get; }
    protected QueryOverOrderBuilderBase`3(TReturn root, Expression`1<Func`2<TSubType, object>> path);
    protected QueryOverOrderBuilderBase`3(TReturn root, Expression`1<Func`1<object>> path, bool isAlias);
    protected QueryOverOrderBuilderBase`3(TReturn root, ProjectionInfo projection);
    private void AddOrder(Func`2<string, Order> orderStringDelegate, Func`2<IProjection, Order> orderProjectionDelegate);
    public TReturn get_Asc();
    public TReturn get_Desc();
}
public class NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1 : object {
    private ProjectionList projectionList;
    private IProjection lastProjection;
    internal ProjectionList ProjectionList { get; }
    private void AddLastProjection();
    private void PushProjection(IProjection projection);
    internal ProjectionList get_ProjectionList();
    public QueryOverProjectionBuilder`1<T> WithAlias(Expression`1<Func`1<object>> alias);
    public QueryOverProjectionBuilder`1<T> WithAlias(string alias);
    public QueryOverProjectionBuilder`1<T> Select(IProjection projection);
    public QueryOverProjectionBuilder`1<T> SelectAvg(Expression`1<Func`2<T, object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectAvg(Expression`1<Func`1<object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectCount(Expression`1<Func`2<T, object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectCount(Expression`1<Func`1<object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectCountDistinct(Expression`1<Func`2<T, object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectCountDistinct(Expression`1<Func`1<object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectGroup(Expression`1<Func`2<T, object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectGroup(Expression`1<Func`1<object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectMax(Expression`1<Func`2<T, object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectMax(Expression`1<Func`1<object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectMin(Expression`1<Func`2<T, object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectMin(Expression`1<Func`1<object>> expression);
    public QueryOverProjectionBuilder`1<T> Select(Expression`1<Func`2<T, object>> expression);
    public QueryOverProjectionBuilder`1<T> Select(Expression`1<Func`1<object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectSubQuery(QueryOver`1<U> detachedQueryOver);
    public QueryOverProjectionBuilder`1<T> SelectSum(Expression`1<Func`2<T, object>> expression);
    public QueryOverProjectionBuilder`1<T> SelectSum(Expression`1<Func`1<object>> expression);
}
public class NHibernate.Criterion.Lambda.QueryOverRestrictionBuilder`2 : QueryOverRestrictionBuilderBase`3<QueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
    public QueryOverRestrictionBuilder`2<TRoot, TSubType> Not { get; }
    public QueryOverRestrictionBuilder`2(QueryOver`2<TRoot, TSubType> root, ProjectionInfo projection);
    public QueryOverRestrictionBuilder`2<TRoot, TSubType> get_Not();
}
public class NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3 : object {
    private TReturn root;
    private ProjectionInfo projection;
    protected bool isNot;
    public TReturn IsEmpty { get; }
    public TReturn IsNotEmpty { get; }
    public TReturn IsNull { get; }
    public TReturn IsNotNull { get; }
    public QueryOverRestrictionBuilderBase`3(TReturn root, ProjectionInfo projection);
    private TReturn Add(ICriterion criterion);
    public LambdaBetweenBuilder<TReturn, TRoot, TSubType> IsBetween(object lo);
    public TReturn IsIn(ICollection values);
    public TReturn IsIn(Object[] values);
    public TReturn IsInG(IEnumerable`1<T> values);
    public TReturn IsInsensitiveLike(object value);
    public TReturn IsInsensitiveLike(string value, MatchMode matchMode);
    public TReturn get_IsEmpty();
    public TReturn get_IsNotEmpty();
    public TReturn get_IsNull();
    public TReturn get_IsNotNull();
    public TReturn IsLike(object value);
    public TReturn IsLike(string value, MatchMode matchMode);
    public TReturn IsLike(string value, MatchMode matchMode, Nullable`1<char> escapeChar);
}
public class NHibernate.Criterion.Lambda.QueryOverSubqueryBuilder`2 : QueryOverSubqueryBuilderBase`4<QueryOver`2<TRoot, TSubType>, TRoot, TSubType, QueryOverSubqueryPropertyBuilder`2<TRoot, TSubType>> {
    public QueryOverSubqueryBuilder`2(QueryOver`2<TRoot, TSubType> root);
}
public class NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4 : object {
    protected TReturn root;
    protected QueryOverSubqueryBuilderBase`4(TReturn root);
    public TReturn WhereExists(QueryOver`1<U> detachedQuery);
    public TReturn WhereNotExists(QueryOver`1<U> detachedQuery);
    public TReturn Where(Expression`1<Func`2<TSubType, bool>> expression);
    public TReturn Where(Expression`1<Func`1<bool>> expression);
    public TReturn WhereAll(Expression`1<Func`2<TSubType, bool>> expression);
    public TReturn WhereAll(Expression`1<Func`1<bool>> expression);
    public TReturn WhereSome(Expression`1<Func`2<TSubType, bool>> expression);
    public TReturn WhereSome(Expression`1<Func`1<bool>> expression);
    public TBuilderType WhereProperty(Expression`1<Func`2<TSubType, object>> expression);
    public TBuilderType WhereProperty(Expression`1<Func`1<object>> expression);
    public TBuilderType WhereValue(object value);
}
public class NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilder`2 : QueryOverSubqueryPropertyBuilderBase`3<QueryOver`2<TRoot, TSubType>, TRoot, TSubType> {
}
public abstract class NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase : object {
    internal abstract virtual QueryOverSubqueryPropertyBuilderBase Set(object root, string path, object value);
}
public class NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3 : QueryOverSubqueryPropertyBuilderBase {
    protected TReturn root;
    protected string path;
    protected object value;
    internal virtual QueryOverSubqueryPropertyBuilderBase Set(object root, string path, object value);
    private void AddSubquery(Func`3<string, DetachedCriteria, AbstractCriterion> propertyMethod, Func`3<object, DetachedCriteria, AbstractCriterion> valueMethod, QueryOver`1<U> detachedCriteria);
    public TReturn Eq(QueryOver`1<U> detachedCriteria);
    public TReturn EqAll(QueryOver`1<U> detachedCriteria);
    public TReturn Ge(QueryOver`1<U> detachedCriteria);
    public TReturn GeAll(QueryOver`1<U> detachedCriteria);
    public TReturn GeSome(QueryOver`1<U> detachedCriteria);
    public TReturn Gt(QueryOver`1<U> detachedCriteria);
    public TReturn GtAll(QueryOver`1<U> detachedCriteria);
    public TReturn GtSome(QueryOver`1<U> detachedCriteria);
    public TReturn In(QueryOver`1<U> detachedCriteria);
    public TReturn Le(QueryOver`1<U> detachedCriteria);
    public TReturn LeAll(QueryOver`1<U> detachedCriteria);
    public TReturn LeSome(QueryOver`1<U> detachedCriteria);
    public TReturn Lt(QueryOver`1<U> detachedCriteria);
    public TReturn LtAll(QueryOver`1<U> detachedCriteria);
    public TReturn LtSome(QueryOver`1<U> detachedCriteria);
    public TReturn Ne(QueryOver`1<U> detachedCriteria);
    public TReturn NotIn(QueryOver`1<U> detachedCriteria);
}
public class NHibernate.Criterion.LePropertyExpression : PropertyExpression {
    protected string Op { get; }
    public LePropertyExpression(string lhsPropertyName, IProjection rhsProjection);
    public LePropertyExpression(IProjection lhsProjection, IProjection rhsProjection);
    public LePropertyExpression(IProjection lhsProjection, string rhsPropertyName);
    public LePropertyExpression(string lhsPropertyName, string rhsPropertyName);
    protected virtual string get_Op();
}
public class NHibernate.Criterion.LikeExpression : AbstractCriterion {
    private string value;
    private Nullable`1<char> escapeChar;
    private bool ignoreCase;
    private IProjection projection;
    private TypedValue typedValue;
    public LikeExpression(string propertyName, string value, Nullable`1<char> escapeChar, bool ignoreCase);
    public LikeExpression(IProjection projection, string value, MatchMode matchMode);
    public LikeExpression(string propertyName, string value);
    public LikeExpression(string propertyName, string value, MatchMode matchMode);
    public LikeExpression(string propertyName, string value, MatchMode matchMode, Nullable`1<char> escapeChar, bool ignoreCase);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual string ToString();
}
public abstract class NHibernate.Criterion.LogicalExpression : AbstractCriterion {
    private ICriterion _lhs;
    private ICriterion _rhs;
    protected ICriterion LeftHandSide { get; }
    protected ICriterion RightHandSide { get; }
    protected string Op { get; }
    protected LogicalExpression(ICriterion lhs, ICriterion rhs);
    protected ICriterion get_LeftHandSide();
    protected ICriterion get_RightHandSide();
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    protected abstract virtual string get_Op();
    public virtual string ToString();
}
public class NHibernate.Criterion.LtPropertyExpression : PropertyExpression {
    protected string Op { get; }
    public LtPropertyExpression(string lhsPropertyName, IProjection rhsProjection);
    public LtPropertyExpression(IProjection lhsProjection, IProjection rhsProjection);
    public LtPropertyExpression(IProjection lhsProjection, string rhsPropertyName);
    public LtPropertyExpression(string lhsPropertyName, string rhsPropertyName);
    protected virtual string get_Op();
}
public abstract class NHibernate.Criterion.MatchMode : object {
    private int _intCode;
    private string _name;
    private static Hashtable Instances;
    public static MatchMode Exact;
    public static MatchMode Start;
    public static MatchMode End;
    public static MatchMode Anywhere;
    private static MatchMode();
    protected MatchMode(int intCode, string name);
    public virtual string ToString();
    public abstract virtual string ToMatchString(string pattern);
}
public class NHibernate.Criterion.NaturalIdentifier : object {
    private Junction conjunction;
    public sealed virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual IProjection[] GetProjections();
    public NaturalIdentifier Set(string property, object value);
    public LambdaNaturalIdentifierBuilder Set(Expression`1<Func`2<T, object>> expression);
    public LambdaNaturalIdentifierBuilder Set(Expression`1<Func`1<object>> expression);
}
public class NHibernate.Criterion.NotExpression : AbstractCriterion {
    private ICriterion _criterion;
    public NotExpression(ICriterion criterion);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
    public virtual IProjection[] GetProjections();
}
public class NHibernate.Criterion.NotNullExpression : AbstractCriterion {
    private string _propertyName;
    private IProjection _projection;
    private static TypedValue[] NoValues;
    public NotNullExpression(IProjection projection);
    public NotNullExpression(string propertyName);
    private static NotNullExpression();
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual string ToString();
}
public class NHibernate.Criterion.NullExpression : AbstractCriterion {
    private string _propertyName;
    private IProjection _projection;
    private static TypedValue[] NoValues;
    public NullExpression(IProjection projection);
    public NullExpression(string propertyName);
    private static NullExpression();
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual string ToString();
}
public class NHibernate.Criterion.NullSubqueryExpression : SubqueryExpression {
    internal NullSubqueryExpression(string quantifier, DetachedCriteria dc);
    protected virtual SqlString ToLeftSqlString(ICriteria criteria, ICriteriaQuery outerQuery);
}
public class NHibernate.Criterion.Order : object {
    protected bool ascending;
    protected string propertyName;
    protected IProjection projection;
    private bool ignoreCase;
    public Order(IProjection projection, bool ascending);
    public Order(string propertyName, bool ascending);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private Object[] GetColumnsOrAliases(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private SqlType[] SqlTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
    public static Order Asc(string propertyName);
    public static Order Asc(IProjection projection);
    public static Order Desc(IProjection projection);
    public static Order Desc(string propertyName);
    public TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public Order IgnoreCase();
    private bool IsStringType(SqlType propertyType);
}
public class NHibernate.Criterion.OrExpression : LogicalExpression {
    protected string Op { get; }
    public OrExpression(ICriterion lhs, ICriterion rhs);
    protected virtual string get_Op();
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Criterion.ProjectionList : object {
    private List`1<IProjection> elements;
    public String[] Aliases { get; }
    public IProjection Item { get; }
    public int Length { get; }
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    public ProjectionList Create();
    public ProjectionList Add(IProjection proj);
    public ProjectionList Add(IProjection projection, string alias);
    public ProjectionList Add(IProjection projection, Expression`1<Func`1<T>> alias);
    public sealed virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual SqlString ToSqlString(ICriteria criteria, int loc, ICriteriaQuery criteriaQuery);
    public sealed virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] GetColumnAliases(int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] GetColumnAliases(string alias, int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual IType[] GetTypes(string alias, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] get_Aliases();
    public IProjection get_Item(int index);
    public int get_Length();
    public virtual string ToString();
    public sealed virtual bool get_IsGrouped();
    public sealed virtual bool get_IsAggregate();
    public sealed virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public static class NHibernate.Criterion.Projections : object {
    public static EntityProjection RootEntity();
    public static EntityProjection Entity(Type type, string alias);
    public static EntityProjection Entity(string alias);
    public static EntityProjection Entity(Expression`1<Func`1<T>> alias);
    public static IProjection Distinct(IProjection proj);
    public static ProjectionList ProjectionList();
    public static IProjection RowCount();
    public static IProjection RowCountInt64();
    public static CountProjection Count(IProjection projection);
    public static CountProjection Count(string propertyName);
    public static CountProjection CountDistinct(IProjection projection);
    public static CountProjection CountDistinct(string propertyName);
    public static AggregateProjection Max(string propertyName);
    public static AggregateProjection Max(IProjection projection);
    public static AggregateProjection Min(string propertyName);
    public static AggregateProjection Min(IProjection projection);
    public static AggregateProjection Avg(string propertyName);
    public static AggregateProjection Avg(IProjection projection);
    public static AggregateProjection Sum(string propertyName);
    public static AggregateProjection Sum(IProjection projection);
    public static IProjection SqlProjection(string sql, String[] columnAliases, IType[] types);
    public static IProjection SqlGroupProjection(string sql, string groupBy, String[] columnAliases, IType[] types);
    public static PropertyProjection GroupProperty(string propertyName);
    public static GroupedProjection GroupProperty(IProjection projection);
    public static PropertyProjection Property(string propertyName);
    public static IdentifierProjection Id();
    public static IProjection Alias(IProjection projection, string alias);
    public static IProjection Cast(IType type, IProjection projection);
    public static IProjection Constant(object obj);
    public static IProjection Constant(object obj, IType type);
    public static IProjection SqlFunction(string functionName, IType type, IProjection[] projections);
    public static IProjection SqlFunction(ISQLFunction function, IType type, IProjection[] projections);
    public static IProjection Conditional(ICriterion criterion, IProjection whenTrue, IProjection whenFalse);
    public static IProjection Conditional(ConditionalProjectionCase[] cases, IProjection elseProjection);
    public static IProjection SubQuery(DetachedCriteria detachedCriteria);
    public static AggregateProjection Avg(Expression`1<Func`2<T, object>> expression);
    public static AggregateProjection Avg(Expression`1<Func`1<object>> expression);
    public static CountProjection Count(Expression`1<Func`2<T, object>> expression);
    public static CountProjection Count(Expression`1<Func`1<object>> expression);
    public static CountProjection CountDistinct(Expression`1<Func`2<T, object>> expression);
    public static CountProjection CountDistinct(Expression`1<Func`1<object>> expression);
    public static PropertyProjection Group(Expression`1<Func`2<T, object>> expression);
    public static IProjection GroupProjection(Expression`1<Func`2<T, object>> expression);
    public static PropertyProjection Group(Expression`1<Func`1<object>> expression);
    public static IProjection GroupProjection(Expression`1<Func`1<object>> expression);
    public static AggregateProjection Max(Expression`1<Func`2<T, object>> expression);
    public static AggregateProjection Max(Expression`1<Func`1<object>> expression);
    public static AggregateProjection Min(Expression`1<Func`2<T, object>> expression);
    public static AggregateProjection Min(Expression`1<Func`1<object>> expression);
    public static PropertyProjection Property(Expression`1<Func`2<T, object>> expression);
    public static PropertyProjection Property(Expression`1<Func`1<object>> expression);
    public static IProjection SubQuery(QueryOver`1<T> detachedQueryOver);
    public static AggregateProjection Sum(Expression`1<Func`2<T, object>> expression);
    public static AggregateProjection Sum(Expression`1<Func`1<object>> expression);
    public static string Concat(String[] strings);
    public static IProjection Select(Expression`1<Func`1<object>> expression);
    public static IProjection Select(Expression`1<Func`2<TEntity, object>> expression);
    internal static IProjection ProcessConcat(MethodCallExpression methodCallExpression);
    private static TProjection Create(Expression`1<Func`2<T, object>> expression, Func`2<string, TProjection> stringFunc, Func`2<IProjection, TProjection> projectionFunc);
    private static TProjection Create(Expression`1<Func`1<object>> expression, Func`2<string, TProjection> stringFunc, Func`2<IProjection, TProjection> projectionFunc);
}
[ExtensionAttribute]
public static class NHibernate.Criterion.ProjectionsExtensions : object {
    [ExtensionAttribute]
public static IProjection WithAlias(IProjection projection, Expression`1<Func`1<object>> alias);
    [ExtensionAttribute]
public static IProjection WithAlias(IProjection projection, string alias);
    internal static IProjection ProcessYear(Expression expression);
    internal static IProjection ProcessDay(Expression expression);
    internal static IProjection ProcessMonth(Expression expression);
    private static IProjection SqlFunction(string name, IType type, Expression projection);
    internal static IProjection ProcessHour(Expression expression);
    internal static IProjection ProcessMinute(Expression expression);
    internal static IProjection ProcessSecond(Expression expression);
    internal static IProjection ProcessDate(Expression expression);
    [ExtensionAttribute]
public static double Sqrt(double numericProperty);
    [ExtensionAttribute]
public static double Sqrt(int numericProperty);
    [ExtensionAttribute]
public static double Sqrt(long numericProperty);
    [ExtensionAttribute]
public static double Sqrt(decimal numericProperty);
    [ExtensionAttribute]
public static double Sqrt(byte numericProperty);
    internal static IProjection ProcessSqrt(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static string Lower(string stringProperty);
    internal static IProjection ProcessLower(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static string Upper(string stringProperty);
    internal static IProjection ProcessUpper(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static int Abs(int numericProperty);
    internal static IProjection ProcessIntAbs(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static long Abs(long numericProperty);
    internal static IProjection ProcessInt64Abs(MethodCallExpression methodCallExpression);
    internal static IProjection ProcessRound(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static double Abs(double numericProperty);
    internal static IProjection ProcessDoubleAbs(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static string TrimStr(string stringProperty);
    internal static IProjection ProcessTrimStr(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static int StrLength(string stringProperty);
    internal static IProjection ProcessStrLength(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static int BitLength(string stringProperty);
    internal static IProjection ProcessBitLength(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static string Substr(string stringProperty, int startIndex, int length);
    internal static IProjection ProcessSubstr(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static int CharIndex(string stringProperty, string theChar, int startLocation);
    internal static IProjection ProcessCharIndex(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static T Coalesce(T objectProperty, T replaceValueIfIsNull);
    [ExtensionAttribute]
public static Nullable`1<T> Coalesce(Nullable`1<T> objectProperty, T replaceValueIfIsNull);
    internal static IProjection ProcessCoalesce(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static int Mod(int numericProperty, int divisor);
    internal static IProjection ProcessMod(MethodCallExpression methodCallExpression);
    [ExtensionAttribute]
public static T AsEntity(T alias);
    internal static IProjection ProcessAsEntity(MethodCallExpression methodCallExpression);
}
public class NHibernate.Criterion.Property : PropertyProjection {
    internal Property(string propertyName);
    public AbstractCriterion Between(object min, object max);
    public AbstractCriterion In(ICollection values);
    public AbstractCriterion In(Object[] values);
    public AbstractCriterion Like(object value);
    public AbstractCriterion Like(string value, MatchMode matchMode);
    public AbstractCriterion Eq(object value);
    public AbstractCriterion Gt(object value);
    public AbstractCriterion Lt(object value);
    public AbstractCriterion Le(object value);
    public AbstractCriterion Ge(object value);
    public AbstractCriterion EqProperty(Property other);
    public AbstractCriterion NotEqProperty(Property other);
    public AbstractCriterion LeProperty(Property other);
    public AbstractCriterion GeProperty(Property other);
    public AbstractCriterion LtProperty(Property other);
    public AbstractCriterion GtProperty(Property other);
    public AbstractCriterion EqProperty(string other);
    public AbstractCriterion NotEqProperty(string other);
    public AbstractCriterion LeProperty(string other);
    public AbstractCriterion GeProperty(string other);
    public AbstractCriterion LtProperty(string other);
    public AbstractCriterion GtProperty(string other);
    public AbstractCriterion IsNull();
    public AbstractCriterion IsNotNull();
    public AbstractEmptinessExpression IsEmpty();
    public AbstractEmptinessExpression IsNotEmpty();
    public CountProjection Count();
    public AggregateProjection Max();
    public AggregateProjection Min();
    public AggregateProjection Avg();
    public PropertyProjection Group();
    public Order Asc();
    public Order Desc();
    public static Property ForName(string propertyName);
    public Property GetProperty(string propertyName);
    public AbstractCriterion Eq(DetachedCriteria subselect);
    public AbstractCriterion Ne(DetachedCriteria subselect);
    public AbstractCriterion Lt(DetachedCriteria subselect);
    public AbstractCriterion Le(DetachedCriteria subselect);
    public AbstractCriterion Bt(DetachedCriteria subselect);
    public AbstractCriterion Ge(DetachedCriteria subselect);
    public AbstractCriterion NotIn(DetachedCriteria subselect);
    public AbstractCriterion In(DetachedCriteria subselect);
    public AbstractCriterion EqAll(DetachedCriteria subselect);
    public AbstractCriterion GtAll(DetachedCriteria subselect);
    public AbstractCriterion LtAll(DetachedCriteria subselect);
    public AbstractCriterion LeAll(DetachedCriteria subselect);
    public AbstractCriterion GeAll(DetachedCriteria subselect);
    public AbstractCriterion GtSome(DetachedCriteria subselect);
    public AbstractCriterion LtSome(DetachedCriteria subselect);
    public AbstractCriterion LeSome(DetachedCriteria subselect);
    public AbstractCriterion GeSome(DetachedCriteria subselect);
}
public abstract class NHibernate.Criterion.PropertyExpression : AbstractCriterion {
    private static TypedValue[] NoTypedValues;
    private string _lhsPropertyName;
    private string _rhsPropertyName;
    private IProjection _lhsProjection;
    private IProjection _rhsProjection;
    protected string Op { get; }
    protected PropertyExpression(IProjection lhsProjection, string rhsPropertyName);
    protected PropertyExpression(IProjection lhsProjection, IProjection rhsProjection);
    protected PropertyExpression(string lhsPropertyName, string rhsPropertyName);
    protected PropertyExpression(string lhsPropertyName, IProjection rhsProjection);
    private static PropertyExpression();
    protected abstract virtual string get_Op();
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
    public virtual IProjection[] GetProjections();
}
public class NHibernate.Criterion.PropertyProjection : SimpleProjection {
    private string propertyName;
    private bool grouped;
    public string PropertyName { get; }
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    protected internal PropertyProjection(string propertyName, bool grouped);
    protected internal PropertyProjection(string propertyName);
    public sealed virtual string get_PropertyName();
    public virtual string ToString();
    public virtual bool get_IsGrouped();
    public virtual bool get_IsAggregate();
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToSqlString(ICriteria criteria, int loc, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.PropertySubqueryExpression : SubqueryExpression {
    private string propertyName;
    internal PropertySubqueryExpression(string propertyName, string op, string quantifier, DetachedCriteria dc);
    protected virtual SqlString ToLeftSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public abstract class NHibernate.Criterion.QueryOver : object {
    protected ICriteria criteria;
    protected CriteriaImpl impl;
    public ICriteria UnderlyingCriteria { get; }
    public ICriteria RootCriteria { get; }
    public DetachedCriteria DetachedCriteria { get; }
    public static QueryOver`2<T, T> Of();
    public static QueryOver`2<T, T> Of(Expression`1<Func`1<T>> alias);
    public static QueryOver`2<T, T> Of(string entityName);
    public static QueryOver`2<T, T> Of(string entityName, Expression`1<Func`1<T>> alias);
    public sealed virtual ICriteria get_UnderlyingCriteria();
    public sealed virtual ICriteria get_RootCriteria();
    public DetachedCriteria get_DetachedCriteria();
    internal static Exception GetDirectUsageException();
}
public abstract class NHibernate.Criterion.QueryOver`1 : QueryOver {
    private Task`1<IList`1<TRoot>> ListAsync(CancellationToken cancellationToken);
    private Task`1<IList`1<U>> ListAsync(CancellationToken cancellationToken);
    private Task`1<TRoot> SingleOrDefaultAsync(CancellationToken cancellationToken);
    private Task`1<U> SingleOrDefaultAsync(CancellationToken cancellationToken);
    private sealed virtual override Task`1<IList`1<TRoot>> NHibernate.IQueryOver<TRoot>.ListAsync(CancellationToken cancellationToken);
    private sealed virtual override Task`1<IList`1<U>> NHibernate.IQueryOver<TRoot>.ListAsync(CancellationToken cancellationToken);
    private sealed virtual override Task`1<int> NHibernate.IQueryOver<TRoot>.RowCountAsync(CancellationToken cancellationToken);
    private sealed virtual override Task`1<long> NHibernate.IQueryOver<TRoot>.RowCountInt64Async(CancellationToken cancellationToken);
    private sealed virtual override Task`1<TRoot> NHibernate.IQueryOver<TRoot>.SingleOrDefaultAsync(CancellationToken cancellationToken);
    private sealed virtual override Task`1<U> NHibernate.IQueryOver<TRoot>.SingleOrDefaultAsync(CancellationToken cancellationToken);
    protected internal QueryOver`2<TRoot, TSubType> Create(ICriteria criteria);
    private IList`1<TRoot> List();
    private IList`1<U> List();
    private TRoot SingleOrDefault();
    private U SingleOrDefault();
    private IFutureEnumerable`1<TRoot> Future();
    private IFutureEnumerable`1<U> Future();
    private IFutureValue`1<TRoot> FutureValue();
    private IFutureValue`1<U> FutureValue();
    public IQueryOver`2<TRoot, TRoot> GetExecutableQueryOver(ISession session);
    public IQueryOver`2<TRoot, TRoot> GetExecutableQueryOver(IStatelessSession session);
    public QueryOver`2<TRoot, TRoot> ToRowCountQuery();
    public QueryOver`2<TRoot, TRoot> ToRowCountInt64Query();
    public QueryOver`2<TRoot, TRoot> Clone();
    public QueryOver`1<TRoot> ClearOrders();
    public QueryOver`1<TRoot> Skip(int firstResult);
    public QueryOver`1<TRoot> Take(int maxResults);
    public QueryOver`1<TRoot> Cacheable();
    public QueryOver`1<TRoot> CacheMode(CacheMode cacheMode);
    public QueryOver`1<TRoot> CacheRegion(string cacheRegion);
    private QueryOver`1<TRoot> ReadOnly();
    public S As();
    private sealed virtual override IList`1<TRoot> NHibernate.IQueryOver<TRoot>.List();
    private sealed virtual override IList`1<U> NHibernate.IQueryOver<TRoot>.List();
    private sealed virtual override IQueryOver`2<TRoot, TRoot> NHibernate.IQueryOver<TRoot>.ToRowCountQuery();
    private sealed virtual override IQueryOver`2<TRoot, TRoot> NHibernate.IQueryOver<TRoot>.ToRowCountInt64Query();
    private sealed virtual override int NHibernate.IQueryOver<TRoot>.RowCount();
    private sealed virtual override long NHibernate.IQueryOver<TRoot>.RowCountInt64();
    private sealed virtual override TRoot NHibernate.IQueryOver<TRoot>.SingleOrDefault();
    private sealed virtual override U NHibernate.IQueryOver<TRoot>.SingleOrDefault();
    private sealed virtual override IFutureEnumerable`1<TRoot> NHibernate.IQueryOver<TRoot>.Future();
    private sealed virtual override IFutureEnumerable`1<U> NHibernate.IQueryOver<TRoot>.Future();
    private sealed virtual override IFutureValue`1<TRoot> NHibernate.IQueryOver<TRoot>.FutureValue();
    private sealed virtual override IFutureValue`1<U> NHibernate.IQueryOver<TRoot>.FutureValue();
    private sealed virtual override IQueryOver`2<TRoot, TRoot> NHibernate.IQueryOver<TRoot>.Clone();
    private sealed virtual override IQueryOver`1<TRoot> NHibernate.IQueryOver<TRoot>.ClearOrders();
    private sealed virtual override IQueryOver`1<TRoot> NHibernate.IQueryOver<TRoot>.Skip(int firstResult);
    private sealed virtual override IQueryOver`1<TRoot> NHibernate.IQueryOver<TRoot>.Take(int maxResults);
    private sealed virtual override IQueryOver`1<TRoot> NHibernate.IQueryOver<TRoot>.Cacheable();
    private sealed virtual override IQueryOver`1<TRoot> NHibernate.IQueryOver<TRoot>.CacheMode(CacheMode cacheMode);
    private sealed virtual override IQueryOver`1<TRoot> NHibernate.IQueryOver<TRoot>.CacheRegion(string cacheRegion);
    private sealed virtual override IQueryOver`1<TRoot> NHibernate.IQueryOver<TRoot>.ReadOnly();
}
public class NHibernate.Criterion.QueryOver`2 : QueryOver`1<TRoot> {
    public QueryOverSubqueryBuilder`2<TRoot, TSubType> WithSubquery { get; }
    public QueryOverJoinBuilder`2<TRoot, TSubType> Inner { get; }
    public QueryOverJoinBuilder`2<TRoot, TSubType> Left { get; }
    public QueryOverJoinBuilder`2<TRoot, TSubType> Right { get; }
    public QueryOverJoinBuilder`2<TRoot, TSubType> Full { get; }
    private IQueryOverSubqueryBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.WithSubquery { get; }
    private IQueryOverJoinBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Inner { get; }
    private IQueryOverJoinBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Left { get; }
    private IQueryOverJoinBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Right { get; }
    private IQueryOverJoinBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Full { get; }
    protected internal QueryOver`2(string entityName);
    protected internal QueryOver`2(Expression`1<Func`1<TSubType>> alias);
    protected internal QueryOver`2(string entityName, Expression`1<Func`1<TSubType>> alias);
    protected internal QueryOver`2(CriteriaImpl impl);
    protected internal QueryOver`2(CriteriaImpl rootImpl, ICriteria criteria);
    public QueryOver`2<TRoot, TSubType> And(Expression`1<Func`2<TSubType, bool>> expression);
    public QueryOver`2<TRoot, TSubType> And(Expression`1<Func`1<bool>> expression);
    public QueryOver`2<TRoot, TSubType> And(ICriterion expression);
    public QueryOver`2<TRoot, TSubType> AndNot(Expression`1<Func`2<TSubType, bool>> expression);
    public QueryOver`2<TRoot, TSubType> AndNot(Expression`1<Func`1<bool>> expression);
    public QueryOver`2<TRoot, TSubType> AndNot(ICriterion expression);
    public QueryOverRestrictionBuilder`2<TRoot, TSubType> AndRestrictionOn(Expression`1<Func`2<TSubType, object>> expression);
    public QueryOverRestrictionBuilder`2<TRoot, TSubType> AndRestrictionOn(Expression`1<Func`1<object>> expression);
    public QueryOver`2<TRoot, TSubType> Where(Expression`1<Func`2<TSubType, bool>> expression);
    public QueryOver`2<TRoot, TSubType> Where(Expression`1<Func`1<bool>> expression);
    public QueryOver`2<TRoot, TSubType> Where(ICriterion expression);
    public QueryOver`2<TRoot, TSubType> WhereNot(Expression`1<Func`2<TSubType, bool>> expression);
    public QueryOver`2<TRoot, TSubType> WhereNot(Expression`1<Func`1<bool>> expression);
    public QueryOver`2<TRoot, TSubType> WhereNot(ICriterion expression);
    public QueryOverRestrictionBuilder`2<TRoot, TSubType> WhereRestrictionOn(Expression`1<Func`2<TSubType, object>> expression);
    public QueryOverRestrictionBuilder`2<TRoot, TSubType> WhereRestrictionOn(Expression`1<Func`1<object>> expression);
    public QueryOver`2<TRoot, TSubType> Select(Expression`1[] projections);
    public QueryOver`2<TRoot, TSubType> Select(IProjection[] projections);
    public QueryOver`2<TRoot, TSubType> SelectList(Func`2<QueryOverProjectionBuilder`1<TRoot>, QueryOverProjectionBuilder`1<TRoot>> list);
    public QueryOverOrderBuilder`2<TRoot, TSubType> OrderBy(Expression`1<Func`2<TSubType, object>> path);
    public QueryOverOrderBuilder`2<TRoot, TSubType> OrderBy(Expression`1<Func`1<object>> path);
    public QueryOverOrderBuilder`2<TRoot, TSubType> OrderBy(IProjection projection);
    public QueryOverOrderBuilder`2<TRoot, TSubType> OrderByAlias(Expression`1<Func`1<object>> path);
    public QueryOverOrderBuilder`2<TRoot, TSubType> ThenBy(Expression`1<Func`2<TSubType, object>> path);
    public QueryOverOrderBuilder`2<TRoot, TSubType> ThenBy(Expression`1<Func`1<object>> path);
    public QueryOverOrderBuilder`2<TRoot, TSubType> ThenBy(IProjection projection);
    public QueryOverOrderBuilder`2<TRoot, TSubType> ThenByAlias(Expression`1<Func`1<object>> path);
    public QueryOver`2<TRoot, TSubType> TransformUsing(IResultTransformer resultTransformer);
    public QueryOverSubqueryBuilder`2<TRoot, TSubType> get_WithSubquery();
    [ObsoleteAttribute("Use Fetch(SelectMode mode, Expression<Func<TSubType, object>> path) instead")]
public QueryOverFetchBuilder`2<TRoot, TSubType> Fetch(Expression`1<Func`2<TRoot, object>> path);
    public QueryOverLockBuilder`2<TRoot, TSubType> Lock();
    public QueryOverLockBuilder`2<TRoot, TSubType> Lock(Expression`1<Func`1<object>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, JoinType joinType);
    public QueryOver`2<TRoot, U> JoinEntityQueryOver(Expression`1<Func`1<U>> alias, Expression`1<Func`1<bool>> withClause, JoinType joinType, string entityName);
    public QueryOver`2<TRoot, U> JoinEntityQueryOver(Expression`1<Func`1<U>> alias, ICriterion withClause, JoinType joinType, string entityName);
    public QueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`2<TSubType, object>> path, Expression`1<Func`1<object>> alias);
    public QueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`1<object>> path, Expression`1<Func`1<object>> alias);
    public QueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`2<TSubType, object>> path, Expression`1<Func`1<object>> alias, JoinType joinType);
    public QueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public QueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public QueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`1<object>> path, Expression`1<Func`1<object>> alias, JoinType joinType);
    public QueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public QueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public QueryOverJoinBuilder`2<TRoot, TSubType> get_Inner();
    public QueryOverJoinBuilder`2<TRoot, TSubType> get_Left();
    public QueryOverJoinBuilder`2<TRoot, TSubType> get_Right();
    public QueryOverJoinBuilder`2<TRoot, TSubType> get_Full();
    private QueryOver`2<TRoot, TSubType> AddAlias(string path, string alias, JoinType joinType);
    private QueryOver`2<TRoot, TSubType> AddAlias(string path, string alias, JoinType joinType, ICriterion withClause);
    private QueryOver`2<TRoot, TSubType> Add(Expression`1<Func`2<TSubType, bool>> expression);
    private QueryOver`2<TRoot, TSubType> Add(Expression`1<Func`1<bool>> expression);
    private QueryOver`2<TRoot, TSubType> Add(ICriterion expression);
    private QueryOver`2<TRoot, TSubType> AddNot(Expression`1<Func`2<TSubType, bool>> expression);
    private QueryOver`2<TRoot, TSubType> AddNot(Expression`1<Func`1<bool>> expression);
    private QueryOver`2<TRoot, TSubType> AddNot(ICriterion expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.And(Expression`1<Func`2<TSubType, bool>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.And(Expression`1<Func`1<bool>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.And(ICriterion expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.AndNot(Expression`1<Func`2<TSubType, bool>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.AndNot(Expression`1<Func`1<bool>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.AndNot(ICriterion expression);
    private sealed virtual override IQueryOverRestrictionBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.AndRestrictionOn(Expression`1<Func`2<TSubType, object>> expression);
    private sealed virtual override IQueryOverRestrictionBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.AndRestrictionOn(Expression`1<Func`1<object>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Where(Expression`1<Func`2<TSubType, bool>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Where(Expression`1<Func`1<bool>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Where(ICriterion expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.WhereNot(Expression`1<Func`2<TSubType, bool>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.WhereNot(Expression`1<Func`1<bool>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.WhereNot(ICriterion expression);
    private sealed virtual override IQueryOverRestrictionBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.WhereRestrictionOn(Expression`1<Func`2<TSubType, object>> expression);
    private sealed virtual override IQueryOverRestrictionBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.WhereRestrictionOn(Expression`1<Func`1<object>> expression);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Select(Expression`1[] projections);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Select(IProjection[] projections);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.SelectList(Func`2<QueryOverProjectionBuilder`1<TRoot>, QueryOverProjectionBuilder`1<TRoot>> list);
    private sealed virtual override IQueryOverOrderBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.OrderBy(Expression`1<Func`2<TSubType, object>> path);
    private sealed virtual override IQueryOverOrderBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.OrderBy(Expression`1<Func`1<object>> path);
    private sealed virtual override IQueryOverOrderBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.OrderBy(IProjection projection);
    private sealed virtual override IQueryOverOrderBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.OrderByAlias(Expression`1<Func`1<object>> path);
    private sealed virtual override IQueryOverOrderBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.ThenBy(Expression`1<Func`2<TSubType, object>> path);
    private sealed virtual override IQueryOverOrderBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.ThenBy(Expression`1<Func`1<object>> path);
    private sealed virtual override IQueryOverOrderBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.ThenBy(IProjection projection);
    private sealed virtual override IQueryOverOrderBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.ThenByAlias(Expression`1<Func`1<object>> path);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.TransformUsing(IResultTransformer resultTransformer);
    private sealed virtual override IQueryOverSubqueryBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.get_WithSubquery();
    [ObsoleteAttribute("Use Fetch(SelectMode mode, Expression<Func<TSubType, object>> path) instead")]
private sealed virtual override IQueryOverFetchBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Fetch(Expression`1<Func`2<TRoot, object>> path);
    private sealed virtual override IQueryOverLockBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Lock();
    private sealed virtual override IQueryOverLockBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.Lock(Expression`1<Func`1<object>> alias);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, U>> path);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<U>> path);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<U>> path, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.IQueryOver<TRoot,TSubType>.JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.JoinAlias(Expression`1<Func`2<TSubType, object>> path, Expression`1<Func`1<object>> alias);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.JoinAlias(Expression`1<Func`1<object>> path, Expression`1<Func`1<object>> alias);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.JoinAlias(Expression`1<Func`2<TSubType, object>> path, Expression`1<Func`1<object>> alias, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.JoinAlias(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.JoinAlias(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.JoinAlias(Expression`1<Func`1<object>> path, Expression`1<Func`1<object>> alias, JoinType joinType);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.JoinAlias(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.JoinAlias(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    private sealed virtual override IQueryOver`2<TRoot, U> NHibernate.Criterion.ISupportEntityJoinQueryOver<TRoot>.JoinEntityQueryOver(Expression`1<Func`1<U>> alias, ICriterion withClause, JoinType joinType, string entityName);
    private sealed virtual override IQueryOverJoinBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.get_Inner();
    private sealed virtual override IQueryOverJoinBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.get_Left();
    private sealed virtual override IQueryOverJoinBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.get_Right();
    private sealed virtual override IQueryOverJoinBuilder`2<TRoot, TSubType> NHibernate.IQueryOver<TRoot,TSubType>.get_Full();
    private sealed virtual override IQueryOver`2<TRoot, TSubType> NHibernate.Criterion.ISupportSelectModeQueryOver<TRoot,TSubType>.Fetch(SelectMode mode, Expression`1<Func`2<TSubType, object>> path);
    public QueryOver`2<TRoot, TSubType> Fetch(SelectMode mode, Expression`1<Func`2<TSubType, object>> path);
}
[ExtensionAttribute]
public static class NHibernate.Criterion.QueryOverBuilderExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Fetch(SelectMode.Default, Expression<Func<TSubType, object>> path) instead")]
public static QueryOver`2<TRoot, TSubType> Default(QueryOverFetchBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Fetch(SelectMode.Fetch, Expression<Func<TSubType, object>> path) instead")]
public static QueryOver`2<TRoot, TSubType> Eager(QueryOverFetchBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Fetch(SelectMode.SkipJoin, Expression<Func<TSubType, object>> path) instead")]
public static QueryOver`2<TRoot, TSubType> Lazy(QueryOverFetchBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Fetch(SelectMode.Default, Expression<Func<TSubType, object>> path) instead")]
public static IQueryOver`2<TRoot, TSubType> Default(IQueryOverFetchBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Fetch(SelectMode.Fetch, Expression<Func<TSubType, object>> path) instead")]
public static IQueryOver`2<TRoot, TSubType> Eager(IQueryOverFetchBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Fetch(SelectMode.SkipJoin, Expression<Func<TSubType, object>> path) instead")]
public static IQueryOver`2<TRoot, TSubType> Lazy(IQueryOverFetchBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> Force(QueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> None(QueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> Read(QueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> Upgrade(QueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> UpgradeNoWait(QueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> Write(QueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> Force(IQueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> None(IQueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> Read(IQueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> Upgrade(IQueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> UpgradeNoWait(IQueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> Write(IQueryOverLockBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> Asc(QueryOverOrderBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> Desc(QueryOverOrderBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> Asc(IQueryOverOrderBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> Desc(IQueryOverOrderBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> IsEmpty(QueryOverRestrictionBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> IsNotEmpty(QueryOverRestrictionBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> IsNotNull(QueryOverRestrictionBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> IsNull(QueryOverRestrictionBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> IsEmpty(IQueryOverRestrictionBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> IsNotEmpty(IQueryOverRestrictionBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> IsNotNull(IQueryOverRestrictionBuilder`2<TRoot, TSubType> builder);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> IsNull(IQueryOverRestrictionBuilder`2<TRoot, TSubType> builder);
}
[ExtensionAttribute]
public static class NHibernate.Criterion.RestrictionExtensions : object {
    [ExtensionAttribute]
public static bool IsLike(string projection, string comparison);
    [ExtensionAttribute]
public static bool IsLike(string projection, string comparison, MatchMode matchMode);
    [ExtensionAttribute]
public static bool IsLike(string projection, string comparison, MatchMode matchMode, Nullable`1<char> escapeChar);
    [ExtensionAttribute]
public static bool IsInsensitiveLike(string projection, string comparison);
    [ExtensionAttribute]
public static bool IsInsensitiveLike(string projection, string comparison, MatchMode matchMode);
    [ExtensionAttribute]
public static bool IsIn(object projection, Object[] values);
    [ExtensionAttribute]
public static bool IsIn(object projection, ICollection values);
    [ExtensionAttribute]
public static RestrictionBetweenBuilder IsBetween(object projection, object lo);
    public static ICriterion ProcessIsLike(MethodCallExpression methodCallExpression);
    public static ICriterion ProcessIsLikeMatchMode(MethodCallExpression methodCallExpression);
    public static ICriterion ProcessIsLikeMatchModeEscapeChar(MethodCallExpression methodCallExpression);
    public static ICriterion ProcessIsInsensitiveLike(MethodCallExpression methodCallExpression);
    public static ICriterion ProcessIsInsensitiveLikeMatchMode(MethodCallExpression methodCallExpression);
    public static ICriterion ProcessIsInArray(MethodCallExpression methodCallExpression);
    public static ICriterion ProcessIsInCollection(MethodCallExpression methodCallExpression);
    public static ICriterion ProcessIsBetween(MethodCallExpression methodCallExpression);
}
public class NHibernate.Criterion.Restrictions : object {
    public static AbstractCriterion IdEq(object value);
    public static AbstractCriterion IdEq(IProjection projection);
    public static SimpleExpression Eq(string propertyName, object value);
    public static SimpleExpression Eq(IProjection projection, object value);
    public static SimpleExpression Like(string propertyName, object value);
    public static AbstractCriterion Like(string propertyName, string value, MatchMode matchMode, Nullable`1<char> escapeChar);
    public static SimpleExpression Like(IProjection projection, object value);
    public static SimpleExpression Like(IProjection projection, string value, MatchMode matchMode);
    public static SimpleExpression Like(string propertyName, string value, MatchMode matchMode);
    public static AbstractCriterion InsensitiveLike(string propertyName, string value, MatchMode matchMode);
    public static AbstractCriterion InsensitiveLike(IProjection projection, string value, MatchMode matchMode);
    public static AbstractCriterion InsensitiveLike(string propertyName, object value);
    public static AbstractCriterion InsensitiveLike(IProjection projection, object value);
    public static SimpleExpression Gt(string propertyName, object value);
    public static SimpleExpression Gt(IProjection projection, object value);
    public static SimpleExpression Lt(string propertyName, object value);
    public static SimpleExpression Lt(IProjection projection, object value);
    public static SimpleExpression Le(string propertyName, object value);
    public static SimpleExpression Le(IProjection projection, object value);
    public static SimpleExpression Ge(string propertyName, object value);
    public static SimpleExpression Ge(IProjection projection, object value);
    public static AbstractCriterion Between(string propertyName, object lo, object hi);
    public static AbstractCriterion Between(IProjection projection, object lo, object hi);
    public static AbstractCriterion In(string propertyName, Object[] values);
    public static AbstractCriterion In(IProjection projection, Object[] values);
    public static AbstractCriterion In(IProjection projection, ICollection values);
    public static AbstractCriterion In(string propertyName, ICollection values);
    public static AbstractCriterion InG(string propertyName, IEnumerable`1<T> values);
    public static AbstractCriterion InG(IProjection projection, IEnumerable`1<T> values);
    public static AbstractCriterion IsNull(string propertyName);
    public static AbstractCriterion IsNull(IProjection projection);
    public static AbstractCriterion EqProperty(string propertyName, string otherPropertyName);
    public static AbstractCriterion EqProperty(IProjection projection, string otherPropertyName);
    public static AbstractCriterion EqProperty(IProjection lshProjection, IProjection rshProjection);
    public static AbstractCriterion EqProperty(string propertyName, IProjection rshProjection);
    public static AbstractCriterion NotEqProperty(string propertyName, string otherPropertyName);
    public static AbstractCriterion NotEqProperty(IProjection projection, string otherPropertyName);
    public static AbstractCriterion NotEqProperty(IProjection lhsProjection, IProjection rhsProjection);
    public static AbstractCriterion NotEqProperty(string propertyName, IProjection rhsProjection);
    public static AbstractCriterion GtProperty(string propertyName, string otherPropertyName);
    public static AbstractCriterion GtProperty(IProjection projection, string otherPropertyName);
    public static AbstractCriterion GtProperty(string propertyName, IProjection projection);
    public static AbstractCriterion GtProperty(IProjection lhsProjection, IProjection rhsProjection);
    public static AbstractCriterion GeProperty(string propertyName, string otherPropertyName);
    public static AbstractCriterion GeProperty(IProjection lhsProjection, IProjection rhsProjection);
    public static AbstractCriterion GeProperty(IProjection projection, string otherPropertyName);
    public static AbstractCriterion GeProperty(string propertyName, IProjection projection);
    public static AbstractCriterion LtProperty(string propertyName, string otherPropertyName);
    public static AbstractCriterion LtProperty(IProjection projection, string otherPropertyName);
    public static AbstractCriterion LtProperty(string propertyName, IProjection projection);
    public static AbstractCriterion LtProperty(IProjection lhsProjection, IProjection rhsProjection);
    public static AbstractCriterion LeProperty(string propertyName, string otherPropertyName);
    public static AbstractCriterion LeProperty(IProjection projection, string otherPropertyName);
    public static AbstractCriterion LeProperty(string propertyName, IProjection projection);
    public static AbstractCriterion LeProperty(IProjection lhsProjection, IProjection rhsProjection);
    public static AbstractCriterion IsNotNull(string propertyName);
    public static AbstractCriterion IsNotNull(IProjection projection);
    public static AbstractEmptinessExpression IsNotEmpty(string propertyName);
    public static AbstractEmptinessExpression IsEmpty(string propertyName);
    public static AbstractCriterion And(ICriterion lhs, ICriterion rhs);
    public static AbstractCriterion Or(ICriterion lhs, ICriterion rhs);
    public static AbstractCriterion Not(ICriterion expression);
    public static Conjunction Conjunction();
    public static Disjunction Disjunction();
    public static AbstractCriterion AllEq(IDictionary propertyNameValues);
    public static NaturalIdentifier NaturalId();
    public static ICriterion Where(Expression`1<Func`2<T, bool>> expression);
    public static ICriterion Where(Expression`1<Func`1<bool>> expression);
    public static ICriterion WhereNot(Expression`1<Func`2<T, bool>> expression);
    public static ICriterion WhereNot(Expression`1<Func`1<bool>> expression);
    public static LambdaRestrictionBuilder On(Expression`1<Func`2<T, object>> expression);
    public static LambdaRestrictionBuilder On(Expression`1<Func`1<object>> expression);
}
public class NHibernate.Criterion.RowCountInt64Projection : RowCountProjection {
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.RowCountProjection : SimpleProjection {
    public bool IsAggregate { get; }
    public bool IsGrouped { get; }
    public virtual bool get_IsAggregate();
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
    public virtual bool get_IsGrouped();
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.SelectSubqueryExpression : SubqueryExpression {
    internal SelectSubqueryExpression(DetachedCriteria dc);
    protected virtual SqlString ToLeftSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.SimpleExpression : AbstractCriterion {
    private IProjection _projection;
    private string propertyName;
    private object value;
    private bool ignoreCase;
    private string op;
    private static Type[] CallToStringTypes;
    public string PropertyName { get; }
    public object Value { get; }
    protected string Op { get; }
    protected internal SimpleExpression(IProjection projection, object value, string op);
    public SimpleExpression(string propertyName, object value, string op);
    public SimpleExpression(string propertyName, object value, string op, bool ignoreCase);
    private static SimpleExpression();
    public SimpleExpression IgnoreCase();
    public string get_PropertyName();
    public object get_Value();
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public TypedValue GetParameterTypedValue(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual string ToString();
    protected virtual string get_Op();
    private string ValueToStrings();
}
public abstract class NHibernate.Criterion.SimpleProjection : object {
    public String[] Aliases { get; }
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    public IProjection As(string alias);
    public virtual String[] GetColumnAliases(string alias, int loc);
    public virtual IType[] GetTypes(string alias, ICriteria criteria, ICriteriaQuery criteriaQuery);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public virtual String[] GetColumnAliases(int loc);
    protected string GetColumnAlias(int position);
    public sealed virtual String[] GetColumnAliases(string alias, int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] GetColumnAliases(int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual String[] get_Aliases();
    public abstract virtual bool get_IsGrouped();
    public abstract virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual bool get_IsAggregate();
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public abstract virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    public abstract virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private int GetColumnCount(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.SimpleSubqueryExpression : SubqueryExpression {
    private object value;
    internal SimpleSubqueryExpression(object value, string op, string quantifier, DetachedCriteria dc);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    protected virtual SqlString ToLeftSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private static TypedValue[] GetTypedValues(IType type, object value);
}
public class NHibernate.Criterion.SQLCriterion : AbstractCriterion {
    private SqlString _sql;
    private TypedValue[] _typedValues;
    public SQLCriterion(SqlString sql, Object[] values, IType[] types);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public virtual string ToString();
}
public class NHibernate.Criterion.SqlFunctionProjection : SimpleProjection {
    private IProjection[] args;
    private ISQLFunction function;
    private string functionName;
    private IType returnType;
    private IProjection returnTypeProjection;
    public bool IsAggregate { get; }
    public bool IsGrouped { get; }
    public SqlFunctionProjection(string functionName, IType returnType, IProjection[] args);
    public SqlFunctionProjection(ISQLFunction function, IType returnType, IProjection[] args);
    public SqlFunctionProjection(string functionName, IProjection returnTypeProjection, IProjection[] args);
    public virtual bool get_IsAggregate();
    public virtual bool get_IsGrouped();
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToSqlString(ICriteria criteria, int position, ICriteriaQuery criteriaQuery);
    private ISQLFunction GetFunction(ICriteriaQuery criteriaQuery);
    private static Object[] GetProjectionArguments(ICriteriaQuery criteriaQuery, ICriteria criteria, IProjection projection);
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private IType GetReturnType(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.SQLProjection : object {
    private string sql;
    private string groupBy;
    private IType[] types;
    private String[] aliases;
    private String[] columnAliases;
    private bool grouped;
    public String[] Aliases { get; }
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    internal SQLProjection(string sql, String[] columnAliases, IType[] types);
    internal SQLProjection(string sql, string groupBy, String[] columnAliases, IType[] types);
    public sealed virtual SqlString ToSqlString(ICriteria criteria, int loc, ICriteriaQuery criteriaQuery);
    public sealed virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    private SqlString GetSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery, string sqlTemplate);
    public virtual string ToString();
    public sealed virtual IType[] GetTypes(ICriteria crit, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] get_Aliases();
    public sealed virtual bool get_IsGrouped();
    public sealed virtual bool get_IsAggregate();
    public sealed virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual IType[] GetTypes(string alias, ICriteria crit, ICriteriaQuery criteriaQuery);
    public String[] GetColumnAliases(int loc);
    public String[] GetColumnAliases(string alias, int loc);
    public sealed virtual String[] GetColumnAliases(int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
    public sealed virtual String[] GetColumnAliases(string alias, int position, ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.Criterion.Subqueries : object {
    public static AbstractCriterion Exists(DetachedCriteria dc);
    public static AbstractCriterion NotExists(DetachedCriteria dc);
    public static AbstractCriterion PropertyEqAll(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyIn(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyNotIn(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyEq(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyNe(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyGt(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyLt(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyGe(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyLe(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyGtAll(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyLtAll(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyGeAll(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyLeAll(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyGtSome(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyLtSome(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyGeSome(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion PropertyLeSome(string propertyName, DetachedCriteria dc);
    public static AbstractCriterion EqAll(object value, DetachedCriteria dc);
    public static AbstractCriterion In(object value, DetachedCriteria dc);
    public static AbstractCriterion NotIn(object value, DetachedCriteria dc);
    public static AbstractCriterion Eq(object value, DetachedCriteria dc);
    public static AbstractCriterion Gt(object value, DetachedCriteria dc);
    public static AbstractCriterion Lt(object value, DetachedCriteria dc);
    public static AbstractCriterion Ge(object value, DetachedCriteria dc);
    public static AbstractCriterion Le(object value, DetachedCriteria dc);
    public static AbstractCriterion Ne(object value, DetachedCriteria dc);
    public static AbstractCriterion GtAll(object value, DetachedCriteria dc);
    public static AbstractCriterion LtAll(object value, DetachedCriteria dc);
    public static AbstractCriterion GeAll(object value, DetachedCriteria dc);
    public static AbstractCriterion LeAll(object value, DetachedCriteria dc);
    public static AbstractCriterion GtSome(object value, DetachedCriteria dc);
    public static AbstractCriterion LtSome(object value, DetachedCriteria dc);
    public static AbstractCriterion GeSome(object value, DetachedCriteria dc);
    public static AbstractCriterion LeSome(object value, DetachedCriteria dc);
    public static AbstractCriterion Select(DetachedCriteria detachedCriteria);
    public static LambdaSubqueryBuilder WhereProperty(Expression`1<Func`2<T, object>> expression);
    public static LambdaSubqueryBuilder WhereProperty(Expression`1<Func`1<object>> expression);
    public static LambdaSubqueryBuilder WhereValue(object value);
    public static AbstractCriterion Where(Expression`1<Func`2<T, bool>> expression);
    public static AbstractCriterion Where(Expression`1<Func`1<bool>> expression);
    public static AbstractCriterion WhereAll(Expression`1<Func`2<T, bool>> expression);
    public static AbstractCriterion WhereAll(Expression`1<Func`1<bool>> expression);
    public static AbstractCriterion WhereSome(Expression`1<Func`2<T, bool>> expression);
    public static AbstractCriterion WhereSome(Expression`1<Func`1<bool>> expression);
    public static AbstractCriterion WhereExists(QueryOver`1<U> detachedQuery);
    public static AbstractCriterion WhereNotExists(QueryOver`1<U> detachedQuery);
    public static AbstractCriterion IsNull(DetachedCriteria dc);
    public static AbstractCriterion IsNotNull(DetachedCriteria dc);
}
public abstract class NHibernate.Criterion.SubqueryExpression : AbstractCriterion {
    private CriteriaImpl criteriaImpl;
    private string quantifier;
    private bool prefixOp;
    private string op;
    private QueryParameters parameters;
    private IType[] types;
    public ICriteria Criteria { get; }
    protected SubqueryExpression(string op, string quantifier, DetachedCriteria dc);
    protected SubqueryExpression(string op, string quantifier, DetachedCriteria dc, bool prefixOp);
    public IType[] GetTypes();
    protected abstract virtual SqlString ToLeftSqlString(ICriteria criteria, ICriteriaQuery outerQuery);
    public virtual SqlString ToSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual string ToString();
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual IProjection[] GetProjections();
    public ICriteria get_Criteria();
    private static ISessionImplementor DeriveRootSession(ICriteria criteria);
}
public class NHibernate.Criterion.SubqueryProjection : SimpleProjection {
    private SelectSubqueryExpression _subQuery;
    public bool IsGrouped { get; }
    public bool IsAggregate { get; }
    protected internal SubqueryProjection(SelectSubqueryExpression subquery);
    public virtual string ToString();
    public virtual bool get_IsGrouped();
    public virtual bool get_IsAggregate();
    public virtual IType[] GetTypes(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToSqlString(ICriteria criteria, int loc, ICriteriaQuery criteriaQuery);
    public virtual SqlString ToGroupSqlString(ICriteria criteria, ICriteriaQuery criteriaQuery);
    public virtual TypedValue[] GetTypedValues(ICriteria criteria, ICriteriaQuery criteriaQuery);
}
public class NHibernate.DebugHelpers.CollectionProxy : object {
    private ICollection set;
    [DebuggerBrowsableAttribute("3")]
public Object[] Items { get; }
    public CollectionProxy(ICollection dic);
    public Object[] get_Items();
}
public class NHibernate.DebugHelpers.CollectionProxy`1 : object {
    private ICollection`1<T> set;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CollectionProxy`1(ICollection`1<T> dic);
    public T[] get_Items();
}
public class NHibernate.DebugHelpers.DictionaryProxy : object {
    private IDictionary set;
    [DebuggerBrowsableAttribute("3")]
public DictionaryEntry[] Items { get; }
    public DictionaryProxy(IDictionary dic);
    public DictionaryEntry[] get_Items();
}
public class NHibernate.DebugHelpers.DictionaryProxy`2 : object {
    private IDictionary`2<K, V> dic;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public DictionaryProxy`2(IDictionary`2<K, V> dic);
    public KeyValuePair`2[] get_Items();
}
public class NHibernate.Dialect.AnsiSqlKeywords : object {
    public static IReadOnlyCollection`1<string> Sql2003;
    private static AnsiSqlKeywords();
}
[ObsoleteAttribute("Use NHibernate.Dialect.Function.BitwiseFunctionOperation instead")]
public class NHibernate.Dialect.BitwiseFunctionOperation : BitwiseFunctionOperation {
    public BitwiseFunctionOperation(string functionName);
}
[ObsoleteAttribute("Use NHibernate.Dialect.Function.BitwiseNativeOperation instead")]
public class NHibernate.Dialect.BitwiseNativeOperation : BitwiseNativeOperation {
    public BitwiseNativeOperation(string sqlOpToken);
    public BitwiseNativeOperation(string sqlOpToken, bool isNot);
}
public class NHibernate.Dialect.DB2400Dialect : DB2Dialect {
    public bool SupportsSequences { get; }
    public string IdentitySelectString { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool UseMaxForLimit { get; }
    public bool SupportsVariableLimit { get; }
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual bool get_SupportsSequences();
    public virtual string get_IdentitySelectString();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual bool get_UseMaxForLimit();
    public virtual bool get_SupportsVariableLimit();
}
public class NHibernate.Dialect.DB2Dialect : Dialect {
    public string AddColumnString { get; }
    public bool DropConstraints { get; }
    public bool SupportsIdentityColumns { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public string IdentityInsertString { get; }
    public bool SupportsSequences { get; }
    public bool SupportsLimit { get; }
    public bool UseMaxForLimit { get; }
    public bool SupportsVariableLimit { get; }
    public string ForUpdateString { get; }
    public int MaxAliasLength { get; }
    public long TimestampResolutionInTicks { get; }
    public bool SupportsNullInUnique { get; }
    public bool SupportsEmptyInList { get; }
    public bool SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor { get; }
    public bool SupportsCrossJoin { get; }
    public bool SupportsLobValueChangePropogation { get; }
    public bool SupportsExistsInSelect { get; }
    public bool DoesReadCommittedCauseWritersToBlockReaders { get; }
    public virtual string get_AddColumnString();
    public virtual bool get_DropConstraints();
    public virtual bool get_SupportsIdentityColumns();
    public virtual string get_IdentitySelectString();
    public virtual string get_IdentityColumnString();
    public virtual string get_IdentityInsertString();
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetCreateSequenceString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsLimit();
    public virtual bool get_UseMaxForLimit();
    public virtual bool get_SupportsVariableLimit();
    public virtual SqlString GetLimitString(SqlString sql, SqlString offset, SqlString limit);
    private static string GetRowNumber(SqlString sql);
    public virtual string get_ForUpdateString();
    public virtual int get_MaxAliasLength();
    public virtual long get_TimestampResolutionInTicks();
    public virtual string ToStringLiteral(string value, SqlType type);
    public virtual bool get_SupportsNullInUnique();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor();
    public virtual bool get_SupportsCrossJoin();
    public virtual bool get_SupportsLobValueChangePropogation();
    public virtual bool get_SupportsExistsInSelect();
    public virtual bool get_DoesReadCommittedCauseWritersToBlockReaders();
}
public abstract class NHibernate.Dialect.Dialect : object {
    private static INHibernateLogger Log;
    protected static string DefaultBatchSize;
    protected static string NoBatch;
    public static string PossibleQuoteChars;
    public static string PossibleClosedQuoteChars;
    private TypeNames _typeNames;
    private TypeNames _hibernateTypeNames;
    private IDictionary`2<string, string> _properties;
    private IDictionary`2<string, ISQLFunction> _sqlFunctions;
    private static IDictionary`2<string, ISQLFunction> StandardAggregateFunctions;
    private static IViolatedConstraintNameExtracter Extracter;
    [CompilerGeneratedAttribute]
private int <DefaultCastLength>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <DefaultCastPrecision>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <DefaultCastScale>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeBackslashInStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Keywords>k__BackingField;
    public int DefaultCastLength { get; protected set; }
    public byte DefaultCastPrecision { get; protected set; }
    public byte DefaultCastScale { get; protected set; }
    public bool DropConstraints { get; }
    public bool QualifyIndexName { get; }
    public bool SupportsUnique { get; }
    public bool SupportsUniqueConstraintInCreateAlterTable { get; }
    public bool SupportsForeignKeyConstraintInAlterTable { get; }
    public bool HasSelfReferentialForeignKeyBug { get; }
    public bool SupportsCommentOn { get; }
    public bool SupportsIfExistsBeforeTableName { get; }
    public bool SupportsIfExistsAfterTableName { get; }
    public bool SupportsColumnCheck { get; }
    public bool SupportsTableCheck { get; }
    public bool SupportsCascadeDelete { get; }
    [ObsoleteAttribute("Use or override SupportsNullInUnique instead")]
public bool SupportsNotNullUnique { get; }
    public bool SupportsNullInUnique { get; }
    public string ForUpdateString { get; }
    public bool SupportsForUpdateOf { get; }
    [ObsoleteAttribute("Use UsesColumnsWithForUpdateOf instead")]
public bool ForUpdateOfColumns { get; }
    public bool UsesColumnsWithForUpdateOf { get; }
    public bool SupportsOuterJoinForUpdate { get; }
    public string ForUpdateNowaitString { get; }
    public bool SupportsTemporaryTables { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public bool SupportsCurrentUtcTimestampSelection { get; }
    public long TimestampResolutionInTicks { get; }
    public string CascadeConstraintsString { get; }
    public string DisableForeignKeyConstraintsString { get; }
    public string EnableForeignKeyConstraintsString { get; }
    public bool SupportsIdentityColumns { get; }
    public bool SupportsInsertSelectIdentity { get; }
    public bool HasDataTypeInIdentityColumn { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public bool GenerateTablePrimaryKeyConstraintForIdentityColumn { get; }
    public InsertGeneratedIdentifierRetrievalMethod InsertGeneratedIdentifierRetrievalMethod { get; }
    public string IdentityInsertString { get; }
    public bool SupportsSequences { get; }
    public bool SupportsPooledSequences { get; }
    public string QuerySequencesString { get; }
    public Type IdentityStyleIdentifierGeneratorClass { get; }
    public Type NativeIdentifierGeneratorClass { get; }
    public bool SupportsCrossJoin { get; }
    public bool SupportsConcurrentWritingConnections { get; }
    public bool SupportsConcurrentWritingConnectionsInSameTransaction { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool SupportsVariableLimit { get; }
    public bool UseMaxForLimit { get; }
    public bool OffsetStartsAtOne { get; }
    public char OpenQuote { get; }
    public char CloseQuote { get; }
    protected bool EscapeBackslashInStrings { get; protected set; }
    protected bool UseNPrefixForUnicodeStrings { get; }
    public bool SupportsUnionAll { get; }
    public bool SupportsEmptyInList { get; }
    public bool AreStringComparisonsCaseInsensitive { get; }
    public bool SupportsRowValueConstructorSyntax { get; }
    public bool SupportsRowValueConstructorSyntaxInInList { get; }
    public bool UseInputStreamToInsertBlob { get; }
    public bool SupportsParametersInInsertSelect { get; }
    public bool ReplaceResultVariableInOrderByClauseWithPosition { get; }
    public bool SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor { get; }
    public bool SupportsCircularCascadeDeleteConstraints { get; }
    public bool SupportsSubselectAsInPredicateLHS { get; }
    public bool SupportsSubSelectsWithPagingAsInPredicateRhs { get; }
    public bool SupportsExpectedLobUsagePattern { get; }
    public bool SupportsLobValueChangePropogation { get; }
    public bool SupportsUnboundedLobLocatorMaterialization { get; }
    public bool SupportsSubqueryOnMutatingTable { get; }
    public bool SupportsExistsInSelect { get; }
    public bool DoesReadCommittedCauseWritersToBlockReaders { get; }
    public bool DoesRepeatableReadCauseReadersToBlockWriters { get; }
    public bool SupportsBindAsCallableArgument { get; }
    public bool SupportsSubSelects { get; }
    public bool SupportsScalarSubSelects { get; }
    public bool SupportsPoolingParameter { get; }
    public bool SupportsHavingOnGroupedByComputation { get; }
    public bool SupportsDistributedTransactions { get; }
    public bool SupportsDateTimeScale { get; }
    public IDictionary`2<string, string> DefaultProperties { get; }
    public IDictionary`2<string, ISQLFunction> Functions { get; }
    public HashSet`1<string> Keywords { get; }
    public string SelectGUIDString { get; }
    public string CreateTableString { get; }
    public string CreateMultisetTableString { get; }
    public string CreateTemporaryTableString { get; }
    public string CreateTemporaryTablePostfix { get; }
    public bool IsCurrentTimestampSelectStringCallable { get; }
    public string CurrentTimestampSelectString { get; }
    public string CurrentTimestampSQLFunctionName { get; }
    public string CurrentUtcTimestampSelectString { get; }
    public string CurrentUtcTimestampSQLFunctionName { get; }
    public IViolatedConstraintNameExtracter ViolatedConstraintNameExtracter { get; }
    public string NoColumnsInsertString { get; }
    public string LowercaseFunction { get; }
    public int MaxAliasLength { get; }
    public Nullable`1<int> MaxNumberOfParameters { get; }
    public char StatementTerminator { get; }
    public string AddColumnString { get; }
    public string AddColumnSuffixString { get; }
    public string DropForeignKeyString { get; }
    public string TableTypeString { get; }
    public string NullColumnString { get; }
    public string PrimaryKeyString { get; }
    public bool SupportsSqlBatches { get; }
    public bool IsDecimalStoredAsFloatingPointNumber { get; }
    private static Dialect();
    public virtual Task`1<DbDataReader> GetResultSetAsync(DbCommand statement, CancellationToken cancellationToken);
    public static Dialect GetDialect();
    public static Dialect GetDialect(IDictionary`2<string, string> props);
    private static Dialect InstantiateDialect(string dialectName, IDictionary`2<string, string> props);
    public virtual void Configure(IDictionary`2<string, string> settings);
    public virtual string GetTypeName(SqlType sqlType);
    public virtual string GetTypeName(SqlType sqlType, int length, int precision, int scale);
    public virtual string GetLongestTypeName(DbType dbType);
    [CompilerGeneratedAttribute]
public int get_DefaultCastLength();
    [CompilerGeneratedAttribute]
protected void set_DefaultCastLength(int value);
    [CompilerGeneratedAttribute]
public byte get_DefaultCastPrecision();
    [CompilerGeneratedAttribute]
protected void set_DefaultCastPrecision(byte value);
    [CompilerGeneratedAttribute]
public byte get_DefaultCastScale();
    [CompilerGeneratedAttribute]
protected void set_DefaultCastScale(byte value);
    public virtual string GetCastTypeName(SqlType sqlType);
    public virtual bool TryGetCastTypeName(SqlType sqlType, String& typeName);
    protected virtual string GetCastTypeName(SqlType sqlType, TypeNames castTypeNames);
    protected virtual bool TryGetCastTypeName(SqlType sqlType, TypeNames castTypeNames, String& typeName);
    protected void RegisterColumnType(DbType code, int capacity, string name);
    protected void RegisterColumnType(DbType code, string name);
    public virtual SqlType OverrideSqlType(SqlType type);
    public virtual bool get_DropConstraints();
    public virtual bool get_QualifyIndexName();
    public virtual bool get_SupportsUnique();
    public virtual bool get_SupportsUniqueConstraintInCreateAlterTable();
    public virtual bool get_SupportsForeignKeyConstraintInAlterTable();
    public virtual string GetAddForeignKeyConstraintString(string constraintName, String[] foreignKey, string referencedTable, String[] primaryKey, bool referencesPrimaryKey);
    public virtual string GetAddPrimaryKeyConstraintString(string constraintName);
    public virtual bool get_HasSelfReferentialForeignKeyBug();
    public virtual bool get_SupportsCommentOn();
    public virtual string GetTableComment(string comment);
    public virtual string GetColumnComment(string comment);
    public virtual bool get_SupportsIfExistsBeforeTableName();
    public virtual bool get_SupportsIfExistsAfterTableName();
    public virtual bool get_SupportsColumnCheck();
    public virtual bool get_SupportsTableCheck();
    public virtual bool get_SupportsCascadeDelete();
    public virtual bool get_SupportsNotNullUnique();
    public virtual bool get_SupportsNullInUnique();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual ILockingStrategy GetLockingStrategy(ILockable lockable, LockMode lockMode);
    public virtual string GetForUpdateString(LockMode lockMode);
    public virtual string get_ForUpdateString();
    public virtual bool get_SupportsForUpdateOf();
    public virtual bool get_ForUpdateOfColumns();
    public virtual bool get_UsesColumnsWithForUpdateOf();
    public virtual bool get_SupportsOuterJoinForUpdate();
    public virtual string GetForUpdateString(string aliases);
    public virtual string get_ForUpdateNowaitString();
    public virtual string GetForUpdateNowaitString(string aliases);
    public virtual SqlString ApplyLocksToSql(SqlString sql, IDictionary`2<string, LockMode> aliasedLockModes, IDictionary`2<string, String[]> keyColumnNames);
    public virtual string AppendLockHint(LockMode lockMode, string tableName);
    public virtual string GetDropTableString(string tableName);
    public virtual bool get_SupportsTemporaryTables();
    public virtual string GenerateTemporaryTableName(string baseTableName);
    public virtual Nullable`1<bool> PerformTemporaryTableDDLInIsolation();
    public virtual bool DropTemporaryTableAfterUse();
    public virtual int RegisterResultSetOutParameter(DbCommand statement, int position);
    public virtual DbDataReader GetResultSet(DbCommand statement);
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual bool get_SupportsCurrentUtcTimestampSelection();
    public virtual long get_TimestampResolutionInTicks();
    public virtual string GetDropForeignKeyConstraintString(string constraintName);
    [ObsoleteAttribute("Can cause issues when a custom schema is defined (https://nhibernate.jira.com/browse/NH-1285). The new overload with the defaultSchema parameter should be used instead")]
public virtual string GetIfNotExistsCreateConstraint(Table table, string name);
    [ObsoleteAttribute("Can cause issues when a custom schema is defined (https://nhibernate.jira.com/browse/NH-1285). The new overload with the defaultSchema parameter should be used instead")]
public virtual string GetIfNotExistsCreateConstraintEnd(Table table, string name);
    [ObsoleteAttribute("Can cause issues when a custom schema is defined (https://nhibernate.jira.com/browse/NH-1285). The new overload with the defaultSchema parameter should be used instead")]
public virtual string GetIfExistsDropConstraint(Table table, string name);
    [ObsoleteAttribute("Can cause issues when a custom schema is defined (https://nhibernate.jira.com/browse/NH-1285). The new overload with the defaultSchema parameter should be used instead")]
public virtual string GetIfExistsDropConstraintEnd(Table table, string name);
    public virtual string GetIfNotExistsCreateConstraint(string catalog, string schema, string table, string name);
    public virtual string GetIfNotExistsCreateConstraintEnd(string catalog, string schema, string table, string name);
    public virtual string GetIfExistsDropConstraint(string catalog, string schema, string table, string name);
    public virtual string GetIfExistsDropConstraintEnd(string catalog, string schema, string table, string name);
    public virtual string GetDropPrimaryKeyConstraintString(string constraintName);
    public virtual string GetDropIndexConstraintString(string constraintName);
    public virtual string get_CascadeConstraintsString();
    public virtual string get_DisableForeignKeyConstraintsString();
    public virtual string get_EnableForeignKeyConstraintsString();
    public virtual bool get_SupportsIdentityColumns();
    public virtual bool get_SupportsInsertSelectIdentity();
    public virtual bool get_HasDataTypeInIdentityColumn();
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertString);
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertString, string identifierColumnName);
    public virtual string GetIdentitySelectString(string identityColumn, string tableName, DbType type);
    public virtual string get_IdentitySelectString();
    public virtual string GetIdentityColumnString(DbType type);
    public virtual string get_IdentityColumnString();
    public virtual bool get_GenerateTablePrimaryKeyConstraintForIdentityColumn();
    public virtual SqlString AddIdentifierOutParameterToInsert(SqlString insertString, string identifierColumnName, string parameterName);
    public virtual InsertGeneratedIdentifierRetrievalMethod get_InsertGeneratedIdentifierRetrievalMethod();
    public virtual string get_IdentityInsertString();
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsPooledSequences();
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual String[] GetDropSequenceStrings(string sequenceName);
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string GetCreateSequenceString(string sequenceName);
    public virtual String[] GetCreateSequenceStrings(string sequenceName, int initialValue, int incrementSize);
    protected virtual string GetCreateSequenceString(string sequenceName, int initialValue, int incrementSize);
    public virtual string get_QuerySequencesString();
    public virtual Type get_IdentityStyleIdentifierGeneratorClass();
    public virtual Type get_NativeIdentifierGeneratorClass();
    public virtual JoinFragment CreateOuterJoinFragment();
    public virtual bool get_SupportsCrossJoin();
    public virtual CaseFragment CreateCaseFragment();
    internal static void ExtractColumnOrAliasNames(SqlString select, List`1& columnsOrAliases, Dictionary`2& aliasToColumn, Dictionary`2& columnToAlias);
    public virtual bool get_SupportsConcurrentWritingConnections();
    public virtual bool get_SupportsConcurrentWritingConnectionsInSameTransaction();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual bool get_SupportsVariableLimit();
    public virtual bool get_UseMaxForLimit();
    public virtual bool get_OffsetStartsAtOne();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public SqlString GetLimitString(SqlString queryString, Nullable`1<int> offset, Nullable`1<int> limit, Parameter offsetParameter, Parameter limitParameter);
    public int GetLimitValue(int offset, int limit);
    public int GetOffsetValue(int offset);
    public virtual char get_OpenQuote();
    public virtual char get_CloseQuote();
    public virtual bool IsQuoted(string name);
    public virtual string Qualify(string catalog, string schema, string name);
    protected virtual string Quote(string name);
    public virtual string QuoteForAliasName(string aliasName);
    public virtual string QuoteForColumnName(string columnName);
    public virtual string QuoteForTableName(string tableName);
    public virtual string QuoteForSchemaName(string schemaName);
    public virtual string QuoteForCatalogName(string catalogName);
    public virtual string UnQuote(string quoted);
    public virtual String[] UnQuote(String[] quoted);
    public virtual string ConvertQuotesForAliasName(string aliasName);
    public virtual string ConvertQuotesForColumnName(string columnName);
    public virtual string ConvertQuotesForTableName(string tableName);
    public virtual string ConvertQuotesForSchemaName(string schemaName);
    public virtual string ConvertQuotesForCatalogName(string catalogName);
    public virtual string ToBooleanValueString(bool value);
    [CompilerGeneratedAttribute]
protected virtual bool get_EscapeBackslashInStrings();
    [CompilerGeneratedAttribute]
protected virtual void set_EscapeBackslashInStrings(bool value);
    protected virtual bool get_UseNPrefixForUnicodeStrings();
    public virtual string ToStringLiteral(string value, SqlType type);
    public virtual string GetSelectClauseNullString(SqlType sqlType);
    public virtual bool get_SupportsUnionAll();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_AreStringComparisonsCaseInsensitive();
    public virtual bool get_SupportsRowValueConstructorSyntax();
    public virtual bool get_SupportsRowValueConstructorSyntaxInInList();
    public virtual bool get_UseInputStreamToInsertBlob();
    public virtual bool get_SupportsParametersInInsertSelect();
    public virtual bool get_ReplaceResultVariableInOrderByClauseWithPosition();
    public virtual bool get_SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor();
    public virtual bool get_SupportsCircularCascadeDeleteConstraints();
    public virtual bool get_SupportsSubselectAsInPredicateLHS();
    public virtual bool get_SupportsSubSelectsWithPagingAsInPredicateRhs();
    public virtual bool get_SupportsExpectedLobUsagePattern();
    public virtual bool get_SupportsLobValueChangePropogation();
    public virtual bool get_SupportsUnboundedLobLocatorMaterialization();
    public virtual bool get_SupportsSubqueryOnMutatingTable();
    public virtual bool get_SupportsExistsInSelect();
    public virtual bool get_DoesReadCommittedCauseWritersToBlockReaders();
    public virtual bool get_DoesRepeatableReadCauseReadersToBlockWriters();
    public virtual bool get_SupportsBindAsCallableArgument();
    public virtual bool get_SupportsSubSelects();
    public virtual bool get_SupportsScalarSubSelects();
    public virtual bool get_SupportsPoolingParameter();
    public virtual bool get_SupportsHavingOnGroupedByComputation();
    public virtual bool get_SupportsDistributedTransactions();
    public virtual bool get_SupportsDateTimeScale();
    public IDictionary`2<string, string> get_DefaultProperties();
    public virtual IDictionary`2<string, ISQLFunction> get_Functions();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Keywords();
    public virtual string get_SelectGUIDString();
    public virtual string get_CreateTableString();
    public virtual string get_CreateMultisetTableString();
    public virtual string get_CreateTemporaryTableString();
    public virtual string get_CreateTemporaryTablePostfix();
    public virtual bool get_IsCurrentTimestampSelectStringCallable();
    public virtual string get_CurrentTimestampSelectString();
    public virtual string get_CurrentTimestampSQLFunctionName();
    public virtual string get_CurrentUtcTimestampSelectString();
    public virtual string get_CurrentUtcTimestampSQLFunctionName();
    public virtual IViolatedConstraintNameExtracter get_ViolatedConstraintNameExtracter();
    public virtual string get_NoColumnsInsertString();
    public virtual string get_LowercaseFunction();
    public virtual int get_MaxAliasLength();
    public virtual Nullable`1<int> get_MaxNumberOfParameters();
    public virtual char get_StatementTerminator();
    public virtual string get_AddColumnString();
    public virtual string get_AddColumnSuffixString();
    public virtual string get_DropForeignKeyString();
    public virtual string get_TableTypeString();
    public virtual string get_NullColumnString();
    public virtual string get_PrimaryKeyString();
    public virtual bool get_SupportsSqlBatches();
    public virtual bool get_IsDecimalStoredAsFloatingPointNumber();
    public virtual bool IsKnownToken(string currentToken, string nextToken);
    protected void RegisterKeyword(string word);
    protected internal void RegisterKeywords(String[] keywords);
    protected internal void RegisterKeywords(IEnumerable`1<string> keywords);
    public bool IsKeyword(string str);
    protected void RegisterFunction(string name, ISQLFunction function);
    private void RegisterHibernateType(DbType code, string name);
    public virtual ISQLExceptionConverter BuildSQLExceptionConverter();
}
public class NHibernate.Dialect.Firebird4Dialect : FirebirdDialect {
    public string CurrentTimestampSelectString { get; }
    public virtual string get_CurrentTimestampSelectString();
    protected virtual void RegisterFunctions();
}
public class NHibernate.Dialect.FirebirdDialect : Dialect {
    private static String[] DialectKeywords;
    public string AddColumnString { get; }
    public bool SupportsSequences { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool SupportsTemporaryTables { get; }
    public string CreateTemporaryTableString { get; }
    public string QuerySequencesString { get; }
    public long TimestampResolutionInTicks { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public string CurrentTimestampSelectString { get; }
    public string SelectGUIDString { get; }
    public int MaxAliasLength { get; }
    public bool SupportsDistributedTransactions { get; }
    private static FirebirdDialect();
    public virtual string get_AddColumnString();
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetCreateSequenceString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual bool get_SupportsTemporaryTables();
    public virtual string get_CreateTemporaryTableString();
    public virtual Nullable`1<bool> PerformTemporaryTableDDLInIsolation();
    public virtual bool DropTemporaryTableAfterUse();
    private static int GetAfterSelectInsertPoint(SqlString text);
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual string get_QuerySequencesString();
    public virtual SqlString AddIdentifierOutParameterToInsert(SqlString insertString, string identifierColumnName, string parameterName);
    public virtual long get_TimestampResolutionInTicks();
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual string get_CurrentTimestampSelectString();
    public virtual string get_SelectGUIDString();
    protected virtual void RegisterKeywords();
    protected virtual void RegisterColumnTypes();
    protected virtual void RegisterFunctions();
    private void OverrideStandardHQLFunctions();
    private void RegisterFirebirdServerEmbeddedFunctions();
    private void RegisterExternalFbAndIbStandardUDFs();
    private void RegisterMathematicalFunctions();
    private void RegisterDateTimeFunctions();
    private void RegisterStringAndCharFunctions();
    private void RegisterBlobFunctions();
    private void RegisterTrigonometricFunctions();
    public virtual int get_MaxAliasLength();
    public virtual bool get_SupportsDistributedTransactions();
}
public class NHibernate.Dialect.Function.AnsiExtractFunction : SQLFunctionTemplate {
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsSeparator(string token);
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsKnownArgument(string token);
}
public class NHibernate.Dialect.Function.AnsiSubstringFunction : object {
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
public class NHibernate.Dialect.Function.AnsiTrimEmulationFunction : object {
    private static ISQLFunction LeadingSpaceTrim;
    private static ISQLFunction TrailingSpaceTrim;
    private static ISQLFunction BothSpaceTrim;
    private static ISQLFunction BothSpaceTrimFrom;
    private static ISQLFunction LeadingTrim;
    private static ISQLFunction TrailingTrim;
    private static ISQLFunction BothTrim;
    private ISQLFunction _leadingTrim;
    private ISQLFunction _trailingTrim;
    private ISQLFunction _bothTrim;
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    public AnsiTrimEmulationFunction(string replaceFunction);
    private static AnsiTrimEmulationFunction();
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsSeparator(string token);
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsKnownArgument(string token);
}
public class NHibernate.Dialect.Function.AnsiTrimFunction : SQLFunctionTemplate {
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsSeparator(string token);
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsKnownArgument(string token);
}
internal class NHibernate.Dialect.Function.AvgQueryFunctionInfo : ClassicAggregateFunction {
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
public class NHibernate.Dialect.Function.BitwiseFunctionOperation : object {
    private string _functionName;
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    public BitwiseFunctionOperation(string functionName);
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    private static bool IsParens(string candidate);
}
public class NHibernate.Dialect.Function.BitwiseNativeOperation : object {
    private string _sqlOpToken;
    private bool _isUnary;
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    public BitwiseNativeOperation(string sqlOpToken);
    public BitwiseNativeOperation(string sqlOpToken, bool isUnary);
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    private static void AddToBuffer(object arg, SqlStringBuilder buffer);
}
public class NHibernate.Dialect.Function.CastFunction : object {
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
protected virtual bool CastingIsRequired(string sqlType);
    protected virtual SqlString Render(object expression, string sqlType, ISessionFactoryImplementor factory);
    internal SqlString Render(IList args, IType expectedType, ISessionFactoryImplementor factory);
    private static string GetCastTypeName(ISessionFactoryImplementor factory, IType hqlType, string typeName);
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsSeparator(string token);
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsKnownArgument(string token);
}
public class NHibernate.Dialect.Function.CharIndexFunction : object {
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    private static void RenderPositionInSubstring(SqlStringBuilder buf, object pattern, object orgString, object start);
}
public class NHibernate.Dialect.Function.ClassicAggregateFunction : object {
    private IType returnType;
    private string name;
    protected bool acceptAsterisk;
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    public ClassicAggregateFunction(string name, bool acceptAsterisk);
    public ClassicAggregateFunction(string name, bool acceptAsterisk, IType typeValue);
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    protected bool TryGetArgumentType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError, IType& argumentType, SqlType& sqlType);
    public virtual string ToString();
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsSeparator(string token);
    private sealed virtual override bool NHibernate.Dialect.Function.IFunctionGrammar.IsKnownArgument(string token);
}
public class NHibernate.Dialect.Function.ClassicAvgFunction : ClassicAggregateFunction {
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
public class NHibernate.Dialect.Function.ClassicCountFunction : ClassicAggregateFunction {
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
public class NHibernate.Dialect.Function.ClassicSumFunction : ClassicAggregateFunction {
}
public class NHibernate.Dialect.Function.CommonGrammar : object {
    public sealed virtual bool IsSeparator(string token);
    public sealed virtual bool IsKnownArgument(string token);
}
internal class NHibernate.Dialect.Function.CountQueryFunctionInfo : ClassicAggregateFunction {
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
public class NHibernate.Dialect.Function.EmulatedLengthSubstringFunction : StandardSQLFunction {
    public virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
public interface NHibernate.Dialect.Function.IFunctionGrammar {
    public abstract virtual bool IsSeparator(string token);
    public abstract virtual bool IsKnownArgument(string token);
}
internal class NHibernate.Dialect.Function.IifSafeSQLFunction : StandardSafeSQLFunction {
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
internal class NHibernate.Dialect.Function.IifSQLFunction : SQLFunctionTemplate {
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
public interface NHibernate.Dialect.Function.ISQLFunction {
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    [ObsoleteAttribute("Use GetReturnType extension method instead.")]
public abstract virtual IType ReturnType(IType columnType, IMapping mapping);
    public abstract virtual bool get_HasArguments();
    public abstract virtual bool get_HasParenthesesIfNoArguments();
    public abstract virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
internal interface NHibernate.Dialect.Function.ISQLFunctionExtended {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public abstract virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
internal class NHibernate.Dialect.Function.ModulusFunction : StandardSafeSQLFunction {
    private ModulusFunctionTypeDetector _modulusFunctionTypeDetector;
    public ModulusFunction(bool supportDecimals, bool supportFloatingNumbers);
    public ModulusFunction(ModulusFunctionTypeDetector modulusFunction);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
internal class NHibernate.Dialect.Function.ModulusFunctionTemplate : SQLFunctionTemplate {
    private ModulusFunctionTypeDetector _modulusFunctionTypeDetector;
    public ModulusFunctionTemplate(bool supportDecimals);
    public ModulusFunctionTemplate(ModulusFunctionTypeDetector modulusFunction);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
internal class NHibernate.Dialect.Function.ModulusFunctionTypeDetector : object {
    private Lazy`1<Dictionary`2<DbType, KeyValuePair`2<int, IType>>> _supportedDbTypesLazy;
    private bool _supportDecimals;
    private bool _supportFloatingNumbers;
    public ModulusFunctionTypeDetector(bool supportDecimals, bool supportFloatingNumbers);
    public ModulusFunctionTypeDetector(bool supportDecimals);
    protected virtual Dictionary`2<DbType, KeyValuePair`2<int, IType>> GetSupportedTypes();
    public IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    private IType ThrowOrReturnDefault(string error, bool throwOnError);
}
public class NHibernate.Dialect.Function.NoArgSQLFunction : object {
    [CompilerGeneratedAttribute]
private IType <FunctionReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasParenthesesIfNoArguments>k__BackingField;
    public IType FunctionReturnType { get; protected set; }
    public string Name { get; protected set; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; protected set; }
    public NoArgSQLFunction(string name, IType returnType);
    public NoArgSQLFunction(string name, IType returnType, bool hasParenthesesIfNoArguments);
    [CompilerGeneratedAttribute]
public IType get_FunctionReturnType();
    [CompilerGeneratedAttribute]
protected void set_FunctionReturnType(IType value);
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public sealed virtual bool get_HasArguments();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasParenthesesIfNoArguments();
    [CompilerGeneratedAttribute]
protected void set_HasParenthesesIfNoArguments(bool value);
    public virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
public class NHibernate.Dialect.Function.NvlFunction : object {
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
public class NHibernate.Dialect.Function.PositionSubstringFunction : object {
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public sealed virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    private static void RenderPositionInSubstring(SqlStringBuilder buf, object pattern, object orgString, object start);
}
[ExtensionAttribute]
public static class NHibernate.Dialect.Function.SQLFunctionExtensions : object {
    [ExtensionAttribute]
public static IType GetEffectiveReturnType(ISQLFunction sqlFunction, IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    [ExtensionAttribute]
public static IType GetReturnType(ISQLFunction sqlFunction, IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
public class NHibernate.Dialect.Function.SQLFunctionRegistry : object {
    private Dialect dialect;
    private IDictionary`2<string, ISQLFunction> userFunctions;
    public SQLFunctionRegistry(Dialect dialect, IDictionary`2<string, ISQLFunction> userFunctions);
    public ISQLFunction FindSQLFunction(string functionName);
    public bool HasFunction(string functionName);
}
public class NHibernate.Dialect.Function.SQLFunctionTemplate : object {
    private static int InvalidArgumentIndex;
    private static Regex SplitRegex;
    private IType returnType;
    private bool hasArguments;
    private bool hasParenthesesIfNoArgs;
    private string template;
    private TemplateChunk[] chunks;
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    public SQLFunctionTemplate(IType type, string template);
    public SQLFunctionTemplate(IType type, string template, bool hasParenthesesIfNoArgs);
    private static SQLFunctionTemplate();
    private void InitFromTemplate();
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public sealed virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    public virtual string ToString();
}
public class NHibernate.Dialect.Function.SQLFunctionTemplateWithRequiredParameters : SQLFunctionTemplate {
    private Object[] _requiredArgs;
    public SQLFunctionTemplateWithRequiredParameters(IType type, string template, Object[] requiredArgs);
    public SQLFunctionTemplateWithRequiredParameters(IType type, string template, Object[] requiredArgs, bool hasParenthesesIfNoArgs);
    public virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
public class NHibernate.Dialect.Function.StandardSafeSQLFunction : StandardSQLFunction {
    private int allowedArgsCount;
    public StandardSafeSQLFunction(string name, int allowedArgsCount);
    public StandardSafeSQLFunction(string name, IType typeValue, int allowedArgsCount);
    public virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
public class NHibernate.Dialect.Function.StandardSQLFunction : object {
    private IType returnType;
    protected string name;
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    public StandardSQLFunction(string name);
    public StandardSQLFunction(string name, IType typeValue);
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
    public virtual string ToString();
}
internal class NHibernate.Dialect.Function.StandardSQLFunctionWithRequiredParameters : StandardSQLFunction {
    private Object[] _requiredArgs;
    public StandardSQLFunctionWithRequiredParameters(string name, Object[] requiredArgs);
    public StandardSQLFunctionWithRequiredParameters(string name, IType typeValue, Object[] requiredArgs);
    public virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
internal class NHibernate.Dialect.Function.SumQueryFunctionInfo : ClassicAggregateFunction {
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
}
public class NHibernate.Dialect.Function.TransparentCastFunction : CastFunction {
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
protected virtual bool CastingIsRequired(string sqlType);
    protected virtual SqlString Render(object expression, string sqlType, ISessionFactoryImplementor factory);
}
public class NHibernate.Dialect.Function.VarArgsSQLFunction : object {
    private string begin;
    private string sep;
    private string end;
    private IType returnType;
    public string Name { get; }
    public bool HasArguments { get; }
    public bool HasParenthesesIfNoArguments { get; }
    public VarArgsSQLFunction(string begin, string sep, string end);
    public VarArgsSQLFunction(IType type, string begin, string sep, string end);
    [ObsoleteAttribute("Use GetReturnType method instead.")]
public virtual IType ReturnType(IType columnType, IMapping mapping);
    public virtual IType GetReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual IType GetEffectiveReturnType(IEnumerable`1<IType> argumentTypes, IMapping mapping, bool throwOnError);
    public virtual string get_Name();
    public sealed virtual bool get_HasArguments();
    public sealed virtual bool get_HasParenthesesIfNoArguments();
    public sealed virtual SqlString Render(IList args, ISessionFactoryImplementor factory);
}
public class NHibernate.Dialect.GenericDialect : Dialect {
    public string AddColumnString { get; }
    public virtual string get_AddColumnString();
}
public class NHibernate.Dialect.HanaColumnStoreDialect : HanaDialectBase {
    public string CreateTableString { get; }
    public string CreateTemporaryTableString { get; }
    public virtual string get_CreateTableString();
    public virtual string get_CreateTemporaryTableString();
}
public abstract class NHibernate.Dialect.HanaDialectBase : Dialect {
    private static String[] DialectKeywords;
    public bool DropConstraints { get; }
    public bool QualifyIndexName { get; }
    public bool SupportsCommentOn { get; }
    public bool SupportsColumnCheck { get; }
    public bool UsesColumnsWithForUpdateOf { get; }
    public string ForUpdateNowaitString { get; }
    public bool SupportsTemporaryTables { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public bool SupportsCurrentUtcTimestampSelection { get; }
    public long TimestampResolutionInTicks { get; }
    public string CascadeConstraintsString { get; }
    public bool SupportsIdentityColumns { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public bool SupportsSequences { get; }
    public bool SupportsPooledSequences { get; }
    public string QuerySequencesString { get; }
    public bool SupportsLimit { get; }
    public bool SupportsUnionAll { get; }
    public bool SupportsEmptyInList { get; }
    public bool SupportsRowValueConstructorSyntax { get; }
    public bool SupportsRowValueConstructorSyntaxInInList { get; }
    public bool SupportsExpectedLobUsagePattern { get; }
    public bool SupportsUnboundedLobLocatorMaterialization { get; }
    public bool SupportsExistsInSelect { get; }
    public string SelectGUIDString { get; }
    public bool IsCurrentTimestampSelectStringCallable { get; }
    public string CurrentTimestampSelectString { get; }
    public string CurrentUtcTimestampSelectString { get; }
    public string CurrentUtcTimestampSQLFunctionName { get; }
    public int MaxAliasLength { get; }
    public string AddColumnString { get; }
    public string AddColumnSuffixString { get; }
    private static HanaDialectBase();
    protected virtual void RegisterKeywords();
    protected virtual void RegisterFunctions();
    protected virtual void RegisterNHibernateFunctions();
    protected virtual void RegisterHANAFunctions();
    public virtual bool get_DropConstraints();
    public virtual bool get_QualifyIndexName();
    public virtual bool get_SupportsCommentOn();
    public virtual string GetTableComment(string comment);
    public virtual string GetColumnComment(string comment);
    public virtual bool get_SupportsColumnCheck();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual bool get_UsesColumnsWithForUpdateOf();
    public virtual string GetForUpdateString(string aliases);
    public virtual string get_ForUpdateNowaitString();
    public virtual string GetForUpdateNowaitString(string aliases);
    public virtual bool get_SupportsTemporaryTables();
    public virtual string GenerateTemporaryTableName(string baseTableName);
    public virtual Nullable`1<bool> PerformTemporaryTableDDLInIsolation();
    public virtual int RegisterResultSetOutParameter(DbCommand statement, int position);
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual bool get_SupportsCurrentUtcTimestampSelection();
    public virtual long get_TimestampResolutionInTicks();
    public virtual string get_CascadeConstraintsString();
    public virtual bool get_SupportsIdentityColumns();
    public virtual string GetIdentitySelectString(string identityColumn, string tableName, DbType type);
    public virtual string get_IdentitySelectString();
    public virtual string get_IdentityColumnString();
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsPooledSequences();
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string GetCreateSequenceString(string sequenceName);
    protected virtual string GetCreateSequenceString(string sequenceName, int initialValue, int incrementSize);
    public virtual string get_QuerySequencesString();
    public virtual string ToBooleanValueString(bool value);
    public virtual bool get_SupportsLimit();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual string GetSelectClauseNullString(SqlType sqlType);
    public virtual bool get_SupportsUnionAll();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_SupportsRowValueConstructorSyntax();
    public virtual bool get_SupportsRowValueConstructorSyntaxInInList();
    public virtual bool get_SupportsExpectedLobUsagePattern();
    public virtual bool get_SupportsUnboundedLobLocatorMaterialization();
    public virtual bool get_SupportsExistsInSelect();
    public virtual string get_SelectGUIDString();
    public virtual bool get_IsCurrentTimestampSelectStringCallable();
    public virtual string get_CurrentTimestampSelectString();
    public virtual string get_CurrentUtcTimestampSelectString();
    public virtual string get_CurrentUtcTimestampSQLFunctionName();
    public virtual int get_MaxAliasLength();
    public virtual string get_AddColumnString();
    public virtual string get_AddColumnSuffixString();
}
public class NHibernate.Dialect.HanaRowStoreDialect : HanaDialectBase {
    public string CreateTableString { get; }
    public string CreateTemporaryTableString { get; }
    public bool SupportsOuterJoinForUpdate { get; }
    public bool SupportsDistributedTransactions { get; }
    public virtual string get_CreateTableString();
    public virtual string get_CreateTemporaryTableString();
    public virtual bool get_SupportsOuterJoinForUpdate();
    public virtual bool get_SupportsDistributedTransactions();
}
public class NHibernate.Dialect.IfxViolatedConstraintExtracter : TemplatedViolatedConstraintNameExtracter {
    public virtual string ExtractConstraintName(DbException sqle);
}
public class NHibernate.Dialect.InformixDialect : Dialect {
    public string IdentityInsertString { get; }
    public string CreateTemporaryTableString { get; }
    public string CreateTemporaryTablePostfix { get; }
    public bool IsCurrentTimestampSelectStringCallable { get; }
    public string CurrentTimestampSelectString { get; }
    public string CurrentTimestampSQLFunctionName { get; }
    public IViolatedConstraintNameExtracter ViolatedConstraintNameExtracter { get; }
    public string AddColumnString { get; }
    [ObsoleteAttribute("Use UsesColumnsWithForUpdateOf instead")]
public bool ForUpdateOfColumns { get; }
    public bool SupportsOuterJoinForUpdate { get; }
    public bool SupportsTemporaryTables { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public long TimestampResolutionInTicks { get; }
    public bool SupportsIdentityColumns { get; }
    public bool HasDataTypeInIdentityColumn { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public bool SupportsSequences { get; }
    public bool SupportsCrossJoin { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool SupportsVariableLimit { get; }
    public bool SupportsUnionAll { get; }
    public bool SupportsEmptyInList { get; }
    public bool SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor { get; }
    public bool DoesRepeatableReadCauseReadersToBlockWriters { get; }
    public int MaxAliasLength { get; }
    public virtual Task`1<DbDataReader> GetResultSetAsync(DbCommand statement, CancellationToken cancellationToken);
    public virtual string get_IdentityInsertString();
    public virtual string get_CreateTemporaryTableString();
    public virtual string get_CreateTemporaryTablePostfix();
    public virtual bool get_IsCurrentTimestampSelectStringCallable();
    public virtual string get_CurrentTimestampSelectString();
    public virtual string get_CurrentTimestampSQLFunctionName();
    public virtual IViolatedConstraintNameExtracter get_ViolatedConstraintNameExtracter();
    public virtual string get_AddColumnString();
    public virtual bool get_ForUpdateOfColumns();
    public virtual bool get_SupportsOuterJoinForUpdate();
    public virtual string GetForUpdateString(string aliases);
    public virtual bool get_SupportsTemporaryTables();
    public virtual Nullable`1<bool> PerformTemporaryTableDDLInIsolation();
    public virtual int RegisterResultSetOutParameter(DbCommand statement, int position);
    public virtual DbDataReader GetResultSet(DbCommand statement);
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual long get_TimestampResolutionInTicks();
    public virtual bool get_SupportsIdentityColumns();
    public virtual bool get_HasDataTypeInIdentityColumn();
    public virtual string GetIdentitySelectString(string identityColumn, string tableName, DbType type);
    public virtual string get_IdentitySelectString();
    public virtual string GetIdentityColumnString(DbType type);
    public virtual string get_IdentityColumnString();
    public virtual bool get_SupportsSequences();
    public virtual JoinFragment CreateOuterJoinFragment();
    public virtual bool get_SupportsCrossJoin();
    public virtual string ToBooleanValueString(bool value);
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual bool get_SupportsVariableLimit();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual bool get_SupportsUnionAll();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor();
    public virtual bool get_DoesRepeatableReadCauseReadersToBlockWriters();
    public virtual ISQLExceptionConverter BuildSQLExceptionConverter();
    private static int GetAfterSelectInsertPoint(SqlString text);
    public virtual string GetAddForeignKeyConstraintString(string constraintName, String[] foreignKey, string referencedTable, String[] primaryKey, bool referencesPrimaryKey);
    public virtual int get_MaxAliasLength();
}
public class NHibernate.Dialect.InformixDialect0940 : InformixDialect {
    public string QuerySequencesString { get; }
    public bool SupportsSequences { get; }
    public bool SupportsPooledSequences { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public int MaxAliasLength { get; }
    public virtual string get_QuerySequencesString();
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsPooledSequences();
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string GetCreateSequenceString(string sequenceName);
    public virtual JoinFragment CreateOuterJoinFragment();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual int get_MaxAliasLength();
}
public class NHibernate.Dialect.InformixDialect1000 : InformixDialect0940 {
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
}
public class NHibernate.Dialect.Ingres9Dialect : IngresDialect {
    public bool SupportsLimit { get; }
    public bool SupportsVariableLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool SupportsSequences { get; }
    public bool SupportsPooledSequences { get; }
    public string QuerySequencesString { get; }
    public Type IdentityStyleIdentifierGeneratorClass { get; }
    public Type NativeIdentifierGeneratorClass { get; }
    public bool DoesRepeatableReadCauseReadersToBlockWriters { get; }
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsVariableLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsPooledSequences();
    public virtual string get_QuerySequencesString();
    public virtual Type get_IdentityStyleIdentifierGeneratorClass();
    public virtual Type get_NativeIdentifierGeneratorClass();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string GetCreateSequenceString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual bool get_DoesRepeatableReadCauseReadersToBlockWriters();
}
public class NHibernate.Dialect.IngresDialect : Dialect {
    public int MaxAliasLength { get; }
    protected bool UseNPrefixForUnicodeStrings { get; }
    public bool SupportsEmptyInList { get; }
    public bool SupportsSubselectAsInPredicateLHS { get; }
    public bool SupportsExpectedLobUsagePattern { get; }
    public bool DoesReadCommittedCauseWritersToBlockReaders { get; }
    public virtual int get_MaxAliasLength();
    protected virtual bool get_UseNPrefixForUnicodeStrings();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_SupportsSubselectAsInPredicateLHS();
    public virtual bool get_SupportsExpectedLobUsagePattern();
    public virtual bool get_DoesReadCommittedCauseWritersToBlockReaders();
}
public enum NHibernate.Dialect.InsertGeneratedIdentifierRetrievalMethod : Enum {
    public int value__;
    public static InsertGeneratedIdentifierRetrievalMethod OutputParameter;
    public static InsertGeneratedIdentifierRetrievalMethod ReturnValueParameter;
}
public interface NHibernate.Dialect.Lock.ILockingStrategy {
    public abstract virtual Task LockAsync(object id, object version, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual void Lock(object id, object version, object obj, ISessionImplementor session);
}
public class NHibernate.Dialect.Lock.SelectLockingStrategy : object {
    private ILockable lockable;
    private LockMode lockMode;
    private SqlString sql;
    public SelectLockingStrategy(ILockable lockable, LockMode lockMode);
    [AsyncStateMachineAttribute("NHibernate.Dialect.Lock.SelectLockingStrategy/<LockAsync>d__0")]
public sealed virtual Task LockAsync(object id, object version, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    private SqlString GenerateLockString();
    public sealed virtual void Lock(object id, object version, object obj, ISessionImplementor session);
}
public class NHibernate.Dialect.Lock.UpdateLockingStrategy : object {
    private static INHibernateLogger log;
    private ILockable lockable;
    private LockMode lockMode;
    private SqlString sql;
    public UpdateLockingStrategy(ILockable lockable, LockMode lockMode);
    private static UpdateLockingStrategy();
    public sealed virtual Task LockAsync(object id, object version, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    private SqlString GenerateLockString();
    public sealed virtual void Lock(object id, object version, object obj, ISessionImplementor session);
}
public class NHibernate.Dialect.MsSql2000Dialect : Dialect {
    public static int MaxSizeForAnsiClob;
    public static int MaxSizeForClob;
    public static int MaxSizeForBlob;
    public static int MaxSizeForLengthLimitedAnsiString;
    public static int MaxSizeForLengthLimitedString;
    public static int MaxSizeForLengthLimitedBinary;
    public static byte MaxDateTime2;
    public static byte MaxDateTimeOffset;
    private static String[] DialectKeywords;
    public string AddColumnString { get; }
    public string NullColumnString { get; }
    public string CurrentTimestampSQLFunctionName { get; }
    public string CurrentTimestampSelectString { get; }
    public bool IsCurrentTimestampSelectStringCallable { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public string CurrentUtcTimestampSQLFunctionName { get; }
    public string CurrentUtcTimestampSelectString { get; }
    public bool SupportsCurrentUtcTimestampSelection { get; }
    public bool QualifyIndexName { get; }
    public string SelectGUIDString { get; }
    public string ForUpdateString { get; }
    public bool SupportsInsertSelectIdentity { get; }
    public bool SupportsIdentityColumns { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public string NoColumnsInsertString { get; }
    public char CloseQuote { get; }
    public char OpenQuote { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool SupportsVariableLimit { get; }
    public bool UseMaxForLimit { get; }
    public bool SupportsTemporaryTables { get; }
    public long TimestampResolutionInTicks { get; }
    public bool SupportsCircularCascadeDeleteConstraints { get; }
    public bool SupportsUnionAll { get; }
    public bool SupportsSqlBatches { get; }
    public int MaxAliasLength { get; }
    public Nullable`1<int> MaxNumberOfParameters { get; }
    protected bool UseNPrefixForUnicodeStrings { get; }
    public bool SupportsEmptyInList { get; }
    public bool AreStringComparisonsCaseInsensitive { get; }
    public bool SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor { get; }
    public bool SupportsLobValueChangePropogation { get; }
    public bool DoesReadCommittedCauseWritersToBlockReaders { get; }
    public bool DoesRepeatableReadCauseReadersToBlockWriters { get; }
    private static MsSql2000Dialect();
    protected virtual void RegisterDefaultProperties();
    protected virtual void RegisterKeywords();
    protected virtual void RegisterFunctions();
    protected virtual void RegisterGuidTypeMapping();
    protected virtual void RegisterLargeObjectTypeMappings();
    protected virtual void RegisterDateTimeTypeMappings();
    protected virtual void RegisterNumericTypeMappings();
    protected virtual void RegisterCharacterTypeMappings();
    public virtual string get_AddColumnString();
    public virtual string get_NullColumnString();
    public virtual string get_CurrentTimestampSQLFunctionName();
    public virtual string get_CurrentTimestampSelectString();
    public virtual bool get_IsCurrentTimestampSelectStringCallable();
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual string get_CurrentUtcTimestampSQLFunctionName();
    public virtual string get_CurrentUtcTimestampSelectString();
    public virtual bool get_SupportsCurrentUtcTimestampSelection();
    public virtual bool get_QualifyIndexName();
    public virtual string get_SelectGUIDString();
    public virtual string GetDropTableString(string tableName);
    public virtual string get_ForUpdateString();
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertSql);
    public virtual bool get_SupportsInsertSelectIdentity();
    public virtual bool get_SupportsIdentityColumns();
    public virtual string get_IdentitySelectString();
    public virtual string get_IdentityColumnString();
    public virtual string get_NoColumnsInsertString();
    public virtual char get_CloseQuote();
    public virtual char get_OpenQuote();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual bool get_SupportsVariableLimit();
    public virtual SqlString GetLimitString(SqlString querySqlString, SqlString offset, SqlString limit);
    public virtual bool get_UseMaxForLimit();
    public virtual bool get_SupportsTemporaryTables();
    public virtual string GenerateTemporaryTableName(string baseTableName);
    public virtual bool DropTemporaryTableAfterUse();
    public virtual string Qualify(string catalog, string schema, string name);
    protected virtual string Quote(string name);
    public virtual string UnQuote(string quoted);
    protected bool NeedsLockHint(LockMode lockMode);
    public virtual string AppendLockHint(LockMode lockMode, string tableName);
    public virtual SqlString ApplyLocksToSql(SqlString sql, IDictionary`2<string, LockMode> aliasedLockModes, IDictionary`2<string, String[]> keyColumnNames);
    public virtual long get_TimestampResolutionInTicks();
    public virtual string GetIfExistsDropConstraint(string catalog, string schema, string tableName, string name);
    public virtual string GetIfNotExistsCreateConstraint(string catalog, string schema, string table, string name);
    [ObsoleteAttribute("Please use overload with catalog and schema parameters")]
protected virtual string GetSelectExistingObject(string name, Table table);
    protected virtual string GetSelectExistingObject(string catalog, string schema, string table, string name);
    public virtual bool get_SupportsCircularCascadeDeleteConstraints();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual bool get_SupportsUnionAll();
    public virtual bool get_SupportsSqlBatches();
    public virtual int get_MaxAliasLength();
    public virtual Nullable`1<int> get_MaxNumberOfParameters();
    protected virtual bool get_UseNPrefixForUnicodeStrings();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_AreStringComparisonsCaseInsensitive();
    public virtual bool get_SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor();
    public virtual bool get_SupportsLobValueChangePropogation();
    public virtual bool get_DoesReadCommittedCauseWritersToBlockReaders();
    public virtual bool get_DoesRepeatableReadCauseReadersToBlockWriters();
    public virtual bool IsKnownToken(string currentToken, string nextToken);
}
public class NHibernate.Dialect.MsSql2005Dialect : MsSql2000Dialect {
    public static int MaxSizeForXml;
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool SupportsVariableLimit { get; }
    public bool UseMaxForLimit { get; }
    public int MaxAliasLength { get; }
    public bool DoesReadCommittedCauseWritersToBlockReaders { get; }
    public bool DoesRepeatableReadCauseReadersToBlockWriters { get; }
    protected virtual void RegisterCharacterTypeMappings();
    protected virtual void RegisterLargeObjectTypeMappings();
    protected virtual void RegisterKeywords();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual bool get_SupportsVariableLimit();
    protected virtual string GetSelectExistingObject(string catalog, string schema, string table, string name);
    public virtual bool get_UseMaxForLimit();
    public virtual string AppendLockHint(LockMode lockMode, string tableName);
    public virtual int get_MaxAliasLength();
    public virtual bool get_DoesReadCommittedCauseWritersToBlockReaders();
    public virtual bool get_DoesRepeatableReadCauseReadersToBlockWriters();
}
internal class NHibernate.Dialect.MsSql2005DialectQueryPager : object {
    private SqlString _sourceQuery;
    public MsSql2005DialectQueryPager(SqlString sourceQuery);
    public SqlString PageBy(SqlString offset, SqlString limit);
    private SqlString PageByLimitOnly(SqlString limit);
    private SqlString PageByLimitAndOffset(SqlString offset, SqlString limit);
    private static void BuildSelectClauseForPagingQuery(MsSqlSelectParser sqlQuery, SqlString limit, SqlStringBuilder result);
    private static void BuildFromClauseForPagingQuery(MsSqlSelectParser sqlQuery, SqlStringBuilder result);
    private static void BuildFromClauseForPagingDistinctQuery(MsSqlSelectParser sqlQuery, SqlStringBuilder result);
    private static void BuildWhereAndOrderClausesForPagingQuery(SqlString offset, SqlStringBuilder result);
}
public class NHibernate.Dialect.MsSql2008Dialect : MsSql2005Dialect {
    [CompilerGeneratedAttribute]
private bool <KeepDateTime>k__BackingField;
    protected bool KeepDateTime { get; private set; }
    public string CurrentTimestampSQLFunctionName { get; }
    public string CurrentUtcTimestampSQLFunctionName { get; }
    public long TimestampResolutionInTicks { get; }
    public bool SupportsDateTimeScale { get; }
    [CompilerGeneratedAttribute]
protected bool get_KeepDateTime();
    [CompilerGeneratedAttribute]
private void set_KeepDateTime(bool value);
    public virtual void Configure(IDictionary`2<string, string> settings);
    protected virtual void RegisterDateTimeTypeMappings();
    protected virtual void RegisterFunctions();
    protected virtual void RegisterKeywords();
    protected virtual void RegisterDefaultProperties();
    public virtual string get_CurrentTimestampSQLFunctionName();
    public virtual string get_CurrentUtcTimestampSQLFunctionName();
    public virtual long get_TimestampResolutionInTicks();
    public virtual SqlType OverrideSqlType(SqlType type);
    public virtual bool get_SupportsDateTimeScale();
}
public class NHibernate.Dialect.MsSql2012Dialect : MsSql2008Dialect {
    public bool SupportsSequences { get; }
    public bool SupportsPooledSequences { get; }
    public string QuerySequencesString { get; }
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsPooledSequences();
    public virtual string GetCreateSequenceString(string sequenceName);
    protected virtual string GetCreateSequenceString(string sequenceName, int initialValue, int incrementSize);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string get_QuerySequencesString();
    protected virtual void RegisterFunctions();
    public virtual SqlString GetLimitString(SqlString querySqlString, SqlString offset, SqlString limit);
}
public class NHibernate.Dialect.MsSql7Dialect : MsSql2000Dialect {
    public string IdentitySelectString { get; }
    public virtual string get_IdentitySelectString();
}
public class NHibernate.Dialect.MsSqlAzure2008Dialect : MsSql2008Dialect {
    public string PrimaryKeyString { get; }
    public virtual string get_PrimaryKeyString();
}
public class NHibernate.Dialect.MsSqlCe40Dialect : MsSqlCeDialect {
    public bool SupportsLimitOffset { get; }
    public bool SupportsVariableLimit { get; }
    public virtual bool get_SupportsLimitOffset();
    public virtual bool get_SupportsVariableLimit();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
}
public class NHibernate.Dialect.MsSqlCeDialect : Dialect {
    private static String[] DialectKeywords;
    public string AddColumnString { get; }
    public string NullColumnString { get; }
    public bool QualifyIndexName { get; }
    public string ForUpdateString { get; }
    public bool SupportsIdentityColumns { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public string SelectGUIDString { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public Type NativeIdentifierGeneratorClass { get; }
    public bool SupportsCircularCascadeDeleteConstraints { get; }
    public bool SupportsConcurrentWritingConnectionsInSameTransaction { get; }
    public long TimestampResolutionInTicks { get; }
    public int MaxAliasLength { get; }
    public bool SupportsPoolingParameter { get; }
    public bool SupportsScalarSubSelects { get; }
    public bool SupportsDistributedTransactions { get; }
    private static MsSqlCeDialect();
    protected virtual void RegisterKeywords();
    protected virtual void RegisterTypeMapping();
    protected virtual void RegisterFunctions();
    protected virtual void RegisterDefaultProperties();
    public virtual string get_AddColumnString();
    public virtual string get_NullColumnString();
    public virtual bool get_QualifyIndexName();
    public virtual string get_ForUpdateString();
    public virtual bool get_SupportsIdentityColumns();
    public virtual string get_IdentitySelectString();
    public virtual string get_IdentityColumnString();
    public virtual string get_SelectGUIDString();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual Type get_NativeIdentifierGeneratorClass();
    public virtual bool get_SupportsCircularCascadeDeleteConstraints();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual SqlString GetLimitString(SqlString querySqlString, SqlString offset, SqlString limit);
    public virtual string Qualify(string catalog, string schema, string table);
    private static int GetAfterSelectInsertPoint(SqlString sql);
    public virtual bool get_SupportsConcurrentWritingConnectionsInSameTransaction();
    public virtual long get_TimestampResolutionInTicks();
    public virtual int get_MaxAliasLength();
    public virtual bool get_SupportsPoolingParameter();
    public virtual bool get_SupportsScalarSubSelects();
    public virtual bool get_SupportsDistributedTransactions();
}
public class NHibernate.Dialect.MySQL55Dialect : MySQL5Dialect {
    protected virtual void RegisterFunctions();
}
public class NHibernate.Dialect.MySQL55InnoDBDialect : MySQL55Dialect {
    public bool SupportsCascadeDelete { get; }
    public string TableTypeString { get; }
    public bool HasSelfReferentialForeignKeyBug { get; }
    public virtual bool get_SupportsCascadeDelete();
    public virtual string get_TableTypeString();
    public virtual bool get_HasSelfReferentialForeignKeyBug();
}
public class NHibernate.Dialect.MySQL57Dialect : MySQL55Dialect {
    public long TimestampResolutionInTicks { get; }
    public bool SupportsDateTimeScale { get; }
    public bool SupportsRowValueConstructorSyntaxInInList { get; }
    public virtual long get_TimestampResolutionInTicks();
    public virtual bool get_SupportsDateTimeScale();
    public virtual bool get_SupportsRowValueConstructorSyntaxInInList();
}
public class NHibernate.Dialect.MySQL5Dialect : MySQLDialect {
    public bool SupportsSubSelects { get; }
    public string SelectGUIDString { get; }
    public bool SupportsInsertSelectIdentity { get; }
    public int MaxAliasLength { get; }
    protected virtual void RegisterFunctions();
    protected virtual void RegisterCastTypes();
    public virtual bool get_SupportsSubSelects();
    public virtual string get_SelectGUIDString();
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertString);
    public virtual bool get_SupportsInsertSelectIdentity();
    public virtual int get_MaxAliasLength();
}
public class NHibernate.Dialect.MySQL5InnoDBDialect : MySQL5Dialect {
    public bool SupportsCascadeDelete { get; }
    public string TableTypeString { get; }
    public bool HasSelfReferentialForeignKeyBug { get; }
    public virtual bool get_SupportsCascadeDelete();
    public virtual string get_TableTypeString();
    public virtual bool get_HasSelfReferentialForeignKeyBug();
}
public class NHibernate.Dialect.MySQL8Dialect : MySQL57Dialect {
}
public class NHibernate.Dialect.MySQL8InnoDBDialect : MySQL8Dialect {
    public bool SupportsCascadeDelete { get; }
    public string TableTypeString { get; }
    public bool HasSelfReferentialForeignKeyBug { get; }
    public virtual bool get_SupportsCascadeDelete();
    public virtual string get_TableTypeString();
    public virtual bool get_HasSelfReferentialForeignKeyBug();
}
public class NHibernate.Dialect.MySQLDialect : Dialect {
    private TypeNames castTypeNames;
    private static String[] DialectKeywords;
    [CompilerGeneratedAttribute]
private bool <EscapeBackslashInStrings>k__BackingField;
    public string AddColumnString { get; }
    public bool QualifyIndexName { get; }
    public bool SupportsIdentityColumns { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public char CloseQuote { get; }
    public char OpenQuote { get; }
    public bool SupportsIfExistsBeforeTableName { get; }
    public bool SupportsLimit { get; }
    public bool SupportsSubSelects { get; }
    public bool SupportsTemporaryTables { get; }
    public string CreateTemporaryTableString { get; }
    public long TimestampResolutionInTicks { get; }
    public bool SupportsConcurrentWritingConnectionsInSameTransaction { get; }
    protected bool EscapeBackslashInStrings { get; protected set; }
    protected bool UseNPrefixForUnicodeStrings { get; }
    public bool SupportsEmptyInList { get; }
    public bool AreStringComparisonsCaseInsensitive { get; }
    public bool SupportsLobValueChangePropogation { get; }
    public bool SupportsSubqueryOnMutatingTable { get; }
    public bool SupportsSubSelectsWithPagingAsInPredicateRhs { get; }
    public bool SupportsHavingOnGroupedByComputation { get; }
    public bool SupportsDistributedTransactions { get; }
    private static MySQLDialect();
    protected virtual void RegisterKeywords();
    protected virtual void RegisterFunctions();
    public virtual string get_AddColumnString();
    public virtual bool get_QualifyIndexName();
    public virtual bool get_SupportsIdentityColumns();
    public virtual string get_IdentitySelectString();
    public virtual string get_IdentityColumnString();
    public virtual char get_CloseQuote();
    public virtual char get_OpenQuote();
    public virtual bool get_SupportsIfExistsBeforeTableName();
    public virtual bool get_SupportsLimit();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual bool get_SupportsSubSelects();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual string GetAddForeignKeyConstraintString(string constraintName, String[] foreignKey, string referencedTable, String[] primaryKey, bool referencesPrimaryKey);
    public virtual string GetDropForeignKeyConstraintString(string constraintName);
    public virtual string GetDropPrimaryKeyConstraintString(string constraintName);
    public virtual string GetDropIndexConstraintString(string constraintName);
    public virtual bool get_SupportsTemporaryTables();
    public virtual string get_CreateTemporaryTableString();
    protected virtual void RegisterCastTypes();
    protected void RegisterCastType(DbType code, string name);
    protected void RegisterCastType(DbType code, int capacity, string name);
    public virtual string GetCastTypeName(SqlType sqlType);
    public virtual bool TryGetCastTypeName(SqlType sqlType, String& typeName);
    public virtual long get_TimestampResolutionInTicks();
    public virtual bool get_SupportsConcurrentWritingConnectionsInSameTransaction();
    [CompilerGeneratedAttribute]
protected virtual bool get_EscapeBackslashInStrings();
    [CompilerGeneratedAttribute]
protected virtual void set_EscapeBackslashInStrings(bool value);
    protected virtual bool get_UseNPrefixForUnicodeStrings();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_AreStringComparisonsCaseInsensitive();
    public virtual bool get_SupportsLobValueChangePropogation();
    public virtual bool get_SupportsSubqueryOnMutatingTable();
    public virtual bool get_SupportsSubSelectsWithPagingAsInPredicateRhs();
    public virtual bool get_SupportsHavingOnGroupedByComputation();
    public virtual bool get_SupportsDistributedTransactions();
}
public class NHibernate.Dialect.Oracle10gDialect : Oracle9iDialect {
    private bool _useBinaryFloatingPointTypes;
    public bool SupportsCrossJoin { get; }
    public virtual JoinFragment CreateOuterJoinFragment();
    public virtual void Configure(IDictionary`2<string, string> settings);
    protected virtual void RegisterFloatingPointTypeMappings();
    protected virtual void RegisterFunctions();
    public virtual bool get_SupportsCrossJoin();
}
public class NHibernate.Dialect.Oracle12cDialect : Oracle10gDialect {
    public bool UseMaxForLimit { get; }
    public virtual bool get_UseMaxForLimit();
    public virtual SqlString GetLimitString(SqlString querySqlString, SqlString offset, SqlString limit);
}
public class NHibernate.Dialect.Oracle8iDialect : Dialect {
    [CompilerGeneratedAttribute]
private bool <UseNPrefixedTypesForUnicode>k__BackingField;
    private static String[] DialectKeywords;
    public string CurrentTimestampSelectString { get; }
    public string CurrentTimestampSQLFunctionName { get; }
    public string AddColumnString { get; }
    public string CascadeConstraintsString { get; }
    public string QuerySequencesString { get; }
    public string SelectGUIDString { get; }
    public string CreateTemporaryTableString { get; }
    public string CreateTemporaryTablePostfix { get; }
    public bool IsCurrentTimestampSelectStringCallable { get; }
    public bool UseNPrefixedTypesForUnicode { get; private set; }
    public bool SupportsCrossJoin { get; }
    public bool DropConstraints { get; }
    public string ForUpdateNowaitString { get; }
    public bool SupportsSequences { get; }
    public bool SupportsPooledSequences { get; }
    public bool SupportsLimit { get; }
    public bool UseMaxForLimit { get; }
    [ObsoleteAttribute("Use UsesColumnsWithForUpdateOf instead")]
public bool ForUpdateOfColumns { get; }
    public bool SupportsUnionAll { get; }
    public bool SupportsCommentOn { get; }
    public bool SupportsTemporaryTables { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public long TimestampResolutionInTicks { get; }
    public int MaxAliasLength { get; }
    protected bool UseNPrefixForUnicodeStrings { get; }
    public bool SupportsEmptyInList { get; }
    public bool SupportsExistsInSelect { get; }
    private static Oracle8iDialect();
    public virtual string get_CurrentTimestampSelectString();
    public virtual string get_CurrentTimestampSQLFunctionName();
    public virtual string get_AddColumnString();
    public virtual string get_CascadeConstraintsString();
    public virtual string get_QuerySequencesString();
    public virtual string get_SelectGUIDString();
    public virtual string get_CreateTemporaryTableString();
    public virtual string get_CreateTemporaryTablePostfix();
    public virtual bool get_IsCurrentTimestampSelectStringCallable();
    [CompilerGeneratedAttribute]
public bool get_UseNPrefixedTypesForUnicode();
    [CompilerGeneratedAttribute]
private void set_UseNPrefixedTypesForUnicode(bool value);
    public virtual void Configure(IDictionary`2<string, string> settings);
    protected virtual void RegisterKeywords();
    protected virtual void RegisterGuidTypeMapping();
    protected virtual void RegisterCharacterTypeMappings();
    protected virtual void RegisterNumericTypeMappings();
    protected virtual void RegisterFloatingPointTypeMappings();
    protected virtual void RegisterDateTimeTypeMappings();
    protected virtual void RegisterLargeObjectTypeMappings();
    protected virtual void RegisterReverseHibernateTypeMappings();
    protected virtual void RegisterFunctions();
    protected internal virtual void RegisterDefaultProperties();
    public virtual JoinFragment CreateOuterJoinFragment();
    public virtual bool get_SupportsCrossJoin();
    public virtual CaseFragment CreateCaseFragment();
    public virtual SqlString GetLimitString(SqlString sql, SqlString offset, SqlString limit);
    private static string ExtractColumnOrAliasNames(SqlString select);
    public virtual string GetBasicSelectClauseNullString(SqlType sqlType);
    public virtual string GetSelectClauseNullString(SqlType sqlType);
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual SqlString AddIdentifierOutParameterToInsert(SqlString insertString, string identifierColumnName, string parameterName);
    public virtual string GetCreateSequenceString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual bool get_DropConstraints();
    public virtual string get_ForUpdateNowaitString();
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsPooledSequences();
    public virtual bool get_SupportsLimit();
    public virtual string GetForUpdateString(string aliases);
    public virtual string GetForUpdateNowaitString(string aliases);
    public virtual bool get_UseMaxForLimit();
    public virtual bool get_ForUpdateOfColumns();
    public virtual bool get_SupportsUnionAll();
    public virtual bool get_SupportsCommentOn();
    public virtual bool get_SupportsTemporaryTables();
    public virtual string GenerateTemporaryTableName(string baseTableName);
    public virtual bool DropTemporaryTableAfterUse();
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual long get_TimestampResolutionInTicks();
    public virtual int get_MaxAliasLength();
    protected virtual bool get_UseNPrefixForUnicodeStrings();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_SupportsExistsInSelect();
}
public class NHibernate.Dialect.Oracle9iDialect : Oracle8iDialect {
    public string CurrentTimestampSelectString { get; }
    public string CurrentTimestampSQLFunctionName { get; }
    public string CurrentUtcTimestampSQLFunctionName { get; }
    public string CurrentUtcTimestampSelectString { get; }
    public bool SupportsCurrentUtcTimestampSelection { get; }
    public long TimestampResolutionInTicks { get; }
    public bool SupportsDateTimeScale { get; }
    public bool SupportsRowValueConstructorSyntaxInInList { get; }
    public virtual string get_CurrentTimestampSelectString();
    public virtual string get_CurrentTimestampSQLFunctionName();
    public virtual string get_CurrentUtcTimestampSQLFunctionName();
    public virtual string get_CurrentUtcTimestampSelectString();
    public virtual bool get_SupportsCurrentUtcTimestampSelection();
    protected virtual void RegisterDateTimeTypeMappings();
    protected virtual void RegisterFunctions();
    public virtual long get_TimestampResolutionInTicks();
    public virtual string GetSelectClauseNullString(SqlType sqlType);
    public virtual CaseFragment CreateCaseFragment();
    public virtual bool get_SupportsDateTimeScale();
    public virtual bool get_SupportsRowValueConstructorSyntaxInInList();
}
public class NHibernate.Dialect.OracleLiteDialect : Oracle9iDialect {
    public virtual string GetCreateSequenceString(string sequenceName);
    protected virtual string GetCreateSequenceString(string sequenceName, int initialValue, int incrementSize);
}
public class NHibernate.Dialect.PostgreSQL81Dialect : PostgreSQLDialect {
    public string ForUpdateNowaitString { get; }
    public bool SupportsIdentityColumns { get; }
    public bool HasDataTypeInIdentityColumn { get; }
    public string NoColumnsInsertString { get; }
    public string IdentitySelectString { get; }
    public bool SupportsInsertSelectIdentity { get; }
    public bool SupportsDateTimeScale { get; }
    public int MaxAliasLength { get; }
    protected virtual void RegisterDateTimeTypeMappings();
    public virtual string get_ForUpdateNowaitString();
    public virtual string GetForUpdateNowaitString(string aliases);
    public virtual bool get_SupportsIdentityColumns();
    public virtual bool get_HasDataTypeInIdentityColumn();
    public virtual string GetIdentityColumnString(DbType type);
    public virtual string get_NoColumnsInsertString();
    public virtual string get_IdentitySelectString();
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertSql);
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertString, string identifierColumnName);
    public virtual bool get_SupportsInsertSelectIdentity();
    public virtual bool get_SupportsDateTimeScale();
    public virtual int get_MaxAliasLength();
}
public class NHibernate.Dialect.PostgreSQL82Dialect : PostgreSQL81Dialect {
    public bool SupportsIfExistsBeforeTableName { get; }
    public bool SupportsRowValueConstructorSyntaxInInList { get; }
    public virtual bool get_SupportsIfExistsBeforeTableName();
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual bool get_SupportsRowValueConstructorSyntaxInInList();
}
public class NHibernate.Dialect.PostgreSQL83Dialect : PostgreSQL82Dialect {
}
public class NHibernate.Dialect.PostgreSQLDialect : Dialect {
    private static String[] DialectKeywords;
    public string AddColumnString { get; }
    public bool DropConstraints { get; }
    public string CascadeConstraintsString { get; }
    public InsertGeneratedIdentifierRetrievalMethod InsertGeneratedIdentifierRetrievalMethod { get; }
    public bool SupportsSequences { get; }
    public bool SupportsPooledSequences { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool SupportsForUpdateOf { get; }
    public bool SupportsOuterJoinForUpdate { get; }
    public bool SupportsUnionAll { get; }
    public bool SupportsTemporaryTables { get; }
    public string CreateTemporaryTableString { get; }
    public string CreateTemporaryTablePostfix { get; }
    public string SelectGUIDString { get; }
    public long TimestampResolutionInTicks { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public string CurrentTimestampSelectString { get; }
    public bool SupportsEmptyInList { get; }
    public bool UseInputStreamToInsertBlob { get; }
    public bool SupportsLobValueChangePropogation { get; }
    public bool SupportsUnboundedLobLocatorMaterialization { get; }
    public string QuerySequencesString { get; }
    public bool SupportsDistributedTransactions { get; }
    private static PostgreSQLDialect();
    protected virtual void RegisterDateTimeTypeMappings();
    protected virtual void RegisterKeywords();
    public virtual string get_AddColumnString();
    public virtual bool get_DropConstraints();
    public virtual string get_CascadeConstraintsString();
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string GetCreateSequenceString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
    public virtual SqlString AddIdentifierOutParameterToInsert(SqlString insertString, string identifierColumnName, string parameterName);
    public virtual InsertGeneratedIdentifierRetrievalMethod get_InsertGeneratedIdentifierRetrievalMethod();
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsPooledSequences();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual bool get_SupportsForUpdateOf();
    public virtual bool get_SupportsOuterJoinForUpdate();
    public virtual string GetForUpdateString(string aliases);
    public virtual bool get_SupportsUnionAll();
    public virtual string GetSelectClauseNullString(SqlType sqlType);
    public virtual bool get_SupportsTemporaryTables();
    public virtual string get_CreateTemporaryTableString();
    public virtual string get_CreateTemporaryTablePostfix();
    public virtual string ToBooleanValueString(bool value);
    public virtual string get_SelectGUIDString();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual long get_TimestampResolutionInTicks();
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual string get_CurrentTimestampSelectString();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_UseInputStreamToInsertBlob();
    public virtual bool get_SupportsLobValueChangePropogation();
    public virtual bool get_SupportsUnboundedLobLocatorMaterialization();
    public virtual string get_QuerySequencesString();
    public virtual bool get_SupportsDistributedTransactions();
}
public class NHibernate.Dialect.SapSQLAnywhere17Dialect : SybaseSQLAnywhere12Dialect {
    private static String[] DialectKeywords;
    public bool SupportsNullInUnique { get; }
    private static SapSQLAnywhere17Dialect();
    protected virtual void RegisterKeywords();
    protected virtual void RegisterStringFunctions();
    protected virtual void RegisterMathFunctions();
    public virtual void Configure(IDictionary`2<string, string> settings);
    protected virtual void RegisterConfigurationDependentFunctions();
    public virtual bool get_SupportsNullInUnique();
    public virtual SqlString GetLimitString(SqlString sql, SqlString offset, SqlString limit);
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
}
public abstract class NHibernate.Dialect.Schema.AbstractColumnMetaData : object {
    private string name;
    private string typeName;
    private int columnSize;
    private int numericalPrecision;
    private string isNullable;
    public string Name { get; protected set; }
    public string TypeName { get; protected set; }
    public int ColumnSize { get; protected set; }
    public int NumericalPrecision { get; protected set; }
    public string Nullable { get; protected set; }
    public AbstractColumnMetaData(DataRow rs);
    public sealed virtual string get_Name();
    protected void set_Name(string value);
    public sealed virtual string get_TypeName();
    protected void set_TypeName(string value);
    public sealed virtual int get_ColumnSize();
    protected void set_ColumnSize(int value);
    public sealed virtual int get_NumericalPrecision();
    protected void set_NumericalPrecision(int value);
    public sealed virtual string get_Nullable();
    protected void set_Nullable(string value);
    public virtual string ToString();
    protected void SetColumnSize(object columnSizeValue);
    protected void SetNumericalPrecision(object numericalPrecisionValue);
}
public abstract class NHibernate.Dialect.Schema.AbstractDataBaseSchema : object {
    private Dialect _dialect;
    [CompilerGeneratedAttribute]
private DbConnection <Connection>k__BackingField;
    protected DbConnection Connection { get; }
    public bool IncludeDataTypesInReservedWords { get; }
    public bool UseDialectQualifyInsteadOfTableName { get; }
    public bool StoresMixedCaseQuotedIdentifiers { get; }
    public bool StoresUpperCaseQuotedIdentifiers { get; }
    public bool StoresUpperCaseIdentifiers { get; }
    public bool StoresLowerCaseQuotedIdentifiers { get; }
    public bool StoresLowerCaseIdentifiers { get; }
    public string ColumnNameForTableName { get; }
    protected string ForeignKeysSchemaName { get; }
    protected AbstractDataBaseSchema(DbConnection connection);
    protected AbstractDataBaseSchema(DbConnection connection, Dialect dialect);
    [CompilerGeneratedAttribute]
protected DbConnection get_Connection();
    public virtual bool get_IncludeDataTypesInReservedWords();
    public virtual bool get_UseDialectQualifyInsteadOfTableName();
    public virtual bool get_StoresMixedCaseQuotedIdentifiers();
    public virtual bool get_StoresUpperCaseQuotedIdentifiers();
    public virtual bool get_StoresUpperCaseIdentifiers();
    public virtual bool get_StoresLowerCaseQuotedIdentifiers();
    public virtual bool get_StoresLowerCaseIdentifiers();
    public virtual DataTable GetTables(string catalog, string schemaPattern, string tableNamePattern, String[] types);
    public virtual string get_ColumnNameForTableName();
    public abstract virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    public virtual DataTable GetColumns(string catalog, string schemaPattern, string tableNamePattern, string columnNamePattern);
    public virtual DataTable GetIndexInfo(string catalog, string schemaPattern, string tableName);
    public virtual DataTable GetIndexColumns(string catalog, string schemaPattern, string tableName, string indexName);
    public virtual DataTable GetForeignKeys(string catalog, string schema, string table);
    public virtual ISet`1<string> GetReservedWords();
    protected virtual string get_ForeignKeysSchemaName();
    private string GetActualTableName(string catalog, string schemaPattern, string tableNamePattern);
}
public class NHibernate.Dialect.Schema.AbstractForeignKeyMetadata : object {
    private string name;
    private List`1<IColumnMetadata> columns;
    public string Name { get; protected set; }
    public IColumnMetadata[] Columns { get; }
    public AbstractForeignKeyMetadata(DataRow rs);
    public sealed virtual string get_Name();
    protected void set_Name(string value);
    public sealed virtual void AddColumn(IColumnMetadata column);
    public sealed virtual IColumnMetadata[] get_Columns();
    public virtual string ToString();
}
public abstract class NHibernate.Dialect.Schema.AbstractIndexMetadata : object {
    private string name;
    private List`1<IColumnMetadata> columns;
    public string Name { get; protected set; }
    public IColumnMetadata[] Columns { get; }
    public AbstractIndexMetadata(DataRow rs);
    public sealed virtual string get_Name();
    protected void set_Name(string value);
    public sealed virtual void AddColumn(IColumnMetadata column);
    public sealed virtual IColumnMetadata[] get_Columns();
    public virtual string ToString();
}
public abstract class NHibernate.Dialect.Schema.AbstractTableMetadata : object {
    private static INHibernateLogger log;
    private string catalog;
    private string schema;
    private string name;
    private Dictionary`2<string, IColumnMetadata> columns;
    private Dictionary`2<string, IForeignKeyMetadata> foreignKeys;
    private Dictionary`2<string, IIndexMetadata> indexes;
    public string Name { get; protected set; }
    public string Catalog { get; protected set; }
    public string Schema { get; protected set; }
    public AbstractTableMetadata(DataRow rs, IDataBaseSchema meta, bool extras);
    private static AbstractTableMetadata();
    protected abstract virtual void ParseTableInfo(DataRow rs);
    protected abstract virtual string GetConstraintName(DataRow rs);
    protected abstract virtual string GetColumnName(DataRow rs);
    protected abstract virtual string GetIndexName(DataRow rs);
    protected abstract virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected abstract virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected abstract virtual IIndexMetadata GetIndexMetadata(DataRow rs);
    public sealed virtual string get_Name();
    protected void set_Name(string value);
    public sealed virtual string get_Catalog();
    protected void set_Catalog(string value);
    public sealed virtual string get_Schema();
    protected void set_Schema(string value);
    public virtual string ToString();
    public sealed virtual IColumnMetadata GetColumnMetadata(string columnName);
    public sealed virtual IForeignKeyMetadata GetForeignKeyMetadata(string keyName);
    public sealed virtual IIndexMetadata GetIndexMetadata(string indexName);
    public virtual bool NeedPhysicalConstraintCreation(string fkName);
    private void AddForeignKey(DataRow rs, IDataBaseSchema meta);
    private void AddIndex(DataRow rs, IDataBaseSchema meta);
    private void AddColumn(DataRow rs);
    private void InitForeignKeys(IDataBaseSchema meta);
    private void InitIndexes(IDataBaseSchema meta);
    private void InitColumns(IDataBaseSchema meta);
}
public class NHibernate.Dialect.Schema.DB2ColumnMetaData : AbstractColumnMetaData {
    public DB2ColumnMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.DB2ForeignKeyMetaData : AbstractForeignKeyMetadata {
    public DB2ForeignKeyMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.DB2IndexMetaData : AbstractIndexMetadata {
    public DB2IndexMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.DB2MetaData : AbstractDataBaseSchema {
    public DB2MetaData(DbConnection connection);
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    public virtual DataTable GetIndexColumns(string catalog, string schemaPattern, string tableName, string indexName);
    public virtual ISet`1<string> GetReservedWords();
}
public class NHibernate.Dialect.Schema.DB2TableMetaData : AbstractTableMetadata {
    public DB2TableMetaData(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual void ParseTableInfo(DataRow rs);
}
public class NHibernate.Dialect.Schema.FirebirdColumnMetadata : AbstractColumnMetaData {
    public FirebirdColumnMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.FirebirdDataBaseSchema : AbstractDataBaseSchema {
    public bool StoresUpperCaseIdentifiers { get; }
    public FirebirdDataBaseSchema(DbConnection connection);
    public virtual bool get_StoresUpperCaseIdentifiers();
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
}
public class NHibernate.Dialect.Schema.FirebirdForeignKeyMetadata : AbstractForeignKeyMetadata {
    public FirebirdForeignKeyMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.FirebirdIndexMetadata : AbstractIndexMetadata {
    public FirebirdIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.FirebirdTableMetadata : AbstractTableMetadata {
    public FirebirdTableMetadata(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual void ParseTableInfo(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.HanaColumnMetadata : AbstractColumnMetaData {
    public HanaColumnMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.HanaDataBaseSchema : AbstractDataBaseSchema {
    public bool StoresUpperCaseIdentifiers { get; }
    public HanaDataBaseSchema(DbConnection connection);
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    public virtual ISet`1<string> GetReservedWords();
    public virtual DataTable GetTables(string catalog, string schemaPattern, string tableNamePattern, String[] types);
    public virtual DataTable GetIndexInfo(string catalog, string schemaPattern, string tableName);
    public virtual DataTable GetIndexColumns(string catalog, string schemaPattern, string tableName, string indexName);
    public virtual DataTable GetColumns(string catalog, string schemaPattern, string tableNamePattern, string columnNamePattern);
    public virtual DataTable GetForeignKeys(string catalog, string schema, string table);
    public virtual bool get_StoresUpperCaseIdentifiers();
}
public class NHibernate.Dialect.Schema.HanaForeignKeyMetadata : AbstractForeignKeyMetadata {
    public HanaForeignKeyMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.HanaIndexMetadata : AbstractIndexMetadata {
    public HanaIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.HanaTableMetadata : AbstractTableMetadata {
    public HanaTableMetadata(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual void ParseTableInfo(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
}
public interface NHibernate.Dialect.Schema.IColumnMetadata {
    public string Name { get; }
    public string TypeName { get; }
    public int ColumnSize { get; }
    public int NumericalPrecision { get; }
    public string Nullable { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_TypeName();
    public abstract virtual int get_ColumnSize();
    public abstract virtual int get_NumericalPrecision();
    public abstract virtual string get_Nullable();
}
public interface NHibernate.Dialect.Schema.IDataBaseSchema {
    public bool StoresMixedCaseQuotedIdentifiers { get; }
    public bool StoresUpperCaseQuotedIdentifiers { get; }
    public bool StoresUpperCaseIdentifiers { get; }
    public bool StoresLowerCaseQuotedIdentifiers { get; }
    public bool StoresLowerCaseIdentifiers { get; }
    public string ColumnNameForTableName { get; }
    public abstract virtual bool get_StoresMixedCaseQuotedIdentifiers();
    public abstract virtual bool get_StoresUpperCaseQuotedIdentifiers();
    public abstract virtual bool get_StoresUpperCaseIdentifiers();
    public abstract virtual bool get_StoresLowerCaseQuotedIdentifiers();
    public abstract virtual bool get_StoresLowerCaseIdentifiers();
    public abstract virtual DataTable GetTables(string catalog, string schemaPattern, string tableNamePattern, String[] types);
    public abstract virtual string get_ColumnNameForTableName();
    public abstract virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    public abstract virtual DataTable GetColumns(string catalog, string schemaPattern, string tableNamePattern, string columnNamePattern);
    public abstract virtual DataTable GetIndexInfo(string catalog, string schemaPattern, string tableName);
    public abstract virtual DataTable GetIndexColumns(string catalog, string schemaPattern, string tableName, string indexName);
    public abstract virtual DataTable GetForeignKeys(string catalog, string schema, string table);
    public abstract virtual ISet`1<string> GetReservedWords();
}
public interface NHibernate.Dialect.Schema.IForeignKeyMetadata {
    public string Name { get; }
    public IColumnMetadata[] Columns { get; }
    public abstract virtual string get_Name();
    public abstract virtual void AddColumn(IColumnMetadata column);
    public abstract virtual IColumnMetadata[] get_Columns();
}
public interface NHibernate.Dialect.Schema.IIndexMetadata {
    public string Name { get; }
    public IColumnMetadata[] Columns { get; }
    public abstract virtual string get_Name();
    public abstract virtual void AddColumn(IColumnMetadata column);
    public abstract virtual IColumnMetadata[] get_Columns();
}
public interface NHibernate.Dialect.Schema.ITableMetadata {
    public string Name { get; }
    public string Catalog { get; }
    public string Schema { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Catalog();
    public abstract virtual string get_Schema();
    public abstract virtual IColumnMetadata GetColumnMetadata(string columnName);
    public abstract virtual IForeignKeyMetadata GetForeignKeyMetadata(string keyName);
    public abstract virtual IIndexMetadata GetIndexMetadata(string indexName);
    public abstract virtual bool NeedPhysicalConstraintCreation(string fkName);
}
public class NHibernate.Dialect.Schema.MsSqlCeColumnMetadata : AbstractColumnMetaData {
    public MsSqlCeColumnMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MsSqlCeDataBaseSchema : AbstractDataBaseSchema {
    [CompilerGeneratedAttribute]
private bool <UseDialectQualifyInsteadOfTableName>k__BackingField;
    public bool UseDialectQualifyInsteadOfTableName { get; }
    [ObsoleteAttribute("Use overload with dialect argument.")]
public MsSqlCeDataBaseSchema(DbConnection connection);
    public MsSqlCeDataBaseSchema(DbConnection connection, Dialect dialect);
    [CompilerGeneratedAttribute]
public virtual bool get_UseDialectQualifyInsteadOfTableName();
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
}
public class NHibernate.Dialect.Schema.MsSqlCeForeignKeyMetadata : AbstractForeignKeyMetadata {
    public MsSqlCeForeignKeyMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MsSqlCeIndexMetadata : AbstractIndexMetadata {
    public MsSqlCeIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MsSqlCeTableMetadata : AbstractTableMetadata {
    public MsSqlCeTableMetadata(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual void ParseTableInfo(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MsSqlColumnMetadata : AbstractColumnMetaData {
    public MsSqlColumnMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MsSqlDataBaseSchema : AbstractDataBaseSchema {
    public MsSqlDataBaseSchema(DbConnection connection);
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
}
public class NHibernate.Dialect.Schema.MsSqlForeignKeyMetadata : AbstractForeignKeyMetadata {
    public MsSqlForeignKeyMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MsSqlIndexMetadata : AbstractIndexMetadata {
    public MsSqlIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MsSqlTableMetadata : AbstractTableMetadata {
    public MsSqlTableMetadata(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual void ParseTableInfo(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MySQLColumnMetadata : AbstractColumnMetaData {
    public MySQLColumnMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MySQLDataBaseSchema : AbstractDataBaseSchema {
    protected string ForeignKeysSchemaName { get; }
    public MySQLDataBaseSchema(DbConnection connection);
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    protected virtual string get_ForeignKeysSchemaName();
}
public class NHibernate.Dialect.Schema.MySQLForeignKeyMetadata : AbstractForeignKeyMetadata {
    public MySQLForeignKeyMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MySQLIndexMetadata : AbstractIndexMetadata {
    public MySQLIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.MySQLTableMetadata : AbstractTableMetadata {
    public MySQLTableMetadata(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual void ParseTableInfo(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.OracleColumnMetadata : AbstractColumnMetaData {
    public OracleColumnMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.OracleDataBaseSchema : AbstractDataBaseSchema {
    public bool StoresUpperCaseIdentifiers { get; }
    public OracleDataBaseSchema(DbConnection connection);
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    public virtual bool get_StoresUpperCaseIdentifiers();
    public virtual DataTable GetTables(string catalog, string schemaPattern, string tableNamePattern, String[] types);
    public virtual DataTable GetColumns(string catalog, string schemaPattern, string tableNamePattern, string columnNamePattern);
    public virtual DataTable GetIndexColumns(string catalog, string schemaPattern, string tableName, string indexName);
    public virtual DataTable GetIndexInfo(string catalog, string schemaPattern, string tableName);
    public virtual DataTable GetForeignKeys(string catalog, string schema, string table);
}
public class NHibernate.Dialect.Schema.OracleForeignKeyMetadata : AbstractForeignKeyMetadata {
    public OracleForeignKeyMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.OracleIndexMetadata : AbstractIndexMetadata {
    public OracleIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.OracleTableMetadata : AbstractTableMetadata {
    public OracleTableMetadata(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual void ParseTableInfo(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.PostgreSQLColumnMetadata : AbstractColumnMetaData {
    public PostgreSQLColumnMetadata(DataRow rs);
    private static string NormalizeTypeNames(string typeName);
}
public class NHibernate.Dialect.Schema.PostgreSQLDataBaseMetadata : AbstractDataBaseSchema {
    public bool IncludeDataTypesInReservedWords { get; }
    public bool StoresMixedCaseQuotedIdentifiers { get; }
    public bool StoresLowerCaseIdentifiers { get; }
    public PostgreSQLDataBaseMetadata(DbConnection connection);
    public virtual bool get_IncludeDataTypesInReservedWords();
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    public virtual bool get_StoresMixedCaseQuotedIdentifiers();
    public virtual bool get_StoresLowerCaseIdentifiers();
    public virtual DataTable GetColumns(string catalog, string schemaPattern, string tableNamePattern, string columnNamePattern);
    public virtual DataTable GetTables(string catalog, string schemaPattern, string tableNamePattern, String[] types);
    public virtual DataTable GetIndexColumns(string catalog, string schemaPattern, string tableName, string indexName);
    public virtual DataTable GetIndexInfo(string catalog, string schemaPattern, string tableName);
    public virtual DataTable GetForeignKeys(string catalog, string schema, string table);
}
public class NHibernate.Dialect.Schema.PostgreSQLForeignKeyMetadata : AbstractForeignKeyMetadata {
    public PostgreSQLForeignKeyMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.PostgreSQLIndexMetadata : AbstractIndexMetadata {
    public PostgreSQLIndexMetadata(DataRow rs);
}
public class NHibernate.Dialect.Schema.PostgreSQLTableMetadata : AbstractTableMetadata {
    public PostgreSQLTableMetadata(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual void ParseTableInfo(DataRow rs);
}
public class NHibernate.Dialect.Schema.SapSqlAnywhere17ColumnMetaData : AbstractColumnMetaData {
    public SapSqlAnywhere17ColumnMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SapSqlAnywhere17DataBaseMetaData : AbstractDataBaseSchema {
    public SapSqlAnywhere17DataBaseMetaData(DbConnection connection);
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    public virtual ISet`1<string> GetReservedWords();
    public virtual DataTable GetTables(string catalog, string schemaPattern, string tableNamePattern, String[] types);
    public virtual DataTable GetIndexInfo(string catalog, string schemaPattern, string tableName);
    public virtual DataTable GetIndexColumns(string catalog, string schemaPattern, string tableName, string indexName);
    public virtual DataTable GetColumns(string catalog, string schemaPattern, string tableNamePattern, string columnNamePattern);
    public virtual DataTable GetForeignKeys(string catalog, string schema, string table);
}
public class NHibernate.Dialect.Schema.SapSqlAnywhere17ForeignKeyMetaData : AbstractForeignKeyMetadata {
    public SapSqlAnywhere17ForeignKeyMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SapSqlAnywhere17IndexMetaData : AbstractIndexMetadata {
    public SapSqlAnywhere17IndexMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SapSqlAnywhere17TableMetaData : AbstractTableMetadata {
    public SapSqlAnywhere17TableMetaData(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual void ParseTableInfo(DataRow rs);
}
public static class NHibernate.Dialect.Schema.SchemaHelper : object {
    public static object GetValue(DataRow row, String[] alternativeColumnNames);
    public static string GetString(DataRow row, String[] alternativeColumnNames);
}
public class NHibernate.Dialect.Schema.SQLiteColumnMetaData : AbstractColumnMetaData {
    public SQLiteColumnMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SQLiteDataBaseMetaData : AbstractDataBaseSchema {
    [CompilerGeneratedAttribute]
private bool <UseDialectQualifyInsteadOfTableName>k__BackingField;
    public bool UseDialectQualifyInsteadOfTableName { get; }
    [ObsoleteAttribute("Use overload with dialect argument.")]
public SQLiteDataBaseMetaData(DbConnection connection);
    public SQLiteDataBaseMetaData(DbConnection connection, Dialect dialect);
    [CompilerGeneratedAttribute]
public virtual bool get_UseDialectQualifyInsteadOfTableName();
    public virtual DataTable GetTables(string catalog, string schemaPattern, string tableNamePattern, String[] types);
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
}
public class NHibernate.Dialect.Schema.SQLiteForeignKeyMetaData : AbstractForeignKeyMetadata {
    public SQLiteForeignKeyMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SQLiteIndexMetaData : AbstractIndexMetadata {
    public SQLiteIndexMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SQLiteTableMetaData : AbstractTableMetadata {
    public SQLiteTableMetaData(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual void ParseTableInfo(DataRow rs);
}
public class NHibernate.Dialect.Schema.SybaseAnywhereColumnMetaData : AbstractColumnMetaData {
    public SybaseAnywhereColumnMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SybaseAnywhereDataBaseMetaData : AbstractDataBaseSchema {
    public SybaseAnywhereDataBaseMetaData(DbConnection pObjConnection);
    public virtual ITableMetadata GetTableMetadata(DataRow rs, bool extras);
    public virtual ISet`1<string> GetReservedWords();
    public virtual DataTable GetTables(string catalog, string schemaPattern, string tableNamePattern, String[] types);
    public virtual DataTable GetIndexInfo(string catalog, string schemaPattern, string tableName);
    public virtual DataTable GetIndexColumns(string catalog, string schemaPattern, string tableName, string indexName);
    public virtual DataTable GetColumns(string catalog, string schemaPattern, string tableNamePattern, string columnNamePattern);
    public virtual DataTable GetForeignKeys(string catalog, string schema, string table);
}
public class NHibernate.Dialect.Schema.SybaseAnywhereForeignKeyMetaData : AbstractForeignKeyMetadata {
    public SybaseAnywhereForeignKeyMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SybaseAnywhereIndexMetaData : AbstractIndexMetadata {
    public SybaseAnywhereIndexMetaData(DataRow rs);
}
public class NHibernate.Dialect.Schema.SybaseAnywhereTableMetaData : AbstractTableMetadata {
    public SybaseAnywhereTableMetaData(DataRow rs, IDataBaseSchema meta, bool extras);
    protected virtual IColumnMetadata GetColumnMetadata(DataRow rs);
    protected virtual string GetColumnName(DataRow rs);
    protected virtual string GetConstraintName(DataRow rs);
    protected virtual IForeignKeyMetadata GetForeignKeyMetadata(DataRow rs);
    protected virtual IIndexMetadata GetIndexMetadata(DataRow rs);
    protected virtual string GetIndexName(DataRow rs);
    protected virtual void ParseTableInfo(DataRow rs);
}
public class NHibernate.Dialect.SQLiteDialect : Dialect {
    private bool _binaryGuid;
    private static String[] DialectKeywords;
    public string AddColumnString { get; }
    public string IdentitySelectString { get; }
    public bool SupportsInsertSelectIdentity { get; }
    public bool DropConstraints { get; }
    public string ForUpdateString { get; }
    public bool SupportsSubSelects { get; }
    public bool SupportsIfExistsBeforeTableName { get; }
    public bool HasDataTypeInIdentityColumn { get; }
    public bool SupportsIdentityColumns { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public string IdentityColumnString { get; }
    public bool GenerateTablePrimaryKeyConstraintForIdentityColumn { get; }
    public bool IsDecimalStoredAsFloatingPointNumber { get; }
    public string NoColumnsInsertString { get; }
    public bool SupportsTemporaryTables { get; }
    public string CreateTemporaryTableString { get; }
    public string SelectGUIDString { get; }
    public string DisableForeignKeyConstraintsString { get; }
    public string EnableForeignKeyConstraintsString { get; }
    public bool SupportsForeignKeyConstraintInAlterTable { get; }
    public bool SupportsConcurrentWritingConnections { get; }
    public bool SupportsDistributedTransactions { get; }
    public int MaxAliasLength { get; }
    private static SQLiteDialect();
    protected virtual void RegisterColumnTypes();
    protected virtual void RegisterFunctions();
    public virtual void Configure(IDictionary`2<string, string> settings);
    private void ConfigureBinaryGuid(IDictionary`2<string, string> settings);
    private string GetConnectionStringProperty(DbConnectionStringBuilder builder, string propertyName);
    protected virtual void RegisterKeywords();
    protected virtual void RegisterDefaultProperties();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual string get_AddColumnString();
    public virtual string get_IdentitySelectString();
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertSql);
    public virtual bool get_SupportsInsertSelectIdentity();
    public virtual bool get_DropConstraints();
    public virtual string get_ForUpdateString();
    public virtual bool get_SupportsSubSelects();
    public virtual bool get_SupportsIfExistsBeforeTableName();
    public virtual bool get_HasDataTypeInIdentityColumn();
    public virtual bool get_SupportsIdentityColumns();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual string get_IdentityColumnString();
    public virtual bool get_GenerateTablePrimaryKeyConstraintForIdentityColumn();
    public virtual bool get_IsDecimalStoredAsFloatingPointNumber();
    public virtual string Qualify(string catalog, string schema, string table);
    public virtual string get_NoColumnsInsertString();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual bool get_SupportsTemporaryTables();
    public virtual string get_CreateTemporaryTableString();
    public virtual bool DropTemporaryTableAfterUse();
    public virtual string get_SelectGUIDString();
    public virtual string get_DisableForeignKeyConstraintsString();
    public virtual string get_EnableForeignKeyConstraintsString();
    public virtual bool get_SupportsForeignKeyConstraintInAlterTable();
    public virtual bool get_SupportsConcurrentWritingConnections();
    public virtual bool get_SupportsDistributedTransactions();
    public virtual int get_MaxAliasLength();
}
public class NHibernate.Dialect.SybaseASA9Dialect : Dialect {
    [CompilerGeneratedAttribute]
private bool <EscapeBackslashInStrings>k__BackingField;
    public bool SupportsLimit { get; }
    public bool SupportsVariableLimit { get; }
    public bool OffsetStartsAtOne { get; }
    public bool SupportsCrossJoin { get; }
    public string AddColumnString { get; }
    public string NullColumnString { get; }
    public bool QualifyIndexName { get; }
    public string ForUpdateString { get; }
    public bool SupportsIdentityColumns { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public string NoColumnsInsertString { get; }
    public bool DropConstraints { get; }
    protected bool EscapeBackslashInStrings { get; protected set; }
    protected bool UseNPrefixForUnicodeStrings { get; }
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsVariableLimit();
    public virtual bool get_OffsetStartsAtOne();
    public virtual bool get_SupportsCrossJoin();
    public virtual SqlString GetLimitString(SqlString queryString, SqlString offset, SqlString limit);
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual string get_AddColumnString();
    public virtual string get_NullColumnString();
    public virtual bool get_QualifyIndexName();
    public virtual string get_ForUpdateString();
    public virtual bool get_SupportsIdentityColumns();
    public virtual string get_IdentitySelectString();
    public virtual string get_IdentityColumnString();
    public virtual string get_NoColumnsInsertString();
    public virtual bool get_DropConstraints();
    private static int GetAfterSelectInsertPoint(SqlString sql);
    [CompilerGeneratedAttribute]
protected virtual bool get_EscapeBackslashInStrings();
    [CompilerGeneratedAttribute]
protected virtual void set_EscapeBackslashInStrings(bool value);
    protected virtual bool get_UseNPrefixForUnicodeStrings();
}
public class NHibernate.Dialect.SybaseASE15Dialect : Dialect {
    public string AddColumnString { get; }
    public string NullColumnString { get; }
    public bool QualifyIndexName { get; }
    public bool SupportsIdentityColumns { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public bool SupportsInsertSelectIdentity { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public bool IsCurrentTimestampSelectStringCallable { get; }
    public string CurrentTimestampSelectString { get; }
    public string CurrentUtcTimestampSelectString { get; }
    public bool SupportsCurrentUtcTimestampSelection { get; }
    public bool SupportsTemporaryTables { get; }
    public string SelectGUIDString { get; }
    public bool SupportsEmptyInList { get; }
    public bool SupportsUnionAll { get; }
    public bool SupportsExistsInSelect { get; }
    public bool DoesReadCommittedCauseWritersToBlockReaders { get; }
    public bool DoesRepeatableReadCauseReadersToBlockWriters { get; }
    public bool SupportsCascadeDelete { get; }
    public int MaxAliasLength { get; }
    public bool AreStringComparisonsCaseInsensitive { get; }
    public string CurrentTimestampSQLFunctionName { get; }
    public string CurrentUtcTimestampSQLFunctionName { get; }
    public bool SupportsExpectedLobUsagePattern { get; }
    public bool SupportsCrossJoin { get; }
    public char OpenQuote { get; }
    public char CloseQuote { get; }
    public string ForUpdateString { get; }
    public virtual Task`1<DbDataReader> GetResultSetAsync(DbCommand statement, CancellationToken cancellationToken);
    public virtual string get_AddColumnString();
    public virtual string get_NullColumnString();
    public virtual bool get_QualifyIndexName();
    public virtual bool get_SupportsIdentityColumns();
    public virtual string get_IdentitySelectString();
    public virtual string get_IdentityColumnString();
    public virtual bool get_SupportsInsertSelectIdentity();
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual bool get_IsCurrentTimestampSelectStringCallable();
    public virtual string get_CurrentTimestampSelectString();
    public virtual string get_CurrentUtcTimestampSelectString();
    public virtual bool get_SupportsCurrentUtcTimestampSelection();
    public virtual bool get_SupportsTemporaryTables();
    public virtual string get_SelectGUIDString();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_SupportsUnionAll();
    public virtual bool get_SupportsExistsInSelect();
    public virtual bool get_DoesReadCommittedCauseWritersToBlockReaders();
    public virtual bool get_DoesRepeatableReadCauseReadersToBlockWriters();
    public virtual bool get_SupportsCascadeDelete();
    public virtual int get_MaxAliasLength();
    public virtual bool get_AreStringComparisonsCaseInsensitive();
    public virtual string get_CurrentTimestampSQLFunctionName();
    public virtual string get_CurrentUtcTimestampSQLFunctionName();
    public virtual bool get_SupportsExpectedLobUsagePattern();
    public virtual bool get_SupportsCrossJoin();
    public virtual char get_OpenQuote();
    public virtual char get_CloseQuote();
    public virtual string get_ForUpdateString();
    public virtual string GenerateTemporaryTableName(string baseTableName);
    public virtual bool DropTemporaryTableAfterUse();
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertString);
    public virtual string AppendLockHint(LockMode lockMode, string tableName);
    public virtual SqlString ApplyLocksToSql(SqlString sql, IDictionary`2<string, LockMode> aliasedLockModes, IDictionary`2<string, String[]> keyColumnNames);
    public virtual int RegisterResultSetOutParameter(DbCommand statement, int position);
    public virtual DbDataReader GetResultSet(DbCommand statement);
}
public class NHibernate.Dialect.SybaseSQLAnywhere10Dialect : Dialect {
    private static String[] DialectKeywords;
    [CompilerGeneratedAttribute]
private bool <EscapeBackslashInStrings>k__BackingField;
    public bool SupportsIdentityColumns { get; }
    public string IdentitySelectString { get; }
    public string IdentityColumnString { get; }
    public bool SupportsInsertSelectIdentity { get; }
    public bool SupportsLimit { get; }
    public bool SupportsLimitOffset { get; }
    public bool SupportsVariableLimit { get; }
    public bool OffsetStartsAtOne { get; }
    [ObsoleteAttribute("Use UsesColumnsWithForUpdateOf instead")]
public bool ForUpdateOfColumns { get; }
    public bool SupportsOuterJoinForUpdate { get; }
    public string ForUpdateString { get; }
    public string ForReadOnlyString { get; }
    public string ForUpdateByLockString { get; }
    public string ForUpdateNowaitString { get; }
    public bool DoesReadCommittedCauseWritersToBlockReaders { get; }
    public bool DoesRepeatableReadCauseReadersToBlockWriters { get; }
    public bool SupportsCurrentTimestampSelection { get; }
    public string CurrentTimestampSQLFunctionName { get; }
    public bool IsCurrentTimestampSelectStringCallable { get; }
    public string CurrentTimestampSelectString { get; }
    public char CloseQuote { get; }
    public char OpenQuote { get; }
    public bool SupportsEmptyInList { get; }
    public bool SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor { get; }
    public bool SupportsExistsInSelect { get; }
    public bool AreStringComparisonsCaseInsensitive { get; }
    public bool SupportsCommentOn { get; }
    public int MaxAliasLength { get; }
    public string AddColumnString { get; }
    public string NullColumnString { get; }
    public bool QualifyIndexName { get; }
    public string NoColumnsInsertString { get; }
    public bool DropConstraints { get; }
    public string DropForeignKeyString { get; }
    public bool SupportsTemporaryTables { get; }
    public string CreateTemporaryTableString { get; }
    public string CreateTemporaryTablePostfix { get; }
    public string SelectGUIDString { get; }
    public bool SupportsUnionAll { get; }
    public long TimestampResolutionInTicks { get; }
    protected bool EscapeBackslashInStrings { get; protected set; }
    protected bool UseNPrefixForUnicodeStrings { get; }
    private static SybaseSQLAnywhere10Dialect();
    [AsyncStateMachineAttribute("NHibernate.Dialect.SybaseSQLAnywhere10Dialect/<GetResultSetAsync>d__0")]
public virtual Task`1<DbDataReader> GetResultSetAsync(DbCommand statement, CancellationToken cancellationToken);
    protected virtual void RegisterCharacterTypeMappings();
    protected virtual void RegisterNumericTypeMappings();
    protected virtual void RegisterDateTimeTypeMappings();
    protected virtual void RegisterReverseNHibernateTypeMappings();
    protected virtual void RegisterFunctions();
    protected virtual void RegisterMathFunctions();
    protected virtual void RegisterXmlFunctions();
    protected virtual void RegisterAggregationFunctions();
    protected virtual void RegisterBitFunctions();
    protected virtual void RegisterDateFunctions();
    protected virtual void RegisterStringFunctions();
    protected virtual void RegisterSoapFunctions();
    protected virtual void RegisterMiscellaneousFunctions();
    protected virtual void RegisterKeywords();
    public virtual bool get_SupportsIdentityColumns();
    public virtual string get_IdentitySelectString();
    public virtual string get_IdentityColumnString();
    public virtual SqlString AppendIdentitySelectToInsert(SqlString insertSql);
    public virtual bool get_SupportsInsertSelectIdentity();
    public virtual bool get_SupportsLimit();
    public virtual bool get_SupportsLimitOffset();
    public virtual bool get_SupportsVariableLimit();
    public virtual bool get_OffsetStartsAtOne();
    protected static int GetAfterSelectInsertPoint(SqlString sql);
    public virtual SqlString GetLimitString(SqlString sql, SqlString offset, SqlString limit);
    public virtual string GetForUpdateString(LockMode lockMode);
    public virtual bool get_ForUpdateOfColumns();
    public virtual bool get_SupportsOuterJoinForUpdate();
    public virtual string get_ForUpdateString();
    public string get_ForReadOnlyString();
    public string get_ForUpdateByLockString();
    public virtual string get_ForUpdateNowaitString();
    public virtual bool get_DoesReadCommittedCauseWritersToBlockReaders();
    public virtual bool get_DoesRepeatableReadCauseReadersToBlockWriters();
    public virtual bool get_SupportsCurrentTimestampSelection();
    public virtual string get_CurrentTimestampSQLFunctionName();
    public virtual bool get_IsCurrentTimestampSelectStringCallable();
    public virtual string get_CurrentTimestampSelectString();
    public virtual char get_CloseQuote();
    public virtual char get_OpenQuote();
    public virtual bool get_SupportsEmptyInList();
    public virtual bool get_SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor();
    public virtual bool get_SupportsExistsInSelect();
    public virtual bool get_AreStringComparisonsCaseInsensitive();
    public virtual bool get_SupportsCommentOn();
    public virtual int get_MaxAliasLength();
    public virtual string get_AddColumnString();
    public virtual string get_NullColumnString();
    public virtual bool get_QualifyIndexName();
    public virtual string get_NoColumnsInsertString();
    public virtual bool get_DropConstraints();
    public virtual string get_DropForeignKeyString();
    public virtual bool get_SupportsTemporaryTables();
    public virtual string get_CreateTemporaryTableString();
    public virtual string get_CreateTemporaryTablePostfix();
    public virtual Nullable`1<bool> PerformTemporaryTableDDLInIsolation();
    public virtual int RegisterResultSetOutParameter(DbCommand statement, int position);
    public virtual DbDataReader GetResultSet(DbCommand statement);
    public virtual string get_SelectGUIDString();
    public virtual bool get_SupportsUnionAll();
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
    public virtual long get_TimestampResolutionInTicks();
    [CompilerGeneratedAttribute]
protected virtual bool get_EscapeBackslashInStrings();
    [CompilerGeneratedAttribute]
protected virtual void set_EscapeBackslashInStrings(bool value);
    protected virtual bool get_UseNPrefixForUnicodeStrings();
}
public class NHibernate.Dialect.SybaseSQLAnywhere11Dialect : SybaseSQLAnywhere10Dialect {
}
public class NHibernate.Dialect.SybaseSQLAnywhere12Dialect : SybaseSQLAnywhere11Dialect {
    public string NoColumnsInsertString { get; }
    public string CurrentUtcTimestampSQLFunctionName { get; }
    public string CurrentUtcTimestampSelectString { get; }
    public bool SupportsCurrentUtcTimestampSelection { get; }
    public bool SupportsSequences { get; }
    public bool SupportsPooledSequences { get; }
    public string QuerySequencesString { get; }
    protected virtual void RegisterKeywords();
    protected virtual void RegisterDateTimeTypeMappings();
    protected virtual void RegisterDateFunctions();
    public virtual string get_NoColumnsInsertString();
    public virtual string get_CurrentUtcTimestampSQLFunctionName();
    public virtual string get_CurrentUtcTimestampSelectString();
    public virtual bool get_SupportsCurrentUtcTimestampSelection();
    public virtual bool get_SupportsSequences();
    public virtual bool get_SupportsPooledSequences();
    public virtual string get_QuerySequencesString();
    public virtual string GetSequenceNextValString(string sequenceName);
    public virtual string GetSelectSequenceNextValString(string sequenceName);
    public virtual string GetCreateSequenceString(string sequenceName);
    public virtual string GetDropSequenceString(string sequenceName);
}
public class NHibernate.Dialect.TypeNames : object {
    public static string LengthPlaceHolder;
    public static string PrecisionPlaceHolder;
    public static string ScalePlaceHolder;
    private Dictionary`2<DbType, SortedList`2<int, string>> weighted;
    private Dictionary`2<DbType, string> defaults;
    public string Get(DbType typecode);
    public bool TryGet(DbType typecode, String& typeName);
    public string Get(DbType typecode, int size, int precision, int scale);
    public bool TryGet(DbType typecode, int size, int precision, int scale, String& typeName);
    public string GetLongest(DbType typecode);
    private static bool IsPrecisionType(DbType typecode);
    private static bool IsScaleType(DbType typecode);
    private static string Replace(string type, int size, int precision, int scale);
    public void Put(DbType typecode, int capacity, string value);
    public void Put(DbType typecode, string value);
}
public class NHibernate.Driver.BasicResultSetsCommand : object {
    private static INHibernateLogger log;
    private SqlString _sqlString;
    [CompilerGeneratedAttribute]
private List`1<ISqlCommand> <Commands>k__BackingField;
    [CompilerGeneratedAttribute]
private ISessionImplementor <Session>k__BackingField;
    protected List`1<ISqlCommand> Commands { get; private set; }
    protected ISessionImplementor Session { get; private set; }
    public bool HasQueries { get; }
    public SqlString Sql { get; }
    public BasicResultSetsCommand(ISessionImplementor session);
    private static BasicResultSetsCommand();
    [AsyncStateMachineAttribute("NHibernate.Driver.BasicResultSetsCommand/<GetReaderAsync>d__0")]
public virtual Task`1<DbDataReader> GetReaderAsync(Nullable`1<int> commandTimeout, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
protected List`1<ISqlCommand> get_Commands();
    [CompilerGeneratedAttribute]
private void set_Commands(List`1<ISqlCommand> value);
    [CompilerGeneratedAttribute]
protected ISessionImplementor get_Session();
    [CompilerGeneratedAttribute]
private void set_Session(ISessionImplementor value);
    public virtual void Append(ISqlCommand command);
    public sealed virtual bool get_HasQueries();
    public virtual SqlString get_Sql();
    private SqlString GetSqlString();
    public virtual DbDataReader GetReader(Nullable`1<int> commandTimeout);
    protected virtual void BindParameters(DbCommand command);
    protected void ForEachSqlCommand(Action`2<ISqlCommand, int> actionToDo);
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Driver.BatcherDataReaderWrapper : DbDataReader {
    private IBatcher batcher;
    private DbCommand command;
    private DbDataReader reader;
    public int FieldCount { get; }
    public bool HasRows { get; }
    public object Item { get; }
    public object Item { get; }
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    protected BatcherDataReaderWrapper(IBatcher batcher, DbCommand command);
    [AsyncStateMachineAttribute("NHibernate.Driver.BatcherDataReaderWrapper/<CreateAsync>d__0")]
public static Task`1<BatcherDataReaderWrapper> CreateAsync(IBatcher batcher, DbCommand command, CancellationToken cancellationToken);
    public static BatcherDataReaderWrapper Create(IBatcher batcher, DbCommand command);
    public virtual string GetName(int i);
    public virtual string GetDataTypeName(int i);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int i);
    public virtual object GetValue(int i);
    public virtual int GetValues(Object[] values);
    public virtual int GetOrdinal(string name);
    public virtual bool GetBoolean(int i);
    public virtual byte GetByte(int i);
    public virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public virtual char GetChar(int i);
    public virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public virtual Guid GetGuid(int i);
    public virtual short GetInt16(int i);
    public virtual int GetInt32(int i);
    public virtual long GetInt64(int i);
    public virtual float GetFloat(int i);
    public virtual double GetDouble(int i);
    public virtual string GetString(int i);
    public virtual decimal GetDecimal(int i);
    public virtual DateTime GetDateTime(int i);
    protected virtual DbDataReader GetDbDataReader(int ordinal);
    public virtual bool IsDBNull(int i);
    public virtual int get_FieldCount();
    public virtual bool get_HasRows();
    public virtual object get_Item(int i);
    public virtual object get_Item(string name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Close();
    public virtual DataTable GetSchemaTable();
    public virtual bool NextResult();
    public virtual bool Read();
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public virtual int get_Depth();
    public virtual bool get_IsClosed();
    public virtual int get_RecordsAffected();
}
public class NHibernate.Driver.CsharpSqliteDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
}
public class NHibernate.Driver.DB2400Driver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
}
public class NHibernate.Driver.DB2CoreDriver : DB2DriverBase {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
}
public class NHibernate.Driver.DB2Driver : DB2DriverBase {
}
public abstract class NHibernate.Driver.DB2DriverBase : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public bool SupportsMultipleQueries { get; }
    protected DB2DriverBase(string assemblyName);
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
    public virtual bool get_SupportsMultipleQueries();
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
}
public class NHibernate.Driver.DbProviderFactoryDriveConnectionCommandProvider : object {
    private DbProviderFactory dbProviderFactory;
    public DbProviderFactoryDriveConnectionCommandProvider(DbProviderFactory dbProviderFactory);
    public sealed virtual DbConnection CreateConnection();
    public sealed virtual DbCommand CreateCommand();
}
public class NHibernate.Driver.DotConnectMySqlDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
}
public abstract class NHibernate.Driver.DriverBase : object {
    private static INHibernateLogger log;
    private int commandTimeout;
    private bool prepareSql;
    protected bool IsPrepareSqlEnabled { get; }
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    protected bool SupportsPreparingCommands { get; }
    public bool SupportsMultipleQueries { get; }
    public bool RequiresTimeSpanForTime { get; }
    public bool SupportsSystemTransactions { get; }
    public bool SupportsNullEnlistment { get; }
    public bool SupportsEnlistmentWhenAutoEnlistmentIsDisabled { get; }
    public bool HasDelayedDistributedTransactionCompletion { get; }
    public DateTime MinDate { get; }
    public int CommandTimeout { get; }
    private static DriverBase();
    public virtual void Configure(IDictionary`2<string, string> settings);
    protected bool get_IsPrepareSqlEnabled();
    public abstract virtual DbConnection CreateConnection();
    public abstract virtual DbCommand CreateCommand();
    public virtual DbCommand UnwrapDbCommand(DbCommand command);
    public virtual DbTransaction BeginTransaction(IsolationLevel isolationLevel, DbConnection connection);
    public abstract virtual bool get_UseNamedPrefixInSql();
    public abstract virtual bool get_UseNamedPrefixInParameter();
    public abstract virtual string get_NamedPrefix();
    public string FormatNameForSql(string parameterName);
    public string FormatNameForParameter(string parameterName);
    public virtual bool get_SupportsMultipleOpenReaders();
    protected virtual bool get_SupportsPreparingCommands();
    public virtual DbCommand GenerateCommand(CommandType type, SqlString sqlString, SqlType[] parameterTypes);
    protected virtual void SetCommandTimeout(DbCommand cmd);
    private static string ToParameterName(int index);
    private sealed virtual override string NHibernate.Driver.ISqlParameterFormatter.GetParameterName(int index);
    private void SetCommandText(DbCommand cmd, SqlString sqlString);
    protected virtual SqlStringFormatter GetSqlStringFormatter();
    private void SetCommandParameters(DbCommand cmd, SqlType[] sqlTypes);
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    public sealed virtual DbParameter GenerateParameter(DbCommand command, string name, SqlType sqlType);
    public sealed virtual void RemoveUnusedCommandParameters(DbCommand cmd, SqlString sqlString);
    public virtual void ExpandQueryParameters(DbCommand cmd, SqlString sqlString, SqlType[] parameterTypes);
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    public virtual bool get_SupportsMultipleQueries();
    protected virtual DbParameter CloneParameter(DbCommand cmd, DbParameter originalParameter, SqlType originalType);
    public sealed virtual void PrepareCommand(DbCommand command);
    protected virtual void OnBeforePrepare(DbCommand command);
    public virtual void AdjustCommand(DbCommand command);
    public DbParameter GenerateOutputParameter(DbCommand command);
    public virtual bool get_RequiresTimeSpanForTime();
    public virtual bool get_SupportsSystemTransactions();
    public virtual bool get_SupportsNullEnlistment();
    public virtual bool get_SupportsEnlistmentWhenAutoEnlistmentIsDisabled();
    public virtual bool get_HasDelayedDistributedTransactionCompletion();
    public virtual DateTime get_MinDate();
    public virtual int get_CommandTimeout();
}
[ExtensionAttribute]
public static class NHibernate.Driver.DriverExtensions : object {
    [ExtensionAttribute]
internal static void AdjustParameterForValue(IDriver driver, DbParameter parameter, SqlType sqlType, object value);
    [ExtensionAttribute]
internal static int GetCommandTimeout(IDriver driver);
    [ExtensionAttribute]
public static DbTransaction BeginTransaction(IDriver driver, IsolationLevel isolationLevel, DbConnection connection);
    [ExtensionAttribute]
public static DbCommand UnwrapDbCommand(IDriver driver, DbCommand command);
}
public class NHibernate.Driver.FirebirdClientDriver : ReflectionBasedDriver {
    private static string SELECT_CLAUSE_EXP;
    private static string CAST_PARAMS_EXP;
    private static Regex _statementRegEx;
    private static Regex _castCandidateRegEx;
    private FirebirdDialect _fbDialect;
    private bool _disableParameterCasting;
    private static MethodInfo modreq(System.Runtime.CompilerServices.IsVolatile) _clearPool;
    private static MethodInfo modreq(System.Runtime.CompilerServices.IsVolatile) _clearAllPools;
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsSystemTransactions { get; }
    public bool SupportsEnlistmentWhenAutoEnlistmentIsDisabled { get; }
    private static FirebirdClientDriver();
    public virtual void Configure(IDictionary`2<string, string> settings);
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    public virtual DbCommand GenerateCommand(CommandType type, SqlString sqlString, SqlType[] parameterTypes);
    private string GetStatementsWithCastCandidates(string commandText);
    private static HashSet`1<string> GetCastCandidates(string statement);
    private string GetFbTypeForParam(SqlType sqlType);
    public void ClearPool(string connectionString);
    public virtual bool get_SupportsSystemTransactions();
    public virtual bool get_SupportsEnlistmentWhenAutoEnlistmentIsDisabled();
}
public class NHibernate.Driver.HanaColumnStoreDriver : HanaDriverBase {
}
public abstract class NHibernate.Driver.HanaDriverBase : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsNullEnlistment { get; }
    public bool RequiresTimeSpanForTime { get; }
    private Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.BatcherFactoryClass { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    public virtual bool get_SupportsNullEnlistment();
    public virtual bool get_RequiresTimeSpanForTime();
    private sealed virtual override Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.get_BatcherFactoryClass();
}
public class NHibernate.Driver.HanaRowStoreDriver : HanaDriverBase {
    public bool SupportsSystemTransactions { get; }
    public virtual bool get_SupportsSystemTransactions();
}
public interface NHibernate.Driver.IDriveConnectionCommandProvider {
    public abstract virtual DbConnection CreateConnection();
    public abstract virtual DbCommand CreateCommand();
}
public interface NHibernate.Driver.IDriver {
    public bool SupportsMultipleOpenReaders { get; }
    public bool SupportsMultipleQueries { get; }
    public bool RequiresTimeSpanForTime { get; }
    public bool SupportsSystemTransactions { get; }
    public bool SupportsNullEnlistment { get; }
    public bool SupportsEnlistmentWhenAutoEnlistmentIsDisabled { get; }
    public bool HasDelayedDistributedTransactionCompletion { get; }
    public DateTime MinDate { get; }
    public abstract virtual void Configure(IDictionary`2<string, string> settings);
    public abstract virtual DbConnection CreateConnection();
    public abstract virtual bool get_SupportsMultipleOpenReaders();
    public abstract virtual DbCommand GenerateCommand(CommandType type, SqlString sqlString, SqlType[] parameterTypes);
    public abstract virtual void PrepareCommand(DbCommand command);
    public abstract virtual DbParameter GenerateParameter(DbCommand command, string name, SqlType sqlType);
    public abstract virtual void RemoveUnusedCommandParameters(DbCommand cmd, SqlString sqlString);
    public abstract virtual void ExpandQueryParameters(DbCommand cmd, SqlString sqlString, SqlType[] parameterTypes);
    public abstract virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    public abstract virtual bool get_SupportsMultipleQueries();
    public abstract virtual void AdjustCommand(DbCommand command);
    public abstract virtual bool get_RequiresTimeSpanForTime();
    public abstract virtual bool get_SupportsSystemTransactions();
    public abstract virtual bool get_SupportsNullEnlistment();
    public abstract virtual bool get_SupportsEnlistmentWhenAutoEnlistmentIsDisabled();
    public abstract virtual bool get_HasDelayedDistributedTransactionCompletion();
    public abstract virtual DateTime get_MinDate();
}
public class NHibernate.Driver.IfxDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
}
public class NHibernate.Driver.IngresDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
}
public interface NHibernate.Driver.IResultSetsCommand {
    public bool HasQueries { get; }
    public SqlString Sql { get; }
    public abstract virtual Task`1<DbDataReader> GetReaderAsync(Nullable`1<int> commandTimeout, CancellationToken cancellationToken);
    public abstract virtual void Append(ISqlCommand command);
    public abstract virtual bool get_HasQueries();
    public abstract virtual SqlString get_Sql();
    public abstract virtual DbDataReader GetReader(Nullable`1<int> commandTimeout);
}
public interface NHibernate.Driver.ISqlParameterFormatter {
    public abstract virtual string GetParameterName(int index);
}
public class NHibernate.Driver.MicrosoftDataSqlClientDriver : ReflectionBasedDriver {
    private static byte MaxTime;
    private static Action`2<object, SqlDbType> SetSqlDbType;
    private Dialect _dialect;
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public bool SupportsMultipleQueries { get; }
    public bool HasDelayedDistributedTransactionCompletion { get; }
    public bool RequiresTimeSpanForTime { get; }
    public DateTime MinDate { get; }
    private Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.BatcherFactoryClass { get; }
    private static MicrosoftDataSqlClientDriver();
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
    public virtual bool get_SupportsMultipleQueries();
    public virtual bool get_HasDelayedDistributedTransactionCompletion();
    public virtual bool get_RequiresTimeSpanForTime();
    public virtual DateTime get_MinDate();
    private sealed virtual override Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.get_BatcherFactoryClass();
    public virtual void AdjustParameterForValue(DbParameter parameter, SqlType sqlType, object value);
    public virtual void Configure(IDictionary`2<string, string> settings);
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    protected static bool IsAnsiText(DbParameter dbParam, SqlType sqlType);
    protected static bool IsText(DbParameter dbParam, SqlType sqlType);
    protected static bool IsBlob(DbParameter dbParam, SqlType sqlType);
    protected static bool IsChar(DbParameter dbParam, SqlType sqlType);
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
}
public class NHibernate.Driver.MySqlDataDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    protected bool SupportsPreparingCommands { get; }
    public bool SupportsMultipleQueries { get; }
    public bool RequiresTimeSpanForTime { get; }
    public DateTime MinDate { get; }
    private Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.BatcherFactoryClass { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
    protected virtual bool get_SupportsPreparingCommands();
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    public virtual bool get_SupportsMultipleQueries();
    public virtual bool get_RequiresTimeSpanForTime();
    public virtual DateTime get_MinDate();
    private sealed virtual override Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.get_BatcherFactoryClass();
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Driver.NDataReader : DbDataReader {
    private NResult[] results;
    private bool isClosed;
    private int currentRowIndex;
    private int currentResultIndex;
    private Byte[] cachedByteArray;
    private Char[] cachedCharArray;
    private int cachedColIndex;
    public int RecordsAffected { get; }
    public bool HasRows { get; }
    public bool IsClosed { get; }
    public int Depth { get; }
    public object Item { get; }
    public object Item { get; }
    public int FieldCount { get; }
    [AsyncStateMachineAttribute("NHibernate.Driver.NDataReader/<CreateAsync>d__0")]
public static Task`1<NDataReader> CreateAsync(DbDataReader reader, bool isMidstream, CancellationToken cancellationToken);
    public static NDataReader Create(DbDataReader reader, bool isMidstream);
    private void ClearCache();
    private NResult GetCurrentResult();
    private object GetValue(string name);
    public virtual int get_RecordsAffected();
    public virtual bool get_HasRows();
    public virtual bool get_IsClosed();
    public virtual bool NextResult();
    public virtual void Close();
    public virtual bool Read();
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
    public virtual int get_Depth();
    public virtual DataTable GetSchemaTable();
    protected virtual void Dispose(bool disposing);
    public virtual int GetInt32(int i);
    public virtual object get_Item(string name);
    public virtual object get_Item(int i);
    public virtual object GetValue(int i);
    public virtual bool IsDBNull(int i);
    public virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferOffset, int length);
    public virtual byte GetByte(int i);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int i);
    public virtual decimal GetDecimal(int i);
    public virtual int GetValues(Object[] values);
    public virtual string GetName(int i);
    public virtual int get_FieldCount();
    public virtual long GetInt64(int i);
    public virtual double GetDouble(int i);
    public virtual bool GetBoolean(int i);
    public virtual Guid GetGuid(int i);
    public virtual DateTime GetDateTime(int i);
    public virtual int GetOrdinal(string name);
    public virtual string GetDataTypeName(int i);
    public virtual float GetFloat(int i);
    protected virtual DbDataReader GetDbDataReader(int ordinal);
    public virtual long GetChars(int i, long fieldOffset, Char[] buffer, int bufferOffset, int length);
    public virtual string GetString(int i);
    public virtual char GetChar(int i);
    public virtual short GetInt16(int i);
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Driver.NHybridDataReader : DbDataReader {
    private INHibernateLogger log;
    private DbDataReader _reader;
    private bool _isMidstream;
    private bool disposed;
    public DbDataReader Target { get; }
    public bool IsMidstream { get; }
    public int RecordsAffected { get; }
    public bool HasRows { get; }
    public bool IsClosed { get; }
    public int Depth { get; }
    public object Item { get; }
    public object Item { get; }
    public int FieldCount { get; }
    public static Task`1<NHybridDataReader> CreateAsync(DbDataReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Driver.NHybridDataReader/<CreateAsync>d__1")]
public static Task`1<NHybridDataReader> CreateAsync(DbDataReader reader, bool inMemory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Driver.NHybridDataReader/<ReadIntoMemoryAsync>d__2")]
public Task ReadIntoMemoryAsync(CancellationToken cancellationToken);
    public DbDataReader get_Target();
    public static NHybridDataReader Create(DbDataReader reader);
    public static NHybridDataReader Create(DbDataReader reader, bool inMemory);
    public void ReadIntoMemory();
    public bool get_IsMidstream();
    public virtual int get_RecordsAffected();
    public virtual bool get_HasRows();
    public virtual bool get_IsClosed();
    public virtual bool NextResult();
    public virtual void Close();
    public virtual bool Read();
    [AsyncStateMachineAttribute("NHibernate.Driver.NHybridDataReader/<ReadAsync>d__23")]
public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
    public virtual int get_Depth();
    public virtual DataTable GetSchemaTable();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual int GetInt32(int i);
    public virtual object get_Item(string name);
    public virtual object get_Item(int i);
    public virtual object GetValue(int i);
    public virtual bool IsDBNull(int i);
    public virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public virtual byte GetByte(int i);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int i);
    public virtual decimal GetDecimal(int i);
    public virtual int GetValues(Object[] values);
    public virtual string GetName(int i);
    public virtual int get_FieldCount();
    public virtual long GetInt64(int i);
    public virtual double GetDouble(int i);
    public virtual bool GetBoolean(int i);
    public virtual Guid GetGuid(int i);
    public virtual DateTime GetDateTime(int i);
    public virtual int GetOrdinal(string name);
    public virtual string GetDataTypeName(int i);
    public virtual float GetFloat(int i);
    protected virtual DbDataReader GetDbDataReader(int ordinal);
    public virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public virtual string GetString(int i);
    public virtual char GetChar(int i);
    public virtual short GetInt16(int i);
}
public class NHibernate.Driver.NpgsqlDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    protected bool SupportsPreparingCommands { get; }
    public bool SupportsNullEnlistment { get; }
    public bool SupportsMultipleQueries { get; }
    public bool RequiresTimeSpanForTime { get; }
    public bool HasDelayedDistributedTransactionCompletion { get; }
    private Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.BatcherFactoryClass { get; }
    private int DriverVersionMajor { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
    protected virtual bool get_SupportsPreparingCommands();
    public virtual bool get_SupportsNullEnlistment();
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    public virtual bool get_SupportsMultipleQueries();
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    public virtual void AdjustCommand(DbCommand command);
    public virtual bool get_RequiresTimeSpanForTime();
    public virtual bool get_HasDelayedDistributedTransactionCompletion();
    private sealed virtual override Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.get_BatcherFactoryClass();
    private int get_DriverVersionMajor();
}
public class NHibernate.Driver.OdbcDriver : ReflectionBasedDriver {
    private static INHibernateLogger Log;
    private Nullable`1<byte> _dbDateTimeScale;
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool RequiresTimeSpanForTime { get; }
    public bool HasDelayedDistributedTransactionCompletion { get; }
    public DateTime MinDate { get; }
    private static OdbcDriver();
    public virtual void Configure(IDictionary`2<string, string> settings);
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    private void SetVariableLengthParameterSize(DbParameter dbParam, SqlType sqlType);
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    public virtual bool get_RequiresTimeSpanForTime();
    public virtual bool get_HasDelayedDistributedTransactionCompletion();
    public virtual DateTime get_MinDate();
}
public class NHibernate.Driver.OleDbDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
}
[ObsoleteAttribute("Use OracleManagedDataClientDriver or OracleDataClientDriver driver instead.")]
public class NHibernate.Driver.OracleClientDriver : ReflectionBasedDriver {
    private static SqlType GuidSqlType;
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    private static OracleClientDriver();
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    protected virtual void OnBeforePrepare(DbCommand command);
}
public class NHibernate.Driver.OracleDataClientDriver : OracleDataClientDriverBase {
}
public abstract class NHibernate.Driver.OracleDataClientDriverBase : ReflectionBasedDriver {
    private static string _commandClassName;
    private static SqlType _guidSqlType;
    private Action`2<object, bool> _commandBindByNameSetter;
    private Action`2<object, object> _parameterOracleDbTypeSetter;
    private Action`2<object, bool> _suppressDecimalInvalidCastExceptionSetter;
    private object _oracleDbTypeRefCursor;
    private object _oracleDbTypeXmlType;
    private object _oracleDbTypeBlob;
    private object _oracleDbTypeNVarchar2;
    private object _oracleDbTypeNChar;
    private object _oracleDbTypeBinaryDouble;
    private object _oracleDbTypeBinaryFloat;
    [CompilerGeneratedAttribute]
private bool <UseNPrefixedTypesForUnicode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseBinaryFloatingPointTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressDecimalInvalidCastException>k__BackingField;
    public bool UseNPrefixedTypesForUnicode { get; private set; }
    public bool UseBinaryFloatingPointTypes { get; private set; }
    public bool SuppressDecimalInvalidCastException { get; private set; }
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    private Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.BatcherFactoryClass { get; }
    protected OracleDataClientDriverBase(string assemblyName);
    private OracleDataClientDriverBase(string driverAssemblyName, string clientNamespace);
    private static OracleDataClientDriverBase();
    public virtual void Configure(IDictionary`2<string, string> settings);
    [CompilerGeneratedAttribute]
public bool get_UseNPrefixedTypesForUnicode();
    [CompilerGeneratedAttribute]
private void set_UseNPrefixedTypesForUnicode(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseBinaryFloatingPointTypes();
    [CompilerGeneratedAttribute]
private void set_UseBinaryFloatingPointTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressDecimalInvalidCastException();
    [CompilerGeneratedAttribute]
private void set_SuppressDecimalInvalidCastException(bool value);
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    private void InitializeParameter(DbParameter dbParam, string name, object oracleDbType);
    protected virtual void OnBeforePrepare(DbCommand command);
    public virtual DbCommand CreateCommand();
    public virtual DbCommand UnwrapDbCommand(DbCommand command);
    private sealed virtual override Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.get_BatcherFactoryClass();
}
public class NHibernate.Driver.OracleLiteDataClientDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    private Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.BatcherFactoryClass { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    private sealed virtual override Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.get_BatcherFactoryClass();
}
public class NHibernate.Driver.OracleManagedDataClientDriver : OracleDataClientDriverBase {
    public bool HasDelayedDistributedTransactionCompletion { get; }
    public virtual bool get_HasDelayedDistributedTransactionCompletion();
}
public abstract class NHibernate.Driver.ReflectionBasedDriver : DriverBase {
    protected static string ReflectionTypedProviderExceptionMessageTemplate;
    private IDriveConnectionCommandProvider connectionCommandProvider;
    [CompilerGeneratedAttribute]
private Version <DriverVersion>k__BackingField;
    protected Version DriverVersion { get; }
    protected ReflectionBasedDriver(string driverAssemblyName, string connectionTypeName, string commandTypeName);
    protected ReflectionBasedDriver(string providerInvariantName, string driverAssemblyName, string connectionTypeName, string commandTypeName);
    [CompilerGeneratedAttribute]
protected Version get_DriverVersion();
    public virtual DbConnection CreateConnection();
    public virtual DbCommand CreateCommand();
}
public class NHibernate.Driver.ReflectionDriveConnectionCommandProvider : object {
    private Type commandType;
    private Type connectionType;
    public ReflectionDriveConnectionCommandProvider(Type connectionType, Type commandType);
    public sealed virtual DbConnection CreateConnection();
    public sealed virtual DbCommand CreateCommand();
}
public class NHibernate.Driver.SapSQLAnywhere17Driver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool RequiresTimeSpanForTime { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_RequiresTimeSpanForTime();
}
public class NHibernate.Driver.Sql2008ClientDriver : SqlClientDriver {
    private static byte MaxTime;
    private static Action`2<object, SqlDbType> SetSqlDbType;
    public bool RequiresTimeSpanForTime { get; }
    public DateTime MinDate { get; }
    private static Sql2008ClientDriver();
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    public virtual bool get_RequiresTimeSpanForTime();
    public virtual DateTime get_MinDate();
}
public class NHibernate.Driver.SqlClientDriver : ReflectionBasedDriver {
    [ObsoleteAttribute("Use MsSql2000Dialect.MaxSizeForAnsiClob")]
public static int MaxSizeForAnsiClob;
    [ObsoleteAttribute("Use MsSql2000Dialect.MaxSizeForClob")]
public static int MaxSizeForClob;
    [ObsoleteAttribute("Use MsSql2000Dialect.MaxSizeForBlob")]
public static int MaxSizeForBlob;
    [ObsoleteAttribute("Use MsSql2005Dialect.MaxSizeForXml")]
public static int MaxSizeForXml;
    [ObsoleteAttribute("Use MsSql2000Dialect.MaxSizeForLengthLimitedAnsiString")]
public static int MaxSizeForLengthLimitedAnsiString;
    [ObsoleteAttribute("Use MsSql2000Dialect.MaxSizeForLengthLimitedString")]
public static int MaxSizeForLengthLimitedString;
    [ObsoleteAttribute("Use MsSql2000Dialect.MaxSizeForLengthLimitedBinary")]
public static int MaxSizeForLengthLimitedBinary;
    [ObsoleteAttribute("This member has no more usages and will be removed in a future version")]
public static byte MaxPrecision;
    [ObsoleteAttribute("This member has no more usages and will be removed in a future version")]
public static byte MaxScale;
    [ObsoleteAttribute("Use MsSql2000Dialect.MaxDateTime2")]
public static byte MaxDateTime2;
    [ObsoleteAttribute("Use MsSql2000Dialect.MaxDateTimeOffset")]
public static byte MaxDateTimeOffset;
    private Dialect _dialect;
    private Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.BatcherFactoryClass { get; }
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public bool SupportsMultipleQueries { get; }
    public bool HasDelayedDistributedTransactionCompletion { get; }
    public DateTime MinDate { get; }
    public virtual void Configure(IDictionary`2<string, string> settings);
    private sealed virtual override Type NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider.get_BatcherFactoryClass();
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public static void SetVariableLengthParameterSize(DbParameter dbParam, SqlType sqlType);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
protected static void SetDefaultParameterSize(DbParameter dbParam, SqlType sqlType);
    protected static bool IsAnsiText(DbParameter dbParam, SqlType sqlType);
    protected static bool IsText(DbParameter dbParam, SqlType sqlType);
    protected static bool IsBlob(DbParameter dbParam, SqlType sqlType);
    protected static bool IsChar(DbParameter dbParam, SqlType sqlType);
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    public virtual bool get_SupportsMultipleQueries();
    public virtual bool get_HasDelayedDistributedTransactionCompletion();
    public virtual DateTime get_MinDate();
    public virtual void AdjustParameterForValue(DbParameter parameter, SqlType sqlType, object value);
}
public class NHibernate.Driver.SQLite20Driver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public bool SupportsMultipleQueries { get; }
    public bool SupportsNullEnlistment { get; }
    public bool HasDelayedDistributedTransactionCompletion { get; }
    public virtual DbConnection CreateConnection();
    private static void Connection_StateChange(object sender, StateChangeEventArgs e);
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
    public virtual bool get_SupportsMultipleQueries();
    public virtual bool get_SupportsNullEnlistment();
    public virtual bool get_HasDelayedDistributedTransactionCompletion();
}
public class NHibernate.Driver.SqlServerCeDriver : ReflectionBasedDriver {
    private static Action`2<object, SqlDbType> SetSqlDbType;
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public bool SupportsNullEnlistment { get; }
    public bool SupportsEnlistmentWhenAutoEnlistmentIsDisabled { get; }
    public DateTime MinDate { get; }
    private static SqlServerCeDriver();
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
    protected virtual void SetCommandTimeout(DbCommand cmd);
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    protected virtual void InitializeParameter(DbParameter dbParam, string name, SqlType sqlType);
    private static SqlType AdjustSqlType(SqlType sqlType);
    private void AdjustDbParamTypeForLargeObjects(DbParameter dbParam, SqlType sqlType);
    public virtual bool get_SupportsNullEnlistment();
    public virtual bool get_SupportsEnlistmentWhenAutoEnlistmentIsDisabled();
    public virtual DateTime get_MinDate();
}
public class NHibernate.Driver.SqlStringFormatter : object {
    private StringBuilder result;
    private int parameterIndex;
    private ISqlParameterFormatter formatter;
    private string multipleQueriesSeparator;
    private bool hasReturnParameter;
    private bool foundReturnParameter;
    private List`1<string> assignedParameterNames;
    public bool HasReturnParameter { get; }
    public String[] AssignedParameterNames { get; }
    public SqlStringFormatter(ISqlParameterFormatter formatter, string multipleQueriesSeparator);
    public void Format(SqlString text);
    public string GetFormattedText();
    private sealed virtual override void NHibernate.SqlCommand.ISqlStringVisitor.String(string text);
    private sealed virtual override void NHibernate.SqlCommand.ISqlStringVisitor.String(SqlString sqlString);
    private sealed virtual override void NHibernate.SqlCommand.ISqlStringVisitor.Parameter(Parameter parameter);
    private bool DetermineIfSqlStringHasReturnParameter(SqlString text);
    public bool get_HasReturnParameter();
    public String[] get_AssignedParameterNames();
}
public class NHibernate.Driver.SybaseAdoNet45Driver : SybaseAseClientDriverBase {
}
public class NHibernate.Driver.SybaseAdoNet4Driver : SybaseAseClientDriverBase {
}
public class NHibernate.Driver.SybaseAsaClientDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool RequiresTimeSpanForTime { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_RequiresTimeSpanForTime();
}
public class NHibernate.Driver.SybaseAseClientDriver : SybaseAseClientDriverBase {
}
public abstract class NHibernate.Driver.SybaseAseClientDriverBase : ReflectionBasedDriver {
    public string NamedPrefix { get; }
    public bool UseNamedPrefixInParameter { get; }
    public bool UseNamedPrefixInSql { get; }
    protected SybaseAseClientDriverBase(string assemblyName);
    protected SybaseAseClientDriverBase(string providerInvariantName, string assemblyName, string connectionTypeName, string commandTypeName);
    public virtual string get_NamedPrefix();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual bool get_UseNamedPrefixInSql();
}
public class NHibernate.Driver.SybaseSQLAnywhereDotNet4Driver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool RequiresTimeSpanForTime { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_RequiresTimeSpanForTime();
}
public class NHibernate.Driver.SybaseSQLAnywhereDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool RequiresTimeSpanForTime { get; }
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_RequiresTimeSpanForTime();
}
public class NHibernate.DuplicateMappingException : MappingException {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Type { get; }
    public string Name { get; }
    public DuplicateMappingException(string customMessage, string type, string name);
    public DuplicateMappingException(string type, string name);
    public DuplicateMappingException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
}
public class NHibernate.EmptyInterceptor : object {
    public static EmptyInterceptor Instance;
    private static EmptyInterceptor();
    public virtual void OnDelete(object entity, object id, Object[] state, String[] propertyNames, IType[] types);
    public virtual void OnCollectionRecreate(object collection, object key);
    public virtual void OnCollectionRemove(object collection, object key);
    public virtual void OnCollectionUpdate(object collection, object key);
    public virtual bool OnFlushDirty(object entity, object id, Object[] currentState, Object[] previousState, String[] propertyNames, IType[] types);
    public virtual bool OnLoad(object entity, object id, Object[] state, String[] propertyNames, IType[] types);
    public virtual bool OnSave(object entity, object id, Object[] state, String[] propertyNames, IType[] types);
    public virtual void PostFlush(ICollection entities);
    public virtual void PreFlush(ICollection entitites);
    public virtual Nullable`1<bool> IsTransient(object entity);
    public virtual object Instantiate(string clazz, object id);
    public virtual string GetEntityName(object entity);
    public virtual object GetEntity(string entityName, object id);
    public virtual Int32[] FindDirty(object entity, object id, Object[] currentState, Object[] previousState, String[] propertyNames, IType[] types);
    public virtual void AfterTransactionBegin(ITransaction tx);
    public virtual void BeforeTransactionCompletion(ITransaction tx);
    public virtual void AfterTransactionCompletion(ITransaction tx);
    public virtual void SetSession(ISession session);
    public virtual SqlString OnPrepareStatement(SqlString sql);
}
public abstract class NHibernate.Engine.AbstractLhsAssociationTypeSqlInfo : object {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private IOuterJoinLoadable <Persister>k__BackingField;
    [CompilerGeneratedAttribute]
private IMapping <Mapping>k__BackingField;
    public string Alias { get; private set; }
    public IOuterJoinLoadable Persister { get; private set; }
    public IMapping Mapping { get; private set; }
    protected AbstractLhsAssociationTypeSqlInfo(string alias, IOuterJoinLoadable persister, IMapping mapping);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
private void set_Alias(string value);
    [CompilerGeneratedAttribute]
public IOuterJoinLoadable get_Persister();
    [CompilerGeneratedAttribute]
private void set_Persister(IOuterJoinLoadable value);
    [CompilerGeneratedAttribute]
public IMapping get_Mapping();
    [CompilerGeneratedAttribute]
private void set_Mapping(IMapping value);
    public sealed virtual String[] GetAliasedColumnNames(IAssociationType type, int begin);
    public sealed virtual String[] GetColumnNames(IAssociationType type, int begin);
    protected abstract virtual String[] GetAliasedColumns();
    protected abstract virtual String[] GetColumns();
    public abstract virtual string GetTableName(IAssociationType type);
}
public class NHibernate.Engine.ActionQueue : object {
    private static INHibernateLogger log;
    private static int InitQueueListSize;
    private ISessionImplementor session;
    private List`1<AbstractEntityInsertAction> insertions;
    private List`1<EntityDeleteAction> deletions;
    private List`1<EntityUpdateAction> updates;
    private List`1<CollectionRecreateAction> collectionCreations;
    private List`1<CollectionUpdateAction> collectionUpdates;
    private List`1<CollectionRemoveAction> collectionRemovals;
    private AfterTransactionCompletionProcessQueue afterTransactionProcesses;
    private BeforeTransactionCompletionProcessQueue beforeTransactionProcesses;
    private HashSet`1<string> executedSpaces;
    public bool AreInsertionsOrDeletionsQueued { get; }
    public int CollectionRemovalsCount { get; }
    public int CollectionUpdatesCount { get; }
    public int CollectionCreationsCount { get; }
    public int DeletionsCount { get; }
    public int UpdatesCount { get; }
    public int InsertionsCount { get; }
    public bool HasAnyQueuedActions { get; }
    public ActionQueue(ISessionImplementor session);
    private static ActionQueue();
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<ExecuteActionsAsync>d__0`1")]
private Task ExecuteActionsAsync(List`1<T> list, CancellationToken cancellationToken);
    private Task PreInvalidateCachesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<ExecuteAsync>d__2")]
public Task ExecuteAsync(IExecutable executable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<InnerExecuteAsync>d__3")]
private Task InnerExecuteAsync(IExecutable executable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<ExecuteInsertsAsync>d__4")]
public Task ExecuteInsertsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<ExecuteActionsAsync>d__5")]
public Task ExecuteActionsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<PrepareActionsAsync>d__6`1")]
private static Task PrepareActionsAsync(List`1<T> queue, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<PrepareActionsAsync>d__7")]
public Task PrepareActionsAsync(CancellationToken cancellationToken);
    public Task BeforeTransactionCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<AfterTransactionCompletionAsync>d__9")]
public Task AfterTransactionCompletionAsync(bool success, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ActionQueue/<InvalidateCachesAsync>d__10")]
private Task InvalidateCachesAsync(CancellationToken cancellationToken);
    public virtual void Clear();
    public void AddAction(EntityInsertAction action);
    public void AddAction(EntityDeleteAction action);
    public void AddAction(EntityUpdateAction action);
    public void AddAction(CollectionRecreateAction action);
    public void AddAction(CollectionRemoveAction action);
    public void AddAction(CollectionUpdateAction action);
    public void AddAction(EntityIdentityInsertAction insert);
    public void AddAction(BulkOperationCleanupAction cleanupAction);
    [ObsoleteAttribute("This method is no longer executed asynchronously and will be removed in a next major version.")]
public Task AddActionAsync(BulkOperationCleanupAction cleanupAction, CancellationToken cancellationToken);
    public void RegisterProcess(IBeforeTransactionCompletionProcess process);
    public void RegisterProcess(IAfterTransactionCompletionProcess process);
    [ObsoleteAttribute("This method is not used and will be removed in a future version.")]
public void RegisterProcess(BeforeTransactionCompletionProcessDelegate process);
    [ObsoleteAttribute("This method is not used and will be removed in a future version.")]
public void RegisterProcess(AfterTransactionCompletionProcessDelegate process);
    private void ExecuteActions(List`1<T> list);
    private void PreInvalidateCaches();
    public void Execute(IExecutable executable);
    private void InnerExecute(IExecutable executable);
    private void RegisterCleanupActions(IExecutable executable);
    public void ExecuteInserts();
    public void ExecuteActions();
    private static void PrepareActions(List`1<T> queue);
    public void PrepareActions();
    public void BeforeTransactionCompletion();
    public void AfterTransactionCompletion(bool success);
    private void InvalidateCaches();
    public virtual bool AreTablesToBeUpdated(ISet`1<string> tables);
    public bool get_AreInsertionsOrDeletionsQueued();
    private static bool AreTablesToUpdated(List`1<T> executables, ISet`1<string> tablespaces);
    public int get_CollectionRemovalsCount();
    public int get_CollectionUpdatesCount();
    public int get_CollectionCreationsCount();
    public int get_DeletionsCount();
    public int get_UpdatesCount();
    public int get_InsertionsCount();
    public void SortCollectionActions();
    public void SortActions();
    private void SortInsertActions();
    public IList`1<EntityDeleteAction> CloneDeletions();
    public void ClearFromFlushNeededCheck(int previousCollectionRemovalSize);
    public bool HasBeforeTransactionActions();
    public bool HasAfterTransactionActions();
    public bool get_HasAnyQueuedActions();
    public virtual string ToString();
}
internal class NHibernate.Engine.AssociationKey : object {
    private EntityKey ownerKey;
    private string propertyName;
    public AssociationKey(EntityKey ownerKey, string propertyName);
    public virtual bool Equals(object that);
    public virtual int GetHashCode();
}
public class NHibernate.Engine.BatchFetchQueue : object {
    private static INHibernateLogger log;
    private Dictionary`2<string, LinkedHashSet`1<EntityKey>> batchLoadableEntityKeys;
    private Dictionary`2<EntityKey, SubselectFetch> subselectsByEntityKey;
    private Dictionary`2<string, LinkedHashMap`2<CollectionEntry, IPersistentCollection>> batchLoadableCollections;
    private IPersistenceContext context;
    [CompilerGeneratedAttribute]
private QueryCacheBatchQueue <QueryCacheQueue>k__BackingField;
    internal QueryCacheBatchQueue QueryCacheQueue { get; private set; }
    public BatchFetchQueue(IPersistenceContext context);
    private static BatchFetchQueue();
    public Task`1<Object[]> GetCollectionBatchAsync(ICollectionPersister collectionPersister, object id, int batchSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.BatchFetchQueue/<GetCollectionBatchAsync>d__1")]
internal Task`1<Object[]> GetCollectionBatchAsync(ICollectionPersister collectionPersister, object key, int batchSize, bool checkCache, CollectionEntry[] collectionEntries, CancellationToken cancellationToken);
    public Task`1<Object[]> GetEntityBatchAsync(IEntityPersister persister, object id, int batchSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.BatchFetchQueue/<GetEntityBatchAsync>d__3")]
internal Task`1<Object[]> GetEntityBatchAsync(IEntityPersister persister, object id, int batchSize, bool checkCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.BatchFetchQueue/<AreCachedAsync>d__4")]
private Task`1<Boolean[]> AreCachedAsync(List`1<KeyValuePair`2<EntityKey, int>> entityKeys, Int32[] keyIndexes, IEntityPersister persister, CacheBase batchableCache, bool checkCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.BatchFetchQueue/<AreCachedAsync>d__5")]
private Task`1<Boolean[]> AreCachedAsync(List`1<KeyValuePair`2<KeyValuePair`2<CollectionEntry, IPersistentCollection>, int>> collectionKeys, Int32[] keyIndexes, ICollectionPersister persister, CacheBase batchableCache, bool checkCache, CancellationToken cancellationToken);
    public void Clear();
    public SubselectFetch GetSubselect(EntityKey key);
    public void AddSubselect(EntityKey key, SubselectFetch subquery);
    public void RemoveSubselect(EntityKey key);
    public void ClearSubselects();
    public void AddBatchLoadableEntityKey(EntityKey key);
    public void RemoveBatchLoadableEntityKey(EntityKey key);
    public void AddBatchLoadableCollection(IPersistentCollection collection, CollectionEntry ce);
    internal IPersistentCollection GetBatchLoadableCollection(ICollectionPersister persister, CollectionEntry ce);
    public void RemoveBatchLoadableCollection(CollectionEntry ce);
    public Object[] GetCollectionBatch(ICollectionPersister collectionPersister, object id, int batchSize);
    internal Object[] GetCollectionBatch(ICollectionPersister collectionPersister, object key, int batchSize, bool checkCache, CollectionEntry[] collectionEntries);
    public Object[] GetEntityBatch(IEntityPersister persister, object id, int batchSize);
    internal Object[] GetEntityBatch(IEntityPersister persister, object id, int batchSize, bool checkCache);
    internal void InitializeQueryCacheQueue();
    internal void TerminateQueryCacheQueue();
    [CompilerGeneratedAttribute]
internal QueryCacheBatchQueue get_QueryCacheQueue();
    [CompilerGeneratedAttribute]
private void set_QueryCacheQueue(QueryCacheBatchQueue value);
    private Boolean[] AreCached(List`1<KeyValuePair`2<EntityKey, int>> entityKeys, Int32[] keyIndexes, IEntityPersister persister, CacheBase batchableCache, bool checkCache);
    private Boolean[] AreCached(List`1<KeyValuePair`2<KeyValuePair`2<CollectionEntry, IPersistentCollection>, int>> collectionKeys, Int32[] keyIndexes, ICollectionPersister persister, CacheBase batchableCache, bool checkCache);
    private static Int32[] GetSortedKeyIndexes(List`1<KeyValuePair`2<T, int>> keys, Nullable`1<int> keyIndex, int fromIndex, int toIndex);
    [CompilerGeneratedAttribute]
private bool <GetCollectionBatch>g__CheckCacheAndProcessResult|23_0(<>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <GetCollectionBatch>g__ProcessKey|23_1(KeyValuePair`2<CollectionEntry, IPersistentCollection> me, bool ignoreCache, <>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
private bool <GetEntityBatch>g__CheckCacheAndProcessResult|25_0(<>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <GetEntityBatch>g__ProcessKey|25_1(EntityKey key, bool ignoreCache, <>c__DisplayClass25_0& );
}
public class NHibernate.Engine.Cascade : object {
    private static INHibernateLogger log;
    private CascadePoint point;
    private IEventSource eventSource;
    private CascadingAction action;
    private Stack`1<string> componentPathStack;
    public Cascade(CascadingAction action, CascadePoint point, IEventSource eventSource);
    private static Cascade();
    public Task CascadeOnAsync(IEntityPersister persister, object parent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Cascade/<CascadeOnAsync>d__1")]
public Task CascadeOnAsync(IEntityPersister persister, object parent, object anything, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Cascade/<CascadePropertyAsync>d__2")]
private Task CascadePropertyAsync(object parent, object child, IType type, CascadeStyle style, string propertyName, object anything, bool isCascadeDeleteEnabled, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Cascade/<CascadeComponentAsync>d__3")]
private Task CascadeComponentAsync(object parent, object child, IAbstractComponentType componentType, string componentPropertyName, object anything, CancellationToken cancellationToken);
    private Task CascadeAssociationAsync(object parent, object child, IType type, CascadeStyle style, object anything, bool isCascadeDeleteEnabled, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Cascade/<CascadeCollectionAsync>d__5")]
private Task CascadeCollectionAsync(object parent, object child, CascadeStyle style, object anything, CollectionType type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Cascade/<CascadeToOneAsync>d__6")]
private Task CascadeToOneAsync(object parent, object child, IType type, CascadeStyle style, object anything, bool isCascadeDeleteEnabled, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Cascade/<CascadeCollectionElementsAsync>d__7")]
private Task CascadeCollectionElementsAsync(object parent, object child, CollectionType collectionType, CascadeStyle style, IType elemType, object anything, bool isCascadeDeleteEnabled, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Cascade/<DeleteOrphansAsync>d__8")]
private Task DeleteOrphansAsync(string entityName, IPersistentCollection pc, CancellationToken cancellationToken);
    public void CascadeOn(IEntityPersister persister, object parent);
    public void CascadeOn(IEntityPersister persister, object parent, object anything);
    private void CascadeProperty(object parent, object child, IType type, CascadeStyle style, string propertyName, object anything, bool isCascadeDeleteEnabled);
    private bool CascadeAssociationNow(IAssociationType associationType);
    private void CascadeComponent(object parent, object child, IAbstractComponentType componentType, string componentPropertyName, object anything);
    private void CascadeAssociation(object parent, object child, IType type, CascadeStyle style, object anything, bool isCascadeDeleteEnabled);
    private void CascadeCollection(object parent, object child, CascadeStyle style, object anything, CollectionType type);
    private void CascadeToOne(object parent, object child, IType type, CascadeStyle style, object anything, bool isCascadeDeleteEnabled);
    private void CascadeCollectionElements(object parent, object child, CollectionType collectionType, CascadeStyle style, IType elemType, object anything, bool isCascadeDeleteEnabled);
    private void DeleteOrphans(string entityName, IPersistentCollection pc);
}
public enum NHibernate.Engine.CascadePoint : Enum {
    public int value__;
    public static CascadePoint AfterInsertBeforeDelete;
    public static CascadePoint BeforeInsertAfterDelete;
    public static CascadePoint AfterInsertBeforeDeleteViaCollection;
    public static CascadePoint AfterUpdate;
    public static CascadePoint BeforeFlush;
    public static CascadePoint AfterEvict;
    public static CascadePoint BeforeRefresh;
    public static CascadePoint AfterLock;
    public static CascadePoint BeforeMerge;
}
public abstract class NHibernate.Engine.CascadeStyle : object {
    private static Dictionary`2<string, CascadeStyle> Styles;
    private static Dictionary`2<CascadeStyle, string> AliasByStyle;
    public static CascadeStyle AllDeleteOrphan;
    public static CascadeStyle All;
    public static CascadeStyle Update;
    public static CascadeStyle Lock;
    public static CascadeStyle Refresh;
    public static CascadeStyle Evict;
    public static CascadeStyle Replicate;
    public static CascadeStyle Merge;
    public static CascadeStyle Persist;
    public static CascadeStyle Delete;
    public static CascadeStyle DeleteOrphan;
    public static CascadeStyle None;
    public bool HasOrphanDelete { get; }
    private static CascadeStyle();
    public abstract virtual bool DoCascade(CascadingAction action);
    public virtual bool ReallyDoCascade(CascadingAction action);
    public virtual bool get_HasOrphanDelete();
    public static CascadeStyle GetCascadeStyle(string cascade);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.Engine.CascadingAction : object {
    private static INHibernateLogger log;
    public static CascadingAction Delete;
    public static CascadingAction Lock;
    public static CascadingAction Refresh;
    public static CascadingAction Evict;
    public static CascadingAction SaveUpdate;
    public static CascadingAction Merge;
    public static CascadingAction Persist;
    public static CascadingAction PersistOnFlush;
    public static CascadingAction Replicate;
    public bool DeleteOrphans { get; }
    public bool RequiresNoCascadeChecking { get; }
    public bool PerformOnLazyProperty { get; }
    private static CascadingAction();
    public abstract virtual Task CascadeAsync(IEventSource session, object child, string entityName, object anything, bool isCascadeDeleteEnabled, CancellationToken cancellationToken);
    public virtual Task NoCascadeAsync(IEventSource session, object child, object parent, IEntityPersister persister, int propertyIndex, CancellationToken cancellationToken);
    public abstract virtual void Cascade(IEventSource session, object child, string entityName, object anything, bool isCascadeDeleteEnabled);
    public abstract virtual IEnumerable GetCascadableChildrenIterator(IEventSource session, CollectionType collectionType, object collection);
    public abstract virtual bool get_DeleteOrphans();
    public virtual bool get_RequiresNoCascadeChecking();
    public virtual void NoCascade(IEventSource session, object child, object parent, IEntityPersister persister, int propertyIndex);
    public virtual bool get_PerformOnLazyProperty();
    private static IEnumerable GetAllElementsIterator(IEventSource session, CollectionType collectionType, object collection);
    public static IEnumerable GetLoadedElementsIterator(ISessionImplementor session, CollectionType collectionType, object collection);
    private static bool CollectionIsInitialized(object collection);
}
public class NHibernate.Engine.CollectionEntry : object {
    private static INHibernateLogger log;
    private object snapshot;
    private string role;
    private ICollectionPersister loadedPersister;
    private object loadedKey;
    private bool reached;
    private bool processed;
    private bool doupdate;
    private bool doremove;
    private bool dorecreate;
    private bool ignore;
    private ICollectionPersister currentPersister;
    private object currentKey;
    public object Key { get; }
    public string Role { get; public set; }
    public object Snapshot { get; }
    public bool IsReached { get; public set; }
    public bool IsProcessed { get; public set; }
    public bool IsDoupdate { get; public set; }
    public bool IsDoremove { get; public set; }
    public bool IsDorecreate { get; public set; }
    public bool IsIgnore { get; }
    public ICollectionPersister CurrentPersister { get; public set; }
    public object CurrentKey { get; public set; }
    public object LoadedKey { get; }
    public ICollectionPersister LoadedPersister { get; }
    public bool WasDereferenced { get; }
    public CollectionEntry(ICollectionPersister persister, IPersistentCollection collection);
    public CollectionEntry(IPersistentCollection collection, ICollectionPersister loadedPersister, object loadedKey, bool ignore);
    public CollectionEntry(ICollectionPersister loadedPersister, object loadedKey);
    internal CollectionEntry(IPersistentCollection collection, ISessionFactoryImplementor factory);
    private static CollectionEntry();
    [AsyncStateMachineAttribute("NHibernate.Engine.CollectionEntry/<DirtyAsync>d__0")]
private Task DirtyAsync(IPersistentCollection collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.CollectionEntry/<PreFlushAsync>d__1")]
public Task PreFlushAsync(IPersistentCollection collection, CancellationToken cancellationToken);
    public object get_Key();
    public string get_Role();
    public void set_Role(string value);
    public object get_Snapshot();
    public bool get_IsReached();
    public void set_IsReached(bool value);
    public bool get_IsProcessed();
    public void set_IsProcessed(bool value);
    public bool get_IsDoupdate();
    public void set_IsDoupdate(bool value);
    public bool get_IsDoremove();
    public void set_IsDoremove(bool value);
    public bool get_IsDorecreate();
    public void set_IsDorecreate(bool value);
    public bool get_IsIgnore();
    public ICollectionPersister get_CurrentPersister();
    public void set_CurrentPersister(ICollectionPersister value);
    public object get_CurrentKey();
    public void set_CurrentKey(object value);
    public object get_LoadedKey();
    public ICollectionPersister get_LoadedPersister();
    public bool get_WasDereferenced();
    private void Dirty(IPersistentCollection collection);
    public void PreFlush(IPersistentCollection collection);
    [ObsoleteAttribute("Please use PostInitialize(collection, persistenceContext) instead.")]
public void PostInitialize(IPersistentCollection collection);
    public void PostInitialize(IPersistentCollection collection, IPersistenceContext persistenceContext);
    public void PostFlush(IPersistentCollection collection);
    public void AfterAction(IPersistentCollection collection);
    private void SetLoadedPersister(ICollectionPersister persister);
    internal void AfterDeserialize(ISessionFactoryImplementor factory);
    public ICollection GetOrphans(string entityName, IPersistentCollection collection);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public Task`1<ICollection> GetOrphansAsync(string entityName, IPersistentCollection collection, CancellationToken cancellationToken);
    public bool IsSnapshotEmpty(IPersistentCollection collection);
    public virtual string ToString();
}
public class NHibernate.Engine.CollectionKey : object {
    private string role;
    private object key;
    private IType keyType;
    private ISessionFactoryImplementor factory;
    private Nullable`1<int> _hashCode;
    public string Role { get; }
    public object Key { get; }
    public CollectionKey(ICollectionPersister persister, object key);
    private CollectionKey(string role, object key, IType keyType, ISessionFactoryImplementor factory);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void OnDeserialization(object sender);
    private int GenerateHashCode();
    public string get_Role();
    public object get_Key();
    public virtual string ToString();
}
public static class NHibernate.Engine.Collections : object {
    private static INHibernateLogger log;
    private static Collections();
    public static Task ProcessUnreachableCollectionAsync(IPersistentCollection coll, ISessionImplementor session, CancellationToken cancellationToken);
    private static Task ProcessDereferencedCollectionAsync(IPersistentCollection coll, ISessionImplementor session, CancellationToken cancellationToken);
    private static Task ProcessNeverReferencedCollectionAsync(IPersistentCollection coll, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Collections/<ProcessReachableCollectionAsync>d__3")]
public static Task ProcessReachableCollectionAsync(IPersistentCollection collection, CollectionType type, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    private static Task PrepareCollectionForUpdateAsync(IPersistentCollection collection, CollectionEntry entry, ISessionFactoryImplementor factory, CancellationToken cancellationToken);
    public static void ProcessUnreachableCollection(IPersistentCollection coll, ISessionImplementor session);
    private static void ProcessDereferencedCollection(IPersistentCollection coll, ISessionImplementor session);
    private static void ProcessNeverReferencedCollection(IPersistentCollection coll, ISessionImplementor session);
    public static void ProcessReachableCollection(IPersistentCollection collection, CollectionType type, object entity, ISessionImplementor session);
    private static void PrepareCollectionForUpdate(IPersistentCollection collection, CollectionEntry entry, ISessionFactoryImplementor factory);
}
public class NHibernate.Engine.EntityEntry : object {
    private LockMode lockMode;
    private Status status;
    private Nullable`1<Status> previousStatus;
    private object id;
    private Object[] loadedState;
    private Object[] deletedState;
    private bool existsInDatabase;
    private object version;
    private IEntityPersister persister;
    private string entityName;
    private EntityKey cachedEntityKey;
    private bool isBeingReplicated;
    private bool loadedWithLazyPropertiesUnfetched;
    private object rowId;
    public LockMode LockMode { get; public set; }
    public Status Status { get; public set; }
    public object Id { get; }
    public Object[] LoadedState { get; }
    public Object[] DeletedState { get; public set; }
    public bool ExistsInDatabase { get; }
    public object Version { get; }
    public IEntityPersister Persister { get; internal set; }
    public string EntityName { get; }
    public bool IsBeingReplicated { get; }
    public object RowId { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public bool LoadedWithLazyPropertiesUnfetched { get; }
    public EntityKey EntityKey { get; }
    public bool IsReadOnly { get; }
    [ObsoleteAttribute("Use the constructor without lazyPropertiesAreUnfetched parameter")]
internal EntityEntry(Status status, Object[] loadedState, object rowId, object id, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement, bool lazyPropertiesAreUnfetched);
    internal EntityEntry(Status status, Object[] loadedState, object rowId, object id, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement);
    public LockMode get_LockMode();
    public void set_LockMode(LockMode value);
    public Status get_Status();
    public void set_Status(Status value);
    public object get_Id();
    public Object[] get_LoadedState();
    public Object[] get_DeletedState();
    public void set_DeletedState(Object[] value);
    public bool get_ExistsInDatabase();
    public object get_Version();
    public IEntityPersister get_Persister();
    internal void set_Persister(IEntityPersister value);
    public string get_EntityName();
    public bool get_IsBeingReplicated();
    public object get_RowId();
    public bool get_LoadedWithLazyPropertiesUnfetched();
    public EntityKey get_EntityKey();
    public object GetLoadedValue(string propertyName);
    public void PostInsert();
    public void PostUpdate(object entity, Object[] updatedState, object nextVersion);
    public void PostDelete();
    public void ForceLocked(object entity, object nextVersion);
    public bool IsNullifiable(bool earlyInsert, ISessionImplementor session);
    public bool RequiresDirtyCheck(object entity);
    public bool IsModifiableEntity();
    public bool get_IsReadOnly();
    public void SetReadOnly(bool readOnly, object entity);
    public virtual string ToString();
}
public class NHibernate.Engine.EntityKey : object {
    private object identifier;
    private IEntityPersister _persister;
    private int _hashCode;
    public bool IsBatchLoadable { get; }
    public object Identifier { get; }
    public string EntityName { get; }
    internal string RootEntityName { get; }
    public EntityKey(object id, IEntityPersister persister);
    private EntityKey(SerializationInfo info, StreamingContext context);
    public bool get_IsBatchLoadable();
    public object get_Identifier();
    public string get_EntityName();
    internal string get_RootEntityName();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(EntityKey other);
    public virtual int GetHashCode();
    private static int GenerateHashCode(IEntityPersister persister, object id);
    public virtual string ToString();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("IDeserializationCallback interface has no usages and will be removed in a future version")]
public sealed virtual void OnDeserialization(object sender);
}
public class NHibernate.Engine.EntityUniqueKey : object {
    private string entityName;
    private string uniqueKeyName;
    private object key;
    private IType keyType;
    private ISessionFactoryImplementor _factory;
    private Nullable`1<int> _hashCode;
    public string EntityName { get; }
    public object Key { get; }
    public string UniqueKeyName { get; }
    public EntityUniqueKey(string entityName, string uniqueKeyName, object semiResolvedKey, IType keyType, ISessionFactoryImplementor factory);
    public string get_EntityName();
    public object get_Key();
    public string get_UniqueKeyName();
    public virtual int GetHashCode();
    public sealed virtual void OnDeserialization(object sender);
    public int GenerateHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(EntityUniqueKey that);
    public virtual string ToString();
}
public class NHibernate.Engine.ExecuteUpdateResultCheckStyle : object {
    public static ExecuteUpdateResultCheckStyle None;
    public static ExecuteUpdateResultCheckStyle Count;
    private string name;
    private ExecuteUpdateResultCheckStyle(string name);
    private static ExecuteUpdateResultCheckStyle();
    public static ExecuteUpdateResultCheckStyle Parse(string name);
    public static ExecuteUpdateResultCheckStyle DetermineDefault(SqlString customSql, bool callable);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NHibernate.Engine.FilterDefinition : object {
    private string filterName;
    private string defaultFilterCondition;
    private IDictionary`2<string, IType> parameterTypes;
    private bool useInManyToOne;
    public bool UseInManyToOne { get; }
    public string FilterName { get; }
    public ICollection`1<string> ParameterNames { get; }
    public string DefaultFilterCondition { get; }
    public IDictionary`2<string, IType> ParameterTypes { get; }
    public FilterDefinition(string name, string defaultCondition, IDictionary`2<string, IType> parameterTypes, bool useManyToOne);
    public bool get_UseInManyToOne();
    public string get_FilterName();
    public ICollection`1<string> get_ParameterNames();
    public IType GetParameterType(string parameterName);
    public string get_DefaultFilterCondition();
    public IDictionary`2<string, IType> get_ParameterTypes();
}
public static class NHibernate.Engine.ForeignKeys : object {
    private static INHibernateLogger log;
    private static ForeignKeys();
    [AsyncStateMachineAttribute("NHibernate.Engine.ForeignKeys/<IsNotTransientSlowAsync>d__1")]
public static Task`1<bool> IsNotTransientSlowAsync(string entityName, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ForeignKeys/<IsTransientFastAsync>d__2")]
public static Task`1<Nullable`1<bool>> IsTransientFastAsync(string entityName, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ForeignKeys/<IsTransientSlowAsync>d__3")]
public static Task`1<bool> IsTransientSlowAsync(string entityName, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ForeignKeys/<HasDbSnapshotAsync>d__4")]
private static Task`1<bool> HasDbSnapshotAsync(string entityName, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.ForeignKeys/<GetEntityIdentifierIfNotUnsavedAsync>d__5")]
public static Task`1<object> GetEntityIdentifierIfNotUnsavedAsync(string entityName, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    public static bool IsNotTransientSlow(string entityName, object entity, ISessionImplementor session);
    public static Nullable`1<bool> IsTransientFast(string entityName, object entity, ISessionImplementor session);
    public static bool IsTransientSlow(string entityName, object entity, ISessionImplementor session);
    private static bool HasDbSnapshot(string entityName, object entity, ISessionImplementor session);
    internal static object GetIdentifier(IEntityPersister persister, object entity);
    public static object GetEntityIdentifierIfNotUnsaved(string entityName, object entity, ISessionImplementor session);
}
public interface NHibernate.Engine.IBatcher {
    public bool HasOpenResources { get; }
    public int BatchSize { get; public set; }
    public abstract virtual Task`1<DbCommand> PrepareCommandAsync(CommandType commandType, SqlString sql, SqlType[] parameterTypes, CancellationToken cancellationToken);
    public abstract virtual Task`1<DbCommand> PrepareBatchCommandAsync(CommandType commandType, SqlString sql, SqlType[] parameterTypes, CancellationToken cancellationToken);
    public abstract virtual Task AddToBatchAsync(IExpectation expectation, CancellationToken cancellationToken);
    public abstract virtual Task ExecuteBatchAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<DbDataReader> ExecuteReaderAsync(DbCommand cmd, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> ExecuteNonQueryAsync(DbCommand cmd, CancellationToken cancellationToken);
    public abstract virtual DbCommand PrepareQueryCommand(CommandType commandType, SqlString sql, SqlType[] parameterTypes);
    public abstract virtual DbCommand PrepareCommand(CommandType commandType, SqlString sql, SqlType[] parameterTypes);
    public abstract virtual void CloseCommand(DbCommand cmd, DbDataReader reader);
    public abstract virtual void CloseReader(DbDataReader reader);
    public abstract virtual DbCommand PrepareBatchCommand(CommandType commandType, SqlString sql, SqlType[] parameterTypes);
    public abstract virtual void AddToBatch(IExpectation expectation);
    public abstract virtual void ExecuteBatch();
    public abstract virtual void CloseCommands();
    public abstract virtual DbDataReader ExecuteReader(DbCommand cmd);
    public abstract virtual int ExecuteNonQuery(DbCommand cmd);
    public abstract virtual void AbortBatch(Exception e);
    public abstract virtual void CancelLastQuery();
    public abstract virtual bool get_HasOpenResources();
    public abstract virtual int get_BatchSize();
    public abstract virtual void set_BatchSize(int value);
}
public class NHibernate.Engine.IdentifierValue : object {
    private static INHibernateLogger log;
    private object value;
    private static string UnsavedStrategyLog;
    public static IdentifierValue SaveAny;
    public static IdentifierValue SaveNone;
    public static IdentifierValue SaveNull;
    public static IdentifierValue Undefined;
    public IdentifierValue(object value);
    private static IdentifierValue();
    public virtual Nullable`1<bool> IsUnsaved(object id);
    public virtual object GetDefaultValue(object currentValue);
}
public class NHibernate.Engine.IdPropertiesLhsAssociationTypeSqlInfo : AbstractLhsAssociationTypeSqlInfo {
    public IdPropertiesLhsAssociationTypeSqlInfo(string alias, IOuterJoinLoadable persister, IMapping mapping);
    protected virtual String[] GetAliasedColumns();
    protected virtual String[] GetColumns();
    public virtual string GetTableName(IAssociationType type);
}
internal interface NHibernate.Engine.IJoin {
    public IJoinable Joinable { get; }
    public String[] LHSColumns { get; }
    public String[] RHSColumns { get; }
    public string Alias { get; }
    public IAssociationType AssociationType { get; }
    public JoinType JoinType { get; }
    public abstract virtual IJoinable get_Joinable();
    public abstract virtual String[] get_LHSColumns();
    public abstract virtual String[] get_RHSColumns();
    public abstract virtual string get_Alias();
    public abstract virtual IAssociationType get_AssociationType();
    public abstract virtual JoinType get_JoinType();
}
public interface NHibernate.Engine.ILhsAssociationTypeSqlInfo {
    public abstract virtual String[] GetAliasedColumnNames(IAssociationType type, int begin);
    public abstract virtual String[] GetColumnNames(IAssociationType type, int begin);
    public abstract virtual string GetTableName(IAssociationType type);
}
public interface NHibernate.Engine.IMapping {
    public Dialect Dialect { get; }
    public abstract virtual IType GetIdentifierType(string className);
    public abstract virtual string GetIdentifierPropertyName(string className);
    public abstract virtual IType GetReferencedPropertyType(string className, string propertyName);
    public abstract virtual bool HasNonIdentifierPropertyNamedId(string className);
    public abstract virtual Dialect get_Dialect();
}
public interface NHibernate.Engine.IPersistenceContext {
    public bool IsStateless { get; }
    public ISessionImplementor Session { get; }
    public LoadContexts LoadContexts { get; }
    public BatchFetchQueue BatchFetchQueue { get; }
    public ISet`1<EntityKey> NullifiableEntityKeys { get; }
    public IDictionary`2<EntityKey, object> EntitiesByKey { get; }
    public IDictionary EntityEntries { get; }
    public IDictionary CollectionEntries { get; }
    public IDictionary`2<CollectionKey, IPersistentCollection> CollectionsByKey { get; }
    public int CascadeLevel { get; }
    public bool Flushing { get; public set; }
    public bool DefaultReadOnly { get; public set; }
    public bool HasNonReadOnlyEntities { get; }
    public bool IsLoadFinished { get; }
    public abstract virtual Task`1<Object[]> GetDatabaseSnapshotAsync(object id, IEntityPersister persister, CancellationToken cancellationToken);
    public abstract virtual Task`1<Object[]> GetNaturalIdSnapshotAsync(object id, IEntityPersister persister, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> UnproxyAndReassociateAsync(object maybeProxy, CancellationToken cancellationToken);
    public abstract virtual Task InitializeNonLazyCollectionsAsync(CancellationToken cancellationToken);
    public abstract virtual bool get_IsStateless();
    public abstract virtual ISessionImplementor get_Session();
    public abstract virtual LoadContexts get_LoadContexts();
    public abstract virtual BatchFetchQueue get_BatchFetchQueue();
    public abstract virtual ISet`1<EntityKey> get_NullifiableEntityKeys();
    public abstract virtual IDictionary`2<EntityKey, object> get_EntitiesByKey();
    public abstract virtual IDictionary get_EntityEntries();
    public abstract virtual IDictionary get_CollectionEntries();
    public abstract virtual IDictionary`2<CollectionKey, IPersistentCollection> get_CollectionsByKey();
    public abstract virtual int get_CascadeLevel();
    public abstract virtual bool get_Flushing();
    public abstract virtual void set_Flushing(bool value);
    public abstract virtual bool get_DefaultReadOnly();
    public abstract virtual void set_DefaultReadOnly(bool value);
    public abstract virtual void AddUnownedCollection(CollectionKey key, IPersistentCollection collection);
    public abstract virtual IPersistentCollection UseUnownedCollection(CollectionKey key);
    public abstract virtual void Clear();
    public abstract virtual bool get_HasNonReadOnlyEntities();
    public abstract virtual void SetEntryStatus(EntityEntry entry, Status status);
    public abstract virtual void AfterTransactionCompletion();
    public abstract virtual Object[] GetDatabaseSnapshot(object id, IEntityPersister persister);
    public abstract virtual Object[] GetCachedDatabaseSnapshot(EntityKey key);
    public abstract virtual Object[] GetNaturalIdSnapshot(object id, IEntityPersister persister);
    public abstract virtual void AddEntity(EntityKey key, object entity);
    public abstract virtual object GetEntity(EntityKey key);
    public abstract virtual bool ContainsEntity(EntityKey key);
    public abstract virtual object RemoveEntity(EntityKey key);
    public abstract virtual object GetEntity(EntityUniqueKey euk);
    public abstract virtual void AddEntity(EntityUniqueKey euk, object entity);
    public abstract virtual EntityEntry GetEntry(object entity);
    public abstract virtual EntityEntry RemoveEntry(object entity);
    public abstract virtual bool IsEntryFor(object entity);
    public abstract virtual CollectionEntry GetCollectionEntry(IPersistentCollection coll);
    [ObsoleteAttribute("Use the AddEntity extension method instead")]
public abstract virtual EntityEntry AddEntity(object entity, Status status, Object[] loadedState, EntityKey entityKey, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement, bool lazyPropertiesAreUnfetched);
    [ObsoleteAttribute("Use the AddEntry extension method instead")]
public abstract virtual EntityEntry AddEntry(object entity, Status status, Object[] loadedState, object rowId, object id, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement, bool lazyPropertiesAreUnfetched);
    public abstract virtual bool ContainsCollection(IPersistentCollection collection);
    public abstract virtual bool ContainsProxy(INHibernateProxy proxy);
    public abstract virtual bool ReassociateIfUninitializedProxy(object value);
    public abstract virtual void ReassociateProxy(object value, object id);
    public abstract virtual object Unproxy(object maybeProxy);
    public abstract virtual object UnproxyAndReassociate(object maybeProxy);
    public abstract virtual void CheckUniqueness(EntityKey key, object obj);
    public abstract virtual object NarrowProxy(INHibernateProxy proxy, IEntityPersister persister, EntityKey key, object obj);
    public abstract virtual object ProxyFor(IEntityPersister persister, EntityKey key, object impl);
    public abstract virtual object ProxyFor(object impl);
    public abstract virtual object GetCollectionOwner(object key, ICollectionPersister collectionPersister);
    public abstract virtual object GetLoadedCollectionOwnerOrNull(IPersistentCollection collection);
    public abstract virtual object GetLoadedCollectionOwnerIdOrNull(IPersistentCollection collection);
    public abstract virtual void AddUninitializedCollection(ICollectionPersister persister, IPersistentCollection collection, object id);
    public abstract virtual void AddUninitializedDetachedCollection(ICollectionPersister persister, IPersistentCollection collection);
    public abstract virtual void AddNewCollection(ICollectionPersister persister, IPersistentCollection collection);
    public abstract virtual void AddInitializedDetachedCollection(ICollectionPersister collectionPersister, IPersistentCollection collection);
    public abstract virtual CollectionEntry AddInitializedCollection(ICollectionPersister persister, IPersistentCollection collection, object id);
    public abstract virtual IPersistentCollection GetCollection(CollectionKey collectionKey);
    public abstract virtual void AddNonLazyCollection(IPersistentCollection collection);
    public abstract virtual void InitializeNonLazyCollections();
    public abstract virtual IPersistentCollection GetCollectionHolder(object array);
    public abstract virtual void AddCollectionHolder(IPersistentCollection holder);
    public abstract virtual IPersistentCollection RemoveCollectionHolder(object array);
    public abstract virtual object GetSnapshot(IPersistentCollection coll);
    public abstract virtual CollectionEntry GetCollectionEntryOrNull(object collection);
    public abstract virtual object GetProxy(EntityKey key);
    public abstract virtual void AddProxy(EntityKey key, INHibernateProxy proxy);
    public abstract virtual object RemoveProxy(EntityKey key);
    public abstract virtual int IncrementCascadeLevel();
    public abstract virtual int DecrementCascadeLevel();
    public abstract virtual void BeforeLoad();
    public abstract virtual void AfterLoad();
    public abstract virtual object GetOwnerId(string entity, string property, object childObject, IDictionary mergeMap);
    public abstract virtual object GetIndexInOwner(string entity, string property, object childObject, IDictionary mergeMap);
    public abstract virtual void AddNullProperty(EntityKey ownerKey, string propertyName);
    public abstract virtual bool IsPropertyNull(EntityKey ownerKey, string propertyName);
    public abstract virtual void SetReadOnly(object entityOrProxy, bool readOnly);
    public abstract virtual bool IsReadOnly(object entityOrProxy);
    public abstract virtual void ReplaceDelayedEntityIdentityInsertKeys(EntityKey oldKey, object generatedId);
    public abstract virtual bool get_IsLoadFinished();
    public abstract virtual void AddChildParent(object child, object parent);
    public abstract virtual void RemoveChildParent(object child);
}
public interface NHibernate.Engine.ISessionFactoryImplementor {
    public IInterceptor Interceptor { get; }
    public QueryPlanCache QueryPlanCache { get; }
    public IConnectionProvider ConnectionProvider { get; }
    public ITransactionFactory TransactionFactory { get; }
    public UpdateTimestampsCache UpdateTimestampsCache { get; }
    public IStatisticsImplementor StatisticsImplementor { get; }
    public ISQLExceptionConverter SQLExceptionConverter { get; }
    public Settings Settings { get; }
    public IEntityNotFoundDelegate EntityNotFoundDelegate { get; }
    public SQLFunctionRegistry SQLFunctionRegistry { get; }
    public IQueryCache QueryCache { get; }
    public ICurrentSessionContext CurrentSessionContext { get; }
    public abstract virtual IInterceptor get_Interceptor();
    public abstract virtual QueryPlanCache get_QueryPlanCache();
    public abstract virtual IConnectionProvider get_ConnectionProvider();
    public abstract virtual ITransactionFactory get_TransactionFactory();
    public abstract virtual UpdateTimestampsCache get_UpdateTimestampsCache();
    public abstract virtual IStatisticsImplementor get_StatisticsImplementor();
    public abstract virtual ISQLExceptionConverter get_SQLExceptionConverter();
    public abstract virtual Settings get_Settings();
    public abstract virtual IEntityNotFoundDelegate get_EntityNotFoundDelegate();
    public abstract virtual SQLFunctionRegistry get_SQLFunctionRegistry();
    public abstract virtual IDictionary`2<string, ICache> GetAllSecondLevelCacheRegions();
    public abstract virtual IEntityPersister GetEntityPersister(string entityName);
    public abstract virtual ICollectionPersister GetCollectionPersister(string role);
    public abstract virtual IType[] GetReturnTypes(string queryString);
    public abstract virtual String[] GetReturnAliases(string queryString);
    public abstract virtual String[] GetImplementors(string entityOrClassName);
    public abstract virtual string GetImportedClassName(string name);
    public abstract virtual IQueryCache get_QueryCache();
    public abstract virtual IQueryCache GetQueryCache(string regionName);
    public abstract virtual NamedQueryDefinition GetNamedQuery(string queryName);
    public abstract virtual NamedSQLQueryDefinition GetNamedSQLQuery(string queryName);
    public abstract virtual ResultSetMappingDefinition GetResultSetMapping(string resultSetRef);
    public abstract virtual IIdentifierGenerator GetIdentifierGenerator(string rootEntityName);
    public abstract virtual ICache GetSecondLevelCacheRegion(string regionName);
    [ObsoleteAttribute("Please use WithOptions() instead.")]
public abstract virtual ISession OpenSession(DbConnection connection, bool flushBeforeCompletionEnabled, bool autoCloseSessionEnabled, ConnectionReleaseMode connectionReleaseMode);
    public abstract virtual ISet`1<string> GetCollectionRolesByEntityParticipant(string entityName);
    public abstract virtual ICurrentSessionContext get_CurrentSessionContext();
    public abstract virtual IEntityPersister TryGetEntityPersister(string entityName);
    public abstract virtual string TryGetGuessEntityName(Type implementor);
}
public interface NHibernate.Engine.ISessionImplementor {
    public long Timestamp { get; }
    public ISessionFactoryImplementor Factory { get; }
    public IBatcher Batcher { get; }
    public IDictionary`2<string, IFilter> EnabledFilters { get; }
    public IInterceptor Interceptor { get; }
    public EventListeners Listeners { get; }
    public ConnectionManager ConnectionManager { get; }
    public bool IsEventSource { get; }
    public IPersistenceContext PersistenceContext { get; }
    public CacheMode CacheMode { get; public set; }
    public bool IsOpen { get; }
    public bool IsConnected { get; }
    public FlushMode FlushMode { get; public set; }
    public string FetchProfile { get; public set; }
    public DbConnection Connection { get; }
    public bool IsClosed { get; }
    public bool TransactionInProgress { get; }
    [ObsoleteAttribute("Replaced by FutureBatch")]
public FutureCriteriaBatch FutureCriteriaBatch { get; }
    [ObsoleteAttribute("Replaced by FutureBatch")]
public FutureQueryBatch FutureQueryBatch { get; }
    public Guid SessionId { get; }
    public ITransactionContext TransactionContext { get; public set; }
    public abstract virtual Task InitializeCollectionAsync(IPersistentCollection collection, bool writing, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> InternalLoadAsync(string entityName, object id, bool eager, bool isNullable, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ImmediateLoadAsync(string entityName, object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList> ListAsync(IQueryExpression queryExpression, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task ListAsync(IQueryExpression queryExpression, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListAsync(CriteriaImpl criteria, CancellationToken cancellationToken);
    public abstract virtual Task ListAsync(CriteriaImpl criteria, IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList> ListAsync(CriteriaImpl criteria, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> EnumerableAsync(IQueryExpression query, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<T>> EnumerableAsync(IQueryExpression query, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList> ListFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList> ListFilterAsync(object collection, IQueryExpression queryExpression, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> EnumerableFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<T>> EnumerableFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task BeforeTransactionCompletionAsync(ITransaction tx, CancellationToken cancellationToken);
    public abstract virtual Task FlushBeforeTransactionCompletionAsync(CancellationToken cancellationToken);
    public abstract virtual Task AfterTransactionCompletionAsync(bool successful, ITransaction tx, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList> ListAsync(NativeSQLQuerySpecification spec, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task ListAsync(NativeSQLQuerySpecification spec, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListAsync(NativeSQLQuerySpecification spec, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task ListCustomQueryAsync(ICustomQuery customQuery, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListCustomQueryAsync(ICustomQuery customQuery, QueryParameters queryParameters, CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public abstract virtual Task`1<IQueryTranslator[]> GetQueriesAsync(IQueryExpression query, bool scalar, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetEntityUsingInterceptorAsync(EntityKey key, CancellationToken cancellationToken);
    public abstract virtual Task FlushAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<int> ExecuteNativeUpdateAsync(NativeSQLQuerySpecification specification, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> ExecuteUpdateAsync(IQueryExpression query, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IQuery> CreateFilterAsync(object collection, IQueryExpression queryExpression, CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no more usages in NHibernate and will be removed.")]
public abstract virtual void Initialize();
    public abstract virtual void InitializeCollection(IPersistentCollection collection, bool writing);
    public abstract virtual object InternalLoad(string entityName, object id, bool eager, bool isNullable);
    public abstract virtual object ImmediateLoad(string entityName, object id);
    public abstract virtual long get_Timestamp();
    public abstract virtual ISessionFactoryImplementor get_Factory();
    public abstract virtual IBatcher get_Batcher();
    public abstract virtual IList List(IQueryExpression queryExpression, QueryParameters parameters);
    public abstract virtual IQuery CreateQuery(IQueryExpression queryExpression);
    public abstract virtual void List(IQueryExpression queryExpression, QueryParameters queryParameters, IList results);
    public abstract virtual IList`1<T> List(IQueryExpression queryExpression, QueryParameters queryParameters);
    public abstract virtual IList`1<T> List(CriteriaImpl criteria);
    public abstract virtual void List(CriteriaImpl criteria, IList results);
    public abstract virtual IList List(CriteriaImpl criteria);
    public abstract virtual IEnumerable Enumerable(IQueryExpression query, QueryParameters parameters);
    public abstract virtual IEnumerable`1<T> Enumerable(IQueryExpression query, QueryParameters queryParameters);
    public abstract virtual IList ListFilter(object collection, string filter, QueryParameters parameters);
    public abstract virtual IList ListFilter(object collection, IQueryExpression queryExpression, QueryParameters parameters);
    public abstract virtual IList`1<T> ListFilter(object collection, string filter, QueryParameters parameters);
    public abstract virtual IEnumerable EnumerableFilter(object collection, string filter, QueryParameters parameters);
    public abstract virtual IEnumerable`1<T> EnumerableFilter(object collection, string filter, QueryParameters parameters);
    public abstract virtual IEntityPersister GetEntityPersister(string entityName, object obj);
    public abstract virtual void AfterTransactionBegin(ITransaction tx);
    public abstract virtual void BeforeTransactionCompletion(ITransaction tx);
    public abstract virtual void FlushBeforeTransactionCompletion();
    public abstract virtual void AfterTransactionCompletion(bool successful, ITransaction tx);
    public abstract virtual object GetContextEntityIdentifier(object obj);
    public abstract virtual object Instantiate(string entityName, object id);
    public abstract virtual IList List(NativeSQLQuerySpecification spec, QueryParameters queryParameters);
    public abstract virtual void List(NativeSQLQuerySpecification spec, QueryParameters queryParameters, IList results);
    public abstract virtual IList`1<T> List(NativeSQLQuerySpecification spec, QueryParameters queryParameters);
    public abstract virtual void ListCustomQuery(ICustomQuery customQuery, QueryParameters queryParameters, IList results);
    public abstract virtual IList`1<T> ListCustomQuery(ICustomQuery customQuery, QueryParameters queryParameters);
    public abstract virtual object GetFilterParameterValue(string filterParameterName);
    public abstract virtual IType GetFilterParameterType(string filterParameterName);
    public abstract virtual IDictionary`2<string, IFilter> get_EnabledFilters();
    public abstract virtual IQuery GetNamedSQLQuery(string name);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public abstract virtual IQueryTranslator[] GetQueries(IQueryExpression query, bool scalar);
    public abstract virtual IInterceptor get_Interceptor();
    public abstract virtual EventListeners get_Listeners();
    public abstract virtual ConnectionManager get_ConnectionManager();
    public abstract virtual bool get_IsEventSource();
    public abstract virtual object GetEntityUsingInterceptor(EntityKey key);
    public abstract virtual IPersistenceContext get_PersistenceContext();
    public abstract virtual CacheMode get_CacheMode();
    public abstract virtual void set_CacheMode(CacheMode value);
    public abstract virtual bool get_IsOpen();
    public abstract virtual bool get_IsConnected();
    public abstract virtual FlushMode get_FlushMode();
    public abstract virtual void set_FlushMode(FlushMode value);
    public abstract virtual string get_FetchProfile();
    public abstract virtual void set_FetchProfile(string value);
    public abstract virtual string BestGuessEntityName(object entity);
    public abstract virtual string GuessEntityName(object entity);
    public abstract virtual DbConnection get_Connection();
    public abstract virtual IQuery GetNamedQuery(string queryName);
    public abstract virtual bool get_IsClosed();
    public abstract virtual void Flush();
    public abstract virtual bool get_TransactionInProgress();
    public abstract virtual int ExecuteNativeUpdate(NativeSQLQuerySpecification specification, QueryParameters queryParameters);
    public abstract virtual int ExecuteUpdate(IQueryExpression query, QueryParameters queryParameters);
    public abstract virtual FutureCriteriaBatch get_FutureCriteriaBatch();
    public abstract virtual FutureQueryBatch get_FutureQueryBatch();
    public abstract virtual Guid get_SessionId();
    public abstract virtual ITransactionContext get_TransactionContext();
    public abstract virtual void set_TransactionContext(ITransactionContext value);
    public abstract virtual void JoinTransaction();
    public abstract virtual void CloseSessionFromSystemTransaction();
    public abstract virtual IQuery CreateFilter(object collection, IQueryExpression queryExpression);
    public abstract virtual EntityKey GenerateEntityKey(object id, IEntityPersister persister);
    public abstract virtual CacheKey GenerateCacheKey(object id, IType type, string entityOrRoleName);
}
public static class NHibernate.Engine.JoinHelper : object {
    public static ILhsAssociationTypeSqlInfo GetLhsSqlInfo(string alias, int property, IOuterJoinLoadable lhsPersister, IMapping mapping);
    public static ILhsAssociationTypeSqlInfo GetIdLhsSqlInfo(string alias, IOuterJoinLoadable lhsPersister, IMapping mapping);
    public static String[] GetRHSColumnNames(IAssociationType type, ISessionFactoryImplementor factory);
    public static String[] GetRHSColumnNames(IJoinable joinable, IAssociationType type);
}
public class NHibernate.Engine.JoinSequence : object {
    private ISessionFactoryImplementor factory;
    private List`1<Join> joins;
    private bool useThetaStyle;
    private SqlStringBuilder conditions;
    private string rootAlias;
    private IJoinable rootJoinable;
    private ISelector selector;
    private JoinSequence next;
    private bool isFromPart;
    [CompilerGeneratedAttribute]
private bool <ForceFilter>k__BackingField;
    public bool IsThetaStyle { get; }
    public int JoinCount { get; }
    internal string RootAlias { get; }
    public ISessionFactoryImplementor Factory { get; }
    internal bool ForceFilter { get; internal set; }
    public JoinSequence(ISessionFactoryImplementor factory);
    public virtual string ToString();
    public JoinSequence GetFromPart();
    public JoinSequence Copy();
    public JoinSequence AddJoin(IAssociationType associationType, string alias, JoinType joinType, String[] referencingKey);
    public JoinFragment ToJoinFragment();
    public JoinFragment ToJoinFragment(IDictionary`2<string, IFilter> enabledFilters, bool includeExtraJoins);
    public JoinFragment ToJoinFragment(IDictionary`2<string, IFilter> enabledFilters, bool includeAllSubclassJoins, SqlString withClause);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public JoinFragment ToJoinFragment(IDictionary`2<string, IFilter> enabledFilters, bool includeExtraJoins, SqlString withClauseFragment, string withClauseJoinAlias);
    internal virtual JoinFragment ToJoinFragment(IDictionary`2<string, IFilter> enabledFilters, bool includeAllSubclassJoins, bool renderSubclassJoins, SqlString withClauseFragment);
    private SqlString GetWithClause(IDictionary`2<string, IFilter> enabledFilters, Join join, IJoinable last, SqlString& withClauseFragment);
    private bool IsManyToManyRoot(IJoinable joinable);
    private bool IsIncluded(string alias);
    private void AddSubclassJoins(JoinFragment joinFragment, string alias, IJoinable joinable, bool innerJoin, bool includeSubclassJoins);
    public JoinSequence AddCondition(SqlString condition);
    public JoinSequence AddCondition(string alias, String[] columns, string condition, bool appendParameter);
    public JoinSequence SetRoot(IJoinable joinable, string alias);
    public JoinSequence SetNext(JoinSequence next);
    public JoinSequence SetSelector(ISelector s);
    public JoinSequence SetUseThetaStyle(bool useThetaStyle);
    public bool get_IsThetaStyle();
    public int get_JoinCount();
    internal string get_RootAlias();
    public ISessionFactoryImplementor get_Factory();
    [CompilerGeneratedAttribute]
internal bool get_ForceFilter();
    [CompilerGeneratedAttribute]
internal void set_ForceFilter(bool value);
    public JoinSequence AddJoin(FromElement fromElement);
    internal void SetJoinType(JoinType joinType);
    [CompilerGeneratedAttribute]
private bool <ToJoinFragment>b__19_0(string alias);
}
public class NHibernate.Engine.Loading.CollectionLoadContext : object {
    private static INHibernateLogger log;
    private LoadContexts loadContexts;
    private DbDataReader resultSet;
    private HashSet`1<CollectionKey> localLoadingCollectionKeys;
    public LoadContexts LoadContext { get; }
    public DbDataReader ResultSet { get; }
    public CollectionLoadContext(LoadContexts loadContexts, DbDataReader resultSet);
    private static CollectionLoadContext();
    [ObsoleteAttribute("Please use overload with skipCache and cacheBatcher parameter instead.")]
public Task EndLoadingCollectionsAsync(ICollectionPersister persister, CancellationToken cancellationToken);
    [ObsoleteAttribute("Please use overload with cacheBatcher parameter instead.")]
public Task EndLoadingCollectionsAsync(ICollectionPersister persister, bool skipCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Loading.CollectionLoadContext/<EndLoadingCollectionsAsync>d__2")]
public Task EndLoadingCollectionsAsync(ICollectionPersister persister, bool skipCache, CacheBatcher cacheBatcher, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Loading.CollectionLoadContext/<EndLoadingCollectionsAsync>d__3")]
private Task EndLoadingCollectionsAsync(ICollectionPersister persister, IList`1<LoadingCollectionEntry> matchedCollectionEntries, bool skipCache, CacheBatcher cacheBatcher, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Loading.CollectionLoadContext/<EndLoadingCollectionAsync>d__4")]
private Task EndLoadingCollectionAsync(LoadingCollectionEntry lce, ICollectionPersister persister, Action`1<CachePutData> cacheBatchingHandler, bool skipCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Loading.CollectionLoadContext/<AddCollectionToCacheAsync>d__5")]
private Task AddCollectionToCacheAsync(LoadingCollectionEntry lce, ICollectionPersister persister, Action`1<CachePutData> cacheBatchingHandler, CancellationToken cancellationToken);
    public LoadContexts get_LoadContext();
    public DbDataReader get_ResultSet();
    public IPersistentCollection GetLoadingCollection(ICollectionPersister persister, object key);
    [ObsoleteAttribute("Please use overload with skipCache and cacheBatcher parameter instead.")]
public void EndLoadingCollections(ICollectionPersister persister);
    [ObsoleteAttribute("Please use overload with cacheBatcher parameter instead.")]
public void EndLoadingCollections(ICollectionPersister persister, bool skipCache);
    public void EndLoadingCollections(ICollectionPersister persister, bool skipCache, CacheBatcher cacheBatcher);
    private void EndLoadingCollections(ICollectionPersister persister, IList`1<LoadingCollectionEntry> matchedCollectionEntries, bool skipCache, CacheBatcher cacheBatcher);
    private void EndLoadingCollection(LoadingCollectionEntry lce, ICollectionPersister persister, Action`1<CachePutData> cacheBatchingHandler, bool skipCache);
    private void AddCollectionToCache(LoadingCollectionEntry lce, ICollectionPersister persister, Action`1<CachePutData> cacheBatchingHandler);
    internal void Cleanup();
    public virtual string ToString();
    internal void StopLoadingCollections(ICollectionPersister[] collectionPersisters);
}
public class NHibernate.Engine.Loading.LoadContexts : object {
    private static INHibernateLogger log;
    private IPersistenceContext persistenceContext;
    private IDictionary collectionLoadContexts;
    private Dictionary`2<CollectionKey, LoadingCollectionEntry> xrefLoadingCollectionEntries;
    public IPersistenceContext PersistenceContext { get; }
    private ISessionImplementor Session { get; }
    internal IDictionary`2<CollectionKey, LoadingCollectionEntry> LoadingCollectionXRefs { get; }
    public bool HasLoadingCollectionEntries { get; }
    public bool HasRegisteredLoadingCollectionEntries { get; }
    public LoadContexts(IPersistenceContext persistenceContext);
    private static LoadContexts();
    public IPersistenceContext get_PersistenceContext();
    private ISessionImplementor get_Session();
    internal IDictionary`2<CollectionKey, LoadingCollectionEntry> get_LoadingCollectionXRefs();
    public virtual void Cleanup(DbDataReader resultSet);
    public void Cleanup();
    public bool get_HasLoadingCollectionEntries();
    public bool get_HasRegisteredLoadingCollectionEntries();
    public CollectionLoadContext GetCollectionLoadContext(DbDataReader resultSet);
    public IPersistentCollection LocateLoadingCollection(ICollectionPersister persister, object ownerKey);
    internal void RegisterLoadingCollectionXRef(CollectionKey entryKey, LoadingCollectionEntry entry);
    internal void UnregisterLoadingCollectionXRef(CollectionKey key);
    internal LoadingCollectionEntry LocateLoadingCollectionEntry(CollectionKey key);
    internal void CleanupCollectionXRefs(IEnumerable entryKeys);
}
public class NHibernate.Engine.Loading.LoadingCollectionEntry : object {
    private DbDataReader resultSet;
    private ICollectionPersister persister;
    private object key;
    private IPersistentCollection collection;
    [CompilerGeneratedAttribute]
private bool <StopLoading>k__BackingField;
    public DbDataReader ResultSet { get; }
    public ICollectionPersister Persister { get; }
    public object Key { get; }
    public IPersistentCollection Collection { get; }
    public bool StopLoading { get; public set; }
    public LoadingCollectionEntry(DbDataReader resultSet, ICollectionPersister persister, object key, IPersistentCollection collection);
    public DbDataReader get_ResultSet();
    public ICollectionPersister get_Persister();
    public object get_Key();
    public IPersistentCollection get_Collection();
    [CompilerGeneratedAttribute]
public bool get_StopLoading();
    [CompilerGeneratedAttribute]
public void set_StopLoading(bool value);
    public virtual string ToString();
}
public class NHibernate.Engine.NamedQueryDefinition : object {
    private string query;
    private bool cacheable;
    private string cacheRegion;
    private int timeout;
    private int fetchSize;
    private FlushMode flushMode;
    private IDictionary`2<string, string> parameterTypes;
    private Nullable`1<CacheMode> cacheMode;
    private bool readOnly;
    private string comment;
    public string QueryString { get; }
    public bool IsCacheable { get; }
    public string CacheRegion { get; }
    public int FetchSize { get; }
    public int Timeout { get; }
    public FlushMode FlushMode { get; }
    public IDictionary`2<string, string> ParameterTypes { get; }
    public string Query { get; }
    public bool IsReadOnly { get; }
    public string Comment { get; }
    public Nullable`1<CacheMode> CacheMode { get; }
    public NamedQueryDefinition(string query, bool cacheable, string cacheRegion, int timeout, int fetchSize, FlushMode flushMode, bool readOnly, string comment, IDictionary`2<string, string> parameterTypes);
    public NamedQueryDefinition(string query, bool cacheable, string cacheRegion, int timeout, int fetchSize, FlushMode flushMode, Nullable`1<CacheMode> cacheMode, bool readOnly, string comment, IDictionary`2<string, string> parameterTypes);
    public string get_QueryString();
    public bool get_IsCacheable();
    public string get_CacheRegion();
    public int get_FetchSize();
    public int get_Timeout();
    public FlushMode get_FlushMode();
    public virtual string ToString();
    public IDictionary`2<string, string> get_ParameterTypes();
    public string get_Query();
    public bool get_IsReadOnly();
    public string get_Comment();
    public Nullable`1<CacheMode> get_CacheMode();
}
public class NHibernate.Engine.NamedSQLQueryDefinition : NamedQueryDefinition {
    private INativeSQLQueryReturn[] queryReturns;
    private IList`1<string> querySpaces;
    private bool callable;
    private string resultSetRef;
    public INativeSQLQueryReturn[] QueryReturns { get; }
    public IList`1<string> QuerySpaces { get; }
    public bool IsCallable { get; }
    public string ResultSetRef { get; }
    public NamedSQLQueryDefinition(string query, INativeSQLQueryReturn[] queryReturns, IList`1<string> querySpaces, bool cacheable, string cacheRegion, int timeout, int fetchSize, FlushMode flushMode, Nullable`1<CacheMode> cacheMode, bool readOnly, string comment, IDictionary`2<string, string> parameterTypes, bool callable);
    public NamedSQLQueryDefinition(string query, string resultSetRef, IList`1<string> querySpaces, bool cacheable, string cacheRegion, int timeout, int fetchSize, FlushMode flushMode, Nullable`1<CacheMode> cacheMode, bool readOnly, string comment, IDictionary`2<string, string> parameterTypes, bool callable);
    public INativeSQLQueryReturn[] get_QueryReturns();
    public IList`1<string> get_QuerySpaces();
    public bool get_IsCallable();
    public string get_ResultSetRef();
}
public class NHibernate.Engine.Nullability : object {
    private ISessionImplementor session;
    public Nullability(ISessionImplementor session);
    public void CheckNullability(Object[] values, IEntityPersister persister, bool isUpdate);
    private string CheckSubElementsNullability(IType propertyType, object value);
    private string CheckComponentNullability(object value, IAbstractComponentType compType);
    private static string BuildPropertyPath(string parent, string child);
}
[ExtensionAttribute]
public static class NHibernate.Engine.PersistenceContextExtensions : object {
    [ExtensionAttribute]
public static EntityEntry AddEntity(IPersistenceContext context, object entity, Status status, Object[] loadedState, EntityKey entityKey, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement);
    [ExtensionAttribute]
public static EntityEntry AddEntry(IPersistenceContext context, object entity, Status status, Object[] loadedState, object rowId, object id, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement);
}
public class NHibernate.Engine.PropertiesLhsAssociationTypeSqlInfo : AbstractLhsAssociationTypeSqlInfo {
    private int propertyIdx;
    public PropertiesLhsAssociationTypeSqlInfo(string alias, int propertyIdx, IOuterJoinLoadable persister, IMapping mapping);
    protected virtual String[] GetAliasedColumns();
    protected virtual String[] GetColumns();
    public virtual string GetTableName(IAssociationType type);
}
public static class NHibernate.Engine.Query.CallableParser : object {
    private static Regex functionNameFinder;
    private static CallableParser();
    public static Detail Parse(string sqlString);
    internal static bool HasReturnParameter(string sqlString, int indexOfCall);
}
public class NHibernate.Engine.Query.FilterQueryPlan : QueryExpressionPlan {
    [CompilerGeneratedAttribute]
private string <CollectionRole>k__BackingField;
    public string CollectionRole { get; }
    public FilterQueryPlan(IQueryExpression queryExpression, string collectionRole, bool shallow, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory);
    protected FilterQueryPlan(FilterQueryPlan source, IQueryExpression expression);
    [CompilerGeneratedAttribute]
public string get_CollectionRole();
    public virtual QueryExpressionPlan Copy(IQueryExpression expression);
}
public class NHibernate.Engine.Query.HQLQueryPlan : object {
    protected static INHibernateLogger Log;
    private string _sourceQuery;
    [CompilerGeneratedAttribute]
private ISet`1<string> <QuerySpaces>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterMetadata <ParameterMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnMetadata <ReturnMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SqlStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryTranslator[] <Translators>k__BackingField;
    public ISet`1<string> QuerySpaces { get; private set; }
    public ParameterMetadata ParameterMetadata { get; private set; }
    public ReturnMetadata ReturnMetadata { get; private set; }
    public String[] SqlStrings { get; private set; }
    public IQueryTranslator[] Translators { get; private set; }
    protected HQLQueryPlan(string sourceQuery, IQueryTranslator[] translators);
    internal HQLQueryPlan(HQLQueryPlan source);
    private static HQLQueryPlan();
    [AsyncStateMachineAttribute("NHibernate.Engine.Query.HQLQueryPlan/<PerformListAsync>d__0")]
public sealed virtual Task PerformListAsync(QueryParameters queryParameters, ISessionImplementor session, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Query.HQLQueryPlan/<PerformIterateAsync>d__1")]
public sealed virtual Task`1<IEnumerable> PerformIterateAsync(QueryParameters queryParameters, IEventSource session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Query.HQLQueryPlan/<PerformIterateAsync>d__2`1")]
public sealed virtual Task`1<IEnumerable`1<T>> PerformIterateAsync(QueryParameters queryParameters, IEventSource session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Query.HQLQueryPlan/<PerformExecuteUpdateAsync>d__3")]
public sealed virtual Task`1<int> PerformExecuteUpdateAsync(QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<string> get_QuerySpaces();
    [CompilerGeneratedAttribute]
private void set_QuerySpaces(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual ParameterMetadata get_ParameterMetadata();
    [CompilerGeneratedAttribute]
private void set_ParameterMetadata(ParameterMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual ReturnMetadata get_ReturnMetadata();
    [CompilerGeneratedAttribute]
private void set_ReturnMetadata(ReturnMetadata value);
    [CompilerGeneratedAttribute]
public String[] get_SqlStrings();
    [CompilerGeneratedAttribute]
private void set_SqlStrings(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryTranslator[] get_Translators();
    [CompilerGeneratedAttribute]
private void set_Translators(IQueryTranslator[] value);
    public sealed virtual void PerformList(QueryParameters queryParameters, ISessionImplementor session, IList results);
    public sealed virtual IEnumerable PerformIterate(QueryParameters queryParameters, IEventSource session);
    public sealed virtual IEnumerable`1<T> PerformIterate(QueryParameters queryParameters, IEventSource session);
    public sealed virtual int PerformExecuteUpdate(QueryParameters queryParameters, ISessionImplementor session);
    private void FinaliseQueryPlan();
    private void BuildMetaData();
    private void BuildSqlStringsAndQuerySpaces();
}
public interface NHibernate.Engine.Query.IQueryExpressionPlan {
    public IQueryExpression QueryExpression { get; }
    public abstract virtual IQueryExpression get_QueryExpression();
}
public interface NHibernate.Engine.Query.IQueryPlan {
    public ParameterMetadata ParameterMetadata { get; }
    public ISet`1<string> QuerySpaces { get; }
    public IQueryTranslator[] Translators { get; }
    public ReturnMetadata ReturnMetadata { get; }
    public abstract virtual Task PerformListAsync(QueryParameters queryParameters, ISessionImplementor statelessSessionImpl, IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> PerformExecuteUpdateAsync(QueryParameters queryParameters, ISessionImplementor statelessSessionImpl, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<T>> PerformIterateAsync(QueryParameters queryParameters, IEventSource session, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> PerformIterateAsync(QueryParameters queryParameters, IEventSource session, CancellationToken cancellationToken);
    public abstract virtual ParameterMetadata get_ParameterMetadata();
    public abstract virtual ISet`1<string> get_QuerySpaces();
    public abstract virtual IQueryTranslator[] get_Translators();
    public abstract virtual ReturnMetadata get_ReturnMetadata();
    public abstract virtual void PerformList(QueryParameters queryParameters, ISessionImplementor statelessSessionImpl, IList results);
    public abstract virtual int PerformExecuteUpdate(QueryParameters queryParameters, ISessionImplementor statelessSessionImpl);
    public abstract virtual IEnumerable`1<T> PerformIterate(QueryParameters queryParameters, IEventSource session);
    public abstract virtual IEnumerable PerformIterate(QueryParameters queryParameters, IEventSource session);
}
public class NHibernate.Engine.Query.NamedParameterDescriptor : object {
    private string name;
    private IType expectedType;
    private bool jpaStyle;
    public string Name { get; }
    public IType ExpectedType { get; }
    public bool JpaStyle { get; }
    public NamedParameterDescriptor(string name, IType expectedType, bool jpaStyle);
    public string get_Name();
    public IType get_ExpectedType();
    public bool get_JpaStyle();
}
public class NHibernate.Engine.Query.NativeSQLQueryPlan : object {
    private static INHibernateLogger log;
    private string sourceQuery;
    private SQLCustomQuery customQuery;
    public string SourceQuery { get; }
    public SQLCustomQuery CustomQuery { get; }
    public NativeSQLQueryPlan(NativeSQLQuerySpecification specification, ISessionFactoryImplementor factory);
    private static NativeSQLQueryPlan();
    [AsyncStateMachineAttribute("NHibernate.Engine.Query.NativeSQLQueryPlan/<PerformExecuteUpdateAsync>d__0")]
public Task`1<int> PerformExecuteUpdateAsync(QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public string get_SourceQuery();
    public SQLCustomQuery get_CustomQuery();
    private void CoordinateSharedCacheCleanup(ISessionImplementor session);
    public int PerformExecuteUpdate(QueryParameters queryParameters, ISessionImplementor session);
}
public class NHibernate.Engine.Query.OrdinalParameterDescriptor : object {
    private int ordinalPosition;
    private IType expectedType;
    public int OrdinalPosition { get; }
    public IType ExpectedType { get; }
    public OrdinalParameterDescriptor(int ordinalPosition, IType expectedType);
    public int get_OrdinalPosition();
    public IType get_ExpectedType();
}
public class NHibernate.Engine.Query.ParameterMetadata : object {
    private Dictionary`2<string, NamedParameterDescriptor> namedDescriptorMap;
    private OrdinalParameterDescriptor[] ordinalDescriptors;
    public int OrdinalParameterCount { get; }
    public ICollection`1<string> NamedParameterNames { get; }
    public ParameterMetadata(IEnumerable`1<OrdinalParameterDescriptor> ordinalDescriptors, IDictionary`2<string, NamedParameterDescriptor> namedDescriptorMap);
    public int get_OrdinalParameterCount();
    public ICollection`1<string> get_NamedParameterNames();
    public OrdinalParameterDescriptor GetOrdinalParameterDescriptor(int position);
    public IType GetOrdinalParameterExpectedType(int position);
    public NamedParameterDescriptor GetNamedParameterDescriptor(string name);
    public IType GetNamedParameterExpectedType(string name);
}
public class NHibernate.Engine.Query.ParameterParser : object {
    public static void Parse(string sqlString, IRecognizer recognizer);
}
public class NHibernate.Engine.Query.ParamLocationRecognizer : object {
    private Dictionary`2<string, NamedParameterDescription> namedParameterDescriptions;
    private List`1<int> ordinalParameterLocationList;
    public IDictionary`2<string, NamedParameterDescription> NamedParameterDescriptionMap { get; }
    public List`1<int> OrdinalParameterLocationList { get; }
    public static ParamLocationRecognizer ParseLocations(string query);
    public IDictionary`2<string, NamedParameterDescription> get_NamedParameterDescriptionMap();
    public List`1<int> get_OrdinalParameterLocationList();
    public sealed virtual void OutParameter(int position);
    public sealed virtual void OrdinalParameter(int position);
    public sealed virtual void NamedParameter(string name, int position);
    public sealed virtual void JpaPositionalParameter(string name, int position);
    public sealed virtual void Other(char character);
    public sealed virtual void Other(string sqlPart);
    private NamedParameterDescription GetOrBuildNamedParameterDescription(string name, bool jpa);
}
public class NHibernate.Engine.Query.QueryExpressionPlan : HQLQueryPlan {
    [CompilerGeneratedAttribute]
private IQueryExpression <QueryExpression>k__BackingField;
    public IQueryExpression QueryExpression { get; }
    public QueryExpressionPlan(IQueryExpression queryExpression, string collectionRole, bool shallow, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory);
    public QueryExpressionPlan(IQueryExpression queryExpression, bool shallow, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory);
    protected QueryExpressionPlan(string key, IQueryTranslator[] translators);
    protected QueryExpressionPlan(HQLQueryPlan source, IQueryExpression expression);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryExpression get_QueryExpression();
    protected static IQueryTranslator[] CreateTranslators(IQueryExpression queryExpression, string collectionRole, bool shallow, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory);
    public virtual QueryExpressionPlan Copy(IQueryExpression expression);
}
public class NHibernate.Engine.Query.QueryPlanCache : object {
    private static INHibernateLogger log;
    private ISessionFactoryImplementor factory;
    private SimpleMRUCache sqlParamMetadataCache;
    private SoftLimitMRUCache planCache;
    internal static int DefaultParameterMetadataMaxCount;
    internal static int DefaultQueryPlanMaxCount;
    public QueryPlanCache(ISessionFactoryImplementor factory);
    private static QueryPlanCache();
    public ParameterMetadata GetSQLParameterMetadata(string query);
    public ParameterMetadata GetSQLParameterMetadata(string query, IDictionary`2<string, string> parameterTypes);
    public IQueryExpressionPlan GetHQLQueryPlan(IQueryExpression queryExpression, bool shallow, IDictionary`2<string, IFilter> enabledFilters);
    private QueryExpressionPlan PreparePlanToCache(QueryExpressionPlan plan);
    private static QueryExpressionPlan CopyIfRequired(QueryExpressionPlan plan, IQueryExpression queryExpression);
    public IQueryExpressionPlan GetFilterQueryPlan(string filterString, string collectionRole, bool shallow, IDictionary`2<string, IFilter> enabledFilters);
    public IQueryExpressionPlan GetFilterQueryPlan(IQueryExpression queryExpression, string collectionRole, bool shallow, IDictionary`2<string, IFilter> enabledFilters);
    public NativeSQLQueryPlan GetNativeSQLQueryPlan(NativeSQLQuerySpecification spec);
    private ParameterMetadata BuildNativeSQLParameterMetadata(string sqlString, IDictionary`2<string, string> parameterTypes);
}
public class NHibernate.Engine.Query.ReturnMetadata : object {
    private String[] returnAliases;
    private IType[] returnTypes;
    public String[] ReturnAliases { get; }
    public IType[] ReturnTypes { get; }
    public ReturnMetadata(String[] returnAliases, IType[] returnTypes);
    public String[] get_ReturnAliases();
    public IType[] get_ReturnTypes();
}
public interface NHibernate.Engine.Query.Sql.INativeSQLQueryReturn {
}
public class NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn : NativeSQLQueryNonScalarReturn {
    private string ownerEntityName;
    private string ownerProperty;
    public string OwnerEntityName { get; }
    public string OwnerProperty { get; }
    public NativeSQLQueryCollectionReturn(string alias, string ownerEntityName, string ownerProperty, IDictionary`2<string, String[]> propertyResults, LockMode lockMode);
    public string get_OwnerEntityName();
    public string get_OwnerProperty();
}
public class NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn : NativeSQLQueryNonScalarReturn {
    private string ownerAlias;
    private string ownerProperty;
    public string OwnerAlias { get; }
    public string OwnerProperty { get; }
    public NativeSQLQueryJoinReturn(string alias, string ownerAlias, string ownerProperty, IDictionary`2<string, String[]> propertyResults, LockMode lockMode);
    public string get_OwnerAlias();
    public string get_OwnerProperty();
}
public abstract class NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn : object {
    private string alias;
    private Dictionary`2<string, String[]> propertyResults;
    private LockMode lockMode;
    public string Alias { get; }
    public LockMode LockMode { get; }
    public IDictionary`2<string, String[]> PropertyResultsMap { get; }
    protected internal NativeSQLQueryNonScalarReturn(string alias, IDictionary`2<string, String[]> propertyResults, LockMode lockMode);
    public string get_Alias();
    public LockMode get_LockMode();
    public IDictionary`2<string, String[]> get_PropertyResultsMap();
    public virtual bool Equals(object obj);
    public bool Equals(NativeSQLQueryNonScalarReturn other);
    public virtual int GetHashCode();
}
public class NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn : NativeSQLQueryNonScalarReturn {
    private string returnEntityName;
    public string ReturnEntityName { get; }
    public NativeSQLQueryRootReturn(string alias, string entityName, LockMode lockMode);
    public NativeSQLQueryRootReturn(string alias, string entityName, IDictionary`2<string, String[]> propertyResults, LockMode lockMode);
    public string get_ReturnEntityName();
}
public class NHibernate.Engine.Query.Sql.NativeSQLQueryScalarReturn : object {
    private string columnAlias;
    private IType type;
    public string ColumnAlias { get; }
    public IType Type { get; }
    public NativeSQLQueryScalarReturn(string alias, IType type);
    public string get_ColumnAlias();
    public IType get_Type();
    public virtual bool Equals(object obj);
    public bool Equals(NativeSQLQueryScalarReturn other);
    public virtual int GetHashCode();
}
public class NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification : object {
    private string queryString;
    private INativeSQLQueryReturn[] sqlQueryReturns;
    private HashSet`1<string> querySpaces;
    private int hashCode;
    public string QueryString { get; }
    public INativeSQLQueryReturn[] SqlQueryReturns { get; }
    public ISet`1<string> QuerySpaces { get; }
    public NativeSQLQuerySpecification(string queryString, INativeSQLQueryReturn[] sqlQueryReturns, ICollection`1<string> querySpaces);
    public string get_QueryString();
    public INativeSQLQueryReturn[] get_SqlQueryReturns();
    public ISet`1<string> get_QuerySpaces();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NHibernate.Engine.QueryCacheBatchQueue : object {
    private IPersistenceContext _persistenceContext;
    private Dictionary`2<string, HashSet`1<EntityKey>> _queryEntityKeys;
    private Dictionary`2<string, HashSet`1<EntityKey>> _queryCheckedEntityKeys;
    private Dictionary`2<string, Dictionary`2<CollectionKey, CollectionEntry>> _queryCollectionKeys;
    private Dictionary`2<string, HashSet`1<CollectionKey>> _queryCheckedCollectionKeys;
    private Dictionary`2<string, HashSet`1<CollectionEntry>> _queryCheckedCollectionEntries;
    internal QueryCacheBatchQueue(IPersistenceContext persistenceContext);
    internal Object[] GetEntityBatch(IEntityPersister persister, object id);
    internal Object[] GetCollectionBatch(ICollectionPersister collectionPersister, object key, CollectionEntry[]& collectionEntries);
    internal void AddEntityKey(EntityKey key);
    internal void AddCollection(ICollectionPersister persister, CollectionKey ce);
    internal void LinkCollectionEntry(CollectionEntry ce);
    internal bool WasEntityKeyChecked(IEntityPersister persister, EntityKey key);
    internal bool WasCollectionEntryChecked(ICollectionPersister persister, CollectionEntry entry);
}
public class NHibernate.Engine.QueryParameters : object {
    private static INHibernateLogger log;
    private bool readOnly;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, TypedValue> <NamedParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IType[] <PositionalParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <PositionalParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private RowSelection <RowSelection>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, LockMode> <LockModes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnlyInitialized>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cacheable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CacheMode> <CacheMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceCacheRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OptionalEntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OptionalId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OptionalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <CollectionKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Callable>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlString <ProcessedSql>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IParameterSpecification> <ProcessedSqlParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private RowSelection <ProcessedRowSelection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NaturalKeyLookup>k__BackingField;
    [CompilerGeneratedAttribute]
private IResultTransformer <ResultTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAutoDiscoverScalarTypes>k__BackingField;
    public bool HasRowSelection { get; }
    public IDictionary`2<string, TypedValue> NamedParameters { get; internal set; }
    public IType[] PositionalParameterTypes { get; public set; }
    public Object[] PositionalParameterValues { get; public set; }
    public RowSelection RowSelection { get; public set; }
    public IDictionary`2<string, LockMode> LockModes { get; public set; }
    public bool IsReadOnlyInitialized { get; private set; }
    public bool Cacheable { get; public set; }
    public string CacheRegion { get; public set; }
    public Nullable`1<CacheMode> CacheMode { get; public set; }
    public string Comment { get; public set; }
    public bool ForceCacheRefresh { get; public set; }
    public string OptionalEntityName { get; public set; }
    public object OptionalId { get; public set; }
    public object OptionalObject { get; public set; }
    public Object[] CollectionKeys { get; public set; }
    public bool Callable { get; public set; }
    public bool ReadOnly { get; public set; }
    public SqlString ProcessedSql { get; internal set; }
    public IEnumerable`1<IParameterSpecification> ProcessedSqlParameters { get; internal set; }
    public RowSelection ProcessedRowSelection { get; internal set; }
    public bool NaturalKeyLookup { get; public set; }
    public IResultTransformer ResultTransformer { get; private set; }
    public bool HasAutoDiscoverScalarTypes { get; public set; }
    public QueryParameters(IType[] positionalParameterTypes, Object[] postionalParameterValues, object optionalObject, string optionalEntityName, object optionalObjectId);
    public QueryParameters(IType[] positionalParameterTypes, Object[] postionalParameterValues);
    public QueryParameters(IType[] positionalParameterTypes, Object[] postionalParameterValues, Object[] collectionKeys);
    public QueryParameters(IType[] positionalParameterTypes, Object[] postionalParameterValues, IDictionary`2<string, TypedValue> namedParameters, Object[] collectionKeys);
    public QueryParameters(IType[] positionalParameterTypes, Object[] positionalParameterValues, IDictionary`2<string, LockMode> lockModes, RowSelection rowSelection, bool isReadOnlyInitialized, bool readOnly, bool cacheable, string cacheRegion, string comment, bool isLookupByNaturalKey, IResultTransformer transformer);
    public QueryParameters(IDictionary`2<string, TypedValue> namedParameters, IDictionary`2<string, LockMode> lockModes, RowSelection rowSelection, bool isReadOnlyInitialized, bool readOnly, bool cacheable, string cacheRegion, string comment, bool isLookupByNaturalKey, IResultTransformer transformer);
    public QueryParameters(IType[] positionalParameterTypes, Object[] positionalParameterValues, IDictionary`2<string, TypedValue> namedParameters, IDictionary`2<string, LockMode> lockModes, RowSelection rowSelection, bool isReadOnlyInitialized, bool readOnly, bool cacheable, string cacheRegion, string comment, Object[] collectionKeys, IResultTransformer transformer);
    public QueryParameters(IType[] positionalParameterTypes, Object[] positionalParameterValues, IDictionary`2<string, TypedValue> namedParameters, IDictionary`2<string, LockMode> lockModes, RowSelection rowSelection, bool isReadOnlyInitialized, bool readOnly, bool cacheable, string cacheRegion, string comment, Object[] collectionKeys, object optionalObject, string optionalEntityName, object optionalId, IResultTransformer transformer);
    private static QueryParameters();
    public bool get_HasRowSelection();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, TypedValue> get_NamedParameters();
    [CompilerGeneratedAttribute]
internal void set_NamedParameters(IDictionary`2<string, TypedValue> value);
    [CompilerGeneratedAttribute]
public IType[] get_PositionalParameterTypes();
    [CompilerGeneratedAttribute]
public void set_PositionalParameterTypes(IType[] value);
    [CompilerGeneratedAttribute]
public Object[] get_PositionalParameterValues();
    [CompilerGeneratedAttribute]
public void set_PositionalParameterValues(Object[] value);
    [CompilerGeneratedAttribute]
public RowSelection get_RowSelection();
    [CompilerGeneratedAttribute]
public void set_RowSelection(RowSelection value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, LockMode> get_LockModes();
    [CompilerGeneratedAttribute]
public void set_LockModes(IDictionary`2<string, LockMode> value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnlyInitialized();
    [CompilerGeneratedAttribute]
private void set_IsReadOnlyInitialized(bool value);
    [CompilerGeneratedAttribute]
public bool get_Cacheable();
    [CompilerGeneratedAttribute]
public void set_Cacheable(bool value);
    [CompilerGeneratedAttribute]
public string get_CacheRegion();
    [CompilerGeneratedAttribute]
public void set_CacheRegion(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<CacheMode> get_CacheMode();
    [CompilerGeneratedAttribute]
public void set_CacheMode(Nullable`1<CacheMode> value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceCacheRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceCacheRefresh(bool value);
    [CompilerGeneratedAttribute]
public string get_OptionalEntityName();
    [CompilerGeneratedAttribute]
public void set_OptionalEntityName(string value);
    [CompilerGeneratedAttribute]
public object get_OptionalId();
    [CompilerGeneratedAttribute]
public void set_OptionalId(object value);
    [CompilerGeneratedAttribute]
public object get_OptionalObject();
    [CompilerGeneratedAttribute]
public void set_OptionalObject(object value);
    [CompilerGeneratedAttribute]
public Object[] get_CollectionKeys();
    [CompilerGeneratedAttribute]
public void set_CollectionKeys(Object[] value);
    [CompilerGeneratedAttribute]
public bool get_Callable();
    [CompilerGeneratedAttribute]
public void set_Callable(bool value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    [CompilerGeneratedAttribute]
public SqlString get_ProcessedSql();
    [CompilerGeneratedAttribute]
internal void set_ProcessedSql(SqlString value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IParameterSpecification> get_ProcessedSqlParameters();
    [CompilerGeneratedAttribute]
internal void set_ProcessedSqlParameters(IEnumerable`1<IParameterSpecification> value);
    [CompilerGeneratedAttribute]
public RowSelection get_ProcessedRowSelection();
    [CompilerGeneratedAttribute]
internal void set_ProcessedRowSelection(RowSelection value);
    [CompilerGeneratedAttribute]
public bool get_NaturalKeyLookup();
    [CompilerGeneratedAttribute]
public void set_NaturalKeyLookup(bool value);
    [CompilerGeneratedAttribute]
public IResultTransformer get_ResultTransformer();
    [CompilerGeneratedAttribute]
private void set_ResultTransformer(IResultTransformer value);
    [CompilerGeneratedAttribute]
public bool get_HasAutoDiscoverScalarTypes();
    [CompilerGeneratedAttribute]
public void set_HasAutoDiscoverScalarTypes(bool value);
    public void LogParameters(ISessionFactoryImplementor factory);
    public void ValidateParameters();
    public QueryParameters CreateCopyUsing(RowSelection selection);
    public bool IsReadOnly(ISessionImplementor session);
    public bool CanGetFromCache(ISessionImplementor session);
    public bool CanPutToCache(ISessionImplementor session);
}
public class NHibernate.Engine.ResultSetMappingDefinition : object {
    private string name;
    private List`1<INativeSQLQueryReturn> queryReturns;
    public string Name { get; }
    public ResultSetMappingDefinition(string name);
    public string get_Name();
    public void AddQueryReturn(INativeSQLQueryReturn queryReturn);
    public INativeSQLQueryReturn[] GetQueryReturns();
}
public class NHibernate.Engine.RowSelection : object {
    public static int NoValue;
    private int firstRow;
    private int maxRows;
    private int timeout;
    private int fetchSize;
    public int FirstRow { get; public set; }
    public int MaxRows { get; public set; }
    public int Timeout { get; public set; }
    public int FetchSize { get; public set; }
    public bool DefinesLimits { get; }
    private static RowSelection();
    public int get_FirstRow();
    public void set_FirstRow(int value);
    public int get_MaxRows();
    public void set_MaxRows(int value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public int get_FetchSize();
    public void set_FetchSize(int value);
    public bool get_DefinesLimits();
}
[ExtensionAttribute]
public static class NHibernate.Engine.SessionFactoryImplementorExtension : object {
    [ExtensionAttribute]
public static ISet`1<IEntityPersister> GetEntityPersisters(ISessionFactoryImplementor factory, ISet`1<string> spaces);
    [ExtensionAttribute]
public static ISet`1<ICollectionPersister> GetCollectionPersisters(ISessionFactoryImplementor factory, ISet`1<string> spaces);
}
[ExtensionAttribute]
public static class NHibernate.Engine.SessionImplementorExtensions : object {
    [AsyncStateMachineAttribute("NHibernate.Engine.SessionImplementorExtensions/<AutoFlushIfRequiredAsync>d__0")]
[ExtensionAttribute]
internal static Task AutoFlushIfRequiredAsync(ISessionImplementor implementor, ISet`1<string> querySpaces, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GetTenantIdentifier(ISessionImplementor session);
    [ExtensionAttribute]
internal static object Instantiate(ISessionImplementor session, IEntityPersister persister, object id);
    [ExtensionAttribute]
internal static IDisposable BeginContext(ISessionImplementor session);
    [ExtensionAttribute]
internal static IDisposable BeginProcess(ISessionImplementor session);
    [ExtensionAttribute]
internal static IQueryBatch GetFutureBatch(ISessionImplementor session);
    [ExtensionAttribute]
internal static void AutoFlushIfRequired(ISessionImplementor implementor, ISet`1<string> querySpaces);
    [ExtensionAttribute]
internal static IDisposable SwitchCacheMode(ISessionImplementor session, Nullable`1<CacheMode> cacheMode);
}
public class NHibernate.Engine.StatefulPersistenceContext : object {
    private static int InitCollectionSize;
    private static INHibernateLogger log;
    private static INHibernateLogger ProxyWarnLog;
    public static object NoRow;
    private ISessionImplementor session;
    private Dictionary`2<EntityKey, object> entitiesByKey;
    private Dictionary`2<EntityUniqueKey, object> entitiesByUniqueKey;
    private IDictionary entityEntries;
    private Dictionary`2<EntityKey, INHibernateProxy> proxiesByKey;
    private Dictionary`2<EntityKey, object> entitySnapshotsByKey;
    private IDictionary arrayHolders;
    private IDictionary collectionEntries;
    private Dictionary`2<CollectionKey, IPersistentCollection> collectionsByKey;
    private HashSet`1<EntityKey> nullifiableEntityKeys;
    private HashSet`1<AssociationKey> nullAssociations;
    private List`1<IPersistentCollection> nonlazyCollections;
    private Dictionary`2<CollectionKey, IPersistentCollection> unownedCollections;
    private bool hasNonReadOnlyEntities;
    private IDictionary parentsByChild;
    private int cascading;
    private bool flushing;
    private int loadCounter;
    private LoadContexts loadContexts;
    private BatchFetchQueue batchFetchQueue;
    private bool defaultReadOnly;
    public bool IsStateless { get; }
    public ISessionImplementor Session { get; }
    public LoadContexts LoadContexts { get; }
    public BatchFetchQueue BatchFetchQueue { get; }
    public ISet`1<EntityKey> NullifiableEntityKeys { get; }
    public IDictionary`2<EntityKey, object> EntitiesByKey { get; }
    public IDictionary EntityEntries { get; }
    public IDictionary CollectionEntries { get; }
    public IDictionary`2<CollectionKey, IPersistentCollection> CollectionsByKey { get; }
    public int CascadeLevel { get; }
    public bool Flushing { get; public set; }
    public bool HasNonReadOnlyEntities { get; }
    public bool DefaultReadOnly { get; public set; }
    public bool IsLoadFinished { get; }
    public StatefulPersistenceContext(ISessionImplementor session);
    internal StatefulPersistenceContext(SerializationInfo info, StreamingContext context);
    private static StatefulPersistenceContext();
    [AsyncStateMachineAttribute("NHibernate.Engine.StatefulPersistenceContext/<GetDatabaseSnapshotAsync>d__0")]
public sealed virtual Task`1<Object[]> GetDatabaseSnapshotAsync(object id, IEntityPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.StatefulPersistenceContext/<GetNaturalIdSnapshotAsync>d__1")]
public sealed virtual Task`1<Object[]> GetNaturalIdSnapshotAsync(object id, IEntityPersister persister, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> UnproxyAndReassociateAsync(object maybeProxy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.StatefulPersistenceContext/<InitializeNonLazyCollectionsAsync>d__3")]
public sealed virtual Task InitializeNonLazyCollectionsAsync(CancellationToken cancellationToken);
    private void InitTransientState();
    public sealed virtual bool get_IsStateless();
    public sealed virtual ISessionImplementor get_Session();
    public sealed virtual LoadContexts get_LoadContexts();
    public sealed virtual BatchFetchQueue get_BatchFetchQueue();
    public sealed virtual ISet`1<EntityKey> get_NullifiableEntityKeys();
    public sealed virtual IDictionary`2<EntityKey, object> get_EntitiesByKey();
    public sealed virtual IDictionary get_EntityEntries();
    public sealed virtual IDictionary get_CollectionEntries();
    public sealed virtual IDictionary`2<CollectionKey, IPersistentCollection> get_CollectionsByKey();
    public sealed virtual int get_CascadeLevel();
    public sealed virtual bool get_Flushing();
    public sealed virtual void set_Flushing(bool value);
    public sealed virtual void AddUnownedCollection(CollectionKey key, IPersistentCollection collection);
    public sealed virtual IPersistentCollection UseUnownedCollection(CollectionKey key);
    public sealed virtual void Clear();
    public sealed virtual bool get_HasNonReadOnlyEntities();
    public sealed virtual bool get_DefaultReadOnly();
    public sealed virtual void set_DefaultReadOnly(bool value);
    private void SetHasNonReadOnlyEnties(Status value);
    public sealed virtual void SetEntryStatus(EntityEntry entry, Status status);
    public sealed virtual void AfterTransactionCompletion();
    public sealed virtual Object[] GetDatabaseSnapshot(object id, IEntityPersister persister);
    public sealed virtual Object[] GetCachedDatabaseSnapshot(EntityKey key);
    public sealed virtual Object[] GetNaturalIdSnapshot(object id, IEntityPersister persister);
    public sealed virtual void AddEntity(EntityKey key, object entity);
    public sealed virtual object GetEntity(EntityKey key);
    public sealed virtual bool ContainsEntity(EntityKey key);
    public sealed virtual object RemoveEntity(EntityKey key);
    public sealed virtual object GetEntity(EntityUniqueKey euk);
    public sealed virtual void AddEntity(EntityUniqueKey euk, object entity);
    public sealed virtual EntityEntry GetEntry(object entity);
    public sealed virtual EntityEntry RemoveEntry(object entity);
    public sealed virtual bool IsEntryFor(object entity);
    public sealed virtual CollectionEntry GetCollectionEntry(IPersistentCollection coll);
    [ObsoleteAttribute("Use overload without lazyPropertiesAreUnfetched parameter")]
public sealed virtual EntityEntry AddEntity(object entity, Status status, Object[] loadedState, EntityKey entityKey, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement, bool lazyPropertiesAreUnfetched);
    public EntityEntry AddEntity(object entity, Status status, Object[] loadedState, EntityKey entityKey, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement);
    [ObsoleteAttribute("Use overload without lazyPropertiesAreUnfetched parameter")]
public sealed virtual EntityEntry AddEntry(object entity, Status status, Object[] loadedState, object rowId, object id, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement, bool lazyPropertiesAreUnfetched);
    public EntityEntry AddEntry(object entity, Status status, Object[] loadedState, object rowId, object id, object version, LockMode lockMode, bool existsInDatabase, IEntityPersister persister, bool disableVersionIncrement);
    public sealed virtual bool ContainsCollection(IPersistentCollection collection);
    public sealed virtual bool ContainsProxy(INHibernateProxy proxy);
    public sealed virtual bool ReassociateIfUninitializedProxy(object value);
    public sealed virtual void ReassociateProxy(object value, object id);
    private void ReassociateProxy(ILazyInitializer li, INHibernateProxy proxy);
    public sealed virtual object Unproxy(object maybeProxy);
    public sealed virtual object UnproxyAndReassociate(object maybeProxy);
    public sealed virtual void CheckUniqueness(EntityKey key, object obj);
    public sealed virtual object NarrowProxy(INHibernateProxy proxy, IEntityPersister persister, EntityKey key, object obj);
    public sealed virtual object ProxyFor(IEntityPersister persister, EntityKey key, object impl);
    public sealed virtual object ProxyFor(object impl);
    public sealed virtual object GetCollectionOwner(object key, ICollectionPersister collectionPersister);
    public virtual object GetLoadedCollectionOwnerOrNull(IPersistentCollection collection);
    public virtual object GetLoadedCollectionOwnerIdOrNull(IPersistentCollection collection);
    private object GetLoadedCollectionOwnerIdOrNull(CollectionEntry ce);
    public sealed virtual void AddUninitializedCollection(ICollectionPersister persister, IPersistentCollection collection, object id);
    public sealed virtual void AddUninitializedDetachedCollection(ICollectionPersister persister, IPersistentCollection collection);
    public sealed virtual void AddNewCollection(ICollectionPersister persister, IPersistentCollection collection);
    private void AddCollection(IPersistentCollection coll, CollectionEntry entry, object key);
    private void AddCollection(IPersistentCollection collection, ICollectionPersister persister);
    public sealed virtual void AddInitializedDetachedCollection(ICollectionPersister collectionPersister, IPersistentCollection collection);
    public sealed virtual CollectionEntry AddInitializedCollection(ICollectionPersister persister, IPersistentCollection collection, object id);
    public sealed virtual IPersistentCollection GetCollection(CollectionKey collectionKey);
    public sealed virtual void AddNonLazyCollection(IPersistentCollection collection);
    public sealed virtual void InitializeNonLazyCollections();
    private void ClearNullProperties();
    public sealed virtual IPersistentCollection GetCollectionHolder(object array);
    public sealed virtual void AddCollectionHolder(IPersistentCollection holder);
    public sealed virtual IPersistentCollection RemoveCollectionHolder(object array);
    public sealed virtual object GetSnapshot(IPersistentCollection coll);
    public sealed virtual CollectionEntry GetCollectionEntryOrNull(object collection);
    public sealed virtual object GetProxy(EntityKey key);
    public sealed virtual void AddProxy(EntityKey key, INHibernateProxy proxy);
    public sealed virtual object RemoveProxy(EntityKey key);
    public sealed virtual int IncrementCascadeLevel();
    public sealed virtual int DecrementCascadeLevel();
    public sealed virtual void BeforeLoad();
    public sealed virtual void AfterLoad();
    public sealed virtual object GetOwnerId(string entityName, string propertyName, object childEntity, IDictionary mergeMap);
    private bool IsFoundInParent(string property, object childEntity, IEntityPersister persister, ICollectionPersister collectionPersister, object potentialParent);
    public sealed virtual object GetIndexInOwner(string entity, string property, object childEntity, IDictionary mergeMap);
    private object GetIndexInParent(string property, object childEntity, IEntityPersister persister, ICollectionPersister collectionPersister, object potentialParent);
    public sealed virtual void AddNullProperty(EntityKey ownerKey, string propertyName);
    public sealed virtual bool IsPropertyNull(EntityKey ownerKey, string propertyName);
    public sealed virtual void SetReadOnly(object entityOrProxy, bool readOnly);
    private void SetProxyReadOnly(INHibernateProxy proxy, bool readOnly);
    private void SetEntityReadOnly(object entity, bool readOnly);
    public sealed virtual bool IsReadOnly(object entityOrProxy);
    public sealed virtual void ReplaceDelayedEntityIdentityInsertKeys(EntityKey oldKey, object generatedId);
    public sealed virtual bool get_IsLoadFinished();
    public sealed virtual void AddChildParent(object child, object parent);
    public sealed virtual void RemoveChildParent(object child);
    public virtual string ToString();
    internal void SetSession(ISessionImplementor session);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum NHibernate.Engine.Status : Enum {
    public int value__;
    public static Status Loaded;
    public static Status Deleted;
    public static Status Gone;
    public static Status Loading;
    public static Status Saving;
    public static Status ReadOnly;
}
public class NHibernate.Engine.SubselectFetch : object {
    private string alias;
    private ILoadable loadable;
    private QueryParameters queryParameters;
    private SqlString queryString;
    private ISet`1<EntityKey> resultingEntityKeys;
    public QueryParameters QueryParameters { get; }
    public ISet`1<EntityKey> Result { get; }
    public SubselectFetch(string alias, ILoadable loadable, QueryParameters queryParameters, ISet`1<EntityKey> resultingEntityKeys);
    public QueryParameters get_QueryParameters();
    public ISet`1<EntityKey> get_Result();
    public SqlString ToSubselectString(string ukname);
    public virtual string ToString();
}
internal class NHibernate.Engine.TableGroupJoinHelper : object {
    internal static bool ProcessAsTableGroupJoin(IReadOnlyList`1<IJoin> tableGroupJoinables, SqlString[] withClauseFragments, bool includeAllSubclassJoins, JoinFragment joinFragment, Func`2<string, bool> isSubclassIncluded);
    private static bool NeedsTableGroupJoin(IReadOnlyList`1<IJoin> joins, SqlString[] withClauseFragments, bool includeSubclasses, Func`2<string, bool> isSubclassIncluded);
    private static SqlString GetTableGroupJoinWithClause(SqlString[] withClauseFragments, IJoin first);
    private static AbstractEntityPersister GetEntityPersister(IJoinable joinable, EntityType& manyToManyType);
    private static void AppendWithClause(SqlStringBuilder fromFragment, bool hasConditions, SqlString[] withClauseFragments);
}
public interface NHibernate.Engine.Transaction.IIsolatedWork {
    public abstract virtual Task DoWorkAsync(DbConnection connection, DbTransaction transaction, CancellationToken cancellationToken);
    public abstract virtual void DoWork(DbConnection connection, DbTransaction transaction);
}
internal class NHibernate.Engine.Transaction.IsolatedWorkAfterTransaction : object {
    private IIsolatedWork _work;
    private ISessionImplementor _session;
    internal IsolatedWorkAfterTransaction(IIsolatedWork work, ISessionImplementor session);
    public sealed virtual Task ExecuteBeforeTransactionCompletionAsync(CancellationToken cancellationToken);
    public sealed virtual Task ExecuteAfterTransactionCompletionAsync(bool success, CancellationToken cancellationToken);
    public sealed virtual void ExecuteBeforeTransactionCompletion();
    public sealed virtual void ExecuteAfterTransactionCompletion(bool success);
}
public class NHibernate.Engine.Transaction.Isolater : object {
    private static INHibernateLogger log;
    private static Isolater();
    public static Task DoIsolatedWorkAsync(IIsolatedWork work, ISessionImplementor session, CancellationToken cancellationToken);
    public static Task DoNonTransactedWorkAsync(IIsolatedWork work, ISessionImplementor session, CancellationToken cancellationToken);
    public static void DoIsolatedWork(IIsolatedWork work, ISessionImplementor session);
    public static void DoNonTransactedWork(IIsolatedWork work, ISessionImplementor session);
}
public abstract class NHibernate.Engine.TransactionHelper : object {
    public abstract virtual Task`1<object> DoWorkInCurrentTransactionAsync(ISessionImplementor session, DbConnection conn, DbTransaction transaction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.TransactionHelper/<DoWorkInNewTransactionAsync>d__2")]
public virtual Task`1<object> DoWorkInNewTransactionAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual object DoWorkInCurrentTransaction(ISessionImplementor session, DbConnection conn, DbTransaction transaction);
    public virtual object DoWorkInNewTransaction(ISessionImplementor session);
}
public static class NHibernate.Engine.TwoPhaseLoad : object {
    private static INHibernateLogger log;
    private static TwoPhaseLoad();
    public static Task InitializeEntityAsync(object entity, bool readOnly, ISessionImplementor session, PreLoadEvent preLoadEvent, PostLoadEvent postLoadEvent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.TwoPhaseLoad/<InitializeEntityAsync>d__1")]
internal static Task InitializeEntityAsync(object entity, bool readOnly, ISessionImplementor session, PreLoadEvent preLoadEvent, PostLoadEvent postLoadEvent, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use the overload without lazyPropertiesAreUnfetched parameter instead")]
public static void PostHydrate(IEntityPersister persister, object id, Object[] values, object rowId, object obj, LockMode lockMode, bool lazyPropertiesAreUnfetched, ISessionImplementor session);
    public static void PostHydrate(IEntityPersister persister, object id, Object[] values, object rowId, object obj, LockMode lockMode, ISessionImplementor session);
    public static void InitializeEntity(object entity, bool readOnly, ISessionImplementor session, PreLoadEvent preLoadEvent, PostLoadEvent postLoadEvent);
    internal static void InitializeEntity(object entity, bool readOnly, ISessionImplementor session, PreLoadEvent preLoadEvent, PostLoadEvent postLoadEvent, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler);
    private static bool UseMinimalPuts(ISessionImplementor session, EntityEntry entityEntry);
    [ObsoleteAttribute("Use the overload without the lazyPropertiesAreUnfetched parameter")]
public static void AddUninitializedEntity(EntityKey key, object obj, IEntityPersister persister, LockMode lockMode, bool lazyPropertiesAreUnfetched, ISessionImplementor session);
    public static void AddUninitializedEntity(EntityKey key, object obj, IEntityPersister persister, LockMode lockMode, ISessionImplementor session);
    [ObsoleteAttribute("Use the overload without the lazyPropertiesAreUnfetched parameter")]
public static void AddUninitializedCachedEntity(EntityKey key, object obj, IEntityPersister persister, LockMode lockMode, bool lazyPropertiesAreUnfetched, object version, ISessionImplementor session);
    public static void AddUninitializedCachedEntity(EntityKey key, object obj, IEntityPersister persister, LockMode lockMode, object version, ISessionImplementor session);
}
public class NHibernate.Engine.TypedValue : object {
    private IType type;
    private object value;
    private IEqualityComparer`1<TypedValue> comparer;
    public object Value { get; }
    public IType Type { get; }
    public IEqualityComparer`1<TypedValue> Comparer { get; }
    public TypedValue(IType type, object value);
    public TypedValue(IType type, object value, bool isList);
    public object get_Value();
    public IType get_Type();
    public IEqualityComparer`1<TypedValue> get_Comparer();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public static class NHibernate.Engine.UnsavedValueFactory : object {
    private static Object[] NoParameters;
    private static UnsavedValueFactory();
    private static object Instantiate(ConstructorInfo constructor);
    public static IdentifierValue GetUnsavedIdentifierValue(string unsavedValue, IGetter identifierGetter, IType identifierType, ConstructorInfo constructor);
    public static VersionValue GetUnsavedVersionValue(string versionUnsavedValue, IGetter versionGetter, IVersionType versionType, ConstructorInfo constructor);
}
public enum NHibernate.Engine.ValueInclusion : Enum {
    public int value__;
    public static ValueInclusion None;
    public static ValueInclusion Partial;
    public static ValueInclusion Full;
}
public class NHibernate.Engine.Versioning : object {
    private static INHibernateLogger log;
    private static Versioning();
    [AsyncStateMachineAttribute("NHibernate.Engine.Versioning/<IncrementAsync>d__0")]
public static Task`1<object> IncrementAsync(object version, IVersionType versionType, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Versioning/<SeedAsync>d__1")]
public static Task`1<object> SeedAsync(IVersionType versionType, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Engine.Versioning/<SeedVersionAsync>d__2")]
public static Task`1<bool> SeedVersionAsync(Object[] fields, int versionProperty, IVersionType versionType, Nullable`1<bool> force, ISessionImplementor session, CancellationToken cancellationToken);
    public static object Increment(object version, IVersionType versionType, ISessionImplementor session);
    public static object Seed(IVersionType versionType, ISessionImplementor session);
    public static bool SeedVersion(Object[] fields, int versionProperty, IVersionType versionType, Nullable`1<bool> force, ISessionImplementor session);
    public static void SetVersion(Object[] fields, object version, IEntityPersister persister);
    public static object GetVersion(Object[] fields, IEntityPersister persister);
    public static bool IsVersionIncrementRequired(Int32[] dirtyProperties, bool hasDirtyCollections, Boolean[] propertyVersionability);
}
public class NHibernate.Engine.VersionValue : object {
    private static INHibernateLogger log;
    private object value;
    private static string UnsavedStrategyLog;
    public static VersionValue VersionSaveNull;
    public static VersionValue VersionUndefined;
    public static VersionValue VersionNegative;
    public VersionValue(object value);
    private static VersionValue();
    public virtual Nullable`1<bool> IsUnsaved(object version);
    public virtual object GetDefaultValue(object currentValue);
}
[ExtensionAttribute]
public static class NHibernate.EntityJoinExtensions : object {
    [ExtensionAttribute]
public static TThis JoinEntityAlias(TThis queryOver, Expression`1<Func`1<TEntity>> alias, ICriterion withClause, JoinType joinType, string entityName);
    [ExtensionAttribute]
public static TThis JoinEntityAlias(TThis queryOver, Expression`1<Func`1<TEntity>> alias, Expression`1<Func`1<bool>> withClause, JoinType joinType, string entityName);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TEntity> JoinEntityQueryOver(IQueryOver`1<TRoot> queryOver, Expression`1<Func`1<TEntity>> alias, Expression`1<Func`1<bool>> withClause, JoinType joinType, string entityName);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TEntity> JoinEntityQueryOver(IQueryOver`1<TRoot> queryOver, Expression`1<Func`1<TEntity>> alias, ICriterion withClause, JoinType joinType, string entityName);
    [ExtensionAttribute]
public static ICriteria CreateEntityAlias(ICriteria criteria, string alias, ICriterion withClause, JoinType joinType, string entityName);
    [ExtensionAttribute]
public static ICriteria CreateEntityAlias(ICriteria criteria, Expression`1<Func`1<U>> alias, ICriterion withClause, JoinType joinType, string entityName);
    [ExtensionAttribute]
public static ICriteria CreateEntityCriteria(ICriteria criteria, string alias, ICriterion withClause, JoinType joinType, string entityName);
    [ExtensionAttribute]
public static ICriteria CreateEntityCriteria(ICriteria criteria, Expression`1<Func`1<U>> alias, ICriterion withClause, JoinType joinType, string entityName);
    private static T CastOrThrow(object obj);
}
public enum NHibernate.EntityMode : Enum {
    public int value__;
    public static EntityMode Poco;
    public static EntityMode Map;
}
public abstract class NHibernate.Event.AbstractCollectionEvent : AbstractEvent {
    private object affectedOwner;
    private string affectedOwnerEntityName;
    private object affectedOwnerId;
    private IPersistentCollection collection;
    public IPersistentCollection Collection { get; }
    public object AffectedOwnerOrNull { get; }
    public object AffectedOwnerIdOrNull { get; }
    protected AbstractCollectionEvent(ICollectionPersister collectionPersister, IPersistentCollection collection, IEventSource source, object affectedOwner, object affectedOwnerId);
    public IPersistentCollection get_Collection();
    public object get_AffectedOwnerOrNull();
    public object get_AffectedOwnerIdOrNull();
    protected static ICollectionPersister GetLoadedCollectionPersister(IPersistentCollection collection, IEventSource source);
    protected static object GetLoadedOwnerOrNull(IPersistentCollection collection, IEventSource source);
    protected static object GetLoadedOwnerIdOrNull(IPersistentCollection collection, IEventSource source);
    protected static object GetOwnerIdOrNull(object owner, IEventSource source);
    protected static string GetAffectedOwnerEntityName(ICollectionPersister collectionPersister, object affectedOwner, IEventSource source);
    public virtual string GetAffectedOwnerEntityName();
}
public class NHibernate.Event.AbstractEvent : object {
    [CompilerGeneratedAttribute]
private IEventSource <Session>k__BackingField;
    public IEventSource Session { get; private set; }
    public AbstractEvent(IEventSource source);
    [CompilerGeneratedAttribute]
public sealed virtual IEventSource get_Session();
    [CompilerGeneratedAttribute]
private void set_Session(IEventSource value);
}
public class NHibernate.Event.AbstractPostDatabaseOperationEvent : AbstractEvent {
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IEntityPersister <Persister>k__BackingField;
    public object Entity { get; private set; }
    public object Id { get; private set; }
    public IEntityPersister Persister { get; private set; }
    protected AbstractPostDatabaseOperationEvent(IEventSource source, object entity, object id, IEntityPersister persister);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Entity();
    [CompilerGeneratedAttribute]
private void set_Entity(object value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(object value);
    [CompilerGeneratedAttribute]
public sealed virtual IEntityPersister get_Persister();
    [CompilerGeneratedAttribute]
private void set_Persister(IEntityPersister value);
}
public abstract class NHibernate.Event.AbstractPreDatabaseOperationEvent : AbstractEvent {
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IEntityPersister <Persister>k__BackingField;
    public object Entity { get; private set; }
    public object Id { get; private set; }
    public IEntityPersister Persister { get; private set; }
    protected AbstractPreDatabaseOperationEvent(IEventSource source, object entity, object id, IEntityPersister persister);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Entity();
    [CompilerGeneratedAttribute]
private void set_Entity(object value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(object value);
    [CompilerGeneratedAttribute]
public sealed virtual IEntityPersister get_Persister();
    [CompilerGeneratedAttribute]
private void set_Persister(IEntityPersister value);
}
public class NHibernate.Event.AutoFlushEvent : FlushEvent {
    private ISet`1<string> querySpaces;
    private bool flushRequired;
    public ISet`1<string> QuerySpaces { get; public set; }
    public bool FlushRequired { get; public set; }
    public AutoFlushEvent(ISet`1<string> querySpaces, IEventSource source);
    public ISet`1<string> get_QuerySpaces();
    public void set_QuerySpaces(ISet`1<string> value);
    public bool get_FlushRequired();
    public void set_FlushRequired(bool value);
}
public abstract class NHibernate.Event.Default.AbstractFlushingEventListener : object {
    private static INHibernateLogger log;
    protected object Anything { get; }
    protected CascadingAction CascadingAction { get; }
    private static AbstractFlushingEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractFlushingEventListener/<FlushEverythingToExecutionsAsync>d__0")]
protected virtual Task FlushEverythingToExecutionsAsync(FlushEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractFlushingEventListener/<FlushCollectionsAsync>d__1")]
protected virtual Task FlushCollectionsAsync(IEventSource session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractFlushingEventListener/<FlushEntitiesAsync>d__2")]
protected virtual Task FlushEntitiesAsync(FlushEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractFlushingEventListener/<PrepareCollectionFlushesAsync>d__3")]
protected virtual Task PrepareCollectionFlushesAsync(ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractFlushingEventListener/<PrepareEntityFlushesAsync>d__4")]
protected virtual Task PrepareEntityFlushesAsync(IEventSource session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractFlushingEventListener/<CascadeOnFlushAsync>d__5")]
protected virtual Task CascadeOnFlushAsync(IEventSource session, IEntityPersister persister, object key, object anything, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractFlushingEventListener/<PerformExecutionsAsync>d__6")]
protected virtual Task PerformExecutionsAsync(IEventSource session, CancellationToken cancellationToken);
    protected virtual object get_Anything();
    protected virtual CascadingAction get_CascadingAction();
    protected virtual void FlushEverythingToExecutions(FlushEvent event);
    protected virtual void FlushCollections(IEventSource session);
    protected virtual void FlushEntities(FlushEvent event);
    protected virtual void PrepareCollectionFlushes(ISessionImplementor session);
    protected virtual void PrepareEntityFlushes(IEventSource session);
    protected virtual void CascadeOnFlush(IEventSource session, IEntityPersister persister, object key, object anything);
    protected virtual void PerformExecutions(IEventSource session);
    protected virtual void PostFlush(ISessionImplementor session);
}
public class NHibernate.Event.Default.AbstractLockUpgradeEventListener : AbstractReassociateEventListener {
    private static INHibernateLogger log;
    private static AbstractLockUpgradeEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractLockUpgradeEventListener/<UpgradeLockAsync>d__0")]
protected virtual Task UpgradeLockAsync(object entity, EntityEntry entry, LockMode requestedLockMode, ISessionImplementor source, CancellationToken cancellationToken);
    protected virtual void UpgradeLock(object entity, EntityEntry entry, LockMode requestedLockMode, ISessionImplementor source);
}
public class NHibernate.Event.Default.AbstractReassociateEventListener : object {
    private static INHibernateLogger log;
    private static AbstractReassociateEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractReassociateEventListener/<ReassociateAsync>d__0")]
protected Task`1<EntityEntry> ReassociateAsync(AbstractEvent event, object entity, object id, IEntityPersister persister, CancellationToken cancellationToken);
    protected EntityEntry Reassociate(AbstractEvent event, object entity, object id, IEntityPersister persister);
}
public abstract class NHibernate.Event.Default.AbstractSaveEventListener : AbstractReassociateEventListener {
    private static INHibernateLogger log;
    protected Nullable`1<bool> AssumedUnsaved { get; }
    protected CascadingAction CascadeAction { get; }
    protected bool VersionIncrementDisabled { get; }
    private static AbstractSaveEventListener();
    protected virtual Task`1<object> SaveWithRequestedIdAsync(object entity, object requestedId, string entityName, object anything, IEventSource source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractSaveEventListener/<SaveWithGeneratedIdAsync>d__1")]
protected virtual Task`1<object> SaveWithGeneratedIdAsync(object entity, string entityName, object anything, IEventSource source, bool requiresImmediateIdAccess, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractSaveEventListener/<PerformSaveAsync>d__2")]
protected virtual Task`1<object> PerformSaveAsync(object entity, object id, IEntityPersister persister, bool useIdentityColumn, object anything, IEventSource source, bool requiresImmediateIdAccess, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractSaveEventListener/<PerformSaveOrReplicateAsync>d__3")]
protected virtual Task`1<object> PerformSaveOrReplicateAsync(object entity, EntityKey key, IEntityPersister persister, bool useIdentityColumn, object anything, IEventSource source, bool requiresImmediateIdAccess, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractSaveEventListener/<VisitCollectionsBeforeSaveAsync>d__4")]
protected virtual Task`1<bool> VisitCollectionsBeforeSaveAsync(object entity, object id, Object[] values, IType[] types, IEventSource source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractSaveEventListener/<SubstituteValuesIfNecessaryAsync>d__5")]
protected virtual Task`1<bool> SubstituteValuesIfNecessaryAsync(object entity, object id, Object[] values, IEntityPersister persister, ISessionImplementor source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractSaveEventListener/<CascadeBeforeSaveAsync>d__6")]
protected virtual Task CascadeBeforeSaveAsync(IEventSource source, IEntityPersister persister, object entity, object anything, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractSaveEventListener/<CascadeAfterSaveAsync>d__7")]
protected virtual Task CascadeAfterSaveAsync(IEventSource source, IEntityPersister persister, object entity, object anything, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractSaveEventListener/<GetEntityStateAsync>d__8")]
protected virtual Task`1<EntityState> GetEntityStateAsync(object entity, string entityName, EntityEntry entry, ISessionImplementor source, CancellationToken cancellationToken);
    protected virtual Nullable`1<bool> get_AssumedUnsaved();
    protected abstract virtual CascadingAction get_CascadeAction();
    protected virtual bool get_VersionIncrementDisabled();
    protected virtual bool InvokeSaveLifecycle(object entity, IEntityPersister persister, IEventSource source);
    protected virtual void Validate(object entity, IEntityPersister persister, IEventSource source);
    protected virtual object SaveWithRequestedId(object entity, object requestedId, string entityName, object anything, IEventSource source);
    protected virtual object SaveWithGeneratedId(object entity, string entityName, object anything, IEventSource source, bool requiresImmediateIdAccess);
    protected virtual object PerformSave(object entity, object id, IEntityPersister persister, bool useIdentityColumn, object anything, IEventSource source, bool requiresImmediateIdAccess);
    protected virtual object PerformSaveOrReplicate(object entity, EntityKey key, IEntityPersister persister, bool useIdentityColumn, object anything, IEventSource source, bool requiresImmediateIdAccess);
    private void MarkInterceptorDirty(object entity, IEntityPersister persister, IEventSource source);
    protected virtual IDictionary GetMergeMap(object anything);
    protected virtual bool VisitCollectionsBeforeSave(object entity, object id, Object[] values, IType[] types, IEventSource source);
    protected virtual bool SubstituteValuesIfNecessary(object entity, object id, Object[] values, IEntityPersister persister, ISessionImplementor source);
    protected virtual void CascadeBeforeSave(IEventSource source, IEntityPersister persister, object entity, object anything);
    protected virtual void CascadeAfterSave(IEventSource source, IEntityPersister persister, object entity, object anything);
    protected virtual EntityState GetEntityState(object entity, string entityName, EntityEntry entry, ISessionImplementor source);
    protected virtual string GetLoggableName(string entityName, object entity);
}
public abstract class NHibernate.Event.Default.AbstractVisitor : object {
    private IEventSource session;
    public IEventSource Session { get; }
    public AbstractVisitor(IEventSource session);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractVisitor/<ProcessValuesAsync>d__0")]
internal Task ProcessValuesAsync(Object[] values, IType[] types, CancellationToken cancellationToken);
    internal virtual Task ProcessValueAsync(int i, Object[] values, IType[] types, CancellationToken cancellationToken);
    internal Task`1<object> ProcessValueAsync(object value, IType type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractVisitor/<ProcessComponentAsync>d__3")]
internal virtual Task`1<object> ProcessComponentAsync(object component, IAbstractComponentType componentType, CancellationToken cancellationToken);
    internal virtual Task`1<object> ProcessCollectionAsync(object value, CollectionType collectionType, CancellationToken cancellationToken);
    internal virtual Task ProcessAsync(object obj, IEntityPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.AbstractVisitor/<ProcessEntityPropertyValuesAsync>d__6")]
public Task ProcessEntityPropertyValuesAsync(Object[] values, IType[] types, CancellationToken cancellationToken);
    public IEventSource get_Session();
    internal void ProcessValues(Object[] values, IType[] types);
    internal virtual void ProcessValue(int i, Object[] values, IType[] types);
    internal object ProcessValue(object value, IType type);
    internal virtual object ProcessComponent(object component, IAbstractComponentType componentType);
    internal virtual object ProcessEntity(object value, EntityType entityType);
    internal virtual object ProcessCollection(object value, CollectionType collectionType);
    internal virtual void Process(object obj, IEntityPersister persister);
    public void ProcessEntityPropertyValues(Object[] values, IType[] types);
    internal virtual bool IncludeEntityProperty(Object[] values, int i);
    internal bool IncludeProperty(Object[] values, int i);
}
public class NHibernate.Event.Default.DefaultAutoFlushEventListener : AbstractFlushingEventListener {
    private static INHibernateLogger log;
    private static DefaultAutoFlushEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultAutoFlushEventListener/<OnAutoFlushAsync>d__0")]
public virtual Task OnAutoFlushAsync(AutoFlushEvent event, CancellationToken cancellationToken);
    public virtual void OnAutoFlush(AutoFlushEvent event);
    private bool FlushIsReallyNeeded(AutoFlushEvent event, IEventSource source);
    private bool FlushMightBeNeeded(IEventSource source);
}
public class NHibernate.Event.Default.DefaultDeleteEventListener : object {
    private static INHibernateLogger log;
    private static DefaultDeleteEventListener();
    public virtual Task OnDeleteAsync(DeleteEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultDeleteEventListener/<OnDeleteAsync>d__1")]
public virtual Task OnDeleteAsync(DeleteEvent event, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultDeleteEventListener/<DeleteTransientEntityAsync>d__2")]
protected virtual Task DeleteTransientEntityAsync(IEventSource session, object entity, bool cascadeDeleteEnabled, IEntityPersister persister, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultDeleteEventListener/<DeleteEntityAsync>d__3")]
protected virtual Task DeleteEntityAsync(IEventSource session, object entity, EntityEntry entityEntry, bool isCascadeDeleteEnabled, IEntityPersister persister, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultDeleteEventListener/<CascadeBeforeDeleteAsync>d__4")]
protected virtual Task CascadeBeforeDeleteAsync(IEventSource session, IEntityPersister persister, object entity, EntityEntry entityEntry, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultDeleteEventListener/<CascadeAfterDeleteAsync>d__5")]
protected virtual Task CascadeAfterDeleteAsync(IEventSource session, IEntityPersister persister, object entity, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    public virtual void OnDelete(DeleteEvent event);
    public virtual void OnDelete(DeleteEvent event, ISet`1<object> transientEntities);
    protected virtual void PerformDetachedEntityDeletionCheck(DeleteEvent event);
    protected virtual void DeleteTransientEntity(IEventSource session, object entity, bool cascadeDeleteEnabled, IEntityPersister persister, ISet`1<object> transientEntities);
    protected virtual void DeleteEntity(IEventSource session, object entity, EntityEntry entityEntry, bool isCascadeDeleteEnabled, IEntityPersister persister, ISet`1<object> transientEntities);
    private Object[] CreateDeletedState(IEntityPersister persister, Object[] currentState, IEventSource session);
    protected virtual bool InvokeDeleteLifecycle(IEventSource session, object entity, IEntityPersister persister);
    protected virtual void CascadeBeforeDelete(IEventSource session, IEntityPersister persister, object entity, EntityEntry entityEntry, ISet`1<object> transientEntities);
    protected virtual void CascadeAfterDelete(IEventSource session, IEntityPersister persister, object entity, ISet`1<object> transientEntities);
}
public class NHibernate.Event.Default.DefaultDirtyCheckEventListener : AbstractFlushingEventListener {
    private static INHibernateLogger log;
    protected object Anything { get; }
    protected CascadingAction CascadingAction { get; }
    private static DefaultDirtyCheckEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultDirtyCheckEventListener/<OnDirtyCheckAsync>d__0")]
public virtual Task OnDirtyCheckAsync(DirtyCheckEvent event, CancellationToken cancellationToken);
    protected virtual object get_Anything();
    protected virtual CascadingAction get_CascadingAction();
    public virtual void OnDirtyCheck(DirtyCheckEvent event);
}
public class NHibernate.Event.Default.DefaultEvictEventListener : object {
    private static INHibernateLogger log;
    private static DefaultEvictEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultEvictEventListener/<OnEvictAsync>d__0")]
public virtual Task OnEvictAsync(EvictEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultEvictEventListener/<DoEvictAsync>d__1")]
protected virtual Task DoEvictAsync(object obj, EntityKey key, IEntityPersister persister, IEventSource session, CancellationToken cancellationToken);
    public virtual void OnEvict(EvictEvent event);
    protected virtual void DoEvict(object obj, EntityKey key, IEntityPersister persister, IEventSource session);
}
public class NHibernate.Event.Default.DefaultFlushEntityEventListener : object {
    private static INHibernateLogger log;
    private static DefaultFlushEntityEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<OnFlushEntityAsync>d__0")]
public virtual Task OnFlushEntityAsync(FlushEntityEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<GetValuesAsync>d__1")]
private Task`1<Object[]> GetValuesAsync(object entity, EntityEntry entry, bool mightBeDirty, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<CheckNaturalIdAsync>d__2")]
private Task CheckNaturalIdAsync(IEntityPersister persister, EntityEntry entry, Object[] current, Object[] loaded, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<WrapCollectionsAsync>d__3")]
private Task`1<bool> WrapCollectionsAsync(IEventSource session, IEntityPersister persister, IType[] types, Object[] values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<IsUpdateNecessaryAsync>d__4")]
private Task`1<bool> IsUpdateNecessaryAsync(FlushEntityEvent event, bool mightBeDirty, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<ScheduleUpdateAsync>d__5")]
private Task`1<bool> ScheduleUpdateAsync(FlushEntityEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<HandleInterceptionAsync>d__6")]
protected virtual Task`1<bool> HandleInterceptionAsync(FlushEntityEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<GetNextVersionAsync>d__7")]
private Task`1<object> GetNextVersionAsync(FlushEntityEvent event, CancellationToken cancellationToken);
    protected Task`1<bool> IsUpdateNecessaryAsync(FlushEntityEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<HasDirtyCollectionsAsync>d__9")]
private Task`1<bool> HasDirtyCollectionsAsync(FlushEntityEvent event, IEntityPersister persister, Status status, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<DirtyCheckAsync>d__10")]
protected virtual Task DirtyCheckAsync(FlushEntityEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEntityEventListener/<GetDatabaseSnapshotAsync>d__11")]
private Task`1<Object[]> GetDatabaseSnapshotAsync(ISessionImplementor session, IEntityPersister persister, object id, CancellationToken cancellationToken);
    public virtual void OnFlushEntity(FlushEntityEvent event);
    private Object[] GetValues(object entity, EntityEntry entry, bool mightBeDirty, ISessionImplementor session);
    public virtual void CheckId(object obj, IEntityPersister persister, object id);
    private void CheckNaturalId(IEntityPersister persister, EntityEntry entry, Object[] current, Object[] loaded, ISessionImplementor session);
    private bool WrapCollections(IEventSource session, IEntityPersister persister, IType[] types, Object[] values);
    private bool IsUpdateNecessary(FlushEntityEvent event, bool mightBeDirty);
    private bool ScheduleUpdate(FlushEntityEvent event);
    protected virtual void Validate(object entity, IEntityPersister persister, Status status);
    protected virtual bool HandleInterception(FlushEntityEvent event);
    protected virtual bool InvokeInterceptor(ISessionImplementor session, object entity, EntityEntry entry, Object[] values, IEntityPersister persister);
    private object GetNextVersion(FlushEntityEvent event);
    private bool IsVersionIncrementRequired(FlushEntityEvent event, EntityEntry entry, IEntityPersister persister, Int32[] dirtyProperties);
    protected bool IsUpdateNecessary(FlushEntityEvent event);
    private bool HasDirtyCollections(FlushEntityEvent event, IEntityPersister persister, Status status);
    private bool IsCollectionDirtyCheckNecessary(IEntityPersister persister, Status status);
    protected virtual void DirtyCheck(FlushEntityEvent event);
    private Object[] GetDatabaseSnapshot(ISessionImplementor session, IEntityPersister persister, object id);
}
public class NHibernate.Event.Default.DefaultFlushEventListener : AbstractFlushingEventListener {
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultFlushEventListener/<OnFlushAsync>d__0")]
public virtual Task OnFlushAsync(FlushEvent event, CancellationToken cancellationToken);
    public virtual void OnFlush(FlushEvent event);
}
public class NHibernate.Event.Default.DefaultInitializeCollectionEventListener : object {
    private static INHibernateLogger log;
    private static DefaultInitializeCollectionEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultInitializeCollectionEventListener/<OnInitializeCollectionAsync>d__0")]
public virtual Task OnInitializeCollectionAsync(InitializeCollectionEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultInitializeCollectionEventListener/<InitializeCollectionFromCacheAsync>d__1")]
private Task`1<bool> InitializeCollectionFromCacheAsync(object collectionKey, ICollectionPersister persister, IPersistentCollection collection, ISessionImplementor source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultInitializeCollectionEventListener/<AssembleAsync>d__2")]
private Task`1<bool> AssembleAsync(CacheKey ck, object ce, ICollectionPersister persister, ISessionImplementor source, IPersistentCollection collection, object collectionKey, bool alterStatistics, CancellationToken cancellationToken);
    public virtual void OnInitializeCollection(InitializeCollectionEvent event);
    private bool InitializeCollectionFromCache(object collectionKey, ICollectionPersister persister, IPersistentCollection collection, ISessionImplementor source);
    private bool Assemble(CacheKey ck, object ce, ICollectionPersister persister, ISessionImplementor source, IPersistentCollection collection, object collectionKey, bool alterStatistics);
}
public class NHibernate.Event.Default.DefaultLoadEventListener : AbstractLockUpgradeEventListener {
    private static INHibernateLogger log;
    public static object RemovedEntityMarker;
    public static object InconsistentRTNClassMarker;
    public static LockMode DefaultLockMode;
    private static DefaultLoadEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<OnLoadAsync>d__0")]
public virtual Task OnLoadAsync(LoadEvent event, LoadType loadType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<LoadAsync>d__1")]
protected virtual Task`1<object> LoadAsync(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, CancellationToken cancellationToken);
    protected virtual Task`1<object> ProxyOrLoadAsync(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<ReturnNarrowedProxyAsync>d__3")]
private Task`1<object> ReturnNarrowedProxyAsync(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, IPersistenceContext persistenceContext, object proxy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<LockAndLoadAsync>d__4")]
protected virtual Task`1<object> LockAndLoadAsync(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, ISessionImplementor source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<DoLoadAsync>d__5")]
protected virtual Task`1<object> DoLoadAsync(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<LoadFromDatasourceAsync>d__6")]
protected virtual Task`1<object> LoadFromDatasourceAsync(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<LoadFromSessionCacheAsync>d__7")]
protected virtual Task`1<object> LoadFromSessionCacheAsync(LoadEvent event, EntityKey keyToLoad, LoadType options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<LoadFromSecondLevelCacheAsync>d__8")]
protected virtual Task`1<object> LoadFromSecondLevelCacheAsync(LoadEvent event, IEntityPersister persister, LoadType options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLoadEventListener/<AssembleCacheEntryAsync>d__9")]
private Task`1<object> AssembleCacheEntryAsync(CacheEntry entry, object id, IEntityPersister persister, LoadEvent event, CancellationToken cancellationToken);
    public virtual void OnLoad(LoadEvent event, LoadType loadType);
    protected virtual object Load(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options);
    protected virtual object ProxyOrLoad(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options);
    private object ReturnNarrowedProxy(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, IPersistenceContext persistenceContext, object proxy);
    private object CreateProxyIfNecessary(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, IPersistenceContext persistenceContext);
    protected virtual object LockAndLoad(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options, ISessionImplementor source);
    protected virtual object DoLoad(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options);
    protected virtual object LoadFromDatasource(LoadEvent event, IEntityPersister persister, EntityKey keyToLoad, LoadType options);
    protected virtual object LoadFromSessionCache(LoadEvent event, EntityKey keyToLoad, LoadType options);
    protected virtual object LoadFromSecondLevelCache(LoadEvent event, IEntityPersister persister, LoadType options);
    private object AssembleCacheEntry(CacheEntry entry, object id, IEntityPersister persister, LoadEvent event);
    protected virtual IEntityPersister GetEntityPersister(ISessionFactoryImplementor factory, string entityName);
    [CompilerGeneratedAttribute]
private Task`1<object> <LoadFromSecondLevelCacheAsync>g__AssembleAsync|8_0(CacheKey ck, object ce, LoadEvent evt, bool alterStatistics, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
private object <LoadFromSecondLevelCache>g__Assemble|23_0(CacheKey ck, object ce, LoadEvent evt, bool alterStatistics, <>c__DisplayClass23_0& );
}
public class NHibernate.Event.Default.DefaultLockEventListener : AbstractLockUpgradeEventListener {
    public virtual Task OnLockAsync(LockEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultLockEventListener/<CascadeOnLockAsync>d__1")]
private Task CascadeOnLockAsync(LockEvent event, IEntityPersister persister, object entity, CancellationToken cancellationToken);
    public virtual void OnLock(LockEvent event);
    private void CascadeOnLock(LockEvent event, IEntityPersister persister, object entity);
}
public class NHibernate.Event.Default.DefaultMergeEventListener : AbstractSaveEventListener {
    private static INHibernateLogger log;
    protected CascadingAction CascadeAction { get; }
    protected Nullable`1<bool> AssumedUnsaved { get; }
    private static DefaultMergeEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<OnMergeAsync>d__0")]
public virtual Task OnMergeAsync(MergeEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<OnMergeAsync>d__1")]
public virtual Task OnMergeAsync(MergeEvent event, IDictionary copiedAlready, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<EntityIsPersistentAsync>d__2")]
protected virtual Task EntityIsPersistentAsync(MergeEvent event, IDictionary copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<EntityIsTransientAsync>d__3")]
protected virtual Task EntityIsTransientAsync(MergeEvent event, IDictionary copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<MergeTransientEntityAsync>d__4")]
private Task`1<object> MergeTransientEntityAsync(object entity, string entityName, object requestedId, IEventSource source, IDictionary copyCache, CancellationToken cancellationToken);
    private Task SaveTransientEntityAsync(object entity, string entityName, object requestedId, IEventSource source, IDictionary copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<EntityIsDetachedAsync>d__6")]
protected virtual Task EntityIsDetachedAsync(MergeEvent event, IDictionary copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<CopyValuesAsync>d__7")]
protected virtual Task CopyValuesAsync(IEntityPersister persister, object entity, object target, ISessionImplementor source, IDictionary copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<CopyValuesAsync>d__8")]
protected virtual Task CopyValuesAsync(IEntityPersister persister, object entity, object target, ISessionImplementor source, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<CascadeOnMergeAsync>d__9")]
protected virtual Task CascadeOnMergeAsync(IEventSource source, IEntityPersister persister, object entity, IDictionary copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<GetTransientCopyCacheAsync>d__10")]
protected Task`1<EventCache> GetTransientCopyCacheAsync(MergeEvent event, EventCache copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultMergeEventListener/<RetryMergeTransientEntitiesAsync>d__11")]
protected Task RetryMergeTransientEntitiesAsync(MergeEvent event, IDictionary transientCopyCache, EventCache copyCache, CancellationToken cancellationToken);
    protected virtual Task CascadeAfterSaveAsync(IEventSource source, IEntityPersister persister, object entity, object anything, CancellationToken cancellationToken);
    protected virtual Task CascadeBeforeSaveAsync(IEventSource source, IEntityPersister persister, object entity, object anything, CancellationToken cancellationToken);
    protected virtual CascadingAction get_CascadeAction();
    protected virtual Nullable`1<bool> get_AssumedUnsaved();
    protected virtual IDictionary GetMergeMap(object anything);
    public virtual void OnMerge(MergeEvent event);
    public virtual void OnMerge(MergeEvent event, IDictionary copiedAlready);
    protected virtual void EntityIsPersistent(MergeEvent event, IDictionary copyCache);
    protected virtual void EntityIsTransient(MergeEvent event, IDictionary copyCache);
    private object MergeTransientEntity(object entity, string entityName, object requestedId, IEventSource source, IDictionary copyCache);
    private void SaveTransientEntity(object entity, string entityName, object requestedId, IEventSource source, IDictionary copyCache);
    protected virtual void EntityIsDetached(MergeEvent event, IDictionary copyCache);
    protected virtual bool InvokeUpdateLifecycle(object entity, IEntityPersister persister, IEventSource source);
    private void MarkInterceptorDirty(object entity, IEntityPersister persister, object target);
    private static bool IsVersionChanged(object entity, IEventSource source, IEntityPersister persister, object target);
    private static bool ExistsInDatabase(object entity, IEventSource source, IEntityPersister persister);
    protected virtual void CopyValues(IEntityPersister persister, object entity, object target, ISessionImplementor source, IDictionary copyCache);
    protected virtual void CopyValues(IEntityPersister persister, object entity, object target, ISessionImplementor source, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection);
    protected virtual void CascadeOnMerge(IEventSource source, IEntityPersister persister, object entity, IDictionary copyCache);
    protected EventCache GetTransientCopyCache(MergeEvent event, EventCache copyCache);
    protected void RetryMergeTransientEntities(MergeEvent event, IDictionary transientCopyCache, EventCache copyCache);
    protected virtual void CascadeAfterSave(IEventSource source, IEntityPersister persister, object entity, object anything);
    protected virtual void CascadeBeforeSave(IEventSource source, IEntityPersister persister, object entity, object anything);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(IEventSource source, IEntityPersister persister, object entity, object anything, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(IEventSource source, IEntityPersister persister, object entity, object anything, CancellationToken cancellationToken);
}
public class NHibernate.Event.Default.DefaultPersistEventListener : AbstractSaveEventListener {
    private static INHibernateLogger log;
    protected CascadingAction CascadeAction { get; }
    protected Nullable`1<bool> AssumedUnsaved { get; }
    private static DefaultPersistEventListener();
    public virtual Task OnPersistAsync(PersistEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultPersistEventListener/<OnPersistAsync>d__1")]
public virtual Task OnPersistAsync(PersistEvent event, IDictionary createdAlready, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultPersistEventListener/<EntityIsPersistentAsync>d__2")]
protected virtual Task EntityIsPersistentAsync(PersistEvent event, IDictionary createCache, CancellationToken cancellationToken);
    protected virtual Task EntityIsTransientAsync(PersistEvent event, IDictionary createCache, CancellationToken cancellationToken);
    protected virtual CascadingAction get_CascadeAction();
    protected virtual Nullable`1<bool> get_AssumedUnsaved();
    public virtual void OnPersist(PersistEvent event);
    public virtual void OnPersist(PersistEvent event, IDictionary createdAlready);
    protected virtual void EntityIsPersistent(PersistEvent event, IDictionary createCache);
    protected virtual void EntityIsTransient(PersistEvent event, IDictionary createCache);
}
public class NHibernate.Event.Default.DefaultPersistOnFlushEventListener : DefaultPersistEventListener {
    protected CascadingAction CascadeAction { get; }
    protected virtual CascadingAction get_CascadeAction();
}
public class NHibernate.Event.Default.DefaultPostLoadEventListener : object {
    public virtual void OnPostLoad(PostLoadEvent event);
}
public class NHibernate.Event.Default.DefaultPreLoadEventListener : object {
    public virtual Task OnPreLoadAsync(PreLoadEvent event, CancellationToken cancellationToken);
    public virtual void OnPreLoad(PreLoadEvent event);
}
public class NHibernate.Event.Default.DefaultRefreshEventListener : object {
    private static INHibernateLogger log;
    private static DefaultRefreshEventListener();
    public virtual Task OnRefreshAsync(RefreshEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultRefreshEventListener/<OnRefreshAsync>d__1")]
public virtual Task OnRefreshAsync(RefreshEvent event, IDictionary refreshedAlready, CancellationToken cancellationToken);
    private Task EvictCachedCollectionsAsync(IEntityPersister persister, object id, ISessionFactoryImplementor factory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultRefreshEventListener/<EvictCachedCollectionsAsync>d__3")]
private Task EvictCachedCollectionsAsync(IType[] types, object id, ISessionFactoryImplementor factory, CancellationToken cancellationToken);
    public virtual void OnRefresh(RefreshEvent event);
    public virtual void OnRefresh(RefreshEvent event, IDictionary refreshedAlready);
    private void EvictCachedCollections(IEntityPersister persister, object id, ISessionFactoryImplementor factory);
    private void EvictCachedCollections(IType[] types, object id, ISessionFactoryImplementor factory);
}
public class NHibernate.Event.Default.DefaultReplicateEventListener : AbstractSaveEventListener {
    private static INHibernateLogger log;
    protected bool VersionIncrementDisabled { get; }
    protected CascadingAction CascadeAction { get; }
    private static DefaultReplicateEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultReplicateEventListener/<OnReplicateAsync>d__0")]
public virtual Task OnReplicateAsync(ReplicateEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultReplicateEventListener/<PerformReplicationAsync>d__1")]
private Task PerformReplicationAsync(object entity, object id, object version, IEntityPersister persister, ReplicationMode replicationMode, IEventSource source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultReplicateEventListener/<CascadeAfterReplicateAsync>d__2")]
private Task CascadeAfterReplicateAsync(object entity, IEntityPersister persister, ReplicationMode replicationMode, IEventSource source, CancellationToken cancellationToken);
    protected virtual Task`1<bool> SubstituteValuesIfNecessaryAsync(object entity, object id, Object[] values, IEntityPersister persister, ISessionImplementor source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultReplicateEventListener/<VisitCollectionsBeforeSaveAsync>d__4")]
protected virtual Task`1<bool> VisitCollectionsBeforeSaveAsync(object entity, object id, Object[] values, IType[] types, IEventSource source, CancellationToken cancellationToken);
    public virtual void OnReplicate(ReplicateEvent event);
    private void PerformReplication(object entity, object id, object version, IEntityPersister persister, ReplicationMode replicationMode, IEventSource source);
    private void CascadeAfterReplicate(object entity, IEntityPersister persister, ReplicationMode replicationMode, IEventSource source);
    protected virtual bool get_VersionIncrementDisabled();
    protected virtual CascadingAction get_CascadeAction();
    protected virtual bool SubstituteValuesIfNecessary(object entity, object id, Object[] values, IEntityPersister persister, ISessionImplementor source);
    protected virtual bool VisitCollectionsBeforeSave(object entity, object id, Object[] values, IType[] types, IEventSource source);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<bool> <>n__0(object entity, object id, Object[] values, IType[] types, IEventSource source, CancellationToken cancellationToken);
}
public class NHibernate.Event.Default.DefaultSaveEventListener : DefaultSaveOrUpdateEventListener {
    protected virtual Task`1<object> PerformSaveOrUpdateAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    protected virtual object PerformSaveOrUpdate(SaveOrUpdateEvent event);
    protected virtual bool ReassociateIfUninitializedProxy(object obj, ISessionImplementor source);
}
public class NHibernate.Event.Default.DefaultSaveOrUpdateEventListener : AbstractSaveEventListener {
    private static INHibernateLogger log;
    protected CascadingAction CascadeAction { get; }
    private static DefaultSaveOrUpdateEventListener();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultSaveOrUpdateEventListener/<OnSaveOrUpdateAsync>d__0")]
public virtual Task OnSaveOrUpdateAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultSaveOrUpdateEventListener/<PerformSaveOrUpdateAsync>d__1")]
protected virtual Task`1<object> PerformSaveOrUpdateAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultSaveOrUpdateEventListener/<EntityIsTransientAsync>d__2")]
protected virtual Task`1<object> EntityIsTransientAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    protected virtual Task`1<object> SaveWithGeneratedOrRequestedIdAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    protected virtual Task EntityIsDetachedAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultSaveOrUpdateEventListener/<PerformUpdateAsync>d__5")]
protected virtual Task PerformUpdateAsync(SaveOrUpdateEvent event, object entity, IEntityPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultSaveOrUpdateEventListener/<CascadeOnUpdateAsync>d__6")]
private Task CascadeOnUpdateAsync(SaveOrUpdateEvent event, IEntityPersister persister, object entity, CancellationToken cancellationToken);
    protected virtual CascadingAction get_CascadeAction();
    public virtual void OnSaveOrUpdate(SaveOrUpdateEvent event);
    protected virtual bool ReassociateIfUninitializedProxy(object obj, ISessionImplementor source);
    protected virtual object PerformSaveOrUpdate(SaveOrUpdateEvent event);
    protected virtual object EntityIsPersistent(SaveOrUpdateEvent event);
    protected virtual object EntityIsTransient(SaveOrUpdateEvent event);
    protected virtual object SaveWithGeneratedOrRequestedId(SaveOrUpdateEvent event);
    protected virtual void EntityIsDetached(SaveOrUpdateEvent event);
    protected virtual object GetUpdateId(object entity, IEntityPersister persister, object requestedId);
    protected virtual void PerformUpdate(SaveOrUpdateEvent event, object entity, IEntityPersister persister);
    protected virtual bool InvokeUpdateLifecycle(object entity, IEntityPersister persister, IEventSource source);
    private void CascadeOnUpdate(SaveOrUpdateEvent event, IEntityPersister persister, object entity);
}
public class NHibernate.Event.Default.DefaultUpdateEventListener : DefaultSaveOrUpdateEventListener {
    [AsyncStateMachineAttribute("NHibernate.Event.Default.DefaultUpdateEventListener/<PerformSaveOrUpdateAsync>d__0")]
protected virtual Task`1<object> PerformSaveOrUpdateAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    protected virtual Task`1<object> SaveWithGeneratedOrRequestedIdAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    protected virtual object PerformSaveOrUpdate(SaveOrUpdateEvent event);
    protected virtual object SaveWithGeneratedOrRequestedId(SaveOrUpdateEvent event);
    protected virtual object GetUpdateId(object entity, IEntityPersister persister, object requestedId);
}
public class NHibernate.Event.Default.DirtyCollectionSearchVisitor : AbstractVisitor {
    private Boolean[] propertyVersionability;
    private bool dirty;
    public bool WasDirtyCollectionFound { get; }
    public DirtyCollectionSearchVisitor(IEventSource session, Boolean[] propertyVersionability);
    internal virtual Task`1<object> ProcessCollectionAsync(object collection, CollectionType type, CancellationToken cancellationToken);
    public bool get_WasDirtyCollectionFound();
    internal virtual object ProcessCollection(object collection, CollectionType type);
    internal virtual bool IncludeEntityProperty(Object[] values, int i);
}
public enum NHibernate.Event.Default.EntityState : Enum {
    public int value__;
    public static EntityState Undefined;
    public static EntityState Persistent;
    public static EntityState Transient;
    public static EntityState Detached;
    public static EntityState Deleted;
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Event.Default.EventCache : object {
    private IDictionary entityToCopyMap;
    private IDictionary entityToOperatedOnFlagMap;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    public sealed virtual void Remove(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Clear();
    public void Add(object entity, object copy, bool isOperatedOn);
    public IDictionary InvertMap();
    public bool IsOperatedOn(object entity);
    public void SetOperatedOn(object entity, bool isOperatedOn);
}
public class NHibernate.Event.Default.EvictVisitor : AbstractVisitor {
    private static INHibernateLogger log;
    public EvictVisitor(IEventSource session);
    private static EvictVisitor();
    internal virtual Task`1<object> ProcessCollectionAsync(object collection, CollectionType type, CancellationToken cancellationToken);
    internal virtual object ProcessCollection(object collection, CollectionType type);
    public virtual void EvictCollection(object value, CollectionType type);
    private void EvictCollection(IPersistentCollection collection);
}
public class NHibernate.Event.Default.FlushVisitor : AbstractVisitor {
    private object owner;
    public FlushVisitor(IEventSource session, object owner);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.FlushVisitor/<ProcessCollectionAsync>d__0")]
internal virtual Task`1<object> ProcessCollectionAsync(object collection, CollectionType type, CancellationToken cancellationToken);
    internal virtual object ProcessCollection(object collection, CollectionType type);
}
public class NHibernate.Event.Default.OnLockVisitor : ReattachVisitor {
    public OnLockVisitor(IEventSource session, object ownerIdentifier, object owner);
    internal virtual Task`1<object> ProcessCollectionAsync(object collection, CollectionType type, CancellationToken cancellationToken);
    internal virtual object ProcessCollection(object collection, CollectionType type);
}
public class NHibernate.Event.Default.OnReplicateVisitor : ReattachVisitor {
    private bool isUpdate;
    public OnReplicateVisitor(IEventSource session, object ownerIdentifier, object owner, bool isUpdate);
    internal virtual Task`1<object> ProcessCollectionAsync(object collection, CollectionType type, CancellationToken cancellationToken);
    internal virtual object ProcessCollection(object collection, CollectionType type);
}
public class NHibernate.Event.Default.OnUpdateVisitor : ReattachVisitor {
    public OnUpdateVisitor(IEventSource session, object ownerIdentifier, object owner);
    internal virtual Task`1<object> ProcessCollectionAsync(object collection, CollectionType type, CancellationToken cancellationToken);
    internal virtual object ProcessCollection(object collection, CollectionType type);
}
public abstract class NHibernate.Event.Default.ProxyVisitor : AbstractVisitor {
    public ProxyVisitor(IEventSource session);
    internal virtual object ProcessEntity(object value, EntityType entityType);
    protected internal static bool IsOwnerUnchanged(IPersistentCollection snapshot, ICollectionPersister persister, object id);
    private static bool IsCollectionSnapshotValid(IPersistentCollection snapshot);
    protected internal void ReattachCollection(IPersistentCollection collection, CollectionType type);
}
public abstract class NHibernate.Event.Default.ReattachVisitor : ProxyVisitor {
    private object ownerIdentifier;
    private object owner;
    private static INHibernateLogger log;
    public object OwnerIdentifier { get; }
    public object Owner { get; }
    protected ReattachVisitor(IEventSource session, object ownerIdentifier, object owner);
    private static ReattachVisitor();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.ReattachVisitor/<ProcessComponentAsync>d__0")]
internal virtual Task`1<object> ProcessComponentAsync(object component, IAbstractComponentType componentType, CancellationToken cancellationToken);
    public object get_OwnerIdentifier();
    public object get_Owner();
    internal virtual object ProcessComponent(object component, IAbstractComponentType componentType);
    internal void RemoveCollection(ICollectionPersister role, object collectionKey, IEventSource source);
    internal object ExtractCollectionKeyFromOwner(ICollectionPersister role);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<object> <>n__0(object component, IAbstractComponentType componentType, CancellationToken cancellationToken);
}
public class NHibernate.Event.Default.WrapVisitor : ProxyVisitor {
    private static INHibernateLogger log;
    private bool substitute;
    internal bool SubstitutionRequired { get; }
    public WrapVisitor(IEventSource session);
    private static WrapVisitor();
    [AsyncStateMachineAttribute("NHibernate.Event.Default.WrapVisitor/<ProcessAsync>d__0")]
internal virtual Task ProcessAsync(object obj, IEntityPersister persister, CancellationToken cancellationToken);
    internal virtual Task`1<object> ProcessCollectionAsync(object collection, CollectionType collectionType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.WrapVisitor/<ProcessValueAsync>d__2")]
internal virtual Task ProcessValueAsync(int i, Object[] values, IType[] types, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Event.Default.WrapVisitor/<ProcessComponentAsync>d__3")]
internal virtual Task`1<object> ProcessComponentAsync(object component, IAbstractComponentType componentType, CancellationToken cancellationToken);
    internal bool get_SubstitutionRequired();
    internal virtual void Process(object obj, IEntityPersister persister);
    internal virtual object ProcessCollection(object collection, CollectionType collectionType);
    private object ProcessArrayOrNewCollection(object collection, CollectionType collectionType);
    internal virtual void ProcessValue(int i, Object[] values, IType[] types);
    internal virtual object ProcessComponent(object component, IAbstractComponentType componentType);
}
public class NHibernate.Event.DeleteEvent : AbstractEvent {
    private string entityName;
    private object entity;
    private bool cascadeDeleteEnabled;
    public string EntityName { get; }
    public object Entity { get; }
    public bool CascadeDeleteEnabled { get; }
    public DeleteEvent(object entity, IEventSource source);
    public DeleteEvent(string entityName, object entity, IEventSource source);
    public DeleteEvent(string entityName, object entity, bool isCascadeDeleteEnabled, IEventSource source);
    public string get_EntityName();
    public object get_Entity();
    public bool get_CascadeDeleteEnabled();
}
public class NHibernate.Event.DirtyCheckEvent : FlushEvent {
    private bool dirty;
    public bool Dirty { get; public set; }
    public DirtyCheckEvent(IEventSource source);
    public bool get_Dirty();
    public void set_Dirty(bool value);
}
public class NHibernate.Event.EventListeners : object {
    private List`1<object> initializedListeners;
    private static IDictionary`2<ListenerType, Type> eventInterfaceFromType;
    private ILoadEventListener[] loadEventListeners;
    private ISaveOrUpdateEventListener[] saveOrUpdateEventListeners;
    private IMergeEventListener[] mergeEventListeners;
    private IPersistEventListener[] persistEventListeners;
    private IPersistEventListener[] persistOnFlushEventListeners;
    private IReplicateEventListener[] replicateEventListeners;
    private IDeleteEventListener[] deleteEventListeners;
    private IAutoFlushEventListener[] autoFlushEventListeners;
    private IDirtyCheckEventListener[] dirtyCheckEventListeners;
    private IFlushEventListener[] flushEventListeners;
    private IEvictEventListener[] evictEventListeners;
    private ILockEventListener[] lockEventListeners;
    private IRefreshEventListener[] refreshEventListeners;
    private IFlushEntityEventListener[] flushEntityEventListeners;
    private IInitializeCollectionEventListener[] initializeCollectionEventListeners;
    private IPostLoadEventListener[] postLoadEventListeners;
    private IPreLoadEventListener[] preLoadEventListeners;
    private IPreDeleteEventListener[] preDeleteEventListeners;
    private IPreUpdateEventListener[] preUpdateEventListeners;
    private IPreInsertEventListener[] preInsertEventListeners;
    private IPostDeleteEventListener[] postDeleteEventListeners;
    private IPostUpdateEventListener[] postUpdateEventListeners;
    private IPostInsertEventListener[] postInsertEventListeners;
    private IPostDeleteEventListener[] postCommitDeleteEventListeners;
    private IPostUpdateEventListener[] postCommitUpdateEventListeners;
    private IPostInsertEventListener[] postCommitInsertEventListeners;
    private IPreCollectionRecreateEventListener[] preCollectionRecreateEventListeners;
    private IPostCollectionRecreateEventListener[] postCollectionRecreateEventListeners;
    private IPreCollectionRemoveEventListener[] preCollectionRemoveEventListeners;
    private IPostCollectionRemoveEventListener[] postCollectionRemoveEventListeners;
    private IPreCollectionUpdateEventListener[] preCollectionUpdateEventListeners;
    private IPostCollectionUpdateEventListener[] postCollectionUpdateEventListeners;
    private ISaveOrUpdateEventListener[] saveEventListeners;
    private ISaveOrUpdateEventListener[] updateEventListeners;
    public ILoadEventListener[] LoadEventListeners { get; public set; }
    public ISaveOrUpdateEventListener[] SaveOrUpdateEventListeners { get; public set; }
    public IMergeEventListener[] MergeEventListeners { get; public set; }
    public IPersistEventListener[] PersistEventListeners { get; public set; }
    public IPersistEventListener[] PersistOnFlushEventListeners { get; public set; }
    public IReplicateEventListener[] ReplicateEventListeners { get; public set; }
    public IDeleteEventListener[] DeleteEventListeners { get; public set; }
    public IAutoFlushEventListener[] AutoFlushEventListeners { get; public set; }
    public IDirtyCheckEventListener[] DirtyCheckEventListeners { get; public set; }
    public IFlushEventListener[] FlushEventListeners { get; public set; }
    public IEvictEventListener[] EvictEventListeners { get; public set; }
    public ILockEventListener[] LockEventListeners { get; public set; }
    public IRefreshEventListener[] RefreshEventListeners { get; public set; }
    public IFlushEntityEventListener[] FlushEntityEventListeners { get; public set; }
    public IInitializeCollectionEventListener[] InitializeCollectionEventListeners { get; public set; }
    public IPostLoadEventListener[] PostLoadEventListeners { get; public set; }
    public IPreLoadEventListener[] PreLoadEventListeners { get; public set; }
    public IPreDeleteEventListener[] PreDeleteEventListeners { get; public set; }
    public IPreUpdateEventListener[] PreUpdateEventListeners { get; public set; }
    public IPreInsertEventListener[] PreInsertEventListeners { get; public set; }
    public IPostDeleteEventListener[] PostDeleteEventListeners { get; public set; }
    public IPostUpdateEventListener[] PostUpdateEventListeners { get; public set; }
    public IPostInsertEventListener[] PostInsertEventListeners { get; public set; }
    public IPostDeleteEventListener[] PostCommitDeleteEventListeners { get; public set; }
    public IPostUpdateEventListener[] PostCommitUpdateEventListeners { get; public set; }
    public IPostInsertEventListener[] PostCommitInsertEventListeners { get; public set; }
    public ISaveOrUpdateEventListener[] SaveEventListeners { get; public set; }
    public ISaveOrUpdateEventListener[] UpdateEventListeners { get; public set; }
    public IPreCollectionRecreateEventListener[] PreCollectionRecreateEventListeners { get; public set; }
    public IPostCollectionRecreateEventListener[] PostCollectionRecreateEventListeners { get; public set; }
    public IPreCollectionRemoveEventListener[] PreCollectionRemoveEventListeners { get; public set; }
    public IPostCollectionRemoveEventListener[] PostCollectionRemoveEventListeners { get; public set; }
    public IPreCollectionUpdateEventListener[] PreCollectionUpdateEventListeners { get; public set; }
    public IPostCollectionUpdateEventListener[] PostCollectionUpdateEventListeners { get; public set; }
    private static EventListeners();
    public ILoadEventListener[] get_LoadEventListeners();
    public void set_LoadEventListeners(ILoadEventListener[] value);
    public ISaveOrUpdateEventListener[] get_SaveOrUpdateEventListeners();
    public void set_SaveOrUpdateEventListeners(ISaveOrUpdateEventListener[] value);
    public IMergeEventListener[] get_MergeEventListeners();
    public void set_MergeEventListeners(IMergeEventListener[] value);
    public IPersistEventListener[] get_PersistEventListeners();
    public void set_PersistEventListeners(IPersistEventListener[] value);
    public IPersistEventListener[] get_PersistOnFlushEventListeners();
    public void set_PersistOnFlushEventListeners(IPersistEventListener[] value);
    public IReplicateEventListener[] get_ReplicateEventListeners();
    public void set_ReplicateEventListeners(IReplicateEventListener[] value);
    public IDeleteEventListener[] get_DeleteEventListeners();
    public void set_DeleteEventListeners(IDeleteEventListener[] value);
    public IAutoFlushEventListener[] get_AutoFlushEventListeners();
    public void set_AutoFlushEventListeners(IAutoFlushEventListener[] value);
    public IDirtyCheckEventListener[] get_DirtyCheckEventListeners();
    public void set_DirtyCheckEventListeners(IDirtyCheckEventListener[] value);
    public IFlushEventListener[] get_FlushEventListeners();
    public void set_FlushEventListeners(IFlushEventListener[] value);
    public IEvictEventListener[] get_EvictEventListeners();
    public void set_EvictEventListeners(IEvictEventListener[] value);
    public ILockEventListener[] get_LockEventListeners();
    public void set_LockEventListeners(ILockEventListener[] value);
    public IRefreshEventListener[] get_RefreshEventListeners();
    public void set_RefreshEventListeners(IRefreshEventListener[] value);
    public IFlushEntityEventListener[] get_FlushEntityEventListeners();
    public void set_FlushEntityEventListeners(IFlushEntityEventListener[] value);
    public IInitializeCollectionEventListener[] get_InitializeCollectionEventListeners();
    public void set_InitializeCollectionEventListeners(IInitializeCollectionEventListener[] value);
    public IPostLoadEventListener[] get_PostLoadEventListeners();
    public void set_PostLoadEventListeners(IPostLoadEventListener[] value);
    public IPreLoadEventListener[] get_PreLoadEventListeners();
    public void set_PreLoadEventListeners(IPreLoadEventListener[] value);
    public IPreDeleteEventListener[] get_PreDeleteEventListeners();
    public void set_PreDeleteEventListeners(IPreDeleteEventListener[] value);
    public IPreUpdateEventListener[] get_PreUpdateEventListeners();
    public void set_PreUpdateEventListeners(IPreUpdateEventListener[] value);
    public IPreInsertEventListener[] get_PreInsertEventListeners();
    public void set_PreInsertEventListeners(IPreInsertEventListener[] value);
    public IPostDeleteEventListener[] get_PostDeleteEventListeners();
    public void set_PostDeleteEventListeners(IPostDeleteEventListener[] value);
    public IPostUpdateEventListener[] get_PostUpdateEventListeners();
    public void set_PostUpdateEventListeners(IPostUpdateEventListener[] value);
    public IPostInsertEventListener[] get_PostInsertEventListeners();
    public void set_PostInsertEventListeners(IPostInsertEventListener[] value);
    public IPostDeleteEventListener[] get_PostCommitDeleteEventListeners();
    public void set_PostCommitDeleteEventListeners(IPostDeleteEventListener[] value);
    public IPostUpdateEventListener[] get_PostCommitUpdateEventListeners();
    public void set_PostCommitUpdateEventListeners(IPostUpdateEventListener[] value);
    public IPostInsertEventListener[] get_PostCommitInsertEventListeners();
    public void set_PostCommitInsertEventListeners(IPostInsertEventListener[] value);
    public ISaveOrUpdateEventListener[] get_SaveEventListeners();
    public void set_SaveEventListeners(ISaveOrUpdateEventListener[] value);
    public ISaveOrUpdateEventListener[] get_UpdateEventListeners();
    public void set_UpdateEventListeners(ISaveOrUpdateEventListener[] value);
    public IPreCollectionRecreateEventListener[] get_PreCollectionRecreateEventListeners();
    public void set_PreCollectionRecreateEventListeners(IPreCollectionRecreateEventListener[] value);
    public IPostCollectionRecreateEventListener[] get_PostCollectionRecreateEventListeners();
    public void set_PostCollectionRecreateEventListeners(IPostCollectionRecreateEventListener[] value);
    public IPreCollectionRemoveEventListener[] get_PreCollectionRemoveEventListeners();
    public void set_PreCollectionRemoveEventListeners(IPreCollectionRemoveEventListener[] value);
    public IPostCollectionRemoveEventListener[] get_PostCollectionRemoveEventListeners();
    public void set_PostCollectionRemoveEventListeners(IPostCollectionRemoveEventListener[] value);
    public IPreCollectionUpdateEventListener[] get_PreCollectionUpdateEventListeners();
    public void set_PreCollectionUpdateEventListeners(IPreCollectionUpdateEventListener[] value);
    public IPostCollectionUpdateEventListener[] get_PostCollectionUpdateEventListeners();
    public void set_PostCollectionUpdateEventListeners(IPostCollectionUpdateEventListener[] value);
    public Type GetListenerClassFor(ListenerType type);
    public virtual void InitializeListeners(Configuration cfg);
    private void InitializeListeners(Configuration cfg, Object[] list);
    public EventListeners ShallowCopy();
    public void DestroyListeners();
}
public class NHibernate.Event.EvictEvent : AbstractEvent {
    private object entity;
    public object Entity { get; public set; }
    public EvictEvent(object entity, IEventSource source);
    public object get_Entity();
    public void set_Entity(object value);
}
public class NHibernate.Event.FlushEntityEvent : AbstractEvent {
    private object entity;
    private EntityEntry entityEntry;
    private Object[] propertyValues;
    private Object[] databaseSnapshot;
    private Int32[] dirtyProperties;
    private bool hasDirtyCollection;
    private bool dirtyCheckPossible;
    private bool dirtyCheckHandledByInterceptor;
    public object Entity { get; }
    public EntityEntry EntityEntry { get; }
    public Object[] PropertyValues { get; public set; }
    public Object[] DatabaseSnapshot { get; public set; }
    public Int32[] DirtyProperties { get; public set; }
    public bool HasDirtyCollection { get; public set; }
    public bool DirtyCheckPossible { get; public set; }
    public bool DirtyCheckHandledByInterceptor { get; public set; }
    public bool HasDatabaseSnapshot { get; }
    public FlushEntityEvent(IEventSource source, object entity, EntityEntry entry);
    public object get_Entity();
    public EntityEntry get_EntityEntry();
    public Object[] get_PropertyValues();
    public void set_PropertyValues(Object[] value);
    public Object[] get_DatabaseSnapshot();
    public void set_DatabaseSnapshot(Object[] value);
    public Int32[] get_DirtyProperties();
    public void set_DirtyProperties(Int32[] value);
    public bool get_HasDirtyCollection();
    public void set_HasDirtyCollection(bool value);
    public bool get_DirtyCheckPossible();
    public void set_DirtyCheckPossible(bool value);
    public bool get_DirtyCheckHandledByInterceptor();
    public void set_DirtyCheckHandledByInterceptor(bool value);
    public bool get_HasDatabaseSnapshot();
}
public class NHibernate.Event.FlushEvent : AbstractEvent {
    public FlushEvent(IEventSource source);
}
public interface NHibernate.Event.IAutoFlushEventListener {
    public abstract virtual Task OnAutoFlushAsync(AutoFlushEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnAutoFlush(AutoFlushEvent event);
}
public interface NHibernate.Event.IDatabaseEventArgs {
    public IEventSource Session { get; }
    public abstract virtual IEventSource get_Session();
}
public interface NHibernate.Event.IDeleteEventListener {
    public abstract virtual Task OnDeleteAsync(DeleteEvent event, CancellationToken cancellationToken);
    public abstract virtual Task OnDeleteAsync(DeleteEvent event, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    public abstract virtual void OnDelete(DeleteEvent event);
    public abstract virtual void OnDelete(DeleteEvent event, ISet`1<object> transientEntities);
}
public interface NHibernate.Event.IDestructible {
    public abstract virtual void Cleanup();
}
public interface NHibernate.Event.IDirtyCheckEventListener {
    public abstract virtual Task OnDirtyCheckAsync(DirtyCheckEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnDirtyCheck(DirtyCheckEvent event);
}
public interface NHibernate.Event.IEventSource {
    public ActionQueue ActionQueue { get; }
    public bool AutoFlushSuspended { get; }
    public abstract virtual Task ForceFlushAsync(EntityEntry e, CancellationToken cancellationToken);
    public abstract virtual Task MergeAsync(string entityName, object obj, IDictionary copiedAlready, CancellationToken cancellationToken);
    public abstract virtual Task PersistAsync(string entityName, object obj, IDictionary createdAlready, CancellationToken cancellationToken);
    public abstract virtual Task PersistOnFlushAsync(string entityName, object obj, IDictionary copiedAlready, CancellationToken cancellationToken);
    public abstract virtual Task RefreshAsync(object obj, IDictionary refreshedAlready, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(string entityName, object child, bool isCascadeDeleteEnabled, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    public abstract virtual ActionQueue get_ActionQueue();
    public abstract virtual bool get_AutoFlushSuspended();
    public abstract virtual object Instantiate(IEntityPersister persister, object id);
    public abstract virtual void ForceFlush(EntityEntry e);
    public abstract virtual void Merge(string entityName, object obj, IDictionary copiedAlready);
    public abstract virtual void Persist(string entityName, object obj, IDictionary createdAlready);
    public abstract virtual void PersistOnFlush(string entityName, object obj, IDictionary copiedAlready);
    public abstract virtual void Refresh(object obj, IDictionary refreshedAlready);
    public abstract virtual void Delete(string entityName, object child, bool isCascadeDeleteEnabled, ISet`1<object> transientEntities);
    public abstract virtual IDisposable SuspendAutoFlush();
}
public interface NHibernate.Event.IEvictEventListener {
    public abstract virtual Task OnEvictAsync(EvictEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnEvict(EvictEvent event);
}
public interface NHibernate.Event.IFlushEntityEventListener {
    public abstract virtual Task OnFlushEntityAsync(FlushEntityEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnFlushEntity(FlushEntityEvent event);
}
public interface NHibernate.Event.IFlushEventListener {
    public abstract virtual Task OnFlushAsync(FlushEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnFlush(FlushEvent event);
}
public interface NHibernate.Event.IInitializable {
    public abstract virtual void Initialize(Configuration cfg);
}
public interface NHibernate.Event.IInitializeCollectionEventListener {
    public abstract virtual Task OnInitializeCollectionAsync(InitializeCollectionEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnInitializeCollection(InitializeCollectionEvent event);
}
public interface NHibernate.Event.ILoadEventListener {
    public abstract virtual Task OnLoadAsync(LoadEvent event, LoadType loadType, CancellationToken cancellationToken);
    public abstract virtual void OnLoad(LoadEvent event, LoadType loadType);
}
public interface NHibernate.Event.ILockEventListener {
    public abstract virtual Task OnLockAsync(LockEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnLock(LockEvent event);
}
public interface NHibernate.Event.IMergeEventListener {
    public abstract virtual Task OnMergeAsync(MergeEvent event, CancellationToken cancellationToken);
    public abstract virtual Task OnMergeAsync(MergeEvent event, IDictionary copiedAlready, CancellationToken cancellationToken);
    public abstract virtual void OnMerge(MergeEvent event);
    public abstract virtual void OnMerge(MergeEvent event, IDictionary copiedAlready);
}
public class NHibernate.Event.InitializeCollectionEvent : AbstractCollectionEvent {
    public InitializeCollectionEvent(IPersistentCollection collection, IEventSource source);
}
public interface NHibernate.Event.IPersistEventListener {
    public abstract virtual Task OnPersistAsync(PersistEvent event, CancellationToken cancellationToken);
    public abstract virtual Task OnPersistAsync(PersistEvent event, IDictionary createdAlready, CancellationToken cancellationToken);
    public abstract virtual void OnPersist(PersistEvent event);
    public abstract virtual void OnPersist(PersistEvent event, IDictionary createdAlready);
}
public interface NHibernate.Event.IPostCollectionRecreateEventListener {
    public abstract virtual Task OnPostRecreateCollectionAsync(PostCollectionRecreateEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPostRecreateCollection(PostCollectionRecreateEvent event);
}
public interface NHibernate.Event.IPostCollectionRemoveEventListener {
    public abstract virtual Task OnPostRemoveCollectionAsync(PostCollectionRemoveEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPostRemoveCollection(PostCollectionRemoveEvent event);
}
public interface NHibernate.Event.IPostCollectionUpdateEventListener {
    public abstract virtual Task OnPostUpdateCollectionAsync(PostCollectionUpdateEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPostUpdateCollection(PostCollectionUpdateEvent event);
}
public interface NHibernate.Event.IPostDatabaseOperationEventArgs {
    public object Entity { get; }
    public object Id { get; }
    public IEntityPersister Persister { get; }
    public abstract virtual object get_Entity();
    public abstract virtual object get_Id();
    public abstract virtual IEntityPersister get_Persister();
}
public interface NHibernate.Event.IPostDeleteEventListener {
    public abstract virtual Task OnPostDeleteAsync(PostDeleteEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPostDelete(PostDeleteEvent event);
}
public interface NHibernate.Event.IPostInsertEventListener {
    public abstract virtual Task OnPostInsertAsync(PostInsertEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPostInsert(PostInsertEvent event);
}
public interface NHibernate.Event.IPostLoadEventListener {
    public abstract virtual void OnPostLoad(PostLoadEvent event);
}
public interface NHibernate.Event.IPostUpdateEventListener {
    public abstract virtual Task OnPostUpdateAsync(PostUpdateEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPostUpdate(PostUpdateEvent event);
}
public interface NHibernate.Event.IPreCollectionRecreateEventListener {
    public abstract virtual Task OnPreRecreateCollectionAsync(PreCollectionRecreateEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPreRecreateCollection(PreCollectionRecreateEvent event);
}
public interface NHibernate.Event.IPreCollectionRemoveEventListener {
    public abstract virtual Task OnPreRemoveCollectionAsync(PreCollectionRemoveEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPreRemoveCollection(PreCollectionRemoveEvent event);
}
public interface NHibernate.Event.IPreCollectionUpdateEventListener {
    public abstract virtual Task OnPreUpdateCollectionAsync(PreCollectionUpdateEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPreUpdateCollection(PreCollectionUpdateEvent event);
}
public interface NHibernate.Event.IPreDatabaseOperationEventArgs {
    public object Entity { get; }
    public object Id { get; }
    public IEntityPersister Persister { get; }
    public abstract virtual object get_Entity();
    public abstract virtual object get_Id();
    public abstract virtual IEntityPersister get_Persister();
}
public interface NHibernate.Event.IPreDeleteEventListener {
    public abstract virtual Task`1<bool> OnPreDeleteAsync(PreDeleteEvent event, CancellationToken cancellationToken);
    public abstract virtual bool OnPreDelete(PreDeleteEvent event);
}
public interface NHibernate.Event.IPreInsertEventListener {
    public abstract virtual Task`1<bool> OnPreInsertAsync(PreInsertEvent event, CancellationToken cancellationToken);
    public abstract virtual bool OnPreInsert(PreInsertEvent event);
}
public interface NHibernate.Event.IPreLoadEventListener {
    public abstract virtual Task OnPreLoadAsync(PreLoadEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnPreLoad(PreLoadEvent event);
}
public interface NHibernate.Event.IPreUpdateEventListener {
    public abstract virtual Task`1<bool> OnPreUpdateAsync(PreUpdateEvent event, CancellationToken cancellationToken);
    public abstract virtual bool OnPreUpdate(PreUpdateEvent event);
}
public interface NHibernate.Event.IRefreshEventListener {
    public abstract virtual Task OnRefreshAsync(RefreshEvent event, CancellationToken cancellationToken);
    public abstract virtual Task OnRefreshAsync(RefreshEvent event, IDictionary refreshedAlready, CancellationToken cancellationToken);
    public abstract virtual void OnRefresh(RefreshEvent event);
    public abstract virtual void OnRefresh(RefreshEvent event, IDictionary refreshedAlready);
}
public interface NHibernate.Event.IReplicateEventListener {
    public abstract virtual Task OnReplicateAsync(ReplicateEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnReplicate(ReplicateEvent event);
}
public interface NHibernate.Event.ISaveOrUpdateEventListener {
    public abstract virtual Task OnSaveOrUpdateAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    public abstract virtual void OnSaveOrUpdate(SaveOrUpdateEvent event);
}
public enum NHibernate.Event.ListenerType : Enum {
    public int value__;
    public static ListenerType NotValidType;
    public static ListenerType Autoflush;
    public static ListenerType Merge;
    public static ListenerType Create;
    public static ListenerType CreateOnFlush;
    public static ListenerType Delete;
    public static ListenerType DirtyCheck;
    public static ListenerType Evict;
    public static ListenerType Flush;
    public static ListenerType FlushEntity;
    public static ListenerType Load;
    public static ListenerType LoadCollection;
    public static ListenerType Lock;
    public static ListenerType Refresh;
    public static ListenerType Replicate;
    public static ListenerType SaveUpdate;
    public static ListenerType Save;
    public static ListenerType PreUpdate;
    public static ListenerType Update;
    public static ListenerType PreLoad;
    public static ListenerType PreDelete;
    public static ListenerType PreInsert;
    public static ListenerType PreCollectionRecreate;
    public static ListenerType PreCollectionRemove;
    public static ListenerType PreCollectionUpdate;
    public static ListenerType PostLoad;
    public static ListenerType PostInsert;
    public static ListenerType PostUpdate;
    public static ListenerType PostDelete;
    public static ListenerType PostCommitUpdate;
    public static ListenerType PostCommitInsert;
    public static ListenerType PostCommitDelete;
    public static ListenerType PostCollectionRecreate;
    public static ListenerType PostCollectionRemove;
    public static ListenerType PostCollectionUpdate;
}
public class NHibernate.Event.LoadEvent : AbstractEvent {
    public static LockMode DefaultLockMode;
    private object entityId;
    private string entityClassName;
    private object instanceToLoad;
    private LockMode lockMode;
    private bool isAssociationFetch;
    private object result;
    public bool IsAssociationFetch { get; }
    public object EntityId { get; public set; }
    public string EntityClassName { get; public set; }
    public object InstanceToLoad { get; public set; }
    public LockMode LockMode { get; public set; }
    public object Result { get; public set; }
    private LoadEvent(object entityId, string entityClassName, object instanceToLoad, LockMode lockMode, bool isAssociationFetch, IEventSource source);
    public LoadEvent(object entityId, object instanceToLoad, IEventSource source);
    public LoadEvent(object entityId, string entityClassName, LockMode lockMode, IEventSource source);
    public LoadEvent(object entityId, string entityClassName, bool isAssociationFetch, IEventSource source);
    private static LoadEvent();
    public bool get_IsAssociationFetch();
    public object get_EntityId();
    public void set_EntityId(object value);
    public string get_EntityClassName();
    public void set_EntityClassName(string value);
    public object get_InstanceToLoad();
    public void set_InstanceToLoad(object value);
    public LockMode get_LockMode();
    public void set_LockMode(LockMode value);
    public object get_Result();
    public void set_Result(object value);
}
public static class NHibernate.Event.LoadEventListener : object {
    public static LoadType Reload;
    public static LoadType Get;
    public static LoadType Load;
    public static LoadType ImmediateLoad;
    public static LoadType InternalLoadEager;
    public static LoadType InternalLoadLazy;
    public static LoadType InternalLoadNullable;
    private static LoadEventListener();
}
public class NHibernate.Event.LoadType : object {
    private string name;
    private bool nakedEntityReturned;
    private bool allowNulls;
    private bool checkDeleted;
    private bool allowProxyCreation;
    private bool exactPersister;
    public string Name { get; }
    public bool IsAllowNulls { get; }
    public bool IsNakedEntityReturned { get; }
    public bool IsCheckDeleted { get; }
    public bool IsAllowProxyCreation { get; }
    public bool ExactPersister { get; }
    internal LoadType(string name);
    public string get_Name();
    public bool get_IsAllowNulls();
    internal LoadType SetAllowNulls(bool allowNulls);
    public bool get_IsNakedEntityReturned();
    internal LoadType SetNakedEntityReturned(bool immediateLoad);
    public bool get_IsCheckDeleted();
    internal LoadType SetCheckDeleted(bool checkDeleted);
    public bool get_IsAllowProxyCreation();
    internal LoadType SetAllowProxyCreation(bool allowProxyCreation);
    public bool get_ExactPersister();
    internal LoadType SetExactPersister(bool exactPersister);
    public virtual string ToString();
}
public class NHibernate.Event.LockEvent : AbstractEvent {
    private string entityName;
    private object entity;
    private LockMode lockMode;
    public string EntityName { get; public set; }
    public object Entity { get; public set; }
    public LockMode LockMode { get; public set; }
    public LockEvent(object entity, LockMode lockMode, IEventSource source);
    public LockEvent(string entityName, object original, LockMode lockMode, IEventSource source);
    public string get_EntityName();
    public void set_EntityName(string value);
    public object get_Entity();
    public void set_Entity(object value);
    public LockMode get_LockMode();
    public void set_LockMode(LockMode value);
}
public class NHibernate.Event.MergeEvent : AbstractEvent {
    private object original;
    private string entityName;
    private object requestedId;
    private object entity;
    private object result;
    public object Original { get; public set; }
    public string EntityName { get; public set; }
    public object RequestedId { get; public set; }
    public object Entity { get; public set; }
    public object Result { get; public set; }
    public MergeEvent(object entity, IEventSource source);
    public MergeEvent(string entityName, object original, IEventSource source);
    public MergeEvent(string entityName, object original, object id, IEventSource source);
    public object get_Original();
    public void set_Original(object value);
    public string get_EntityName();
    public void set_EntityName(string value);
    public object get_RequestedId();
    public void set_RequestedId(object value);
    public object get_Entity();
    public void set_Entity(object value);
    public object get_Result();
    public void set_Result(object value);
}
public class NHibernate.Event.PersistEvent : AbstractEvent {
    private object entity;
    private string entityName;
    public string EntityName { get; public set; }
    public object Entity { get; public set; }
    public PersistEvent(object entity, IEventSource source);
    public PersistEvent(string entityName, object original, IEventSource source);
    public string get_EntityName();
    public void set_EntityName(string value);
    public object get_Entity();
    public void set_Entity(object value);
}
public class NHibernate.Event.PostCollectionRecreateEvent : AbstractCollectionEvent {
    public PostCollectionRecreateEvent(ICollectionPersister collectionPersister, IPersistentCollection collection, IEventSource source);
}
public class NHibernate.Event.PostCollectionRemoveEvent : AbstractCollectionEvent {
    public PostCollectionRemoveEvent(ICollectionPersister collectionPersister, IPersistentCollection collection, IEventSource source, object loadedOwner);
}
public class NHibernate.Event.PostCollectionUpdateEvent : AbstractCollectionEvent {
    public PostCollectionUpdateEvent(ICollectionPersister collectionPersister, IPersistentCollection collection, IEventSource source);
}
public class NHibernate.Event.PostDeleteEvent : AbstractPostDatabaseOperationEvent {
    [CompilerGeneratedAttribute]
private Object[] <DeletedState>k__BackingField;
    public Object[] DeletedState { get; private set; }
    public PostDeleteEvent(object entity, object id, Object[] deletedState, IEntityPersister persister, IEventSource source);
    [CompilerGeneratedAttribute]
public Object[] get_DeletedState();
    [CompilerGeneratedAttribute]
private void set_DeletedState(Object[] value);
}
public class NHibernate.Event.PostInsertEvent : AbstractPostDatabaseOperationEvent {
    [CompilerGeneratedAttribute]
private Object[] <State>k__BackingField;
    public Object[] State { get; private set; }
    public PostInsertEvent(object entity, object id, Object[] state, IEntityPersister persister, IEventSource source);
    [CompilerGeneratedAttribute]
public Object[] get_State();
    [CompilerGeneratedAttribute]
private void set_State(Object[] value);
}
public class NHibernate.Event.PostLoadEvent : AbstractEvent {
    private object entity;
    private object id;
    private IEntityPersister persister;
    public object Entity { get; public set; }
    public object Id { get; public set; }
    public IEntityPersister Persister { get; public set; }
    public PostLoadEvent(IEventSource source);
    public sealed virtual object get_Entity();
    public void set_Entity(object value);
    public sealed virtual object get_Id();
    public void set_Id(object value);
    public sealed virtual IEntityPersister get_Persister();
    public void set_Persister(IEntityPersister value);
}
public class NHibernate.Event.PostUpdateEvent : AbstractPostDatabaseOperationEvent {
    [CompilerGeneratedAttribute]
private Object[] <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <OldState>k__BackingField;
    public Object[] State { get; private set; }
    public Object[] OldState { get; private set; }
    public PostUpdateEvent(object entity, object id, Object[] state, Object[] oldState, IEntityPersister persister, IEventSource source);
    [CompilerGeneratedAttribute]
public Object[] get_State();
    [CompilerGeneratedAttribute]
private void set_State(Object[] value);
    [CompilerGeneratedAttribute]
public Object[] get_OldState();
    [CompilerGeneratedAttribute]
private void set_OldState(Object[] value);
}
public class NHibernate.Event.PreCollectionRecreateEvent : AbstractCollectionEvent {
    public PreCollectionRecreateEvent(ICollectionPersister collectionPersister, IPersistentCollection collection, IEventSource source);
}
public class NHibernate.Event.PreCollectionRemoveEvent : AbstractCollectionEvent {
    public PreCollectionRemoveEvent(ICollectionPersister collectionPersister, IPersistentCollection collection, IEventSource source, object loadedOwner);
}
public class NHibernate.Event.PreCollectionUpdateEvent : AbstractCollectionEvent {
    public PreCollectionUpdateEvent(ICollectionPersister collectionPersister, IPersistentCollection collection, IEventSource source);
}
public class NHibernate.Event.PreDeleteEvent : AbstractPreDatabaseOperationEvent {
    [CompilerGeneratedAttribute]
private Object[] <DeletedState>k__BackingField;
    public Object[] DeletedState { get; private set; }
    public PreDeleteEvent(object entity, object id, Object[] deletedState, IEntityPersister persister, IEventSource source);
    [CompilerGeneratedAttribute]
public Object[] get_DeletedState();
    [CompilerGeneratedAttribute]
private void set_DeletedState(Object[] value);
}
public class NHibernate.Event.PreInsertEvent : AbstractPreDatabaseOperationEvent {
    [CompilerGeneratedAttribute]
private Object[] <State>k__BackingField;
    public Object[] State { get; private set; }
    public PreInsertEvent(object entity, object id, Object[] state, IEntityPersister persister, IEventSource source);
    [CompilerGeneratedAttribute]
public Object[] get_State();
    [CompilerGeneratedAttribute]
private void set_State(Object[] value);
}
public class NHibernate.Event.PreLoadEvent : AbstractEvent {
    private object entity;
    private Object[] state;
    private object id;
    private IEntityPersister persister;
    public object Entity { get; public set; }
    public Object[] State { get; public set; }
    public object Id { get; public set; }
    public IEntityPersister Persister { get; public set; }
    public PreLoadEvent(IEventSource source);
    public sealed virtual object get_Entity();
    public void set_Entity(object value);
    public Object[] get_State();
    public void set_State(Object[] value);
    public sealed virtual object get_Id();
    public void set_Id(object value);
    public sealed virtual IEntityPersister get_Persister();
    public void set_Persister(IEntityPersister value);
}
public class NHibernate.Event.PreUpdateEvent : AbstractPreDatabaseOperationEvent {
    [CompilerGeneratedAttribute]
private Object[] <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <OldState>k__BackingField;
    public Object[] State { get; private set; }
    public Object[] OldState { get; private set; }
    public PreUpdateEvent(object entity, object id, Object[] state, Object[] oldState, IEntityPersister persister, IEventSource source);
    [CompilerGeneratedAttribute]
public Object[] get_State();
    [CompilerGeneratedAttribute]
private void set_State(Object[] value);
    [CompilerGeneratedAttribute]
public Object[] get_OldState();
    [CompilerGeneratedAttribute]
private void set_OldState(Object[] value);
}
public class NHibernate.Event.RefreshEvent : AbstractEvent {
    private LockMode lockMode;
    private object entity;
    public object Entity { get; }
    public LockMode LockMode { get; }
    public RefreshEvent(object entity, IEventSource source);
    public RefreshEvent(object entity, LockMode lockMode, IEventSource source);
    public object get_Entity();
    public LockMode get_LockMode();
}
public class NHibernate.Event.ReplicateEvent : AbstractEvent {
    private string entityName;
    private object entity;
    private ReplicationMode replicationMode;
    public string EntityName { get; public set; }
    public object Entity { get; public set; }
    public ReplicationMode ReplicationMode { get; public set; }
    public ReplicateEvent(object entity, ReplicationMode replicationMode, IEventSource source);
    public ReplicateEvent(string entityName, object entity, ReplicationMode replicationMode, IEventSource source);
    public string get_EntityName();
    public void set_EntityName(string value);
    public object get_Entity();
    public void set_Entity(object value);
    public ReplicationMode get_ReplicationMode();
    public void set_ReplicationMode(ReplicationMode value);
}
public class NHibernate.Event.SaveOrUpdateEvent : AbstractEvent {
    private object entity;
    private string entityName;
    private object requestedId;
    private object resultEntity;
    private EntityEntry entry;
    private object resultId;
    public object Entity { get; public set; }
    public string EntityName { get; public set; }
    public object RequestedId { get; public set; }
    public object ResultEntity { get; public set; }
    public EntityEntry Entry { get; public set; }
    public object ResultId { get; public set; }
    public SaveOrUpdateEvent(object entity, IEventSource source);
    public SaveOrUpdateEvent(string entityName, object original, IEventSource source);
    public SaveOrUpdateEvent(string entityName, object original, object id, IEventSource source);
    public object get_Entity();
    public void set_Entity(object value);
    public string get_EntityName();
    public void set_EntityName(string value);
    public object get_RequestedId();
    public void set_RequestedId(object value);
    public object get_ResultEntity();
    public void set_ResultEntity(object value);
    public EntityEntry get_Entry();
    public void set_Entry(EntityEntry value);
    public object get_ResultId();
    public void set_ResultId(object value);
}
public class NHibernate.Exceptions.ADOConnectionException : ADOException {
    public ADOConnectionException(SerializationInfo info, StreamingContext context);
    public ADOConnectionException(string message, Exception innerException, string sql);
    public ADOConnectionException(string message, Exception innerException);
}
public class NHibernate.Exceptions.AdoExceptionContextInfo : object {
    [CompilerGeneratedAttribute]
private Exception <SqlException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sql>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EntityId>k__BackingField;
    public Exception SqlException { get; public set; }
    public string Message { get; public set; }
    public string Sql { get; public set; }
    public string EntityName { get; public set; }
    public object EntityId { get; public set; }
    [CompilerGeneratedAttribute]
public Exception get_SqlException();
    [CompilerGeneratedAttribute]
public void set_SqlException(Exception value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_Sql();
    [CompilerGeneratedAttribute]
public void set_Sql(string value);
    [CompilerGeneratedAttribute]
public string get_EntityName();
    [CompilerGeneratedAttribute]
public void set_EntityName(string value);
    [CompilerGeneratedAttribute]
public object get_EntityId();
    [CompilerGeneratedAttribute]
public void set_EntityId(object value);
}
public static class NHibernate.Exceptions.ADOExceptionHelper : object {
    public static string SQLNotAvailable;
    public static Exception Convert(ISQLExceptionConverter converter, AdoExceptionContextInfo exceptionContextInfo);
    public static Exception Convert(ISQLExceptionConverter converter, Exception sqlException, string message, SqlString sql);
    public static Exception Convert(ISQLExceptionConverter converter, Exception sqlException, string message);
    public static Exception Convert(ISQLExceptionConverter converter, Exception sqle, string message, SqlString sql, Object[] parameterValues, IDictionary`2<string, TypedValue> namedParameters);
    public static DbException ExtractDbException(Exception sqlException);
    public static string ExtendMessage(string message, string sql, Object[] parameterValues, IDictionary`2<string, TypedValue> namedParameters);
    public static SqlString TryGetActualSqlQuery(Exception sqle, SqlString sql);
    public static string TryGetActualSqlQuery(Exception sqle, string sql);
}
public class NHibernate.Exceptions.AggregateHibernateException : HibernateException {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Exception> <InnerExceptions>k__BackingField;
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public AggregateHibernateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateHibernateException(Exception[] innerExceptions);
    public AggregateHibernateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateHibernateException(string message, Exception[] innerExceptions);
    private AggregateHibernateException(string message, IList`1<Exception> innerExceptions);
    protected AggregateHibernateException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class NHibernate.Exceptions.ConstraintViolationException : ADOException {
    [CompilerGeneratedAttribute]
private string <ConstraintName>k__BackingField;
    public string ConstraintName { get; }
    public ConstraintViolationException(string message, Exception innerException, string sql, string constraintName);
    public ConstraintViolationException(string message, Exception innerException, string constraintName);
    public ConstraintViolationException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ConstraintName();
}
public class NHibernate.Exceptions.DataException : ADOException {
    public DataException(SerializationInfo info, StreamingContext context);
    public DataException(string message, Exception innerException, string sql);
    public DataException(string message, Exception innerException);
}
public class NHibernate.Exceptions.GenericADOException : ADOException {
    public GenericADOException(SerializationInfo info, StreamingContext context);
    public GenericADOException(string message, Exception innerException, string sql);
    public GenericADOException(string message, Exception innerException);
}
public interface NHibernate.Exceptions.IConfigurable {
    public abstract virtual void Configure(IDictionary`2<string, string> properties);
}
public interface NHibernate.Exceptions.ISQLExceptionConverter {
    public abstract virtual Exception Convert(AdoExceptionContextInfo adoExceptionContextInfo);
}
public interface NHibernate.Exceptions.IViolatedConstraintNameExtracter {
    public abstract virtual string ExtractConstraintName(DbException sqle);
}
public class NHibernate.Exceptions.LockAcquisitionException : ADOException {
    public LockAcquisitionException(SerializationInfo info, StreamingContext context);
    public LockAcquisitionException(string message, Exception innerException, string sql);
    public LockAcquisitionException(string message, Exception innerException);
}
public class NHibernate.Exceptions.NoOpViolatedConstraintNameExtracter : object {
    public virtual string ExtractConstraintName(DbException sqle);
}
internal class NHibernate.Exceptions.ReflectionBasedSqlStateExtracter : SqlStateExtracter {
    public virtual int ExtractSingleErrorCode(DbException sqle);
    public virtual string ExtractSingleSqlState(DbException sqle);
}
public static class NHibernate.Exceptions.SQLExceptionConverterFactory : object {
    private static INHibernateLogger log;
    private static SQLExceptionConverterFactory();
    public static ISQLExceptionConverter BuildSQLExceptionConverter(Dialect dialect, IDictionary`2<string, string> properties);
    public static ISQLExceptionConverter BuildMinimalSQLExceptionConverter();
    private static ISQLExceptionConverter ConstructConverter(string converterClassName, IViolatedConstraintNameExtracter violatedConstraintNameExtracter);
}
public class NHibernate.Exceptions.SQLGrammarException : ADOException {
    public SQLGrammarException(SerializationInfo info, StreamingContext context);
    public SQLGrammarException(string message, Exception innerException, string sql);
    public SQLGrammarException(string message, Exception innerException);
}
public class NHibernate.Exceptions.SqlParseException : Exception {
    public SqlParseException(string message);
    protected SqlParseException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.Exceptions.SQLStateConverter : object {
    public SQLStateConverter(IViolatedConstraintNameExtracter extracter);
    public sealed virtual Exception Convert(AdoExceptionContextInfo exceptionInfo);
    public static ADOException HandledNonSpecificException(Exception sqlException, string message, string sql);
}
public abstract class NHibernate.Exceptions.SqlStateExtracter : object {
    public int ExtractErrorCode(DbException sqle);
    public string ExtractSqlState(DbException sqle);
    public abstract virtual int ExtractSingleErrorCode(DbException sqle);
    public abstract virtual string ExtractSingleSqlState(DbException sqle);
}
public abstract class NHibernate.Exceptions.TemplatedViolatedConstraintNameExtracter : object {
    protected string ExtractUsingTemplate(string templateStart, string templateEnd, string message);
    public abstract virtual string ExtractConstraintName(DbException sqle);
}
public enum NHibernate.FetchMode : Enum {
    public int value__;
    public static FetchMode Default;
    public static FetchMode Select;
    public static FetchMode Join;
    [ObsoleteAttribute("Use Select instead")]
public static FetchMode Lazy;
    [ObsoleteAttribute("Use Join instead")]
public static FetchMode Eager;
}
public class NHibernate.FKUnmatchingColumnsException : MappingException {
    public FKUnmatchingColumnsException(string message);
    public FKUnmatchingColumnsException(string message, Exception innerException);
    protected FKUnmatchingColumnsException(SerializationInfo info, StreamingContext context);
}
public enum NHibernate.FlushMode : Enum {
    public int value__;
    public static FlushMode Unspecified;
    public static FlushMode Manual;
    [ObsoleteAttribute("Please use Manual instead.")]
public static FlushMode Never;
    public static FlushMode Commit;
    public static FlushMode Auto;
    public static FlushMode Always;
}
public class NHibernate.HibernateException : Exception {
    public HibernateException(string message);
    public HibernateException(Exception innerException);
    public HibernateException(string message, Exception innerException);
    protected HibernateException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.Hql.Ast.ANTLR.AstPolymorphicProcessor : object {
    private IASTNode _ast;
    private ISessionFactoryImplementor _factory;
    private Dictionary`2<IASTNode, IASTNode[]> _nodeMapping;
    private AstPolymorphicProcessor(IASTNode ast, ISessionFactoryImplementor factory);
    public static IASTNode[] Process(IASTNode ast, ISessionFactoryImplementor factory);
    private IASTNode[] Process();
    private IASTNode[] DuplicateTree();
    private static IASTNode DuplicateTree(IASTNode ast, IDictionary`2<IASTNode, IASTNode> nodeMapping);
    [CompilerGeneratedAttribute]
private IASTNode <DuplicateTree>b__6_0(Dictionary`2<IASTNode, IASTNode> x);
}
public class NHibernate.Hql.Ast.ANTLR.ASTQueryTranslatorFactory : object {
    public sealed virtual IQueryTranslator[] CreateQueryTranslators(IQueryExpression queryExpression, string collectionRole, bool shallow, IDictionary`2<string, IFilter> filters, ISessionFactoryImplementor factory);
    private static IQueryTranslator[] CreateQueryTranslators(IQueryExpression queryExpression, IASTNode ast, string queryIdentifier, string collectionRole, bool shallow, IDictionary`2<string, IFilter> filters, ISessionFactoryImplementor factory);
}
internal class NHibernate.Hql.Ast.ANTLR.CaseInsensitiveStringStream : ANTLRStringStream {
    public CaseInsensitiveStringStream(string input);
    public virtual int LA(int i);
}
internal static class NHibernate.Hql.Ast.ANTLR.CollectionProperties : object {
    public static Dictionary`2<string, string> HQL_COLLECTION_PROPERTIES;
    private static CollectionProperties();
    private static void Init(String[] names);
    public static bool IsCollectionProperty(string name);
    public static string GetNormalizedPropertyName(string name);
    public static bool IsAnyCollectionProperty(string name);
}
public static class NHibernate.Hql.Ast.ANTLR.CrossJoinDictionaryArrays : object {
    public static IList`1<Dictionary`2<IASTNode, IASTNode>> PerformCrossJoin(IEnumerable`1<KeyValuePair`2<IASTNode, IASTNode[]>> input);
    private static IEnumerable`1<IEnumerable`1<KeyValuePair`2<IASTNode, IASTNode>>> CrossJoinKeyValuePairList(IEnumerable`1<KeyValuePair`2<IASTNode, IASTNode[]>> input);
    private static IEnumerable`1<IEnumerable`1<KeyValuePair`2<IASTNode, IASTNode>>> ExpandKeyValuePair(KeyValuePair`2<IASTNode, IASTNode[]> input);
}
public class NHibernate.Hql.Ast.ANTLR.DetailedSemanticException : SemanticException {
    public DetailedSemanticException(string message);
    public DetailedSemanticException(string message, Exception inner);
    protected DetailedSemanticException(SerializationInfo info, StreamingContext context);
}
internal class NHibernate.Hql.Ast.ANTLR.ErrorCounter : object {
    private static INHibernateLogger log;
    private static INHibernateLogger hqlLog;
    private List`1<string> _errorList;
    private List`1<string> _warningList;
    private List`1<RecognitionException> _recognitionExceptions;
    private static ErrorCounter();
    public sealed virtual void ReportError(RecognitionException e);
    public sealed virtual void ReportError(string message);
    public sealed virtual int GetErrorCount();
    public sealed virtual void ReportWarning(string message);
    private string GetErrorString();
    public sealed virtual void ThrowQueryException();
}
[CLSCompliantAttribute("False")]
public abstract class NHibernate.Hql.Ast.ANTLR.Exec.AbstractStatementExecutor : object {
    private INHibernateLogger log;
    [CompilerGeneratedAttribute]
private HqlSqlWalker <Walker>k__BackingField;
    [CompilerGeneratedAttribute]
private IStatement <Statement>k__BackingField;
    protected HqlSqlWalker Walker { get; private set; }
    protected IStatement Statement { get; private set; }
    public SqlString[] SqlStatements { get; }
    protected IQueryable[] AffectedQueryables { get; }
    protected ISessionFactoryImplementor Factory { get; }
    protected AbstractStatementExecutor(IStatement statement, INHibernateLogger log);
    public abstract virtual Task`1<int> ExecuteAsync(QueryParameters parameters, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.Exec.AbstractStatementExecutor/<CreateTemporaryTableIfNecessaryAsync>d__1")]
protected virtual Task CreateTemporaryTableIfNecessaryAsync(IQueryable persister, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.Exec.AbstractStatementExecutor/<DropTemporaryTableIfNecessaryAsync>d__2")]
protected virtual Task DropTemporaryTableIfNecessaryAsync(IQueryable persister, ISessionImplementor session, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
protected HqlSqlWalker get_Walker();
    [CompilerGeneratedAttribute]
private void set_Walker(HqlSqlWalker value);
    [CompilerGeneratedAttribute]
protected IStatement get_Statement();
    [CompilerGeneratedAttribute]
private void set_Statement(IStatement value);
    public abstract virtual SqlString[] get_SqlStatements();
    public abstract virtual int Execute(QueryParameters parameters, ISessionImplementor session);
    protected abstract virtual IQueryable[] get_AffectedQueryables();
    protected ISessionFactoryImplementor get_Factory();
    protected virtual void CoordinateSharedCacheCleanup(ISessionImplementor session);
    [ObsoleteAttribute("This method has no more actual async calls to do, use its sync version instead.")]
protected virtual Task CoordinateSharedCacheCleanupAsync(ISessionImplementor session, CancellationToken cancellationToken);
    protected SqlString GenerateIdInsertSelect(IQueryable persister, string tableAlias, IASTNode whereClause);
    private static SqlString GetWhereJoinFragment(IJoinable persister, string tableAlias);
    protected string GenerateIdSubselect(IQueryable persister);
    protected virtual void CreateTemporaryTableIfNecessary(IQueryable persister, ISessionImplementor session);
    protected virtual bool ShouldIsolateTemporaryTableDDL();
    protected virtual void DropTemporaryTableIfNecessary(IQueryable persister, ISessionImplementor session);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Exec.BasicExecutor : AbstractStatementExecutor {
    private IQueryable persister;
    private static INHibernateLogger log;
    private SqlString sql;
    [CompilerGeneratedAttribute]
private IList`1<IParameterSpecification> <Parameters>k__BackingField;
    private IList`1<IParameterSpecification> Parameters { get; private set; }
    public SqlString[] SqlStatements { get; }
    protected IQueryable[] AffectedQueryables { get; }
    public BasicExecutor(IStatement statement, IQueryable persister);
    private static BasicExecutor();
    [AsyncStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.Exec.BasicExecutor/<ExecuteAsync>d__0")]
public virtual Task`1<int> ExecuteAsync(QueryParameters parameters, ISessionImplementor session, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private IList`1<IParameterSpecification> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<IParameterSpecification> value);
    public virtual SqlString[] get_SqlStatements();
    public virtual int Execute(QueryParameters parameters, ISessionImplementor session);
    private void CheckParametersExpectedType(QueryParameters parameters);
    protected virtual IQueryable[] get_AffectedQueryables();
}
public interface NHibernate.Hql.Ast.ANTLR.Exec.IStatementExecutor {
    public SqlString[] SqlStatements { get; }
    public abstract virtual Task`1<int> ExecuteAsync(QueryParameters parameters, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual SqlString[] get_SqlStatements();
    public abstract virtual int Execute(QueryParameters parameters, ISessionImplementor session);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Exec.MultiTableDeleteExecutor : AbstractStatementExecutor {
    private static INHibernateLogger log;
    private IQueryable persister;
    private SqlString idInsertSelect;
    private SqlString[] deletes;
    public SqlString[] SqlStatements { get; }
    protected IQueryable[] AffectedQueryables { get; }
    public MultiTableDeleteExecutor(IStatement statement);
    private static MultiTableDeleteExecutor();
    [AsyncStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.Exec.MultiTableDeleteExecutor/<ExecuteAsync>d__0")]
public virtual Task`1<int> ExecuteAsync(QueryParameters parameters, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual SqlString[] get_SqlStatements();
    public virtual int Execute(QueryParameters parameters, ISessionImplementor session);
    protected virtual IQueryable[] get_AffectedQueryables();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Exec.MultiTableUpdateExecutor : AbstractStatementExecutor {
    private static INHibernateLogger log;
    private IQueryable persister;
    private SqlString idInsertSelect;
    private SqlString[] updates;
    private IParameterSpecification[][] hqlParameters;
    public SqlString[] SqlStatements { get; }
    protected IQueryable[] AffectedQueryables { get; }
    public MultiTableUpdateExecutor(IStatement statement);
    private static MultiTableUpdateExecutor();
    [AsyncStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.Exec.MultiTableUpdateExecutor/<ExecuteAsync>d__0")]
public virtual Task`1<int> ExecuteAsync(QueryParameters parameters, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual SqlString[] get_SqlStatements();
    public virtual int Execute(QueryParameters parameters, ISessionImplementor session);
    protected virtual IQueryable[] get_AffectedQueryables();
}
internal static class NHibernate.Hql.Ast.ANTLR.HqlFilterPreprocessor : object {
    private static INHibernateLogger log;
    private static HqlFilterPreprocessor();
    internal static void AddImpliedFromToQuery(IASTNode ast, string collectionRole, ISessionFactoryImplementor factory);
    private static void AddImpliedFromToFromNode(IASTNode fromClause, string collectionRole, ISessionFactoryImplementor factory);
}
[GeneratedCodeAttribute("ANTLR", "3.5.2-rc1")]
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.HqlLexer : Lexer {
    public static int EOF;
    public static int AGGREGATE;
    public static int ALIAS;
    public static int ALL;
    public static int AND;
    public static int ANY;
    public static int AS;
    public static int ASCENDING;
    public static int AVG;
    public static int BAND;
    public static int BETWEEN;
    public static int BNOT;
    public static int BOR;
    public static int BOTH;
    public static int BXOR;
    public static int CASE;
    public static int CASE2;
    public static int CLASS;
    public static int CLOSE;
    public static int CLOSE_BRACKET;
    public static int COLON;
    public static int COMMA;
    public static int CONCAT;
    public static int CONSTANT;
    public static int CONSTRUCTOR;
    public static int COUNT;
    public static int CROSS;
    public static int DELETE;
    public static int DESCENDING;
    public static int DISTINCT;
    public static int DIV;
    public static int DOT;
    public static int ELEMENTS;
    public static int ELSE;
    public static int EMPTY;
    public static int END;
    public static int EQ;
    public static int ESCAPE;
    public static int ESCqs;
    public static int EXISTS;
    public static int EXPONENT;
    public static int EXPR_LIST;
    public static int FALSE;
    public static int FETCH;
    public static int FILTER_ENTITY;
    public static int FLOAT_SUFFIX;
    public static int FROM;
    public static int FULL;
    public static int GE;
    public static int GROUP;
    public static int GT;
    public static int HAVING;
    public static int HEX_DIGIT;
    public static int IDENT;
    public static int ID_LETTER;
    public static int ID_START_LETTER;
    public static int IN;
    public static int INDEX_OP;
    public static int INDICES;
    public static int INNER;
    public static int INSERT;
    public static int INTO;
    public static int IN_LIST;
    public static int IS;
    public static int IS_NOT_NULL;
    public static int IS_NULL;
    public static int JAVA_CONSTANT;
    public static int JOIN;
    public static int LE;
    public static int LEADING;
    public static int LEFT;
    public static int LIKE;
    public static int LITERAL_by;
    public static int LT;
    public static int MAX;
    public static int MEMBER;
    public static int METHOD_CALL;
    public static int MIN;
    public static int MINUS;
    public static int NE;
    public static int NEW;
    public static int NOT;
    public static int NOT_BETWEEN;
    public static int NOT_IN;
    public static int NOT_LIKE;
    public static int NULL;
    public static int NUM_DECIMAL;
    public static int NUM_DOUBLE;
    public static int NUM_FLOAT;
    public static int NUM_INT;
    public static int NUM_LONG;
    public static int OBJECT;
    public static int OF;
    public static int ON;
    public static int OPEN;
    public static int OPEN_BRACKET;
    public static int OR;
    public static int ORDER;
    public static int ORDER_ELEMENT;
    public static int OUTER;
    public static int PARAM;
    public static int PLUS;
    public static int PROPERTIES;
    public static int QUERY;
    public static int QUOTED_String;
    public static int RANGE;
    public static int RIGHT;
    public static int ROW_STAR;
    public static int SELECT;
    public static int SELECT_FROM;
    public static int SET;
    public static int SKIP;
    public static int SOME;
    public static int SQL_NE;
    public static int STAR;
    public static int SUM;
    public static int TAKE;
    public static int THEN;
    public static int TRAILING;
    public static int TRUE;
    public static int UNARY_MINUS;
    public static int UNARY_PLUS;
    public static int UNION;
    public static int UPDATE;
    public static int VECTOR_EXPR;
    public static int VERSIONED;
    public static int WEIRD_IDENT;
    public static int WHEN;
    public static int WHERE;
    public static int WITH;
    public static int WS;
    public static int T__134;
    public static int T__135;
    private DFA23 dfa23;
    public string GrammarFileName { get; }
    public HqlLexer(ICharStream input);
    public HqlLexer(ICharStream input, RecognizerSharedState state);
    public virtual IToken Emit();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("ALL")]
private void mALL();
    [GrammarRuleAttribute("AND")]
private void mAND();
    [GrammarRuleAttribute("ANY")]
private void mANY();
    [GrammarRuleAttribute("AS")]
private void mAS();
    [GrammarRuleAttribute("ASCENDING")]
private void mASCENDING();
    [GrammarRuleAttribute("AVG")]
private void mAVG();
    [GrammarRuleAttribute("BETWEEN")]
private void mBETWEEN();
    [GrammarRuleAttribute("BOTH")]
private void mBOTH();
    [GrammarRuleAttribute("CASE")]
private void mCASE();
    [GrammarRuleAttribute("CLASS")]
private void mCLASS();
    [GrammarRuleAttribute("COUNT")]
private void mCOUNT();
    [GrammarRuleAttribute("CROSS")]
private void mCROSS();
    [GrammarRuleAttribute("DELETE")]
private void mDELETE();
    [GrammarRuleAttribute("DESCENDING")]
private void mDESCENDING();
    [GrammarRuleAttribute("DISTINCT")]
private void mDISTINCT();
    [GrammarRuleAttribute("ELEMENTS")]
private void mELEMENTS();
    [GrammarRuleAttribute("ELSE")]
private void mELSE();
    [GrammarRuleAttribute("EMPTY")]
private void mEMPTY();
    [GrammarRuleAttribute("END")]
private void mEND();
    [GrammarRuleAttribute("ESCAPE")]
private void mESCAPE();
    [GrammarRuleAttribute("EXISTS")]
private void mEXISTS();
    [GrammarRuleAttribute("FALSE")]
private void mFALSE();
    [GrammarRuleAttribute("FETCH")]
private void mFETCH();
    [GrammarRuleAttribute("FROM")]
private void mFROM();
    [GrammarRuleAttribute("FULL")]
private void mFULL();
    [GrammarRuleAttribute("GROUP")]
private void mGROUP();
    [GrammarRuleAttribute("HAVING")]
private void mHAVING();
    [GrammarRuleAttribute("IN")]
private void mIN();
    [GrammarRuleAttribute("INDICES")]
private void mINDICES();
    [GrammarRuleAttribute("INNER")]
private void mINNER();
    [GrammarRuleAttribute("INSERT")]
private void mINSERT();
    [GrammarRuleAttribute("INTO")]
private void mINTO();
    [GrammarRuleAttribute("IS")]
private void mIS();
    [GrammarRuleAttribute("JOIN")]
private void mJOIN();
    [GrammarRuleAttribute("LEADING")]
private void mLEADING();
    [GrammarRuleAttribute("LEFT")]
private void mLEFT();
    [GrammarRuleAttribute("LIKE")]
private void mLIKE();
    [GrammarRuleAttribute("LITERAL_by")]
private void mLITERAL_by();
    [GrammarRuleAttribute("MAX")]
private void mMAX();
    [GrammarRuleAttribute("MEMBER")]
private void mMEMBER();
    [GrammarRuleAttribute("MIN")]
private void mMIN();
    [GrammarRuleAttribute("NEW")]
private void mNEW();
    [GrammarRuleAttribute("NOT")]
private void mNOT();
    [GrammarRuleAttribute("NULL")]
private void mNULL();
    [GrammarRuleAttribute("OBJECT")]
private void mOBJECT();
    [GrammarRuleAttribute("OF")]
private void mOF();
    [GrammarRuleAttribute("ON")]
private void mON();
    [GrammarRuleAttribute("OR")]
private void mOR();
    [GrammarRuleAttribute("ORDER")]
private void mORDER();
    [GrammarRuleAttribute("OUTER")]
private void mOUTER();
    [GrammarRuleAttribute("PROPERTIES")]
private void mPROPERTIES();
    [GrammarRuleAttribute("RIGHT")]
private void mRIGHT();
    [GrammarRuleAttribute("SELECT")]
private void mSELECT();
    [GrammarRuleAttribute("SET")]
private void mSET();
    [GrammarRuleAttribute("SKIP")]
private void mSKIP();
    [GrammarRuleAttribute("SOME")]
private void mSOME();
    [GrammarRuleAttribute("SUM")]
private void mSUM();
    [GrammarRuleAttribute("TAKE")]
private void mTAKE();
    [GrammarRuleAttribute("THEN")]
private void mTHEN();
    [GrammarRuleAttribute("TRAILING")]
private void mTRAILING();
    [GrammarRuleAttribute("TRUE")]
private void mTRUE();
    [GrammarRuleAttribute("UNION")]
private void mUNION();
    [GrammarRuleAttribute("UPDATE")]
private void mUPDATE();
    [GrammarRuleAttribute("VERSIONED")]
private void mVERSIONED();
    [GrammarRuleAttribute("WHEN")]
private void mWHEN();
    [GrammarRuleAttribute("WHERE")]
private void mWHERE();
    [GrammarRuleAttribute("WITH")]
private void mWITH();
    [GrammarRuleAttribute("T__134")]
private void mT__134();
    [GrammarRuleAttribute("T__135")]
private void mT__135();
    [GrammarRuleAttribute("EQ")]
private void mEQ();
    [GrammarRuleAttribute("LT")]
private void mLT();
    [GrammarRuleAttribute("GT")]
private void mGT();
    [GrammarRuleAttribute("SQL_NE")]
private void mSQL_NE();
    [GrammarRuleAttribute("NE")]
private void mNE();
    [GrammarRuleAttribute("LE")]
private void mLE();
    [GrammarRuleAttribute("GE")]
private void mGE();
    [GrammarRuleAttribute("BOR")]
private void mBOR();
    [GrammarRuleAttribute("BXOR")]
private void mBXOR();
    [GrammarRuleAttribute("BAND")]
private void mBAND();
    [GrammarRuleAttribute("BNOT")]
private void mBNOT();
    [GrammarRuleAttribute("COMMA")]
private void mCOMMA();
    [GrammarRuleAttribute("OPEN")]
private void mOPEN();
    [GrammarRuleAttribute("CLOSE")]
private void mCLOSE();
    [GrammarRuleAttribute("OPEN_BRACKET")]
private void mOPEN_BRACKET();
    [GrammarRuleAttribute("CLOSE_BRACKET")]
private void mCLOSE_BRACKET();
    [GrammarRuleAttribute("CONCAT")]
private void mCONCAT();
    [GrammarRuleAttribute("PLUS")]
private void mPLUS();
    [GrammarRuleAttribute("MINUS")]
private void mMINUS();
    [GrammarRuleAttribute("STAR")]
private void mSTAR();
    [GrammarRuleAttribute("DIV")]
private void mDIV();
    [GrammarRuleAttribute("COLON")]
private void mCOLON();
    [GrammarRuleAttribute("PARAM")]
private void mPARAM();
    [GrammarRuleAttribute("IDENT")]
private void mIDENT();
    [GrammarRuleAttribute("ID_START_LETTER")]
private void mID_START_LETTER();
    [GrammarRuleAttribute("ID_LETTER")]
private void mID_LETTER();
    [GrammarRuleAttribute("QUOTED_String")]
private void mQUOTED_String();
    [GrammarRuleAttribute("ESCqs")]
private void mESCqs();
    [GrammarRuleAttribute("WS")]
private void mWS();
    [GrammarRuleAttribute("NUM_INT")]
private void mNUM_INT();
    [GrammarRuleAttribute("HEX_DIGIT")]
private void mHEX_DIGIT();
    [GrammarRuleAttribute("EXPONENT")]
private void mEXPONENT();
    [GrammarRuleAttribute("FLOAT_SUFFIX")]
private void mFLOAT_SUFFIX();
    public virtual void mTokens();
    private void synpred1_Hql_fragment();
    private bool EvaluatePredicate(Action fragment);
    protected virtual void InitDFAs();
}
public class NHibernate.Hql.Ast.ANTLR.HqlParseEngine : object {
    private static INHibernateLogger log;
    private string _hql;
    private CommonTokenStream _tokens;
    private bool _filter;
    private ISessionFactoryImplementor _sfi;
    public HqlParseEngine(string hql, bool filter, ISessionFactoryImplementor sfi);
    private static HqlParseEngine();
    public IASTNode Parse();
}
[GeneratedCodeAttribute("ANTLR", "3.5.2-rc1")]
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.HqlParser : Parser {
    private static INHibernateLogger log;
    internal static Boolean[] possibleIds;
    private bool filter;
    private int queryDepth;
    private IParseErrorHandler _parseErrorHandler;
    internal static String[] tokenNames;
    public static int EOF;
    public static int AGGREGATE;
    public static int ALIAS;
    public static int ALL;
    public static int AND;
    public static int ANY;
    public static int AS;
    public static int ASCENDING;
    public static int AVG;
    public static int BAND;
    public static int BETWEEN;
    public static int BNOT;
    public static int BOR;
    public static int BOTH;
    public static int BXOR;
    public static int CASE;
    public static int CASE2;
    public static int CLASS;
    public static int CLOSE;
    public static int CLOSE_BRACKET;
    public static int COLON;
    public static int COMMA;
    public static int CONCAT;
    public static int CONSTANT;
    public static int CONSTRUCTOR;
    public static int COUNT;
    public static int CROSS;
    public static int DELETE;
    public static int DESCENDING;
    public static int DISTINCT;
    public static int DIV;
    public static int DOT;
    public static int ELEMENTS;
    public static int ELSE;
    public static int EMPTY;
    public static int END;
    public static int EQ;
    public static int ESCAPE;
    public static int ESCqs;
    public static int EXISTS;
    public static int EXPONENT;
    public static int EXPR_LIST;
    public static int FALSE;
    public static int FETCH;
    public static int FILTER_ENTITY;
    public static int FLOAT_SUFFIX;
    public static int FROM;
    public static int FULL;
    public static int GE;
    public static int GROUP;
    public static int GT;
    public static int HAVING;
    public static int HEX_DIGIT;
    public static int IDENT;
    public static int ID_LETTER;
    public static int ID_START_LETTER;
    public static int IN;
    public static int INDEX_OP;
    public static int INDICES;
    public static int INNER;
    public static int INSERT;
    public static int INTO;
    public static int IN_LIST;
    public static int IS;
    public static int IS_NOT_NULL;
    public static int IS_NULL;
    public static int JAVA_CONSTANT;
    public static int JOIN;
    public static int LE;
    public static int LEADING;
    public static int LEFT;
    public static int LIKE;
    public static int LITERAL_by;
    public static int LT;
    public static int MAX;
    public static int MEMBER;
    public static int METHOD_CALL;
    public static int MIN;
    public static int MINUS;
    public static int NE;
    public static int NEW;
    public static int NOT;
    public static int NOT_BETWEEN;
    public static int NOT_IN;
    public static int NOT_LIKE;
    public static int NULL;
    public static int NUM_DECIMAL;
    public static int NUM_DOUBLE;
    public static int NUM_FLOAT;
    public static int NUM_INT;
    public static int NUM_LONG;
    public static int OBJECT;
    public static int OF;
    public static int ON;
    public static int OPEN;
    public static int OPEN_BRACKET;
    public static int OR;
    public static int ORDER;
    public static int ORDER_ELEMENT;
    public static int OUTER;
    public static int PARAM;
    public static int PLUS;
    public static int PROPERTIES;
    public static int QUERY;
    public static int QUOTED_String;
    public static int RANGE;
    public static int RIGHT;
    public static int ROW_STAR;
    public static int SELECT;
    public static int SELECT_FROM;
    public static int SET;
    public static int SKIP;
    public static int SOME;
    public static int SQL_NE;
    public static int STAR;
    public static int SUM;
    public static int TAKE;
    public static int THEN;
    public static int TRAILING;
    public static int TRUE;
    public static int UNARY_MINUS;
    public static int UNARY_PLUS;
    public static int UNION;
    public static int UPDATE;
    public static int VECTOR_EXPR;
    public static int VERSIONED;
    public static int WEIRD_IDENT;
    public static int WHEN;
    public static int WHERE;
    public static int WITH;
    public static int WS;
    public static int T__134;
    public static int T__135;
    private ITreeAdaptor adaptor;
    public IParseErrorHandler ParseErrorHandler { get; public set; }
    public bool Filter { get; public set; }
    public ITreeAdaptor TreeAdaptor { get; public set; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    private static HqlParser();
    public HqlParser(ITokenStream input);
    public HqlParser(ITokenStream input, RecognizerSharedState state);
    public IParseErrorHandler get_ParseErrorHandler();
    public void set_ParseErrorHandler(IParseErrorHandler value);
    public bool get_Filter();
    public void set_Filter(bool value);
    public virtual void ReportError(RecognitionException e);
    protected virtual object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow);
    public void HandleDotIdents();
    public void WeakKeywords();
    public void WeakKeywords2();
    public IASTNode NegateNode(IASTNode node);
    public IASTNode ProcessEqualityExpression(IASTNode x);
    public void HandleDotIdent();
    private IASTNode CreateIsNullParent(IASTNode node, bool negated);
    private IASTNode ProcessIsEmpty(IASTNode node, bool negated);
    private IASTNode CreateSubquery(IASTNode node);
    public IASTNode ProcessMemberOf(IToken n, IASTNode p, IASTNode root);
    public IASTNode HandleIdentifierError(IToken token, RecognitionException ex);
    public static bool IsPossibleId(IToken token);
    public ITreeAdaptor get_TreeAdaptor();
    public void set_TreeAdaptor(ITreeAdaptor value);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("statement")]
public AstParserRuleReturnScope`2<IASTNode, IToken> statement();
    [GrammarRuleAttribute("updateStatement")]
private AstParserRuleReturnScope`2<IASTNode, IToken> updateStatement();
    [GrammarRuleAttribute("setClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> setClause();
    [GrammarRuleAttribute("assignment")]
private AstParserRuleReturnScope`2<IASTNode, IToken> assignment();
    [GrammarRuleAttribute("stateField")]
private AstParserRuleReturnScope`2<IASTNode, IToken> stateField();
    [GrammarRuleAttribute("newValue")]
private AstParserRuleReturnScope`2<IASTNode, IToken> newValue();
    [GrammarRuleAttribute("deleteStatement")]
private AstParserRuleReturnScope`2<IASTNode, IToken> deleteStatement();
    [GrammarRuleAttribute("optionalFromTokenFromClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> optionalFromTokenFromClause();
    [GrammarRuleAttribute("optionalFromTokenFromClause2")]
private AstParserRuleReturnScope`2<IASTNode, IToken> optionalFromTokenFromClause2();
    [GrammarRuleAttribute("selectStatement")]
private AstParserRuleReturnScope`2<IASTNode, IToken> selectStatement();
    [GrammarRuleAttribute("insertStatement")]
private AstParserRuleReturnScope`2<IASTNode, IToken> insertStatement();
    [GrammarRuleAttribute("intoClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> intoClause();
    [GrammarRuleAttribute("insertablePropertySpec")]
private AstParserRuleReturnScope`2<IASTNode, IToken> insertablePropertySpec();
    [GrammarRuleAttribute("queryRule")]
private AstParserRuleReturnScope`2<IASTNode, IToken> queryRule();
    [GrammarRuleAttribute("selectFrom")]
private AstParserRuleReturnScope`2<IASTNode, IToken> selectFrom();
    [GrammarRuleAttribute("selectClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> selectClause();
    [GrammarRuleAttribute("newExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> newExpression();
    [GrammarRuleAttribute("selectObject")]
private AstParserRuleReturnScope`2<IASTNode, IToken> selectObject();
    [GrammarRuleAttribute("fromClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> fromClause();
    [GrammarRuleAttribute("fromJoin")]
private AstParserRuleReturnScope`2<IASTNode, IToken> fromJoin();
    [GrammarRuleAttribute("withClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> withClause();
    [GrammarRuleAttribute("fromRange")]
private AstParserRuleReturnScope`2<IASTNode, IToken> fromRange();
    [GrammarRuleAttribute("fromClassOrOuterQueryPath")]
private AstParserRuleReturnScope`2<IASTNode, IToken> fromClassOrOuterQueryPath();
    [GrammarRuleAttribute("inClassDeclaration")]
private AstParserRuleReturnScope`2<IASTNode, IToken> inClassDeclaration();
    [GrammarRuleAttribute("inCollectionDeclaration")]
private AstParserRuleReturnScope`2<IASTNode, IToken> inCollectionDeclaration();
    [GrammarRuleAttribute("inCollectionElementsDeclaration")]
private AstParserRuleReturnScope`2<IASTNode, IToken> inCollectionElementsDeclaration();
    [GrammarRuleAttribute("asAlias")]
private AstParserRuleReturnScope`2<IASTNode, IToken> asAlias();
    [GrammarRuleAttribute("alias")]
private AstParserRuleReturnScope`2<IASTNode, IToken> alias();
    [GrammarRuleAttribute("propertyFetch")]
private AstParserRuleReturnScope`2<IASTNode, IToken> propertyFetch();
    [GrammarRuleAttribute("groupByClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> groupByClause();
    [GrammarRuleAttribute("orderByClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> orderByClause();
    [GrammarRuleAttribute("skipClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> skipClause();
    [GrammarRuleAttribute("takeClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> takeClause();
    [GrammarRuleAttribute("parameter")]
private AstParserRuleReturnScope`2<IASTNode, IToken> parameter();
    [GrammarRuleAttribute("orderElement")]
private AstParserRuleReturnScope`2<IASTNode, IToken> orderElement();
    [GrammarRuleAttribute("ascendingOrDescending")]
private AstParserRuleReturnScope`2<IASTNode, IToken> ascendingOrDescending();
    [GrammarRuleAttribute("havingClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> havingClause();
    [GrammarRuleAttribute("whereClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> whereClause();
    [GrammarRuleAttribute("selectedPropertiesList")]
private AstParserRuleReturnScope`2<IASTNode, IToken> selectedPropertiesList();
    [GrammarRuleAttribute("aliasedExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> aliasedExpression();
    [GrammarRuleAttribute("logicalExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> logicalExpression();
    [GrammarRuleAttribute("expression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> expression();
    [GrammarRuleAttribute("logicalOrExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> logicalOrExpression();
    [GrammarRuleAttribute("logicalAndExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> logicalAndExpression();
    [GrammarRuleAttribute("negatedExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> negatedExpression();
    [GrammarRuleAttribute("equalityExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> equalityExpression();
    [GrammarRuleAttribute("relationalExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> relationalExpression();
    [GrammarRuleAttribute("likeEscape")]
private AstParserRuleReturnScope`2<IASTNode, IToken> likeEscape();
    [GrammarRuleAttribute("inList")]
private AstParserRuleReturnScope`2<IASTNode, IToken> inList();
    [GrammarRuleAttribute("betweenList")]
private AstParserRuleReturnScope`2<IASTNode, IToken> betweenList();
    [GrammarRuleAttribute("concatenation")]
private AstParserRuleReturnScope`2<IASTNode, IToken> concatenation();
    [GrammarRuleAttribute("bitwiseNotExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> bitwiseNotExpression();
    [GrammarRuleAttribute("bitwiseOrExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> bitwiseOrExpression();
    [GrammarRuleAttribute("bitwiseXOrExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> bitwiseXOrExpression();
    [GrammarRuleAttribute("bitwiseAndExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> bitwiseAndExpression();
    [GrammarRuleAttribute("additiveExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> additiveExpression();
    [GrammarRuleAttribute("multiplyExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> multiplyExpression();
    [GrammarRuleAttribute("unaryExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> unaryExpression();
    [GrammarRuleAttribute("caseExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> caseExpression();
    [GrammarRuleAttribute("simpleCaseStatement")]
private AstParserRuleReturnScope`2<IASTNode, IToken> simpleCaseStatement();
    [GrammarRuleAttribute("simpleCaseWhenClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> simpleCaseWhenClause();
    [GrammarRuleAttribute("elseClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> elseClause();
    [GrammarRuleAttribute("searchedCaseStatement")]
private AstParserRuleReturnScope`2<IASTNode, IToken> searchedCaseStatement();
    [GrammarRuleAttribute("searchedCaseWhenClause")]
private AstParserRuleReturnScope`2<IASTNode, IToken> searchedCaseWhenClause();
    [GrammarRuleAttribute("quantifiedExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> quantifiedExpression();
    [GrammarRuleAttribute("atom")]
private AstParserRuleReturnScope`2<IASTNode, IToken> atom();
    [GrammarRuleAttribute("primaryExpression")]
private AstParserRuleReturnScope`2<IASTNode, IToken> primaryExpression();
    [GrammarRuleAttribute("expressionOrVector")]
private AstParserRuleReturnScope`2<IASTNode, IToken> expressionOrVector();
    [GrammarRuleAttribute("vectorExpr")]
private AstParserRuleReturnScope`2<IASTNode, IToken> vectorExpr();
    [GrammarRuleAttribute("identPrimary")]
private AstParserRuleReturnScope`2<IASTNode, IToken> identPrimary();
    [GrammarRuleAttribute("aggregate")]
private AstParserRuleReturnScope`2<IASTNode, IToken> aggregate();
    [GrammarRuleAttribute("aggregateArgument")]
private AstParserRuleReturnScope`2<IASTNode, IToken> aggregateArgument();
    [GrammarRuleAttribute("aggregateDistinctAll")]
private AstParserRuleReturnScope`2<IASTNode, IToken> aggregateDistinctAll();
    [GrammarRuleAttribute("distinctAll")]
private AstParserRuleReturnScope`2<IASTNode, IToken> distinctAll();
    [GrammarRuleAttribute("collectionExpr")]
private AstParserRuleReturnScope`2<IASTNode, IToken> collectionExpr();
    [GrammarRuleAttribute("compoundExpr")]
private AstParserRuleReturnScope`2<IASTNode, IToken> compoundExpr();
    [GrammarRuleAttribute("exprList")]
private AstParserRuleReturnScope`2<IASTNode, IToken> exprList();
    [GrammarRuleAttribute("subQuery")]
private AstParserRuleReturnScope`2<IASTNode, IToken> subQuery();
    [GrammarRuleAttribute("innerSubQuery")]
private AstParserRuleReturnScope`2<IASTNode, IToken> innerSubQuery();
    [GrammarRuleAttribute("constant")]
private AstParserRuleReturnScope`2<IASTNode, IToken> constant();
    [GrammarRuleAttribute("path")]
private AstParserRuleReturnScope`2<IASTNode, IToken> path();
    [GrammarRuleAttribute("identifier")]
private AstParserRuleReturnScope`2<IASTNode, IToken> identifier();
}
internal class NHibernate.Hql.Ast.ANTLR.HqlSqlGenerator : object {
    private static INHibernateLogger log;
    private IASTNode _ast;
    private ISessionFactoryImplementor _sfi;
    private SqlString _sql;
    private IList`1<IParameterSpecification> _parameters;
    public SqlString Sql { get; }
    public IList`1<IParameterSpecification> CollectionParameters { get; }
    public HqlSqlGenerator(IStatement ast, ISessionFactoryImplementor sfi);
    private static HqlSqlGenerator();
    public SqlString get_Sql();
    public IList`1<IParameterSpecification> get_CollectionParameters();
    public SqlString Generate();
}
internal class NHibernate.Hql.Ast.ANTLR.HqlSqlTranslator : object {
    private IASTNode _inputAst;
    private QueryTranslatorImpl _qti;
    private ISessionFactoryImplementor _sfi;
    private IDictionary`2<string, string> _tokenReplacements;
    private string _collectionRole;
    private IStatement _resultAst;
    public IStatement SqlStatement { get; }
    internal HqlSqlTranslator(IASTNode ast, QueryTranslatorImpl qti, ISessionFactoryImplementor sfi, IDictionary`2<string, string> tokenReplacements, string collectionRole);
    public IStatement get_SqlStatement();
    public IStatement Translate();
}
[GeneratedCodeAttribute("ANTLR", "3.5.2-rc1")]
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.HqlSqlWalker : TreeParser {
    private static INHibernateLogger log;
    private string _collectionFilterRole;
    private SessionFactoryHelperExtensions _sessionFactoryHelper;
    private QueryTranslatorImpl _qti;
    private int _currentClauseType;
    private int _level;
    private bool _inSelect;
    private bool _inFrom;
    private bool _inFunctionCall;
    private bool _inCase;
    private int _statementType;
    private int _currentStatementType;
    private string _statementTypeName;
    private int _positionalParameterCount;
    private int _parameterCount;
    private NullableDictionary`2<string, object> _namedParameterLocations;
    private List`1<IParameterSpecification> _parameters;
    private FromClause _currentFromClause;
    private SelectClause _selectClause;
    private AliasGenerator _aliasGenerator;
    private ASTPrinter _printer;
    private Dictionary`2<string, ISelectExpression> selectExpressionsByResultVariable;
    private HashSet`1<string> _querySpaces;
    private bool _supportsQueryCache;
    private HashSet`1<IPersister> _persisters;
    private LiteralProcessor _literalProcessor;
    private IDictionary`2<string, string> _tokenReplacements;
    private JoinType _impliedJoinType;
    private IParseErrorHandler _parseErrorHandler;
    private IASTFactory _nodeFactory;
    private List`1<AssignmentSpecification> assignmentSpecifications;
    private int numberOfParametersInSetClause;
    private Stack`1<int> clauseStack;
    private Dictionary`2<FromElement, string> _suffixes;
    private Dictionary`2<FromElement, string> _collectionSuffixes;
    internal int CurrentScalarIndex;
    [CompilerGeneratedAttribute]
private int <CurrentTopLevelClauseType>k__BackingField;
    internal static String[] tokenNames;
    public static int EOF;
    public static int AGGREGATE;
    public static int ALIAS;
    public static int ALL;
    public static int AND;
    public static int ANY;
    public static int AS;
    public static int ASCENDING;
    public static int AVG;
    public static int BAND;
    public static int BETWEEN;
    public static int BNOT;
    public static int BOR;
    public static int BOTH;
    public static int BXOR;
    public static int CASE;
    public static int CASE2;
    public static int CLASS;
    public static int CLOSE;
    public static int CLOSE_BRACKET;
    public static int COLON;
    public static int COMMA;
    public static int CONCAT;
    public static int CONSTANT;
    public static int CONSTRUCTOR;
    public static int COUNT;
    public static int CROSS;
    public static int DELETE;
    public static int DESCENDING;
    public static int DISTINCT;
    public static int DIV;
    public static int DOT;
    public static int ELEMENTS;
    public static int ELSE;
    public static int EMPTY;
    public static int END;
    public static int EQ;
    public static int ESCAPE;
    public static int ESCqs;
    public static int EXISTS;
    public static int EXPONENT;
    public static int EXPR_LIST;
    public static int FALSE;
    public static int FETCH;
    public static int FILTER_ENTITY;
    public static int FLOAT_SUFFIX;
    public static int FROM;
    public static int FULL;
    public static int GE;
    public static int GROUP;
    public static int GT;
    public static int HAVING;
    public static int HEX_DIGIT;
    public static int IDENT;
    public static int ID_LETTER;
    public static int ID_START_LETTER;
    public static int IN;
    public static int INDEX_OP;
    public static int INDICES;
    public static int INNER;
    public static int INSERT;
    public static int INTO;
    public static int IN_LIST;
    public static int IS;
    public static int IS_NOT_NULL;
    public static int IS_NULL;
    public static int JAVA_CONSTANT;
    public static int JOIN;
    public static int LE;
    public static int LEADING;
    public static int LEFT;
    public static int LIKE;
    public static int LITERAL_by;
    public static int LT;
    public static int MAX;
    public static int MEMBER;
    public static int METHOD_CALL;
    public static int MIN;
    public static int MINUS;
    public static int NE;
    public static int NEW;
    public static int NOT;
    public static int NOT_BETWEEN;
    public static int NOT_IN;
    public static int NOT_LIKE;
    public static int NULL;
    public static int NUM_DECIMAL;
    public static int NUM_DOUBLE;
    public static int NUM_FLOAT;
    public static int NUM_INT;
    public static int NUM_LONG;
    public static int OBJECT;
    public static int OF;
    public static int ON;
    public static int OPEN;
    public static int OPEN_BRACKET;
    public static int OR;
    public static int ORDER;
    public static int ORDER_ELEMENT;
    public static int OUTER;
    public static int PARAM;
    public static int PLUS;
    public static int PROPERTIES;
    public static int QUERY;
    public static int QUOTED_String;
    public static int RANGE;
    public static int RIGHT;
    public static int ROW_STAR;
    public static int SELECT;
    public static int SELECT_FROM;
    public static int SET;
    public static int SKIP;
    public static int SOME;
    public static int SQL_NE;
    public static int STAR;
    public static int SUM;
    public static int TAKE;
    public static int THEN;
    public static int TRAILING;
    public static int TRUE;
    public static int UNARY_MINUS;
    public static int UNARY_PLUS;
    public static int UNION;
    public static int UPDATE;
    public static int VECTOR_EXPR;
    public static int VERSIONED;
    public static int WEIRD_IDENT;
    public static int WHEN;
    public static int WHERE;
    public static int WITH;
    public static int WS;
    public static int T__134;
    public static int T__135;
    public static int ALIAS_REF;
    public static int BOGUS;
    public static int ENTITY_JOIN;
    public static int FILTERS;
    public static int FROM_FRAGMENT;
    public static int IMPLIED_FROM;
    public static int JOIN_FRAGMENT;
    public static int JOIN_SUBQUERY;
    public static int LEFT_OUTER;
    public static int METHOD_NAME;
    public static int NAMED_PARAM;
    public static int PROPERTY_REF;
    public static int RESULT_VARIABLE_REF;
    public static int RIGHT_OUTER;
    public static int SELECT_CLAUSE;
    public static int SELECT_COLUMNS;
    public static int SELECT_EXPR;
    public static int SQL_TOKEN;
    public static int THETA_JOINS;
    private ITreeAdaptor adaptor;
    public IList`1<AssignmentSpecification> AssignmentSpecifications { get; }
    public int NumberOfParametersInSetClause { get; }
    public IParseErrorHandler ParseErrorHandler { get; public set; }
    public AliasGenerator AliasGenerator { get; }
    public ISet`1<string> QuerySpaces { get; }
    public bool SupportsQueryCache { get; }
    internal ISet`1<IPersister> Persisters { get; }
    public IDictionary`2<string, object> NamedParameters { get; }
    internal SessionFactoryHelperExtensions SessionFactoryHelper { get; }
    public int CurrentStatementType { get; }
    public JoinType ImpliedJoinType { get; }
    public String[] ReturnAliases { get; }
    public IType[] ReturnTypes { get; }
    public string CollectionFilterRole { get; }
    public SelectClause SelectClause { get; }
    public IList`1<IParameterSpecification> Parameters { get; }
    public FromClause CurrentFromClause { get; }
    public int StatementType { get; }
    public LiteralProcessor LiteralProcessor { get; }
    public int CurrentClauseType { get; }
    public int CurrentTopLevelClauseType { get; private set; }
    public IDictionary`2<string, IFilter> EnabledFilters { get; }
    public bool IsSubQuery { get; }
    public bool IsScalarSubQuery { get; }
    public bool IsSelectStatement { get; }
    public bool IsInFrom { get; }
    public bool IsInSelect { get; }
    public IDictionary`2<string, string> TokenReplacements { get; }
    public bool IsComparativeExpressionClause { get; }
    public bool IsInCase { get; }
    public bool IsShallowQuery { get; }
    public IASTFactory ASTFactory { get; }
    public ITreeAdaptor TreeAdaptor { get; public set; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public HqlSqlWalker(QueryTranslatorImpl qti, ISessionFactoryImplementor sfi, ITreeNodeStream input, IDictionary`2<string, string> tokenReplacements, string collectionRole);
    public HqlSqlWalker(ITreeNodeStream input);
    public HqlSqlWalker(ITreeNodeStream input, RecognizerSharedState state);
    private static HqlSqlWalker();
    public virtual void ReportError(RecognitionException e);
    public IList`1<AssignmentSpecification> get_AssignmentSpecifications();
    public int get_NumberOfParametersInSetClause();
    public IParseErrorHandler get_ParseErrorHandler();
    public void set_ParseErrorHandler(IParseErrorHandler value);
    public AliasGenerator get_AliasGenerator();
    public ISet`1<string> get_QuerySpaces();
    public bool get_SupportsQueryCache();
    internal ISet`1<IPersister> get_Persisters();
    public IDictionary`2<string, object> get_NamedParameters();
    internal SessionFactoryHelperExtensions get_SessionFactoryHelper();
    public int get_CurrentStatementType();
    public JoinType get_ImpliedJoinType();
    public String[] get_ReturnAliases();
    public IType[] get_ReturnTypes();
    public string get_CollectionFilterRole();
    public SelectClause get_SelectClause();
    public IList`1<IParameterSpecification> get_Parameters();
    private void BeforeStatement(string statementName, int statementType);
    private void BeforeStatementCompletion(string statementName);
    private void PrepareVersioned(IASTNode updateNode, IASTNode versioned);
    private IASTNode GenerateVersionPropertyNode(IQueryable persister);
    private void PostProcessUpdate(IASTNode update);
    private void PostProcessDelete(IASTNode delete);
    private void PostProcessInsert(IASTNode insert);
    private static bool IsDatabaseGeneratedTimestamp(IType type);
    private static bool IsUtcDatabaseGeneratedTimestamp(IType type);
    private static bool IsIntegral(IType type);
    public static bool SupportsIdGenWithBulkInsertion(IIdentifierGenerator generator);
    private void PostProcessDML(IRestrictableStatement statement);
    private void AfterStatementCompletion(string statementName);
    private void HandleClauseStart(int clauseType);
    private void HandleClauseEnd(int clauseType);
    private void FinishFromClause();
    private IASTNode CreateIntoClause(string path, IASTNode propertySpec);
    private IASTNode Resolve(IASTNode node);
    internal string GetSuffix(FromElement fromElement);
    internal string GetEntitySuffix(FromElement fromElement);
    internal string GetCollectionSuffix(FromElement fromElement);
    private void ProcessQuery(IASTNode select, IASTNode query);
    private void UseSelectClause(IASTNode select);
    private void CreateSelectClauseFromFromClause(IASTNode qn);
    private void PopFromClause();
    private static void ProcessConstructor(IASTNode constructor);
    protected void EvaluateAssignment(IASTNode eq);
    private void EvaluateAssignment(IASTNode eq, IQueryable persister, int targetIndex);
    private void BeforeSelectClause();
    private void SetAlias(IASTNode selectExpr, IASTNode ident);
    protected bool IsOrderExpressionResultVariableRef(IASTNode orderExpressionNode);
    protected void HandleResultVariableRef(IASTNode resultVariableRef);
    private static void ResolveSelectExpression(IASTNode node);
    private void PrepareFilterParameter();
    private void CreateJoinSubquery(IASTNode query, IASTNode alias, int joinType, IASTNode with);
    private void CreateFromJoinElement(IASTNode path, IASTNode alias, int joinType, IASTNode fetchNode, IASTNode propertyFetch, IASTNode with);
    private EntityJoinFromElement CreateEntityJoin(IQueryable entityPersister, IASTNode aliasNode, int joinType, IASTNode with);
    private IQueryable ResolveEntityJoinReferencedPersister(FromReferenceNode path);
    private static string GetPropertyPath(DotNode dotNode, IASTNode alias);
    private FromElement CreateFromElement(string path, IASTNode pathNode, IASTNode alias, IASTNode propertyFetch);
    private static void SetPropertyFetch(FromElement fromElement, IASTNode propertyFetch, IASTNode alias);
    private IASTNode CreateFromFilterElement(IASTNode filterEntity, IASTNode alias);
    private void SetImpliedJoinType(int joinType);
    private void PushFromClause(IASTNode fromNode);
    private static void PrepareArithmeticOperator(IASTNode op);
    private static void ProcessFunction(IASTNode functionCall, bool inSelect);
    private void ProcessBool(IASTNode constant);
    private static void PrepareLogicOperator(IASTNode operatorNode);
    private void ProcessNumericLiteral(IASTNode literal);
    protected IASTNode LookupProperty(IASTNode dot, bool root, bool inSelect);
    private static void ProcessIndex(IASTNode indexOp);
    private bool IsNonQualifiedPropertyRef(IASTNode ident);
    private IASTNode LookupNonQualifiedProperty(IASTNode property);
    private IASTNode GenerateSyntheticDotNodeForNonQualifiedPropertyRef(IASTNode property, FromElement fromElement);
    private void LookupAlias(IASTNode aliasRef);
    private IASTNode GenerateNamedParameter(IASTNode delimiterNode, IASTNode nameNode);
    private IASTNode GeneratePositionalParameter(IASTNode inputNode);
    public FromClause get_CurrentFromClause();
    public int get_StatementType();
    public LiteralProcessor get_LiteralProcessor();
    public int get_CurrentClauseType();
    [CompilerGeneratedAttribute]
public int get_CurrentTopLevelClauseType();
    [CompilerGeneratedAttribute]
private void set_CurrentTopLevelClauseType(int value);
    public IDictionary`2<string, IFilter> get_EnabledFilters();
    public bool get_IsSubQuery();
    public bool get_IsScalarSubQuery();
    public bool get_IsSelectStatement();
    public bool get_IsInFrom();
    public bool get_IsInSelect();
    public IDictionary`2<string, string> get_TokenReplacements();
    public bool get_IsComparativeExpressionClause();
    public bool get_IsInCase();
    public bool get_IsShallowQuery();
    public FromClause GetFinalFromClause();
    public bool IsFilter();
    public IASTFactory get_ASTFactory();
    public void AddQuerySpaces(IEntityPersister persister);
    public void AddQuerySpaces(ICollectionPersister collectionPersister);
    private void AddPersister(object persister);
    public void AddQuerySpaces(String[] spaces);
    private void TrackNamedParameterPositions(string name);
    private void HandleWithFragment(FromElement fromElement, IASTNode hqlWithNode);
    public ITreeAdaptor get_TreeAdaptor();
    public void set_TreeAdaptor(ITreeAdaptor value);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("statement")]
public AstTreeRuleReturnScope`2<IASTNode, IASTNode> statement();
    [GrammarRuleAttribute("selectStatement")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> selectStatement();
    [GrammarRuleAttribute("updateStatement")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> updateStatement();
    [GrammarRuleAttribute("deleteStatement")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> deleteStatement();
    [GrammarRuleAttribute("insertStatement")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> insertStatement();
    [GrammarRuleAttribute("intoClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> intoClause();
    [GrammarRuleAttribute("insertablePropertySpec")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> insertablePropertySpec();
    [GrammarRuleAttribute("setClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> setClause();
    [GrammarRuleAttribute("assignment")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> assignment();
    [GrammarRuleAttribute("newValue")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> newValue();
    [GrammarRuleAttribute("query")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> query();
    [GrammarRuleAttribute("unionedQuery")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> unionedQuery();
    [GrammarRuleAttribute("orderClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> orderClause();
    [GrammarRuleAttribute("orderExprs")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> orderExprs();
    [GrammarRuleAttribute("orderExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> orderExpr();
    [GrammarRuleAttribute("resultVariableRef")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> resultVariableRef();
    [GrammarRuleAttribute("skipClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> skipClause();
    [GrammarRuleAttribute("takeClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> takeClause();
    [GrammarRuleAttribute("groupClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> groupClause();
    [GrammarRuleAttribute("havingClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> havingClause();
    [GrammarRuleAttribute("selectClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> selectClause();
    [GrammarRuleAttribute("selectExprList")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> selectExprList();
    [GrammarRuleAttribute("aliasedSelectExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> aliasedSelectExpr();
    [GrammarRuleAttribute("selectExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> selectExpr();
    [GrammarRuleAttribute("count")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> count();
    [GrammarRuleAttribute("constructor")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> constructor();
    [GrammarRuleAttribute("aggregateExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> aggregateExpr();
    [GrammarRuleAttribute("propertyFetch")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> propertyFetch();
    [GrammarRuleAttribute("fromClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> fromClause();
    [GrammarRuleAttribute("fromElementList")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> fromElementList();
    [GrammarRuleAttribute("fromElement")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> fromElement();
    [GrammarRuleAttribute("joinElement")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> joinElement();
    [GrammarRuleAttribute("joinType")]
private joinType_return joinType();
    [GrammarRuleAttribute("path")]
private path_return path();
    [GrammarRuleAttribute("pathAsIdent")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> pathAsIdent();
    [GrammarRuleAttribute("withClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> withClause();
    [GrammarRuleAttribute("whereClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> whereClause();
    [GrammarRuleAttribute("logicalExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> logicalExpr();
    [GrammarRuleAttribute("logicalPath")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> logicalPath();
    [GrammarRuleAttribute("comparisonExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> comparisonExpr();
    [GrammarRuleAttribute("inRhs")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> inRhs();
    [GrammarRuleAttribute("exprOrSubquery")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> exprOrSubquery();
    [GrammarRuleAttribute("collectionFunctionOrSubselect")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> collectionFunctionOrSubselect();
    [GrammarRuleAttribute("expr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> expr();
    [GrammarRuleAttribute("arithmeticExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> arithmeticExpr();
    [GrammarRuleAttribute("caseExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> caseExpr();
    [GrammarRuleAttribute("simpleCaseExpression")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> simpleCaseExpression();
    [GrammarRuleAttribute("simpleCaseWhenClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> simpleCaseWhenClause();
    [GrammarRuleAttribute("elseClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> elseClause();
    [GrammarRuleAttribute("searchedCaseExpression")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> searchedCaseExpression();
    [GrammarRuleAttribute("searchedCaseWhenClause")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> searchedCaseWhenClause();
    [GrammarRuleAttribute("collectionFunction")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> collectionFunction();
    [GrammarRuleAttribute("functionCall")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> functionCall();
    [GrammarRuleAttribute("constant")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> constant();
    [GrammarRuleAttribute("literal")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> literal();
    [GrammarRuleAttribute("numericLiteral")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> numericLiteral();
    [GrammarRuleAttribute("stringLiteral")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> stringLiteral();
    [GrammarRuleAttribute("identifier")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> identifier();
    [GrammarRuleAttribute("addrExpr")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> addrExpr(bool root);
    [GrammarRuleAttribute("addrExprDot")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> addrExprDot(bool root);
    [GrammarRuleAttribute("addrExprIndex")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> addrExprIndex(bool root);
    [GrammarRuleAttribute("addrExprIdent")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> addrExprIdent(bool root);
    [GrammarRuleAttribute("addrExprLhs")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> addrExprLhs();
    [GrammarRuleAttribute("propertyName")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> propertyName();
    [GrammarRuleAttribute("propertyRef")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> propertyRef();
    [GrammarRuleAttribute("propertyRefPath")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> propertyRefPath();
    [GrammarRuleAttribute("propertyRefIdent")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> propertyRefIdent();
    [GrammarRuleAttribute("propertyRefLhs")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> propertyRefLhs();
    [GrammarRuleAttribute("aliasRef")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> aliasRef();
    [GrammarRuleAttribute("parameter")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> parameter();
    [GrammarRuleAttribute("numericInteger")]
private AstTreeRuleReturnScope`2<IASTNode, IASTNode> numericInteger();
    [CompilerGeneratedAttribute]
private void <CreateFromJoinElement>g__ProcessAsEntityJoin|106_0(<>c__DisplayClass106_0& );
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.HqlToken : CommonToken {
    private int _previousTokenType;
    [ObsoleteAttribute("Use HqlParser.IsPossibleId method instead.")]
public bool PossibleId { get; }
    private int PreviousType { get; }
    public HqlToken(ICharStream input, int type, int channel, int start, int stop);
    public HqlToken(IToken other);
    public bool get_PossibleId();
    private int get_PreviousType();
    public virtual string ToString();
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.IErrorReporter {
    public abstract virtual void ReportError(RecognitionException e);
    public abstract virtual void ReportError(string s);
    public abstract virtual void ReportWarning(string s);
}
public class NHibernate.Hql.Ast.ANTLR.InvalidPathException : SemanticException {
    public InvalidPathException(string s);
    protected InvalidPathException(SerializationInfo info, StreamingContext context);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.InvalidWithClauseException : QuerySyntaxException {
    public InvalidWithClauseException(string message);
    public InvalidWithClauseException(string message, Exception inner);
    protected InvalidWithClauseException(SerializationInfo info, StreamingContext context);
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.IParseErrorHandler {
    public abstract virtual int GetErrorCount();
    public abstract virtual void ThrowQueryException();
}
internal class NHibernate.Hql.Ast.ANTLR.PolymorphicQuerySourceDetector : object {
    private ISessionFactoryImplementor _sfi;
    private Dictionary`2<IASTNode, IASTNode[]> _map;
    private SessionFactoryHelper _sessionFactoryHelper;
    public PolymorphicQuerySourceDetector(ISessionFactoryImplementor sfi);
    public Dictionary`2<IASTNode, IASTNode[]> Process(IASTNode tree);
    private void AddImplementorsToMap(IASTNode querySource, string className, String[] implementors);
    internal static string GetClassName(IASTNode querySource);
    private static IASTNode MakeIdent(IASTNode source, string text);
    private static string BuildPath(IASTNode node);
    private static void BuildPath(IASTNode node, StringBuilder sb);
}
internal class NHibernate.Hql.Ast.ANTLR.QuerySourceDetector : object {
    private IASTNode _tree;
    private List`1<IASTNode> _nodes;
    public QuerySourceDetector(IASTNode tree);
    public IList`1<IASTNode> LocateQuerySources();
    public sealed virtual void Visit(IASTNode node);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.QuerySyntaxException : QueryException {
    public QuerySyntaxException(string message, string hql);
    public QuerySyntaxException(string message, string hql, Exception inner);
    public QuerySyntaxException(string message);
    public QuerySyntaxException(string message, Exception inner);
    protected QuerySyntaxException(SerializationInfo info, StreamingContext context);
    public static QuerySyntaxException Convert(RecognitionException e);
    public static QuerySyntaxException Convert(RecognitionException e, string hql);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl : object {
    private static INHibernateLogger log;
    private string _queryIdentifier;
    private IASTNode _stageOneAst;
    private ISessionFactoryImplementor _factory;
    private IQueryLoaderFactory _queryLoaderFactory;
    private IDictionary`2<string, Tuple`2<IType, bool>> _namedParameters;
    private bool _shallowQuery;
    private bool _compiled;
    private IDictionary`2<string, IFilter> _enabledFilters;
    private IQueryLoader _queryLoader;
    private IStatementExecutor _statementExecutor;
    private IStatement _sqlAst;
    private IDictionary`2<string, string> _tokenReplacements;
    private HqlSqlGenerator _generator;
    [ObsoleteAttribute("Use QueryLoader property instead")]
public Loader Loader { get; }
    public ILoader QueryLoader { get; }
    public IType[] ActualReturnTypes { get; }
    public ISet`1<string> QuerySpaces { get; }
    internal ISet`1<IPersister> Persisters { get; }
    public bool SupportsQueryCache { get; }
    public string SQLString { get; }
    public IStatement SqlAST { get; }
    public IList`1<IParameterSpecification> CollectedParameterSpecifications { get; }
    public SqlString SqlString { get; }
    public string QueryIdentifier { get; }
    public IList`1<string> CollectSqlStrings { get; }
    public string QueryString { get; }
    public IDictionary`2<string, IFilter> EnabledFilters { get; }
    public IType[] ReturnTypes { get; }
    public String[] ReturnAliases { get; }
    public bool ContainsCollectionFetches { get; }
    public ISet`1<ICollectionPersister> UncacheableCollectionPersisters { get; }
    public bool IsManipulationStatement { get; }
    public bool IsShallowQuery { get; }
    [ObsoleteAttribute("Use overload taking an IQueryLoaderFactory.")]
public QueryTranslatorImpl(string queryIdentifier, IASTNode parsedQuery, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory);
    public QueryTranslatorImpl(string queryIdentifier, IASTNode parsedQuery, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory, IQueryLoaderFactory queryLoaderFactory);
    public QueryTranslatorImpl(string queryIdentifier, IASTNode parsedQuery, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory, IQueryLoaderFactory queryLoaderFactory, IDictionary`2<string, Tuple`2<IType, bool>> namedParameters);
    private static QueryTranslatorImpl();
    [AsyncStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl/<ListAsync>d__0")]
public sealed virtual Task`1<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable> GetEnumerableAsync(QueryParameters queryParameters, IEventSource session, CancellationToken cancellationToken);
    public sealed virtual Task`1<int> ExecuteUpdateAsync(QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Compile(IDictionary`2<string, string> replacements, bool shallow);
    public sealed virtual void Compile(string collectionRole, IDictionary`2<string, string> replacements, bool shallow);
    public sealed virtual IList List(ISessionImplementor session, QueryParameters queryParameters);
    public sealed virtual IEnumerable GetEnumerable(QueryParameters queryParameters, IEventSource session);
    public sealed virtual int ExecuteUpdate(QueryParameters queryParameters, ISessionImplementor session);
    private void ErrorIfSelect();
    public sealed virtual Loader get_Loader();
    public sealed virtual ILoader get_QueryLoader();
    public virtual IType[] get_ActualReturnTypes();
    public sealed virtual ParameterMetadata BuildParameterMetadata();
    public sealed virtual String[][] GetColumnNames();
    public sealed virtual ISet`1<string> get_QuerySpaces();
    internal ISet`1<IPersister> get_Persisters();
    public bool get_SupportsQueryCache();
    public sealed virtual string get_SQLString();
    public IStatement get_SqlAST();
    public IList`1<IParameterSpecification> get_CollectedParameterSpecifications();
    public SqlString get_SqlString();
    public string get_QueryIdentifier();
    public sealed virtual IList`1<string> get_CollectSqlStrings();
    public sealed virtual string get_QueryString();
    public sealed virtual IDictionary`2<string, IFilter> get_EnabledFilters();
    public sealed virtual IType[] get_ReturnTypes();
    public sealed virtual String[] get_ReturnAliases();
    public sealed virtual bool get_ContainsCollectionFetches();
    public ISet`1<ICollectionPersister> get_UncacheableCollectionPersisters();
    public sealed virtual bool get_IsManipulationStatement();
    public bool get_IsShallowQuery();
    private void DoCompile(IDictionary`2<string, string> replacements, bool shallow, string collectionRole);
    private static IStatementExecutor BuildAppropriateStatementExecutor(IStatement statement);
    private HqlSqlTranslator Analyze(string collectionRole);
    private void ErrorIfDML();
    public bool TryGetNamedParameterType(string name, IType& type, Boolean& isGuessedType);
}
public class NHibernate.Hql.Ast.ANTLR.SemanticException : QueryException {
    public SemanticException(string message);
    public SemanticException(string message, Exception inner);
    protected SemanticException(SerializationInfo info, StreamingContext context);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions : object {
    private ISessionFactoryImplementor _sfi;
    private NullableDictionary`2<string, IPropertyMapping> _collectionPropertyMappingByRole;
    private SessionFactoryHelper helper;
    public ISessionFactoryImplementor Factory { get; }
    public bool IsStrictJPAQLComplianceEnabled { get; }
    public SessionFactoryHelperExtensions(ISessionFactoryImplementor sfi);
    public ISessionFactoryImplementor get_Factory();
    public ISQLFunction FindSQLFunction(string functionName);
    private ISQLFunction RequireSQLFunction(string functionName);
    [ObsoleteAttribute("Please use overload with a IEnumerable<IASTNode> parameter instead.")]
public IType FindFunctionReturnType(string functionName, IASTNode first);
    public IType FindFunctionReturnType(string functionName, IEnumerable`1<IASTNode> arguments);
    public string GetImportedClassName(string className);
    public bool HasPhysicalDiscriminatorColumn(IQueryable persister);
    public IQueryableCollection GetCollectionPersister(string collectionFilterRole);
    public string GetIdentifierOrUniqueKeyPropertyName(EntityType entityType);
    public String[] GetCollectionElementColumns(string role, string roleAlias);
    public IAssociationType GetElementAssociationType(CollectionType collectionType);
    public IQueryableCollection RequireQueryableCollection(string role);
    public IEntityPersister RequireClassPersister(string name);
    public IQueryable FindQueryableUsingImports(string className);
    private static IQueryable FindQueryableUsingImports(ISessionFactoryImplementor sfi, string className);
    private IEntityPersister FindEntityPersisterByName(string name);
    public JoinSequence CreateCollectionJoinSequence(IQueryableCollection collPersister, string collectionName);
    public JoinSequence CreateJoinSequence();
    public JoinSequence CreateJoinSequence(bool implicitJoin, IAssociationType associationType, string tableAlias, JoinType joinType, String[] columns);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public String[][] GenerateColumnNames(IType[] sqlResultTypes);
    public bool get_IsStrictJPAQLComplianceEnabled();
    private IPropertyMapping GetCollectionPropertyMapping(string role);
    private IType GetElementType(CollectionType collectionType);
}
[GeneratedCodeAttribute("ANTLR", "3.5.2-rc1")]
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.SqlGenerator : TreeParser {
    private List`1<IParameterSpecification> collectedParameters;
    private Stack`1<ISqlWriter> outputStack;
    private IParseErrorHandler parseErrorHandler;
    private ISessionFactoryImplementor sessionFactory;
    private SqlStringBuilder sqlStringBuilder;
    private ISqlWriter writer;
    internal static String[] tokenNames;
    public static int EOF;
    public static int AGGREGATE;
    public static int ALIAS;
    public static int ALL;
    public static int AND;
    public static int ANY;
    public static int AS;
    public static int ASCENDING;
    public static int AVG;
    public static int BAND;
    public static int BETWEEN;
    public static int BNOT;
    public static int BOR;
    public static int BOTH;
    public static int BXOR;
    public static int CASE;
    public static int CASE2;
    public static int CLASS;
    public static int CLOSE;
    public static int CLOSE_BRACKET;
    public static int COLON;
    public static int COMMA;
    public static int CONCAT;
    public static int CONSTANT;
    public static int CONSTRUCTOR;
    public static int COUNT;
    public static int CROSS;
    public static int DELETE;
    public static int DESCENDING;
    public static int DISTINCT;
    public static int DIV;
    public static int DOT;
    public static int ELEMENTS;
    public static int ELSE;
    public static int EMPTY;
    public static int END;
    public static int EQ;
    public static int ESCAPE;
    public static int ESCqs;
    public static int EXISTS;
    public static int EXPONENT;
    public static int EXPR_LIST;
    public static int FALSE;
    public static int FETCH;
    public static int FILTER_ENTITY;
    public static int FLOAT_SUFFIX;
    public static int FROM;
    public static int FULL;
    public static int GE;
    public static int GROUP;
    public static int GT;
    public static int HAVING;
    public static int HEX_DIGIT;
    public static int IDENT;
    public static int ID_LETTER;
    public static int ID_START_LETTER;
    public static int IN;
    public static int INDEX_OP;
    public static int INDICES;
    public static int INNER;
    public static int INSERT;
    public static int INTO;
    public static int IN_LIST;
    public static int IS;
    public static int IS_NOT_NULL;
    public static int IS_NULL;
    public static int JAVA_CONSTANT;
    public static int JOIN;
    public static int LE;
    public static int LEADING;
    public static int LEFT;
    public static int LIKE;
    public static int LITERAL_by;
    public static int LT;
    public static int MAX;
    public static int MEMBER;
    public static int METHOD_CALL;
    public static int MIN;
    public static int MINUS;
    public static int NE;
    public static int NEW;
    public static int NOT;
    public static int NOT_BETWEEN;
    public static int NOT_IN;
    public static int NOT_LIKE;
    public static int NULL;
    public static int NUM_DECIMAL;
    public static int NUM_DOUBLE;
    public static int NUM_FLOAT;
    public static int NUM_INT;
    public static int NUM_LONG;
    public static int OBJECT;
    public static int OF;
    public static int ON;
    public static int OPEN;
    public static int OPEN_BRACKET;
    public static int OR;
    public static int ORDER;
    public static int ORDER_ELEMENT;
    public static int OUTER;
    public static int PARAM;
    public static int PLUS;
    public static int PROPERTIES;
    public static int QUERY;
    public static int QUOTED_String;
    public static int RANGE;
    public static int RIGHT;
    public static int ROW_STAR;
    public static int SELECT;
    public static int SELECT_FROM;
    public static int SET;
    public static int SKIP;
    public static int SOME;
    public static int SQL_NE;
    public static int STAR;
    public static int SUM;
    public static int TAKE;
    public static int THEN;
    public static int TRAILING;
    public static int TRUE;
    public static int UNARY_MINUS;
    public static int UNARY_PLUS;
    public static int UNION;
    public static int UPDATE;
    public static int VECTOR_EXPR;
    public static int VERSIONED;
    public static int WEIRD_IDENT;
    public static int WHEN;
    public static int WHERE;
    public static int WITH;
    public static int WS;
    public static int T__134;
    public static int T__135;
    public static int ALIAS_REF;
    public static int BOGUS;
    public static int ENTITY_JOIN;
    public static int FILTERS;
    public static int FROM_FRAGMENT;
    public static int IMPLIED_FROM;
    public static int JOIN_FRAGMENT;
    public static int JOIN_SUBQUERY;
    public static int LEFT_OUTER;
    public static int METHOD_NAME;
    public static int NAMED_PARAM;
    public static int PROPERTY_REF;
    public static int RESULT_VARIABLE_REF;
    public static int RIGHT_OUTER;
    public static int SELECT_CLAUSE;
    public static int SELECT_COLUMNS;
    public static int SELECT_EXPR;
    public static int SQL_TOKEN;
    public static int THETA_JOINS;
    public IParseErrorHandler ParseErrorHandler { get; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public SqlGenerator(ISessionFactoryImplementor sfi, ITreeNodeStream input);
    public SqlGenerator(ITreeNodeStream input);
    public SqlGenerator(ITreeNodeStream input, RecognizerSharedState state);
    private static SqlGenerator();
    public IParseErrorHandler get_ParseErrorHandler();
    public virtual void ReportError(RecognitionException e);
    public sealed virtual void ReportError(string s);
    public sealed virtual void ReportWarning(string s);
    public SqlString GetSQL();
    public IList`1<IParameterSpecification> GetCollectedParameters();
    private void Out(string s);
    private void Out(SqlString s);
    private void OptionalSpace();
    private void Out(IASTNode n);
    private void Separator(IASTNode n, string sep);
    private static bool HasText(IASTNode a);
    protected virtual void FromFragmentSeparator(IASTNode a);
    protected virtual void NestedFromFragment(IASTNode d, IASTNode parent);
    private SqlStringBuilder GetStringBuilder();
    private void BeginFunctionTemplate(IASTNode m, IASTNode i);
    private void EndFunctionTemplate(IASTNode m);
    private void OutAggregateFunctionName(IASTNode m);
    private void CommaBetweenParameters(string comma);
    private void StartJoinSubquery();
    private void EndJoinSubquery(IASTNode node);
    private void StartQuery();
    private void EndQuery();
    private SqlString GetSqlStringWithLimitsIfNeeded(QueryWriter queryWriter);
    private void Skip(IASTNode node);
    private void Take(IASTNode node);
    private void BeginBitwiseOp(string op);
    private void EndBitwiseOp(string op);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("statement")]
public void statement();
    [GrammarRuleAttribute("selectStatement")]
private void selectStatement();
    [GrammarRuleAttribute("updateStatement")]
private void updateStatement();
    [GrammarRuleAttribute("deleteStatement")]
private void deleteStatement();
    [GrammarRuleAttribute("insertStatement")]
private void insertStatement();
    [GrammarRuleAttribute("setClause")]
private void setClause();
    [GrammarRuleAttribute("whereClause")]
public void whereClause();
    [GrammarRuleAttribute("whereClauseExpr")]
private void whereClauseExpr();
    [GrammarRuleAttribute("orderExprs")]
private void orderExprs();
    [GrammarRuleAttribute("groupExprs")]
private void groupExprs();
    [GrammarRuleAttribute("orderDirection")]
private TreeRuleReturnScope`1<IASTNode> orderDirection();
    [GrammarRuleAttribute("whereExpr")]
public void whereExpr();
    [GrammarRuleAttribute("filters")]
private void filters();
    [GrammarRuleAttribute("thetaJoins")]
private void thetaJoins();
    [GrammarRuleAttribute("conditionList")]
private void conditionList();
    [GrammarRuleAttribute("selectClause")]
private void selectClause();
    [GrammarRuleAttribute("selectColumn")]
private void selectColumn();
    [GrammarRuleAttribute("selectExpr")]
private TreeRuleReturnScope`1<IASTNode> selectExpr();
    [GrammarRuleAttribute("count")]
private void count();
    [GrammarRuleAttribute("distinctOrAll")]
private void distinctOrAll();
    [GrammarRuleAttribute("countExpr")]
private void countExpr();
    [GrammarRuleAttribute("selectAtom")]
private TreeRuleReturnScope`1<IASTNode> selectAtom();
    [GrammarRuleAttribute("from")]
private void from();
    [GrammarRuleAttribute("fromTable")]
private void fromTable();
    [GrammarRuleAttribute("tableJoin")]
private void tableJoin(IASTNode parent);
    [GrammarRuleAttribute("booleanOp")]
private void booleanOp(bool parens);
    [GrammarRuleAttribute("booleanExpr")]
private void booleanExpr(bool parens);
    [GrammarRuleAttribute("comparisonExpr")]
public void comparisonExpr(bool parens);
    [GrammarRuleAttribute("binaryComparisonExpression")]
private void binaryComparisonExpression();
    [GrammarRuleAttribute("exoticComparisonExpression")]
private void exoticComparisonExpression();
    [GrammarRuleAttribute("likeEscape")]
private void likeEscape();
    [GrammarRuleAttribute("inList")]
private void inList();
    [GrammarRuleAttribute("simpleExprList")]
private void simpleExprList();
    [GrammarRuleAttribute("expr")]
private TreeRuleReturnScope`1<IASTNode> expr();
    [GrammarRuleAttribute("quantified")]
private void quantified();
    [GrammarRuleAttribute("parenSelect")]
private void parenSelect();
    [GrammarRuleAttribute("simpleExpr")]
public TreeRuleReturnScope`1<IASTNode> simpleExpr();
    [GrammarRuleAttribute("constant")]
private TreeRuleReturnScope`1<IASTNode> constant();
    [GrammarRuleAttribute("arithmeticExpr")]
private void arithmeticExpr();
    [GrammarRuleAttribute("additiveExpr")]
private void additiveExpr();
    [GrammarRuleAttribute("bitwiseExpr")]
private void bitwiseExpr();
    [GrammarRuleAttribute("multiplicativeExpr")]
private void multiplicativeExpr();
    [GrammarRuleAttribute("nestedExpr")]
private void nestedExpr();
    [GrammarRuleAttribute("nestedExprAfterMinusDiv")]
private void nestedExprAfterMinusDiv();
    [GrammarRuleAttribute("caseExpr")]
private void caseExpr();
    [GrammarRuleAttribute("aggregate")]
private void aggregate();
    [GrammarRuleAttribute("methodCall")]
private void methodCall();
    [GrammarRuleAttribute("arguments")]
private void arguments();
    [GrammarRuleAttribute("parameter")]
private void parameter();
    [GrammarRuleAttribute("limitValue")]
private TreeRuleReturnScope`1<IASTNode> limitValue();
    [GrammarRuleAttribute("addrExpr")]
private void addrExpr();
    [GrammarRuleAttribute("sqlToken")]
private void sqlToken();
    private void synpred1_SqlGenerator_fragment();
    private void synpred2_SqlGenerator_fragment();
    private void synpred3_SqlGenerator_fragment();
    private void synpred4_SqlGenerator_fragment();
    private bool EvaluatePredicate(Action fragment);
}
[CLSCompliantAttribute("False")]
public abstract class NHibernate.Hql.Ast.ANTLR.Tree.AbstractNullnessCheckNode : UnaryLogicOperatorNode {
    protected int ExpansionConnectorType { get; }
    protected string ExpansionConnectorText { get; }
    protected AbstractNullnessCheckNode(IToken token);
    public virtual void Initialize();
    protected abstract virtual int get_ExpansionConnectorType();
    protected abstract virtual string get_ExpansionConnectorText();
    private void MutateRowValueConstructorSyntax(int operandColumnSpan);
    private static IType ExtractDataType(IASTNode operand);
    private static String[] ExtractMutationTexts(IASTNode operand, int count);
}
[CLSCompliantAttribute("False")]
public abstract class NHibernate.Hql.Ast.ANTLR.Tree.AbstractRestrictableStatement : AbstractStatement {
    private FromClause _fromClause;
    private IASTNode _whereClause;
    public FromClause FromClause { get; }
    public bool HasWhereClause { get; }
    public IASTNode WhereClause { get; }
    protected AbstractRestrictableStatement(IToken token);
    protected abstract virtual INHibernateLogger GetLog();
    protected abstract virtual int GetWhereClauseParentTokenType();
    public sealed virtual FromClause get_FromClause();
    public sealed virtual bool get_HasWhereClause();
    public sealed virtual IASTNode get_WhereClause();
}
[CLSCompliantAttribute("False")]
public abstract class NHibernate.Hql.Ast.ANTLR.Tree.AbstractSelectExpression : HqlSqlWalkerNode {
    private string _alias;
    private int _scalarColumnIndex;
    public string Alias { get; public set; }
    public int ScalarColumnIndex { get; }
    public bool IsConstructor { get; }
    public bool IsReturnableEntity { get; }
    public FromElement FromElement { get; public set; }
    public bool IsScalar { get; }
    protected AbstractSelectExpression(IToken token);
    public sealed virtual string get_Alias();
    public sealed virtual void set_Alias(string value);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public sealed virtual void SetScalarColumn(int i);
    public sealed virtual String[] SetScalarColumn(int i, Func`3<int, int, string> aliasCreator);
    public sealed virtual int get_ScalarColumnIndex();
    public sealed virtual bool get_IsConstructor();
    public virtual bool get_IsReturnableEntity();
    public virtual FromElement get_FromElement();
    public virtual void set_FromElement(FromElement value);
    public virtual bool get_IsScalar();
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public abstract virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
}
[CLSCompliantAttribute("False")]
public abstract class NHibernate.Hql.Ast.ANTLR.Tree.AbstractStatement : HqlSqlWalkerNode {
    public bool NeedsExecutor { get; }
    public int StatementType { get; }
    protected AbstractStatement(IToken token);
    public abstract virtual bool get_NeedsExecutor();
    public abstract virtual int get_StatementType();
    public sealed virtual string GetDisplayText();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.AggregateNode : AbstractSelectExpression {
    public string FunctionName { get; }
    public IType DataType { get; public set; }
    public AggregateNode(IToken token);
    public string get_FunctionName();
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.AssignmentSpecification : object {
    private IASTNode _eq;
    private ISessionFactoryImplementor _factory;
    private HashSet`1<string> _tableNames;
    private IParameterSpecification[] _hqlParameters;
    private SqlString _sqlAssignmentString;
    public IParameterSpecification[] Parameters { get; }
    public SqlString SqlAssignmentFragment { get; }
    public AssignmentSpecification(IASTNode eq, IQueryable persister);
    public bool AffectsTable(string tableName);
    private static bool IsParam(IASTNode node);
    private static void ValidateLhs(FromReferenceNode lhs);
    public IParameterSpecification[] get_Parameters();
    public SqlString get_SqlAssignmentFragment();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ASTErrorNode : ASTNode {
    [CompilerGeneratedAttribute]
private ITokenStream <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private IToken <Stop>k__BackingField;
    [CompilerGeneratedAttribute]
private RecognitionException <RecognitionException>k__BackingField;
    public ITokenStream Input { get; private set; }
    public IToken Stop { get; private set; }
    public RecognitionException RecognitionException { get; private set; }
    public ASTErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
    [CompilerGeneratedAttribute]
public ITokenStream get_Input();
    [CompilerGeneratedAttribute]
private void set_Input(ITokenStream value);
    [CompilerGeneratedAttribute]
public IToken get_Stop();
    [CompilerGeneratedAttribute]
private void set_Stop(IToken value);
    [CompilerGeneratedAttribute]
public RecognitionException get_RecognitionException();
    [CompilerGeneratedAttribute]
private void set_RecognitionException(RecognitionException value);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ASTFactory : object {
    private ITreeAdaptor _adaptor;
    public ASTFactory(ITreeAdaptor adaptor);
    public sealed virtual IASTNode CreateNode(int type, string text, IASTNode[] children);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ASTNode : object {
    private int _startIndex;
    private int _stopIndex;
    private int _childIndex;
    private IASTNode _parent;
    private IToken _token;
    private List`1<IASTNode> _children;
    public bool IsNil { get; }
    public int Type { get; public set; }
    public string Text { get; public set; }
    public IASTNode Parent { get; public set; }
    public int ChildCount { get; }
    public int ChildIndex { get; }
    public int Line { get; }
    public int CharPositionInLine { get; }
    public IASTNode NextSibling { get; }
    public IToken Token { get; }
    private int Antlr.Runtime.Tree.ITree.ChildIndex { get; private set; }
    private ITree Antlr.Runtime.Tree.ITree.Parent { get; private set; }
    private int Antlr.Runtime.Tree.ITree.TokenStartIndex { get; private set; }
    private int Antlr.Runtime.Tree.ITree.TokenStopIndex { get; private set; }
    public ASTNode(IToken token);
    public ASTNode(ASTNode other);
    public sealed virtual bool get_IsNil();
    public sealed virtual int get_Type();
    public sealed virtual void set_Type(int value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public sealed virtual IASTNode get_Parent();
    public sealed virtual void set_Parent(IASTNode value);
    public sealed virtual int get_ChildCount();
    public sealed virtual int get_ChildIndex();
    public sealed virtual int get_Line();
    public sealed virtual int get_CharPositionInLine();
    public sealed virtual IASTNode AddChild(IASTNode child);
    public sealed virtual IASTNode InsertChild(int index, IASTNode child);
    public sealed virtual IASTNode AddSibling(IASTNode newSibling);
    public sealed virtual void RemoveChild(IASTNode child);
    public void RemoveChild(int index);
    public sealed virtual void ClearChildren();
    public sealed virtual void AddChildren(IEnumerable`1<IASTNode> children);
    public sealed virtual void AddChildren(IASTNode[] children);
    public sealed virtual IASTNode DupNode();
    public sealed virtual IASTNode get_NextSibling();
    public sealed virtual IASTNode GetChild(int index);
    public sealed virtual IASTNode GetFirstChild();
    public sealed virtual void SetFirstChild(IASTNode newChild);
    public sealed virtual void SetChild(int index, IASTNode newChild);
    public sealed virtual IToken get_Token();
    public virtual string ToString();
    public sealed virtual string ToStringTree();
    public sealed virtual IEnumerator`1<IASTNode> GetEnumerator();
    public sealed virtual bool HasAncestor(int ttype);
    public sealed virtual ITree GetAncestor(int ttype);
    public sealed virtual IList`1<ITree> GetAncestors();
    private sealed virtual override void Antlr.Runtime.Tree.ITree.FreshenParentAndChildIndexes();
    private sealed virtual override ITree Antlr.Runtime.Tree.ITree.GetChild(int i);
    private sealed virtual override void Antlr.Runtime.Tree.ITree.AddChild(ITree t);
    private sealed virtual override void Antlr.Runtime.Tree.ITree.SetChild(int i, ITree t);
    private sealed virtual override object Antlr.Runtime.Tree.ITree.DeleteChild(int i);
    private sealed virtual override void Antlr.Runtime.Tree.ITree.ReplaceChildren(int startChildIndex, int stopChildIndex, object t);
    private sealed virtual override ITree Antlr.Runtime.Tree.ITree.DupNode();
    private sealed virtual override int Antlr.Runtime.Tree.ITree.get_ChildIndex();
    private sealed virtual override void Antlr.Runtime.Tree.ITree.set_ChildIndex(int value);
    private sealed virtual override ITree Antlr.Runtime.Tree.ITree.get_Parent();
    private sealed virtual override void Antlr.Runtime.Tree.ITree.set_Parent(ITree value);
    private sealed virtual override int Antlr.Runtime.Tree.ITree.get_TokenStartIndex();
    private sealed virtual override void Antlr.Runtime.Tree.ITree.set_TokenStartIndex(int value);
    private sealed virtual override int Antlr.Runtime.Tree.ITree.get_TokenStopIndex();
    private sealed virtual override void Antlr.Runtime.Tree.ITree.set_TokenStopIndex(int value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void FreshenParentAndChildIndexes();
    private void FreshenParentAndChildIndexes(int offset);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ASTTreeAdaptor : BaseTreeAdaptor {
    public virtual object DupNode(object t);
    public virtual object Create(IToken payload);
    public virtual IToken GetToken(object treeNode);
    public virtual IToken CreateToken(int tokenType, string text);
    public virtual IToken CreateToken(IToken fromToken);
    public virtual object ErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.BetweenOperatorNode : SqlNode {
    public IType DataType { get; public set; }
    public BetweenOperatorNode(IToken token);
    public sealed virtual void Initialize();
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    private IASTNode GetFixtureOperand();
    private IASTNode GetLowOperand();
    private IASTNode GetHighOperand();
    private static void Check(IASTNode check, IASTNode first, IASTNode second);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.BinaryArithmeticOperatorNode : AbstractSelectExpression {
    public IType DataType { get; public set; }
    public IASTNode LeftHandOperand { get; }
    public IASTNode RightHandOperand { get; }
    public BinaryArithmeticOperatorNode(IToken token);
    public sealed virtual void Initialize();
    private void TrySetExpectedType(IASTNode operand, IType otherOperandType, bool leftHandOperand);
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    private IType ResolveDataType();
    private static bool IsDateTimeType(IType type);
    private IType ResolveDateTimeArithmeticResultType(IType lhType, IType rhType);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public sealed virtual IASTNode get_LeftHandOperand();
    public sealed virtual IASTNode get_RightHandOperand();
    public sealed virtual string GetDisplayText();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.BinaryLogicOperatorNode : HqlSqlWalkerNode {
    private List`1<IParameterSpecification> embeddedParameters;
    public IASTNode LeftHandOperand { get; }
    public IASTNode RightHandOperand { get; }
    public bool HasEmbeddedParameters { get; }
    public BinaryLogicOperatorNode(IToken token);
    public sealed virtual IASTNode get_LeftHandOperand();
    public sealed virtual IASTNode get_RightHandOperand();
    public virtual void Initialize();
    protected void MutateRowValueConstructorSyntaxesIfNecessary(IType lhsType, IType rhsType);
    private static bool AreCompatibleEntityTypes(IType lhsType, IType rhsType);
    private void MutateRowValueConstructorSyntax(int valueElements);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
    public sealed virtual void AddEmbeddedParameter(IParameterSpecification specification);
    public sealed virtual bool get_HasEmbeddedParameters();
    public sealed virtual IParameterSpecification[] GetEmbeddedParameters();
    private protected string Translate(int valueElements, string comparisonText, String[] lhsElementTexts, String[] rhsElementTexts);
    private protected static String[] ExtractMutationTexts(IASTNode operand, int count);
    private static bool IsGuessedType(IASTNode operand);
    protected static IType ExtractDataType(IASTNode operand);
    private void ProcessMetaTypeDiscriminatorIfNecessary(IASTNode lhs, IASTNode rhs);
    private void EvaluateType(SqlNode node, MetaType metaType);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.BooleanLiteralNode : LiteralNode {
    [CompilerGeneratedAttribute]
private IType <ExpectedType>k__BackingField;
    public IType DataType { get; public set; }
    public IType ExpectedType { get; public set; }
    public BooleanLiteralNode(IToken token);
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    private ILiteralType TypeAsLiteralType();
    private bool GetValue();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpectedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpectedType(IType value);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.Case2Node : AbstractSelectExpression {
    public IType DataType { get; public set; }
    public Case2Node(IToken token);
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    private ISelectExpression GetFirstThenNode();
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.CaseNode : AbstractSelectExpression {
    private IType _expectedType;
    public IType DataType { get; public set; }
    public IType ExpectedType { get; public set; }
    public CaseNode(IToken token);
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    [IteratorStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.Tree.CaseNode/<GetResultNodes>d__5")]
public IEnumerable`1<IASTNode> GetResultNodes();
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.CollectionFunction : MethodNode {
    public CollectionFunction(IToken token);
    public virtual void Resolve(bool inSelect);
    protected virtual void PrepareSelectColumns(String[] selectColumns);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ComponentJoin : FromElement {
    private string columns;
    private string componentPath;
    private string componentProperty;
    private ComponentType componentType;
    public string ComponentPath { get; }
    public ComponentType ComponentType { get; }
    public string ComponentProperty { get; }
    public IType DataType { get; public set; }
    public ComponentJoin(FromClause fromClause, FromElement origin, string alias, string componentPath, ComponentType componentType);
    public string get_ComponentPath();
    public ComponentType get_ComponentType();
    public string get_ComponentProperty();
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    public virtual string GetIdentityColumn();
    public virtual string GetDisplayText();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ConstructorNode : SelectExpressionList {
    private IType[] _constructorArgumentTypes;
    private ConstructorInfo _constructor;
    private bool _isMap;
    private bool _isList;
    private int _scalarColumnIndex;
    public IList`1<IType> ConstructorArgumentTypeList { get; }
    public int ScalarColumnIndex { get; }
    public FromElement FromElement { get; }
    public bool IsConstructor { get; }
    public bool IsReturnableEntity { get; }
    public bool IsScalar { get; }
    public string Alias { get; public set; }
    public ConstructorInfo Constructor { get; }
    public bool IsMap { get; }
    public bool IsList { get; }
    public ConstructorNode(IToken token);
    public IList`1<IType> get_ConstructorArgumentTypeList();
    public String[] GetAliases();
    protected internal virtual IASTNode GetFirstSelectExpression();
    public sealed virtual int get_ScalarColumnIndex();
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public sealed virtual void SetScalarColumn(int i);
    public sealed virtual String[] SetScalarColumn(int i, Func`3<int, int, string> aliasCreator);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public sealed virtual void SetScalarColumnText(int i);
    public sealed virtual FromElement get_FromElement();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsReturnableEntity();
    public sealed virtual bool get_IsScalar();
    public sealed virtual string get_Alias();
    public sealed virtual void set_Alias(string value);
    public ConstructorInfo get_Constructor();
    public bool get_IsMap();
    public bool get_IsList();
    public void Prepare();
    private IType[] ResolveConstructorArgumentTypes();
    private ConstructorInfo ResolveConstructor(string path);
}
internal class NHibernate.Hql.Ast.ANTLR.Tree.CountNode : AggregateNode {
    public IType DataType { get; public set; }
    public CountNode(IToken token);
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.DeleteStatement : AbstractRestrictableStatement {
    private static INHibernateLogger Log;
    public bool NeedsExecutor { get; }
    public int StatementType { get; }
    public DeleteStatement(IToken token);
    private static DeleteStatement();
    public virtual bool get_NeedsExecutor();
    public virtual int get_StatementType();
    protected virtual INHibernateLogger GetLog();
    protected virtual int GetWhereClauseParentTokenType();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.DotNode : FromReferenceNode {
    private static INHibernateLogger Log;
    private static int DerefUnknown;
    private static int DerefEntity;
    private static int DerefComponent;
    private static int DerefCollection;
    private static int DerefPrimitive;
    private static int DerefIdentifier;
    private static int DerefJavaConstant;
    public static bool UseThetaStyleImplicitJoins;
    public static bool REGRESSION_STYLE_JOIN_SUPPRESSION;
    private string _path;
    private int _dereferenceType;
    private string _propertyName;
    private string _propertyPath;
    private String[] _columns;
    private bool _fetch;
    private FromElement _impliedJoin;
    private JoinType _joinType;
    private object _constantValue;
    [CompilerGeneratedAttribute]
private bool <SkipSemiResolve>k__BackingField;
    unknown JoinType JoinType {public set; }
    unknown bool Fetch {public set; }
    public string Path { get; }
    public string PropertyPath { get; public set; }
    internal bool SkipSemiResolve { get; internal set; }
    private bool IsCorrelatedSubselect { get; }
    public IType ExpectedType { get; public set; }
    public DotNode(IToken token);
    private static DotNode();
    public void set_JoinType(JoinType value);
    public void set_Fetch(bool value);
    public virtual FromElement GetImpliedJoin();
    public virtual string get_Path();
    public string get_PropertyPath();
    public void set_PropertyPath(string value);
    [CompilerGeneratedAttribute]
internal bool get_SkipSemiResolve();
    [CompilerGeneratedAttribute]
internal void set_SkipSemiResolve(bool value);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public virtual void ResolveIndex(IASTNode parent);
    public virtual void ResolveFirstChild();
    public virtual void ResolveInFunctionCall(bool generateJoin, bool implicitJoin);
    public virtual void Resolve(bool generateJoin, bool implicitJoin, string classAlias, IASTNode parent);
    public FromReferenceNode GetLhs();
    private IType GetDataType();
    public void SetResolvedConstant(string text);
    public void SetResolvedConstant(string text, object value);
    private static QueryException BuildIllegalCollectionDereferenceException(string propertyName, IASTNode lhs);
    private void DereferenceCollection(CollectionType collectionType, bool implicitJoin, bool indexed, string classAlias);
    private void DereferenceEntity(EntityType entityType, bool implicitJoin, string classAlias, bool generateJoin, IASTNode parent);
    private void DereferenceEntityIdentifier(string propertyName, DotNode dotParent);
    private void DereferenceEntityJoin(string classAlias, EntityType propertyType, bool impliedJoin, IASTNode parent, bool forceLeftJoin);
    private bool AreSame(string alias1, string alias2);
    private bool CanReuse(string classAlias, FromElement fromElement);
    private void SetImpliedJoin(FromElement elem);
    private bool IsReferenceToPrimaryKey(string propertyName, EntityType owningType);
    private void CheckForCorrelatedSubquery(string methodName);
    private bool get_IsCorrelatedSubselect();
    private void CheckLhsIsNotCollection();
    private IType PrepareLhs();
    private void DereferenceComponent(IASTNode parent);
    private void SetPropertyNameAndPath(IASTNode parent);
    private void InitText();
    private String[] GetColumns();
    private static void CheckSubclassOrSuperclassPropertyReference(AbstractSelectExpression lhs, string propertyName);
    private static bool IsDotNode(IASTNode n);
    public void ResolveSelectExpression();
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
}
internal class NHibernate.Hql.Ast.ANTLR.Tree.EntityJoinFromElement : FromElement {
    public EntityJoinFromElement(FromClause fromClause, IQueryable entityPersister, JoinType joinType, string alias);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.FromClause : HqlSqlWalkerNode {
    private static INHibernateLogger Log;
    private static int RootLevel;
    private int _level;
    private int _fromElementCounter;
    private NullableDictionary`2<string, FromElement> _fromElementByClassAlias;
    private Dictionary`2<string, FromElement> _fromElementByTableAlias;
    private NullableDictionary`2<string, FromElement> _fromElementsByPath;
    private List`1<FromElement> _fromElements;
    private List`1<FromElement> _appendFromElements;
    private NullableDictionary`2<string, FromElement> _collectionJoinFromElementsByPath;
    private FromClause _parentFromClause;
    private ISet`1<FromClause> _childFromClauses;
    [CompilerGeneratedAttribute]
private bool <IsJoinSubQuery>k__BackingField;
    public FromClause ParentFromClause { get; }
    private int Level { get; }
    public bool IsSubQuery { get; }
    internal bool IsScalarSubQuery { get; }
    internal bool IsJoinSubQuery { get; internal set; }
    public FromClause(IToken token);
    private static FromClause();
    public void SetParentFromClause(FromClause parentFromClause);
    public FromClause get_ParentFromClause();
    public IList`1<IASTNode> GetExplicitFromElements();
    internal IList`1<FromElement> GetExplicitFromElementsTyped();
    public IList`1<IASTNode> GetCollectionFetches();
    internal IList`1<FromElement> GetCollectionFetchesTyped();
    public FromElement FindCollectionJoin(string path);
    public bool IsFromElementAlias(string possibleAlias);
    public bool ContainsClassAlias(string alias);
    public bool ContainsTableAlias(string alias);
    public void AddJoinByPathMap(string path, FromElement destination);
    public void AddCollectionJoinFromElementByPath(string path, FromElement destination);
    private void AddChild(FromClause fromClause);
    public FromElement AddFromElement(string path, IASTNode alias);
    public FromElement GetFromElement(string aliasOrClassName);
    public IList`1<IASTNode> GetFromElements();
    internal IList`1<FromElement> GetFromElementsTyped();
    public IList`1<IASTNode> GetProjectionList();
    internal IList`1<FromElement> GetProjectionListTyped();
    internal IList`1<FromElement> GetAllProjectionListTyped();
    public FromElement GetFromElement();
    public void AddDuplicateAlias(string alias, FromElement element);
    public FromElement FindJoinByPath(string path);
    private int get_Level();
    public bool get_IsSubQuery();
    internal bool get_IsScalarSubQuery();
    [CompilerGeneratedAttribute]
internal bool get_IsJoinSubQuery();
    [CompilerGeneratedAttribute]
internal void set_IsJoinSubQuery(bool value);
    public sealed virtual string GetDisplayText();
    private void CheckForDuplicateClassAlias(string classAlias);
    private static bool ProjectionListPredicate(IASTNode node, FromClause fromClause);
    private static bool AllProjectionListPredicate(IASTNode node);
    private static bool FromElementPredicate(IASTNode node, FromClause fromClause);
    private static bool ExplicitFromPredicate(IASTNode node);
    private static bool CollectionFetchPredicate(IASTNode node);
    private FromElement FindIntendedAliasedFromElementBasedOnCrazyJPARequirements(string specifiedAlias);
    public void RegisterFromElement(FromElement element);
    internal void AppendFromElement(FromElement element);
    private FromElement FindJoinByPathLocal(string path);
    public virtual string ToString();
    public virtual void Resolve();
    public FromElement GetFromElementByClassName(string className);
    internal void FinishInit();
    private FromElement GetFirstDependentFromElement(FromElement element);
    [CompilerGeneratedAttribute]
private bool <GetFromElements>b__29_0(IASTNode node);
    [CompilerGeneratedAttribute]
private bool <GetFromElementsTyped>b__30_0(IASTNode node);
    [CompilerGeneratedAttribute]
private bool <GetProjectionList>b__31_0(IASTNode node);
    [CompilerGeneratedAttribute]
private bool <GetProjectionListTyped>b__32_0(IASTNode node);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.FromElement : HqlSqlWalkerNode {
    private static INHibernateLogger Log;
    private bool _isAllPropertyFetch;
    private FromElementType _elementType;
    private string _tableAlias;
    private string _classAlias;
    private string _className;
    private string _collectionTableAlias;
    private FromClause _fromClause;
    private String[] _columns;
    private String[] _fetchLazyProperties;
    private FromElement _origin;
    private bool _useFromFragment;
    private bool _useWhereFragment;
    private bool _includeSubclasses;
    private List`1<FromElement> _destinations;
    private bool _dereferencedBySubclassProperty;
    private bool _dereferencedBySuperclassProperty;
    private bool _collectionJoin;
    private string _role;
    private bool _initialized;
    private SqlString _withClauseFragment;
    private string _withClauseJoinAlias;
    private bool _filter;
    private IToken _token;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsPartOfJoinSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private FromElement <ParentFromElement>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<FromElement> <WithClauseFromElements>k__BackingField;
    private bool _fetch;
    [CompilerGeneratedAttribute]
private bool <ReusedJoin>k__BackingField;
    private List`1<IParameterSpecification> _embeddedParameters;
    public JoinSequence JoinSequence { get; public set; }
    public String[] Columns { get; public set; }
    public bool IsEntity { get; }
    public bool IsFromOrJoinFragment { get; }
    public bool IsAllPropertyFetch { get; public set; }
    public String[] FetchLazyProperties { get; public set; }
    public bool IsImpliedInFromClause { get; }
    public bool IsFetch { get; }
    unknown bool Filter {public set; }
    public bool IsFilter { get; }
    public bool HasEmbeddedParameters { get; }
    public IParameterSpecification IndexCollectionSelectorParamSpec { get; public set; }
    public bool IsImplied { get; }
    internal Nullable`1<bool> IsPartOfJoinSequence { get; internal set; }
    public bool IsDereferencedBySuperclassOrSubclassProperty { get; }
    public bool IsDereferencedBySubclassProperty { get; }
    public IEntityPersister EntityPersister { get; }
    public IType DataType { get; public set; }
    public string TableAlias { get; }
    private string TableName { get; }
    public string ClassAlias { get; }
    public string ClassName { get; }
    public FromClause FromClause { get; }
    public IQueryable Queryable { get; }
    public IQueryableCollection QueryableCollection { get; public set; }
    public string CollectionTableAlias { get; public set; }
    public bool CollectionJoin { get; public set; }
    public string CollectionSuffix { get; public set; }
    public string EntitySuffix { get; public set; }
    public IType SelectType { get; }
    public bool IsCollectionOfValuesOrComponents { get; }
    public bool IsCollectionJoin { get; }
    internal FromElement ParentFromElement { get; internal set; }
    public FromElement Origin { get; }
    public FromElement RealOrigin { get; }
    public SqlString WithClauseFragment { get; public set; }
    internal HashSet`1<FromElement> WithClauseFromElements { get; internal set; }
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public string WithClauseJoinAlias { get; }
    public bool IncludeSubclasses { get; public set; }
    public bool InProjectionList { get; public set; }
    public bool Fetch { get; public set; }
    public bool UseFromFragment { get; public set; }
    public bool UseWhereFragment { get; public set; }
    internal bool UseTableAliases { get; }
    internal bool ReusedJoin { get; internal set; }
    public FromElement(IToken token);
    protected FromElement(FromClause fromClause, FromElement origin, string alias);
    private static FromElement();
    protected void InitializeComponentJoin(FromElementType elementType);
    public void SetAllPropertyFetch(bool fetch);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public void SetWithClauseFragment(string withClauseJoinAlias, SqlString withClauseFragment);
    public JoinSequence get_JoinSequence();
    public void set_JoinSequence(JoinSequence value);
    public String[] get_Columns();
    public void set_Columns(String[] value);
    public bool get_IsEntity();
    public bool get_IsFromOrJoinFragment();
    public bool get_IsAllPropertyFetch();
    public void set_IsAllPropertyFetch(bool value);
    public String[] get_FetchLazyProperties();
    public void set_FetchLazyProperties(String[] value);
    public virtual bool get_IsImpliedInFromClause();
    public bool get_IsFetch();
    public void set_Filter(bool value);
    public bool get_IsFilter();
    public sealed virtual IParameterSpecification[] GetEmbeddedParameters();
    public sealed virtual bool get_HasEmbeddedParameters();
    public IParameterSpecification get_IndexCollectionSelectorParamSpec();
    public void set_IndexCollectionSelectorParamSpec(IParameterSpecification value);
    public virtual bool get_IsImplied();
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsPartOfJoinSequence();
    [CompilerGeneratedAttribute]
internal void set_IsPartOfJoinSequence(Nullable`1<bool> value);
    public bool get_IsDereferencedBySuperclassOrSubclassProperty();
    public bool get_IsDereferencedBySubclassProperty();
    public IEntityPersister get_EntityPersister();
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    public string get_TableAlias();
    private string get_TableName();
    public string get_ClassAlias();
    public string get_ClassName();
    public FromClause get_FromClause();
    public IQueryable get_Queryable();
    public IQueryableCollection get_QueryableCollection();
    public void set_QueryableCollection(IQueryableCollection value);
    public string get_CollectionTableAlias();
    public void set_CollectionTableAlias(string value);
    public bool get_CollectionJoin();
    public void set_CollectionJoin(bool value);
    public string get_CollectionSuffix();
    public void set_CollectionSuffix(string value);
    public string get_EntitySuffix();
    public void set_EntitySuffix(string value);
    public virtual IType get_SelectType();
    public bool get_IsCollectionOfValuesOrComponents();
    public bool get_IsCollectionJoin();
    public void SetRole(string role);
    [CompilerGeneratedAttribute]
internal FromElement get_ParentFromElement();
    [CompilerGeneratedAttribute]
internal void set_ParentFromElement(FromElement value);
    public FromElement get_Origin();
    public FromElement get_RealOrigin();
    public SqlString get_WithClauseFragment();
    public void set_WithClauseFragment(SqlString value);
    [CompilerGeneratedAttribute]
internal HashSet`1<FromElement> get_WithClauseFromElements();
    [CompilerGeneratedAttribute]
internal void set_WithClauseFromElements(HashSet`1<FromElement> value);
    public string get_WithClauseJoinAlias();
    [ObsoleteAttribute("Use GetIdentifierSelectFragment method instead.")]
public string RenderIdentifierSelect(int size, int k);
    public SelectFragment GetIdentifierSelectFragment(string suffix);
    internal SelectFragment GetIdentifierSelectFragment(string suffix, string alias);
    [ObsoleteAttribute("Use GetPropertiesSelectFragment method instead.")]
public string RenderPropertySelect(int size, int k);
    public SelectFragment GetPropertiesSelectFragment(string suffix);
    internal SelectFragment GetPropertiesSelectFragment(string suffix, string alias);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
    [ObsoleteAttribute("Use GetCollectionSelectFragment method instead.")]
public string RenderCollectionSelectFragment(int size, int k);
    public SelectFragment GetCollectionSelectFragment(string suffix);
    [ObsoleteAttribute("Use GetValueCollectionSelectFragment method instead.")]
public string RenderValueCollectionSelectFragment(int size, int k);
    public SelectFragment GetValueCollectionSelectFragment(string suffix);
    public void SetIndexCollectionSelectorParamSpec(IParameterSpecification indexCollectionSelectorParamSpec);
    public virtual void SetImpliedInFromClause(bool flag);
    public virtual bool get_IncludeSubclasses();
    public virtual void set_IncludeSubclasses(bool value);
    public virtual bool get_InProjectionList();
    public virtual void set_InProjectionList(bool value);
    public bool get_Fetch();
    public void set_Fetch(bool value);
    [ObsoleteAttribute("Use GetScalarIdentifierSelectFragment method instead.")]
public string RenderScalarIdentifierSelect(int i);
    public SelectFragment GetScalarIdentifierSelectFragment(int i, Func`3<int, int, string> aliasCreator);
    public bool get_UseFromFragment();
    public void set_UseFromFragment(bool value);
    public bool get_UseWhereFragment();
    public void set_UseWhereFragment(bool value);
    public String[] ToColumns(string tableAlias, string path, bool inSelect);
    public String[] ToColumns(string tableAlias, string path, bool inSelect, bool forceAlias);
    public IPropertyMapping GetPropertyMapping(string propertyName);
    public IType GetPropertyType(string propertyName, string propertyPath);
    public virtual string GetIdentityColumn();
    internal String[] GetIdentityColumns();
    internal virtual String[] GetIdentityColumns(string alias);
    internal bool get_UseTableAliases();
    [CompilerGeneratedAttribute]
internal bool get_ReusedJoin();
    [CompilerGeneratedAttribute]
internal void set_ReusedJoin(bool value);
    public void HandlePropertyBeingDereferenced(IType propertySource, string propertyName);
    public void SetOrigin(FromElement origin, bool manyToMany);
    public void SetIncludeSubclasses(bool includeSubclasses);
    public virtual string GetDisplayText();
    public void InitializeCollection(FromClause fromClause, string classAlias, string tableAlias);
    public void InitializeEntity(FromClause fromClause, string className, IEntityPersister persister, EntityType type, string classAlias, string tableAlias);
    internal void Initialize(FromClause fromClause, IPropertyMapping propertyMapping, IType type, string classAlias, string tableAlias, IEntityPersister persister);
    public void CheckInitialized();
    protected void AppendDisplayText(StringBuilder buf);
    private void AddDestination(FromElement fromElement);
    private void DoInitialize(FromClause fromClause, string tableAlias, string className, string classAlias, IEntityPersister persister, IType type, IPropertyMapping propertyMapping);
    public sealed virtual void AddEmbeddedParameter(IParameterSpecification specification);
    internal bool IsEntityJoin();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.FromElementFactory : object {
    private static INHibernateLogger Log;
    private FromClause _fromClause;
    private FromElement _origin;
    private string _path;
    private bool _collection;
    private string _classAlias;
    private String[] _columns;
    private bool _implied;
    private bool _inElementsFunction;
    private IQueryableCollection _queryableCollection;
    private CollectionType _collectionType;
    private String[] Columns { get; }
    public FromElementFactory(FromClause fromClause, FromElement origin, string path);
    public FromElementFactory(FromClause fromClause, FromElement origin, string path, string classAlias, String[] columns, bool implied);
    private static FromElementFactory();
    public FromElement AddFromElement();
    public FromElement CreateCollectionElementsJoin(IQueryableCollection queryableCollection, string collectionName);
    private FromElement CreateFromElementInSubselect(string path, string pathAlias, FromElement parentFromElement, string classAlias);
    public FromElement CreateCollection(IQueryableCollection queryableCollection, string role, JoinType joinType, bool fetchFlag, bool indexed);
    public FromElement CreateElementJoin(IQueryableCollection queryableCollection);
    public FromElement CreateEntityJoin(string entityClass, string tableAlias, JoinSequence joinSequence, bool fetchFlag, bool inFrom, EntityType type);
    private FromElement CreateEntityAssociation(string role, string roleAlias, JoinType joinType, bool implicitJoin);
    private FromElement CreateCollectionJoin(JoinSequence collectionJoinSequence, string tableAlias);
    private FromElement CreateManyToMany(string role, string associatedEntityName, string roleAlias, IEntityPersister entityPersister, EntityType type, JoinType joinType, bool implicitJoin);
    private JoinSequence CreateJoinSequence(string roleAlias, JoinType joinType, bool implicitJoin);
    private FromElement CreateJoin(string entityClass, string tableAlias, JoinSequence joinSequence, EntityType type, bool manyToMany);
    private FromElement InitializeJoin(string path, FromElement destination, JoinSequence joinSequence, String[] columns, FromElement origin, bool manyToMany);
    private FromElement EvaluateFromElementPath(string path, string classAlias);
    private FromElement CreateFromElement(IEntityPersister entityPersister);
    private IASTNode CreateFromElement(string text);
    private void InitializeAndAddFromElement(FromElement element, string className, string classAlias, IEntityPersister entityPersister, EntityType type, string tableAlias);
    private FromElement CreateAndAddFromElement(string className, string classAlias, IEntityPersister entityPersister, EntityType type, string tableAlias);
    private String[] get_Columns();
    public FromElement CreateComponentJoin(ComponentType type);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.FromElementType : object {
    private static INHibernateLogger Log;
    private FromElement _fromElement;
    private IEntityPersister _persister;
    private IPropertyMapping _propertyMapping;
    private IType _type;
    private IQueryableCollection _queryableCollection;
    private CollectionPropertyMapping _collectionPropertyMapping;
    private JoinSequence _joinSequence;
    private IParameterSpecification _indexCollectionSelectorParamSpec;
    private string _collectionSuffix;
    [CompilerGeneratedAttribute]
private string <EntitySuffix>k__BackingField;
    public IEntityPersister EntityPersister { get; }
    private string TableAlias { get; }
    private string CollectionTableAlias { get; }
    public IType DataType { get; }
    public IType SelectType { get; }
    public string CollectionSuffix { get; public set; }
    public string EntitySuffix { get; public set; }
    public IParameterSpecification IndexCollectionSelectorParamSpec { get; public set; }
    public JoinSequence JoinSequence { get; public set; }
    public bool IsEntity { get; }
    public bool IsCollectionOfValuesOrComponents { get; }
    public IQueryable Queryable { get; }
    public IQueryableCollection QueryableCollection { get; public set; }
    private bool IsCorrelation { get; }
    private bool IsMultiTable { get; }
    public FromElementType(FromElement fromElement, IEntityPersister persister, EntityType entityType);
    internal FromElementType(FromElement fromElement, IEntityPersister persister, IPropertyMapping propertyMapping, IType type);
    protected FromElementType(FromElement fromElement);
    private static FromElementType();
    public IEntityPersister get_EntityPersister();
    private string get_TableAlias();
    private string get_CollectionTableAlias();
    public virtual IType get_DataType();
    public IType get_SelectType();
    public string get_CollectionSuffix();
    public void set_CollectionSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_EntitySuffix();
    [CompilerGeneratedAttribute]
public void set_EntitySuffix(string value);
    public IParameterSpecification get_IndexCollectionSelectorParamSpec();
    public void set_IndexCollectionSelectorParamSpec(IParameterSpecification value);
    public JoinSequence get_JoinSequence();
    public void set_JoinSequence(JoinSequence value);
    [ObsoleteAttribute("Use GetIdentifierSelectFragment method instead.")]
public string RenderIdentifierSelect(int size, int k);
    public SelectFragment GetIdentifierSelectFragment(string suffix);
    internal SelectFragment GetIdentifierSelectFragment(string suffix, string alias);
    [ObsoleteAttribute("Use GetScalarIdentifierSelectFragment method instead.")]
public virtual string RenderScalarIdentifierSelect(int i);
    public virtual SelectFragment GetScalarIdentifierSelectFragment(int i, Func`3<int, int, string> aliasCreator);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public string RenderPropertySelect(int size, int k, bool allProperties);
    internal SelectFragment GetPropertiesSelectFragment(string suffix, bool allProperties, string alias);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public string RenderPropertySelect(int size, int k, String[] fetchLazyProperties);
    internal SelectFragment GetPropertiesSelectFragment(string suffix, String[] fetchLazyProperties, string alias);
    private SelectFragment GetPropertiesSelectFragment(string suffix, String[] fetchLazyProperties, bool allProperties, string alias);
    [ObsoleteAttribute("Use GetCollectionSelectFragment method instead.")]
public string RenderCollectionSelectFragment(int size, int k);
    public SelectFragment GetCollectionSelectFragment(string suffix);
    [ObsoleteAttribute("Use GetValueCollectionSelectFragment method instead.")]
public string RenderValueCollectionSelectFragment(int size, int k);
    public SelectFragment GetValueCollectionSelectFragment(string suffix);
    public bool get_IsEntity();
    public bool get_IsCollectionOfValuesOrComponents();
    public virtual IPropertyMapping GetPropertyMapping(string propertyName);
    public virtual IType GetPropertyType(string propertyName, string propertyPath);
    public String[] ToColumns(string tableAlias, string path, bool inSelect);
    public IQueryable get_Queryable();
    public virtual IQueryableCollection get_QueryableCollection();
    public virtual void set_QueryableCollection(IQueryableCollection value);
    public String[] ToColumns(string tableAlias, string path, bool inSelect, bool forceAlias);
    private static string GetSuffix(int size, int sequence);
    private static string GenerateSuffix(int size, int k);
    private void CheckInitialized();
    private bool get_IsCorrelation();
    private bool get_IsMultiTable();
    private string ExtractTableName();
}
[CLSCompliantAttribute("False")]
public abstract class NHibernate.Hql.Ast.ANTLR.Tree.FromReferenceNode : AbstractSelectExpression {
    private static INHibernateLogger Log;
    public static int RootLevel;
    private FromElement _fromElement;
    private bool _resolved;
    public bool IsReturnableEntity { get; }
    public FromElement FromElement { get; public set; }
    public bool IsResolved { get; public set; }
    public string Path { get; }
    protected FromReferenceNode(IToken token);
    private static FromReferenceNode();
    public virtual bool get_IsReturnableEntity();
    public virtual FromElement get_FromElement();
    public virtual void set_FromElement(FromElement value);
    public bool get_IsResolved();
    public void set_IsResolved(bool value);
    public sealed virtual string GetDisplayText();
    public abstract virtual void Resolve(bool generateJoin, bool implicitJoin, string classAlias, IASTNode parent);
    public sealed virtual void Resolve(bool generateJoin, bool implicitJoin, string classAlias);
    public sealed virtual void Resolve(bool generateJoin, bool implicitJoin);
    public virtual void ResolveInFunctionCall(bool generateJoin, bool implicitJoin);
    public abstract virtual void ResolveIndex(IASTNode parent);
    public virtual string get_Path();
    public void RecursiveResolve(int level, bool impliedAtRoot, string classAlias, IASTNode parent);
    public virtual FromElement GetImpliedJoin();
    public virtual void PrepareForDot(string propertyName);
    public virtual void ResolveFirstChild();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerNode : SqlNode {
    private HqlSqlWalker _walker;
    public HqlSqlWalker Walker { get; protected set; }
    internal SessionFactoryHelperExtensions SessionFactoryHelper { get; }
    public IASTFactory ASTFactory { get; }
    public AliasGenerator AliasGenerator { get; }
    public HqlSqlWalkerNode(IToken token);
    public virtual void Initialize(object param);
    public sealed virtual HqlSqlWalker get_Walker();
    protected void set_Walker(HqlSqlWalker value);
    internal SessionFactoryHelperExtensions get_SessionFactoryHelper();
    public IASTFactory get_ASTFactory();
    public AliasGenerator get_AliasGenerator();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerTreeAdaptor : ASTTreeAdaptor {
    private HqlSqlWalker _walker;
    public HqlSqlWalkerTreeAdaptor(object walker);
    public virtual object Create(IToken payload);
    public virtual object ErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
    public virtual object DupNode(object t);
    private void Initialise(object node);
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Tree.IASTFactory {
    public abstract virtual IASTNode CreateNode(int type, string text, IASTNode[] children);
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Tree.IASTNode {
    public bool IsNil { get; }
    public int Type { get; public set; }
    public string Text { get; public set; }
    public int Line { get; }
    public int CharPositionInLine { get; }
    public int ChildCount { get; }
    public int ChildIndex { get; }
    public IASTNode Parent { get; public set; }
    public IASTNode NextSibling { get; }
    public IToken Token { get; }
    public abstract virtual bool get_IsNil();
    public abstract virtual int get_Type();
    public abstract virtual void set_Type(int value);
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    public abstract virtual int get_Line();
    public abstract virtual int get_CharPositionInLine();
    public abstract virtual int get_ChildCount();
    public abstract virtual int get_ChildIndex();
    public abstract virtual IASTNode get_Parent();
    public abstract virtual void set_Parent(IASTNode value);
    public abstract virtual IASTNode get_NextSibling();
    public abstract virtual IASTNode GetChild(int index);
    public abstract virtual IASTNode GetFirstChild();
    public abstract virtual void SetFirstChild(IASTNode newChild);
    public abstract virtual void SetChild(int index, IASTNode newChild);
    public abstract virtual IASTNode AddChild(IASTNode childNode);
    public abstract virtual IASTNode InsertChild(int index, IASTNode child);
    public abstract virtual IASTNode AddSibling(IASTNode newSibling);
    public abstract virtual void ClearChildren();
    public abstract virtual void RemoveChild(IASTNode child);
    public abstract virtual void AddChildren(IEnumerable`1<IASTNode> children);
    public abstract virtual void AddChildren(IASTNode[] children);
    public abstract virtual IASTNode DupNode();
    public abstract virtual IToken get_Token();
    public abstract virtual string ToStringTree();
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Tree.IBinaryOperatorNode {
    public IASTNode LeftHandOperand { get; }
    public IASTNode RightHandOperand { get; }
    public abstract virtual IASTNode get_LeftHandOperand();
    public abstract virtual IASTNode get_RightHandOperand();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.IdentNode : FromReferenceNode {
    private static int Unknown;
    private static int PropertyRef;
    private static int ComponentRef;
    private bool _nakedPropertyRef;
    public IType DataType { get; public set; }
    public IdentNode(IToken token);
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public virtual void ResolveIndex(IASTNode parent);
    public virtual void Resolve(bool generateJoin, bool implicitJoin, string classAlias, IASTNode parent);
    private int ResolveAsNakedPropertyRef();
    private bool ResolveAsNakedComponentPropertyRefLhs(DotNode parent);
    private bool ResolveAsNakedComponentPropertyRefRhs(DotNode parent);
    private IType GetNakedPropertyType(FromElement fromElement);
    private FromElement LocateSingleFromElement();
    private bool ResolveAsAlias();
}
public interface NHibernate.Hql.Ast.ANTLR.Tree.IDisplayableNode {
    public abstract virtual string GetDisplayText();
}
public interface NHibernate.Hql.Ast.ANTLR.Tree.IExpectedTypeAwareNode {
    public IType ExpectedType { get; public set; }
    public abstract virtual IType get_ExpectedType();
    public abstract virtual void set_ExpectedType(IType value);
}
public interface NHibernate.Hql.Ast.ANTLR.Tree.IInitializableNode {
    public abstract virtual void Initialize(object param);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ImpliedFromElement : FromElement {
    private bool _impliedInFromClause;
    private bool _inProjectionList;
    public bool IsImplied { get; }
    public bool IsImpliedInFromClause { get; }
    public bool IncludeSubclasses { get; public set; }
    public bool InProjectionList { get; public set; }
    public ImpliedFromElement(IToken token);
    public virtual bool get_IsImplied();
    public virtual bool get_IsImpliedInFromClause();
    public virtual void SetImpliedInFromClause(bool flag);
    public virtual bool get_IncludeSubclasses();
    public virtual void set_IncludeSubclasses(bool value);
    public virtual bool get_InProjectionList();
    public virtual void set_InProjectionList(bool value);
    public virtual string GetDisplayText();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.IndexNode : FromReferenceNode {
    private static INHibernateLogger Log;
    public IndexNode(IToken token);
    private static IndexNode();
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public virtual void ResolveIndex(IASTNode parent);
    public virtual void Resolve(bool generateJoin, bool implicitJoin, string classAlias, IASTNode parent);
    public virtual void PrepareForDot(string propertyName);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.InLogicOperatorNode : BinaryLogicOperatorNode {
    private IASTNode InList { get; }
    public InLogicOperatorNode(IToken token);
    private IASTNode get_InList();
    public virtual void Initialize();
    private static bool IsNodeAcceptable(IASTNode rhsNode);
    private void MutateRowValueConstructorSyntaxInInListSyntax(IASTNode lhsNode, int lhsColumnSpan, IASTNode rhsNode, int rhsColumnSpan);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement : AbstractStatement {
    public bool NeedsExecutor { get; }
    public int StatementType { get; }
    public IntoClause IntoClause { get; }
    public SelectClause SelectClause { get; }
    public InsertStatement(IToken token);
    public virtual bool get_NeedsExecutor();
    public virtual int get_StatementType();
    public IntoClause get_IntoClause();
    public SelectClause get_SelectClause();
    public virtual void Validate();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.IntoClause : HqlSqlWalkerNode {
    private IQueryable _persister;
    private string _columnSpec;
    private IType[] _types;
    private bool _discriminated;
    private bool _explicitIdInsertion;
    private bool _explicitVersionInsertion;
    private string TableName { get; }
    public IQueryable Queryable { get; }
    private string EntityName { get; }
    public bool IsDiscriminated { get; }
    public bool IsExplicitIdInsertion { get; }
    public bool IsExplicitVersionInsertion { get; }
    public IntoClause(IToken token);
    public void Initialize(IQueryable persister);
    private void ResetText();
    private string get_TableName();
    public IQueryable get_Queryable();
    private string get_EntityName();
    public bool get_IsDiscriminated();
    public bool get_IsExplicitIdInsertion();
    public bool get_IsExplicitVersionInsertion();
    public void PrependIdColumnSpec();
    public void PrependVersionColumnSpec();
    public void ValidateTypes(SelectClause selectClause);
    public sealed virtual string GetDisplayText();
    private void InitializeColumns();
    private void VisitPropertySpecNodes(IASTNode propertyNode, ICollection`1<IType> types);
    private void RenderColumns(String[] columnNames);
    private bool IsSuperclassProperty(string propertyName);
    private bool AreCompatible(IType target, IType source);
    private static bool AreSqlTypesCompatible(SqlType target, SqlType source);
}
public interface NHibernate.Hql.Ast.ANTLR.Tree.IOperatorNode {
    public IType DataType { get; }
    public abstract virtual void Initialize();
    public abstract virtual IType get_DataType();
}
public interface NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer {
    unknown string Text {public set; }
    public bool HasEmbeddedParameters { get; }
    public abstract virtual void set_Text(string value);
    public abstract virtual void AddEmbeddedParameter(IParameterSpecification specification);
    public abstract virtual bool get_HasEmbeddedParameters();
    public abstract virtual IParameterSpecification[] GetEmbeddedParameters();
}
public interface NHibernate.Hql.Ast.ANTLR.Tree.IPathNode {
    public string Path { get; }
    public abstract virtual string get_Path();
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode {
    public abstract virtual void Resolve(bool generateJoin, bool implicitJoin, string classAlias, IASTNode parent);
    public abstract virtual void Resolve(bool generateJoin, bool implicitJoin, string classAlias);
    public abstract virtual void Resolve(bool generateJoin, bool implicitJoin);
    public abstract virtual void ResolveInFunctionCall(bool generateJoin, bool implicitJoin);
    public abstract virtual void ResolveIndex(IASTNode parent);
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement {
    public FromClause FromClause { get; }
    public bool HasWhereClause { get; }
    public IASTNode WhereClause { get; }
    public abstract virtual FromClause get_FromClause();
    public abstract virtual bool get_HasWhereClause();
    public abstract virtual IASTNode get_WhereClause();
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression {
    public IType DataType { get; }
    public int ScalarColumnIndex { get; }
    public FromElement FromElement { get; }
    public bool IsConstructor { get; }
    public bool IsReturnableEntity { get; }
    unknown string Text {public set; }
    public bool IsScalar { get; }
    public string Alias { get; public set; }
    public abstract virtual IType get_DataType();
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public abstract virtual void SetScalarColumnText(int i);
    [ObsoleteAttribute("Use SetScalarColumn extension method with aliasCreator parameter instead.")]
public abstract virtual void SetScalarColumn(int i);
    public abstract virtual int get_ScalarColumnIndex();
    public abstract virtual FromElement get_FromElement();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsReturnableEntity();
    public abstract virtual void set_Text(string value);
    public abstract virtual bool get_IsScalar();
    public abstract virtual string get_Alias();
    public abstract virtual void set_Alias(string value);
}
internal interface NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpressionExtension {
    public abstract virtual String[] SetScalarColumn(int i, Func`3<int, int, string> aliasCreator);
}
public interface NHibernate.Hql.Ast.ANTLR.Tree.ISessionFactoryAwareNode {
    unknown ISessionFactoryImplementor SessionFactory {public set; }
    public abstract virtual void set_SessionFactory(ISessionFactoryImplementor value);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.IsNotNullLogicOperatorNode : AbstractNullnessCheckNode {
    protected int ExpansionConnectorType { get; }
    protected string ExpansionConnectorText { get; }
    public IsNotNullLogicOperatorNode(IToken token);
    protected virtual int get_ExpansionConnectorType();
    protected virtual string get_ExpansionConnectorText();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.IsNullLogicOperatorNode : AbstractNullnessCheckNode {
    protected int ExpansionConnectorType { get; }
    protected string ExpansionConnectorText { get; }
    public IsNullLogicOperatorNode(IToken token);
    protected virtual int get_ExpansionConnectorType();
    protected virtual string get_ExpansionConnectorText();
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Tree.IStatement {
    public HqlSqlWalker Walker { get; }
    public int StatementType { get; }
    public bool NeedsExecutor { get; }
    public abstract virtual HqlSqlWalker get_Walker();
    public abstract virtual int get_StatementType();
    public abstract virtual bool get_NeedsExecutor();
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Tree.IUnaryOperatorNode {
    public IASTNode Operand { get; }
    public abstract virtual IASTNode get_Operand();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.JavaConstantNode : SqlNode {
    private ISessionFactoryImplementor _factory;
    private object _constantValue;
    private IType _heuristicType;
    private IType _expectedType;
    private bool _processedText;
    public IType ExpectedType { get; public set; }
    unknown ISessionFactoryImplementor SessionFactory {public set; }
    public JavaConstantNode(IToken token);
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public sealed virtual void set_SessionFactory(ISessionFactoryImplementor value);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
    private SqlString ResolveToLiteralString(IType type);
    internal static SqlString ResolveToLiteralString(IType type, object constantValue, Dialect dialect);
    private void ProcessText();
}
internal class NHibernate.Hql.Ast.ANTLR.Tree.JoinSubqueryFromElement : FromElement {
    [CompilerGeneratedAttribute]
private QueryNode <QueryNode>k__BackingField;
    [CompilerGeneratedAttribute]
private SubqueryPropertyMapping <PropertyMapping>k__BackingField;
    public IType SelectType { get; }
    public QueryNode QueryNode { get; }
    public SubqueryPropertyMapping PropertyMapping { get; }
    public JoinSubqueryFromElement(FromClause fromClause, QueryNode queryNode, JoinType joinType, string alias);
    private IType CreateDataType(SelectClause selectClause, IEntityPersister& entityPersister);
    public virtual IType get_SelectType();
    [CompilerGeneratedAttribute]
public QueryNode get_QueryNode();
    [CompilerGeneratedAttribute]
public SubqueryPropertyMapping get_PropertyMapping();
    public SqlString RenderText(SqlString subQuery, ISessionFactoryImplementor sessionFactory);
    internal List`1<ISelectExpression> GetRelatedSelectExpressions(DotNode dotNode, SelectClause& selectClause);
    internal virtual String[] GetIdentityColumns(string alias);
}
internal class NHibernate.Hql.Ast.ANTLR.Tree.JoinSubqueryJoinSequenceImpl : JoinSequence {
    private string _tableAlias;
    private JoinType _joinType;
    public JoinSubqueryJoinSequenceImpl(ISessionFactoryImplementor factory, string tableAlias, JoinType joinType);
    internal virtual JoinFragment ToJoinFragment(IDictionary`2<string, IFilter> enabledFilters, bool includeAllSubclassJoins, bool renderSubclassJoins, SqlString withClauseFragment);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.LiteralNode : AbstractSelectExpression {
    public IType DataType { get; public set; }
    public LiteralNode(IToken token);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.MethodNode : AbstractSelectExpression {
    private static INHibernateLogger Log;
    private String[] _selectColumns;
    private string _methodName;
    private bool _inSelect;
    private FromElement _fromElement;
    private ISQLFunction _function;
    public bool IsCollectionPropertyMethod { get; }
    public ISQLFunction SQLFunction { get; }
    public FromElement FromElement { get; public set; }
    public bool IsScalar { get; }
    public MethodNode(IToken token);
    private static MethodNode();
    public virtual void Resolve(bool inSelect);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public void InitializeMethodNode(IASTNode name, bool inSelect);
    public bool get_IsCollectionPropertyMethod();
    public ISQLFunction get_SQLFunction();
    public virtual FromElement get_FromElement();
    public virtual void set_FromElement(FromElement value);
    public virtual bool get_IsScalar();
    public void ResolveCollectionProperty(IASTNode expr);
    public sealed virtual string GetDisplayText();
    protected virtual void PrepareSelectColumns(String[] columns);
    private void CollectionProperty(IASTNode path, IASTNode name);
    private static void PrepareAnyImplicitJoins(DotNode dotNode);
    private void HandleElements(FromReferenceNode collectionNode, string propertyName);
    private void DialectFunction(IASTNode exprList);
    public virtual SqlString Render(IList args);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.OrderByClause : HqlSqlWalkerNode {
    public OrderByClause(IToken token);
    public void AddOrderFragment(string orderByFragment);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ParameterNode : HqlSqlWalkerNode {
    private string _alias;
    private IParameterSpecification _parameterSpecification;
    private int _scalarColumnIndex;
    [CompilerGeneratedAttribute]
private IType <GuessedType>k__BackingField;
    public IParameterSpecification HqlParameterSpecification { get; public set; }
    public IType ExpectedType { get; public set; }
    internal IType GuessedType { get; internal set; }
    public FromElement FromElement { get; }
    public bool IsConstructor { get; }
    public bool IsReturnableEntity { get; }
    public bool IsScalar { get; }
    public string Alias { get; public set; }
    public int ScalarColumnIndex { get; }
    public ParameterNode(IToken token);
    public IParameterSpecification get_HqlParameterSpecification();
    public void set_HqlParameterSpecification(IParameterSpecification value);
    public sealed virtual string GetDisplayText();
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    [CompilerGeneratedAttribute]
internal IType get_GuessedType();
    [CompilerGeneratedAttribute]
internal void set_GuessedType(IType value);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public sealed virtual void SetScalarColumnText(int i);
    public sealed virtual FromElement get_FromElement();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsReturnableEntity();
    public sealed virtual bool get_IsScalar();
    public sealed virtual string get_Alias();
    public sealed virtual void set_Alias(string value);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public sealed virtual void SetScalarColumn(int i);
    public sealed virtual String[] SetScalarColumn(int i, Func`3<int, int, string> aliasCreator);
    public sealed virtual int get_ScalarColumnIndex();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.QueryNode : AbstractRestrictableStatement {
    private static INHibernateLogger Log;
    private OrderByClause _orderByClause;
    private int _scalarColumn;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public bool NeedsExecutor { get; }
    public int StatementType { get; }
    public IType DataType { get; public set; }
    public FromElement FromElement { get; }
    public bool IsConstructor { get; }
    public bool IsReturnableEntity { get; }
    public bool IsScalar { get; }
    public string Alias { get; public set; }
    public int ScalarColumnIndex { get; }
    public QueryNode(IToken token);
    private static QueryNode();
    protected virtual INHibernateLogger GetLog();
    protected virtual int GetWhereClauseParentTokenType();
    public virtual bool get_NeedsExecutor();
    public virtual int get_StatementType();
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public sealed virtual void SetScalarColumnText(int i);
    public sealed virtual FromElement get_FromElement();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsReturnableEntity();
    public sealed virtual bool get_IsScalar();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Alias();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Alias(string value);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public sealed virtual void SetScalarColumn(int i);
    public sealed virtual String[] SetScalarColumn(int i, Func`3<int, int, string> aliasCreator);
    public sealed virtual int get_ScalarColumnIndex();
    public OrderByClause GetOrderByClause();
    public SelectClause GetSelectClause();
    private OrderByClause LocateOrderByClause();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.ResultVariableRefNode : HqlSqlWalkerNode {
    private ISelectExpression _selectExpression;
    public ResultVariableRefNode(IToken token);
    public void SetSelectExpression(ISelectExpression selectExpression);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
    private SqlString GetColumnPositionsString(int scalarColumnIndex);
    private SqlString GetColumnNamesString(int scalarColumnIndex);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.SelectClause : SelectExpressionList {
    private static string JoinFetchWithoutOwnerExceptionMsg;
    private bool _prepared;
    private bool _scalarSelect;
    private List`1<FromElement> _collectionFromElements;
    private IType[] _queryReturnTypes;
    private String[][] _columnNames;
    private List`1<FromElement> _fromElementsForLoad;
    private Dictionary`2<int, int> _entityByResultTypeDic;
    private ConstructorNode _constructorNode;
    private String[] _aliases;
    private Int32[] _columnNamesStartPositions;
    private HashSet`1<ISelectExpression> _derivedSelectExpressions;
    private Dictionary`2<ISelectExpression, List`1<int>> _replacedExpressions;
    internal List`1<ISelectExpression> SelectExpressions;
    internal List`1<ISelectExpression> OriginalSelectExpressions;
    internal List`1<ISelectExpression> NonScalarExpressions;
    public static bool VERSION2_SQL;
    public IList`1<FromElement> FromElementsForLoad { get; }
    internal IReadOnlyDictionary`2<int, int> EntityByResultTypeDic { get; }
    public bool IsScalarSelect { get; }
    public bool IsDistinct { get; }
    public String[][] ColumnNames { get; }
    public ConstructorInfo Constructor { get; }
    public bool IsMap { get; }
    public bool IsList { get; }
    public String[] QueryReturnAliases { get; }
    public IList`1<FromElement> CollectionFromElements { get; }
    public IType[] QueryReturnTypes { get; }
    public SelectClause(IToken token);
    public void InitializeDerivedSelectClause(FromClause fromClause);
    public void InitializeExplicitSelectClause(FromClause fromClause);
    private bool TryProcessSubqueryExpressions(ISelectExpression selectExpression, JoinSubqueryFromElement joinSubquery, SelectClause& selectClause, List`1& subqueryExpressions);
    private void Render(FromClause fromClause, Dictionary`2<ISelectExpression, SelectClause> inheritedExpressions);
    private List`1<FromElement> GetFetchedFromElements(FromClause fromClause);
    private void AddExpression(ISelectExpression expr, List`1<IType> queryReturnTypeList);
    private void AddEntityToProjection(int resultIndex, ISelectExpression se);
    private static FromElement GetOrigin(FromElement fromElement);
    public IList`1<FromElement> get_FromElementsForLoad();
    internal IReadOnlyDictionary`2<int, int> get_EntityByResultTypeDic();
    public bool get_IsScalarSelect();
    public bool get_IsDistinct();
    public String[][] get_ColumnNames();
    public ConstructorInfo get_Constructor();
    public bool get_IsMap();
    public bool get_IsList();
    public String[] get_QueryReturnAliases();
    public IList`1<FromElement> get_CollectionFromElements();
    public IType[] get_QueryReturnTypes();
    protected internal virtual IASTNode GetFirstSelectExpression();
    private static bool IsReturnableEntity(ISelectExpression selectExpression);
    private void InitAliases(List`1<ISelectExpression> selectExpressions);
    private void RenderNonScalarSelects(FromClause currentFromClause, Dictionary`2<ISelectExpression, SelectClause> inheritedExpressions, IList`1<FromElement> fetchedFromElements);
    private void RenderNonScalarIdentifiers(ASTAppender appender, HashSet`1<FromElement> processedElements, List`1<FromElement> combinedFromElements, Dictionary`2<ISelectExpression, SelectClause> inheritedExpressions);
    private void RenderFetchedNonScalarIdentifiers(ASTAppender appender, IList`1<FromElement> fetchedFromElements, HashSet`1<FromElement> processedElements, List`1<FromElement> combinedFromElements);
    private IASTNode Append(ASTAppender appender, int type, SelectFragment fragment);
    private void RenderNonScalarIdentifiers(FromElement fromElement, ISelectExpression expr, ASTAppender appender);
    private void RenderNonScalarProperties(ASTAppender appender, FromElement fromElement);
    internal List`1<ISelectExpression> GetReplacedExpressions(ISelectExpression expression);
    internal String[] GetScalarColumns(ISelectExpression expression);
    private void RenderScalarSelects(FromClause currentFromClause, Dictionary`2<ISelectExpression, SelectClause> inheritedExpressions);
    private void AddCollectionFromElement(FromElement fromElement);
    private void FinishInitialization();
    private void InitializeScalarColumnNames();
    public int GetColumnNamesStartPosition(int i);
    private static void RemoveChildAndUnsetParent(IASTNode node);
    [CompilerGeneratedAttribute]
private ISelectExpression <GetReplacedExpressions>b__57_0(int o);
}
[ExtensionAttribute]
public static class NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionExtensions : object {
    [ExtensionAttribute]
public static String[] SetScalarColumn(ISelectExpression selectExpression, int i, Func`3<int, int, string> aliasCreator);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionImpl : FromReferenceNode {
    public SelectExpressionImpl(IToken token);
    public virtual void ResolveIndex(IASTNode parent);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public virtual void Resolve(bool generateJoin, bool implicitJoin, string classAlias, IASTNode parent);
}
[CLSCompliantAttribute("False")]
public abstract class NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList : HqlSqlWalkerNode {
    protected SelectExpressionList(IToken token);
    [ObsoleteAttribute("Use GetSelectExpressions method instead.")]
public ISelectExpression[] CollectSelectExpressions();
    [ObsoleteAttribute("Use GetSelectExpressions method instead.")]
public ISelectExpression[] CollectSelectExpressions(bool recurse);
    public List`1<ISelectExpression> GetSelectExpressions();
    public List`1<ISelectExpression> GetSelectExpressions(bool recurse, Predicate`1<ISelectExpression> predicate);
    protected internal abstract virtual IASTNode GetFirstSelectExpression();
    [CompilerGeneratedAttribute]
internal static void <GetSelectExpressions>g__AddExpression|4_0(IASTNode n, <>c__DisplayClass4_0& );
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.SqlFragment : SqlNode {
    private JoinFragment _joinFragment;
    private FromElement _fromElement;
    private List`1<IParameterSpecification> _embeddedParameters;
    public bool HasFilterCondition { get; }
    public FromElement FromElement { get; public set; }
    public bool HasEmbeddedParameters { get; }
    public SqlFragment(IToken token);
    public void SetJoinFragment(JoinFragment joinFragment);
    public bool get_HasFilterCondition();
    public FromElement get_FromElement();
    public void set_FromElement(FromElement value);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
    public sealed virtual void AddEmbeddedParameter(IParameterSpecification specification);
    public sealed virtual bool get_HasEmbeddedParameters();
    public sealed virtual IParameterSpecification[] GetEmbeddedParameters();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.SqlNode : ASTNode {
    private string _originalText;
    private IType _dataType;
    public string Text { get; public set; }
    public string OriginalText { get; }
    public IType DataType { get; public set; }
    public SqlNode(IToken token);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual SqlString RenderText(ISessionFactoryImplementor sessionFactory);
    public string get_OriginalText();
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
}
internal class NHibernate.Hql.Ast.ANTLR.Tree.TransparentCastNode : MethodNode {
    private IType _expectedType;
    public static string Name;
    public IType ExpectedType { get; public set; }
    public TransparentCastNode(IToken token);
    public static bool IsTransparentCast(IASTNode node);
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public virtual SqlString Render(IList args);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.UnaryArithmeticNode : AbstractSelectExpression {
    public IType DataType { get; public set; }
    public IASTNode Operand { get; }
    public UnaryArithmeticNode(IToken token);
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public virtual void SetScalarColumnText(int i);
    public virtual String[] SetScalarColumnText(int i, Func`3<int, int, string> aliasCreator);
    public sealed virtual void Initialize();
    public sealed virtual IASTNode get_Operand();
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.UnaryLogicOperatorNode : HqlSqlWalkerNode {
    public IASTNode Operand { get; }
    public IType DataType { get; public set; }
    public UnaryLogicOperatorNode(IToken token);
    public sealed virtual IASTNode get_Operand();
    public virtual void Initialize();
    public virtual IType get_DataType();
    public virtual void set_DataType(IType value);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Tree.UpdateStatement : AbstractRestrictableStatement {
    private static INHibernateLogger Log;
    public bool NeedsExecutor { get; }
    public int StatementType { get; }
    public IASTNode SetClause { get; }
    public UpdateStatement(IToken token);
    private static UpdateStatement();
    public virtual bool get_NeedsExecutor();
    public virtual int get_StatementType();
    public IASTNode get_SetClause();
    protected virtual INHibernateLogger GetLog();
    protected virtual int GetWhereClauseParentTokenType();
}
public class NHibernate.Hql.Ast.ANTLR.Util.AliasGenerator : object {
    private int next;
    private int nextCount();
    public string CreateName(string name);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.ASTAppender : object {
    private IASTFactory factory;
    private IASTNode parent;
    public ASTAppender(IASTFactory factory, IASTNode parent);
    public IASTNode Append(int type, string text, bool appendIfEmpty);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.ASTIterator : object {
    private Stack`1<IASTNode> _stack;
    private IASTNode _current;
    public ASTIterator(IASTNode tree);
    [IteratorStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.Util.ASTIterator/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<IASTNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void Down();
}
internal class NHibernate.Hql.Ast.ANTLR.Util.ASTPrinter : object {
    public string ShowAsString(IASTNode ast, string header);
}
[CLSCompliantAttribute("False")]
public static class NHibernate.Hql.Ast.ANTLR.Util.ASTUtil : object {
    public static void MakeSiblingOfParent(IASTNode parent, IASTNode child);
    public static string GetPathText(IASTNode n);
    private static void GetPathText(StringBuilder buf, IASTNode n);
    public static string GetDebugstring(IASTNode n);
    public static bool IsSubtreeChild(IASTNode fixture, IASTNode test);
    public static IASTNode FindTypeInChildren(IASTNode parent, int type);
    [ObsoleteAttribute("Use generic version instead")]
public static IList`1<IASTNode> CollectChildren(IASTNode root, FilterPredicate predicate);
    public static IList`1<TNode> CollectChildren(IASTNode root, FilterPredicate predicate);
    [IteratorStateMachineAttribute("NHibernate.Hql.Ast.ANTLR.Util.ASTUtil/<IterateChildrenOfType>d__8`1")]
internal static IEnumerable`1<TRequiredType> IterateChildrenOfType(IASTNode root, Func`2<TRequiredType, bool> skipSearchInChildrenWhen);
}
[ObsoleteAttribute("Use generic version instead")]
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.CollectingNodeVisitor : CollectingNodeVisitor`1<IASTNode> {
    public CollectingNodeVisitor(FilterPredicate predicate);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.CollectingNodeVisitor`1 : object {
    private List`1<TNode> collectedNodes;
    private FilterPredicate predicate;
    public CollectingNodeVisitor`1(FilterPredicate predicate);
    public sealed virtual void Visit(IASTNode node);
    public IList`1<TNode> Collect(IASTNode root);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.ColumnHelper : object {
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public static void GenerateSingleScalarColumn(IASTFactory factory, IASTNode node, int i);
    public static string GenerateSingleScalarColumn(IASTFactory factory, IASTNode node, int i, Func`3<int, int, string> aliasCreator);
    [ObsoleteAttribute("Use overload with aliasCreator parameter instead.")]
public static void GenerateScalarColumns(IASTFactory factory, IASTNode node, String[] sqlColumns, int i);
    public static String[] GenerateScalarColumns(IASTFactory factory, IASTNode node, String[] sqlColumns, int i, Func`3<int, int, string> aliasCreator);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.FilterPredicate : MulticastDelegate {
    public FilterPredicate(object object, IntPtr method);
    public virtual bool Invoke(IASTNode node);
    public virtual IAsyncResult BeginInvoke(IASTNode node, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[CLSCompliantAttribute("False")]
public interface NHibernate.Hql.Ast.ANTLR.Util.IVisitationStrategy {
    public abstract virtual void Visit(IASTNode node);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.JoinProcessor : object {
    private static INHibernateLogger log;
    private HqlSqlWalker _walker;
    private SyntheticAndFactory _syntheticAndFactory;
    public JoinProcessor(HqlSqlWalker walker);
    private static JoinProcessor();
    public static JoinType ToHibernateJoinType(int astJoinType);
    [ObsoleteAttribute("Use ProcessJoins taking an IRestrictableStatement instead")]
public void ProcessJoins(QueryNode query);
    public void ProcessJoins(IRestrictableStatement query);
    private void AddJoinNodes(IRestrictableStatement query, JoinSequence join, FromElement fromElement);
    private static SqlString ProcessFromFragment(SqlString frag);
    public static void ProcessDynamicFilterParameters(SqlString sqlFragment, IParameterContainer container, HqlSqlWalker walker);
    private static void ProcessDynamicFilterParameters(SqlString sqlFragment, IParameterContainer container, HqlSqlWalker walker, bool fromFragment);
    private static bool HasDynamicFilterParam(SqlString sqlFragment);
    private static bool HasCollectionFilterParam(SqlString sqlFragment);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.LiteralProcessor : object {
    public static string ErrorCannotFetchWithIterate;
    public static string ErrorNamedParameterDoesNotAppear;
    public static string ErrorCannotDetermineType;
    public static string ErrorCannotFormatLiteral;
    private static INHibernateLogger log;
    private HqlSqlWalker _walker;
    private static IDecimalFormatter[] _formatters;
    public static int EXACT;
    public static int APPROXIMATE;
    public static int DECIMAL_LITERAL_FORMAT;
    public LiteralProcessor(HqlSqlWalker walker);
    private static LiteralProcessor();
    public void LookupConstant(DotNode node);
    public void ProcessNumericLiteral(SqlNode literal);
    private bool IsAlias(string alias);
    public void ProcessBoolean(IASTNode constant);
    public void ProcessConstant(SqlNode constant, bool resolveIdent);
    private static string DetermineDecimalRepresentation(string text, int type);
    private static string GetLiteralValue(string text, int type);
    private static string DetermineIntegerRepresentation(string text, int type);
    private void ProcessLiteral(SqlNode constant);
    private static void SetSQLValue(DotNode node, string text, string value);
    private void SetConstantValue(DotNode node, string text, object value);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.NodeTraverser : object {
    private IVisitationStrategy _visitor;
    public NodeTraverser(IVisitationStrategy visitor);
    public void TraverseDepthFirst(IASTNode ast);
    private void VisitDepthFirst(IASTNode ast);
}
[CLSCompliantAttribute("False")]
public static class NHibernate.Hql.Ast.ANTLR.Util.PathHelper : object {
    private static INHibernateLogger log;
    private static PathHelper();
    public static IASTNode ParsePath(string path, IASTFactory factory);
    public static string GetAlias(string path);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Hql.Ast.ANTLR.Util.SyntheticAndFactory : object {
    private static INHibernateLogger log;
    private HqlSqlWalker _hqlSqlWalker;
    private IASTNode _filters;
    private IASTNode _thetaJoins;
    public SyntheticAndFactory(HqlSqlWalker hqlSqlWalker);
    private static SyntheticAndFactory();
    [ObsoleteAttribute("Use AddWhereFragment taking an IRestrictableStatement instead")]
public void AddWhereFragment(JoinFragment joinFragment, SqlString whereFragment, QueryNode query, FromElement fromElement, HqlSqlWalker hqlSqlWalker);
    public void AddWhereFragment(JoinFragment joinFragment, SqlString whereFragment, IRestrictableStatement query, FromElement fromElement, HqlSqlWalker hqlSqlWalker);
    private IASTNode Create(int tokenType, string text);
    [ObsoleteAttribute("This method has no more usages")]
public virtual void AddDiscriminatorWhereFragment(IRestrictableStatement statement, IQueryable persister, IDictionary`2<string, IFilter> enabledFilters, string alias);
}
internal class NHibernate.Hql.Ast.ANTLR.WithClauseVisitor : object {
    private FromElement _joinFragment;
    [CompilerGeneratedAttribute]
private HashSet`1<FromElement> <FromElements>k__BackingField;
    internal HashSet`1<FromElement> FromElements { get; }
    public WithClauseVisitor(FromElement fromElement);
    [CompilerGeneratedAttribute]
internal HashSet`1<FromElement> get_FromElements();
    public sealed virtual void Visit(IASTNode node);
    private void ApplyParameterSpecifications(IParameterContainer parameterContainer);
    private void ApplyParameterSpecification(IParameterSpecification paramSpec);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public string GetJoinAlias();
}
public class NHibernate.Hql.Ast.HqlAdd : HqlExpression {
    public HqlAdd(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlAlias : HqlExpression {
    public HqlAlias(IASTFactory factory, string alias);
}
public class NHibernate.Hql.Ast.HqlAll : HqlBooleanExpression {
    public HqlAll(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlAny : HqlBooleanExpression {
    public HqlAny(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlAs : HqlExpression {
    public HqlAs(IASTFactory factory, HqlExpression expression, Type type);
}
public class NHibernate.Hql.Ast.HqlAverage : HqlExpression {
    public HqlAverage(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.Ast.HqlBitwiseAnd : HqlExpression {
    public HqlBitwiseAnd(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlBitwiseNot : HqlExpression {
    public HqlBitwiseNot(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlBitwiseOr : HqlExpression {
    public HqlBitwiseOr(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlBooleanAnd : HqlBooleanExpression {
    public HqlBooleanAnd(IASTFactory factory, HqlBooleanExpression lhs, HqlBooleanExpression rhs);
}
public class NHibernate.Hql.Ast.HqlBooleanDot : HqlBooleanExpression {
    public HqlBooleanDot(IASTFactory factory, HqlDot dot);
}
public abstract class NHibernate.Hql.Ast.HqlBooleanExpression : HqlExpression {
    protected HqlBooleanExpression(int type, string text, IASTFactory factory, IEnumerable`1<HqlTreeNode> children);
    protected HqlBooleanExpression(int type, string text, IASTFactory factory, HqlTreeNode[] children);
}
public class NHibernate.Hql.Ast.HqlBooleanMethodCall : HqlBooleanExpression {
    public HqlBooleanMethodCall(IASTFactory factory, string methodName, IEnumerable`1<HqlExpression> parameters);
}
public class NHibernate.Hql.Ast.HqlBooleanNot : HqlBooleanExpression {
    public HqlBooleanNot(IASTFactory factory, HqlBooleanExpression operand);
}
public class NHibernate.Hql.Ast.HqlBooleanOr : HqlBooleanExpression {
    public HqlBooleanOr(IASTFactory factory, HqlBooleanExpression lhs, HqlBooleanExpression rhs);
}
public class NHibernate.Hql.Ast.HqlCase : HqlExpression {
    public HqlCase(IASTFactory factory, HqlWhen[] whenClauses, HqlExpression ifFalse);
}
public class NHibernate.Hql.Ast.HqlCast : HqlExpression {
    public HqlCast(IASTFactory factory, HqlExpression expression, Type type);
}
public class NHibernate.Hql.Ast.HqlClass : HqlExpression {
    public HqlClass(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlCoalesce : HqlExpression {
    public HqlCoalesce(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlConcat : HqlExpression {
    public HqlConcat(IASTFactory factory, HqlExpression[] args);
}
public class NHibernate.Hql.Ast.HqlConstant : HqlExpression {
    public HqlConstant(IASTFactory factory, int type, string value);
}
public class NHibernate.Hql.Ast.HqlCount : HqlExpression {
    public HqlCount(IASTFactory factory);
    public HqlCount(IASTFactory factory, HqlExpression child);
}
public class NHibernate.Hql.Ast.HqlCountBig : HqlExpression {
    public HqlCountBig(IASTFactory factory);
    public HqlCountBig(IASTFactory factory, HqlExpression child);
}
public class NHibernate.Hql.Ast.HqlCross : HqlTreeNode {
    public HqlCross(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlCrossJoin : HqlTreeNode {
    public HqlCrossJoin(IASTFactory factory, HqlExpression expression, HqlAlias alias);
}
public class NHibernate.Hql.Ast.HqlDecimalConstant : HqlConstant {
    public HqlDecimalConstant(IASTFactory factory, string s);
}
public class NHibernate.Hql.Ast.HqlDelete : HqlStatement {
    internal HqlDelete(IASTFactory factory, HqlTreeNode[] children);
}
[ObsoleteAttribute("Please use HqlIndex instead")]
public class NHibernate.Hql.Ast.HqlDictionaryIndex : HqlIndex {
    public HqlDictionaryIndex(IASTFactory factory, HqlExpression dictionary, HqlExpression index);
}
public enum NHibernate.Hql.Ast.HqlDirection : Enum {
    public int value__;
    public static HqlDirection Ascending;
    public static HqlDirection Descending;
}
public class NHibernate.Hql.Ast.HqlDirectionAscending : HqlDirectionStatement {
    public HqlDirectionAscending(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlDirectionDescending : HqlDirectionStatement {
    public HqlDirectionDescending(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlDirectionStatement : HqlStatement {
    public HqlDirectionStatement(int type, string text, IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlDistinct : HqlStatement {
    public HqlDistinct(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlDivide : HqlExpression {
    public HqlDivide(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlDot : HqlExpression {
    public HqlDot(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlDoubleConstant : HqlConstant {
    public HqlDoubleConstant(IASTFactory factory, string s);
}
public class NHibernate.Hql.Ast.HqlElements : HqlBooleanExpression {
    public HqlElements(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlElse : HqlStatement {
    public HqlElse(IASTFactory factory, HqlExpression ifFalse);
}
public class NHibernate.Hql.Ast.HqlEquality : HqlBooleanExpression {
    public HqlEquality(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlEscape : HqlStatement {
    public HqlEscape(IASTFactory factory, HqlConstant escapeCharacter);
}
public class NHibernate.Hql.Ast.HqlExists : HqlBooleanExpression {
    public HqlExists(IASTFactory factory, HqlQuery query);
}
public abstract class NHibernate.Hql.Ast.HqlExpression : HqlTreeNode {
    protected HqlExpression(int type, string text, IASTFactory factory, IEnumerable`1<HqlTreeNode> children);
    protected HqlExpression(int type, string text, IASTFactory factory, HqlTreeNode[] children);
}
public class NHibernate.Hql.Ast.HqlExpressionList : HqlStatement {
    public HqlExpressionList(IASTFactory factory, HqlExpression[] expressions);
    public HqlExpressionList(IASTFactory factory, IEnumerable`1<HqlExpression> expressions);
}
public class NHibernate.Hql.Ast.HqlExpressionSubTreeHolder : HqlExpression {
    public HqlExpressionSubTreeHolder(IASTFactory factory, HqlTreeNode[] children);
    public HqlExpressionSubTreeHolder(IASTFactory factory, IEnumerable`1<HqlTreeNode> children);
}
public class NHibernate.Hql.Ast.HqlFalse : HqlConstant {
    public HqlFalse(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlFetch : HqlTreeNode {
    public HqlFetch(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlFetchJoin : HqlTreeNode {
    public HqlFetchJoin(IASTFactory factory, HqlExpression expression, HqlAlias alias);
}
public class NHibernate.Hql.Ast.HqlFloatConstant : HqlConstant {
    public HqlFloatConstant(IASTFactory factory, string s);
}
public class NHibernate.Hql.Ast.HqlFrom : HqlStatement {
    internal HqlFrom(IASTFactory factory, HqlTreeNode[] children);
}
public class NHibernate.Hql.Ast.HqlGreaterThan : HqlBooleanExpression {
    public HqlGreaterThan(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlGreaterThanOrEqual : HqlBooleanExpression {
    public HqlGreaterThanOrEqual(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlGroupBy : HqlStatement {
    public HqlGroupBy(IASTFactory factory, HqlExpression[] expressions);
}
public class NHibernate.Hql.Ast.HqlHaving : HqlStatement {
    public HqlHaving(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.Ast.HqlIdent : HqlExpression {
    private static Dictionary`2<TypeCode, string> SupportedIdentTypes;
    internal HqlIdent(IASTFactory factory, string ident);
    internal HqlIdent(IASTFactory factory, Type type);
    private static HqlIdent();
    internal static bool SupportsType(Type type);
    private static bool TryGetTypeName(Type type, String& typeName);
}
public class NHibernate.Hql.Ast.HqlIn : HqlBooleanExpression {
    public HqlIn(IASTFactory factory, HqlExpression itemExpression, HqlTreeNode source);
}
public class NHibernate.Hql.Ast.HqlIndex : HqlExpression {
    public HqlIndex(IASTFactory factory, HqlExpression collection, HqlExpression index);
}
public class NHibernate.Hql.Ast.HqlIndices : HqlExpression {
    public HqlIndices(IASTFactory factory, HqlExpression dictionary);
}
public class NHibernate.Hql.Ast.HqlInequality : HqlBooleanExpression {
    public HqlInequality(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlInList : HqlTreeNode {
    public HqlInList(IASTFactory factory, HqlTreeNode source);
}
public class NHibernate.Hql.Ast.HqlInner : HqlTreeNode {
    public HqlInner(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlInnerJoin : HqlTreeNode {
    public HqlInnerJoin(IASTFactory factory, HqlExpression expression, HqlAlias alias);
}
public class NHibernate.Hql.Ast.HqlInsert : HqlStatement {
    internal HqlInsert(IASTFactory factory, HqlTreeNode[] children);
}
public class NHibernate.Hql.Ast.HqlIntegerConstant : HqlConstant {
    public HqlIntegerConstant(IASTFactory factory, string s);
}
public class NHibernate.Hql.Ast.HqlInto : HqlStatement {
    public HqlInto(IASTFactory factory, HqlTreeNode[] children);
}
public class NHibernate.Hql.Ast.HqlIsNotNull : HqlBooleanExpression {
    public HqlIsNotNull(IASTFactory factory, HqlExpression lhs);
}
public class NHibernate.Hql.Ast.HqlIsNull : HqlBooleanExpression {
    public HqlIsNull(IASTFactory factory, HqlExpression lhs);
}
public class NHibernate.Hql.Ast.HqlJoin : HqlStatement {
    public HqlJoin(IASTFactory factory, HqlExpression expression, HqlAlias alias);
}
public class NHibernate.Hql.Ast.HqlLeft : HqlTreeNode {
    public HqlLeft(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlLeftFetchJoin : HqlTreeNode {
    public HqlLeftFetchJoin(IASTFactory factory, HqlExpression expression, HqlAlias alias);
}
public class NHibernate.Hql.Ast.HqlLeftJoin : HqlTreeNode {
    public HqlLeftJoin(IASTFactory factory, HqlExpression expression, HqlAlias alias);
}
public class NHibernate.Hql.Ast.HqlLessThan : HqlBooleanExpression {
    public HqlLessThan(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlLessThanOrEqual : HqlBooleanExpression {
    public HqlLessThanOrEqual(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlLike : HqlBooleanExpression {
    public HqlLike(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
    public HqlLike(IASTFactory factory, HqlExpression lhs, HqlExpression rhs, HqlConstant escapeCharacter);
}
public class NHibernate.Hql.Ast.HqlMax : HqlExpression {
    public HqlMax(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.Ast.HqlMethodCall : HqlExpression {
    public HqlMethodCall(IASTFactory factory, string methodName, IEnumerable`1<HqlExpression> parameters);
}
public class NHibernate.Hql.Ast.HqlMin : HqlExpression {
    public HqlMin(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.Ast.HqlMultiplty : HqlExpression {
    public HqlMultiplty(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlNegate : HqlExpression {
    public HqlNegate(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.Ast.HqlNull : HqlConstant {
    public HqlNull(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlOrderBy : HqlStatement {
    public HqlOrderBy(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlParameter : HqlExpression {
    public HqlParameter(IASTFactory factory, string name);
}
public class NHibernate.Hql.Ast.HqlQuery : HqlExpression {
    internal HqlQuery(IASTFactory factory, HqlStatement[] children);
}
public class NHibernate.Hql.Ast.HqlRange : HqlStatement {
    internal HqlRange(IASTFactory factory, HqlTreeNode[] children);
}
public class NHibernate.Hql.Ast.HqlRowStar : HqlStatement {
    public HqlRowStar(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlSelect : HqlStatement {
    public HqlSelect(IASTFactory factory, HqlExpression[] expression);
}
public class NHibernate.Hql.Ast.HqlSelectFrom : HqlStatement {
    internal HqlSelectFrom(IASTFactory factory, HqlTreeNode[] children);
}
public class NHibernate.Hql.Ast.HqlSet : HqlStatement {
    public HqlSet(IASTFactory factory);
    public HqlSet(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.Ast.HqlSkip : HqlStatement {
    public HqlSkip(IASTFactory factory, HqlExpression parameter);
}
public class NHibernate.Hql.Ast.HqlStar : HqlExpression {
    public HqlStar(IASTFactory factory);
}
public abstract class NHibernate.Hql.Ast.HqlStatement : HqlTreeNode {
    protected HqlStatement(int type, string text, IASTFactory factory, HqlTreeNode[] children);
    protected HqlStatement(int type, string text, IASTFactory factory, IEnumerable`1<HqlTreeNode> children);
}
public class NHibernate.Hql.Ast.HqlStringConstant : HqlConstant {
    public HqlStringConstant(IASTFactory factory, string s);
}
public class NHibernate.Hql.Ast.HqlSubtract : HqlExpression {
    public HqlSubtract(IASTFactory factory, HqlExpression lhs, HqlExpression rhs);
}
public class NHibernate.Hql.Ast.HqlSum : HqlExpression {
    public HqlSum(IASTFactory factory);
    public HqlSum(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.Ast.HqlTake : HqlStatement {
    public HqlTake(IASTFactory factory, HqlExpression parameter);
}
public class NHibernate.Hql.Ast.HqlTransparentCast : HqlExpression {
    public HqlTransparentCast(IASTFactory factory, HqlExpression expression, Type type);
}
public class NHibernate.Hql.Ast.HqlTreeBuilder : object {
    private IASTFactory _factory;
    public HqlQuery Query();
    public HqlQuery Query(HqlSelectFrom selectFrom);
    public HqlQuery Query(HqlSelectFrom selectFrom, HqlWhere where);
    public HqlTreeNode Query(HqlSelectFrom selectFrom, HqlWhere where, HqlOrderBy orderBy);
    public HqlDelete Delete(HqlFrom from);
    public HqlUpdate Update(HqlFrom from, HqlSet set);
    public HqlUpdate Update(HqlVersioned versioned, HqlFrom from, HqlSet set);
    public HqlInsert Insert(HqlInto into, HqlQuery query);
    public HqlSelectFrom SelectFrom();
    public HqlSelectFrom SelectFrom(HqlSelect select);
    public HqlSelectFrom SelectFrom(HqlFrom from, HqlSelect select);
    public HqlSelectFrom SelectFrom(HqlFrom from);
    public HqlFrom From(HqlRange range, HqlJoin[] joins);
    public HqlFrom From(HqlRange range, IEnumerable`1<HqlJoin> joins);
    public HqlFrom From(HqlRange range);
    public HqlFrom From();
    public HqlRange Range(HqlIdent[] idents);
    public HqlRange Range(HqlTreeNode ident, HqlAlias alias);
    public HqlIdent Ident(string ident);
    public HqlIdent Ident(Type type);
    public HqlAlias Alias(string alias);
    public HqlEquality Equality(HqlExpression lhs, HqlExpression rhs);
    public HqlBooleanAnd BooleanAnd(HqlBooleanExpression lhs, HqlBooleanExpression rhs);
    public HqlBooleanOr BooleanOr(HqlBooleanExpression lhs, HqlBooleanExpression rhs);
    public HqlAdd Add(HqlExpression lhs, HqlExpression rhs);
    public HqlSubtract Subtract(HqlExpression lhs, HqlExpression rhs);
    public HqlMultiplty Multiply(HqlExpression lhs, HqlExpression rhs);
    public HqlDivide Divide(HqlExpression lhs, HqlExpression rhs);
    public HqlNegate Negate(HqlExpression expression);
    public HqlDot Dot(HqlExpression lhs, HqlExpression rhs);
    public HqlParameter Parameter(string name);
    public HqlWhere Where(HqlExpression expression);
    public HqlWith With(HqlExpression expression);
    public HqlHaving Having(HqlExpression expression);
    public HqlConstant Constant(object value);
    public HqlOrderBy OrderBy();
    public HqlSkip Skip(HqlExpression parameter);
    public HqlTake Take(HqlExpression parameter);
    public HqlSelect Select(HqlExpression expression);
    public HqlSelect Select(HqlExpression[] expression);
    public HqlSelect Select(IEnumerable`1<HqlExpression> expressions);
    public HqlCase Case(HqlWhen[] whenClauses);
    public HqlCase Case(HqlWhen[] whenClauses, HqlExpression ifFalse);
    public HqlWhen When(HqlExpression predicate, HqlExpression ifTrue);
    public HqlElse Else(HqlExpression ifFalse);
    public HqlInequality Inequality(HqlExpression lhs, HqlExpression rhs);
    public HqlLessThan LessThan(HqlExpression lhs, HqlExpression rhs);
    public HqlLessThanOrEqual LessThanOrEqual(HqlExpression lhs, HqlExpression rhs);
    public HqlGreaterThan GreaterThan(HqlExpression lhs, HqlExpression rhs);
    public HqlGreaterThanOrEqual GreaterThanOrEqual(HqlExpression lhs, HqlExpression rhs);
    public HqlCount Count();
    public HqlCount Count(HqlExpression child);
    public HqlCountBig CountBig(HqlExpression child);
    public HqlRowStar RowStar();
    public HqlCast Cast(HqlExpression expression, Type type);
    public HqlTransparentCast TransparentCast(HqlExpression expression, Type type);
    public HqlBitwiseNot BitwiseNot();
    public HqlBooleanNot BooleanNot(HqlBooleanExpression operand);
    public HqlAverage Average(HqlExpression expression);
    public HqlSum Sum(HqlExpression expression);
    public HqlMin Min(HqlExpression expression);
    public HqlMax Max(HqlExpression expression);
    public HqlJoin Join(HqlExpression expression, HqlAlias alias);
    public HqlAny Any();
    public HqlExists Exists(HqlQuery query);
    public HqlElements Elements();
    public HqlDistinct Distinct();
    public HqlDirectionAscending Ascending();
    public HqlDirectionDescending Descending();
    public HqlGroupBy GroupBy(HqlExpression[] expressions);
    public HqlAll All();
    public HqlLike Like(HqlExpression lhs, HqlExpression rhs);
    public HqlLike Like(HqlExpression lhs, HqlExpression rhs, HqlConstant escapeCharacter);
    public HqlConcat Concat(HqlExpression[] args);
    public HqlMethodCall MethodCall(string methodName, IEnumerable`1<HqlExpression> parameters);
    public HqlMethodCall MethodCall(string methodName, HqlExpression[] parameters);
    public HqlBooleanMethodCall BooleanMethodCall(string methodName, IEnumerable`1<HqlExpression> parameters);
    public HqlExpressionSubTreeHolder ExpressionSubTreeHolder(HqlTreeNode[] children);
    public HqlExpressionSubTreeHolder ExpressionSubTreeHolder(IEnumerable`1<HqlTreeNode> children);
    public HqlIsNull IsNull(HqlExpression lhs);
    public HqlIsNotNull IsNotNull(HqlExpression lhs);
    public HqlTreeNode ExpressionList(IEnumerable`1<HqlExpression> expressions);
    public HqlStar Star();
    public HqlTrue True();
    public HqlFalse False();
    public HqlIn In(HqlExpression itemExpression, HqlTreeNode source);
    public HqlInnerJoin InnerJoin(HqlExpression expression, HqlAlias alias);
    public HqlLeftJoin LeftJoin(HqlExpression expression, HqlAlias alias);
    public HqlCrossJoin CrossJoin(HqlExpression expression, HqlAlias alias);
    public HqlFetchJoin FetchJoin(HqlExpression expression, HqlAlias alias);
    public HqlLeftFetchJoin LeftFetchJoin(HqlExpression expression, HqlAlias alias);
    public HqlFetch Fetch();
    public HqlClass Class();
    public HqlBitwiseAnd BitwiseAnd(HqlExpression lhs, HqlExpression rhs);
    public HqlBitwiseOr BitwiseOr(HqlExpression lhs, HqlExpression rhs);
    public HqlTreeNode Coalesce(HqlExpression lhs, HqlExpression rhs);
    [ObsoleteAttribute("Please use Index method instead.")]
public HqlTreeNode DictionaryItem(HqlExpression dictionary, HqlExpression index);
    public HqlTreeNode Index(HqlExpression collection, HqlExpression index);
    public HqlTreeNode Indices(HqlExpression dictionary);
    public HqlSet Set();
    public HqlSet Set(HqlExpression expression);
    public HqlVersioned Versioned();
    public HqlInto Into();
}
public class NHibernate.Hql.Ast.HqlTreeNode : object {
    [CompilerGeneratedAttribute]
private IASTFactory <Factory>k__BackingField;
    private IASTNode _node;
    private List`1<HqlTreeNode> _children;
    public IASTFactory Factory { get; private set; }
    public IEnumerable`1<HqlTreeNode> NodesPreOrder { get; }
    public IEnumerable`1<HqlTreeNode> NodesPostOrder { get; }
    public IEnumerable`1<HqlTreeNode> Children { get; }
    internal IASTNode AstNode { get; }
    protected HqlTreeNode(int type, string text, IASTFactory factory, IEnumerable`1<HqlTreeNode> children);
    protected HqlTreeNode(int type, string text, IASTFactory factory, HqlTreeNode[] children);
    [CompilerGeneratedAttribute]
public IASTFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(IASTFactory value);
    private void AddChildren(IEnumerable`1<HqlTreeNode> children);
    [IteratorStateMachineAttribute("NHibernate.Hql.Ast.HqlTreeNode/<get_NodesPreOrder>d__10")]
public IEnumerable`1<HqlTreeNode> get_NodesPreOrder();
    [IteratorStateMachineAttribute("NHibernate.Hql.Ast.HqlTreeNode/<get_NodesPostOrder>d__12")]
public IEnumerable`1<HqlTreeNode> get_NodesPostOrder();
    public IEnumerable`1<HqlTreeNode> get_Children();
    public void ClearChildren();
    protected void SetText(string text);
    internal IASTNode get_AstNode();
    internal void AddChild(HqlTreeNode child);
}
[ExtensionAttribute]
public static class NHibernate.Hql.Ast.HqlTreeNodeExtensions : object {
    [ExtensionAttribute]
public static HqlExpression AsExpression(HqlTreeNode node);
    [ExtensionAttribute]
[ObsoleteAttribute]
public static HqlBooleanExpression AsBooleanExpression(HqlTreeNode node);
    [ExtensionAttribute]
public static HqlBooleanExpression ToBooleanExpression(HqlTreeNode node);
    [ExtensionAttribute]
internal static HqlExpression ToArithmeticExpression(HqlTreeNode node);
}
public class NHibernate.Hql.Ast.HqlTrue : HqlConstant {
    public HqlTrue(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlUpdate : HqlStatement {
    internal HqlUpdate(IASTFactory factory, HqlTreeNode[] children);
}
public class NHibernate.Hql.Ast.HqlVersioned : HqlExpression {
    public HqlVersioned(IASTFactory factory);
}
public class NHibernate.Hql.Ast.HqlWhen : HqlStatement {
    public HqlWhen(IASTFactory factory, HqlExpression predicate, HqlExpression ifTrue);
}
public class NHibernate.Hql.Ast.HqlWhere : HqlStatement {
    public HqlWhere(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.Ast.HqlWith : HqlStatement {
    public HqlWith(IASTFactory factory, HqlExpression expression);
}
public class NHibernate.Hql.CollectionSubqueryFactory : object {
    public static string CreateCollectionSubquery(JoinSequence joinSequence, IDictionary`2<string, IFilter> enabledFilters, String[] columns);
}
[ObsoleteAttribute("This class has no more usages and will be removed in a future version.")]
public class NHibernate.Hql.HolderInstantiator : object {
    public static HolderInstantiator NoopInstantiator;
    private IResultTransformer transformer;
    private String[] queryReturnAliases;
    public bool IsRequired { get; }
    public String[] QueryReturnAliases { get; }
    public IResultTransformer ResultTransformer { get; }
    public HolderInstantiator(IResultTransformer transformer, String[] queryReturnAliases);
    private static HolderInstantiator();
    public static HolderInstantiator GetHolderInstantiator(IResultTransformer selectNewTransformer, IResultTransformer customTransformer, String[] queryReturnAliases);
    public static IResultTransformer ResolveResultTransformer(IResultTransformer selectNewTransformer, IResultTransformer customTransformer);
    public static IResultTransformer CreateSelectNewTransformer(ConstructorInfo constructor, bool returnMaps, bool returnLists);
    public static HolderInstantiator CreateClassicHolderInstantiator(ConstructorInfo constructor, IResultTransformer transformer);
    public static IResultTransformer ResolveClassicResultTransformer(ConstructorInfo constructor, IResultTransformer transformer);
    public bool get_IsRequired();
    public object Instantiate(Object[] row);
    public String[] get_QueryReturnAliases();
    public IResultTransformer get_ResultTransformer();
}
public interface NHibernate.Hql.IFilterTranslator {
    public abstract virtual void Compile(string collectionRole, IDictionary`2<string, string> replacements, bool shallow);
}
public interface NHibernate.Hql.IQueryTranslator {
    public ISet`1<string> QuerySpaces { get; }
    public string SQLString { get; }
    public IList`1<string> CollectSqlStrings { get; }
    public string QueryString { get; }
    public IDictionary`2<string, IFilter> EnabledFilters { get; }
    public IType[] ReturnTypes { get; }
    public String[] ReturnAliases { get; }
    public bool ContainsCollectionFetches { get; }
    public bool IsManipulationStatement { get; }
    [ObsoleteAttribute("Use GetQueryLoader extension method instead.")]
public Loader Loader { get; }
    public IType[] ActualReturnTypes { get; }
    public abstract virtual Task`1<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> GetEnumerableAsync(QueryParameters queryParameters, IEventSource session, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> ExecuteUpdateAsync(QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual void Compile(IDictionary`2<string, string> replacements, bool shallow);
    public abstract virtual IList List(ISessionImplementor session, QueryParameters queryParameters);
    public abstract virtual IEnumerable GetEnumerable(QueryParameters queryParameters, IEventSource session);
    public abstract virtual int ExecuteUpdate(QueryParameters queryParameters, ISessionImplementor session);
    public abstract virtual ISet`1<string> get_QuerySpaces();
    public abstract virtual string get_SQLString();
    public abstract virtual IList`1<string> get_CollectSqlStrings();
    public abstract virtual string get_QueryString();
    public abstract virtual IDictionary`2<string, IFilter> get_EnabledFilters();
    public abstract virtual IType[] get_ReturnTypes();
    public abstract virtual String[] get_ReturnAliases();
    public abstract virtual String[][] GetColumnNames();
    public abstract virtual bool get_ContainsCollectionFetches();
    public abstract virtual bool get_IsManipulationStatement();
    public abstract virtual Loader get_Loader();
    public abstract virtual IType[] get_ActualReturnTypes();
    public abstract virtual ParameterMetadata BuildParameterMetadata();
}
public interface NHibernate.Hql.IQueryTranslatorFactory {
    public abstract virtual IQueryTranslator[] CreateQueryTranslators(IQueryExpression queryExpression, string collectionRole, bool shallow, IDictionary`2<string, IFilter> filters, ISessionFactoryImplementor factory);
}
public interface NHibernate.Hql.IQueryTranslatorWithCustomizableLoader {
    public ILoader QueryLoader { get; }
    public abstract virtual ILoader get_QueryLoader();
}
public class NHibernate.Hql.NameGenerator : object {
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public static String[][] GenerateColumnNames(IType[] types, ISessionFactoryImplementor f);
    public static string ScalarName(int x, int y);
}
public static class NHibernate.Hql.ParserHelper : object {
    public static string HqlVariablePrefix;
    public static string HqlSeparators;
    internal static Char[] HqlSeparatorsAsCharArray;
    public static string Whitespace;
    public static string EntityClass;
    private static ParserHelper();
    public static bool IsWhitespace(string str);
    internal static bool HasHqlVariable(string value);
    internal static bool HasHqlVariable(SqlString value);
    internal static bool IsHqlVariable(string value);
}
public class NHibernate.Hql.QueryExecutionRequestException : QueryException {
    public QueryExecutionRequestException(string message, string queryString);
    protected QueryExecutionRequestException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.Hql.QuerySplitter : object {
    private static INHibernateLogger log;
    private static HashSet`1<string> beforeClassTokens;
    private static HashSet`1<string> notAfterClassTokens;
    private static QuerySplitter();
    public static String[] ConcreteQueries(string query, ISessionFactoryImplementor factory);
}
[ExtensionAttribute]
public static class NHibernate.Hql.QueryTranslatorExtensions : object {
    private static INHibernateLogger Log;
    private static bool _hasWarnedForObsoleteQueryTranslator;
    private static QueryTranslatorExtensions();
    [ExtensionAttribute]
public static ILoader GetQueryLoader(IQueryTranslator queryTranslator);
}
public class NHibernate.Hql.StringQueryExpression : object {
    private string _queryString;
    [CompilerGeneratedAttribute]
private IList`1<NamedParameterDescriptor> <ParameterDescriptors>k__BackingField;
    public string Key { get; }
    public Type Type { get; }
    public IList`1<NamedParameterDescriptor> ParameterDescriptors { get; private set; }
    public StringQueryExpression(string queryString);
    public sealed virtual IASTNode Translate(ISessionFactoryImplementor factory, bool filter);
    public sealed virtual string get_Key();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<NamedParameterDescriptor> get_ParameterDescriptors();
    [CompilerGeneratedAttribute]
private void set_ParameterDescriptors(IList`1<NamedParameterDescriptor> value);
}
[ExtensionAttribute]
internal static class NHibernate.Hql.StringQueryExpressionExtensions : object {
    [ExtensionAttribute]
public static StringQueryExpression ToQueryExpression(string queryString);
}
public class NHibernate.Hql.Util.SessionFactoryHelper : object {
    private ISessionFactoryImplementor sfi;
    private Dictionary`2<string, CollectionPropertyMapping> collectionPropertyMappingByRole;
    public SessionFactoryHelper(ISessionFactoryImplementor sfi);
    public IQueryable FindQueryableUsingImports(string className);
    public IEntityPersister FindEntityPersisterUsingImports(string className);
    private static string GetEntityName(string assemblyQualifiedName);
    public IQueryableCollection GetCollectionPersister(string role);
    public IEntityPersister RequireClassPersister(string name);
    private IEntityPersister FindEntityPersisterByName(string name);
    public Type GetImportedClass(string className);
    public IPropertyMapping GetCollectionPropertyMapping(string role);
    public IQueryableCollection RequireQueryableCollection(string role);
}
internal interface NHibernate.ICacheableQueryExpression {
    public bool CanCachePlan { get; }
    public abstract virtual bool get_CanCachePlan();
}
public interface NHibernate.ICriteria {
    public string Alias { get; }
    public bool IsReadOnlyInitialized { get; }
    public bool IsReadOnly { get; }
    public abstract virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<object> UniqueResultAsync(CancellationToken cancellationToken);
    public abstract virtual Task ListAsync(IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> UniqueResultAsync(CancellationToken cancellationToken);
    public abstract virtual string get_Alias();
    public abstract virtual bool get_IsReadOnlyInitialized();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual ICriteria SetProjection(IProjection[] projection);
    public abstract virtual ICriteria Add(ICriterion expression);
    public abstract virtual ICriteria AddOrder(Order order);
    [ObsoleteAttribute("Use Fetch instead")]
public abstract virtual ICriteria SetFetchMode(string associationPath, FetchMode mode);
    public abstract virtual ICriteria SetLockMode(LockMode lockMode);
    public abstract virtual ICriteria SetLockMode(string alias, LockMode lockMode);
    public abstract virtual ICriteria CreateAlias(string associationPath, string alias);
    public abstract virtual ICriteria CreateAlias(string associationPath, string alias, JoinType joinType);
    public abstract virtual ICriteria CreateAlias(string associationPath, string alias, JoinType joinType, ICriterion withClause);
    public abstract virtual ICriteria CreateCriteria(string associationPath);
    public abstract virtual ICriteria CreateCriteria(string associationPath, JoinType joinType);
    public abstract virtual ICriteria CreateCriteria(string associationPath, string alias);
    public abstract virtual ICriteria CreateCriteria(string associationPath, string alias, JoinType joinType);
    public abstract virtual ICriteria CreateCriteria(string associationPath, string alias, JoinType joinType, ICriterion withClause);
    public abstract virtual ICriteria SetResultTransformer(IResultTransformer resultTransformer);
    public abstract virtual ICriteria SetMaxResults(int maxResults);
    public abstract virtual ICriteria SetFirstResult(int firstResult);
    public abstract virtual ICriteria SetFetchSize(int fetchSize);
    public abstract virtual ICriteria SetTimeout(int timeout);
    public abstract virtual ICriteria SetCacheable(bool cacheable);
    public abstract virtual ICriteria SetCacheRegion(string cacheRegion);
    public abstract virtual ICriteria SetComment(string comment);
    public abstract virtual ICriteria SetFlushMode(FlushMode flushMode);
    public abstract virtual ICriteria SetCacheMode(CacheMode cacheMode);
    public abstract virtual IList List();
    public abstract virtual object UniqueResult();
    public abstract virtual IFutureEnumerable`1<T> Future();
    public abstract virtual IFutureValue`1<T> FutureValue();
    public abstract virtual ICriteria SetReadOnly(bool readOnly);
    public abstract virtual void List(IList results);
    public abstract virtual IList`1<T> List();
    public abstract virtual T UniqueResult();
    public abstract virtual void ClearOrders();
    public abstract virtual ICriteria GetCriteriaByPath(string path);
    public abstract virtual ICriteria GetCriteriaByAlias(string alias);
    public abstract virtual Type GetRootEntityTypeIfAvailable();
}
public abstract class NHibernate.Id.AbstractPostInsertGenerator : object {
    public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor s, object obj, CancellationToken cancellationToken);
    public sealed virtual object Generate(ISessionImplementor s, object obj);
    public abstract virtual IInsertGeneratedIdentifierDelegate GetInsertGeneratedIdentifierDelegate(IPostInsertIdentityPersister persister, ISessionFactoryImplementor factory, bool isGetGeneratedKeysEnabled);
}
public class NHibernate.Id.Assigned : object {
    private string entityName;
    public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public sealed virtual object Generate(ISessionImplementor session, object obj);
    public sealed virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
}
public class NHibernate.Id.CounterGenerator : object {
    private static short counter;
    protected short Count { get; }
    public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor cache, object obj, CancellationToken cancellationToken);
    protected short get_Count();
    public sealed virtual object Generate(ISessionImplementor cache, object obj);
}
public interface NHibernate.Id.Enhanced.IAccessCallback {
    public abstract virtual Task`1<long> GetNextValueAsync(CancellationToken cancellationToken);
    public abstract virtual long GetNextValue();
}
public interface NHibernate.Id.Enhanced.IDatabaseStructure {
    public string Name { get; }
    public int TimesAccessed { get; }
    public int IncrementSize { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_TimesAccessed();
    public abstract virtual int get_IncrementSize();
    public abstract virtual IAccessCallback BuildCallback(ISessionImplementor session);
    public abstract virtual void Prepare(IOptimizer optimizer);
    public abstract virtual String[] SqlCreateStrings(Dialect dialect);
    public abstract virtual String[] SqlDropStrings(Dialect dialect);
}
public interface NHibernate.Id.Enhanced.IOptimizer {
    public long LastSourceValue { get; }
    public int IncrementSize { get; }
    public bool ApplyIncrementSizeToSourceValues { get; }
    public abstract virtual Task`1<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken);
    public abstract virtual long get_LastSourceValue();
    public abstract virtual int get_IncrementSize();
    public abstract virtual object Generate(IAccessCallback callback);
    public abstract virtual bool get_ApplyIncrementSizeToSourceValues();
}
public class NHibernate.Id.Enhanced.OptimizerFactory : object {
    private static INHibernateLogger Log;
    public static string None;
    public static string HiLo;
    public static string Pool;
    public static string PoolLo;
    private static Type[] CtorSignature;
    private static OptimizerFactory();
    private static IOptimizer BuildOptimizer(string type, Type returnClass, int incrementSize);
    public static IOptimizer BuildOptimizer(string type, Type returnClass, int incrementSize, long explicitInitialValue);
}
public class NHibernate.Id.Enhanced.SequenceStructure : object {
    private static INHibernateLogger Log;
    private int _incrementSize;
    private int _initialValue;
    private string _sequenceName;
    private SqlString _sql;
    private int _accessCounter;
    private bool _applyIncrementSizeToSourceValues;
    public string Name { get; }
    public int IncrementSize { get; }
    public int TimesAccessed { get; }
    public SequenceStructure(Dialect dialect, string sequenceName, int initialValue, int incrementSize);
    private static SequenceStructure();
    public sealed virtual string get_Name();
    public sealed virtual int get_IncrementSize();
    public sealed virtual IAccessCallback BuildCallback(ISessionImplementor session);
    public sealed virtual void Prepare(IOptimizer optimizer);
    public sealed virtual String[] SqlCreateStrings(Dialect dialect);
    public sealed virtual String[] SqlDropStrings(Dialect dialect);
    public sealed virtual int get_TimesAccessed();
}
public class NHibernate.Id.Enhanced.SequenceStyleGenerator : object {
    private static INHibernateLogger Log;
    public static string DefaultSequenceName;
    public static int DefaultInitialValue;
    public static int DefaultIncrementSize;
    public static string SequenceParam;
    public static string InitialParam;
    public static string IncrementParam;
    public static string OptimizerParam;
    public static string ForceTableParam;
    public static string ValueColumnParam;
    public static string DefaultValueColumnName;
    [CompilerGeneratedAttribute]
private IDatabaseStructure <DatabaseStructure>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptimizer <Optimizer>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <IdentifierType>k__BackingField;
    public IDatabaseStructure DatabaseStructure { get; private set; }
    public IOptimizer Optimizer { get; private set; }
    public IType IdentifierType { get; private set; }
    private static SequenceStyleGenerator();
    public virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IDatabaseStructure get_DatabaseStructure();
    [CompilerGeneratedAttribute]
private void set_DatabaseStructure(IDatabaseStructure value);
    [CompilerGeneratedAttribute]
public IOptimizer get_Optimizer();
    [CompilerGeneratedAttribute]
private void set_Optimizer(IOptimizer value);
    [CompilerGeneratedAttribute]
public IType get_IdentifierType();
    [CompilerGeneratedAttribute]
private void set_IdentifierType(IType value);
    public virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
    protected string DetermineSequenceName(IDictionary`2<string, string> parms, Dialect dialect);
    protected string DetermineValueColumnName(IDictionary`2<string, string> parms, Dialect dialect);
    protected int DetermineInitialValue(IDictionary`2<string, string> parms);
    protected int DetermineIncrementSize(IDictionary`2<string, string> parms);
    protected string DetermineOptimizationStrategy(IDictionary`2<string, string> parms, int incrementSize);
    protected int DetermineAdjustedIncrementSize(string optimizationStrategy, int incrementSize);
    protected IDatabaseStructure BuildDatabaseStructure(IType type, IDictionary`2<string, string> parms, Dialect dialect, bool forceTableUse, string sequenceName, int initialValue, int incrementSize);
    protected bool RequiresPooledSequence(int initialValue, int incrementSize, IOptimizer optimizer);
    public virtual object Generate(ISessionImplementor session, object obj);
    public virtual string GeneratorKey();
    public virtual String[] SqlCreateStrings(Dialect dialect);
    public virtual String[] SqlDropString(Dialect dialect);
}
public class NHibernate.Id.Enhanced.TableGenerator : TransactionHelper {
    private static INHibernateLogger log;
    public static string ConfigPreferSegmentPerEntity;
    public static string TableParam;
    public static string DefaultTable;
    public static string ValueColumnParam;
    public static string DefaultValueColumn;
    public static string SegmentColumnParam;
    public static string DefaultSegmentColumn;
    public static string SegmentValueParam;
    public static string DefaultSegmentValue;
    public static string SegmentLengthParam;
    public static int DefaultSegmentLength;
    public static string InitialParam;
    public static int DefaltInitialValue;
    public static string IncrementParam;
    public static int DefaultIncrementSize;
    public static string OptimizerParam;
    [CompilerGeneratedAttribute]
private IType <IdentifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SegmentColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SegmentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SegmentValueLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IncrementSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptimizer <Optimizer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TableAccessCount>k__BackingField;
    private SqlString selectQuery;
    private SqlType[] selectParameterTypes;
    private SqlString insertQuery;
    private SqlType[] insertParameterTypes;
    private SqlString updateQuery;
    private SqlType[] updateParameterTypes;
    private AsyncLock _asyncLock;
    public IType IdentifierType { get; private set; }
    public string TableName { get; private set; }
    public string SegmentColumnName { get; private set; }
    public string SegmentValue { get; private set; }
    public int SegmentValueLength { get; private set; }
    public string ValueColumnName { get; private set; }
    public int InitialValue { get; private set; }
    public int IncrementSize { get; private set; }
    public IOptimizer Optimizer { get; private set; }
    public long TableAccessCount { get; private set; }
    private static TableGenerator();
    [AsyncStateMachineAttribute("NHibernate.Id.Enhanced.TableGenerator/<GenerateAsync>d__0")]
public virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Id.Enhanced.TableGenerator/<DoWorkInCurrentTransactionAsync>d__2")]
public virtual Task`1<object> DoWorkInCurrentTransactionAsync(ISessionImplementor session, DbConnection conn, DbTransaction transaction, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IType get_IdentifierType();
    [CompilerGeneratedAttribute]
private void set_IdentifierType(IType value);
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
private void set_TableName(string value);
    [CompilerGeneratedAttribute]
public string get_SegmentColumnName();
    [CompilerGeneratedAttribute]
private void set_SegmentColumnName(string value);
    [CompilerGeneratedAttribute]
public string get_SegmentValue();
    [CompilerGeneratedAttribute]
private void set_SegmentValue(string value);
    [CompilerGeneratedAttribute]
public int get_SegmentValueLength();
    [CompilerGeneratedAttribute]
private void set_SegmentValueLength(int value);
    [CompilerGeneratedAttribute]
public string get_ValueColumnName();
    [CompilerGeneratedAttribute]
private void set_ValueColumnName(string value);
    [CompilerGeneratedAttribute]
public int get_InitialValue();
    [CompilerGeneratedAttribute]
private void set_InitialValue(int value);
    [CompilerGeneratedAttribute]
public int get_IncrementSize();
    [CompilerGeneratedAttribute]
private void set_IncrementSize(int value);
    [CompilerGeneratedAttribute]
public IOptimizer get_Optimizer();
    [CompilerGeneratedAttribute]
private void set_Optimizer(IOptimizer value);
    [CompilerGeneratedAttribute]
public long get_TableAccessCount();
    [CompilerGeneratedAttribute]
private void set_TableAccessCount(long value);
    public virtual string GeneratorKey();
    public virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
    protected string DetermineGeneratorTableName(IDictionary`2<string, string> parms, Dialect dialect);
    protected string DetermineSegmentColumnName(IDictionary`2<string, string> parms, Dialect dialect);
    protected string DetermineValueColumnName(IDictionary`2<string, string> parms, Dialect dialect);
    protected string DetermineSegmentValue(IDictionary`2<string, string> parms);
    protected string DetermineDefaultSegmentValue(IDictionary`2<string, string> parms);
    protected int DetermineSegmentColumnSize(IDictionary`2<string, string> parms);
    protected int DetermineInitialValue(IDictionary`2<string, string> parms);
    protected int DetermineIncrementSize(IDictionary`2<string, string> parms);
    protected void BuildSelectQuery(Dialect dialect);
    protected void BuildUpdateQuery();
    protected void BuildInsertQuery();
    public virtual object Generate(ISessionImplementor session, object obj);
    public virtual object DoWorkInCurrentTransaction(ISessionImplementor session, DbConnection conn, DbTransaction transaction);
    public virtual String[] SqlCreateStrings(Dialect dialect);
    public virtual String[] SqlDropString(Dialect dialect);
}
public class NHibernate.Id.Enhanced.TableStructure : TransactionHelper {
    private static INHibernateLogger Log;
    private int _incrementSize;
    private int _initialValue;
    private string _tableName;
    private string _valueColumnName;
    private SqlString _selectQuery;
    private SqlString _updateQuery;
    private SqlType[] _updateParameterTypes;
    private int _accessCounter;
    private bool _applyIncrementSizeToSourceValues;
    public string Name { get; }
    public int TimesAccessed { get; }
    public int IncrementSize { get; }
    public TableStructure(Dialect dialect, string tableName, string valueColumnName, int initialValue, int incrementSize);
    private static TableStructure();
    [AsyncStateMachineAttribute("NHibernate.Id.Enhanced.TableStructure/<DoWorkInCurrentTransactionAsync>d__0")]
public virtual Task`1<object> DoWorkInCurrentTransactionAsync(ISessionImplementor session, DbConnection conn, DbTransaction transaction, CancellationToken cancellationToken);
    public sealed virtual string get_Name();
    public sealed virtual int get_TimesAccessed();
    public sealed virtual int get_IncrementSize();
    public virtual IAccessCallback BuildCallback(ISessionImplementor session);
    public virtual void Prepare(IOptimizer optimizer);
    public virtual String[] SqlCreateStrings(Dialect dialect);
    public virtual String[] SqlDropStrings(Dialect dialect);
    public virtual object DoWorkInCurrentTransaction(ISessionImplementor session, DbConnection conn, DbTransaction transaction);
}
public class NHibernate.Id.ForeignGenerator : object {
    private string propertyName;
    private string entityName;
    [AsyncStateMachineAttribute("NHibernate.Id.ForeignGenerator/<GenerateAsync>d__0")]
public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor sessionImplementor, object obj, CancellationToken cancellationToken);
    public sealed virtual object Generate(ISessionImplementor sessionImplementor, object obj);
    private EntityType GetForeignValueSourceType(IEntityPersister persister);
    private static bool Contains(ISessionImplementor sessionImplementor, object obj);
    public sealed virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
}
public class NHibernate.Id.GuidCombGenerator : object {
    private static long BaseDateTicks;
    private static GuidCombGenerator();
    public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public sealed virtual object Generate(ISessionImplementor session, object obj);
    private Guid GenerateComb();
}
public class NHibernate.Id.GuidGenerator : object {
    public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public sealed virtual object Generate(ISessionImplementor session, object obj);
}
public interface NHibernate.Id.ICompositeKeyPostInsertIdentityPersister {
    public abstract virtual Task BindSelectByUniqueKeyAsync(ISessionImplementor session, DbCommand selectCommand, IBinder binder, String[] suppliedPropertyNames, CancellationToken cancellationToken);
    public abstract virtual SqlString GetSelectByUniqueKeyString(String[] suppliedPropertyNames, IType[]& parameterTypes);
    public abstract virtual void BindSelectByUniqueKey(ISessionImplementor session, DbCommand selectCommand, IBinder binder, String[] suppliedPropertyNames);
}
public interface NHibernate.Id.IConfigurable {
    public abstract virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
}
public class NHibernate.Id.IdentifierGenerationException : HibernateException {
    public IdentifierGenerationException(string message);
    public IdentifierGenerationException(string message, Exception e);
    protected IdentifierGenerationException(SerializationInfo info, StreamingContext context);
}
public static class NHibernate.Id.IdentifierGeneratorFactory : object {
    private static INHibernateLogger log;
    private static Dictionary`2<string, Type> idgenerators;
    public static object ShortCircuitIndicator;
    public static object PostInsertIndicator;
    private static IdentifierGeneratorFactory();
    [AsyncStateMachineAttribute("NHibernate.Id.IdentifierGeneratorFactory/<GetGeneratedIdentityAsync>d__0")]
public static Task`1<object> GetGeneratedIdentityAsync(DbDataReader rs, IType type, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Id.IdentifierGeneratorFactory/<GetAsync>d__1")]
public static Task`1<object> GetAsync(DbDataReader rs, IType type, ISessionImplementor session, CancellationToken cancellationToken);
    public static object GetGeneratedIdentity(DbDataReader rs, IType type, ISessionImplementor session);
    public static object Get(DbDataReader rs, IType type, ISessionImplementor session);
    public static IIdentifierGenerator Create(string strategy, IType type, IDictionary`2<string, string> parms, Dialect dialect);
    public static object CreateNumber(long value, Type type);
    public static Type GetIdentifierGeneratorClass(string strategy, Dialect dialect);
}
public class NHibernate.Id.IdentityGenerator : AbstractPostInsertGenerator {
    public virtual IInsertGeneratedIdentifierDelegate GetInsertGeneratedIdentifierDelegate(IPostInsertIdentityPersister persister, ISessionFactoryImplementor factory, bool isGetGeneratedKeysEnabled);
}
public class NHibernate.Id.IdGeneratorParmsNames : ValueType {
    public static string EntityName;
    private static IdGeneratorParmsNames();
}
public interface NHibernate.Id.IIdentifierGenerator {
    public abstract virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public abstract virtual object Generate(ISessionImplementor session, object obj);
}
public class NHibernate.Id.IncrementGenerator : object {
    private static INHibernateLogger Logger;
    private long _next;
    private SqlString _sql;
    private Type _returnClass;
    private AsyncLock _asyncLock;
    private static IncrementGenerator();
    [AsyncStateMachineAttribute("NHibernate.Id.IncrementGenerator/<GenerateAsync>d__0")]
public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Id.IncrementGenerator/<GetNextAsync>d__1")]
private Task GetNextAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
    public sealed virtual object Generate(ISessionImplementor session, object obj);
    private void GetNext(ISessionImplementor session);
}
public abstract class NHibernate.Id.Insert.AbstractReturningDelegate : object {
    private IPostInsertIdentityPersister persister;
    protected IPostInsertIdentityPersister Persister { get; }
    protected AbstractReturningDelegate(IPostInsertIdentityPersister persister);
    [AsyncStateMachineAttribute("NHibernate.Id.Insert.AbstractReturningDelegate/<PerformInsertAsync>d__0")]
public sealed virtual Task`1<object> PerformInsertAsync(SqlCommandInfo insertSQL, ISessionImplementor session, IBinder binder, CancellationToken cancellationToken);
    protected internal abstract virtual Task`1<DbCommand> PrepareAsync(SqlCommandInfo insertSQL, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ExecuteAndExtractAsync(DbCommand insert, ISessionImplementor session, CancellationToken cancellationToken);
    protected IPostInsertIdentityPersister get_Persister();
    public abstract virtual IdentifierGeneratingInsert PrepareIdentifierGeneratingInsert();
    public sealed virtual object PerformInsert(SqlCommandInfo insertSQL, ISessionImplementor session, IBinder binder);
    protected internal virtual void ReleaseStatement(DbCommand insert, ISessionImplementor session);
    protected internal abstract virtual DbCommand Prepare(SqlCommandInfo insertSQL, ISessionImplementor session);
    public abstract virtual object ExecuteAndExtract(DbCommand insert, ISessionImplementor session);
}
public abstract class NHibernate.Id.Insert.AbstractSelectingDelegate : object {
    private IPostInsertIdentityPersister persister;
    protected internal SqlString SelectSQL { get; }
    protected internal SqlType[] ParametersTypes { get; }
    protected internal AbstractSelectingDelegate(IPostInsertIdentityPersister persister);
    [AsyncStateMachineAttribute("NHibernate.Id.Insert.AbstractSelectingDelegate/<PerformInsertAsync>d__0")]
public sealed virtual Task`1<object> PerformInsertAsync(SqlCommandInfo insertSql, ISessionImplementor session, IBinder binder, CancellationToken cancellationToken);
    protected internal abstract virtual Task`1<object> GetResultAsync(ISessionImplementor session, DbDataReader rs, object entity, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use or override BindParameters(ISessionImplementor session, DbCommand ps, IBinder binder) instead.")]
protected internal virtual Task BindParametersAsync(ISessionImplementor session, DbCommand ps, object entity, CancellationToken cancellationToken);
    protected internal virtual Task BindParametersAsync(ISessionImplementor session, DbCommand ps, IBinder binder, CancellationToken cancellationToken);
    public abstract virtual IdentifierGeneratingInsert PrepareIdentifierGeneratingInsert();
    public sealed virtual object PerformInsert(SqlCommandInfo insertSql, ISessionImplementor session, IBinder binder);
    protected internal abstract virtual SqlString get_SelectSQL();
    protected internal abstract virtual object GetResult(ISessionImplementor session, DbDataReader rs, object entity);
    [ObsoleteAttribute("Use or override BindParameters(ISessionImplementor session, DbCommand ps, IBinder binder) instead.")]
protected internal virtual void BindParameters(ISessionImplementor session, DbCommand ps, object entity);
    protected internal virtual void BindParameters(ISessionImplementor session, DbCommand ps, IBinder binder);
    protected internal virtual SqlType[] get_ParametersTypes();
}
public interface NHibernate.Id.Insert.IBinder {
    public object Entity { get; }
    public abstract virtual Task BindValuesAsync(DbCommand cm, CancellationToken cancellationToken);
    public abstract virtual object get_Entity();
    public abstract virtual void BindValues(DbCommand cm);
}
public class NHibernate.Id.Insert.IdentifierGeneratingInsert : SqlInsertBuilder {
    public IdentifierGeneratingInsert(ISessionFactoryImplementor factory);
}
public interface NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate {
    public abstract virtual Task`1<object> PerformInsertAsync(SqlCommandInfo insertSQL, ISessionImplementor session, IBinder binder, CancellationToken cancellationToken);
    public abstract virtual IdentifierGeneratingInsert PrepareIdentifierGeneratingInsert();
    public abstract virtual object PerformInsert(SqlCommandInfo insertSQL, ISessionImplementor session, IBinder binder);
}
public class NHibernate.Id.Insert.InsertSelectIdentityInsert : IdentifierGeneratingInsert {
    private string _identifierColumnName;
    [ObsoleteAttribute("Please use constructor accepting identifierColumnName parameter.")]
public InsertSelectIdentityInsert(ISessionFactoryImplementor factory);
    public InsertSelectIdentityInsert(ISessionFactoryImplementor factory, string identifierColumnName);
    public virtual SqlString ToSqlString();
}
public class NHibernate.Id.Insert.NoCommentsInsert : IdentifierGeneratingInsert {
    public NoCommentsInsert(ISessionFactoryImplementor factory);
    public virtual SqlInsertBuilder SetComment(string comment);
}
public class NHibernate.Id.Insert.OutputParamReturningDelegate : AbstractReturningDelegate {
    private static string ReturnParameterName;
    private ISessionFactoryImplementor factory;
    private string idColumnName;
    private SqlType paramType;
    private string driveGeneratedParamName;
    public OutputParamReturningDelegate(IPostInsertIdentityPersister persister, ISessionFactoryImplementor factory);
    [AsyncStateMachineAttribute("NHibernate.Id.Insert.OutputParamReturningDelegate/<PrepareAsync>d__0")]
protected internal virtual Task`1<DbCommand> PrepareAsync(SqlCommandInfo insertSQL, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Id.Insert.OutputParamReturningDelegate/<ExecuteAndExtractAsync>d__1")]
public virtual Task`1<object> ExecuteAndExtractAsync(DbCommand insert, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual IdentifierGeneratingInsert PrepareIdentifierGeneratingInsert();
    protected internal virtual DbCommand Prepare(SqlCommandInfo insertSQL, ISessionImplementor session);
    public virtual object ExecuteAndExtract(DbCommand insert, ISessionImplementor session);
}
public class NHibernate.Id.Insert.ReturningIdentifierInsert : NoCommentsInsert {
    private string identifierColumnName;
    private string returnParameterName;
    public ReturningIdentifierInsert(ISessionFactoryImplementor factory, string identifierColumnName, string returnParameterName);
    public virtual SqlString ToSqlString();
}
public interface NHibernate.Id.IPersistentIdentifierGenerator {
    public abstract virtual String[] SqlCreateStrings(Dialect dialect);
    public abstract virtual String[] SqlDropString(Dialect dialect);
    public abstract virtual string GeneratorKey();
}
public interface NHibernate.Id.IPostInsertIdentifierGenerator {
    public abstract virtual IInsertGeneratedIdentifierDelegate GetInsertGeneratedIdentifierDelegate(IPostInsertIdentityPersister persister, ISessionFactoryImplementor factory, bool isGetGeneratedKeysEnabled);
}
public interface NHibernate.Id.IPostInsertIdentityPersister {
    public string IdentitySelectString { get; }
    public String[] RootTableKeyColumnNames { get; }
    public IType IdentifierType { get; }
    public abstract virtual string get_IdentitySelectString();
    public abstract virtual String[] get_RootTableKeyColumnNames();
    [ObsoleteAttribute("Have the persister implement ICompositeKeyPostInsertIdentityPersister and use its GetSelectByUniqueKeyString(string[] suppliedPropertyNames, out IType[] parameterTypes).")]
public abstract virtual SqlString GetSelectByUniqueKeyString(string propertyName);
    public abstract virtual IType get_IdentifierType();
    public abstract virtual string GetInfoString();
}
public class NHibernate.Id.NativeGuidGenerator : object {
    private static INHibernateLogger log;
    private IType identifierType;
    private static NativeGuidGenerator();
    [AsyncStateMachineAttribute("NHibernate.Id.NativeGuidGenerator/<GenerateAsync>d__0")]
public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public sealed virtual object Generate(ISessionImplementor session, object obj);
}
public class NHibernate.Id.PersistentIdGeneratorParmsNames : ValueType {
    public static string Schema;
    public static string Table;
    public static string Tables;
    public static string PK;
    public static string Catalog;
    public static SqlStatementLogger SqlStatementLogger;
    private static PersistentIdGeneratorParmsNames();
}
[ExtensionAttribute]
internal static class NHibernate.Id.PostInsertIdentityPersisterExtension : object {
    [ExtensionAttribute]
public static SqlString GetSelectByUniqueKeyString(IPostInsertIdentityPersister persister, String[] suppliedPropertyNames, IType[]& parameterTypes);
    internal static String[] DetermineNameOfPropertiesToUse(IEntityPersister persister);
}
public class NHibernate.Id.SelectGenerator : AbstractPostInsertGenerator {
    private string uniqueKeyPropertyNames;
    public virtual IInsertGeneratedIdentifierDelegate GetInsertGeneratedIdentifierDelegate(IPostInsertIdentityPersister persister, ISessionFactoryImplementor factory, bool isGetGeneratedKeysEnabled);
    public sealed virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
}
public class NHibernate.Id.SequenceGenerator : object {
    private static INHibernateLogger log;
    public static string Sequence;
    public static string Parameters;
    private string sequenceName;
    private IType identifierType;
    private SqlString sql;
    private string parameters;
    public string SequenceName { get; }
    private static SequenceGenerator();
    [AsyncStateMachineAttribute("NHibernate.Id.SequenceGenerator/<GenerateAsync>d__0")]
public virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public string get_SequenceName();
    public virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
    public virtual object Generate(ISessionImplementor session, object obj);
    public sealed virtual String[] SqlCreateStrings(Dialect dialect);
    public sealed virtual String[] SqlDropString(Dialect dialect);
    public sealed virtual string GeneratorKey();
}
public class NHibernate.Id.SequenceHiLoGenerator : SequenceGenerator {
    private static INHibernateLogger log;
    public static string MaxLo;
    private int maxLo;
    private int lo;
    private long hi;
    private Type returnClass;
    private AsyncLock _asyncLock;
    private static SequenceHiLoGenerator();
    [AsyncStateMachineAttribute("NHibernate.Id.SequenceHiLoGenerator/<GenerateAsync>d__0")]
public virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
    public virtual object Generate(ISessionImplementor session, object obj);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<object> <>n__0(ISessionImplementor session, object obj, CancellationToken cancellationToken);
}
public class NHibernate.Id.SequenceIdentityGenerator : SequenceGenerator {
    public virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public virtual object Generate(ISessionImplementor session, object obj);
    public sealed virtual IInsertGeneratedIdentifierDelegate GetInsertGeneratedIdentifierDelegate(IPostInsertIdentityPersister persister, ISessionFactoryImplementor factory, bool isGetGeneratedKeysEnabled);
}
public class NHibernate.Id.TableGenerator : TransactionHelper {
    private static INHibernateLogger log;
    public static string Where;
    public static string ColumnParamName;
    public static string TableParamName;
    public static string DefaultColumnName;
    public static string DefaultTableName;
    private string tableName;
    private string columnName;
    private string whereClause;
    private string query;
    protected SqlType columnSqlType;
    protected PrimitiveType columnType;
    private SqlString updateSql;
    private SqlType[] parameterTypes;
    private AsyncLock _asyncLock;
    private static TableGenerator();
    [AsyncStateMachineAttribute("NHibernate.Id.TableGenerator/<GenerateAsync>d__0")]
public virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Id.TableGenerator/<DoWorkInCurrentTransactionAsync>d__1")]
public virtual Task`1<object> DoWorkInCurrentTransactionAsync(ISessionImplementor session, DbConnection conn, DbTransaction transaction, CancellationToken cancellationToken);
    public virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
    public virtual object Generate(ISessionImplementor session, object obj);
    public virtual String[] SqlCreateStrings(Dialect dialect);
    public virtual String[] SqlDropString(Dialect dialect);
    public sealed virtual string GeneratorKey();
    public virtual object DoWorkInCurrentTransaction(ISessionImplementor session, DbConnection conn, DbTransaction transaction);
}
public class NHibernate.Id.TableHiLoGenerator : TableGenerator {
    private static INHibernateLogger log;
    public static string MaxLo;
    private long hi;
    private long lo;
    private long maxLo;
    private Type returnClass;
    private AsyncLock _asyncLock;
    private static TableHiLoGenerator();
    [AsyncStateMachineAttribute("NHibernate.Id.TableHiLoGenerator/<GenerateAsync>d__0")]
public virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
    public virtual object Generate(ISessionImplementor session, object obj);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<object> <>n__0(ISessionImplementor session, object obj, CancellationToken cancellationToken);
}
public class NHibernate.Id.TriggerIdentityGenerator : AbstractPostInsertGenerator {
    public virtual IInsertGeneratedIdentifierDelegate GetInsertGeneratedIdentifierDelegate(IPostInsertIdentityPersister persister, ISessionFactoryImplementor factory, bool isGetGeneratedKeysEnabled);
}
public class NHibernate.Id.UUIDHexGenerator : object {
    protected string format;
    protected string sep;
    protected static string FormatWithDigitsOnly;
    public virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public virtual object Generate(ISessionImplementor session, object obj);
    public virtual void Configure(IType type, IDictionary`2<string, string> parms, Dialect dialect);
    protected virtual string GenerateNewGuid();
}
public class NHibernate.Id.UUIDStringGenerator : object {
    public sealed virtual Task`1<object> GenerateAsync(ISessionImplementor session, object obj, CancellationToken cancellationToken);
    public sealed virtual object Generate(ISessionImplementor session, object obj);
}
public interface NHibernate.IDatabinder {
    public bool InitializeLazy { get; public set; }
    public abstract virtual IDatabinder Bind(object obj);
    public abstract virtual IDatabinder BindAll(ICollection objs);
    public abstract virtual string ToGenericXml();
    public abstract virtual XmlDocument ToGenericXmlDocument();
    public abstract virtual string ToXML();
    public abstract virtual XmlDocument ToXmlDocument();
    public abstract virtual bool get_InitializeLazy();
    public abstract virtual void set_InitializeLazy(bool value);
}
[ObsoleteAttribute("This class has no more usages and will be removed in a future version")]
public class NHibernate.IdentityEqualityComparer : object {
    public sealed virtual int GetHashCode(object obj);
    public sealed virtual bool Equals(object x, object y);
}
public interface NHibernate.IDetachedQuery {
    public abstract virtual IQuery GetExecutableQuery(ISession session);
    public abstract virtual IDetachedQuery SetMaxResults(int maxResults);
    public abstract virtual IDetachedQuery SetFirstResult(int firstResult);
    public abstract virtual IDetachedQuery SetCacheable(bool cacheable);
    public abstract virtual IDetachedQuery SetCacheRegion(string cacheRegion);
    public abstract virtual IDetachedQuery SetReadOnly(bool readOnly);
    public abstract virtual IDetachedQuery SetTimeout(int timeout);
    public abstract virtual IDetachedQuery SetFetchSize(int fetchSize);
    public abstract virtual void SetLockMode(string alias, LockMode lockMode);
    public abstract virtual IDetachedQuery SetComment(string comment);
    public abstract virtual IDetachedQuery SetParameter(int position, object val, IType type);
    public abstract virtual IDetachedQuery SetParameter(string name, object val, IType type);
    public abstract virtual IDetachedQuery SetParameter(int position, object val);
    public abstract virtual IDetachedQuery SetParameter(string name, object val);
    public abstract virtual IDetachedQuery SetParameterList(string name, IEnumerable vals, IType type);
    public abstract virtual IDetachedQuery SetParameterList(string name, IEnumerable vals);
    public abstract virtual IDetachedQuery SetProperties(object obj);
    public abstract virtual IDetachedQuery SetAnsiString(int position, string val);
    public abstract virtual IDetachedQuery SetAnsiString(string name, string val);
    public abstract virtual IDetachedQuery SetBinary(int position, Byte[] val);
    public abstract virtual IDetachedQuery SetBinary(string name, Byte[] val);
    public abstract virtual IDetachedQuery SetBoolean(int position, bool val);
    public abstract virtual IDetachedQuery SetBoolean(string name, bool val);
    public abstract virtual IDetachedQuery SetByte(int position, byte val);
    public abstract virtual IDetachedQuery SetByte(string name, byte val);
    public abstract virtual IDetachedQuery SetCharacter(int position, char val);
    public abstract virtual IDetachedQuery SetCharacter(string name, char val);
    public abstract virtual IDetachedQuery SetDateTime(int position, DateTime val);
    public abstract virtual IDetachedQuery SetDateTime(string name, DateTime val);
    public abstract virtual IDetachedQuery SetDateTimeNoMs(int position, DateTime val);
    public abstract virtual IDetachedQuery SetDateTimeNoMs(string name, DateTime val);
    public abstract virtual IDetachedQuery SetDecimal(int position, decimal val);
    public abstract virtual IDetachedQuery SetDecimal(string name, decimal val);
    public abstract virtual IDetachedQuery SetDouble(int position, double val);
    public abstract virtual IDetachedQuery SetDouble(string name, double val);
    public abstract virtual IDetachedQuery SetEntity(int position, object val);
    public abstract virtual IDetachedQuery SetEntity(string name, object val);
    public abstract virtual IDetachedQuery SetEnum(int position, Enum val);
    public abstract virtual IDetachedQuery SetEnum(string name, Enum val);
    public abstract virtual IDetachedQuery SetInt16(int position, short val);
    public abstract virtual IDetachedQuery SetInt16(string name, short val);
    public abstract virtual IDetachedQuery SetInt32(int position, int val);
    public abstract virtual IDetachedQuery SetInt32(string name, int val);
    public abstract virtual IDetachedQuery SetInt64(int position, long val);
    public abstract virtual IDetachedQuery SetInt64(string name, long val);
    public abstract virtual IDetachedQuery SetSingle(int position, float val);
    public abstract virtual IDetachedQuery SetSingle(string name, float val);
    public abstract virtual IDetachedQuery SetString(int position, string val);
    public abstract virtual IDetachedQuery SetString(string name, string val);
    public abstract virtual IDetachedQuery SetTime(int position, DateTime val);
    public abstract virtual IDetachedQuery SetTime(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public abstract virtual IDetachedQuery SetTimestamp(int position, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public abstract virtual IDetachedQuery SetTimestamp(string name, DateTime val);
    public abstract virtual IDetachedQuery SetGuid(int position, Guid val);
    public abstract virtual IDetachedQuery SetGuid(string name, Guid val);
    public abstract virtual IDetachedQuery SetFlushMode(FlushMode flushMode);
    public abstract virtual IDetachedQuery SetResultTransformer(IResultTransformer resultTransformer);
    public abstract virtual IDetachedQuery SetIgnoreUknownNamedParameters(bool ignoredUnknownNamedParameters);
    public abstract virtual IDetachedQuery SetCacheMode(CacheMode cacheMode);
}
public interface NHibernate.IFilter {
    public string Name { get; }
    public FilterDefinition FilterDefinition { get; }
    public abstract virtual string get_Name();
    public abstract virtual FilterDefinition get_FilterDefinition();
    public abstract virtual IFilter SetParameter(string name, object value);
    public abstract virtual IFilter SetParameterList(string name, ICollection`1<T> values);
    public abstract virtual void Validate();
}
public interface NHibernate.IFutureEnumerable`1 {
    public abstract virtual Task`1<IEnumerable`1<T>> GetEnumerableAsync(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<T> GetEnumerable();
    [ObsoleteAttribute("Please use GetEnumerable() or GetEnumerableAsync(cancellationToken) instead")]
public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface NHibernate.IFutureValue`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
    public abstract virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
public interface NHibernate.IInterceptor {
    public abstract virtual bool OnLoad(object entity, object id, Object[] state, String[] propertyNames, IType[] types);
    public abstract virtual bool OnFlushDirty(object entity, object id, Object[] currentState, Object[] previousState, String[] propertyNames, IType[] types);
    public abstract virtual bool OnSave(object entity, object id, Object[] state, String[] propertyNames, IType[] types);
    public abstract virtual void OnDelete(object entity, object id, Object[] state, String[] propertyNames, IType[] types);
    public abstract virtual void OnCollectionRecreate(object collection, object key);
    public abstract virtual void OnCollectionRemove(object collection, object key);
    public abstract virtual void OnCollectionUpdate(object collection, object key);
    public abstract virtual void PreFlush(ICollection entities);
    public abstract virtual void PostFlush(ICollection entities);
    public abstract virtual Nullable`1<bool> IsTransient(object entity);
    public abstract virtual Int32[] FindDirty(object entity, object id, Object[] currentState, Object[] previousState, String[] propertyNames, IType[] types);
    public abstract virtual object Instantiate(string entityName, object id);
    public abstract virtual string GetEntityName(object entity);
    public abstract virtual object GetEntity(string entityName, object id);
    public abstract virtual void AfterTransactionBegin(ITransaction tx);
    public abstract virtual void BeforeTransactionCompletion(ITransaction tx);
    public abstract virtual void AfterTransactionCompletion(ITransaction tx);
    public abstract virtual SqlString OnPrepareStatement(SqlString sql);
    public abstract virtual void SetSession(ISession session);
}
[ObsoleteAttribute("Implement and use NHibernate.INHibernateLogger")]
public interface NHibernate.IInternalLogger {
    [ObsoleteAttribute("Please use IsErrorEnabled() INHibernateLogger extension method instead.")]
public bool IsErrorEnabled { get; }
    [ObsoleteAttribute("Please use IsFatalEnabled() INHibernateLogger extension method instead.")]
public bool IsFatalEnabled { get; }
    [ObsoleteAttribute("Please use IsDebugEnabled() INHibernateLogger extension method instead.")]
public bool IsDebugEnabled { get; }
    [ObsoleteAttribute("Please use IsInfoEnabled() INHibernateLogger extension method instead.")]
public bool IsInfoEnabled { get; }
    [ObsoleteAttribute("Please use IsWarnEnabled() INHibernateLogger extension method instead.")]
public bool IsWarnEnabled { get; }
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    [ObsoleteAttribute("Please use Error(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Error(object message);
    [ObsoleteAttribute("Please use Error(Exception, string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Error(object message, Exception exception);
    [ObsoleteAttribute("Please use Error(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void ErrorFormat(string format, Object[] args);
    [ObsoleteAttribute("Please use Fatal(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Fatal(object message);
    [ObsoleteAttribute("Please use Fatal(Exception, string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Fatal(object message, Exception exception);
    [ObsoleteAttribute("Please use Debug(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Debug(object message);
    [ObsoleteAttribute("Please use Debug(Exception, string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Debug(object message, Exception exception);
    [ObsoleteAttribute("Please use Debug(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void DebugFormat(string format, Object[] args);
    [ObsoleteAttribute("Please use Info(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Info(object message);
    [ObsoleteAttribute("Please use Info(Exception, string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Info(object message, Exception exception);
    [ObsoleteAttribute("Please use Info(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void InfoFormat(string format, Object[] args);
    [ObsoleteAttribute("Please use Warn(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Warn(object message);
    [ObsoleteAttribute("Please use Warn(Exception, string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void Warn(object message, Exception exception);
    [ObsoleteAttribute("Please use Warn(string, params object[]) INHibernateLogger extension method instead.")]
public abstract virtual void WarnFormat(string format, Object[] args);
}
[ObsoleteAttribute("Implement INHibernateLoggerFactory instead")]
public interface NHibernate.ILoggerFactory {
    public abstract virtual IInternalLogger LoggerFor(string keyName);
    public abstract virtual IInternalLogger LoggerFor(Type type);
}
public abstract class NHibernate.Impl.AbstractDetachedQuery : object {
    protected Dictionary`2<int, object> posUntypeParams;
    protected Dictionary`2<string, object> namedUntypeParams;
    protected Dictionary`2<string, IEnumerable> namedUntypeListParams;
    protected IList optionalUntypeParams;
    protected Dictionary`2<int, TypedValue> posParams;
    protected Dictionary`2<string, TypedValue> namedParams;
    protected Dictionary`2<string, TypedValue> namedListParams;
    protected Dictionary`2<string, LockMode> lockModes;
    protected RowSelection selection;
    protected bool cacheable;
    protected string cacheRegion;
    protected bool readOnly;
    protected FlushMode flushMode;
    protected IResultTransformer resultTransformer;
    protected bool shouldIgnoredUnknownNamedParameters;
    protected Nullable`1<CacheMode> cacheMode;
    protected string comment;
    public abstract virtual IQuery GetExecutableQuery(ISession session);
    public sealed virtual IDetachedQuery SetMaxResults(int maxResults);
    public sealed virtual IDetachedQuery SetFirstResult(int firstResult);
    public virtual IDetachedQuery SetComment(string comment);
    public virtual IDetachedQuery SetCacheable(bool cacheable);
    public virtual IDetachedQuery SetCacheRegion(string cacheRegion);
    public virtual IDetachedQuery SetReadOnly(bool readOnly);
    public virtual IDetachedQuery SetTimeout(int timeout);
    public virtual IDetachedQuery SetFetchSize(int fetchSize);
    public sealed virtual void SetLockMode(string alias, LockMode lockMode);
    public sealed virtual IDetachedQuery SetParameter(int position, object val, IType type);
    public sealed virtual IDetachedQuery SetParameter(string name, object val, IType type);
    public sealed virtual IDetachedQuery SetParameter(int position, object val);
    public sealed virtual IDetachedQuery SetParameter(string name, object val);
    public sealed virtual IDetachedQuery SetParameterList(string name, IEnumerable vals, IType type);
    public sealed virtual IDetachedQuery SetParameterList(string name, IEnumerable vals);
    public sealed virtual IDetachedQuery SetProperties(object obj);
    public sealed virtual IDetachedQuery SetAnsiString(int position, string val);
    public sealed virtual IDetachedQuery SetAnsiString(string name, string val);
    public sealed virtual IDetachedQuery SetBinary(int position, Byte[] val);
    public sealed virtual IDetachedQuery SetBinary(string name, Byte[] val);
    public sealed virtual IDetachedQuery SetBoolean(int position, bool val);
    public sealed virtual IDetachedQuery SetBoolean(string name, bool val);
    public sealed virtual IDetachedQuery SetByte(int position, byte val);
    public sealed virtual IDetachedQuery SetByte(string name, byte val);
    public sealed virtual IDetachedQuery SetCharacter(int position, char val);
    public sealed virtual IDetachedQuery SetCharacter(string name, char val);
    public sealed virtual IDetachedQuery SetDateTime(int position, DateTime val);
    public sealed virtual IDetachedQuery SetDateTime(string name, DateTime val);
    public sealed virtual IDetachedQuery SetDateTimeNoMs(int position, DateTime val);
    public sealed virtual IDetachedQuery SetDateTimeNoMs(string name, DateTime val);
    public sealed virtual IDetachedQuery SetDecimal(int position, decimal val);
    public sealed virtual IDetachedQuery SetDecimal(string name, decimal val);
    public sealed virtual IDetachedQuery SetDouble(int position, double val);
    public sealed virtual IDetachedQuery SetDouble(string name, double val);
    public sealed virtual IDetachedQuery SetEntity(int position, object val);
    public sealed virtual IDetachedQuery SetEntity(string name, object val);
    public sealed virtual IDetachedQuery SetEnum(int position, Enum val);
    public sealed virtual IDetachedQuery SetEnum(string name, Enum val);
    public sealed virtual IDetachedQuery SetInt16(int position, short val);
    public sealed virtual IDetachedQuery SetInt16(string name, short val);
    public sealed virtual IDetachedQuery SetInt32(int position, int val);
    public sealed virtual IDetachedQuery SetInt32(string name, int val);
    public sealed virtual IDetachedQuery SetInt64(int position, long val);
    public sealed virtual IDetachedQuery SetInt64(string name, long val);
    public sealed virtual IDetachedQuery SetSingle(int position, float val);
    public sealed virtual IDetachedQuery SetSingle(string name, float val);
    public sealed virtual IDetachedQuery SetString(int position, string val);
    public sealed virtual IDetachedQuery SetString(string name, string val);
    public sealed virtual IDetachedQuery SetTime(int position, DateTime val);
    public sealed virtual IDetachedQuery SetTime(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public sealed virtual IDetachedQuery SetTimestamp(int position, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public sealed virtual IDetachedQuery SetTimestamp(string name, DateTime val);
    public sealed virtual IDetachedQuery SetGuid(int position, Guid val);
    public sealed virtual IDetachedQuery SetGuid(string name, Guid val);
    public virtual IDetachedQuery SetFlushMode(FlushMode flushMode);
    public sealed virtual IDetachedQuery SetResultTransformer(IResultTransformer resultTransformer);
    public sealed virtual IDetachedQuery SetIgnoreUknownNamedParameters(bool ignoredUnknownNamedParameters);
    public virtual IDetachedQuery SetCacheMode(CacheMode cacheMode);
    protected void SetQueryProperties(IQuery q);
    private void Reset();
    private void ClearParameters();
    public sealed virtual void CopyTo(IDetachedQuery destination);
    public sealed virtual void SetParametersTo(IDetachedQuery destination);
    private sealed virtual override void NHibernate.Impl.IDetachedQueryImplementor.OverrideInfoFrom(IDetachedQueryImplementor origin);
    private sealed virtual override void NHibernate.Impl.IDetachedQueryImplementor.OverrideParametersFrom(IDetachedQueryImplementor origin);
    public IDetachedQuery CopyParametersFrom(IDetachedQueryImplementor origin);
}
public abstract class NHibernate.Impl.AbstractQueryImpl : object {
    private string queryString;
    protected ISessionImplementor session;
    protected internal ParameterMetadata parameterMetadata;
    private RowSelection selection;
    private List`1<object> values;
    private List`1<IType> types;
    private Dictionary`2<string, TypedValue> namedParameters;
    protected Dictionary`2<string, TypedValue> namedParameterLists;
    private bool cacheable;
    private string cacheRegion;
    private Nullable`1<bool> readOnly;
    private static object UNSET_PARAMETER;
    private static IType UNSET_TYPE;
    private object optionalId;
    private object optionalObject;
    private string optionalEntityName;
    private FlushMode flushMode;
    private FlushMode sessionFlushMode;
    private object collectionKey;
    private IResultTransformer resultTransformer;
    private bool shouldIgnoredUnknownNamedParameters;
    private Nullable`1<CacheMode> cacheMode;
    private Nullable`1<CacheMode> sessionCacheMode;
    private string comment;
    public bool Cacheable { get; }
    public string CacheRegion { get; }
    public bool HasNamedParameters { get; }
    public string QueryString { get; }
    protected internal IDictionary`2<string, TypedValue> NamedParams { get; }
    protected IDictionary NamedParameterLists { get; }
    protected IList Values { get; }
    protected IList`1<IType> Types { get; }
    public IType[] ReturnTypes { get; }
    public String[] ReturnAliases { get; }
    public RowSelection Selection { get; }
    public String[] NamedParameters { get; }
    protected internal ISessionImplementor Session { get; }
    protected RowSelection RowSelection { get; }
    public bool IsReadOnly { get; }
    protected internal IDictionary`2<string, LockMode> LockModes { get; }
    protected AbstractQueryImpl(string queryString, FlushMode flushMode, ISessionImplementor session, ParameterMetadata parameterMetadata);
    private static AbstractQueryImpl();
    public abstract virtual Task`1<int> ExecuteUpdateAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> EnumerableAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<T>> EnumerableAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task ListAsync(IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractQueryImpl/<UniqueResultAsync>d__6`1")]
public sealed virtual Task`1<T> UniqueResultAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractQueryImpl/<UniqueResultAsync>d__7")]
public sealed virtual Task`1<object> UniqueResultAsync(CancellationToken cancellationToken);
    public bool get_Cacheable();
    public string get_CacheRegion();
    public bool get_HasNamedParameters();
    protected internal virtual void VerifyParameters();
    protected internal virtual void VerifyParameters(bool reserveFirstParameter);
    protected internal virtual IType DetermineType(int paramPosition, object paramValue, IType defaultType);
    protected internal virtual IType DetermineType(int paramPosition, object paramValue);
    protected internal virtual IType DetermineType(string paramName, object paramValue, IType defaultType);
    protected internal virtual IType DetermineType(string paramName, object paramValue);
    protected internal virtual IType DetermineType(string paramName, Type clazz);
    protected internal virtual string ExpandParameterLists(IDictionary`2<string, TypedValue> namedParamsCopy);
    private string ExpandParameterList(string query, string name, TypedValue typedList, IDictionary`2<string, TypedValue> namedParamsCopy);
    public sealed virtual IQuery SetParameter(int position, object val, IType type);
    public sealed virtual IQuery SetParameter(string name, object val, IType type);
    public IQuery SetParameter(string name, object val, IType type, bool preferMetadataType);
    private bool CheckParameterIgnored(string name);
    public sealed virtual IQuery SetParameter(int position, T val);
    private void CheckPositionalParameter(int position);
    public sealed virtual IQuery SetParameter(string name, T val);
    public sealed virtual IQuery SetParameter(string name, object val);
    public sealed virtual IQuery SetParameter(int position, object val);
    public sealed virtual IQuery SetAnsiString(int position, string val);
    public sealed virtual IQuery SetString(int position, string val);
    public sealed virtual IQuery SetCharacter(int position, char val);
    public sealed virtual IQuery SetBoolean(int position, bool val);
    public sealed virtual IQuery SetByte(int position, byte val);
    public sealed virtual IQuery SetInt16(int position, short val);
    public sealed virtual IQuery SetInt32(int position, int val);
    public sealed virtual IQuery SetInt64(int position, long val);
    public sealed virtual IQuery SetSingle(int position, float val);
    public sealed virtual IQuery SetDouble(int position, double val);
    public sealed virtual IQuery SetBinary(int position, Byte[] val);
    public sealed virtual IQuery SetDateTimeOffset(string name, DateTimeOffset val);
    public sealed virtual IQuery SetDecimal(int position, decimal val);
    public sealed virtual IQuery SetDateTime(int position, DateTime val);
    public sealed virtual IQuery SetDateTimeNoMs(int position, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead, it uses DateTime2 with dialects supporting it.")]
public sealed virtual IQuery SetDateTime2(int position, DateTime val);
    public sealed virtual IQuery SetTime(int position, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public sealed virtual IQuery SetTimestamp(int position, DateTime val);
    public sealed virtual IQuery SetEntity(int position, object val);
    public sealed virtual IQuery SetEnum(int position, Enum val);
    public sealed virtual IQuery SetAnsiString(string name, string val);
    public sealed virtual IQuery SetString(string name, string val);
    public sealed virtual IQuery SetCharacter(string name, char val);
    public sealed virtual IQuery SetBoolean(string name, bool val);
    public sealed virtual IQuery SetByte(string name, byte val);
    public sealed virtual IQuery SetInt16(string name, short val);
    public sealed virtual IQuery SetInt32(string name, int val);
    public sealed virtual IQuery SetInt64(string name, long val);
    public sealed virtual IQuery SetSingle(string name, float val);
    public sealed virtual IQuery SetDouble(string name, double val);
    public sealed virtual IQuery SetBinary(string name, Byte[] val);
    public sealed virtual IQuery SetDecimal(string name, decimal val);
    public sealed virtual IQuery SetDateTime(string name, DateTime val);
    public sealed virtual IQuery SetDateTimeNoMs(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead, it uses DateTime2 with dialects supporting it.")]
public sealed virtual IQuery SetDateTime2(string name, DateTime val);
    public sealed virtual IQuery SetTimeSpan(int position, TimeSpan val);
    public sealed virtual IQuery SetTimeSpan(string name, TimeSpan val);
    public sealed virtual IQuery SetTimeAsTimeSpan(int position, TimeSpan val);
    public sealed virtual IQuery SetTimeAsTimeSpan(string name, TimeSpan val);
    public sealed virtual IQuery SetDateTimeOffset(int position, DateTimeOffset val);
    public sealed virtual IQuery SetTime(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public sealed virtual IQuery SetTimestamp(string name, DateTime val);
    public sealed virtual IQuery SetGuid(string name, Guid val);
    public sealed virtual IQuery SetGuid(int position, Guid val);
    public sealed virtual IQuery SetEntity(string name, object val);
    public sealed virtual IQuery SetEnum(string name, Enum val);
    [ObsoleteAttribute("This method was never surfaced to a query interface. Use the overload taking an object instead, and supply to it a generic IDictionary<string, object>.")]
public IQuery SetProperties(IDictionary map);
    private IQuery SetParameters(IDictionary`2<string, object> map);
    private IQuery SetParameters(IDictionary map);
    public sealed virtual IQuery SetProperties(object bean);
    public sealed virtual IQuery SetParameterList(string name, IEnumerable vals, IType type);
    public sealed virtual IQuery SetParameterList(string name, IEnumerable vals);
    public sealed virtual string get_QueryString();
    protected internal IDictionary`2<string, TypedValue> get_NamedParams();
    protected IDictionary get_NamedParameterLists();
    protected virtual IList get_Values();
    protected virtual IList`1<IType> get_Types();
    public virtual IType[] get_ReturnTypes();
    public virtual String[] get_ReturnAliases();
    public RowSelection get_Selection();
    public sealed virtual IQuery SetMaxResults(int maxResults);
    public sealed virtual IQuery SetTimeout(int timeout);
    public sealed virtual IQuery SetFetchSize(int fetchSize);
    public sealed virtual IQuery SetFirstResult(int firstResult);
    public sealed virtual String[] get_NamedParameters();
    public abstract virtual IQuery SetLockMode(string alias, LockMode lockMode);
    public sealed virtual IQuery SetComment(string comment);
    protected internal ISessionImplementor get_Session();
    protected RowSelection get_RowSelection();
    public sealed virtual IQuery SetCacheable(bool cacheable);
    public sealed virtual IQuery SetCacheRegion(string cacheRegion);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IQuery SetReadOnly(bool readOnly);
    public void SetOptionalId(object optionalId);
    public void SetOptionalObject(object optionalObject);
    public void SetOptionalEntityName(string optionalEntityName);
    public sealed virtual IQuery SetFlushMode(FlushMode flushMode);
    public IQuery SetCollectionKey(object collectionKey);
    public sealed virtual IQuery SetResultTransformer(IResultTransformer transformer);
    public sealed virtual IFutureEnumerable`1<T> Future();
    public sealed virtual IFutureValue`1<T> FutureValue();
    public sealed virtual IQuery SetCacheMode(CacheMode cacheMode);
    public IQuery SetIgnoreUknownNamedParameters(bool ignoredUnknownNamedParameters);
    protected internal abstract virtual IDictionary`2<string, LockMode> get_LockModes();
    public abstract virtual int ExecuteUpdate();
    public abstract virtual IEnumerable Enumerable();
    public abstract virtual IEnumerable`1<T> Enumerable();
    public abstract virtual IList List();
    public abstract virtual void List(IList results);
    public abstract virtual IList`1<T> List();
    public sealed virtual T UniqueResult();
    public sealed virtual object UniqueResult();
    internal static object UniqueElement(IList list);
    public virtual IType[] TypeArray();
    public virtual Object[] ValueArray();
    public virtual QueryParameters GetQueryParameters();
    public virtual QueryParameters GetQueryParameters(IDictionary`2<string, TypedValue> namedParams);
    protected void Before();
    protected void After();
    public virtual string ToString();
    protected internal abstract virtual IEnumerable`1<ITranslator> GetTranslators(ISessionImplementor sessionImplementor, QueryParameters queryParameters);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
protected internal abstract virtual Task`1<IEnumerable`1<ITranslator>> GetTranslatorsAsync(ISessionImplementor sessionImplementor, QueryParameters queryParameters, CancellationToken cancellationToken);
}
public abstract class NHibernate.Impl.AbstractQueryImpl2 : AbstractQueryImpl {
    private Dictionary`2<string, LockMode> _lockModes;
    protected internal IDictionary`2<string, LockMode> LockModes { get; }
    protected AbstractQueryImpl2(string queryString, FlushMode flushMode, ISessionImplementor session, ParameterMetadata parameterMetadata);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractQueryImpl2/<ExecuteUpdateAsync>d__0")]
public virtual Task`1<int> ExecuteUpdateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractQueryImpl2/<EnumerableAsync>d__1")]
public virtual Task`1<IEnumerable> EnumerableAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractQueryImpl2/<EnumerableAsync>d__2`1")]
public virtual Task`1<IEnumerable`1<T>> EnumerableAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractQueryImpl2/<ListAsync>d__3")]
public virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractQueryImpl2/<ListAsync>d__4")]
public virtual Task ListAsync(IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractQueryImpl2/<ListAsync>d__5`1")]
public virtual Task`1<IList`1<T>> ListAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
protected internal virtual Task`1<IEnumerable`1<ITranslator>> GetTranslatorsAsync(ISessionImplementor sessionImplementor, QueryParameters queryParameters, CancellationToken cancellationToken);
    protected internal virtual IDictionary`2<string, LockMode> get_LockModes();
    public virtual IQuery SetLockMode(string alias, LockMode lockMode);
    public virtual int ExecuteUpdate();
    public virtual IEnumerable Enumerable();
    public virtual IEnumerable`1<T> Enumerable();
    public virtual IList List();
    public virtual void List(IList results);
    public virtual IList`1<T> List();
    protected abstract virtual IQueryExpression ExpandParameters(IDictionary`2<string, TypedValue> namedParamsCopy);
    protected internal virtual IEnumerable`1<ITranslator> GetTranslators(ISessionImplementor sessionImplementor, QueryParameters queryParameters);
}
public abstract class NHibernate.Impl.AbstractSessionImpl : object {
    private ISessionFactoryImplementor _factory;
    private FlushMode _flushMode;
    private IQueryBatch _futureMultiBatch;
    private bool closed;
    [CompilerGeneratedAttribute]
private bool <IsTransactionCoordinatorShared>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransactionContext <TransactionContext>k__BackingField;
    private bool isAlreadyDisposed;
    private static INHibernateLogger Log;
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionManager <ConnectionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IInterceptor <Interceptor>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    private ProcessHelper _processHelper;
    private TenantConfiguration _tenantConfiguration;
    [ObsoleteAttribute("Use GetCurrentTransaction extension method instead, and check for null.")]
public ITransaction Transaction { get; }
    protected bool IsTransactionCoordinatorShared { get; }
    public ITransactionContext TransactionContext { get; public set; }
    public Guid SessionId { get; }
    public ISessionFactoryImplementor Factory { get; protected set; }
    public IBatcher Batcher { get; }
    public IDictionary`2<string, IFilter> EnabledFilters { get; }
    public ConnectionManager ConnectionManager { get; protected set; }
    public bool IsConnected { get; }
    public DbConnection Connection { get; }
    public EventListeners Listeners { get; }
    public bool IsEventSource { get; }
    public IPersistenceContext PersistenceContext { get; }
    public CacheMode CacheMode { get; public set; }
    public bool IsOpen { get; }
    public string FetchProfile { get; public set; }
    [ObsoleteAttribute("Replaced by FutureBatch")]
public FutureCriteriaBatch FutureCriteriaBatch { get; protected internal set; }
    [ObsoleteAttribute("Replaced by FutureBatch")]
public FutureQueryBatch FutureQueryBatch { get; protected internal set; }
    public IQueryBatch FutureBatch { get; }
    public IInterceptor Interceptor { get; protected set; }
    public FlushMode FlushMode { get; public set; }
    public long Timestamp { get; protected set; }
    public bool IsClosed { get; }
    protected bool IsAlreadyDisposed { get; protected set; }
    public bool TransactionInProgress { get; }
    public TenantConfiguration TenantConfiguration { get; protected set; }
    public string TenantIdentifier { get; }
    protected internal AbstractSessionImpl(ISessionFactoryImplementor factory, ISessionCreationOptions options);
    private static AbstractSessionImpl();
    public abstract virtual Task InitializeCollectionAsync(IPersistentCollection collection, bool writing, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> InternalLoadAsync(string entityName, object id, bool eager, bool isNullable, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ImmediateLoadAsync(string entityName, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListAsync>d__3")]
public virtual Task`1<IList> ListAsync(IQueryExpression queryExpression, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task ListAsync(IQueryExpression queryExpression, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListAsync>d__5`1")]
public virtual Task`1<IList`1<T>> ListAsync(IQueryExpression query, QueryParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListAsync>d__6`1")]
public virtual Task`1<IList`1<T>> ListAsync(CriteriaImpl criteria, CancellationToken cancellationToken);
    public abstract virtual Task ListAsync(CriteriaImpl criteria, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListAsync>d__8")]
public virtual Task`1<IList> ListAsync(CriteriaImpl criteria, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList> ListFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListFilterAsync>d__10")]
public sealed virtual Task`1<IList> ListFilterAsync(object collection, IQueryExpression queryExpression, QueryParameters parameters, CancellationToken cancellationToken);
    protected abstract virtual Task ListFilterAsync(object collection, IQueryExpression queryExpression, QueryParameters parameters, IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> EnumerableFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<T>> EnumerableFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task BeforeTransactionCompletionAsync(ITransaction tx, CancellationToken cancellationToken);
    public abstract virtual Task FlushBeforeTransactionCompletionAsync(CancellationToken cancellationToken);
    public abstract virtual Task AfterTransactionCompletionAsync(bool successful, ITransaction tx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListAsync>d__18")]
public virtual Task`1<IList> ListAsync(NativeSQLQuerySpecification spec, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListAsync>d__19")]
public virtual Task ListAsync(NativeSQLQuerySpecification spec, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListAsync>d__20`1")]
public virtual Task`1<IList`1<T>> ListAsync(NativeSQLQuerySpecification spec, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task ListCustomQueryAsync(ICustomQuery customQuery, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<ListCustomQueryAsync>d__22`1")]
public virtual Task`1<IList`1<T>> ListCustomQueryAsync(ICustomQuery customQuery, QueryParameters queryParameters, CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public abstract virtual Task`1<IQueryTranslator[]> GetQueriesAsync(IQueryExpression query, bool scalar, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetEntityUsingInterceptorAsync(EntityKey key, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> ExecuteNativeUpdateAsync(NativeSQLQuerySpecification specification, QueryParameters queryParameters, CancellationToken cancellationToken);
    public virtual Task`1<bool> AutoFlushIfRequiredAsync(ISet`1<string> querySpaces, CancellationToken cancellationToken);
    public abstract virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.AbstractSessionImpl/<AfterOperationAsync>d__28")]
protected Task AfterOperationAsync(bool success, CancellationToken cancellationToken);
    public abstract virtual Task`1<IQuery> CreateFilterAsync(object collection, IQueryExpression queryExpression, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> EnumerableAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<T>> EnumerableAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> ExecuteUpdateAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    public sealed virtual ITransaction get_Transaction();
    [CompilerGeneratedAttribute]
protected bool get_IsTransactionCoordinatorShared();
    [CompilerGeneratedAttribute]
public sealed virtual ITransactionContext get_TransactionContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TransactionContext(ITransactionContext value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_SessionId();
    private TenantConfiguration ValidateTenantConfiguration(ISessionFactoryImplementor factory, ISessionCreationOptions options);
    [ObsoleteAttribute("This method has no more usages in NHibernate and will be removed.")]
public sealed virtual void Initialize();
    public abstract virtual void InitializeCollection(IPersistentCollection collection, bool writing);
    public abstract virtual object InternalLoad(string entityName, object id, bool eager, bool isNullable);
    public abstract virtual object ImmediateLoad(string entityName, object id);
    public sealed virtual EntityKey GenerateEntityKey(object id, IEntityPersister persister);
    public sealed virtual CacheKey GenerateCacheKey(object id, IType type, string entityOrRoleName);
    public sealed virtual ISessionFactoryImplementor get_Factory();
    protected void set_Factory(ISessionFactoryImplementor value);
    public virtual IBatcher get_Batcher();
    public abstract virtual void CloseSessionFromSystemTransaction();
    public virtual IList List(IQueryExpression queryExpression, QueryParameters parameters);
    public abstract virtual void List(IQueryExpression queryExpression, QueryParameters queryParameters, IList results);
    public virtual IList`1<T> List(IQueryExpression query, QueryParameters parameters);
    public virtual IList`1<T> List(CriteriaImpl criteria);
    public abstract virtual void List(CriteriaImpl criteria, IList results);
    public virtual IList List(CriteriaImpl criteria);
    public abstract virtual IList ListFilter(object collection, string filter, QueryParameters parameters);
    public sealed virtual IList ListFilter(object collection, IQueryExpression queryExpression, QueryParameters parameters);
    protected abstract virtual void ListFilter(object collection, IQueryExpression queryExpression, QueryParameters parameters, IList results);
    public abstract virtual IList`1<T> ListFilter(object collection, string filter, QueryParameters parameters);
    public abstract virtual IEnumerable EnumerableFilter(object collection, string filter, QueryParameters parameters);
    public abstract virtual IEnumerable`1<T> EnumerableFilter(object collection, string filter, QueryParameters parameters);
    public abstract virtual IEntityPersister GetEntityPersister(string entityName, object obj);
    public abstract virtual void AfterTransactionBegin(ITransaction tx);
    public abstract virtual void BeforeTransactionCompletion(ITransaction tx);
    public abstract virtual void FlushBeforeTransactionCompletion();
    public abstract virtual void AfterTransactionCompletion(bool successful, ITransaction tx);
    public abstract virtual object GetContextEntityIdentifier(object obj);
    [ObsoleteAttribute("Use override with persister parameter")]
public abstract virtual object Instantiate(string clazz, object id);
    public virtual object Instantiate(IEntityPersister persister, object id);
    public virtual IList List(NativeSQLQuerySpecification spec, QueryParameters queryParameters);
    public virtual void List(NativeSQLQuerySpecification spec, QueryParameters queryParameters, IList results);
    public virtual IList`1<T> List(NativeSQLQuerySpecification spec, QueryParameters queryParameters);
    public abstract virtual void ListCustomQuery(ICustomQuery customQuery, QueryParameters queryParameters, IList results);
    public virtual IList`1<T> ListCustomQuery(ICustomQuery customQuery, QueryParameters queryParameters);
    public abstract virtual object GetFilterParameterValue(string filterParameterName);
    public abstract virtual IType GetFilterParameterType(string filterParameterName);
    public abstract virtual IDictionary`2<string, IFilter> get_EnabledFilters();
    public virtual IQuery GetNamedSQLQuery(string name);
    [CompilerGeneratedAttribute]
public virtual ConnectionManager get_ConnectionManager();
    [CompilerGeneratedAttribute]
protected virtual void set_ConnectionManager(ConnectionManager value);
    public virtual bool get_IsConnected();
    public virtual DbConnection get_Connection();
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public abstract virtual IQueryTranslator[] GetQueries(IQueryExpression query, bool scalar);
    public abstract virtual EventListeners get_Listeners();
    public abstract virtual bool get_IsEventSource();
    public abstract virtual object GetEntityUsingInterceptor(EntityKey key);
    public abstract virtual IPersistenceContext get_PersistenceContext();
    public abstract virtual CacheMode get_CacheMode();
    public abstract virtual void set_CacheMode(CacheMode value);
    public abstract virtual bool get_IsOpen();
    public abstract virtual string get_FetchProfile();
    public abstract virtual void set_FetchProfile(string value);
    public abstract virtual string BestGuessEntityName(object entity);
    public abstract virtual string GuessEntityName(object entity);
    public abstract virtual int ExecuteNativeUpdate(NativeSQLQuerySpecification specification, QueryParameters queryParameters);
    public abstract virtual FutureCriteriaBatch get_FutureCriteriaBatch();
    protected internal abstract virtual void set_FutureCriteriaBatch(FutureCriteriaBatch value);
    public abstract virtual FutureQueryBatch get_FutureQueryBatch();
    protected internal abstract virtual void set_FutureQueryBatch(FutureQueryBatch value);
    public virtual IQueryBatch get_FutureBatch();
    [CompilerGeneratedAttribute]
public virtual IInterceptor get_Interceptor();
    [CompilerGeneratedAttribute]
protected virtual void set_Interceptor(IInterceptor value);
    public virtual FlushMode get_FlushMode();
    public virtual void set_FlushMode(FlushMode value);
    public virtual bool AutoFlushIfRequired(ISet`1<string> querySpaces);
    public virtual IQuery GetNamedQuery(string queryName);
    [CompilerGeneratedAttribute]
public virtual long get_Timestamp();
    [CompilerGeneratedAttribute]
protected virtual void set_Timestamp(long value);
    public sealed virtual bool get_IsClosed();
    public IDisposable BeginProcess();
    public IDisposable BeginContext();
    protected internal virtual void CheckAndUpdateSessionStatus();
    protected virtual void ErrorIfClosed();
    protected bool get_IsAlreadyDisposed();
    protected void set_IsAlreadyDisposed(bool value);
    public abstract virtual void Flush();
    public virtual bool get_TransactionInProgress();
    public TenantConfiguration get_TenantConfiguration();
    protected void set_TenantConfiguration(TenantConfiguration value);
    public string get_TenantIdentifier();
    protected internal void SetClosed();
    protected DbConnection CloseConnectionManager();
    private void InitQuery(IQuery query, NamedQueryDefinition nqd);
    public virtual IQuery CreateQuery(IQueryExpression queryExpression);
    public virtual IQuery CreateQuery(string queryString);
    public virtual ISQLQuery CreateSQLQuery(string sql);
    protected internal virtual IQueryExpressionPlan GetHQLQueryPlan(IQueryExpression queryExpression, bool shallow);
    protected internal virtual NativeSQLQueryPlan GetNativeSQLQueryPlan(NativeSQLQuerySpecification spec);
    protected Exception Convert(Exception sqlException, string message);
    protected void AfterOperation(bool success);
    public sealed virtual ITransaction BeginTransaction();
    public sealed virtual ITransaction BeginTransaction(IsolationLevel isolationLevel);
    protected void EnlistInAmbientTransactionIfNeeded();
    public sealed virtual void JoinTransaction();
    public abstract virtual IQuery CreateFilter(object collection, IQueryExpression queryExpression);
    internal IOuterJoinLoadable GetOuterJoinLoadable(string entityName);
    public abstract virtual IEnumerable Enumerable(IQueryExpression queryExpression, QueryParameters queryParameters);
    public abstract virtual IEnumerable`1<T> Enumerable(IQueryExpression queryExpression, QueryParameters queryParameters);
    public abstract virtual int ExecuteUpdate(IQueryExpression queryExpression, QueryParameters queryParameters);
    public sealed virtual IQueryable`1<T> Query();
    public sealed virtual IQueryable`1<T> Query(string entityName);
    public virtual IQueryBatch CreateQueryBatch();
}
public class NHibernate.Impl.CollectionFilterImpl : QueryImpl {
    private object collection;
    public CollectionFilterImpl(string queryString, object collection, ISessionImplementor session, ParameterMetadata parameterMetadata);
    public virtual Task`1<IEnumerable> EnumerableAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<T>> EnumerableAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
protected internal virtual Task`1<IEnumerable`1<ITranslator>> GetTranslatorsAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    public virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    public virtual Task`1<IList`1<T>> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.CollectionFilterImpl/<ListAsync>d__5")]
public virtual Task ListAsync(IList results, CancellationToken cancellationToken);
    public virtual IEnumerable Enumerable();
    public virtual IEnumerable`1<T> Enumerable();
    protected internal virtual IEnumerable`1<ITranslator> GetTranslators(ISessionImplementor session, QueryParameters queryParameters);
    internal static IEnumerable`1<ITranslator> GetTranslators(ISessionImplementor session, QueryParameters queryParameters, IQueryExpression queryExpression, object collection);
    public virtual IList List();
    public virtual IList`1<T> List();
    public virtual void List(IList results);
    public virtual IType[] TypeArray();
    public virtual Object[] ValueArray();
}
public class NHibernate.Impl.CriteriaImpl : object {
    private Type persistentClass;
    private List`1<CriterionEntry> criteria;
    private List`1<OrderEntry> orderEntries;
    private Dictionary`2<string, SelectMode> selectModes;
    private Dictionary`2<string, LockMode> lockModes;
    private Dictionary`2<string, HashSet`1<string>> _entityFetchLazyProperties;
    private int maxResults;
    private int firstResult;
    private int timeout;
    private int fetchSize;
    private ISessionImplementor session;
    private IResultTransformer resultTransformer;
    private bool cacheable;
    private string cacheRegion;
    private Nullable`1<CacheMode> cacheMode;
    private Nullable`1<CacheMode> sessionCacheMode;
    private string comment;
    private Nullable`1<FlushMode> flushMode;
    private Nullable`1<FlushMode> sessionFlushMode;
    private Nullable`1<bool> readOnly;
    private List`1<Subcriteria> subcriteriaList;
    private string rootAlias;
    private Dictionary`2<string, ICriteria> subcriteriaByPath;
    private Dictionary`2<string, ICriteria> subcriteriaByAlias;
    private string entityOrClassName;
    private IProjection projection;
    private ICriteria projectionCriteria;
    public ISessionImplementor Session { get; public set; }
    public string EntityOrClassName { get; }
    public IDictionary`2<string, LockMode> LockModes { get; }
    public ICriteria ProjectionCriteria { get; }
    public bool LookupByNaturalKey { get; }
    public string Alias { get; }
    public IProjection Projection { get; }
    public bool IsReadOnlyInitialized { get; }
    public bool IsReadOnly { get; }
    public IResultTransformer ResultTransformer { get; }
    public int MaxResults { get; }
    public int FirstResult { get; }
    public int FetchSize { get; }
    public int Timeout { get; }
    public bool Cacheable { get; }
    public string CacheRegion { get; }
    public Nullable`1<CacheMode> CacheMode { get; }
    public string Comment { get; }
    public CriteriaImpl(Type persistentClass, ISessionImplementor session);
    public CriteriaImpl(Type persistentClass, string alias, ISessionImplementor session);
    public CriteriaImpl(string entityOrClassName, ISessionImplementor session);
    public CriteriaImpl(string entityOrClassName, string alias, ISessionImplementor session);
    [AsyncStateMachineAttribute("NHibernate.Impl.CriteriaImpl/<ListAsync>d__0")]
public sealed virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.CriteriaImpl/<ListAsync>d__1")]
public sealed virtual Task ListAsync(IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.CriteriaImpl/<ListAsync>d__2`1")]
public sealed virtual Task`1<IList`1<T>> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.CriteriaImpl/<UniqueResultAsync>d__3`1")]
public sealed virtual Task`1<T> UniqueResultAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.CriteriaImpl/<UniqueResultAsync>d__4")]
public sealed virtual Task`1<object> UniqueResultAsync(CancellationToken cancellationToken);
    public ISessionImplementor get_Session();
    public void set_Session(ISessionImplementor value);
    public string get_EntityOrClassName();
    public IDictionary`2<string, LockMode> get_LockModes();
    public ICriteria get_ProjectionCriteria();
    public bool get_LookupByNaturalKey();
    public sealed virtual string get_Alias();
    public IProjection get_Projection();
    public sealed virtual bool get_IsReadOnlyInitialized();
    public sealed virtual bool get_IsReadOnly();
    [ObsoleteAttribute("Use GetSelectMode instead")]
public FetchMode GetFetchMode(string path);
    public SelectMode GetSelectMode(string path);
    public HashSet`1<string> GetEntityFetchLazyProperties(string path);
    public IResultTransformer get_ResultTransformer();
    public int get_MaxResults();
    public int get_FirstResult();
    public int get_FetchSize();
    public int get_Timeout();
    public bool get_Cacheable();
    public string get_CacheRegion();
    public Nullable`1<CacheMode> get_CacheMode();
    public string get_Comment();
    protected internal void Before();
    protected internal void After();
    public sealed virtual ICriteria SetMaxResults(int maxResults);
    public sealed virtual ICriteria SetFirstResult(int firstResult);
    public sealed virtual ICriteria SetTimeout(int timeout);
    public sealed virtual ICriteria SetFetchSize(int fetchSize);
    public sealed virtual ICriteria Add(ICriterion expression);
    public sealed virtual IList List();
    public sealed virtual void List(IList results);
    public sealed virtual IList`1<T> List();
    public sealed virtual T UniqueResult();
    public sealed virtual void ClearOrders();
    public IEnumerable`1<CriterionEntry> IterateExpressionEntries();
    public IEnumerable`1<OrderEntry> IterateOrderings();
    public IEnumerable`1<Subcriteria> IterateSubcriteria();
    public virtual string ToString();
    public sealed virtual ICriteria Fetch(SelectMode selectMode, string associationPath, string alias);
    public sealed virtual ICriteria AddOrder(Order ordering);
    [ObsoleteAttribute("Use Fetch instead")]
public sealed virtual ICriteria SetFetchMode(string associationPath, FetchMode mode);
    [ObsoleteAttribute]
private SelectMode GetSelectMode(FetchMode mode);
    public sealed virtual ICriteria CreateAlias(string associationPath, string alias);
    public sealed virtual ICriteria CreateAlias(string associationPath, string alias, JoinType joinType);
    public sealed virtual ICriteria CreateAlias(string associationPath, string alias, JoinType joinType, ICriterion withClause);
    public sealed virtual ICriteria CreateEntityCriteria(string alias, ICriterion withClause, JoinType joinType, string entityName);
    public ICriteria Add(ICriteria criteriaInst, ICriterion expression);
    public sealed virtual ICriteria CreateCriteria(string associationPath);
    public sealed virtual ICriteria CreateCriteria(string associationPath, JoinType joinType);
    public sealed virtual ICriteria CreateCriteria(string associationPath, string alias);
    public sealed virtual ICriteria CreateCriteria(string associationPath, string alias, JoinType joinType);
    public sealed virtual ICriteria CreateCriteria(string associationPath, string alias, JoinType joinType, ICriterion withClause);
    public sealed virtual IFutureValue`1<T> FutureValue();
    public sealed virtual IFutureEnumerable`1<T> Future();
    public sealed virtual object UniqueResult();
    public sealed virtual ICriteria SetLockMode(LockMode lockMode);
    public sealed virtual ICriteria SetLockMode(string alias, LockMode lockMode);
    public sealed virtual ICriteria SetResultTransformer(IResultTransformer tupleMapper);
    public sealed virtual ICriteria SetCacheable(bool cacheable);
    public sealed virtual ICriteria SetCacheRegion(string cacheRegion);
    public sealed virtual ICriteria SetComment(string comment);
    public sealed virtual ICriteria SetFlushMode(FlushMode flushMode);
    public sealed virtual ICriteria SetProjection(IProjection[] projections);
    public sealed virtual ICriteria SetReadOnly(bool readOnly);
    public sealed virtual ICriteria SetCacheMode(CacheMode cacheMode);
    public sealed virtual object Clone();
    private void CloneProjectCrtieria(CriteriaImpl clone);
    private void CloneSubcriteria(CriteriaImpl clone);
    public sealed virtual ICriteria GetCriteriaByPath(string path);
    public sealed virtual ICriteria GetCriteriaByAlias(string alias);
    public sealed virtual Type GetRootEntityTypeIfAvailable();
}
[ObsoleteAttribute]
internal class NHibernate.Impl.DelayedEnumerator`1 : object {
    private GetResult<T> _result;
    private GetResultAsync<T> _resultAsync;
    [CompilerGeneratedAttribute]
private Delegate <ExecuteOnEval>k__BackingField;
    public Delegate ExecuteOnEval { get; public set; }
    public DelayedEnumerator`1(GetResult<T> result, GetResultAsync<T> resultAsync);
    [CompilerGeneratedAttribute]
public sealed virtual Delegate get_ExecuteOnEval();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExecuteOnEval(Delegate value);
    public sealed virtual IEnumerable`1<T> GetEnumerable();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ObsoleteAttribute("Please use GetEnumerable() or GetEnumerableAsync(cancellationToken) instead")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual Task`1<IEnumerable`1<T>> GetEnumerableAsync(CancellationToken cancellationToken);
    public sealed virtual IList TransformList(IList collection);
}
public class NHibernate.Impl.DetachedNamedQuery : AbstractDetachedQuery {
    private string queryName;
    private bool cacheableWasSet;
    private bool cacheModeWasSet;
    private bool cacheRegionWasSet;
    private bool readOnlyWasSet;
    private bool timeoutWasSet;
    private bool fetchSizeWasSet;
    private bool commentWasSet;
    private bool flushModeWasSet;
    public string QueryName { get; }
    public DetachedNamedQuery(string queryName);
    public string get_QueryName();
    public virtual IQuery GetExecutableQuery(ISession session);
    private void SetDefaultProperties(ISessionFactoryImplementor factory);
    public DetachedNamedQuery Clone();
    public virtual IDetachedQuery SetCacheable(bool cacheable);
    public virtual IDetachedQuery SetCacheMode(CacheMode cacheMode);
    public virtual IDetachedQuery SetCacheRegion(string cacheRegion);
    public virtual IDetachedQuery SetReadOnly(bool readOnly);
    public virtual IDetachedQuery SetTimeout(int timeout);
    public virtual IDetachedQuery SetFetchSize(int fetchSize);
    public virtual IDetachedQuery SetComment(string comment);
    public virtual IDetachedQuery SetFlushMode(FlushMode flushMode);
}
public class NHibernate.Impl.DetachedQuery : AbstractDetachedQuery {
    private string hql;
    public string Hql { get; }
    public DetachedQuery(string hql);
    public string get_Hql();
    public virtual IQuery GetExecutableQuery(ISession session);
    public DetachedQuery Clone();
}
public class NHibernate.Impl.EnumerableImpl : object {
    private static INHibernateLogger log;
    private DbDataReader _reader;
    private IEventSource _session;
    private IType[] _types;
    private bool _single;
    private object _currentResult;
    private bool _hasNext;
    private bool _startedReading;
    private String[][] _names;
    private DbCommand _cmd;
    private bool _readOnly;
    private int _currentRow;
    private IResultTransformer _resultTransformer;
    private String[] _returnAliases;
    private RowSelection _selection;
    private bool _isAlreadyDisposed;
    public object Current { get; }
    [ObsoleteAttribute("Please use the constructor accepting resultTransformer and queryReturnAliases")]
public EnumerableImpl(DbDataReader reader, DbCommand cmd, IEventSource session, bool readOnly, IType[] types, String[][] columnNames, RowSelection selection, HolderInstantiator holderInstantiator);
    public EnumerableImpl(DbDataReader reader, DbCommand cmd, IEventSource session, bool readOnly, IType[] types, String[][] columnNames, RowSelection selection, IResultTransformer resultTransformer, String[] returnAliases);
    private static EnumerableImpl();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    private void PostNext();
    private void PostMoveNext(bool hasNext);
    public sealed virtual void Reset();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
}
internal class NHibernate.Impl.ExpandedQueryExpression : object {
    private IASTNode _tree;
    private ICacheableQueryExpression _cacheableExpression;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NamedParameterDescriptor> <ParameterDescriptors>k__BackingField;
    public string Key { get; private set; }
    public Type Type { get; private set; }
    public IList`1<NamedParameterDescriptor> ParameterDescriptors { get; private set; }
    public bool CanCachePlan { get; }
    public ExpandedQueryExpression(IQueryExpression queryExpression, IASTNode tree, string key);
    public sealed virtual IASTNode Translate(ISessionFactoryImplementor sessionFactory, bool filter);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<NamedParameterDescriptor> get_ParameterDescriptors();
    [CompilerGeneratedAttribute]
private void set_ParameterDescriptors(IList`1<NamedParameterDescriptor> value);
    public sealed virtual bool get_CanCachePlan();
}
internal class NHibernate.Impl.ExpressionFilterImpl : ExpressionQueryImpl {
    private object collection;
    public ExpressionFilterImpl(IQueryExpression queryExpression, object collection, ISessionImplementor session, ParameterMetadata parameterMetadata);
    [AsyncStateMachineAttribute("NHibernate.Impl.ExpressionFilterImpl/<ListAsync>d__0")]
public virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.ExpressionFilterImpl/<ListAsync>d__1`1")]
public virtual Task`1<IList`1<T>> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.ExpressionFilterImpl/<ListAsync>d__2")]
public virtual Task ListAsync(IList results, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> EnumerableAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<T>> EnumerableAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
protected internal virtual Task`1<IEnumerable`1<ITranslator>> GetTranslatorsAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    public virtual IList List();
    public virtual IList`1<T> List();
    public virtual void List(IList results);
    public virtual IEnumerable Enumerable();
    public virtual IEnumerable`1<T> Enumerable();
    protected internal virtual IEnumerable`1<ITranslator> GetTranslators(ISessionImplementor session, QueryParameters queryParameters);
    public virtual IType[] TypeArray();
    public virtual Object[] ValueArray();
}
public static class NHibernate.Impl.ExpressionProcessor : object {
    private static Dictionary`2<ExpressionType, Func`3<ProjectionInfo, object, ICriterion>> _simpleExpressionCreators;
    private static Dictionary`2<ExpressionType, Func`3<ProjectionInfo, ProjectionInfo, ICriterion>> _propertyExpressionCreators;
    private static Dictionary`2<LambdaSubqueryType, IDictionary`2<ExpressionType, Func`3<string, DetachedCriteria, AbstractCriterion>>> _subqueryExpressionCreatorTypes;
    private static Dictionary`2<string, Func`2<MethodCallExpression, ICriterion>> _customMethodCallProcessors;
    private static Dictionary`2<string, Func`2<Expression, IProjection>> _customProjectionProcessors;
    private static Dictionary`2<ExpressionType, ISQLFunction> _binaryArithmethicTemplates;
    private static ISQLFunction _unaryNegateTemplate;
    private static Regex GeneratedMemberNameRegex;
    private static ExpressionProcessor();
    private static void RegisterBinaryArithmeticExpression(ExpressionType type, string sqlOperand);
    private static ICriterion Eq(ProjectionInfo property, object value);
    private static ICriterion Ne(ProjectionInfo property, object value);
    private static ICriterion Gt(ProjectionInfo property, object value);
    private static ICriterion Ge(ProjectionInfo property, object value);
    private static ICriterion Lt(ProjectionInfo property, object value);
    private static ICriterion Le(ProjectionInfo property, object value);
    public static object FindValue(Expression expression);
    public static ProjectionInfo FindMemberProjection(Expression expression);
    private static Expression UnwrapConvertExpression(Expression expression);
    private static ProjectionInfo AsArithmeticProjection(Expression expression);
    private static bool IsCompilerGeneratedMemberExpressionOfCompilerGeneratedClass(Expression expression);
    public static string FindMemberExpression(Expression expression);
    public static string FindPropertyExpression(Expression expression);
    public static DetachedCriteria FindDetachedCriteria(Expression expression);
    private static bool EvaluatesToNull(Expression expression);
    private static Type FindMemberType(Expression expression);
    private static bool IsMemberExpression(Expression expression);
    private static bool IsMemberExpressionOrAlias(Expression expr);
    private static bool IsConversion(ExpressionType expressionType);
    private static object ConvertType(object value, Type type);
    private static ICriterion ProcessSimpleExpression(Expression left, TypedValue rightValue, ExpressionType nodeType);
    private static ICriterion ProcessAsVisualBasicStringComparison(Expression left, ExpressionType nodeType);
    private static ICriterion ProcessSimpleNullExpression(ProjectionInfo property, ExpressionType expressionType);
    private static ICriterion ProcessMemberExpression(Expression left, Expression right, ExpressionType nodeType);
    private static ICriterion ProcessAndExpression(BinaryExpression expression);
    private static ICriterion ProcessOrExpression(BinaryExpression expression);
    private static ICriterion ProcessBinaryExpression(BinaryExpression expression);
    private static ICriterion ProcessBooleanExpression(Expression expression);
    private static string ClassMember(Expression expression);
    public static string Signature(MethodInfo methodInfo);
    public static string Signature(MemberInfo memberInfo);
    private static ICriterion ProcessCustomMethodCall(MethodCallExpression methodCallExpression);
    private static ICriterion ProcessExpression(Expression expression);
    private static ICriterion ProcessLambdaExpression(LambdaExpression expression);
    public static ICriterion ProcessExpression(Expression`1<Func`2<T, bool>> expression);
    public static ICriterion ProcessExpression(Expression`1<Func`1<bool>> expression);
    public static Order ProcessOrder(Expression`1<Func`2<T, object>> expression, Func`2<string, Order> orderDelegate);
    public static Order ProcessOrder(Expression`1<Func`1<object>> expression, Func`2<string, Order> orderDelegate);
    public static Order ProcessOrder(LambdaExpression expression, Func`2<string, Order> orderDelegate);
    public static Order ProcessOrder(LambdaExpression expression, Func`2<string, Order> orderStringDelegate, Func`2<IProjection, Order> orderProjectionDelegate);
    private static AbstractCriterion ProcessSubqueryExpression(LambdaSubqueryType subqueryType, BinaryExpression be);
    public static AbstractCriterion ProcessSubquery(LambdaSubqueryType subqueryType, Expression`1<Func`2<T, bool>> expression);
    public static AbstractCriterion ProcessSubquery(LambdaSubqueryType subqueryType, Expression`1<Func`1<bool>> expression);
    public static void RegisterCustomMethodCall(Expression`1<Func`1<bool>> function, Func`2<MethodCallExpression, ICriterion> functionProcessor);
    public static void RegisterCustomProjection(Expression`1<Func`1<T>> function, Func`2<MethodCallExpression, IProjection> functionProcessor);
    public static void RegisterCustomProjection(Expression`1<Func`1<T>> function, Func`2<MemberExpression, IProjection> functionProcessor);
    [CompilerGeneratedAttribute]
internal static object <FindValue>g__findValue|16_0(Expression e);
}
internal class NHibernate.Impl.ExpressionQueryImpl : AbstractQueryImpl2 {
    [CompilerGeneratedAttribute]
private IQueryExpression <QueryExpression>k__BackingField;
    protected bool _isFilter;
    public IQueryExpression QueryExpression { get; private set; }
    public ExpressionQueryImpl(IQueryExpression queryExpression, ISessionImplementor session, ParameterMetadata parameterMetadata);
    protected ExpressionQueryImpl(IQueryExpression queryExpression, ISessionImplementor session, ParameterMetadata parameterMetadata, bool isFilter);
    [CompilerGeneratedAttribute]
public IQueryExpression get_QueryExpression();
    [CompilerGeneratedAttribute]
private void set_QueryExpression(IQueryExpression value);
    protected virtual IQueryExpression ExpandParameters(IDictionary`2<string, TypedValue> namedParamsCopy);
}
public class NHibernate.Impl.FilterImpl : object {
    public static string MARKER;
    private FilterDefinition definition;
    private Dictionary`2<string, object> parameters;
    private Dictionary`2<string, int> _parameterSpans;
    public FilterDefinition FilterDefinition { get; }
    public string Name { get; }
    public IDictionary`2<string, object> Parameters { get; }
    public FilterImpl(FilterDefinition configuration);
    private static FilterImpl();
    public void AfterDeserialize(FilterDefinition factoryDefinition);
    public sealed virtual FilterDefinition get_FilterDefinition();
    public sealed virtual string get_Name();
    public IDictionary`2<string, object> get_Parameters();
    public sealed virtual IFilter SetParameter(string name, object value);
    public sealed virtual IFilter SetParameterList(string name, ICollection`1<T> values);
    public object GetParameter(string name);
    public Nullable`1<int> GetParameterSpan(string name);
    public sealed virtual void Validate();
}
[ObsoleteAttribute("Replaced by QueryBatch")]
public abstract class NHibernate.Impl.FutureBatch`2 : object {
    private List`1<BatchedQuery<TQueryApproach, TMultiApproach>> queries;
    private int index;
    private IList results;
    private bool isCacheable;
    private string cacheRegion;
    protected SessionImpl session;
    protected FutureBatch`2(SessionImpl session);
    [AsyncStateMachineAttribute("NHibernate.Impl.FutureBatch`2/<GetResultsAsync>d__0")]
private Task`1<IList> GetResultsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.FutureBatch`2/<GetCurrentResultAsync>d__1`1")]
private Task`1<IEnumerable`1<TResult>> GetCurrentResultAsync(int currentIndex, CancellationToken cancellationToken);
    protected virtual Task`1<IList> ListAsync(TQueryApproach query, CancellationToken cancellationToken);
    protected abstract virtual Task`1<IList> GetResultsFromAsync(TMultiApproach multiApproach, CancellationToken cancellationToken);
    public void Add(TQueryApproach query);
    public void Add(TQueryApproach query);
    public IFutureValue`1<TResult> GetFutureValue();
    public IFutureEnumerable`1<TResult> GetEnumerator();
    private IList GetResults();
    private IEnumerable`1<TResult> GetCurrentResult(int currentIndex);
    protected virtual IList List(TQueryApproach query);
    protected abstract virtual TMultiApproach CreateMultiApproach(bool isCacheable, string cacheRegion);
    protected abstract virtual void AddTo(TMultiApproach multiApproach, TQueryApproach query, Type resultType);
    protected abstract virtual IList GetResultsFrom(TMultiApproach multiApproach);
    protected abstract virtual void ClearCurrentFutureBatch();
    protected abstract virtual bool IsQueryCacheable(TQueryApproach query);
    protected abstract virtual string CacheRegion(TQueryApproach query);
    protected virtual void AddResultTransformer(TMultiApproach multiApproach, IResultTransformer futureResulsTransformer);
}
[ObsoleteAttribute("Replaced by QueryBatch")]
public class NHibernate.Impl.FutureCriteriaBatch : FutureBatch`2<ICriteria, IMultiCriteria> {
    public FutureCriteriaBatch(SessionImpl session);
    protected virtual Task`1<IList> ListAsync(ICriteria query, CancellationToken cancellationToken);
    protected virtual Task`1<IList> GetResultsFromAsync(IMultiCriteria multiApproach, CancellationToken cancellationToken);
    protected virtual IList List(ICriteria query);
    protected virtual IMultiCriteria CreateMultiApproach(bool isCacheable, string cacheRegion);
    protected virtual void AddTo(IMultiCriteria multiApproach, ICriteria query, Type resultType);
    protected virtual IList GetResultsFrom(IMultiCriteria multiApproach);
    protected virtual void ClearCurrentFutureBatch();
    protected virtual bool IsQueryCacheable(ICriteria query);
    protected virtual string CacheRegion(ICriteria query);
}
[ObsoleteAttribute("Replaced by QueryBatch")]
public class NHibernate.Impl.FutureQueryBatch : FutureBatch`2<IQuery, IMultiQuery> {
    public FutureQueryBatch(SessionImpl session);
    protected virtual Task`1<IList> ListAsync(IQuery query, CancellationToken cancellationToken);
    protected virtual Task`1<IList> GetResultsFromAsync(IMultiQuery multiApproach, CancellationToken cancellationToken);
    protected virtual IList List(IQuery query);
    protected virtual IMultiQuery CreateMultiApproach(bool isCacheable, string cacheRegion);
    protected virtual void AddTo(IMultiQuery multiApproach, IQuery query, Type resultType);
    protected virtual void AddResultTransformer(IMultiQuery multiApproach, IResultTransformer futureResulsTransformer);
    protected virtual IList GetResultsFrom(IMultiQuery multiApproach);
    protected virtual void ClearCurrentFutureBatch();
    protected virtual bool IsQueryCacheable(IQuery query);
    protected virtual string CacheRegion(IQuery query);
}
[ObsoleteAttribute]
internal class NHibernate.Impl.FutureValue`1 : object {
    private GetResult<T> _getResult;
    private GetResultAsync<T> _getResultAsync;
    [CompilerGeneratedAttribute]
private Delegate <ExecuteOnEval>k__BackingField;
    public T Value { get; }
    public Delegate ExecuteOnEval { get; public set; }
    public FutureValue`1(GetResult<T> result, GetResultAsync<T> resultAsync);
    public sealed virtual T get_Value();
    [AsyncStateMachineAttribute("NHibernate.Impl.FutureValue`1/<GetValueAsync>d__7")]
public sealed virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual Delegate get_ExecuteOnEval();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExecuteOnEval(Delegate value);
    public sealed virtual IList TransformList(IList collection);
}
internal class NHibernate.Impl.HqlTranslatorWrapper : object {
    private IQueryTranslator innerTranslator;
    [ObsoleteAttribute("Use QueryLoader instead.")]
public Loader Loader { get; }
    public ILoader QueryLoader { get; }
    public IType[] ReturnTypes { get; }
    public ICollection`1<string> QuerySpaces { get; }
    public String[] ReturnAliases { get; }
    public HqlTranslatorWrapper(IQueryTranslator translator);
    public sealed virtual Loader get_Loader();
    public sealed virtual ILoader get_QueryLoader();
    public sealed virtual IType[] get_ReturnTypes();
    public sealed virtual ICollection`1<string> get_QuerySpaces();
    public sealed virtual String[] get_ReturnAliases();
}
[ObsoleteAttribute]
internal interface NHibernate.Impl.IDelayedValue {
    public Delegate ExecuteOnEval { get; public set; }
    public abstract virtual Delegate get_ExecuteOnEval();
    public abstract virtual void set_ExecuteOnEval(Delegate value);
    public abstract virtual IList TransformList(IList collection);
}
public interface NHibernate.Impl.IDetachedQueryImplementor {
    public abstract virtual void CopyTo(IDetachedQuery destination);
    public abstract virtual void SetParametersTo(IDetachedQuery destination);
    public abstract virtual void OverrideInfoFrom(IDetachedQueryImplementor origin);
    public abstract virtual void OverrideParametersFrom(IDetachedQueryImplementor origin);
}
public interface NHibernate.Impl.ISessionCreationOptions {
    public FlushMode InitialSessionFlushMode { get; }
    public bool ShouldAutoClose { get; }
    public bool ShouldAutoJoinTransaction { get; }
    public DbConnection UserSuppliedConnection { get; }
    public IInterceptor SessionInterceptor { get; }
    public ConnectionReleaseMode SessionConnectionReleaseMode { get; }
    public abstract virtual FlushMode get_InitialSessionFlushMode();
    public abstract virtual bool get_ShouldAutoClose();
    public abstract virtual bool get_ShouldAutoJoinTransaction();
    public abstract virtual DbConnection get_UserSuppliedConnection();
    public abstract virtual IInterceptor get_SessionInterceptor();
    public abstract virtual ConnectionReleaseMode get_SessionConnectionReleaseMode();
}
public interface NHibernate.Impl.ISessionCreationOptionsWithMultiTenancy {
    public TenantConfiguration TenantConfiguration { get; public set; }
    public abstract virtual TenantConfiguration get_TenantConfiguration();
    public abstract virtual void set_TenantConfiguration(TenantConfiguration value);
}
public interface NHibernate.Impl.ISharedSessionCreationOptions {
    public bool IsTransactionCoordinatorShared { get; }
    public ConnectionManager ConnectionManager { get; }
    public abstract virtual bool get_IsTransactionCoordinatorShared();
    public abstract virtual ConnectionManager get_ConnectionManager();
}
public interface NHibernate.Impl.ISupportEntityJoinCriteria {
    public abstract virtual ICriteria CreateEntityCriteria(string alias, ICriterion withClause, JoinType joinType, string entityName);
}
public interface NHibernate.Impl.ITranslator {
    [ObsoleteAttribute("Use GetQueryLoader extension method instead.")]
public Loader Loader { get; }
    public IType[] ReturnTypes { get; }
    public String[] ReturnAliases { get; }
    public ICollection`1<string> QuerySpaces { get; }
    public abstract virtual Loader get_Loader();
    public abstract virtual IType[] get_ReturnTypes();
    public abstract virtual String[] get_ReturnAliases();
    public abstract virtual ICollection`1<string> get_QuerySpaces();
}
public interface NHibernate.Impl.ITranslatorWithCustomizableLoader {
    public ILoader QueryLoader { get; }
    public abstract virtual ILoader get_QueryLoader();
}
public enum NHibernate.Impl.LambdaSubqueryType : Enum {
    public int value__;
    public static LambdaSubqueryType Exact;
    public static LambdaSubqueryType All;
    public static LambdaSubqueryType Some;
}
public static class NHibernate.Impl.MessageHelper : object {
    public static string InfoString(Type clazz, object id);
    public static string InfoString(IEntityPersister persister, object id, ISessionFactoryImplementor factory);
    public static string InfoString(IEntityPersister persister, object id, IType identifierType, ISessionFactoryImplementor factory);
    public static string InfoString(IEntityPersister persister, Object[] ids, ISessionFactoryImplementor factory);
    public static string InfoString(IEntityPersister persister, object id);
    public static string InfoString(IEntityPersister persister);
    public static string InfoString(ICollectionPersister persister, object id);
    internal static string CollectionInfoString(ICollectionPersister persister, object id);
    public static string InfoString(string entityName, string propertyName, object key);
    internal static string CollectionInfoString(ICollectionPersister persister, IPersistentCollection collection, object collectionKey, ISessionImplementor session);
    public static string InfoString(ICollectionPersister persister, object id, ISessionFactoryImplementor factory);
    internal static string CollectionInfoString(ICollectionPersister persister, object id, ISessionFactoryImplementor factory);
    private static void AddIdToCollectionInfoString(ICollectionPersister persister, object id, ISessionFactoryImplementor factory, StringBuilder s);
    public static string InfoString(string entityName, object id);
}
[ObsoleteAttribute("Use Multi.IQueryBatch instead, obtainable with ISession.CreateQueryBatch.")]
public class NHibernate.Impl.MultiCriteriaImpl : object {
    private static INHibernateLogger log;
    private List`1<ICriteria> criteriaQueries;
    private List`1<Type> resultCollectionGenericType;
    private SessionImpl session;
    private ISessionFactoryImplementor factory;
    private List`1<CriteriaQueryTranslator> translators;
    private List`1<QueryParameters> parameters;
    private List`1<CriteriaLoader> loaders;
    private List`1<int> loaderCriteriaMap;
    private Dialect dialect;
    private IList criteriaResults;
    private Dictionary`2<string, int> criteriaResultPositions;
    private bool isCacheable;
    private bool forceCacheRefresh;
    private string cacheRegion;
    private IResultTransformer resultTransformer;
    private IResultSetsCommand resultSetsCommand;
    private Nullable`1<int> _timeout;
    public SqlString SqlString { get; }
    internal MultiCriteriaImpl(SessionImpl session, ISessionFactoryImplementor factory);
    private static MultiCriteriaImpl();
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiCriteriaImpl/<ListAsync>d__0")]
public sealed virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiCriteriaImpl/<ListUsingQueryCacheAsync>d__1")]
private Task`1<IList> ListUsingQueryCacheAsync(HashSet`1<string> querySpaces, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiCriteriaImpl/<ListIgnoreQueryCacheAsync>d__2")]
private Task`1<IList> ListIgnoreQueryCacheAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiCriteriaImpl/<DoListAsync>d__3")]
private Task`1<IList> DoListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiCriteriaImpl/<GetResultsFromDatabaseAsync>d__4")]
private Task GetResultsFromDatabaseAsync(IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiCriteriaImpl/<GetResultAsync>d__5")]
public sealed virtual Task`1<object> GetResultAsync(string key, CancellationToken cancellationToken);
    public SqlString get_SqlString();
    public sealed virtual IList List();
    private IList ListUsingQueryCache(HashSet`1<string> querySpaces);
    private IList ListIgnoreQueryCache();
    protected virtual IList GetResultList(IList results);
    private IList DoList();
    private void CombineCriteriaQueries();
    private void GetResultsFromDatabase(IList results);
    private void CreateCriteriaLoaders();
    public sealed virtual IMultiCriteria Add(Type resultGenericListType, ICriteria criteria);
    public sealed virtual IMultiCriteria Add(ICriteria criteria);
    public sealed virtual IMultiCriteria Add(string key, ICriteria criteria);
    public sealed virtual IMultiCriteria Add(DetachedCriteria detachedCriteria);
    public sealed virtual IMultiCriteria Add(string key, DetachedCriteria detachedCriteria);
    public sealed virtual IMultiCriteria Add(ICriteria criteria);
    public sealed virtual IMultiCriteria Add(string key, ICriteria criteria);
    public sealed virtual IMultiCriteria Add(DetachedCriteria detachedCriteria);
    public sealed virtual IMultiCriteria Add(string key, DetachedCriteria detachedCriteria);
    public sealed virtual IMultiCriteria Add(Type resultGenericListType, IQueryOver queryOver);
    public sealed virtual IMultiCriteria Add(IQueryOver`1<T> queryOver);
    public sealed virtual IMultiCriteria Add(IQueryOver queryOver);
    public sealed virtual IMultiCriteria Add(string key, IQueryOver`1<T> queryOver);
    public sealed virtual IMultiCriteria Add(string key, IQueryOver queryOver);
    public sealed virtual IMultiCriteria SetCacheable(bool cachable);
    public sealed virtual IMultiCriteria ForceCacheRefresh(bool forceRefresh);
    public sealed virtual IMultiCriteria SetResultTransformer(IResultTransformer resultTransformer);
    public sealed virtual object GetResult(string key);
    public sealed virtual IMultiCriteria SetCacheRegion(string cacheRegion);
    private QueryParameters CreateCombinedQueryParameters();
    private void ThrowIfKeyAlreadyExists(string key);
    public IMultiCriteria SetTimeout(int timeout);
}
[ObsoleteAttribute("This class has no more usage and will be removed in a future version")]
internal class NHibernate.Impl.MultipleQueriesCacheAssembler : object {
    private IList assemblersList;
    public MultipleQueriesCacheAssembler(IList assemblers);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultipleQueriesCacheAssembler/<DisassembleAsync>d__0")]
public sealed virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultipleQueriesCacheAssembler/<AssembleAsync>d__1")]
public sealed virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public sealed virtual Task BeforeAssembleAsync(object cached, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultipleQueriesCacheAssembler/<GetResultFromQueryCacheAsync>d__3")]
public Task`1<IList> GetResultFromQueryCacheAsync(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces, IQueryCache queryCache, QueryKey key, CancellationToken cancellationToken);
    public sealed virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public sealed virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public sealed virtual void BeforeAssemble(object cached, ISessionImplementor session);
    public IList GetResultFromQueryCache(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces, IQueryCache queryCache, QueryKey key);
}
[ObsoleteAttribute("Use Multi.QueryBatch instead, obtainable with ISession.CreateQueryBatch.")]
public class NHibernate.Impl.MultiQueryImpl : object {
    private static INHibernateLogger log;
    private List`1<IQuery> queries;
    private List`1<ITranslator> translators;
    private List`1<int> translatorQueryMap;
    private List`1<Type> resultCollectionGenericType;
    private List`1<QueryParameters> parameters;
    private IList queryResults;
    private Dictionary`2<string, int> queryResultPositions;
    private string cacheRegion;
    private Nullable`1<int> _timeout;
    private bool isCacheable;
    private ISessionImplementor session;
    private IResultTransformer resultTransformer;
    private Dialect dialect;
    private bool forceCacheRefresh;
    private QueryParameters combinedParameters;
    private FlushMode flushMode;
    private FlushMode sessionFlushMode;
    private IResultSetsCommand resultSetsCommand;
    protected SqlString SqlString { get; }
    private IList`1<ITranslator> Translators { get; }
    private List`1<QueryParameters> Parameters { get; }
    public MultiQueryImpl(ISessionImplementor session);
    private static MultiQueryImpl();
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiQueryImpl/<ListAsync>d__0")]
public sealed virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiQueryImpl/<DoListAsync>d__1")]
protected Task`1<List`1<object>> DoListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiQueryImpl/<GetResultAsync>d__2")]
public sealed virtual Task`1<object> GetResultAsync(string key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiQueryImpl/<ListIgnoreQueryCacheAsync>d__3")]
private Task`1<IList> ListIgnoreQueryCacheAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.MultiQueryImpl/<ListUsingQueryCacheAsync>d__4")]
private Task`1<IList> ListUsingQueryCacheAsync(HashSet`1<string> querySpaces, CancellationToken cancellationToken);
    public sealed virtual IMultiQuery SetResultTransformer(IResultTransformer transformer);
    public sealed virtual IMultiQuery SetForceCacheRefresh(bool cacheRefresh);
    public sealed virtual IMultiQuery SetTimeout(int timeout);
    public sealed virtual IMultiQuery SetParameter(string name, object val, IType type);
    public sealed virtual IMultiQuery SetParameter(string name, object val);
    public sealed virtual IMultiQuery SetParameterList(string name, IEnumerable vals, IType type);
    public sealed virtual IMultiQuery SetParameterList(string name, IEnumerable vals);
    public sealed virtual IMultiQuery SetAnsiString(string name, string val);
    public sealed virtual IMultiQuery SetBinary(string name, Byte[] val);
    public sealed virtual IMultiQuery SetBoolean(string name, bool val);
    public sealed virtual IMultiQuery SetByte(string name, byte val);
    public sealed virtual IMultiQuery SetCharacter(string name, char val);
    public sealed virtual IMultiQuery SetDateTime(string name, DateTime val);
    public sealed virtual IMultiQuery SetDateTimeNoMs(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead, it uses DateTime2 with dialects supporting it.")]
public sealed virtual IMultiQuery SetDateTime2(string name, DateTime val);
    public sealed virtual IMultiQuery SetTimeSpan(string name, TimeSpan val);
    public sealed virtual IMultiQuery SetTimeAsTimeSpan(string name, TimeSpan val);
    public sealed virtual IMultiQuery SetDateTimeOffset(string name, DateTimeOffset val);
    public sealed virtual IMultiQuery SetDecimal(string name, decimal val);
    public sealed virtual IMultiQuery SetDouble(string name, double val);
    public sealed virtual IMultiQuery SetEntity(string name, object val);
    public sealed virtual IMultiQuery SetEnum(string name, Enum val);
    public sealed virtual IMultiQuery SetInt16(string name, short val);
    public sealed virtual IMultiQuery SetInt32(string name, int val);
    public sealed virtual IMultiQuery SetInt64(string name, long val);
    public sealed virtual IMultiQuery SetSingle(string name, float val);
    public sealed virtual IMultiQuery SetString(string name, string val);
    public sealed virtual IMultiQuery SetGuid(string name, Guid val);
    public sealed virtual IMultiQuery SetTime(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public sealed virtual IMultiQuery SetTimestamp(string name, DateTime val);
    public sealed virtual IMultiQuery AddNamedQuery(string key, string namedQuery);
    public sealed virtual IMultiQuery Add(Type resultGenericListType, IQuery query);
    public sealed virtual IMultiQuery Add(string key, IQuery query);
    public sealed virtual IMultiQuery Add(IQuery query);
    public sealed virtual IMultiQuery Add(string key, string hql);
    public sealed virtual IMultiQuery Add(string hql);
    public sealed virtual IMultiQuery AddNamedQuery(string queryName);
    public sealed virtual IMultiQuery AddNamedQuery(string key, string namedQuery);
    public sealed virtual IMultiQuery Add(IQuery query);
    public sealed virtual IMultiQuery Add(string key, IQuery query);
    public sealed virtual IMultiQuery Add(string hql);
    public sealed virtual IMultiQuery Add(string key, string hql);
    public sealed virtual IMultiQuery AddNamedQuery(string queryName);
    public sealed virtual IMultiQuery SetCacheable(bool cacheable);
    public sealed virtual IMultiQuery SetCacheRegion(string region);
    public sealed virtual IList List();
    public sealed virtual IMultiQuery SetFlushMode(FlushMode mode);
    protected void Before();
    protected void After();
    protected virtual IList GetResultList(IList results);
    private IList GetTransformedResults(IList source);
    protected List`1<object> DoList();
    protected SqlString get_SqlString();
    private void AggregateQueriesInformation();
    public sealed virtual object GetResult(string key);
    public virtual string ToString();
    private IList ListIgnoreQueryCache();
    private IList ListUsingQueryCache(HashSet`1<string> querySpaces);
    private IList`1<ITranslator> get_Translators();
    private QueryParameters CreateCombinedQueryParameters();
    private List`1<QueryParameters> get_Parameters();
    private void ThrowIfKeyAlreadyExists(string key);
    private int AddQueryForLaterExecutionAndReturnIndexOfQuery(Type resultGenericListType, IQuery query);
}
internal class NHibernate.Impl.NonContextualConnectionAccess : object {
    private ISessionFactoryImplementor _sessionFactory;
    public string ConnectionString { get; }
    public NonContextualConnectionAccess(ISessionFactoryImplementor connectionProvider);
    public sealed virtual Task`1<DbConnection> GetConnectionAsync(CancellationToken cancellationToken);
    public sealed virtual string get_ConnectionString();
    public sealed virtual DbConnection GetConnection();
    public sealed virtual void CloseConnection(DbConnection connection);
}
internal class NHibernate.Impl.ParameterDetector : object {
    private List`1<IASTNode> _nodes;
    private HashSet`1<string> _parameterNames;
    private IASTNode _tree;
    private ParameterDetector(IASTNode tree, HashSet`1<string> parameterNames);
    public sealed virtual void Visit(IASTNode node);
    public static IList`1<IASTNode> LocateParameters(IASTNode tree, HashSet`1<string> parameterNames);
    private List`1<IASTNode> LocateParameters();
}
internal class NHibernate.Impl.ParameterExpander : object {
    private Dictionary`2<string, IList`1<string>> _map;
    private IASTNode _tree;
    private ParameterExpander(IASTNode tree, Dictionary`2<string, IList`1<string>> map);
    public static IASTNode Expand(IASTNode tree, Dictionary`2<string, IList`1<string>> map);
    private IASTNode Expand();
    private static IASTNode DuplicateTree(IASTNode ast, IDictionary`2<IASTNode, IEnumerable`1<IASTNode>> nodeMapping);
}
public class NHibernate.Impl.Printer : object {
    private ISessionFactoryImplementor _factory;
    private static INHibernateLogger log;
    public Printer(ISessionFactoryImplementor factory);
    private static Printer();
    public string ToString(object entity);
    public string ToString(IType[] types, Object[] values);
    public string ToString(IDictionary`2<string, TypedValue> namedTypedValues);
    internal string ToString(IEnumerable`1<KeyValuePair`2<string, TypedValue>> namedTypedValues);
    public void ToString(Object[] entities);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, string> <ToString>b__5_0(KeyValuePair`2<string, TypedValue> ntv);
}
public class NHibernate.Impl.QueryImpl : AbstractQueryImpl2 {
    public QueryImpl(string queryString, FlushMode flushMode, ISessionImplementor session, ParameterMetadata parameterMetadata);
    public QueryImpl(string queryString, ISessionImplementor session, ParameterMetadata parameterMetadata);
    protected virtual IQueryExpression ExpandParameters(IDictionary`2<string, TypedValue> namedParams);
}
public class NHibernate.Impl.SessionFactoryImpl : object {
    private static INHibernateLogger log;
    private static IIdentifierGenerator UuidGenerator;
    private ConcurrentDictionary`2<string, CacheBase> _allCacheRegions;
    private IDictionary`2<string, IClassMetadata> classMetadata;
    private IDictionary`2<string, ICollectionMetadata> collectionMetadata;
    private Dictionary`2<string, ICollectionPersister> collectionPersisters;
    private ILookup`2<string, ICollectionPersister> collectionPersistersSpaces;
    private IDictionary`2<string, ISet`1<string>> collectionRolesByEntityParticipant;
    private ICurrentSessionContext currentSessionContext;
    private IEntityNotFoundDelegate entityNotFoundDelegate;
    private IDictionary`2<string, IEntityPersister> entityPersisters;
    private ILookup`2<string, IEntityPersister> entityPersistersSpaces;
    private IDictionary`2<Type, string> implementorToEntityName;
    private EventListeners eventListeners;
    private Dictionary`2<string, FilterDefinition> filters;
    private Dictionary`2<string, IIdentifierGenerator> identifierGenerators;
    private Dictionary`2<string, string> imports;
    private IInterceptor interceptor;
    private string name;
    private Dictionary`2<string, NamedQueryDefinition> namedQueries;
    private Dictionary`2<string, NamedSQLQueryDefinition> namedSqlQueries;
    private IDictionary`2<string, string> properties;
    private IQueryCache queryCache;
    private ConcurrentDictionary`2<string, Lazy`1<IQueryCache>> queryCaches;
    private SchemaExport schemaExport;
    private Settings settings;
    private SQLFunctionRegistry sqlFunctionRegistry;
    private Dictionary`2<string, ResultSetMappingDefinition> sqlResultSetMappings;
    private UpdateTimestampsCache updateTimestampsCache;
    private ConcurrentDictionary`2<string, String[]> entityNameImplementorsMap;
    private string uuid;
    private bool disposed;
    private bool isClosed;
    private QueryPlanCache queryPlanCache;
    private StatisticsImpl statistics;
    public EventListeners EventListeners { get; }
    public Dialect Dialect { get; }
    public IInterceptor Interceptor { get; }
    public ITransactionFactory TransactionFactory { get; }
    public ISQLExceptionConverter SQLExceptionConverter { get; }
    public IConnectionProvider ConnectionProvider { get; }
    public bool IsClosed { get; }
    public UpdateTimestampsCache UpdateTimestampsCache { get; }
    public IStatisticsImplementor StatisticsImplementor { get; }
    public IQueryCache QueryCache { get; }
    public ICollection`1<string> DefinedFilterNames { get; }
    public Settings Settings { get; }
    public IStatistics Statistics { get; }
    public ICurrentSessionContext CurrentSessionContext { get; }
    public SQLFunctionRegistry SQLFunctionRegistry { get; }
    public IEntityNotFoundDelegate EntityNotFoundDelegate { get; }
    public QueryPlanCache QueryPlanCache { get; }
    public string Name { get; }
    public string Uuid { get; }
    public SessionFactoryImpl(Configuration cfg, IMapping mapping, Settings settings, EventListeners listeners);
    private static SessionFactoryImpl();
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionFactoryImpl/<CloseAsync>d__0")]
public sealed virtual Task CloseAsync(CancellationToken cancellationToken);
    public sealed virtual Task EvictAsync(Type persistentClass, object id, CancellationToken cancellationToken);
    public sealed virtual Task EvictAsync(Type persistentClass, CancellationToken cancellationToken);
    public Task EvictAsync(IEnumerable`1<Type> persistentClasses, CancellationToken cancellationToken);
    public sealed virtual Task EvictEntityAsync(string entityName, CancellationToken cancellationToken);
    public Task EvictEntityAsync(IEnumerable`1<string> entityNames, CancellationToken cancellationToken);
    public sealed virtual Task EvictEntityAsync(string entityName, object id, CancellationToken cancellationToken);
    public Task EvictEntityAsync(string entityName, object id, string tenantIdentifier, CancellationToken cancellationToken);
    public sealed virtual Task EvictCollectionAsync(string roleName, object id, CancellationToken cancellationToken);
    public Task EvictCollectionAsync(string roleName, object id, string tenantIdentifier, CancellationToken cancellationToken);
    public sealed virtual Task EvictCollectionAsync(string roleName, CancellationToken cancellationToken);
    public Task EvictCollectionAsync(IEnumerable`1<string> roleNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionFactoryImpl/<EvictQueriesAsync>d__12")]
public sealed virtual Task EvictQueriesAsync(CancellationToken cancellationToken);
    public sealed virtual Task EvictQueriesAsync(string cacheRegion, CancellationToken cancellationToken);
    private IQueryCache BuildQueryCache(string queryCacheName);
    private ICacheConcurrencyStrategy GetCacheConcurrencyStrategy(string cacheRegion, string strategy, bool isMutable, string entityName, Dictionary`2<Tuple`2<string, string>, ICacheConcurrencyStrategy> caches);
    public EventListeners get_EventListeners();
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    public sealed virtual ISessionBuilder WithOptions();
    public sealed virtual ISession OpenSession();
    [ObsoleteAttribute("Please use WithOptions instead.")]
public sealed virtual ISession OpenSession(DbConnection connection);
    [ObsoleteAttribute("Please use WithOptions instead.")]
public sealed virtual ISession OpenSession(DbConnection connection, IInterceptor sessionLocalInterceptor);
    [ObsoleteAttribute("Please use WithOptions instead.")]
public sealed virtual ISession OpenSession(IInterceptor sessionLocalInterceptor);
    [ObsoleteAttribute("Please use WithOptions instead.")]
public sealed virtual ISession OpenSession(DbConnection connection, bool flushBeforeCompletionEnabled, bool autoCloseSessionEnabled, ConnectionReleaseMode connectionReleaseMode);
    public sealed virtual IStatelessSessionBuilder WithStatelessOptions();
    public sealed virtual IStatelessSession OpenStatelessSession();
    public sealed virtual IStatelessSession OpenStatelessSession(DbConnection connection);
    public sealed virtual IEntityPersister GetEntityPersister(string entityName);
    public sealed virtual IEntityPersister TryGetEntityPersister(string entityName);
    public sealed virtual ICollectionPersister GetCollectionPersister(string role);
    public sealed virtual ISet`1<string> GetCollectionRolesByEntityParticipant(string entityName);
    public ISet`1<IEntityPersister> GetEntityPersisters(ISet`1<string> spaces);
    public ISet`1<ICollectionPersister> GetCollectionPersisters(ISet`1<string> spaces);
    public sealed virtual Dialect get_Dialect();
    public sealed virtual IInterceptor get_Interceptor();
    public sealed virtual ITransactionFactory get_TransactionFactory();
    public sealed virtual ISQLExceptionConverter get_SQLExceptionConverter();
    public sealed virtual NamedQueryDefinition GetNamedQuery(string queryName);
    public sealed virtual NamedSQLQueryDefinition GetNamedSQLQuery(string queryName);
    public sealed virtual IType GetIdentifierType(string className);
    public sealed virtual string GetIdentifierPropertyName(string className);
    public sealed virtual IType[] GetReturnTypes(string queryString);
    public sealed virtual String[] GetReturnAliases(string queryString);
    public sealed virtual IClassMetadata GetClassMetadata(Type persistentClass);
    public sealed virtual IClassMetadata GetClassMetadata(string entityName);
    public sealed virtual ICollectionMetadata GetCollectionMetadata(string roleName);
    public sealed virtual String[] GetImplementors(string entityOrClassName);
    private static bool IsMatchingImplementor(string entityOrClassName, Type entityClass, IQueryable implementor);
    public sealed virtual string GetImportedClassName(string className);
    public sealed virtual IDictionary`2<string, IClassMetadata> GetAllClassMetadata();
    public sealed virtual IDictionary`2<string, ICollectionMetadata> GetAllCollectionMetadata();
    public sealed virtual void Dispose();
    private void CheckNotClosed();
    public sealed virtual void Close();
    public sealed virtual void Evict(Type persistentClass, object id);
    public sealed virtual void Evict(Type persistentClass);
    public void Evict(IEnumerable`1<Type> persistentClasses);
    public sealed virtual void EvictEntity(string entityName);
    public void EvictEntity(IEnumerable`1<string> entityNames);
    public sealed virtual void EvictEntity(string entityName, object id);
    public void EvictEntity(string entityName, object id, string tenantIdentifier);
    public sealed virtual void EvictCollection(string roleName, object id);
    public void EvictCollection(string roleName, object id, string tenantIdentifier);
    private CacheKey GenerateCacheKeyForEvict(object id, IType type, string entityOrRoleName, string tenantIdentifier);
    public sealed virtual void EvictCollection(string roleName);
    public void EvictCollection(IEnumerable`1<string> roleNames);
    public sealed virtual IType GetReferencedPropertyType(string className, string propertyName);
    public sealed virtual bool HasNonIdentifierPropertyNamedId(string className);
    public sealed virtual IConnectionProvider get_ConnectionProvider();
    public sealed virtual bool get_IsClosed();
    public sealed virtual UpdateTimestampsCache get_UpdateTimestampsCache();
    public sealed virtual IDictionary`2<string, ICache> GetAllSecondLevelCacheRegions();
    public sealed virtual ICache GetSecondLevelCacheRegion(string regionName);
    private CacheBase GetCache(string cacheRegion);
    public sealed virtual IStatisticsImplementor get_StatisticsImplementor();
    public sealed virtual IQueryCache get_QueryCache();
    public sealed virtual IQueryCache GetQueryCache(string cacheRegion);
    public sealed virtual void EvictQueries();
    public sealed virtual void EvictQueries(string cacheRegion);
    public sealed virtual IIdentifierGenerator GetIdentifierGenerator(string rootEntityName);
    public sealed virtual ResultSetMappingDefinition GetResultSetMapping(string resultSetName);
    public sealed virtual FilterDefinition GetFilterDefinition(string filterName);
    public sealed virtual ICollection`1<string> get_DefinedFilterNames();
    public sealed virtual Settings get_Settings();
    public sealed virtual ISession GetCurrentSession();
    public sealed virtual IStatistics get_Statistics();
    public sealed virtual ICurrentSessionContext get_CurrentSessionContext();
    public sealed virtual SQLFunctionRegistry get_SQLFunctionRegistry();
    public sealed virtual IEntityNotFoundDelegate get_EntityNotFoundDelegate();
    public sealed virtual QueryPlanCache get_QueryPlanCache();
    private static void LogEvict(string tenantIdentifier, string infoString);
    private void Init();
    private IDictionary`2<string, HibernateException> CheckNamedQueries();
    private ICurrentSessionContext BuildCurrentSessionContext();
    public sealed virtual string TryGetGuessEntityName(Type implementor);
    public string get_Name();
    public string get_Uuid();
    [CompilerGeneratedAttribute]
private IQueryCache <.ctor>b__50_8();
    [CompilerGeneratedAttribute]
private CacheBase <GetCache>b__118_0(string cr);
    [CompilerGeneratedAttribute]
private Lazy`1<IQueryCache> <GetQueryCache>b__123_0(string cr);
}
public static class NHibernate.Impl.SessionFactoryObjectFactory : object {
    private static INHibernateLogger log;
    private static IDictionary`2<string, ISessionFactory> Instances;
    private static IDictionary`2<string, ISessionFactory> NamedInstances;
    private static SessionFactoryObjectFactory();
    public static void AddInstance(string uid, string name, ISessionFactory instance, IDictionary`2<string, string> properties);
    public static void RemoveInstance(string uid, string name, IDictionary`2<string, string> properties);
    public static ISessionFactory GetNamedInstance(string name);
    public static ISessionFactory GetInstance(string uid);
}
public class NHibernate.Impl.SessionIdLoggingContext : object {
    private static Lazy`1<AsyncLocal`1<Nullable`1<Guid>>> _currentSessionId;
    private Nullable`1<Guid> _oldSessionId;
    private bool _hasChanged;
    public static Nullable`1<Guid> SessionId { get; public set; }
    [ObsoleteAttribute("Please use SessionIdLoggingContext.CreateOrNull instead.")]
public SessionIdLoggingContext(Guid id);
    private SessionIdLoggingContext(Guid newId, Nullable`1<Guid> oldId);
    private static SessionIdLoggingContext();
    public static IDisposable CreateOrNull(Guid id);
    public static Nullable`1<Guid> get_SessionId();
    public static void set_SessionId(Nullable`1<Guid> value);
    public sealed virtual void Dispose();
}
public class NHibernate.Impl.SessionImpl : AbstractSessionImpl {
    private static INHibernateLogger log;
    private CacheMode cacheMode;
    [ObsoleteAttribute]
private FutureCriteriaBatch futureCriteriaBatch;
    [ObsoleteAttribute]
private FutureQueryBatch futureQueryBatch;
    private EventListeners listeners;
    private ActionQueue actionQueue;
    private int _suspendAutoFlushCount;
    private IDictionary`2<string, IFilter> enabledFilters;
    private List`1<string> enabledFilterNames;
    private StatefulPersistenceContext persistenceContext;
    private bool autoCloseSessionEnabled;
    private ConnectionReleaseMode connectionReleaseMode;
    private static Object[] NoArgs;
    private static IType[] NoTypes;
    private string fetchProfile;
    private IDisposable _context;
    [ObsoleteAttribute("Replaced by QueryBatch")]
public FutureCriteriaBatch FutureCriteriaBatch { get; protected internal set; }
    [ObsoleteAttribute("Replaced by QueryBatch")]
public FutureQueryBatch FutureQueryBatch { get; protected internal set; }
    public ConnectionReleaseMode ConnectionReleaseMode { get; }
    public bool IsAutoCloseSessionEnabled { get; }
    public bool ShouldAutoClose { get; }
    public bool IsOpen { get; }
    public ActionQueue ActionQueue { get; }
    public bool AutoFlushSuspended { get; }
    [ObsoleteAttribute("Please use FlushMode instead.")]
public bool FlushBeforeCompletionEnabled { get; }
    public bool IsEventSource { get; }
    public IPersistenceContext PersistenceContext { get; }
    public ISessionFactory SessionFactory { get; }
    public IDictionary`2<string, IFilter> EnabledFilters { get; }
    public ISessionStatistics Statistics { get; }
    public EventListeners Listeners { get; }
    public CacheMode CacheMode { get; public set; }
    public string FetchProfile { get; public set; }
    public bool DefaultReadOnly { get; public set; }
    private SessionImpl(SerializationInfo info, StreamingContext context);
    internal SessionImpl(SessionFactoryImpl factory, ISessionCreationOptions options);
    private static SessionImpl();
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<AfterTransactionCompletionAsync>d__0")]
public virtual Task AfterTransactionCompletionAsync(bool success, ITransaction tx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<SaveAsync>d__1")]
public sealed virtual Task`1<object> SaveAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<SaveAsync>d__2")]
public sealed virtual Task`1<object> SaveAsync(string entityName, object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<SaveAsync>d__3")]
public sealed virtual Task SaveAsync(string entityName, object obj, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<SaveAsync>d__4")]
public sealed virtual Task SaveAsync(object obj, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<DeleteAsync>d__5")]
public sealed virtual Task DeleteAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<DeleteAsync>d__6")]
public sealed virtual Task DeleteAsync(string entityName, object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<UpdateAsync>d__7")]
public sealed virtual Task UpdateAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<UpdateAsync>d__8")]
public sealed virtual Task UpdateAsync(string entityName, object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<UpdateAsync>d__9")]
public sealed virtual Task UpdateAsync(string entityName, object obj, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<SaveOrUpdateAsync>d__10")]
public sealed virtual Task SaveOrUpdateAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<SaveOrUpdateAsync>d__11")]
public sealed virtual Task SaveOrUpdateAsync(string entityName, object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<SaveOrUpdateAsync>d__12")]
public sealed virtual Task SaveOrUpdateAsync(string entityName, object obj, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<UpdateAsync>d__13")]
public sealed virtual Task UpdateAsync(object obj, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FindAsync>d__14")]
private Task`1<IList> FindAsync(string query, Object[] values, IType[] types, CancellationToken cancellationToken);
    public virtual Task ListAsync(IQueryExpression queryExpression, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    protected virtual Task ListFilterAsync(object collection, IQueryExpression queryExpression, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ListAsync>d__17")]
private Task ListAsync(IQueryExpression queryExpression, QueryParameters queryParameters, IList results, object filterConnection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<GetQueriesAsync>d__18")]
[ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public virtual Task`1<IQueryTranslator[]> GetQueriesAsync(IQueryExpression query, bool scalar, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<EnumerableAsync>d__19`1")]
public virtual Task`1<IEnumerable`1<T>> EnumerableAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<EnumerableAsync>d__20")]
public virtual Task`1<IEnumerable> EnumerableAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    public sealed virtual Task`1<int> DeleteAsync(string query, CancellationToken cancellationToken);
    public sealed virtual Task`1<int> DeleteAsync(string query, object value, IType type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<DeleteAsync>d__23")]
public sealed virtual Task`1<int> DeleteAsync(string query, Object[] values, IType[] types, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<LockAsync>d__24")]
public sealed virtual Task LockAsync(object obj, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<LockAsync>d__25")]
public sealed virtual Task LockAsync(string entityName, object obj, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<CreateFilterAsync>d__26")]
public sealed virtual Task`1<IQuery> CreateFilterAsync(object collection, string queryString, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<CreateFilterAsync>d__27")]
public virtual Task`1<IQuery> CreateFilterAsync(object collection, IQueryExpression queryExpression, CancellationToken cancellationToken);
    private Task`1<IQueryExpressionPlan> GetFilterQueryPlanAsync(object collection, IQueryExpression queryExpression, QueryParameters parameters, bool shallow, CancellationToken cancellationToken);
    private Task`1<IQueryExpressionPlan> GetFilterQueryPlanAsync(object collection, string filter, QueryParameters parameters, bool shallow, CancellationToken cancellationToken);
    private Task`1<IQueryExpressionPlan> GetFilterQueryPlanAsync(object collection, QueryParameters parameters, bool shallow, string filter, IQueryExpression queryExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ForceFlushAsync>d__31")]
public sealed virtual Task ForceFlushAsync(EntityEntry entityEntry, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<MergeAsync>d__32")]
public sealed virtual Task MergeAsync(string entityName, object obj, IDictionary copiedAlready, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<PersistAsync>d__33")]
public sealed virtual Task PersistAsync(string entityName, object obj, IDictionary createdAlready, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<PersistOnFlushAsync>d__34")]
public sealed virtual Task PersistOnFlushAsync(string entityName, object obj, IDictionary copiedAlready, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<RefreshAsync>d__35")]
public sealed virtual Task RefreshAsync(object obj, IDictionary refreshedAlready, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<DeleteAsync>d__36")]
public sealed virtual Task DeleteAsync(string entityName, object child, bool isCascadeDeleteEnabled, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<MergeAsync>d__37")]
public sealed virtual Task`1<object> MergeAsync(string entityName, object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<MergeAsync>d__38`1")]
public sealed virtual Task`1<T> MergeAsync(T entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<MergeAsync>d__39`1")]
public sealed virtual Task`1<T> MergeAsync(string entityName, T entity, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> MergeAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<PersistAsync>d__41")]
public sealed virtual Task PersistAsync(string entityName, object obj, CancellationToken cancellationToken);
    public sealed virtual Task PersistAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<PersistOnFlushAsync>d__43")]
public Task PersistOnFlushAsync(string entityName, object obj, CancellationToken cancellationToken);
    public Task PersistOnFlushAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<GetEntityUsingInterceptorAsync>d__45")]
public virtual Task`1<object> GetEntityUsingInterceptorAsync(EntityKey key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<AutoFlushIfRequiredAsync>d__46")]
public virtual Task`1<bool> AutoFlushIfRequiredAsync(ISet`1<string> querySpaces, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<LoadAsync>d__47")]
public sealed virtual Task LoadAsync(object obj, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<LoadAsync>d__48`1")]
public sealed virtual Task`1<T> LoadAsync(object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<LoadAsync>d__49`1")]
public sealed virtual Task`1<T> LoadAsync(object id, LockMode lockMode, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> LoadAsync(Type entityClass, object id, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<LoadAsync>d__51")]
public sealed virtual Task`1<object> LoadAsync(string entityName, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<LoadAsync>d__52")]
public sealed virtual Task`1<object> LoadAsync(string entityName, object id, LockMode lockMode, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> LoadAsync(Type entityClass, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<GetAsync>d__54`1")]
public sealed virtual Task`1<T> GetAsync(object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<GetAsync>d__55`1")]
public sealed virtual Task`1<T> GetAsync(object id, LockMode lockMode, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> GetAsync(Type entityClass, object id, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> GetAsync(Type clazz, object id, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<GetAsync>d__58")]
public Task`1<object> GetAsync(string entityName, object id, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<GetAsync>d__59")]
public sealed virtual Task`1<object> GetAsync(string entityName, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<GetEntityNameAsync>d__60")]
public sealed virtual Task`1<string> GetEntityNameAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ImmediateLoadAsync>d__61")]
public virtual Task`1<object> ImmediateLoadAsync(string entityName, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<InternalLoadAsync>d__62")]
public virtual Task`1<object> InternalLoadAsync(string entityName, object id, bool eager, bool isNullable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<RefreshAsync>d__63")]
public sealed virtual Task RefreshAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<RefreshAsync>d__64")]
public sealed virtual Task RefreshAsync(object obj, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FlushAsync>d__65")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<IsDirtyAsync>d__66")]
public sealed virtual Task`1<bool> IsDirtyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<InitializeCollectionAsync>d__67")]
public virtual Task InitializeCollectionAsync(IPersistentCollection collection, bool writing, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FilterAsync>d__68")]
private Task FilterAsync(object collection, string filter, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ListFilterAsync>d__69")]
public virtual Task`1<IList> ListFilterAsync(object collection, string filter, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ListFilterAsync>d__70`1")]
public virtual Task`1<IList`1<T>> ListFilterAsync(object collection, string filter, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<EnumerableFilterAsync>d__71")]
public virtual Task`1<IEnumerable> EnumerableFilterAsync(object collection, string filter, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<EnumerableFilterAsync>d__72`1")]
public virtual Task`1<IEnumerable`1<T>> EnumerableFilterAsync(object collection, string filter, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ListAsync>d__73`1")]
public virtual Task`1<IList`1<T>> ListAsync(CriteriaImpl criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ListAsync>d__74")]
public virtual Task ListAsync(CriteriaImpl criteria, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<EvictAsync>d__75")]
public sealed virtual Task EvictAsync(object obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ListCustomQueryAsync>d__76")]
public virtual Task ListCustomQueryAsync(ICustomQuery customQuery, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ReplicateAsync>d__77")]
public sealed virtual Task ReplicateAsync(object obj, ReplicationMode replicationMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ReplicateAsync>d__78")]
public sealed virtual Task ReplicateAsync(string entityName, object obj, ReplicationMode replicationMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<BeforeTransactionCompletionAsync>d__79")]
public virtual Task BeforeTransactionCompletionAsync(ITransaction tx, CancellationToken cancellationToken);
    public virtual Task FlushBeforeTransactionCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireDeleteAsync>d__81")]
private Task FireDeleteAsync(DeleteEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireDeleteAsync>d__82")]
private Task FireDeleteAsync(DeleteEvent event, ISet`1<object> transientEntities, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireEvictAsync>d__83")]
private Task FireEvictAsync(EvictEvent evictEvent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireLoadAsync>d__84")]
private Task FireLoadAsync(LoadEvent event, LoadType loadType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireLockAsync>d__85")]
private Task FireLockAsync(LockEvent lockEvent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireMergeAsync>d__86")]
private Task`1<object> FireMergeAsync(MergeEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireMergeAsync>d__87")]
private Task FireMergeAsync(IDictionary copiedAlready, MergeEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FirePersistAsync>d__88")]
private Task FirePersistAsync(IDictionary copiedAlready, PersistEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FirePersistAsync>d__89")]
private Task FirePersistAsync(PersistEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FirePersistOnFlushAsync>d__90")]
private Task FirePersistOnFlushAsync(IDictionary copiedAlready, PersistEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FirePersistOnFlushAsync>d__91")]
private Task FirePersistOnFlushAsync(PersistEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireRefreshAsync>d__92")]
private Task FireRefreshAsync(RefreshEvent refreshEvent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireRefreshAsync>d__93")]
private Task FireRefreshAsync(IDictionary refreshedAlready, RefreshEvent refreshEvent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireReplicateAsync>d__94")]
private Task FireReplicateAsync(ReplicateEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireSaveAsync>d__95")]
private Task`1<object> FireSaveAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireSaveOrUpdateAsync>d__96")]
private Task FireSaveOrUpdateAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<FireUpdateAsync>d__97")]
private Task FireUpdateAsync(SaveOrUpdateEvent event, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ExecuteNativeUpdateAsync>d__98")]
public virtual Task`1<int> ExecuteNativeUpdateAsync(NativeSQLQuerySpecification nativeQuerySpecification, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SessionImpl/<ExecuteUpdateAsync>d__99")]
public virtual Task`1<int> ExecuteUpdateAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual FutureCriteriaBatch get_FutureCriteriaBatch();
    protected internal virtual void set_FutureCriteriaBatch(FutureCriteriaBatch value);
    public virtual FutureQueryBatch get_FutureQueryBatch();
    protected internal virtual void set_FutureQueryBatch(FutureQueryBatch value);
    public ConnectionReleaseMode get_ConnectionReleaseMode();
    public bool get_IsAutoCloseSessionEnabled();
    public bool get_ShouldAutoClose();
    public sealed virtual DbConnection Close();
    public virtual void AfterTransactionCompletion(bool success, ITransaction tx);
    private void Cleanup();
    public sealed virtual LockMode GetCurrentLockMode(object obj);
    public virtual bool get_IsOpen();
    public sealed virtual object Save(object obj);
    public sealed virtual object Save(string entityName, object obj);
    public sealed virtual void Save(string entityName, object obj, object id);
    public sealed virtual void Save(object obj, object id);
    public sealed virtual void Delete(object obj);
    public sealed virtual void Delete(string entityName, object obj);
    public sealed virtual void Update(object obj);
    public sealed virtual void Update(string entityName, object obj);
    public sealed virtual void Update(string entityName, object obj, object id);
    public sealed virtual void SaveOrUpdate(object obj);
    public sealed virtual void SaveOrUpdate(string entityName, object obj);
    public sealed virtual void SaveOrUpdate(string entityName, object obj, object id);
    public sealed virtual void Update(object obj, object id);
    private IList Find(string query, Object[] values, IType[] types);
    public virtual void CloseSessionFromSystemTransaction();
    public virtual void List(IQueryExpression queryExpression, QueryParameters queryParameters, IList results);
    protected virtual void ListFilter(object collection, IQueryExpression queryExpression, QueryParameters queryParameters, IList results);
    private void List(IQueryExpression queryExpression, QueryParameters queryParameters, IList results, object filterConnection);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public virtual IQueryTranslator[] GetQueries(IQueryExpression query, bool scalar);
    public virtual IEnumerable`1<T> Enumerable(IQueryExpression queryExpression, QueryParameters queryParameters);
    public virtual IEnumerable Enumerable(IQueryExpression queryExpression, QueryParameters queryParameters);
    public sealed virtual int Delete(string query);
    public sealed virtual int Delete(string query, object value, IType type);
    public sealed virtual int Delete(string query, Object[] values, IType[] types);
    public sealed virtual void Lock(object obj, LockMode lockMode);
    public sealed virtual void Lock(string entityName, object obj, LockMode lockMode);
    public sealed virtual IQuery CreateFilter(object collection, string queryString);
    public virtual IQuery CreateFilter(object collection, IQueryExpression queryExpression);
    private IQueryExpressionPlan GetFilterQueryPlan(object collection, IQueryExpression queryExpression, QueryParameters parameters, bool shallow);
    private IQueryExpressionPlan GetFilterQueryPlan(object collection, string filter, QueryParameters parameters, bool shallow);
    private IQueryExpressionPlan GetFilterQueryPlan(object collection, QueryParameters parameters, bool shallow, string filter, IQueryExpression queryExpression);
    private IQueryExpressionPlan GetFilterQueryPlan(string role, bool shallow, string filter, IQueryExpression queryExpression);
    [ObsoleteAttribute("Use override with persister parameter")]
public virtual object Instantiate(string clazz, object id);
    public sealed virtual ActionQueue get_ActionQueue();
    public virtual object Instantiate(IEntityPersister persister, object id);
    public sealed virtual void ForceFlush(EntityEntry entityEntry);
    public sealed virtual void Merge(string entityName, object obj, IDictionary copiedAlready);
    public sealed virtual void Persist(string entityName, object obj, IDictionary createdAlready);
    public sealed virtual void PersistOnFlush(string entityName, object obj, IDictionary copiedAlready);
    public sealed virtual void Refresh(object obj, IDictionary refreshedAlready);
    public sealed virtual void Delete(string entityName, object child, bool isCascadeDeleteEnabled, ISet`1<object> transientEntities);
    public sealed virtual bool get_AutoFlushSuspended();
    public sealed virtual IDisposable SuspendAutoFlush();
    public sealed virtual object Merge(string entityName, object obj);
    public sealed virtual T Merge(T entity);
    public sealed virtual T Merge(string entityName, T entity);
    public sealed virtual object Merge(object obj);
    public sealed virtual void Persist(string entityName, object obj);
    public sealed virtual void Persist(object obj);
    public void PersistOnFlush(string entityName, object obj);
    public void PersistOnFlush(object obj);
    public bool get_FlushBeforeCompletionEnabled();
    public virtual string BestGuessEntityName(object entity);
    public virtual string GuessEntityName(object entity);
    public virtual bool get_IsEventSource();
    public virtual object GetEntityUsingInterceptor(EntityKey key);
    public virtual IPersistenceContext get_PersistenceContext();
    public virtual bool AutoFlushIfRequired(ISet`1<string> querySpaces);
    public sealed virtual void Load(object obj, object id);
    public sealed virtual T Load(object id);
    public sealed virtual T Load(object id, LockMode lockMode);
    public sealed virtual object Load(Type entityClass, object id, LockMode lockMode);
    public sealed virtual object Load(string entityName, object id);
    public sealed virtual object Load(string entityName, object id, LockMode lockMode);
    public sealed virtual object Load(Type entityClass, object id);
    public sealed virtual T Get(object id);
    public sealed virtual T Get(object id, LockMode lockMode);
    public sealed virtual object Get(Type entityClass, object id);
    public sealed virtual object Get(Type clazz, object id, LockMode lockMode);
    public object Get(string entityName, object id, LockMode lockMode);
    public sealed virtual object Get(string entityName, object id);
    public sealed virtual string GetEntityName(object obj);
    public virtual object ImmediateLoad(string entityName, object id);
    public virtual object InternalLoad(string entityName, object id, bool eager, bool isNullable);
    public sealed virtual void Refresh(object obj);
    public sealed virtual void Refresh(object obj, LockMode lockMode);
    public virtual void Flush();
    public sealed virtual bool IsDirty();
    public sealed virtual object GetIdentifier(object obj);
    public virtual object GetContextEntityIdentifier(object obj);
    internal ICollectionPersister GetCollectionPersister(string role);
    public virtual void InitializeCollection(IPersistentCollection collection, bool writing);
    public sealed virtual DbConnection Disconnect();
    public sealed virtual void Reconnect();
    public sealed virtual void Reconnect(DbConnection conn);
    public sealed virtual void Dispose();
    private void Dispose(bool isDisposing);
    private void Filter(object collection, string filter, QueryParameters queryParameters, IList results);
    public virtual IList ListFilter(object collection, string filter, QueryParameters queryParameters);
    public virtual IList`1<T> ListFilter(object collection, string filter, QueryParameters queryParameters);
    public virtual IEnumerable EnumerableFilter(object collection, string filter, QueryParameters queryParameters);
    public virtual IEnumerable`1<T> EnumerableFilter(object collection, string filter, QueryParameters queryParameters);
    public sealed virtual ICriteria CreateCriteria();
    public sealed virtual ICriteria CreateCriteria(Type persistentClass);
    public sealed virtual ICriteria CreateCriteria(string alias);
    public sealed virtual ICriteria CreateCriteria(Type persistentClass, string alias);
    public sealed virtual ICriteria CreateCriteria(string entityName, string alias);
    public sealed virtual ICriteria CreateCriteria(string entityName);
    public sealed virtual IQueryOver`2<T, T> QueryOver();
    public sealed virtual IQueryOver`2<T, T> QueryOver(Expression`1<Func`1<T>> alias);
    public sealed virtual IQueryOver`2<T, T> QueryOver(string entityName);
    public sealed virtual IQueryOver`2<T, T> QueryOver(string entityName, Expression`1<Func`1<T>> alias);
    public virtual IList`1<T> List(CriteriaImpl criteria);
    public virtual void List(CriteriaImpl criteria, IList results);
    public sealed virtual bool Contains(object obj);
    public sealed virtual void Evict(object obj);
    public virtual void ListCustomQuery(ICustomQuery customQuery, QueryParameters queryParameters, IList results);
    public sealed virtual ISharedSessionBuilder SessionWithOptions();
    public ISharedStatelessSessionBuilder StatelessSessionWithOptions();
    public sealed virtual void Clear();
    public sealed virtual void Replicate(object obj, ReplicationMode replicationMode);
    public sealed virtual void Replicate(string entityName, object obj, ReplicationMode replicationMode);
    public sealed virtual ISessionFactory get_SessionFactory();
    public sealed virtual void CancelQuery();
    public sealed virtual IFilter GetEnabledFilter(string filterName);
    public sealed virtual IFilter EnableFilter(string filterName);
    public sealed virtual void DisableFilter(string filterName);
    public virtual object GetFilterParameterValue(string filterParameterName);
    public virtual IType GetFilterParameterType(string filterParameterName);
    public virtual IDictionary`2<string, IFilter> get_EnabledFilters();
    private String[] ParseFilterParameterName(string filterParameterName);
    [ObsoleteAttribute("Use ISession.CreateQueryBatch instead.")]
public sealed virtual IMultiQuery CreateMultiQuery();
    [ObsoleteAttribute("Use ISession.CreateQueryBatch instead.")]
public sealed virtual IMultiCriteria CreateMultiCriteria();
    public sealed virtual ISessionStatistics get_Statistics();
    public virtual void AfterTransactionBegin(ITransaction tx);
    public virtual void BeforeTransactionCompletion(ITransaction tx);
    public virtual void FlushBeforeTransactionCompletion();
    public sealed virtual ISession SetBatchSize(int batchSize);
    public sealed virtual ISessionImplementor GetSessionImplementation();
    [ObsoleteAttribute("Please use SessionWithOptions instead.")]
public sealed virtual ISession GetSession(EntityMode entityMode);
    public virtual EventListeners get_Listeners();
    public virtual CacheMode get_CacheMode();
    public virtual void set_CacheMode(CacheMode value);
    public virtual string get_FetchProfile();
    public virtual void set_FetchProfile(string value);
    public sealed virtual void SetReadOnly(object entityOrProxy, bool readOnly);
    public sealed virtual bool get_DefaultReadOnly();
    public sealed virtual void set_DefaultReadOnly(bool value);
    public sealed virtual bool IsReadOnly(object entityOrProxy);
    private void FireDelete(DeleteEvent event);
    private void FireDelete(DeleteEvent event, ISet`1<object> transientEntities);
    private void FireEvict(EvictEvent evictEvent);
    private void FireLoad(LoadEvent event, LoadType loadType);
    private void FireLock(LockEvent lockEvent);
    private object FireMerge(MergeEvent event);
    private void FireMerge(IDictionary copiedAlready, MergeEvent event);
    private void FirePersist(IDictionary copiedAlready, PersistEvent event);
    private void FirePersist(PersistEvent event);
    private void FirePersistOnFlush(IDictionary copiedAlready, PersistEvent event);
    private void FirePersistOnFlush(PersistEvent event);
    private void FireRefresh(RefreshEvent refreshEvent);
    private void FireRefresh(IDictionary refreshedAlready, RefreshEvent refreshEvent);
    private void FireReplicate(ReplicateEvent event);
    private object FireSave(SaveOrUpdateEvent event);
    private void FireSaveOrUpdate(SaveOrUpdateEvent event);
    private void FireUpdate(SaveOrUpdateEvent event);
    public virtual int ExecuteNativeUpdate(NativeSQLQuerySpecification nativeQuerySpecification, QueryParameters queryParameters);
    public virtual int ExecuteUpdate(IQueryExpression queryExpression, QueryParameters queryParameters);
    public virtual IEntityPersister GetEntityPersister(string entityName, object obj);
}
public class NHibernate.Impl.SqlQueryImpl : AbstractQueryImpl {
    private IList`1<INativeSQLQueryReturn> queryReturns;
    private ICollection`1<string> querySpaces;
    private bool callable;
    private bool autoDiscoverTypes;
    private HashSet`1<string> addedQuerySpaces;
    private List`1<IType> _flattenedTypes;
    private List`1<object> _flattenedValues;
    protected internal IDictionary`2<string, LockMode> LockModes { get; }
    public String[] ReturnAliases { get; }
    public IType[] ReturnTypes { get; }
    protected IList Values { get; }
    protected IList`1<IType> Types { get; }
    internal SqlQueryImpl(NamedSQLQueryDefinition queryDef, ISessionImplementor session, ParameterMetadata parameterMetadata);
    internal SqlQueryImpl(string sql, IList`1<INativeSQLQueryReturn> queryReturns, ICollection`1<string> querySpaces, FlushMode flushMode, bool callable, ISessionImplementor session, ParameterMetadata parameterMetadata);
    internal SqlQueryImpl(string sql, String[] returnAliases, Type[] returnClasses, LockMode[] lockModes, ISessionImplementor session, ICollection`1<string> querySpaces, FlushMode flushMode, ParameterMetadata parameterMetadata);
    internal SqlQueryImpl(string sql, String[] returnAliases, Type[] returnClasses, ISessionImplementor session, ParameterMetadata parameterMetadata);
    internal SqlQueryImpl(string sql, ISessionImplementor session, ParameterMetadata parameterMetadata);
    [AsyncStateMachineAttribute("NHibernate.Impl.SqlQueryImpl/<ListAsync>d__0")]
public virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SqlQueryImpl/<ListAsync>d__1")]
public virtual Task ListAsync(IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SqlQueryImpl/<ListAsync>d__2`1")]
public virtual Task`1<IList`1<T>> ListAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> EnumerableAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<T>> EnumerableAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.SqlQueryImpl/<ExecuteUpdateAsync>d__5")]
public virtual Task`1<int> ExecuteUpdateAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
protected internal virtual Task`1<IEnumerable`1<ITranslator>> GetTranslatorsAsync(ISessionImplementor sessionImplementor, QueryParameters queryParameters, CancellationToken cancellationToken);
    protected internal virtual IDictionary`2<string, LockMode> get_LockModes();
    private INativeSQLQueryReturn[] GetQueryReturns();
    public virtual String[] get_ReturnAliases();
    public virtual IType[] get_ReturnTypes();
    public virtual IList List();
    public virtual void List(IList results);
    public virtual IList`1<T> List();
    public NativeSQLQuerySpecification GenerateQuerySpecification(IDictionary`2<string, TypedValue> parameters);
    public virtual QueryParameters GetQueryParameters(IDictionary`2<string, TypedValue> namedParams);
    public virtual IEnumerable Enumerable();
    public virtual IEnumerable`1<T> Enumerable();
    public sealed virtual ISQLQuery AddScalar(string columnAlias, IType type);
    public sealed virtual ISQLQuery AddJoin(string alias, string path);
    public sealed virtual ISQLQuery AddEntity(Type entityClass);
    public sealed virtual ISQLQuery AddEntity(string entityName);
    public sealed virtual ISQLQuery AddEntity(string alias, string entityName);
    public sealed virtual ISQLQuery AddEntity(string alias, Type entityClass);
    public sealed virtual ISQLQuery AddJoin(string alias, string path, LockMode lockMode);
    public sealed virtual ISQLQuery AddEntity(string alias, string entityName, LockMode lockMode);
    public sealed virtual ISQLQuery AddEntity(string alias, Type entityClass, LockMode lockMode);
    public sealed virtual ISQLQuery SetResultSetMapping(string name);
    protected internal virtual void VerifyParameters();
    protected internal virtual void VerifyParameters(bool reserveFirstParameter);
    private void ComputeFlattenedParameters();
    protected virtual IList get_Values();
    protected virtual IList`1<IType> get_Types();
    public virtual Object[] ValueArray();
    public virtual IType[] TypeArray();
    public virtual IQuery SetLockMode(string alias, LockMode lockMode);
    public virtual int ExecuteUpdate();
    [IteratorStateMachineAttribute("NHibernate.Impl.SqlQueryImpl/<GetTranslators>d__54")]
protected internal virtual IEnumerable`1<ITranslator> GetTranslators(ISessionImplementor sessionImplementor, QueryParameters queryParameters);
    public sealed virtual ISynchronizableSQLQuery AddSynchronizedQuerySpace(string querySpace);
    public sealed virtual ISynchronizableSQLQuery AddSynchronizedEntityName(string entityName);
    public sealed virtual ISynchronizableSQLQuery AddSynchronizedEntityClass(Type entityType);
    public sealed virtual IReadOnlyCollection`1<string> GetSynchronizedQuerySpaces();
    [CompilerGeneratedAttribute]
private void <ComputeFlattenedParameters>g__FlattenTypesAndValues|45_0(IList`1<IType> types, IList values);
}
internal class NHibernate.Impl.SqlTranslator : object {
    private CustomLoader loader;
    public IType[] ReturnTypes { get; }
    [ObsoleteAttribute("Use QueryLoader instead.")]
public Loader Loader { get; }
    public ILoader QueryLoader { get; }
    public ICollection`1<string> QuerySpaces { get; }
    public String[] ReturnAliases { get; }
    public SqlTranslator(ISQLQuery sqlQuery, ISessionFactoryImplementor sessionFactory);
    public sealed virtual IType[] get_ReturnTypes();
    public sealed virtual Loader get_Loader();
    public sealed virtual ILoader get_QueryLoader();
    public sealed virtual ICollection`1<string> get_QuerySpaces();
    public sealed virtual String[] get_ReturnAliases();
}
public class NHibernate.Impl.StatelessSessionImpl : AbstractSessionImpl {
    private static INHibernateLogger log;
    private StatefulPersistenceContext temporaryPersistenceContext;
    private bool _isAlreadyDisposed;
    private IDisposable _context;
    public long Timestamp { get; }
    public IDictionary`2<string, IFilter> EnabledFilters { get; }
    public IInterceptor Interceptor { get; }
    public EventListeners Listeners { get; }
    public bool IsEventSource { get; }
    public IPersistenceContext PersistenceContext { get; }
    public bool IsOpen { get; }
    public FlushMode FlushMode { get; public set; }
    public CacheMode CacheMode { get; public set; }
    public string FetchProfile { get; public set; }
    [ObsoleteAttribute("Replaced by QueryBatch")]
public FutureCriteriaBatch FutureCriteriaBatch { get; protected internal set; }
    [ObsoleteAttribute("Replaced by QueryBatch")]
public FutureQueryBatch FutureQueryBatch { get; protected internal set; }
    internal StatelessSessionImpl(SessionFactoryImpl factory, ISessionCreationOptions options);
    private static StatelessSessionImpl();
    public virtual Task InitializeCollectionAsync(IPersistentCollection collection, bool writing, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<InternalLoadAsync>d__1")]
public virtual Task`1<object> InternalLoadAsync(string entityName, object id, bool eager, bool isNullable, CancellationToken cancellationToken);
    public virtual Task`1<object> ImmediateLoadAsync(string entityName, object id, CancellationToken cancellationToken);
    public virtual Task`1<IQuery> CreateFilterAsync(object collection, IQueryExpression queryExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<ListAsync>d__4")]
public virtual Task ListAsync(IQueryExpression queryExpression, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<ListAsync>d__5`1")]
public virtual Task`1<IList`1<T>> ListAsync(CriteriaImpl criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<ListAsync>d__6")]
public virtual Task ListAsync(CriteriaImpl criteria, IList results, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> EnumerableAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<T>> EnumerableAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    public virtual Task`1<IList> ListFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    protected virtual Task ListFilterAsync(object collection, IQueryExpression queryExpression, QueryParameters parameters, IList results, CancellationToken cancellationToken);
    public virtual Task`1<IList`1<T>> ListFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable> EnumerableFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<T>> EnumerableFilterAsync(object collection, string filter, QueryParameters parameters, CancellationToken cancellationToken);
    public virtual Task BeforeTransactionCompletionAsync(ITransaction tx, CancellationToken cancellationToken);
    public virtual Task FlushBeforeTransactionCompletionAsync(CancellationToken cancellationToken);
    public virtual Task AfterTransactionCompletionAsync(bool successful, ITransaction tx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<ListCustomQueryAsync>d__17")]
public virtual Task ListCustomQueryAsync(ICustomQuery customQuery, QueryParameters queryParameters, IList results, CancellationToken cancellationToken);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public virtual Task`1<IQueryTranslator[]> GetQueriesAsync(IQueryExpression query, bool scalar, CancellationToken cancellationToken);
    public virtual Task`1<object> GetEntityUsingInterceptorAsync(EntityKey key, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<ManagedFlushAsync>d__21")]
public Task ManagedFlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<ManagedCloseAsync>d__22")]
public Task ManagedCloseAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<object> InsertAsync(object entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<InsertAsync>d__24")]
public sealed virtual Task`1<object> InsertAsync(string entityName, object entity, CancellationToken cancellationToken);
    public sealed virtual Task UpdateAsync(object entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<UpdateAsync>d__26")]
public sealed virtual Task UpdateAsync(string entityName, object entity, CancellationToken cancellationToken);
    public sealed virtual Task DeleteAsync(object entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<DeleteAsync>d__28")]
public sealed virtual Task DeleteAsync(string entityName, object entity, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> GetAsync(string entityName, object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<GetAsync>d__30`1")]
public sealed virtual Task`1<T> GetAsync(object id, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<GetAsync>d__31")]
public sealed virtual Task`1<object> GetAsync(string entityName, object id, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<GetAsync>d__32`1")]
public sealed virtual Task`1<T> GetAsync(object id, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<RefreshAsync>d__33")]
public sealed virtual Task RefreshAsync(object entity, CancellationToken cancellationToken);
    public sealed virtual Task RefreshAsync(string entityName, object entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<RefreshAsync>d__35")]
public sealed virtual Task RefreshAsync(object entity, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<RefreshAsync>d__36")]
public sealed virtual Task RefreshAsync(string entityName, object entity, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<ExecuteNativeUpdateAsync>d__37")]
public virtual Task`1<int> ExecuteNativeUpdateAsync(NativeSQLQuerySpecification nativeSQLQuerySpecification, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Impl.StatelessSessionImpl/<ExecuteUpdateAsync>d__38")]
public virtual Task`1<int> ExecuteUpdateAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken);
    public virtual void InitializeCollection(IPersistentCollection collection, bool writing);
    public virtual object InternalLoad(string entityName, object id, bool eager, bool isNullable);
    public virtual object ImmediateLoad(string entityName, object id);
    public virtual long get_Timestamp();
    public virtual void CloseSessionFromSystemTransaction();
    public virtual IQuery CreateFilter(object collection, IQueryExpression queryExpression);
    public virtual void List(IQueryExpression queryExpression, QueryParameters queryParameters, IList results);
    public virtual IList`1<T> List(CriteriaImpl criteria);
    public virtual void List(CriteriaImpl criteria, IList results);
    public virtual IEnumerable Enumerable(IQueryExpression queryExpression, QueryParameters queryParameters);
    public virtual IEnumerable`1<T> Enumerable(IQueryExpression queryExpression, QueryParameters queryParameters);
    public virtual IList ListFilter(object collection, string filter, QueryParameters parameters);
    protected virtual void ListFilter(object collection, IQueryExpression queryExpression, QueryParameters parameters, IList results);
    public virtual IList`1<T> ListFilter(object collection, string filter, QueryParameters parameters);
    public virtual IEnumerable EnumerableFilter(object collection, string filter, QueryParameters parameters);
    public virtual IEnumerable`1<T> EnumerableFilter(object collection, string filter, QueryParameters parameters);
    public virtual void AfterTransactionBegin(ITransaction tx);
    public virtual void BeforeTransactionCompletion(ITransaction tx);
    public virtual void FlushBeforeTransactionCompletion();
    public virtual void AfterTransactionCompletion(bool successful, ITransaction tx);
    public virtual object GetContextEntityIdentifier(object obj);
    [ObsoleteAttribute("Use override with persister parameter")]
public virtual object Instantiate(string clazz, object id);
    public virtual object Instantiate(IEntityPersister persister, object id);
    public virtual void ListCustomQuery(ICustomQuery customQuery, QueryParameters queryParameters, IList results);
    public virtual object GetFilterParameterValue(string filterParameterName);
    public virtual IType GetFilterParameterType(string filterParameterName);
    public virtual IDictionary`2<string, IFilter> get_EnabledFilters();
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public virtual IQueryTranslator[] GetQueries(IQueryExpression query, bool scalar);
    public virtual IInterceptor get_Interceptor();
    public virtual EventListeners get_Listeners();
    public virtual bool get_IsEventSource();
    public virtual object GetEntityUsingInterceptor(EntityKey key);
    public virtual IPersistenceContext get_PersistenceContext();
    public virtual bool get_IsOpen();
    public virtual FlushMode get_FlushMode();
    public virtual void set_FlushMode(FlushMode value);
    public virtual string BestGuessEntityName(object entity);
    public virtual string GuessEntityName(object entity);
    public sealed virtual IStatelessSession SetBatchSize(int batchSize);
    public virtual void Flush();
    public void ManagedFlush();
    public virtual CacheMode get_CacheMode();
    public virtual void set_CacheMode(CacheMode value);
    public virtual string get_FetchProfile();
    public virtual void set_FetchProfile(string value);
    public sealed virtual ISessionImplementor GetSessionImplementation();
    public sealed virtual void Close();
    public void ManagedClose();
    public sealed virtual object Insert(object entity);
    public sealed virtual object Insert(string entityName, object entity);
    public sealed virtual void Update(object entity);
    public sealed virtual void Update(string entityName, object entity);
    public sealed virtual void Delete(object entity);
    public sealed virtual void Delete(string entityName, object entity);
    public sealed virtual object Get(string entityName, object id);
    public sealed virtual T Get(object id);
    public sealed virtual object Get(string entityName, object id, LockMode lockMode);
    public sealed virtual T Get(object id, LockMode lockMode);
    public sealed virtual void Refresh(object entity);
    public sealed virtual void Refresh(string entityName, object entity);
    public sealed virtual void Refresh(object entity, LockMode lockMode);
    public sealed virtual void Refresh(string entityName, object entity, LockMode lockMode);
    public sealed virtual ICriteria CreateCriteria();
    public sealed virtual ICriteria CreateCriteria(string alias);
    public sealed virtual ICriteria CreateCriteria(Type entityType);
    public sealed virtual ICriteria CreateCriteria(Type entityType, string alias);
    public sealed virtual ICriteria CreateCriteria(string entityName);
    public sealed virtual ICriteria CreateCriteria(string entityName, string alias);
    public sealed virtual IQueryOver`2<T, T> QueryOver();
    public sealed virtual IQueryOver`2<T, T> QueryOver(Expression`1<Func`1<T>> alias);
    public sealed virtual void Dispose();
    protected void Dispose(bool isDisposing);
    public virtual int ExecuteNativeUpdate(NativeSQLQuerySpecification nativeSQLQuerySpecification, QueryParameters queryParameters);
    public virtual int ExecuteUpdate(IQueryExpression queryExpression, QueryParameters queryParameters);
    public virtual FutureCriteriaBatch get_FutureCriteriaBatch();
    protected internal virtual void set_FutureCriteriaBatch(FutureCriteriaBatch value);
    public virtual FutureQueryBatch get_FutureQueryBatch();
    protected internal virtual void set_FutureQueryBatch(FutureQueryBatch value);
    public virtual IEntityPersister GetEntityPersister(string entityName, object obj);
}
[ExtensionAttribute]
public static class NHibernate.Impl.TranslatorExtensions : object {
    private static INHibernateLogger Log;
    private static bool _hasWarnedForObsoleteTranslator;
    private static TranslatorExtensions();
    [ExtensionAttribute]
public static ILoader GetQueryLoader(ITranslator translator);
}
[ObsoleteAttribute("Use Multi.IQueryBatch instead, obtainable with ISession.CreateQueryBatch.")]
public interface NHibernate.IMultiCriteria {
    public abstract virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetResultAsync(string key, CancellationToken cancellationToken);
    public abstract virtual IList List();
    public abstract virtual IMultiCriteria Add(Type resultGenericListType, ICriteria criteria);
    public abstract virtual IMultiCriteria Add(ICriteria criteria);
    public abstract virtual IMultiCriteria Add(string key, ICriteria criteria);
    public abstract virtual IMultiCriteria Add(DetachedCriteria detachedCriteria);
    public abstract virtual IMultiCriteria Add(string key, DetachedCriteria detachedCriteria);
    public abstract virtual IMultiCriteria Add(ICriteria criteria);
    public abstract virtual IMultiCriteria Add(string key, ICriteria criteria);
    public abstract virtual IMultiCriteria Add(DetachedCriteria detachedCriteria);
    public abstract virtual IMultiCriteria Add(string key, DetachedCriteria detachedCriteria);
    public abstract virtual IMultiCriteria Add(Type resultGenericListType, IQueryOver queryOver);
    public abstract virtual IMultiCriteria Add(IQueryOver`1<T> queryOver);
    public abstract virtual IMultiCriteria Add(IQueryOver queryOver);
    public abstract virtual IMultiCriteria Add(string key, IQueryOver`1<T> queryOver);
    public abstract virtual IMultiCriteria Add(string key, IQueryOver queryOver);
    public abstract virtual IMultiCriteria SetCacheable(bool cachable);
    public abstract virtual IMultiCriteria SetCacheRegion(string region);
    public abstract virtual IMultiCriteria ForceCacheRefresh(bool forceRefresh);
    public abstract virtual IMultiCriteria SetResultTransformer(IResultTransformer resultTransformer);
    public abstract virtual object GetResult(string key);
}
[ObsoleteAttribute("Use Multi.IQueryBatch instead, obtainable with ISession.CreateQueryBatch.")]
public interface NHibernate.IMultiQuery {
    public abstract virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetResultAsync(string key, CancellationToken cancellationToken);
    public abstract virtual IList List();
    public abstract virtual IMultiQuery Add(Type resultGenericListType, IQuery query);
    public abstract virtual IMultiQuery Add(IQuery query);
    public abstract virtual IMultiQuery Add(string key, IQuery query);
    public abstract virtual IMultiQuery Add(string key, string hql);
    public abstract virtual IMultiQuery Add(string hql);
    public abstract virtual IMultiQuery AddNamedQuery(string queryName);
    public abstract virtual IMultiQuery AddNamedQuery(string key, string queryName);
    public abstract virtual IMultiQuery Add(string key, IQuery query);
    public abstract virtual IMultiQuery Add(IQuery query);
    public abstract virtual IMultiQuery Add(string key, string hql);
    public abstract virtual IMultiQuery Add(string hql);
    public abstract virtual IMultiQuery AddNamedQuery(string queryName);
    public abstract virtual IMultiQuery AddNamedQuery(string key, string queryName);
    public abstract virtual IMultiQuery SetCacheable(bool cacheable);
    public abstract virtual IMultiQuery SetCacheRegion(string region);
    public abstract virtual IMultiQuery SetForceCacheRefresh(bool forceCacheRefresh);
    public abstract virtual IMultiQuery SetTimeout(int timeout);
    public abstract virtual IMultiQuery SetParameter(string name, object val, IType type);
    public abstract virtual IMultiQuery SetParameter(string name, object val);
    public abstract virtual IMultiQuery SetParameterList(string name, IEnumerable vals, IType type);
    public abstract virtual IMultiQuery SetParameterList(string name, IEnumerable vals);
    public abstract virtual IMultiQuery SetAnsiString(string name, string val);
    public abstract virtual IMultiQuery SetBinary(string name, Byte[] val);
    public abstract virtual IMultiQuery SetBoolean(string name, bool val);
    public abstract virtual IMultiQuery SetByte(string name, byte val);
    public abstract virtual IMultiQuery SetCharacter(string name, char val);
    public abstract virtual IMultiQuery SetDateTime(string name, DateTime val);
    public abstract virtual IMultiQuery SetDateTimeNoMs(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead, it uses DateTime2 with dialects supporting it.")]
public abstract virtual IMultiQuery SetDateTime2(string name, DateTime val);
    public abstract virtual IMultiQuery SetTimeSpan(string name, TimeSpan val);
    public abstract virtual IMultiQuery SetTimeAsTimeSpan(string name, TimeSpan val);
    public abstract virtual IMultiQuery SetDateTimeOffset(string name, DateTimeOffset val);
    public abstract virtual IMultiQuery SetDecimal(string name, decimal val);
    public abstract virtual IMultiQuery SetDouble(string name, double val);
    public abstract virtual IMultiQuery SetEntity(string name, object val);
    public abstract virtual IMultiQuery SetEnum(string name, Enum val);
    public abstract virtual IMultiQuery SetInt16(string name, short val);
    public abstract virtual IMultiQuery SetInt32(string name, int val);
    public abstract virtual IMultiQuery SetInt64(string name, long val);
    public abstract virtual IMultiQuery SetSingle(string name, float val);
    public abstract virtual IMultiQuery SetString(string name, string val);
    public abstract virtual IMultiQuery SetGuid(string name, Guid val);
    public abstract virtual IMultiQuery SetTime(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public abstract virtual IMultiQuery SetTimestamp(string name, DateTime val);
    public abstract virtual IMultiQuery SetFlushMode(FlushMode mode);
    public abstract virtual IMultiQuery SetResultTransformer(IResultTransformer transformer);
    public abstract virtual object GetResult(string key);
}
public interface NHibernate.INHibernateLogger {
    public abstract virtual void Log(NHibernateLogLevel logLevel, NHibernateLogValues state, Exception exception);
    public abstract virtual bool IsEnabled(NHibernateLogLevel logLevel);
}
public interface NHibernate.INHibernateLoggerFactory {
    public abstract virtual INHibernateLogger LoggerFor(string keyName);
    public abstract virtual INHibernateLogger LoggerFor(Type type);
}
public class NHibernate.InstantiationException : HibernateException {
    private Type type;
    public Type PersistentType { get; }
    public string Message { get; }
    public InstantiationException(string message, Type type);
    public InstantiationException(string message, Exception innerException, Type type);
    protected InstantiationException(SerializationInfo info, StreamingContext context);
    public Type get_PersistentType();
    public virtual string get_Message();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.Intercept.AbstractFieldInterceptor : object {
    public static object InvokeImplementation;
    private ISessionImplementor session;
    private ISet`1<string> uninitializedFields;
    private ISet`1<string> uninitializedFieldsReadOnly;
    private ISet`1<string> unwrapProxyFieldNames;
    private HashSet`1<string> loadedUnwrapProxyFieldNames;
    private string entityName;
    private Type mappedClass;
    private bool initializing;
    private bool isDirty;
    public bool IsDirty { get; }
    public ISessionImplementor Session { get; public set; }
    public bool IsInitialized { get; }
    public string EntityName { get; }
    public Type MappedClass { get; }
    [ObsoleteAttribute("Please use GetUninitializedFields extension method instead")]
public ISet`1<string> UninitializedFields { get; }
    public bool Initializing { get; }
    protected internal AbstractFieldInterceptor(ISessionImplementor session, ISet`1<string> uninitializedFields, ISet`1<string> unwrapProxyFieldNames, string entityName, Type mappedClass);
    private static AbstractFieldInterceptor();
    public sealed virtual bool get_IsDirty();
    public sealed virtual ISessionImplementor get_Session();
    public sealed virtual void set_Session(ISessionImplementor value);
    public sealed virtual bool get_IsInitialized();
    public sealed virtual bool IsInitializedField(string field);
    public sealed virtual void MarkDirty();
    public sealed virtual void ClearDirty();
    public sealed virtual string get_EntityName();
    public sealed virtual Type get_MappedClass();
    public ISet`1<string> get_UninitializedFields();
    public bool get_Initializing();
    public sealed virtual object Intercept(object target, string fieldName, object value);
    public object Intercept(object target, string fieldName, object value, bool setter);
    private bool IsUninitializedAssociation(string fieldName);
    private bool IsUninitializedProperty(string fieldName);
    private object InitializeOrGetAssociation(INHibernateProxy value, string fieldName);
    private object InitializeField(string fieldName, object target);
    public ISet`1<string> GetUninitializedFields();
}
[ObsoleteAttribute("Dynamic proxy has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Intercept.DefaultDynamicLazyFieldInterceptor : object {
    [CompilerGeneratedAttribute]
private IFieldInterceptor <FieldInterceptor>k__BackingField;
    public IFieldInterceptor FieldInterceptor { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IFieldInterceptor get_FieldInterceptor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FieldInterceptor(IFieldInterceptor value);
    public sealed virtual object Intercept(InvocationInfo info);
    private static bool IsGetFieldInterceptorCall(MethodInfo targetMethod);
    private static bool IsSetFieldInterceptorCall(MethodInfo targetMethod);
}
public class NHibernate.Intercept.DefaultFieldInterceptor : AbstractFieldInterceptor {
    public DefaultFieldInterceptor(ISessionImplementor session, ISet`1<string> uninitializedFields, ISet`1<string> unwrapProxyFieldNames, string entityName, Type mappedClass);
}
public static class NHibernate.Intercept.FieldInterceptionHelper : object {
    public static bool IsInstrumented(Type entityClass);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public static bool IsInstrumented(object entity);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public static IFieldInterceptor ExtractFieldInterceptor(object entity);
    [ObsoleteAttribute("Use IBytecodeEnhancementMetadata.InjectInterceptor method instead")]
public static IFieldInterceptor InjectFieldInterceptor(object entity, string entityName, Type mappedClass, ISet`1<string> uninitializedFieldNames, ISet`1<string> unwrapProxyFieldNames, ISessionImplementor session);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public static void ClearDirty(object entity);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public static void MarkDirty(object entity);
}
[ExtensionAttribute]
public static class NHibernate.Intercept.FieldInterceptorExtensions : object {
    [ExtensionAttribute]
internal static ISet`1<string> GetUninitializedFields(IFieldInterceptor interceptor);
    [ExtensionAttribute]
public static object Intercept(IFieldInterceptor interceptor, object target, string fieldName, object value, bool setter);
}
public interface NHibernate.Intercept.IFieldInterceptor {
    public bool IsDirty { get; }
    public ISessionImplementor Session { get; public set; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public bool IsInitialized { get; }
    public string EntityName { get; }
    public Type MappedClass { get; }
    public abstract virtual bool get_IsDirty();
    public abstract virtual ISessionImplementor get_Session();
    public abstract virtual void set_Session(ISessionImplementor value);
    public abstract virtual bool get_IsInitialized();
    public abstract virtual bool IsInitializedField(string field);
    public abstract virtual void MarkDirty();
    public abstract virtual void ClearDirty();
    [ObsoleteAttribute("Please use 'Intercept(object target, string fieldName, object value, bool setter)' extension method instead")]
public abstract virtual object Intercept(object target, string fieldName, object value);
    public abstract virtual string get_EntityName();
    public abstract virtual Type get_MappedClass();
}
public interface NHibernate.Intercept.IFieldInterceptorAccessor {
    public IFieldInterceptor FieldInterceptor { get; public set; }
    public abstract virtual IFieldInterceptor get_FieldInterceptor();
    public abstract virtual void set_FieldInterceptor(IFieldInterceptor value);
}
public interface NHibernate.Intercept.ILazyPropertyInitializer {
    public abstract virtual object InitializeLazyProperty(string fieldName, object entity, ISessionImplementor session);
}
public class NHibernate.Intercept.LazyPropertyInitializer : ValueType {
    public static object UnfetchedProperty;
    private static LazyPropertyInitializer();
}
public class NHibernate.Intercept.UnfetchedLazyProperty : ValueType {
}
[ObsoleteAttribute("Used only in Obsolete functions to thunk to ILoggerFactory")]
internal class NHibernate.InternalLoggerThunk : object {
    private INHibernateLogger _nhibernateLogger;
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public InternalLoggerThunk(INHibernateLogger nhibernateLogger);
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
}
public class NHibernate.InvalidProxyTypeException : MappingException {
    [CompilerGeneratedAttribute]
private ICollection`1<string> <Errors>k__BackingField;
    public ICollection`1<string> Errors { get; private set; }
    public InvalidProxyTypeException(ICollection`1<string> errors);
    public InvalidProxyTypeException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(ICollection`1<string> value);
    private static string FormatMessage(IEnumerable`1<string> errors);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public interface NHibernate.IQuery {
    public string QueryString { get; }
    public IType[] ReturnTypes { get; }
    public String[] ReturnAliases { get; }
    public String[] NamedParameters { get; }
    public bool IsReadOnly { get; }
    public abstract virtual Task`1<IEnumerable> EnumerableAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<T>> EnumerableAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IList> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task ListAsync(IList results, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<T>> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<object> UniqueResultAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> UniqueResultAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<int> ExecuteUpdateAsync(CancellationToken cancellationToken);
    public abstract virtual string get_QueryString();
    public abstract virtual IType[] get_ReturnTypes();
    public abstract virtual String[] get_ReturnAliases();
    public abstract virtual String[] get_NamedParameters();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual IEnumerable Enumerable();
    public abstract virtual IEnumerable`1<T> Enumerable();
    public abstract virtual IList List();
    public abstract virtual void List(IList results);
    public abstract virtual IList`1<T> List();
    public abstract virtual object UniqueResult();
    public abstract virtual T UniqueResult();
    public abstract virtual int ExecuteUpdate();
    public abstract virtual IQuery SetMaxResults(int maxResults);
    public abstract virtual IQuery SetFirstResult(int firstResult);
    public abstract virtual IQuery SetReadOnly(bool readOnly);
    public abstract virtual IQuery SetCacheable(bool cacheable);
    public abstract virtual IQuery SetCacheRegion(string cacheRegion);
    public abstract virtual IQuery SetTimeout(int timeout);
    public abstract virtual IQuery SetFetchSize(int fetchSize);
    public abstract virtual IQuery SetLockMode(string alias, LockMode lockMode);
    public abstract virtual IQuery SetComment(string comment);
    public abstract virtual IQuery SetFlushMode(FlushMode flushMode);
    public abstract virtual IQuery SetCacheMode(CacheMode cacheMode);
    public abstract virtual IQuery SetParameter(int position, object val, IType type);
    public abstract virtual IQuery SetParameter(string name, object val, IType type);
    public abstract virtual IQuery SetParameter(int position, T val);
    public abstract virtual IQuery SetParameter(string name, T val);
    public abstract virtual IQuery SetParameter(int position, object val);
    public abstract virtual IQuery SetParameter(string name, object val);
    public abstract virtual IQuery SetParameterList(string name, IEnumerable vals, IType type);
    public abstract virtual IQuery SetParameterList(string name, IEnumerable vals);
    public abstract virtual IQuery SetProperties(object obj);
    public abstract virtual IQuery SetAnsiString(int position, string val);
    public abstract virtual IQuery SetAnsiString(string name, string val);
    public abstract virtual IQuery SetBinary(int position, Byte[] val);
    public abstract virtual IQuery SetBinary(string name, Byte[] val);
    public abstract virtual IQuery SetBoolean(int position, bool val);
    public abstract virtual IQuery SetBoolean(string name, bool val);
    public abstract virtual IQuery SetByte(int position, byte val);
    public abstract virtual IQuery SetByte(string name, byte val);
    public abstract virtual IQuery SetCharacter(int position, char val);
    public abstract virtual IQuery SetCharacter(string name, char val);
    public abstract virtual IQuery SetDateTime(int position, DateTime val);
    public abstract virtual IQuery SetDateTime(string name, DateTime val);
    public abstract virtual IQuery SetDateTimeNoMs(int position, DateTime val);
    public abstract virtual IQuery SetDateTimeNoMs(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead, it uses DateTime2 with dialects supporting it.")]
public abstract virtual IQuery SetDateTime2(int position, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead, it uses DateTime2 with dialects supporting it.")]
public abstract virtual IQuery SetDateTime2(string name, DateTime val);
    public abstract virtual IQuery SetTimeSpan(int position, TimeSpan val);
    public abstract virtual IQuery SetTimeSpan(string name, TimeSpan val);
    public abstract virtual IQuery SetTimeAsTimeSpan(int position, TimeSpan val);
    public abstract virtual IQuery SetTimeAsTimeSpan(string name, TimeSpan val);
    public abstract virtual IQuery SetDateTimeOffset(int position, DateTimeOffset val);
    public abstract virtual IQuery SetDateTimeOffset(string name, DateTimeOffset val);
    public abstract virtual IQuery SetDecimal(int position, decimal val);
    public abstract virtual IQuery SetDecimal(string name, decimal val);
    public abstract virtual IQuery SetDouble(int position, double val);
    public abstract virtual IQuery SetDouble(string name, double val);
    public abstract virtual IQuery SetEnum(int position, Enum val);
    public abstract virtual IQuery SetEnum(string name, Enum val);
    public abstract virtual IQuery SetInt16(int position, short val);
    public abstract virtual IQuery SetInt16(string name, short val);
    public abstract virtual IQuery SetInt32(int position, int val);
    public abstract virtual IQuery SetInt32(string name, int val);
    public abstract virtual IQuery SetInt64(int position, long val);
    public abstract virtual IQuery SetInt64(string name, long val);
    public abstract virtual IQuery SetSingle(int position, float val);
    public abstract virtual IQuery SetSingle(string name, float val);
    public abstract virtual IQuery SetString(int position, string val);
    public abstract virtual IQuery SetString(string name, string val);
    public abstract virtual IQuery SetTime(int position, DateTime val);
    public abstract virtual IQuery SetTime(string name, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public abstract virtual IQuery SetTimestamp(int position, DateTime val);
    [ObsoleteAttribute("Use SetDateTime instead.")]
public abstract virtual IQuery SetTimestamp(string name, DateTime val);
    public abstract virtual IQuery SetGuid(int position, Guid val);
    public abstract virtual IQuery SetGuid(string name, Guid val);
    public abstract virtual IQuery SetEntity(int position, object val);
    public abstract virtual IQuery SetEntity(string name, object val);
    public abstract virtual IQuery SetResultTransformer(IResultTransformer resultTransformer);
    public abstract virtual IFutureEnumerable`1<T> Future();
    public abstract virtual IFutureValue`1<T> FutureValue();
}
public interface NHibernate.IQueryExpression {
    public string Key { get; }
    public Type Type { get; }
    public IList`1<NamedParameterDescriptor> ParameterDescriptors { get; }
    public abstract virtual IASTNode Translate(ISessionFactoryImplementor sessionFactory, bool filter);
    public abstract virtual string get_Key();
    public abstract virtual Type get_Type();
    public abstract virtual IList`1<NamedParameterDescriptor> get_ParameterDescriptors();
}
public interface NHibernate.IQueryOver {
    public ICriteria UnderlyingCriteria { get; }
    public ICriteria RootCriteria { get; }
    public abstract virtual ICriteria get_UnderlyingCriteria();
    public abstract virtual ICriteria get_RootCriteria();
}
public interface NHibernate.IQueryOver`1 {
    public abstract virtual Task`1<IList`1<TRoot>> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<U>> ListAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<int> RowCountAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<long> RowCountInt64Async(CancellationToken cancellationToken);
    public abstract virtual Task`1<TRoot> SingleOrDefaultAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<U> SingleOrDefaultAsync(CancellationToken cancellationToken);
    public abstract virtual IList`1<TRoot> List();
    public abstract virtual IList`1<U> List();
    public abstract virtual IQueryOver`2<TRoot, TRoot> ToRowCountQuery();
    public abstract virtual IQueryOver`2<TRoot, TRoot> ToRowCountInt64Query();
    public abstract virtual int RowCount();
    public abstract virtual long RowCountInt64();
    public abstract virtual TRoot SingleOrDefault();
    public abstract virtual U SingleOrDefault();
    public abstract virtual IFutureEnumerable`1<TRoot> Future();
    public abstract virtual IFutureEnumerable`1<U> Future();
    public abstract virtual IFutureValue`1<TRoot> FutureValue();
    public abstract virtual IFutureValue`1<U> FutureValue();
    public abstract virtual IQueryOver`2<TRoot, TRoot> Clone();
    public abstract virtual IQueryOver`1<TRoot> ClearOrders();
    public abstract virtual IQueryOver`1<TRoot> Skip(int firstResult);
    public abstract virtual IQueryOver`1<TRoot> Take(int maxResults);
    public abstract virtual IQueryOver`1<TRoot> Cacheable();
    public abstract virtual IQueryOver`1<TRoot> CacheMode(CacheMode cacheMode);
    public abstract virtual IQueryOver`1<TRoot> CacheRegion(string cacheRegion);
    public abstract virtual IQueryOver`1<TRoot> ReadOnly();
}
public interface NHibernate.IQueryOver`2 {
    public IQueryOverSubqueryBuilder`2<TRoot, TSubType> WithSubquery { get; }
    public IQueryOverJoinBuilder`2<TRoot, TSubType> Inner { get; }
    public IQueryOverJoinBuilder`2<TRoot, TSubType> Left { get; }
    public IQueryOverJoinBuilder`2<TRoot, TSubType> Right { get; }
    public IQueryOverJoinBuilder`2<TRoot, TSubType> Full { get; }
    public abstract virtual IQueryOver`2<TRoot, TSubType> And(Expression`1<Func`2<TSubType, bool>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> And(Expression`1<Func`1<bool>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> And(ICriterion expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> AndNot(Expression`1<Func`2<TSubType, bool>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> AndNot(Expression`1<Func`1<bool>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> AndNot(ICriterion expression);
    public abstract virtual IQueryOverRestrictionBuilder`2<TRoot, TSubType> AndRestrictionOn(Expression`1<Func`2<TSubType, object>> expression);
    public abstract virtual IQueryOverRestrictionBuilder`2<TRoot, TSubType> AndRestrictionOn(Expression`1<Func`1<object>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> Where(Expression`1<Func`2<TSubType, bool>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> Where(Expression`1<Func`1<bool>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> Where(ICriterion expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> WhereNot(Expression`1<Func`2<TSubType, bool>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> WhereNot(Expression`1<Func`1<bool>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> WhereNot(ICriterion expression);
    public abstract virtual IQueryOverRestrictionBuilder`2<TRoot, TSubType> WhereRestrictionOn(Expression`1<Func`2<TSubType, object>> expression);
    public abstract virtual IQueryOverRestrictionBuilder`2<TRoot, TSubType> WhereRestrictionOn(Expression`1<Func`1<object>> expression);
    public abstract virtual IQueryOver`2<TRoot, TSubType> Select(Expression`1[] projections);
    public abstract virtual IQueryOver`2<TRoot, TSubType> Select(IProjection[] projections);
    public abstract virtual IQueryOver`2<TRoot, TSubType> SelectList(Func`2<QueryOverProjectionBuilder`1<TRoot>, QueryOverProjectionBuilder`1<TRoot>> list);
    public abstract virtual IQueryOverOrderBuilder`2<TRoot, TSubType> OrderBy(Expression`1<Func`2<TSubType, object>> path);
    public abstract virtual IQueryOverOrderBuilder`2<TRoot, TSubType> OrderBy(Expression`1<Func`1<object>> path);
    public abstract virtual IQueryOverOrderBuilder`2<TRoot, TSubType> OrderBy(IProjection projection);
    public abstract virtual IQueryOverOrderBuilder`2<TRoot, TSubType> OrderByAlias(Expression`1<Func`1<object>> path);
    public abstract virtual IQueryOverOrderBuilder`2<TRoot, TSubType> ThenBy(Expression`1<Func`2<TSubType, object>> path);
    public abstract virtual IQueryOverOrderBuilder`2<TRoot, TSubType> ThenBy(Expression`1<Func`1<object>> path);
    public abstract virtual IQueryOverOrderBuilder`2<TRoot, TSubType> ThenBy(IProjection projection);
    public abstract virtual IQueryOverOrderBuilder`2<TRoot, TSubType> ThenByAlias(Expression`1<Func`1<object>> path);
    public abstract virtual IQueryOver`2<TRoot, TSubType> TransformUsing(IResultTransformer resultTransformer);
    public abstract virtual IQueryOverSubqueryBuilder`2<TRoot, TSubType> get_WithSubquery();
    [ObsoleteAttribute("Use Fetch(SelectMode mode, Expression<Func<TSubType, object>> path) instead")]
public abstract virtual IQueryOverFetchBuilder`2<TRoot, TSubType> Fetch(Expression`1<Func`2<TRoot, object>> path);
    public abstract virtual IQueryOverLockBuilder`2<TRoot, TSubType> Lock();
    public abstract virtual IQueryOverLockBuilder`2<TRoot, TSubType> Lock(Expression`1<Func`1<object>> alias);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, U> JoinQueryOver(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public abstract virtual IQueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`2<TSubType, object>> path, Expression`1<Func`1<object>> alias);
    public abstract virtual IQueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`1<object>> path, Expression`1<Func`1<object>> alias);
    public abstract virtual IQueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`2<TSubType, object>> path, Expression`1<Func`1<object>> alias, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`2<TSubType, U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public abstract virtual IQueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`2<TSubType, IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public abstract virtual IQueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`1<object>> path, Expression`1<Func`1<object>> alias, JoinType joinType);
    public abstract virtual IQueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`1<U>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public abstract virtual IQueryOver`2<TRoot, TSubType> JoinAlias(Expression`1<Func`1<IEnumerable`1<U>>> path, Expression`1<Func`1<U>> alias, JoinType joinType, ICriterion withClause);
    public abstract virtual IQueryOverJoinBuilder`2<TRoot, TSubType> get_Inner();
    public abstract virtual IQueryOverJoinBuilder`2<TRoot, TSubType> get_Left();
    public abstract virtual IQueryOverJoinBuilder`2<TRoot, TSubType> get_Right();
    public abstract virtual IQueryOverJoinBuilder`2<TRoot, TSubType> get_Full();
}
public interface NHibernate.ISession {
    public FlushMode FlushMode { get; public set; }
    public CacheMode CacheMode { get; public set; }
    public ISessionFactory SessionFactory { get; }
    public DbConnection Connection { get; }
    public bool IsOpen { get; }
    public bool IsConnected { get; }
    public bool DefaultReadOnly { get; public set; }
    [ObsoleteAttribute("Use GetCurrentTransaction extension method instead, and check for null.")]
public ITransaction Transaction { get; }
    public ISessionStatistics Statistics { get; }
    public abstract virtual Task FlushAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsDirtyAsync(CancellationToken cancellationToken);
    public abstract virtual Task EvictAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> LoadAsync(Type theType, object id, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> LoadAsync(string entityName, object id, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> LoadAsync(Type theType, object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> LoadAsync(object id, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> LoadAsync(object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> LoadAsync(string entityName, object id, CancellationToken cancellationToken);
    public abstract virtual Task LoadAsync(object obj, object id, CancellationToken cancellationToken);
    public abstract virtual Task ReplicateAsync(object obj, ReplicationMode replicationMode, CancellationToken cancellationToken);
    public abstract virtual Task ReplicateAsync(string entityName, object obj, ReplicationMode replicationMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> SaveAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual Task SaveAsync(object obj, object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> SaveAsync(string entityName, object obj, CancellationToken cancellationToken);
    public abstract virtual Task SaveAsync(string entityName, object obj, object id, CancellationToken cancellationToken);
    public abstract virtual Task SaveOrUpdateAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual Task SaveOrUpdateAsync(string entityName, object obj, CancellationToken cancellationToken);
    public abstract virtual Task SaveOrUpdateAsync(string entityName, object obj, object id, CancellationToken cancellationToken);
    public abstract virtual Task UpdateAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual Task UpdateAsync(object obj, object id, CancellationToken cancellationToken);
    public abstract virtual Task UpdateAsync(string entityName, object obj, CancellationToken cancellationToken);
    public abstract virtual Task UpdateAsync(string entityName, object obj, object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> MergeAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> MergeAsync(string entityName, object obj, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> MergeAsync(T entity, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> MergeAsync(string entityName, T entity, CancellationToken cancellationToken);
    public abstract virtual Task PersistAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual Task PersistAsync(string entityName, object obj, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(string entityName, object obj, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> DeleteAsync(string query, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> DeleteAsync(string query, object value, IType type, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> DeleteAsync(string query, Object[] values, IType[] types, CancellationToken cancellationToken);
    public abstract virtual Task LockAsync(object obj, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task LockAsync(string entityName, object obj, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task RefreshAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual Task RefreshAsync(object obj, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<IQuery> CreateFilterAsync(object collection, string queryString, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetAsync(Type clazz, object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetAsync(Type clazz, object id, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetAsync(string entityName, object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetAsync(object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetAsync(object id, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetEntityNameAsync(object obj, CancellationToken cancellationToken);
    public abstract virtual ISharedSessionBuilder SessionWithOptions();
    public abstract virtual void Flush();
    public abstract virtual FlushMode get_FlushMode();
    public abstract virtual void set_FlushMode(FlushMode value);
    public abstract virtual CacheMode get_CacheMode();
    public abstract virtual void set_CacheMode(CacheMode value);
    public abstract virtual ISessionFactory get_SessionFactory();
    public abstract virtual DbConnection get_Connection();
    public abstract virtual DbConnection Disconnect();
    public abstract virtual void Reconnect();
    public abstract virtual void Reconnect(DbConnection connection);
    public abstract virtual DbConnection Close();
    public abstract virtual void CancelQuery();
    public abstract virtual bool get_IsOpen();
    public abstract virtual bool get_IsConnected();
    public abstract virtual bool IsDirty();
    public abstract virtual bool IsReadOnly(object entityOrProxy);
    public abstract virtual void SetReadOnly(object entityOrProxy, bool readOnly);
    public abstract virtual bool get_DefaultReadOnly();
    public abstract virtual void set_DefaultReadOnly(bool value);
    public abstract virtual object GetIdentifier(object obj);
    public abstract virtual bool Contains(object obj);
    public abstract virtual void Evict(object obj);
    public abstract virtual object Load(Type theType, object id, LockMode lockMode);
    public abstract virtual object Load(string entityName, object id, LockMode lockMode);
    public abstract virtual object Load(Type theType, object id);
    public abstract virtual T Load(object id, LockMode lockMode);
    public abstract virtual T Load(object id);
    public abstract virtual object Load(string entityName, object id);
    public abstract virtual void Load(object obj, object id);
    public abstract virtual void Replicate(object obj, ReplicationMode replicationMode);
    public abstract virtual void Replicate(string entityName, object obj, ReplicationMode replicationMode);
    public abstract virtual object Save(object obj);
    public abstract virtual void Save(object obj, object id);
    public abstract virtual object Save(string entityName, object obj);
    public abstract virtual void Save(string entityName, object obj, object id);
    public abstract virtual void SaveOrUpdate(object obj);
    public abstract virtual void SaveOrUpdate(string entityName, object obj);
    public abstract virtual void SaveOrUpdate(string entityName, object obj, object id);
    public abstract virtual void Update(object obj);
    public abstract virtual void Update(object obj, object id);
    public abstract virtual void Update(string entityName, object obj);
    public abstract virtual void Update(string entityName, object obj, object id);
    public abstract virtual object Merge(object obj);
    public abstract virtual object Merge(string entityName, object obj);
    public abstract virtual T Merge(T entity);
    public abstract virtual T Merge(string entityName, T entity);
    public abstract virtual void Persist(object obj);
    public abstract virtual void Persist(string entityName, object obj);
    public abstract virtual void Delete(object obj);
    public abstract virtual void Delete(string entityName, object obj);
    public abstract virtual int Delete(string query);
    public abstract virtual int Delete(string query, object value, IType type);
    public abstract virtual int Delete(string query, Object[] values, IType[] types);
    public abstract virtual void Lock(object obj, LockMode lockMode);
    public abstract virtual void Lock(string entityName, object obj, LockMode lockMode);
    public abstract virtual void Refresh(object obj);
    public abstract virtual void Refresh(object obj, LockMode lockMode);
    public abstract virtual LockMode GetCurrentLockMode(object obj);
    public abstract virtual ITransaction BeginTransaction();
    public abstract virtual ITransaction BeginTransaction(IsolationLevel isolationLevel);
    public abstract virtual ITransaction get_Transaction();
    public abstract virtual void JoinTransaction();
    public abstract virtual ICriteria CreateCriteria();
    public abstract virtual ICriteria CreateCriteria(string alias);
    public abstract virtual ICriteria CreateCriteria(Type persistentClass);
    public abstract virtual ICriteria CreateCriteria(Type persistentClass, string alias);
    public abstract virtual ICriteria CreateCriteria(string entityName);
    public abstract virtual ICriteria CreateCriteria(string entityName, string alias);
    public abstract virtual IQueryOver`2<T, T> QueryOver();
    public abstract virtual IQueryOver`2<T, T> QueryOver(Expression`1<Func`1<T>> alias);
    public abstract virtual IQueryOver`2<T, T> QueryOver(string entityName);
    public abstract virtual IQueryOver`2<T, T> QueryOver(string entityName, Expression`1<Func`1<T>> alias);
    public abstract virtual IQuery CreateQuery(string queryString);
    public abstract virtual IQuery CreateFilter(object collection, string queryString);
    public abstract virtual IQuery GetNamedQuery(string queryName);
    public abstract virtual ISQLQuery CreateSQLQuery(string queryString);
    public abstract virtual void Clear();
    public abstract virtual object Get(Type clazz, object id);
    public abstract virtual object Get(Type clazz, object id, LockMode lockMode);
    public abstract virtual object Get(string entityName, object id);
    public abstract virtual T Get(object id);
    public abstract virtual T Get(object id, LockMode lockMode);
    public abstract virtual string GetEntityName(object obj);
    public abstract virtual IFilter EnableFilter(string filterName);
    public abstract virtual IFilter GetEnabledFilter(string filterName);
    public abstract virtual void DisableFilter(string filterName);
    [ObsoleteAttribute("Use ISession.CreateQueryBatch instead.")]
public abstract virtual IMultiQuery CreateMultiQuery();
    public abstract virtual ISession SetBatchSize(int batchSize);
    public abstract virtual ISessionImplementor GetSessionImplementation();
    [ObsoleteAttribute("Use ISession.CreateQueryBatch instead.")]
public abstract virtual IMultiCriteria CreateMultiCriteria();
    public abstract virtual ISessionStatistics get_Statistics();
    [ObsoleteAttribute("Please use SessionWithOptions instead. Now requires to be flushed and disposed of.")]
public abstract virtual ISession GetSession(EntityMode entityMode);
    public abstract virtual IQueryable`1<T> Query();
    public abstract virtual IQueryable`1<T> Query(string entityName);
}
public interface NHibernate.ISessionBuilder {
}
public interface NHibernate.ISessionBuilder`1 {
    public abstract virtual ISession OpenSession();
    public abstract virtual T Interceptor(IInterceptor interceptor);
    public abstract virtual T NoInterceptor();
    public abstract virtual T Connection(DbConnection connection);
    public abstract virtual T ConnectionReleaseMode(ConnectionReleaseMode connectionReleaseMode);
    public abstract virtual T AutoClose(bool autoClose);
    public abstract virtual T AutoJoinTransaction(bool autoJoinTransaction);
    public abstract virtual T FlushMode(FlushMode flushMode);
}
public interface NHibernate.ISessionFactory {
    public IStatistics Statistics { get; }
    public bool IsClosed { get; }
    public ICollection`1<string> DefinedFilterNames { get; }
    public abstract virtual Task CloseAsync(CancellationToken cancellationToken);
    public abstract virtual Task EvictAsync(Type persistentClass, CancellationToken cancellationToken);
    public abstract virtual Task EvictAsync(Type persistentClass, object id, CancellationToken cancellationToken);
    public abstract virtual Task EvictEntityAsync(string entityName, CancellationToken cancellationToken);
    public abstract virtual Task EvictEntityAsync(string entityName, object id, CancellationToken cancellationToken);
    public abstract virtual Task EvictCollectionAsync(string roleName, CancellationToken cancellationToken);
    public abstract virtual Task EvictCollectionAsync(string roleName, object id, CancellationToken cancellationToken);
    public abstract virtual Task EvictQueriesAsync(CancellationToken cancellationToken);
    public abstract virtual Task EvictQueriesAsync(string cacheRegion, CancellationToken cancellationToken);
    public abstract virtual ISessionBuilder WithOptions();
    [ObsoleteAttribute("Please use WithOptions instead.")]
public abstract virtual ISession OpenSession(DbConnection connection);
    [ObsoleteAttribute("Please use WithOptions instead.")]
public abstract virtual ISession OpenSession(IInterceptor sessionLocalInterceptor);
    [ObsoleteAttribute("Please use WithOptions instead.")]
public abstract virtual ISession OpenSession(DbConnection conn, IInterceptor sessionLocalInterceptor);
    public abstract virtual ISession OpenSession();
    public abstract virtual IStatelessSessionBuilder WithStatelessOptions();
    public abstract virtual IStatelessSession OpenStatelessSession();
    public abstract virtual IStatelessSession OpenStatelessSession(DbConnection connection);
    public abstract virtual IClassMetadata GetClassMetadata(Type persistentClass);
    public abstract virtual IClassMetadata GetClassMetadata(string entityName);
    public abstract virtual ICollectionMetadata GetCollectionMetadata(string roleName);
    public abstract virtual IDictionary`2<string, IClassMetadata> GetAllClassMetadata();
    public abstract virtual IDictionary`2<string, ICollectionMetadata> GetAllCollectionMetadata();
    public abstract virtual void Close();
    public abstract virtual void Evict(Type persistentClass);
    public abstract virtual void Evict(Type persistentClass, object id);
    public abstract virtual void EvictEntity(string entityName);
    public abstract virtual void EvictEntity(string entityName, object id);
    public abstract virtual void EvictCollection(string roleName);
    public abstract virtual void EvictCollection(string roleName, object id);
    public abstract virtual void EvictQueries();
    public abstract virtual void EvictQueries(string cacheRegion);
    public abstract virtual FilterDefinition GetFilterDefinition(string filterName);
    public abstract virtual ISession GetCurrentSession();
    public abstract virtual IStatistics get_Statistics();
    public abstract virtual bool get_IsClosed();
    public abstract virtual ICollection`1<string> get_DefinedFilterNames();
}
public interface NHibernate.ISharedSessionBuilder {
    public abstract virtual ISharedSessionBuilder Connection();
    public abstract virtual ISharedSessionBuilder Interceptor();
    public abstract virtual ISharedSessionBuilder ConnectionReleaseMode();
    public abstract virtual ISharedSessionBuilder FlushMode();
    public abstract virtual ISharedSessionBuilder AutoClose();
    public abstract virtual ISharedSessionBuilder AutoJoinTransaction();
}
public interface NHibernate.ISharedStatelessSessionBuilder {
    public abstract virtual ISharedStatelessSessionBuilder Connection(DbConnection connection);
    public abstract virtual ISharedStatelessSessionBuilder AutoJoinTransaction(bool autoJoinTransaction);
    public abstract virtual ISharedStatelessSessionBuilder Connection();
    public abstract virtual ISharedStatelessSessionBuilder AutoJoinTransaction();
}
public interface NHibernate.ISQLQuery {
    public abstract virtual ISQLQuery AddEntity(string entityName);
    public abstract virtual ISQLQuery AddEntity(string alias, string entityName);
    public abstract virtual ISQLQuery AddEntity(string alias, string entityName, LockMode lockMode);
    public abstract virtual ISQLQuery AddEntity(Type entityClass);
    public abstract virtual ISQLQuery AddEntity(string alias, Type entityClass);
    public abstract virtual ISQLQuery AddEntity(string alias, Type entityClass, LockMode lockMode);
    public abstract virtual ISQLQuery AddJoin(string alias, string path);
    public abstract virtual ISQLQuery AddJoin(string alias, string path, LockMode lockMode);
    public abstract virtual ISQLQuery AddScalar(string columnAlias, IType type);
    public abstract virtual ISQLQuery SetResultSetMapping(string name);
}
public interface NHibernate.IStatelessSession {
    public DbConnection Connection { get; }
    [ObsoleteAttribute("Use GetCurrentTransaction extension method instead, and check for null.")]
public ITransaction Transaction { get; }
    public bool IsOpen { get; }
    public bool IsConnected { get; }
    public abstract virtual Task`1<object> InsertAsync(object entity, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> InsertAsync(string entityName, object entity, CancellationToken cancellationToken);
    public abstract virtual Task UpdateAsync(object entity, CancellationToken cancellationToken);
    public abstract virtual Task UpdateAsync(string entityName, object entity, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(object entity, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(string entityName, object entity, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetAsync(string entityName, object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetAsync(object id, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetAsync(string entityName, object id, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetAsync(object id, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task RefreshAsync(object entity, CancellationToken cancellationToken);
    public abstract virtual Task RefreshAsync(string entityName, object entity, CancellationToken cancellationToken);
    public abstract virtual Task RefreshAsync(object entity, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual Task RefreshAsync(string entityName, object entity, LockMode lockMode, CancellationToken cancellationToken);
    public abstract virtual DbConnection get_Connection();
    public abstract virtual ITransaction get_Transaction();
    public abstract virtual bool get_IsOpen();
    public abstract virtual bool get_IsConnected();
    public abstract virtual ISessionImplementor GetSessionImplementation();
    public abstract virtual void Close();
    public abstract virtual object Insert(object entity);
    public abstract virtual object Insert(string entityName, object entity);
    public abstract virtual void Update(object entity);
    public abstract virtual void Update(string entityName, object entity);
    public abstract virtual void Delete(object entity);
    public abstract virtual void Delete(string entityName, object entity);
    public abstract virtual object Get(string entityName, object id);
    public abstract virtual T Get(object id);
    public abstract virtual object Get(string entityName, object id, LockMode lockMode);
    public abstract virtual T Get(object id, LockMode lockMode);
    public abstract virtual void Refresh(object entity);
    public abstract virtual void Refresh(string entityName, object entity);
    public abstract virtual void Refresh(object entity, LockMode lockMode);
    public abstract virtual void Refresh(string entityName, object entity, LockMode lockMode);
    public abstract virtual IQuery CreateQuery(string queryString);
    public abstract virtual IQuery GetNamedQuery(string queryName);
    public abstract virtual ICriteria CreateCriteria();
    public abstract virtual ICriteria CreateCriteria(string alias);
    public abstract virtual ICriteria CreateCriteria(Type entityType);
    public abstract virtual ICriteria CreateCriteria(Type entityType, string alias);
    public abstract virtual ICriteria CreateCriteria(string entityName);
    public abstract virtual ICriteria CreateCriteria(string entityName, string alias);
    public abstract virtual IQueryOver`2<T, T> QueryOver();
    public abstract virtual IQueryOver`2<T, T> QueryOver(Expression`1<Func`1<T>> alias);
    public abstract virtual ISQLQuery CreateSQLQuery(string queryString);
    public abstract virtual ITransaction BeginTransaction();
    public abstract virtual ITransaction BeginTransaction(IsolationLevel isolationLevel);
    public abstract virtual void JoinTransaction();
    public abstract virtual IStatelessSession SetBatchSize(int batchSize);
    public abstract virtual IQueryable`1<T> Query();
    public abstract virtual IQueryable`1<T> Query(string entityName);
}
public interface NHibernate.IStatelessSessionBuilder {
    public abstract virtual IStatelessSession OpenStatelessSession();
    public abstract virtual IStatelessSessionBuilder Connection(DbConnection connection);
    public abstract virtual IStatelessSessionBuilder AutoJoinTransaction(bool autoJoinTransaction);
}
public interface NHibernate.ISupportSelectModeCriteria {
    public abstract virtual ICriteria Fetch(SelectMode selectMode, string associationPath, string alias);
}
public interface NHibernate.ISynchronizableQuery`1 {
    public abstract virtual T AddSynchronizedQuerySpace(string querySpace);
    public abstract virtual T AddSynchronizedEntityName(string entityName);
    public abstract virtual T AddSynchronizedEntityClass(Type entityType);
    public abstract virtual IReadOnlyCollection`1<string> GetSynchronizedQuerySpaces();
}
public interface NHibernate.ISynchronizableSQLQuery {
}
public interface NHibernate.ITransaction {
    public bool IsActive { get; }
    public bool WasRolledBack { get; }
    public bool WasCommitted { get; }
    public abstract virtual Task CommitAsync(CancellationToken cancellationToken);
    public abstract virtual Task RollbackAsync(CancellationToken cancellationToken);
    public abstract virtual void Begin();
    public abstract virtual void Begin(IsolationLevel isolationLevel);
    public abstract virtual void Commit();
    public abstract virtual void Rollback();
    public abstract virtual bool get_IsActive();
    public abstract virtual bool get_WasRolledBack();
    public abstract virtual bool get_WasCommitted();
    public abstract virtual void Enlist(DbCommand command);
    [ObsoleteAttribute("Use RegisterSynchronization(ITransactionCompletionSynchronization) extension method instead. If implementing ITransaction, implement a 'public void RegisterSynchronization(ITransactionCompletionSynchronization)': the TransactionExtensions extension method will call it.")]
public abstract virtual void RegisterSynchronization(ISynchronization synchronization);
}
public class NHibernate.LazyInitializationException : HibernateException {
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EntityId>k__BackingField;
    public string EntityName { get; }
    public object EntityId { get; }
    public LazyInitializationException(string entityName, object entityId, string message);
    public LazyInitializationException(string message);
    public LazyInitializationException(Exception innerException);
    public LazyInitializationException(string message, Exception innerException);
    protected LazyInitializationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_EntityName();
    [CompilerGeneratedAttribute]
public object get_EntityId();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class NHibernate.Linq.Assignments`2 : object {
    private Dictionary`2<string, Expression> _assignments;
    internal IReadOnlyDictionary`2<string, Expression> List { get; }
    internal IReadOnlyDictionary`2<string, Expression> get_List();
    public void Set(Expression`1<Func`2<TTarget, TProp>> property, Expression`1<Func`2<TSource, TProp>> expression);
    public void Set(Expression`1<Func`2<TTarget, TProp>> property, TProp value);
    private static MemberExpression GetMemberExpression(Expression`1<Func`2<TTarget, TProp>> property);
}
public abstract class NHibernate.Linq.Clauses.NhClauseBase : object {
    public sealed virtual void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index);
    protected abstract virtual void Accept(INhQueryModelVisitor visitor, QueryModel queryModel, int index);
}
public class NHibernate.Linq.Clauses.NhHavingClause : NhClauseBase {
    private Expression _predicate;
    public Expression Predicate { get; public set; }
    public NhHavingClause(Expression predicate);
    public Expression get_Predicate();
    public void set_Predicate(Expression value);
    protected virtual void Accept(INhQueryModelVisitor visitor, QueryModel queryModel, int index);
    private sealed virtual override IBodyClause Remotion.Linq.Clauses.IBodyClause.Clone(CloneContext cloneContext);
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
    public NhHavingClause Clone(CloneContext cloneContext);
}
public class NHibernate.Linq.Clauses.NhJoinClause : NhClauseBase {
    private Expression _fromExpression;
    private string _itemName;
    private Type _itemType;
    [CompilerGeneratedAttribute]
private ObservableCollection`1<NhWithClause> <Restrictions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInner>k__BackingField;
    public ObservableCollection`1<NhWithClause> Restrictions { get; }
    public bool IsInner { get; private set; }
    public string ItemName { get; public set; }
    public Type ItemType { get; public set; }
    public Expression FromExpression { get; public set; }
    public NhJoinClause(string itemName, Type itemType, Expression fromExpression);
    public NhJoinClause(string itemName, Type itemType, Expression fromExpression, IEnumerable`1<NhWithClause> restrictions);
    [CompilerGeneratedAttribute]
public ObservableCollection`1<NhWithClause> get_Restrictions();
    [CompilerGeneratedAttribute]
public bool get_IsInner();
    [CompilerGeneratedAttribute]
private void set_IsInner(bool value);
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    protected virtual void Accept(INhQueryModelVisitor visitor, QueryModel queryModel, int index);
    private sealed virtual override IBodyClause Remotion.Linq.Clauses.IBodyClause.Clone(CloneContext cloneContext);
    public sealed virtual string get_ItemName();
    public void set_ItemName(string value);
    public sealed virtual Type get_ItemType();
    public void set_ItemType(Type value);
    public sealed virtual Expression get_FromExpression();
    public void set_FromExpression(Expression value);
    public sealed virtual void CopyFromSource(IFromClause source);
    public NhJoinClause Clone(CloneContext cloneContext);
    public void MakeInner();
    public virtual string ToString();
}
public class NHibernate.Linq.Clauses.NhOuterJoinClause : NhClauseBase {
    [CompilerGeneratedAttribute]
private JoinClause <JoinClause>k__BackingField;
    public JoinClause JoinClause { get; }
    public string ItemName { get; }
    public Type ItemType { get; }
    public NhOuterJoinClause(JoinClause joinClause);
    [CompilerGeneratedAttribute]
public JoinClause get_JoinClause();
    public sealed virtual string get_ItemName();
    public sealed virtual Type get_ItemType();
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public sealed virtual IBodyClause Clone(CloneContext cloneContext);
    protected virtual void Accept(INhQueryModelVisitor visitor, QueryModel queryModel, int index);
}
public class NHibernate.Linq.Clauses.NhWithClause : NhClauseBase {
    private Expression _predicate;
    public Expression Predicate { get; public set; }
    public NhWithClause(Expression predicate);
    public Expression get_Predicate();
    public void set_Predicate(Expression value);
    public virtual string ToString();
    protected virtual void Accept(INhQueryModelVisitor visitor, QueryModel queryModel, int index);
    private sealed virtual override IBodyClause Remotion.Linq.Clauses.IBodyClause.Clone(CloneContext cloneContext);
    public NhWithClause Clone(CloneContext cloneContext);
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
}
public class NHibernate.Linq.DefaultQueryProvider : object {
    private static MethodInfo CreateQueryMethodDefinition;
    private WeakReference`1<ISessionImplementor> _session;
    private NhQueryableOptions _options;
    [CompilerGeneratedAttribute]
private object <Collection>k__BackingField;
    public object Collection { get; }
    public ISessionImplementor Session { get; }
    public DefaultQueryProvider(ISessionImplementor session);
    public DefaultQueryProvider(ISessionImplementor session, object collection);
    protected DefaultQueryProvider(ISessionImplementor session, object collection, NhQueryableOptions options);
    private static DefaultQueryProvider();
    [AsyncStateMachineAttribute("NHibernate.Linq.DefaultQueryProvider/<ExecuteListAsync>d__0`1")]
public virtual Task`1<IList`1<TResult>> ExecuteListAsync(Expression expression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Linq.DefaultQueryProvider/<ExecuteQueryAsync>d__1")]
[ObsoleteAttribute("Use ExecuteQuery(NhLinqExpression nhLinqExpression, IQuery query) instead")]
protected virtual Task`1<object> ExecuteQueryAsync(NhLinqExpression nhLinqExpression, IQuery query, NhLinqExpression nhQuery, CancellationToken cancellationToken);
    protected virtual Task`1<object> ExecuteQueryAsync(NhLinqExpression nhLinqExpression, IQuery query, CancellationToken cancellationToken);
    public sealed virtual Task`1<int> ExecuteDmlAsync(QueryMode queryMode, Expression expression, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public object get_Collection();
    public virtual ISessionImplementor get_Session();
    public virtual object Execute(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    public virtual IList`1<TResult> ExecuteList(Expression expression);
    public sealed virtual IQueryProvider WithOptions(Action`1<NhQueryableOptions> setOptions);
    protected virtual IQueryProvider CreateWithOptions(NhQueryableOptions options);
    public virtual IQueryable CreateQuery(Expression expression);
    public virtual IQueryable`1<T> CreateQuery(Expression expression);
    [ObsoleteAttribute("Replaced by ISupportFutureBatchNhQueryProvider interface")]
public virtual IFutureEnumerable`1<TResult> ExecuteFuture(Expression expression);
    [ObsoleteAttribute("Replaced by ISupportFutureBatchNhQueryProvider interface")]
public virtual IFutureValue`1<TResult> ExecuteFutureValue(Expression expression);
    [ObsoleteAttribute]
private static void SetupFutureResult(NhLinqExpression nhExpression, IDelayedValue result);
    [AsyncStateMachineAttribute("NHibernate.Linq.DefaultQueryProvider/<ExecuteAsync>d__25`1")]
public sealed virtual Task`1<TResult> ExecuteAsync(Expression expression, CancellationToken cancellationToken);
    public virtual Task`1<object> ExecuteAsync(Expression expression, CancellationToken cancellationToken);
    protected virtual NhLinqExpression PrepareQuery(Expression expression, IQuery& query);
    [ObsoleteAttribute("Use ExecuteQuery(NhLinqExpression nhLinqExpression, IQuery query) instead")]
protected virtual object ExecuteQuery(NhLinqExpression nhLinqExpression, IQuery query, NhLinqExpression nhQuery);
    protected virtual object ExecuteQuery(NhLinqExpression nhLinqExpression, IQuery query);
    protected void SetParameters(IQuery query, IDictionary`2<string, NamedParameter> parameters);
    public virtual void SetResultTransformerAndAdditionalCriteria(IQuery query, NhLinqExpression nhExpression, IDictionary`2<string, Tuple`2<object, IType>> parameters);
    public sealed virtual int ExecuteDml(QueryMode queryMode, Expression expression);
    public sealed virtual IQuery GetPreparedQuery(Expression expression, NhLinqExpression& nhExpression);
}
public class NHibernate.Linq.DmlExpressionRewriter : object {
    private IReadOnlyCollection`1<ParameterExpression> _parameters;
    private Dictionary`2<string, Expression> _assignments;
    private DmlExpressionRewriter(IReadOnlyCollection`1<ParameterExpression> parameters);
    private void AddSettersFromBindings(IEnumerable`1<MemberBinding> bindings, string path);
    private void AddSettersFromAnonymousConstructor(NewExpression newExpression, string path);
    private void AddSettersFromAssignment(MemberAssignment assignment, string path);
    private static LambdaExpression ConvertAssignmentsToBlockExpression(IReadOnlyDictionary`2<string, Expression> assignments);
    public static Expression PrepareExpression(Expression sourceExpression, Expression`1<Func`2<TSource, TTarget>> expression);
    public static Expression PrepareExpressionFromAnonymous(Expression sourceExpression, Expression`1<Func`2<TSource, object>> expression);
    public static Expression PrepareExpression(Expression sourceExpression, IReadOnlyDictionary`2<string, Expression> assignments);
}
[ExtensionAttribute]
public static class NHibernate.Linq.DmlExtensionMethods : object {
    [ExtensionAttribute]
public static Task`1<int> DeleteAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> UpdateAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TSource>> expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> UpdateAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, object>> expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> UpdateVersionedAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TSource>> expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> UpdateVersionedAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, object>> expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Task`1<int> ExecuteUpdateAsync(IQueryable`1<TSource> source, Expression updateExpression, bool versioned, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> InsertIntoAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TTarget>> expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> InsertIntoAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, object>> expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Task`1<int> ExecuteInsertAsync(IQueryable`1<TSource> source, Expression insertExpression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static int Delete(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static int Update(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TSource>> expression);
    [ExtensionAttribute]
public static int Update(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, object>> expression);
    [ExtensionAttribute]
public static int UpdateVersioned(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TSource>> expression);
    [ExtensionAttribute]
public static int UpdateVersioned(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, object>> expression);
    [ExtensionAttribute]
public static UpdateBuilder`1<TSource> UpdateBuilder(IQueryable`1<TSource> source);
    [ExtensionAttribute]
internal static int ExecuteUpdate(IQueryable`1<TSource> source, Expression updateExpression, bool versioned);
    [ExtensionAttribute]
public static int InsertInto(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TTarget>> expression);
    [ExtensionAttribute]
public static int InsertInto(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, object>> expression);
    [ExtensionAttribute]
public static InsertBuilder`1<TSource> InsertBuilder(IQueryable`1<TSource> source);
    [ExtensionAttribute]
internal static int ExecuteInsert(IQueryable`1<TSource> source, Expression insertExpression);
}
[ExtensionAttribute]
public static class NHibernate.Linq.EagerFetchingExtensionMethods : object {
    [ExtensionAttribute]
public static INhFetchRequest`2<TOriginating, TRelated> Fetch(IQueryable`1<TOriginating> query, Expression`1<Func`2<TOriginating, TRelated>> relatedObjectSelector);
    [ExtensionAttribute]
public static INhFetchRequest`2<TOriginating, TOriginating> FetchLazyProperties(IQueryable`1<TOriginating> query);
    [ExtensionAttribute]
public static INhFetchRequest`2<TOriginating, TRelated> FetchMany(IQueryable`1<TOriginating> query, Expression`1<Func`2<TOriginating, IEnumerable`1<TRelated>>> relatedObjectSelector);
    [ExtensionAttribute]
public static INhFetchRequest`2<TQueried, TRelated> ThenFetch(INhFetchRequest`2<TQueried, TFetch> query, Expression`1<Func`2<TFetch, TRelated>> relatedObjectSelector);
    [ExtensionAttribute]
public static INhFetchRequest`2<TQueried, TRelated> ThenFetchMany(INhFetchRequest`2<TQueried, TFetch> query, Expression`1<Func`2<TFetch, IEnumerable`1<TRelated>>> relatedObjectSelector);
    private static INhFetchRequest`2<TOriginating, TRelated> CreateFluentFetchRequest(MethodInfo currentFetchMethod, IQueryable`1<TOriginating> query, LambdaExpression relatedObjectSelector);
}
[ObsoleteAttribute("Please use NHibernate.Util.ReflectHelper instead")]
public static class NHibernate.Linq.EnumerableHelper : object {
    public static MethodInfo GetMethod(string name, Type[] parameterTypes);
    public static MethodInfo GetMethod(string name, Type[] parameterTypes, Type[] genericTypeParameters);
}
[ExtensionAttribute]
public static class NHibernate.Linq.ExpressionExtensions : object {
    [ExtensionAttribute]
public static bool IsGroupingKey(MemberExpression expression);
    [ExtensionAttribute]
internal static bool TryGetGroupResultOperator(MemberExpression keyExpression, GroupResultOperator& groupBy);
    [ExtensionAttribute]
public static bool IsGroupingKeyOf(MemberExpression expression, GroupResultOperator groupBy);
    [ExtensionAttribute]
public static bool IsGroupingElementOf(QuerySourceReferenceExpression expression, GroupResultOperator groupBy);
}
public abstract class NHibernate.Linq.Expressions.NhAggregatedExpression : NhExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public bool AllowsNullableReturnType { get; }
    public Type Type { get; }
    public Expression Expression { get; }
    protected NhAggregatedExpression(Expression expression);
    protected NhAggregatedExpression(Expression expression, Type type);
    public virtual bool get_AllowsNullableReturnType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    public abstract virtual Expression CreateNew(Expression expression);
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public class NHibernate.Linq.Expressions.NhAverageExpression : NhAggregatedExpression {
    public NhAverageExpression(Expression expression);
    private static Type CalculateAverageType(Type inputType);
    public virtual Expression CreateNew(Expression expression);
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public abstract class NHibernate.Linq.Expressions.NhCountExpression : NhAggregatedExpression {
    public bool AllowsNullableReturnType { get; }
    protected NhCountExpression(Expression expression, Type type);
    public virtual bool get_AllowsNullableReturnType();
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public class NHibernate.Linq.Expressions.NhDistinctExpression : NhAggregatedExpression {
    public NhDistinctExpression(Expression expression);
    public virtual Expression CreateNew(Expression expression);
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public abstract class NHibernate.Linq.Expressions.NhExpression : Expression {
    public ExpressionType NodeType { get; }
    public sealed virtual ExpressionType get_NodeType();
    protected sealed virtual Expression Accept(ExpressionVisitor visitor);
    protected abstract virtual Expression Accept(NhExpressionVisitor visitor);
}
public class NHibernate.Linq.Expressions.NhLongCountExpression : NhCountExpression {
    public NhLongCountExpression(Expression expression);
    public virtual Expression CreateNew(Expression expression);
}
public class NHibernate.Linq.Expressions.NhMaxExpression : NhAggregatedExpression {
    public NhMaxExpression(Expression expression);
    public virtual Expression CreateNew(Expression expression);
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public class NHibernate.Linq.Expressions.NhMinExpression : NhAggregatedExpression {
    public NhMinExpression(Expression expression);
    public virtual Expression CreateNew(Expression expression);
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public class NHibernate.Linq.Expressions.NhNewExpression : NhExpression {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Expression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Members>k__BackingField;
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public ReadOnlyCollection`1<string> Members { get; }
    public NhNewExpression(IList`1<string> members, IList`1<Expression> arguments);
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Expression> get_Arguments();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_Members();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public class NHibernate.Linq.Expressions.NhNominatedExpression : NhExpression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Type Type { get; }
    public Expression Expression { get; }
    public NhNominatedExpression(Expression expression);
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    protected virtual Expression Accept(NhExpressionVisitor visitor);
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
}
public class NHibernate.Linq.Expressions.NhShortCountExpression : NhCountExpression {
    public NhShortCountExpression(Expression expression);
    public virtual Expression CreateNew(Expression expression);
}
public class NHibernate.Linq.Expressions.NhStarExpression : NhExpression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    public Type Type { get; }
    public NhStarExpression(Expression expression);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    public virtual Type get_Type();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public class NHibernate.Linq.Expressions.NhSumExpression : NhAggregatedExpression {
    public NhSumExpression(Expression expression);
    public virtual Expression CreateNew(Expression expression);
    protected virtual Expression Accept(NhExpressionVisitor visitor);
}
public class NHibernate.Linq.ExpressionToHqlTranslationResults : object {
    [CompilerGeneratedAttribute]
private HqlTreeNode <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultTransformer <ResultTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private Delegate <PostExecuteTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>>> <AdditionalCriteria>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ExecuteResultTypeOverride>k__BackingField;
    public HqlTreeNode Statement { get; }
    public ResultTransformer ResultTransformer { get; }
    public Delegate PostExecuteTransformer { get; }
    public List`1<Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>>> AdditionalCriteria { get; }
    public Type ExecuteResultTypeOverride { get; }
    public ExpressionToHqlTranslationResults(HqlTreeNode statement, IList`1<LambdaExpression> itemTransformers, IList`1<LambdaExpression> listTransformers, IList`1<LambdaExpression> postExecuteTransformers, List`1<Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>>> additionalCriteria, Type executeResultTypeOverride);
    [CompilerGeneratedAttribute]
public HqlTreeNode get_Statement();
    [CompilerGeneratedAttribute]
public ResultTransformer get_ResultTransformer();
    [CompilerGeneratedAttribute]
public Delegate get_PostExecuteTransformer();
    [CompilerGeneratedAttribute]
public List`1<Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>>> get_AdditionalCriteria();
    [CompilerGeneratedAttribute]
public Type get_ExecuteResultTypeOverride();
    private static TDelegate MergeLambdasAndCompile(IList`1<LambdaExpression> itemTransformers);
    private static Delegate MergeLambdasAndCompile(IList`1<LambdaExpression> transformations);
    private static LambdaExpression MergeLambdas(IList`1<LambdaExpression> transformations);
}
public class NHibernate.Linq.ExpressionTransformers.RemoveCharToIntConversion : object {
    private static ExpressionType[] _supportedExpressionTypes;
    public ExpressionType[] SupportedExpressionTypes { get; }
    private static RemoveCharToIntConversion();
    public sealed virtual Expression Transform(BinaryExpression expression);
    private static bool IsConvertCharToInt(UnaryExpression expression);
    private static bool IsConvertExpression(Expression expression);
    private static bool IsConstantExpression(Expression expression);
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
}
public class NHibernate.Linq.ExpressionTransformers.RemoveRedundantCast : object {
    private static ExpressionType[] _supportedExpressionTypes;
    public ExpressionType[] SupportedExpressionTypes { get; }
    private static RemoveRedundantCast();
    public sealed virtual Expression Transform(UnaryExpression expression);
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
}
internal class NHibernate.Linq.ExpressionTransformers.SimplifyCompareTransformer : object {
    private static Dictionary`2<ExpressionType, ExpressionType> ActingOperators;
    private static Dictionary`2<Type, MethodInfo> dummies;
    public ExpressionType[] SupportedExpressionTypes { get; }
    private static SimplifyCompareTransformer();
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
    public sealed virtual Expression Transform(BinaryExpression expression);
    private static bool IsConstantZero(Expression expression);
    private static bool IsCompare(Expression expression);
    private Expression Build(ExpressionType et, Expression expression);
    private static bool DummyComparison(T lhs, T rhs);
}
internal class NHibernate.Linq.FetchLazyPropertiesExpressionNode : ResultOperatorExpressionNodeBase {
    public FetchLazyPropertiesExpressionNode(MethodCallExpressionParseInfo parseInfo);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
internal class NHibernate.Linq.FetchLazyPropertiesResultOperator : ResultOperatorBase {
    public virtual IStreamedData ExecuteInMemory(IStreamedData input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
}
public class NHibernate.Linq.Functions.AllHqlGenerator : BaseHqlGeneratorForMethod {
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.AnyHqlGenerator : BaseHqlGeneratorForMethod {
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public abstract class NHibernate.Linq.Functions.BaseHqlGeneratorForMethod : object {
    protected static INHibernateLogger Log;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <SupportedMethods>k__BackingField;
    public IEnumerable`1<MethodInfo> SupportedMethods { get; protected set; }
    private static BaseHqlGeneratorForMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<MethodInfo> get_SupportedMethods();
    [CompilerGeneratedAttribute]
protected void set_SupportedMethods(IEnumerable`1<MethodInfo> value);
    public abstract virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual bool TryGetCollectionParameter(MethodCallExpression expression, ConstantExpression& collectionParameter);
    private protected static void LogIgnoredParameter(MethodInfo method, string paramType);
    private protected static void LogIgnoredStringComparisonParameter(MethodInfo actualMethod, MethodInfo methodWithStringComparison);
    private protected bool LogIgnoredStringComparisonParameter(MethodInfo actualMethod, MethodInfo[] methodsWithStringComparison);
}
public abstract class NHibernate.Linq.Functions.BaseHqlGeneratorForProperty : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberInfo> <SupportedProperties>k__BackingField;
    public IEnumerable`1<MemberInfo> SupportedProperties { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<MemberInfo> get_SupportedProperties();
    [CompilerGeneratedAttribute]
protected void set_SupportedProperties(IEnumerable`1<MemberInfo> value);
    public abstract virtual HqlTreeNode BuildHql(MemberInfo member, Expression expression, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.CollectionContainsGenerator : BaseHqlGeneratorForMethod {
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual bool TryGetCollectionParameter(MethodCallExpression expression, ConstantExpression& collectionParameter);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.CollectionContainsRuntimeHqlGenerator : object {
    private IHqlGeneratorForMethod containsGenerator;
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
}
internal class NHibernate.Linq.Functions.CompareGenerator : BaseHqlGeneratorForMethod {
    private static MethodInfo MethodWithComparer;
    private static HashSet`1<MethodInfo> ActingMethods;
    private static CompareGenerator();
    internal static bool IsCompareMethod(MethodInfo methodInfo);
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
}
public class NHibernate.Linq.Functions.ContainsGenerator : BaseHqlGeneratorForMethod {
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.ConvertToBooleanGenerator : ConvertToGenerator`1<bool> {
}
public class NHibernate.Linq.Functions.ConvertToDateTimeGenerator : ConvertToGenerator`1<DateTime> {
}
public class NHibernate.Linq.Functions.ConvertToDecimalGenerator : ConvertToGenerator`1<decimal> {
}
public class NHibernate.Linq.Functions.ConvertToDoubleGenerator : ConvertToGenerator`1<double> {
}
public abstract class NHibernate.Linq.Functions.ConvertToGenerator`1 : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.ConvertToInt32Generator : ConvertToGenerator`1<int> {
}
public class NHibernate.Linq.Functions.DateTimeNowHqlGenerator : BaseHqlGeneratorForProperty {
    private static MemberInfo DateTimeNow;
    private static MemberInfo DateTimeUtcNow;
    private static MemberInfo DateTimeToday;
    private static MemberInfo DateTimeOffsetNow;
    private static MemberInfo DateTimeOffsetUtcNow;
    private Dictionary`2<MemberInfo, string> _hqlFunctions;
    private static DateTimeNowHqlGenerator();
    public virtual HqlTreeNode BuildHql(MemberInfo member, Expression expression, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    public sealed virtual bool AllowPreEvaluation(MemberInfo member, ISessionFactoryImplementor factory);
    public sealed virtual bool IgnoreInstance(MemberInfo member);
}
public class NHibernate.Linq.Functions.DateTimePropertiesHqlGenerator : BaseHqlGeneratorForProperty {
    public virtual HqlTreeNode BuildHql(MemberInfo member, Expression expression, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal class NHibernate.Linq.Functions.DecimalAddGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal class NHibernate.Linq.Functions.DecimalDivideGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal class NHibernate.Linq.Functions.DecimalMultiplyGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal class NHibernate.Linq.Functions.DecimalNegateGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal class NHibernate.Linq.Functions.DecimalRemainderGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal class NHibernate.Linq.Functions.DecimalSubtractGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.DefaultLinqToHqlGeneratorsRegistry : object {
    private Dictionary`2<MethodInfo, IHqlGeneratorForMethod> registeredMethods;
    private Dictionary`2<MemberInfo, IHqlGeneratorForProperty> registeredProperties;
    private List`1<IRuntimeMethodHqlGenerator> runtimeMethodHqlGenerators;
    private ConcurrentDictionary`2<MethodInfo, IHqlGeneratorForMethod> _cachedRuntimeMethodHqlGenerators;
    protected bool GetRuntimeMethodGenerator(MethodInfo method, IHqlGeneratorForMethod& methodGenerator);
    public virtual bool TryGetGenerator(MethodInfo method, IHqlGeneratorForMethod& generator);
    public virtual bool TryGetGenerator(MemberInfo property, IHqlGeneratorForProperty& generator);
    public virtual void RegisterGenerator(MethodInfo method, IHqlGeneratorForMethod generator);
    public virtual void RegisterGenerator(MemberInfo property, IHqlGeneratorForProperty generator);
    public sealed virtual void RegisterGenerator(IRuntimeMethodHqlGenerator generator);
    [CompilerGeneratedAttribute]
private IHqlGeneratorForMethod <GetRuntimeMethodGenerator>b__5_0(MethodInfo m);
}
public class NHibernate.Linq.Functions.DictionaryContainsKeyGenerator : BaseHqlGeneratorForMethod {
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.DictionaryContainsKeyRuntimeHqlGenerator : DictionaryRuntimeMethodHqlGeneratorBase`1<DictionaryContainsKeyGenerator> {
    protected string MethodName { get; }
    protected virtual string get_MethodName();
}
public class NHibernate.Linq.Functions.DictionaryItemGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.DictionaryItemRuntimeHqlGenerator : DictionaryRuntimeMethodHqlGeneratorBase`1<DictionaryItemGenerator> {
    protected string MethodName { get; }
    protected virtual string get_MethodName();
}
public abstract class NHibernate.Linq.Functions.DictionaryRuntimeMethodHqlGeneratorBase`1 : object {
    private IHqlGeneratorForMethod generator;
    protected string MethodName { get; }
    protected abstract virtual string get_MethodName();
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
}
public class NHibernate.Linq.Functions.EndsWithGenerator : BaseHqlGeneratorForMethod {
    private static MethodInfo MethodWithComparer;
    private static EndsWithGenerator();
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.EqualsGenerator : BaseHqlGeneratorForMethod {
    internal static HashSet`1<MethodInfo> Methods;
    private static EqualsGenerator();
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.GenericDictionaryContainsKeyRuntimeHqlGenerator : GenericDictionaryRuntimeMethodHqlGeneratorBase`1<DictionaryContainsKeyGenerator> {
    protected string MethodName { get; }
    protected virtual string get_MethodName();
}
public class NHibernate.Linq.Functions.GenericDictionaryItemRuntimeHqlGenerator : GenericDictionaryRuntimeMethodHqlGeneratorBase`1<DictionaryItemGenerator> {
    protected string MethodName { get; }
    protected virtual string get_MethodName();
}
public abstract class NHibernate.Linq.Functions.GenericDictionaryRuntimeMethodHqlGeneratorBase`1 : object {
    private IHqlGeneratorForMethod generator;
    protected string MethodName { get; }
    protected abstract virtual string get_MethodName();
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
}
public class NHibernate.Linq.Functions.GetCharsGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal class NHibernate.Linq.Functions.GetValueOrDefaultGenerator : object {
    public IEnumerable`1<MethodInfo> SupportedMethods { get; }
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
    public sealed virtual IEnumerable`1<MethodInfo> get_SupportedMethods();
    public sealed virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    private static HqlExpression GetRhs(MethodInfo method, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    public sealed virtual bool AllowsNullableReturnType(MethodInfo method);
    public sealed virtual bool TryGetCollectionParameter(MethodCallExpression expression, ConstantExpression& collectionParameter);
}
internal class NHibernate.Linq.Functions.HasFlagGenerator : BaseHqlGeneratorForMethod {
    private static string _bitAndFunctionName;
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.HqlGeneratorForExtensionMethod : BaseHqlGeneratorForMethod {
    private string _name;
    public HqlGeneratorForExtensionMethod(LinqExtensionMethodAttribute attribute, MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
[ExtensionAttribute]
internal static class NHibernate.Linq.Functions.HqlGeneratorForMethodExtensions : object {
    [ExtensionAttribute]
public static bool AllowsNullableReturnType(IHqlGeneratorForMethod generator, MethodInfo method);
    [ExtensionAttribute]
public static bool TryGetCollectionParameters(IHqlGeneratorForMethod generator, MethodCallExpression expression, ConstantExpression& collectionParameter);
    [ExtensionAttribute]
public static bool AllowPreEvaluation(IHqlGeneratorForMethod generator, MemberInfo member, ISessionFactoryImplementor factory);
    [ExtensionAttribute]
public static bool IgnoreInstance(IHqlGeneratorForMethod generator, MemberInfo member);
}
[ExtensionAttribute]
public static class NHibernate.Linq.Functions.HqlGeneratorForPropertyExtensions : object {
    [ExtensionAttribute]
public static bool AllowPreEvaluation(IHqlGeneratorForProperty generator, MemberInfo member, ISessionFactoryImplementor factory);
}
public interface NHibernate.Linq.Functions.IAllowPreEvaluationHqlGenerator {
    public abstract virtual bool AllowPreEvaluation(MemberInfo member, ISessionFactoryImplementor factory);
    public abstract virtual bool IgnoreInstance(MemberInfo member);
}
public interface NHibernate.Linq.Functions.IHqlGeneratorForMethod {
    public IEnumerable`1<MethodInfo> SupportedMethods { get; }
    public abstract virtual IEnumerable`1<MethodInfo> get_SupportedMethods();
    public abstract virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal interface NHibernate.Linq.Functions.IHqlGeneratorForMethodExtended {
    public abstract virtual bool AllowsNullableReturnType(MethodInfo method);
    public abstract virtual bool TryGetCollectionParameter(MethodCallExpression expression, ConstantExpression& collectionParameter);
}
public interface NHibernate.Linq.Functions.IHqlGeneratorForProperty {
    public IEnumerable`1<MemberInfo> SupportedProperties { get; }
    public abstract virtual IEnumerable`1<MemberInfo> get_SupportedProperties();
    public abstract virtual HqlTreeNode BuildHql(MemberInfo member, Expression expression, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public interface NHibernate.Linq.Functions.ILinqToHqlGeneratorsRegistry {
    public abstract virtual bool TryGetGenerator(MethodInfo method, IHqlGeneratorForMethod& generator);
    public abstract virtual bool TryGetGenerator(MemberInfo property, IHqlGeneratorForProperty& generator);
    public abstract virtual void RegisterGenerator(MethodInfo method, IHqlGeneratorForMethod generator);
    public abstract virtual void RegisterGenerator(MemberInfo property, IHqlGeneratorForProperty generator);
    public abstract virtual void RegisterGenerator(IRuntimeMethodHqlGenerator generator);
}
public class NHibernate.Linq.Functions.IndexOfGenerator : BaseHqlGeneratorForMethod {
    private static MethodInfo MethodWithComparer1;
    private static MethodInfo MethodWithComparer2;
    private static IndexOfGenerator();
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public interface NHibernate.Linq.Functions.IRuntimeMethodHqlGenerator {
    public abstract virtual bool SupportsMethod(MethodInfo method);
    public abstract virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
}
public class NHibernate.Linq.Functions.LengthGenerator : BaseHqlGeneratorForProperty {
    public virtual HqlTreeNode BuildHql(MemberInfo member, Expression expression, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.LikeGenerator : object {
    public IEnumerable`1<MethodInfo> SupportedMethods { get; }
    public sealed virtual IEnumerable`1<MethodInfo> get_SupportedMethods();
    public sealed virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
    public sealed virtual bool AllowsNullableReturnType(MethodInfo method);
    public sealed virtual bool TryGetCollectionParameter(MethodCallExpression expression, ConstantExpression& collectionParameter);
}
[ExtensionAttribute]
public static class NHibernate.Linq.Functions.LinqToHqlGeneratorsRegistryExtensions : object {
    [ExtensionAttribute]
public static void Merge(ILinqToHqlGeneratorsRegistry registry, IHqlGeneratorForMethod generator);
    [ExtensionAttribute]
public static void Merge(ILinqToHqlGeneratorsRegistry registry, IHqlGeneratorForProperty generator);
}
public class NHibernate.Linq.Functions.LinqToHqlGeneratorsRegistryFactory : object {
    private static INHibernateLogger log;
    private static LinqToHqlGeneratorsRegistryFactory();
    public static ILinqToHqlGeneratorsRegistry CreateGeneratorsRegistry(IDictionary`2<string, string> properties);
}
internal class NHibernate.Linq.Functions.ListIndexerGenerator : BaseHqlGeneratorForMethod {
    private static HashSet`1<MethodInfo> _supportedMethods;
    private static ListIndexerGenerator();
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public static bool IsMethodSupported(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    private static bool IsRuntimeMethodSupported(MethodInfo method);
}
public class NHibernate.Linq.Functions.MathGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression expression, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.MaxHqlGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.MinHqlGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.NewGuidHqlGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    public sealed virtual bool AllowPreEvaluation(MemberInfo member, ISessionFactoryImplementor factory);
    public sealed virtual bool IgnoreInstance(MemberInfo member);
}
public class NHibernate.Linq.Functions.RandomHqlGenerator : BaseHqlGeneratorForMethod {
    private MethodInfo _nextDouble;
    private static string _randomFunctionName;
    private static string _floorFunctionName;
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    public sealed virtual bool AllowPreEvaluation(MemberInfo member, ISessionFactoryImplementor factory);
    public sealed virtual bool IgnoreInstance(MemberInfo member);
}
public class NHibernate.Linq.Functions.ReplaceGenerator : BaseHqlGeneratorForMethod {
    private static MethodInfo MethodWithComparer;
    private static ReplaceGenerator();
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
internal class NHibernate.Linq.Functions.RoundGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.StandardLinqExtensionMethodGenerator : object {
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
}
public class NHibernate.Linq.Functions.StartsWithGenerator : BaseHqlGeneratorForMethod {
    private static MethodInfo MethodWithComparer;
    private static StartsWithGenerator();
    public virtual bool AllowsNullableReturnType(MethodInfo method);
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.SubStringGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.ToLowerGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.ToStringHqlGeneratorForMethod : object {
    public IEnumerable`1<MethodInfo> SupportedMethods { get; }
    public sealed virtual IEnumerable`1<MethodInfo> get_SupportedMethods();
    public sealed virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.ToStringRuntimeMethodHqlGenerator : object {
    private ToStringHqlGeneratorForMethod generator;
    public sealed virtual bool SupportsMethod(MethodInfo method);
    public sealed virtual IHqlGeneratorForMethod GetMethodGenerator(MethodInfo method);
}
public class NHibernate.Linq.Functions.ToUpperGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Functions.TrimGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression targetObject, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
    private static string ExtractTrimChars(IReadOnlyList`1<Expression> arguments);
}
internal class NHibernate.Linq.Functions.TruncateGenerator : BaseHqlGeneratorForMethod {
    public virtual HqlTreeNode BuildHql(MethodInfo method, Expression expression, ReadOnlyCollection`1<Expression> arguments, HqlTreeBuilder treeBuilder, IHqlExpressionVisitor visitor);
}
[ExtensionAttribute]
internal static class NHibernate.Linq.Functions.UnionExtension : object {
    [IteratorStateMachineAttribute("NHibernate.Linq.Functions.UnionExtension/<Union>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<HqlTreeNode> Union(HqlTreeNode first, IEnumerable`1<HqlTreeNode> rest);
}
public static class NHibernate.Linq.GroupBy.AggregatingGroupByRewriter : object {
    private static ICollection`1<Type> AcceptableOuterResultOperators;
    private static AggregatingGroupByRewriter();
    public static void ReWrite(QueryModel queryModel);
    private static void FlattenSubQuery(QueryModel queryModel, QueryModel subQueryModel, GroupResultOperator groupBy);
    private static void RemoveCostantGroupByKeys(QueryModel queryModel, GroupResultOperator groupBy);
}
public class NHibernate.Linq.GroupBy.ClientSideSelect : ClientSideTransformOperator {
    [CompilerGeneratedAttribute]
private LambdaExpression <SelectClause>k__BackingField;
    public LambdaExpression SelectClause { get; private set; }
    public ClientSideSelect(LambdaExpression selectClause);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SelectClause();
    [CompilerGeneratedAttribute]
private void set_SelectClause(LambdaExpression value);
}
public class NHibernate.Linq.GroupBy.ClientSideSelect2 : ClientSideTransformOperator {
    [CompilerGeneratedAttribute]
private LambdaExpression <SelectClause>k__BackingField;
    public LambdaExpression SelectClause { get; private set; }
    public ClientSideSelect2(LambdaExpression selectClause);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SelectClause();
    [CompilerGeneratedAttribute]
private void set_SelectClause(LambdaExpression value);
}
internal class NHibernate.Linq.GroupBy.GroupBySelectClauseRewriter : RelinqExpressionVisitor {
    private static HashSet`1<ExpressionType> _validElementSelectorTypes;
    private GroupResultOperator _groupBy;
    private QueryModel _model;
    private Expression _nominatedKeySelector;
    private GroupBySelectClauseRewriter(GroupResultOperator groupBy, QueryModel model);
    private static GroupBySelectClauseRewriter();
    public static Expression ReWrite(Expression expression, GroupResultOperator groupBy, QueryModel model);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    protected virtual Expression VisitMember(MemberExpression expression);
    private bool IsMemberOfModel(MemberExpression expression);
    private bool IsMemberOfModel(QuerySourceReferenceExpression expression);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    private static Expression UnwrapUnary(Expression expression);
    [CompilerGeneratedAttribute]
private Expression <VisitSubQuery>b__10_0(Expression e);
}
internal class NHibernate.Linq.GroupBy.GroupKeyNominator : RelinqExpressionVisitor {
    private bool _requiresRootNomination;
    private bool _transformed;
    private int _depth;
    public static Expression Visit(GroupResultOperator groupBy);
    private static Expression VisitInternal(Expression expr);
    public virtual Expression Visit(Expression expression);
    protected virtual Expression VisitNewArray(NewArrayExpression expression);
    protected virtual Expression VisitNew(NewExpression expression);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    protected virtual Expression VisitBinary(BinaryExpression expression);
}
internal class NHibernate.Linq.GroupBy.IsNonAggregatingGroupByDetectionVisitor : NhExpressionVisitor {
    private bool _containsNakedQuerySourceReferenceExpression;
    public bool IsNonAggregatingGroupBy(Expression expression);
    protected virtual Expression VisitMember(MemberExpression expression);
    protected internal virtual Expression VisitNhAggregated(NhAggregatedExpression expression);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
}
internal class NHibernate.Linq.GroupBy.KeySelectorVisitor : RelinqExpressionVisitor {
    private GroupResultOperator _groupBy;
    public KeySelectorVisitor(GroupResultOperator groupBy);
    protected virtual Expression VisitMember(MemberExpression expression);
}
public static class NHibernate.Linq.GroupBy.NonAggregatingGroupByRewriter : object {
    public static void ReWrite(QueryModel queryModel);
    private static void FlattenSubQuery(SubQueryExpression subQueryExpression, QueryModel queryModel);
    private static ClientSideSelect CreateClientSideSelect(Expression expression, QueryModel queryModel);
    private static bool IsNonAggregatingGroupBy(QueryModel queryModel);
}
internal static class NHibernate.Linq.GroupBy.PagingRewriter : object {
    private static Type[] PagingResultOperators;
    private static PagingRewriter();
    public static void ReWrite(QueryModel queryModel);
    private static void FlattenSubQuery(SubQueryExpression subQueryExpression, QueryModel queryModel);
}
public static class NHibernate.Linq.GroupJoin.AggregatingGroupJoinRewriter : object {
    public static void ReWrite(QueryModel model);
    private static IsAggregatingResults IsAggregatingGroupJoin(QueryModel model, IEnumerable`1<GroupJoinClause> clause);
}
internal class NHibernate.Linq.GroupJoin.GroupJoinAggregateDetectionQueryModelVisitor : NhQueryModelVisitorBase {
    private GroupJoinAggregateDetectionVisitor _groupJoinAggregateDetectionVisitor;
    private GroupJoinAggregateDetectionQueryModelVisitor(IEnumerable`1<GroupJoinClause> groupJoinClauses);
    public static IsAggregatingResults Visit(IEnumerable`1<GroupJoinClause> groupJoinClause, QueryModel queryModel);
    public virtual void VisitWhereClause(WhereClause whereClause, QueryModel queryModel, int index);
    public virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    public virtual void VisitOrdering(Ordering ordering, QueryModel queryModel, OrderByClause orderByClause, int index);
}
internal class NHibernate.Linq.GroupJoin.GroupJoinAggregateDetectionVisitor : NhExpressionVisitor {
    private HashSet`1<GroupJoinClause> _groupJoinClauses;
    private StackFlag _inAggregate;
    private StackFlag _parentExpressionProcessed;
    private List`1<Expression> _nonAggregatingExpressions;
    private List`1<GroupJoinClause> _nonAggregatingGroupJoins;
    private List`1<GroupJoinClause> _aggregatingGroupJoins;
    internal GroupJoinAggregateDetectionVisitor(IEnumerable`1<GroupJoinClause> groupJoinClause);
    public static IsAggregatingResults Visit(IEnumerable`1<GroupJoinClause> groupJoinClause, Expression selectExpression);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    protected internal virtual Expression VisitNhAggregated(NhAggregatedExpression expression);
    protected virtual Expression VisitMember(MemberExpression expression);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    internal IsAggregatingResults GetResults();
    private static IsAggregatingResults GetResults(GroupJoinAggregateDetectionVisitor visitor);
}
public class NHibernate.Linq.GroupJoin.GroupJoinSelectClauseRewriter : RelinqExpressionVisitor {
    private IsAggregatingResults _results;
    private GroupJoinSelectClauseRewriter(IsAggregatingResults results);
    public static Expression ReWrite(Expression expression, IsAggregatingResults results);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    private GroupJoinClause LocateGroupJoinQuerySource(QueryModel model);
}
public class NHibernate.Linq.GroupJoin.IsAggregatingResults : object {
    [CompilerGeneratedAttribute]
private List`1<GroupJoinClause> <NonAggregatingClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<GroupJoinClause> <AggregatingClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <NonAggregatingExpressions>k__BackingField;
    public List`1<GroupJoinClause> NonAggregatingClauses { get; public set; }
    public List`1<GroupJoinClause> AggregatingClauses { get; public set; }
    public List`1<Expression> NonAggregatingExpressions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<GroupJoinClause> get_NonAggregatingClauses();
    [CompilerGeneratedAttribute]
public void set_NonAggregatingClauses(List`1<GroupJoinClause> value);
    [CompilerGeneratedAttribute]
public List`1<GroupJoinClause> get_AggregatingClauses();
    [CompilerGeneratedAttribute]
public void set_AggregatingClauses(List`1<GroupJoinClause> value);
    [CompilerGeneratedAttribute]
public List`1<Expression> get_NonAggregatingExpressions();
    [CompilerGeneratedAttribute]
public void set_NonAggregatingExpressions(List`1<Expression> value);
}
public class NHibernate.Linq.GroupJoin.LocateGroupJoinQuerySource : RelinqExpressionVisitor {
    private IsAggregatingResults _results;
    private GroupJoinClause _groupJoin;
    public LocateGroupJoinQuerySource(IsAggregatingResults results);
    public GroupJoinClause Detect(Expression expression);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
}
[ExtensionAttribute]
internal static class NHibernate.Linq.GroupResultOperatorExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Expression> ExtractKeyExpressions(GroupResultOperator groupResult);
    [ExtensionAttribute]
private static IEnumerable`1<Expression> ExtractKeyExpressions(Expression expr);
    private static IEnumerable`1<Expression> ExtractKeyExpressions(MemberBinding memberBinding);
}
internal interface NHibernate.Linq.IEntityNameProvider {
    public string EntityName { get; }
    public abstract virtual string get_EntityName();
}
public interface NHibernate.Linq.ILinqQueryExpression {
    public ExpressionToHqlTranslationResults ExpressionToHqlTranslationResults { get; }
    public abstract virtual ExpressionToHqlTranslationResults get_ExpressionToHqlTranslationResults();
    public abstract virtual IDictionary`2<string, Tuple`2<IType, bool>> GetNamedParameterTypes();
    public abstract virtual void CopyExpressionTranslation(NhLinqExpressionCache cache);
}
public interface NHibernate.Linq.INhFetchRequest`2 {
}
public interface NHibernate.Linq.INhQueryModelVisitor {
    public abstract virtual void VisitNhJoinClause(NhJoinClause nhJoinClause, QueryModel queryModel, int index);
    public abstract virtual void VisitNhWithClause(NhWithClause nhWhereClause, QueryModel queryModel, int index);
    public abstract virtual void VisitNhHavingClause(NhHavingClause nhWhereClause, QueryModel queryModel, int index);
}
internal interface NHibernate.Linq.INhQueryModelVisitorExtended {
    public abstract virtual void VisitNhOuterJoinClause(NhOuterJoinClause nhOuterJoinClause, QueryModel queryModel, int index);
}
public interface NHibernate.Linq.INhQueryProvider {
    public abstract virtual Task`1<int> ExecuteDmlAsync(QueryMode queryMode, Expression expression, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by ISupportFutureBatchNhQueryProvider interface")]
public abstract virtual IFutureEnumerable`1<TResult> ExecuteFuture(Expression expression);
    [ObsoleteAttribute("Replaced by ISupportFutureBatchNhQueryProvider interface")]
public abstract virtual IFutureValue`1<TResult> ExecuteFutureValue(Expression expression);
    public abstract virtual void SetResultTransformerAndAdditionalCriteria(IQuery query, NhLinqExpression nhExpression, IDictionary`2<string, Tuple`2<object, IType>> parameters);
    public abstract virtual int ExecuteDml(QueryMode queryMode, Expression expression);
    public abstract virtual Task`1<TResult> ExecuteAsync(Expression expression, CancellationToken cancellationToken);
}
public class NHibernate.Linq.InsertBuilder`1 : object {
    private IQueryable`1<TSource> _source;
    internal InsertBuilder`1(IQueryable`1<TSource> source);
    public InsertBuilder`2<TSource, TTarget> Into();
}
public class NHibernate.Linq.InsertBuilder`2 : object {
    private IQueryable`1<TSource> _source;
    private Assignments`2<TSource, TTarget> _assignments;
    internal InsertBuilder`2(IQueryable`1<TSource> source);
    public Task`1<int> InsertAsync(CancellationToken cancellationToken);
    public InsertBuilder`2<TSource, TTarget> Value(Expression`1<Func`2<TTarget, TProp>> property, Expression`1<Func`2<TSource, TProp>> expression);
    public InsertBuilder`2<TSource, TTarget> Value(Expression`1<Func`2<TTarget, TProp>> property, TProp value);
    public int Insert();
}
public class NHibernate.Linq.IntermediateHqlTree : object {
    private bool _isRoot;
    private List`1<Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>>> _additionalCriteria;
    private List`1<LambdaExpression> _listTransformers;
    private List`1<LambdaExpression> _itemTransformers;
    private List`1<LambdaExpression> _postExecuteTransformers;
    private bool _hasDistinctRootOperator;
    private HqlExpression _skipCount;
    private HqlExpression _takeCount;
    private HqlHaving _hqlHaving;
    private HqlTreeNode _root;
    private HqlOrderBy _orderBy;
    private HqlInsert _insertRoot;
    [CompilerGeneratedAttribute]
private Type <ExecuteResultTypeOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private HqlTreeBuilder <TreeBuilder>k__BackingField;
    public bool IsRoot { get; }
    public HqlTreeNode Root { get; }
    public Type ExecuteResultTypeOverride { get; public set; }
    public HqlTreeBuilder TreeBuilder { get; }
    public IntermediateHqlTree(bool root, QueryMode mode);
    public bool get_IsRoot();
    public HqlTreeNode get_Root();
    private void AddPendingHqlClausesToRoot();
    [CompilerGeneratedAttribute]
public Type get_ExecuteResultTypeOverride();
    [CompilerGeneratedAttribute]
public void set_ExecuteResultTypeOverride(Type value);
    [CompilerGeneratedAttribute]
public HqlTreeBuilder get_TreeBuilder();
    public ExpressionToHqlTranslationResults GetTranslation();
    public void AddDistinctRootOperator();
    public void AddItemTransformer(LambdaExpression transformer);
    public void AddFromClause(HqlTreeNode from);
    internal HqlTreeNode GetFromNodeByAlias(string alias);
    private static string GetNodeAlias(HqlTreeNode fromNode);
    internal HqlRange GetFromRangeClause();
    public void AddSelectClause(HqlTreeNode select);
    public void AddFromLastChildClause(HqlTreeNode[] nodes);
    public void AddInsertClause(HqlIdent target, HqlRange columnSpec);
    public void AddGroupByClause(HqlGroupBy groupBy);
    public void AddOrderByClause(HqlExpression orderBy, HqlDirectionStatement direction);
    public void AddSkipClause(HqlExpression toSkip);
    public void AddTakeClause(HqlExpression toTake);
    private void ExecuteAddOrderBy(HqlTreeNode orderBy);
    private void ExecuteAddTakeClause(HqlExpression toTake);
    private void ExecuteAddSkipClause(HqlExpression toSkip);
    private void ExecuteAddHavingClause(HqlHaving hqlHaving);
    public void AddWhereClause(HqlBooleanExpression where);
    public void AddHavingClause(HqlBooleanExpression where);
    public void AddSet(HqlEquality equality);
    public void AddAdditionalCriteria(Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>> criteria);
    public void AddPostExecuteTransformer(LambdaExpression lambda);
    public void AddListTransformer(LambdaExpression lambda);
    public void SetRoot(HqlTreeNode newRoot);
}
[ObsoleteAttribute("Please use NhQueryableOptions instead.")]
public interface NHibernate.Linq.IQueryableOptions {
    public abstract virtual IQueryableOptions SetCacheable(bool cacheable);
    public abstract virtual IQueryableOptions SetCacheRegion(string cacheRegion);
    public abstract virtual IQueryableOptions SetCacheMode(CacheMode cacheMode);
    public abstract virtual IQueryableOptions SetTimeout(int timeout);
}
public interface NHibernate.Linq.IQueryProviderWithOptions {
    public abstract virtual IQueryProvider WithOptions(Action`1<NhQueryableOptions> setOptions);
}
public interface NHibernate.Linq.ISupportFutureBatchNhQueryProvider {
    public ISessionImplementor Session { get; }
    public abstract virtual IQuery GetPreparedQuery(Expression expression, NhLinqExpression& nhExpression);
    public abstract virtual ISessionImplementor get_Session();
}
public class NHibernate.Linq.LinqExtensionMethodAttribute : LinqExtensionMethodAttributeBase {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public LinqExtensionMethodAttribute(string name);
    public LinqExtensionMethodAttribute(LinqExtensionPreEvaluation preEvaluation);
    public LinqExtensionMethodAttribute(string name, LinqExtensionPreEvaluation preEvaluation);
    [CompilerGeneratedAttribute]
public string get_Name();
}
public abstract class NHibernate.Linq.LinqExtensionMethodAttributeBase : Attribute {
    [CompilerGeneratedAttribute]
private LinqExtensionPreEvaluation <PreEvaluation>k__BackingField;
    public LinqExtensionPreEvaluation PreEvaluation { get; }
    protected LinqExtensionMethodAttributeBase(LinqExtensionPreEvaluation preEvaluation);
    [CompilerGeneratedAttribute]
public LinqExtensionPreEvaluation get_PreEvaluation();
}
[ExtensionAttribute]
public static class NHibernate.Linq.LinqExtensionMethods : object {
    [ExtensionAttribute]
public static Task`1<bool> AnyAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> AnyAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> AllAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> CountAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> CountAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> SumAsync(IQueryable`1<int> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<int>> SumAsync(IQueryable`1<Nullable`1<int>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<long> SumAsync(IQueryable`1<long> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<long>> SumAsync(IQueryable`1<Nullable`1<long>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<float> SumAsync(IQueryable`1<float> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<float>> SumAsync(IQueryable`1<Nullable`1<float>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<double> SumAsync(IQueryable`1<double> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<double>> SumAsync(IQueryable`1<Nullable`1<double>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<decimal> SumAsync(IQueryable`1<decimal> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<decimal>> SumAsync(IQueryable`1<Nullable`1<decimal>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<int>> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<long> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<long>> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<float> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<float>> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<double> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<double>> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<decimal> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<decimal>> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<double> AverageAsync(IQueryable`1<int> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<double>> AverageAsync(IQueryable`1<Nullable`1<int>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<double> AverageAsync(IQueryable`1<long> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<double>> AverageAsync(IQueryable`1<Nullable`1<long>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<float> AverageAsync(IQueryable`1<float> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<float>> AverageAsync(IQueryable`1<Nullable`1<float>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<double> AverageAsync(IQueryable`1<double> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<double>> AverageAsync(IQueryable`1<Nullable`1<double>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<decimal> AverageAsync(IQueryable`1<decimal> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<decimal>> AverageAsync(IQueryable`1<Nullable`1<decimal>> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<double> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<double>> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<double> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<double>> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<float> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<float>> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<double> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<double>> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<decimal> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Nullable`1<decimal>> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> MinAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TResult> MinAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> MaxAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TResult> MaxAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<long> LongCountAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<long> LongCountAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> FirstAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> FirstAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> SingleAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> SingleAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> SingleOrDefaultAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> SingleOrDefaultAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> FirstOrDefaultAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TSource> FirstOrDefaultAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<List`1<TSource>> ToListAsync(IQueryable`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IFutureEnumerable`1<TSource> ToFuture(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IFutureValue`1<TSource> ToFutureValue(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> ToFutureValue(IQueryable`1<TSource> source, Expression`1<Func`2<IQueryable`1<TSource>, TResult>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> LeftJoin(IQueryable`1<TOuter> outer, IQueryable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use WithOptions instead.")]
public static IQueryable`1<T> SetOptions(IQueryable`1<T> query, Action`1<IQueryableOptions> setOptions);
    [ExtensionAttribute]
public static IQueryable`1<T> WithOptions(IQueryable`1<T> query, Action`1<NhQueryableOptions> setOptions);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use WithOptions instead.")]
public static IQueryable`1<T> Cacheable(IQueryable`1<T> query);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use WithOptions instead.")]
public static IQueryable`1<T> CacheMode(IQueryable`1<T> query, CacheMode cacheMode);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use WithOptions instead.")]
public static IQueryable`1<T> CacheRegion(IQueryable`1<T> query, string region);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use WithOptions instead.")]
public static IQueryable`1<T> Timeout(IQueryable`1<T> query, int timeout);
    [ExtensionAttribute]
public static IQueryable`1<T> WithLock(IQueryable`1<T> query, LockMode lockMode);
    [ExtensionAttribute]
public static IEnumerable`1<T> WithLock(IEnumerable`1<T> query, LockMode lockMode);
    [ExtensionAttribute]
[NoPreEvaluationAttribute]
public static T MappedAs(T parameter, IType type);
    [ExtensionAttribute]
internal static INhQueryProvider GetNhProvider(IQueryable`1<TSource> source);
}
public enum NHibernate.Linq.LinqExtensionPreEvaluation : Enum {
    public int value__;
    public static LinqExtensionPreEvaluation NoEvaluation;
    public static LinqExtensionPreEvaluation AllowPreEvaluation;
}
internal static class NHibernate.Linq.LinqLogging : object {
    private static INHibernateLogger Log;
    private static LinqLogging();
    internal static void LogExpression(string msg, Expression expression);
}
internal class NHibernate.Linq.LockExpressionNode : ResultOperatorExpressionNodeBase {
    private static ParameterExpression Parameter;
    private ConstantExpression _lockMode;
    private ResolvedExpressionCache`1<Expression> _cache;
    public LockExpressionNode(MethodCallExpressionParseInfo parseInfo, ConstantExpression lockMode);
    private static LockExpressionNode();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
internal class NHibernate.Linq.LockResultOperator : ResultOperatorBase {
    private QuerySourceReferenceExpression _qsrExpression;
    [CompilerGeneratedAttribute]
private ConstantExpression <LockMode>k__BackingField;
    public IQuerySource QuerySource { get; }
    public ConstantExpression LockMode { get; }
    public LockResultOperator(QuerySourceReferenceExpression qsrExpression, ConstantExpression lockMode);
    public IQuerySource get_QuerySource();
    [CompilerGeneratedAttribute]
public ConstantExpression get_LockMode();
    public virtual IStreamedData ExecuteInMemory(IStreamedData input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
}
internal class NHibernate.Linq.NestedSelects.ExpressionHolder : object {
    [CompilerGeneratedAttribute]
private int <Tuple>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public int Tuple { get; public set; }
    public Expression Expression { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Tuple();
    [CompilerGeneratedAttribute]
public void set_Tuple(int value);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(Expression value);
}
internal class NHibernate.Linq.NestedSelects.NestedSelectDetector : RelinqExpressionVisitor {
    private ISessionFactory sessionFactory;
    private ICollection`1<Expression> _expressions;
    public ICollection`1<Expression> Expressions { get; }
    public bool HasSubqueries { get; }
    public NestedSelectDetector(ISessionFactory sessionFactory);
    public ICollection`1<Expression> get_Expressions();
    public bool get_HasSubqueries();
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    protected virtual Expression VisitMember(MemberExpression expression);
    private bool IsMappedCollection(MemberInfo memberInfo);
    private bool IsChainedFromQuerySourceReference(MemberExpression expression);
}
internal static class NHibernate.Linq.NestedSelects.NestedSelectRewriter : object {
    private static MethodInfo CastMethod;
    private static MethodInfo GroupByMethod;
    private static MethodInfo WhereMethod;
    private static MethodInfo ObjectReferenceEquals;
    private static PropertyInfo IGroupingKeyProperty;
    private static NestedSelectRewriter();
    public static void ReWrite(QueryModel queryModel, ISessionFactory sessionFactory);
    private static Expression ProcessExpression(QueryModel queryModel, ISessionFactory sessionFactory, Expression expression, List`1<ExpressionHolder> elementExpression, ParameterExpression group);
    private static Expression ProcessSubquery(ISessionFactory sessionFactory, ICollection`1<ExpressionHolder> elementExpression, QueryModel queryModel, Expression group, QueryModel subQueryModel);
    private static bool IsEnumerableOfT(Type type);
    private static Expression ProcessMemberExpression(ISessionFactory sessionFactory, ICollection`1<ExpressionHolder> elementExpression, QueryModel queryModel, Expression group, Expression memberExpression);
    private static Expression BuildSubCollectionQuery(ISessionFactory sessionFactory, ICollection`1<ExpressionHolder> expressions, Expression group, Expression source, Expression select, Type elementType, Type collectionType);
    private static LambdaExpression MakeSelector(ICollection`1<ExpressionHolder> elementExpression, Expression select, Expression identifier);
    private static Expression SubCollectionQuery(Type collectionType, Type elementType, Expression source, Expression predicate, Expression selector);
    private static ConstructorInfo GetCollectionConstructor(Type collectionType, Type elementType);
    private static LambdaExpression MakePredicate(int index);
    private static Expression GetIdentifier(ISessionFactory sessionFactory, Expression expression);
    private static LambdaExpression CreateSelector(IEnumerable`1<ExpressionHolder> expressions, int tuple);
    private static Expression ArrayIndex(Expression param, int value);
    private static Expression ConvertToObject(Expression expression);
    private static Type GetElementType(Type type);
}
internal class NHibernate.Linq.NestedSelects.SelectClauseRewriter : RelinqExpressionVisitor {
    private Dictionary`2<Expression, Expression> _dictionary;
    private ICollection`1<ExpressionHolder> expressions;
    private Expression parameter;
    private int tuple;
    public SelectClauseRewriter(Expression parameter, ICollection`1<ExpressionHolder> expressions, Expression expression, Dictionary`2<Expression, Expression> dictionary);
    public SelectClauseRewriter(Expression parameter, ICollection`1<ExpressionHolder> expressions, Expression expression, int tuple, Dictionary`2<Expression, Expression> dictionary);
    public virtual Expression Visit(Expression expression);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitMember(MemberExpression expression);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    private Expression AddAndConvertExpression(Expression expression);
    private Expression AddAndConvertExpression(Expression expression, Type type);
}
internal class NHibernate.Linq.NestedSelects.Tuple : object {
    public static ConstructorInfo Constructor;
    public static PropertyInfo ItemsProperty;
    private Object[] _items;
    public Object[] Items { get; }
    public Tuple(Object[] items);
    private static Tuple();
    public Object[] get_Items();
    public sealed virtual bool Equals(Tuple other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NHibernate.Linq.NhFetchRequest`2 : QueryableBase`1<TQueried> {
    public NhFetchRequest`2(IQueryProvider provider, Expression expression);
}
public class NHibernate.Linq.NHibernateNodeTypeProvider : object {
    private INodeTypeProvider defaultNodeTypeProvider;
    public sealed virtual bool IsRegistered(MethodInfo method);
    public sealed virtual Type GetNodeType(MethodInfo method);
}
public class NHibernate.Linq.NhLinqDmlExpression`1 : NhLinqExpression {
    protected Type TargetType { get; }
    public NhLinqDmlExpression`1(QueryMode queryMode, Expression expression, ISessionFactoryImplementor sessionFactory);
    protected virtual Type get_TargetType();
}
public class NHibernate.Linq.NhLinqExpression : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanCachePlan>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NamedParameterDescriptor> <ParameterDescriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private NhLinqExpressionReturnType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Tuple`2<object, IType>> <ParameterValuesByName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionToHqlTranslationResults <ExpressionToHqlTranslationResults>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryMode <QueryMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, NamedParameter> <NamedParameters>k__BackingField;
    private Expression _expression;
    private IDictionary`2<ConstantExpression, NamedParameter> _constantToParameterMap;
    public string Key { get; protected set; }
    public bool CanCachePlan { get; private set; }
    public Type Type { get; private set; }
    protected Type TargetType { get; }
    public IList`1<NamedParameterDescriptor> ParameterDescriptors { get; private set; }
    public NhLinqExpressionReturnType ReturnType { get; }
    public IDictionary`2<string, Tuple`2<object, IType>> ParameterValuesByName { get; }
    public ExpressionToHqlTranslationResults ExpressionToHqlTranslationResults { get; private set; }
    protected QueryMode QueryMode { get; }
    public IDictionary`2<string, NamedParameter> NamedParameters { get; }
    public NhLinqExpression(Expression expression, ISessionFactoryImplementor sessionFactory);
    internal NhLinqExpression(QueryMode queryMode, Expression expression, ISessionFactoryImplementor sessionFactory);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
protected void set_Key(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanCachePlan();
    [CompilerGeneratedAttribute]
private void set_CanCachePlan(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    protected virtual Type get_TargetType();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<NamedParameterDescriptor> get_ParameterDescriptors();
    [CompilerGeneratedAttribute]
private void set_ParameterDescriptors(IList`1<NamedParameterDescriptor> value);
    [CompilerGeneratedAttribute]
public NhLinqExpressionReturnType get_ReturnType();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, Tuple`2<object, IType>> get_ParameterValuesByName();
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionToHqlTranslationResults get_ExpressionToHqlTranslationResults();
    [CompilerGeneratedAttribute]
private void set_ExpressionToHqlTranslationResults(ExpressionToHqlTranslationResults value);
    [CompilerGeneratedAttribute]
protected virtual QueryMode get_QueryMode();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, NamedParameter> get_NamedParameters();
    public sealed virtual IASTNode Translate(ISessionFactoryImplementor sessionFactory, bool filter);
    public sealed virtual void CopyExpressionTranslation(NhLinqExpressionCache cache);
    public sealed virtual IDictionary`2<string, Tuple`2<IType, bool>> GetNamedParameterTypes();
    private static IASTNode DuplicateTree(IASTNode ast);
}
public class NHibernate.Linq.NhLinqExpressionCache : object {
    [CompilerGeneratedAttribute]
private ExpressionToHqlTranslationResults <ExpressionToHqlTranslationResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NamedParameterDescriptor> <ParameterDescriptors>k__BackingField;
    public ExpressionToHqlTranslationResults ExpressionToHqlTranslationResults { get; }
    public string Key { get; }
    public Type Type { get; }
    public IList`1<NamedParameterDescriptor> ParameterDescriptors { get; }
    internal NhLinqExpressionCache(ILinqQueryExpression expression);
    [CompilerGeneratedAttribute]
public ExpressionToHqlTranslationResults get_ExpressionToHqlTranslationResults();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<NamedParameterDescriptor> get_ParameterDescriptors();
    public sealed virtual IASTNode Translate(ISessionFactoryImplementor sessionFactory, bool filter);
}
public enum NHibernate.Linq.NhLinqExpressionReturnType : Enum {
    public int value__;
    public static NhLinqExpressionReturnType Sequence;
    public static NhLinqExpressionReturnType Scalar;
}
public class NHibernate.Linq.NhQueryable`1 : QueryableBase`1<T> {
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    public string EntityName { get; private set; }
    public NhQueryable`1(ISessionImplementor session);
    public NhQueryable`1(ISessionImplementor session, string entityName);
    public NhQueryable`1(IQueryProvider provider, Expression expression);
    public NhQueryable`1(IQueryProvider provider, Expression expression, string entityName);
    public NhQueryable`1(ISessionImplementor session, object collection);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EntityName();
    [CompilerGeneratedAttribute]
private void set_EntityName(string value);
    public virtual string ToString();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
public class NHibernate.Linq.NhQueryableOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Cacheable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CacheMode> <CacheMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FlushMode> <FlushMode>k__BackingField;
    protected Nullable`1<bool> Cacheable { get; private set; }
    protected Nullable`1<CacheMode> CacheMode { get; private set; }
    protected string CacheRegion { get; private set; }
    protected Nullable`1<int> Timeout { get; private set; }
    protected Nullable`1<bool> ReadOnly { get; private set; }
    protected string Comment { get; private set; }
    protected Nullable`1<FlushMode> FlushMode { get; private set; }
    [CompilerGeneratedAttribute]
protected Nullable`1<bool> get_Cacheable();
    [CompilerGeneratedAttribute]
private void set_Cacheable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
protected Nullable`1<CacheMode> get_CacheMode();
    [CompilerGeneratedAttribute]
private void set_CacheMode(Nullable`1<CacheMode> value);
    [CompilerGeneratedAttribute]
protected string get_CacheRegion();
    [CompilerGeneratedAttribute]
private void set_CacheRegion(string value);
    [CompilerGeneratedAttribute]
protected Nullable`1<int> get_Timeout();
    [CompilerGeneratedAttribute]
private void set_Timeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
protected Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
private void set_ReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
protected string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
    [CompilerGeneratedAttribute]
protected Nullable`1<FlushMode> get_FlushMode();
    [CompilerGeneratedAttribute]
private void set_FlushMode(Nullable`1<FlushMode> value);
    private sealed virtual override IQueryableOptions NHibernate.Linq.IQueryableOptions.SetCacheable(bool cacheable);
    private sealed virtual override IQueryableOptions NHibernate.Linq.IQueryableOptions.SetCacheMode(CacheMode cacheMode);
    private sealed virtual override IQueryableOptions NHibernate.Linq.IQueryableOptions.SetCacheRegion(string cacheRegion);
    private sealed virtual override IQueryableOptions NHibernate.Linq.IQueryableOptions.SetTimeout(int timeout);
    public NhQueryableOptions SetCacheable(bool cacheable);
    public NhQueryableOptions SetCacheMode(CacheMode cacheMode);
    public NhQueryableOptions SetCacheRegion(string cacheRegion);
    public NhQueryableOptions SetTimeout(int timeout);
    public NhQueryableOptions SetReadOnly(bool readOnly);
    public NhQueryableOptions SetComment(string comment);
    public NhQueryableOptions SetFlushMode(FlushMode flushMode);
    protected internal NhQueryableOptions Clone();
    protected internal void Apply(IQuery query);
}
public static class NHibernate.Linq.NhRelinqQueryParser : object {
    private static QueryParser QueryParser;
    private static NhRelinqQueryParser();
    [ObsoleteAttribute("Use overload with PreTransformationParameters parameter")]
public static Expression PreTransform(Expression expression);
    public static PreTransformationResult PreTransform(Expression expression, PreTransformationParameters parameters);
    public static QueryModel Parse(Expression expression);
    internal static Func`2<Expression, Expression> CreatePreTransformer(IExpressionTransformerRegistrar expressionTransformerRegistrar);
}
public class NHibernate.Linq.NoPreEvaluationAttribute : LinqExtensionMethodAttributeBase {
}
public enum NHibernate.Linq.QueryMode : Enum {
    public int value__;
    public static QueryMode Select;
    public static QueryMode Delete;
    public static QueryMode Update;
    public static QueryMode UpdateVersioned;
    public static QueryMode Insert;
}
internal static class NHibernate.Linq.QueryProviderFactory : object {
    public static INhQueryProvider CreateQueryProvider(ISessionImplementor session, object collection);
}
public class NHibernate.Linq.QuerySourceNamer : object {
    private Dictionary`2<IQuerySource, string> _map;
    private List`1<string> _names;
    private int _differentiator;
    public void Add(IQuerySource querySource);
    internal void Add(IQuerySource querySource, string name);
    public string GetName(IQuerySource querySource);
    private string CreateUniqueName(string proposedName);
}
[ObsoleteAttribute("Please use NHibernate.Util.ReflectHelper instead")]
public static class NHibernate.Linq.ReflectionHelper : object {
    public static MethodInfo GetMethodDefinition(Expression`1<Action`1<TSource>> method);
    public static MethodInfo GetMethod(Expression`1<Action`1<TSource>> method);
    public static MethodInfo GetMethodDefinition(Expression`1<Action> method);
    public static MethodInfo GetMethod(Expression`1<Action> method);
    public static MemberInfo GetProperty(Expression`1<Func`2<TSource, TResult>> property);
}
public class NHibernate.Linq.ResultOperators.ClientSideTransformOperator : ResultOperatorBase {
    public virtual IStreamedData ExecuteInMemory(IStreamedData input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
}
public class NHibernate.Linq.ResultOperators.NonAggregatingGroupBy : ClientSideTransformOperator {
    [CompilerGeneratedAttribute]
private GroupResultOperator <GroupBy>k__BackingField;
    public GroupResultOperator GroupBy { get; }
    public NonAggregatingGroupBy(GroupResultOperator groupBy);
    [CompilerGeneratedAttribute]
public GroupResultOperator get_GroupBy();
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
}
public class NHibernate.Linq.ResultTransformer : object {
    private Func`2<Object[], object> _itemTransformation;
    private Func`2<IEnumerable`1<object>, object> _listTransformation;
    public ResultTransformer(Func`2<Object[], object> itemTransformation, Func`2<IEnumerable`1<object>, object> listTransformation);
    public sealed virtual object TransformTuple(Object[] tuple, String[] aliases);
    public sealed virtual IList TransformList(IList collection);
    private static IEnumerable`1<object> GetToTransform(IList collection);
    public sealed virtual bool Equals(ResultTransformer other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NHibernate.Linq.ReWriters.AddJoinsReWriter : NhQueryModelVisitorBase {
    private ISessionFactoryImplementor _sessionFactory;
    private MemberExpressionJoinDetector _memberExpressionJoinDetector;
    private WhereJoinDetector _whereJoinDetector;
    private AddJoinsReWriter(ISessionFactoryImplementor sessionFactory, QueryModel queryModel);
    public static void ReWrite(QueryModel queryModel, VisitorParameters parameters);
    public virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    public virtual void VisitOrdering(Ordering ordering, QueryModel queryModel, OrderByClause orderByClause, int index);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
    public virtual void VisitWhereClause(WhereClause whereClause, QueryModel queryModel, int index);
    public virtual void VisitNhHavingClause(NhHavingClause havingClause, QueryModel queryModel, int index);
    public sealed virtual void VisitNhOuterJoinClause(NhOuterJoinClause nhOuterJoinClause, QueryModel queryModel, int index);
    public virtual void VisitJoinClause(JoinClause joinClause, QueryModel queryModel, int index);
    private void VisitJoinClause(JoinClause joinClause);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public bool IsEntity(Type type);
    [ObsoleteAttribute("This method has no usages and will be removed in a future version")]
public bool IsIdentifier(Type type, string propertyName);
    private sealed virtual override bool NHibernate.Linq.ReWriters.IIsEntityDecider.IsEntity(MemberExpression expression, Boolean& isIdentifier);
}
public class NHibernate.Linq.ReWriters.ArrayIndexExpressionFlattener : RelinqExpressionVisitor {
    public static void ReWrite(QueryModel model);
    protected virtual Expression VisitBinary(BinaryExpression expression);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
}
internal class NHibernate.Linq.ReWriters.ConditionalQueryReferenceExpander : NhQueryModelVisitorBase {
    private ConditionalQueryReferenceExpressionExpander _expander;
    public virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
    public virtual void VisitOrdering(Ordering ordering, QueryModel queryModel, OrderByClause orderByClause, int index);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
    public virtual void VisitWhereClause(WhereClause whereClause, QueryModel queryModel, int index);
    public virtual void VisitNhHavingClause(NhHavingClause havingClause, QueryModel queryModel, int index);
    public static void ReWrite(QueryModel queryModel);
}
internal interface NHibernate.Linq.ReWriters.IIsEntityDecider {
    public abstract virtual bool IsEntity(MemberExpression expression, Boolean& isIdentifier);
}
internal class NHibernate.Linq.ReWriters.MergeAggregatingResultsInExpressionRewriter : RelinqExpressionVisitor {
    private NameGenerator _nameGenerator;
    private MergeAggregatingResultsInExpressionRewriter(NameGenerator nameGenerator);
    public static Expression Rewrite(Expression expression, NameGenerator nameGenerator);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    protected virtual Expression VisitMethodCall(MethodCallExpression m);
    private Expression CreateAggregate(Expression fromClauseExpression, LambdaExpression body, Func`2<Expression, Expression> aggregateFactory, Func`1<ResultOperatorBase> resultOperatorFactory);
}
public class NHibernate.Linq.ReWriters.MergeAggregatingResultsRewriter : NhQueryModelVisitorBase {
    public static void ReWrite(QueryModel model);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
    public virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    public virtual void VisitWhereClause(WhereClause whereClause, QueryModel queryModel, int index);
    public virtual void VisitOrdering(Ordering ordering, QueryModel queryModel, OrderByClause orderByClause, int index);
    private static Expression TransformCountExpression(Expression expression);
}
public class NHibernate.Linq.ReWriters.MoveOrderByToEndRewriter : object {
    public static void ReWrite(QueryModel queryModel);
}
public class NHibernate.Linq.ReWriters.QueryReferenceExpressionFlattener : RelinqExpressionVisitor {
    private QueryModel _model;
    internal static Type[] FlattenableResultOperators;
    private QueryReferenceExpressionFlattener(QueryModel model);
    private static QueryReferenceExpressionFlattener();
    public static void ReWrite(QueryModel model);
    protected virtual Expression VisitSubQuery(SubQueryExpression subQuery);
    private static bool HasJustAllFlattenableOperator(IEnumerable`1<ResultOperatorBase> resultOperators);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
}
public class NHibernate.Linq.ReWriters.RemoveUnnecessaryBodyOperators : NhQueryModelVisitorBase {
    public static void ReWrite(QueryModel queryModel);
    internal static void RemoveUnnecessaryOrderByClauses(QueryModel queryModel);
    internal static bool IsOrderByNeeded(QueryModel queryModel);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
}
public class NHibernate.Linq.ReWriters.ResultOperatorRemover : NhQueryModelVisitorBase {
    private Func`2<ResultOperatorBase, bool> _predicate;
    private ResultOperatorRemover(Func`2<ResultOperatorBase, bool> predicate);
    public static void Remove(QueryModel queryModel, Func`2<ResultOperatorBase, bool> predicate);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
    public virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
}
public class NHibernate.Linq.ReWriters.ResultOperatorRewriter : NhQueryModelVisitorBase {
    private List`1<ResultOperatorBase> resultOperators;
    private IStreamedDataInfo evaluationType;
    public static ResultOperatorRewriterResult Rewrite(QueryModel queryModel);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
}
public class NHibernate.Linq.ReWriters.ResultOperatorRewriterResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ResultOperatorBase> <RewrittenOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private IStreamedDataInfo <EvaluationType>k__BackingField;
    public IEnumerable`1<ResultOperatorBase> RewrittenOperators { get; private set; }
    public IStreamedDataInfo EvaluationType { get; private set; }
    public ResultOperatorRewriterResult(IEnumerable`1<ResultOperatorBase> rewrittenOperators, IStreamedDataInfo evaluationType);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ResultOperatorBase> get_RewrittenOperators();
    [CompilerGeneratedAttribute]
private void set_RewrittenOperators(IEnumerable`1<ResultOperatorBase> value);
    [CompilerGeneratedAttribute]
public IStreamedDataInfo get_EvaluationType();
    [CompilerGeneratedAttribute]
private void set_EvaluationType(IStreamedDataInfo value);
}
internal class NHibernate.Linq.ReWriters.SubQueryConditionalExpander : NhQueryModelVisitorBase {
    private SubQueryConditionalExpressionExpander _expander;
    public virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
    public virtual void VisitOrdering(Ordering ordering, QueryModel queryModel, OrderByClause orderByClause, int index);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
    public virtual void VisitWhereClause(WhereClause whereClause, QueryModel queryModel, int index);
    public virtual void VisitNhHavingClause(NhHavingClause havingClause, QueryModel queryModel, int index);
    public static void ReWrite(QueryModel queryModel);
}
[ExtensionAttribute]
public static class NHibernate.Linq.SqlMethods : object {
    [ExtensionAttribute]
[NoPreEvaluationAttribute]
public static bool Like(string matchExpression, string sqlLikePattern);
    [ExtensionAttribute]
[NoPreEvaluationAttribute]
public static bool Like(string matchExpression, string sqlLikePattern, char escapeCharacter);
}
public class NHibernate.Linq.UpdateBuilder`1 : object {
    private IQueryable`1<TSource> _source;
    private Assignments`2<TSource, TSource> _assignments;
    internal UpdateBuilder`1(IQueryable`1<TSource> source);
    public Task`1<int> UpdateAsync(CancellationToken cancellationToken);
    public Task`1<int> UpdateVersionedAsync(CancellationToken cancellationToken);
    public UpdateBuilder`1<TSource> Set(Expression`1<Func`2<TSource, TProp>> property, Expression`1<Func`2<TSource, TProp>> expression);
    public UpdateBuilder`1<TSource> Set(Expression`1<Func`2<TSource, TProp>> property, TProp value);
    public int Update();
    public int UpdateVersioned();
}
[ObsoleteAttribute]
public static class NHibernate.Linq.Visitors.BooleanToCaseConvertor : object {
    [ObsoleteAttribute]
public static IEnumerable`1<HqlExpression> Convert(IEnumerable`1<HqlExpression> hqlTreeNodes);
    [ObsoleteAttribute]
public static HqlExpression ConvertBooleanToCase(HqlExpression node);
}
public class NHibernate.Linq.Visitors.EqualityHqlGenerator : object {
    private HqlTreeBuilder _hqlTreeBuilder;
    private VisitorParameters _parameters;
    public EqualityHqlGenerator(VisitorParameters parameters);
    public HqlBooleanExpression Visit(Expression innerKeySelector, Expression outerKeySelector);
    private HqlBooleanExpression VisitNew(NewExpression innerKeySelector, NewExpression outerKeySelector);
    private HqlEquality GenerateEqualityNode(NewExpression innerKeySelector, NewExpression outerKeySelector, int index);
    private HqlEquality GenerateEqualityNode(Expression leftExpr, Expression rightExpr, IHqlExpressionVisitor visitor);
}
public class NHibernate.Linq.Visitors.ExpressionKeyVisitor : RelinqExpressionVisitor {
    private IDictionary`2<ConstantExpression, NamedParameter> _constantToParameterMap;
    private ISessionFactoryImplementor _sessionFactory;
    private StringBuilder _string;
    private ExpressionKeyVisitor(IDictionary`2<ConstantExpression, NamedParameter> constantToParameterMap, ISessionFactoryImplementor sessionFactory);
    [ObsoleteAttribute("Use the overload with ISessionFactoryImplementor parameter")]
public static string Visit(Expression expression, IDictionary`2<ConstantExpression, NamedParameter> parameters);
    public static string Visit(Expression rootExpression, IDictionary`2<ConstantExpression, NamedParameter> parameters, ISessionFactoryImplementor sessionFactory);
    public virtual string ToString();
    protected virtual Expression VisitBinary(BinaryExpression expression);
    protected virtual Expression VisitConditional(ConditionalExpression expression);
    protected virtual Expression VisitConstant(ConstantExpression expression);
    private void VisitConstantValue(object value);
    private void VisitParameter(NamedParameter param);
    private T AppendCommas(T expression);
    protected virtual Expression VisitLambda(Expression`1<T> expression);
    protected virtual Expression VisitMember(MemberExpression expression);
    protected virtual Expression VisitInvocation(InvocationExpression expression);
    protected virtual Expression VisitMethodCall(MethodCallExpression expression);
    protected virtual Expression VisitNew(NewExpression expression);
    protected virtual Expression VisitParameter(ParameterExpression expression);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression expression);
    protected virtual Expression VisitUnary(UnaryExpression expression);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    protected virtual Expression VisitDynamic(DynamicExpression expression);
    private void VisitMethod(MethodInfo methodInfo);
    private void FormatBinder(CallSiteBinder binder);
}
public class NHibernate.Linq.Visitors.ExpressionParameterVisitor : RelinqExpressionVisitor {
    private Dictionary`2<ConstantExpression, NamedParameter> _parameters;
    private Dictionary`2<QueryVariable, NamedParameter> _variableParameters;
    private HashSet`1<ConstantExpression> _collectionParameters;
    private IDictionary`2<ConstantExpression, QueryVariable> _queryVariables;
    private ISessionFactoryImplementor _sessionFactory;
    private ILinqToHqlGeneratorsRegistry _functionRegistry;
    private static HashSet`1<MethodBase> PagingMethods;
    [ObsoleteAttribute("Please use overload with preTransformationResult parameter instead.")]
public ExpressionParameterVisitor(ISessionFactoryImplementor sessionFactory);
    public ExpressionParameterVisitor(PreTransformationResult preTransformationResult);
    private static ExpressionParameterVisitor();
    [ObsoleteAttribute("Please use overload with preTransformationResult parameter instead.")]
public static IDictionary`2<ConstantExpression, NamedParameter> Visit(Expression expression, ISessionFactoryImplementor sessionFactory);
    public static IDictionary`2<ConstantExpression, NamedParameter> Visit(PreTransformationResult preTransformationResult);
    protected virtual Expression VisitMethodCall(MethodCallExpression expression);
    protected virtual Expression VisitInvocation(InvocationExpression expression);
    protected virtual Expression VisitConstant(ConstantExpression expression);
    protected virtual Expression VisitUnary(UnaryExpression node);
    private void AddConstantExpressionParameter(ConstantExpression expression, object overrideValue);
    private NamedParameter CreateParameter(ConstantExpression expression, object value, IType type);
    private static bool IsNullObject(ConstantExpression expression);
}
public class NHibernate.Linq.Visitors.HqlGeneratorExpressionVisitor : object {
    private HqlTreeBuilder _hqlTreeBuilder;
    private VisitorParameters _parameters;
    private ILinqToHqlGeneratorsRegistry _functionRegistry;
    private NullableExpressionDetector _nullableExpressionDetector;
    private Dictionary`2<Expression, Type> _notCastableExpressions;
    public ISessionFactory SessionFactory { get; }
    public HqlGeneratorExpressionVisitor(VisitorParameters parameters);
    public static HqlTreeNode Visit(Expression expression, VisitorParameters parameters);
    public sealed virtual ISessionFactory get_SessionFactory();
    public sealed virtual HqlTreeNode Visit(Expression expression);
    protected HqlTreeNode VisitExpression(Expression expression);
    private HqlTreeNode VisitDynamicExpression(DynamicExpression expression);
    private HqlTreeNode VisitTypeBinaryExpression(TypeBinaryExpression expression);
    internal HqlBooleanExpression BuildOfType(Expression expression, Type type);
    protected HqlTreeNode VisitNhStar(NhStarExpression expression);
    private HqlTreeNode VisitNhNominated(NhNominatedExpression nhNominatedExpression);
    private HqlTreeNode VisitInvocationExpression(InvocationExpression expression);
    protected HqlTreeNode VisitNhAverage(NhAverageExpression expression);
    protected HqlTreeNode VisitNhCount(NhCountExpression expression);
    protected HqlTreeNode VisitNhMin(NhMinExpression expression);
    protected HqlTreeNode VisitNhMax(NhMaxExpression expression);
    protected HqlTreeNode VisitNhSum(NhSumExpression expression);
    protected HqlTreeNode VisitNhDistinct(NhDistinctExpression expression);
    protected HqlTreeNode VisitQuerySourceReferenceExpression(QuerySourceReferenceExpression expression);
    private HqlTreeNode VisitVBStringComparisonExpression(VBStringComparisonExpression expression);
    protected HqlTreeNode VisitBinaryExpression(BinaryExpression expression);
    private Type GetExpressionType(Expression expression);
    private HqlTreeNode TranslateInequalityComparison(BinaryExpression expression);
    private HqlTreeNode TranslateEqualityComparison(BinaryExpression expression);
    protected HqlTreeNode VisitUnaryExpression(UnaryExpression expression);
    protected HqlTreeNode VisitMemberExpression(MemberExpression expression);
    protected HqlTreeNode VisitConstantExpression(ConstantExpression expression);
    protected HqlTreeNode VisitMethodCallExpression(MethodCallExpression expression);
    protected HqlTreeNode VisitLambdaExpression(LambdaExpression expression);
    protected HqlTreeNode VisitParameterExpression(ParameterExpression expression);
    protected HqlTreeNode VisitConditionalExpression(ConditionalExpression expression);
    protected HqlTreeNode VisitSubQueryExpression(SubQueryExpression expression);
    protected HqlTreeNode VisitNewArrayExpression(NewArrayExpression expression);
    private bool IsCastRequired(Expression expression, Type toType, Boolean& needTransparentCast);
    private bool IsCastRequired(IType type, IType toType, Boolean& existType);
    private bool IsCastRequired(string sqlFunctionName, Expression argumentExpression, Type returnType);
    [CompilerGeneratedAttribute]
private HqlTreeNode <VisitNewArrayExpression>b__37_0(Expression exp);
}
public interface NHibernate.Linq.Visitors.IExpressionTransformerRegistrar {
    public abstract virtual void Register(ExpressionTransformerRegistry expressionTransformerRegistry);
}
public interface NHibernate.Linq.Visitors.IHqlExpressionVisitor {
    public ISessionFactory SessionFactory { get; }
    public abstract virtual ISessionFactory get_SessionFactory();
    public abstract virtual HqlTreeNode Visit(Expression expression);
}
public interface NHibernate.Linq.Visitors.IJoiner {
    public abstract virtual Expression AddJoin(Expression expression, string key);
    public abstract virtual bool CanAddJoin(Expression expression);
    public abstract virtual void MakeInnerIfJoined(string key);
}
public interface NHibernate.Linq.Visitors.IQueryModelRewriterFactory {
    public abstract virtual QueryModelVisitorBase CreateVisitor(VisitorParameters parameters);
}
public class NHibernate.Linq.Visitors.Joiner : object {
    private Dictionary`2<string, NhJoinClause> _joins;
    private NameGenerator _nameGenerator;
    private QueryModel _queryModel;
    public IEnumerable`1<NhJoinClause> Joins { get; }
    internal Joiner(QueryModel queryModel);
    public IEnumerable`1<NhJoinClause> get_Joins();
    public sealed virtual Expression AddJoin(Expression expression, string key);
    public sealed virtual void MakeInnerIfJoined(string key);
    public sealed virtual bool CanAddJoin(Expression expression);
    private void AddJoin(QueryModel queryModel, NhJoinClause joinClause);
}
public class NHibernate.Linq.Visitors.LeftJoinRewriter : NhQueryModelVisitorBase {
    public static void ReWrite(QueryModel queryModel);
    public virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    private static void InsertBodyClauses(IEnumerable`1<IBodyClause> bodyClauses, QueryModel destinationQueryModel, int destinationIndex);
    private static bool IsLeftJoin(QueryModel subQueryModel);
}
internal class NHibernate.Linq.Visitors.MemberExpressionJoinDetector : RelinqExpressionVisitor {
    private IIsEntityDecider _isEntityDecider;
    private IJoiner _joiner;
    private ISessionFactoryImplementor _sessionFactory;
    private bool _requiresJoinForNonIdentifier;
    private bool _preventJoinsInConditionalTest;
    private bool _hasIdentifier;
    private int _memberExpressionDepth;
    public MemberExpressionJoinDetector(IIsEntityDecider isEntityDecider, IJoiner joiner, ISessionFactoryImplementor sessionFactory);
    protected virtual Expression VisitMember(MemberExpression expression);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    protected virtual Expression VisitConditional(ConditionalExpression expression);
    protected virtual Expression VisitExtension(Expression expression);
    public void Transform(SelectClause selectClause);
    public void Transform(ResultOperatorBase resultOperator);
    public void Transform(Ordering ordering);
}
public class NHibernate.Linq.Visitors.NameGenerator : object {
    private QueryModel _model;
    public NameGenerator(QueryModel model);
    public string GetNewName();
}
internal class NHibernate.Linq.Visitors.NhEvaluatableExpressionFilter : EvaluatableExpressionFilterBase {
    private ISessionFactoryImplementor _sessionFactory;
    internal NhEvaluatableExpressionFilter(ISessionFactoryImplementor sessionFactory);
    public virtual bool IsEvaluatableConstant(ConstantExpression node);
    public virtual bool IsEvaluatableMember(MemberExpression node);
    public virtual bool IsEvaluatableMethodCall(MethodCallExpression node);
}
public class NHibernate.Linq.Visitors.NhExpressionVisitor : RelinqExpressionVisitor {
    protected internal virtual Expression VisitNhStar(NhStarExpression expression);
    protected internal virtual Expression VisitNhNew(NhNewExpression expression);
    protected internal virtual Expression VisitNhAggregated(NhAggregatedExpression node);
    protected internal virtual Expression VisitNhDistinct(NhDistinctExpression expression);
    protected internal virtual Expression VisitNhCount(NhCountExpression expression);
    protected internal virtual Expression VisitNhSum(NhSumExpression expression);
    protected internal virtual Expression VisitNhMax(NhMaxExpression expression);
    protected internal virtual Expression VisitNhMin(NhMinExpression expression);
    protected internal virtual Expression VisitNhAverage(NhAverageExpression expression);
    protected internal virtual Expression VisitNhNominated(NhNominatedExpression expression);
}
internal class NHibernate.Linq.Visitors.NhPartialEvaluatingExpressionVisitor : RelinqExpressionVisitor {
    private PartialEvaluationInfo _partialEvaluationInfo;
    private PreTransformationParameters _preTransformationParameters;
    private NhPartialEvaluatingExpressionVisitor(PartialEvaluationInfo partialEvaluationInfo, PreTransformationParameters preTransformationParameters);
    public static Expression EvaluateIndependentSubtrees(Expression expressionTree, PreTransformationParameters preTransformationParameters);
    public virtual Expression Visit(Expression expression);
    private Expression EvaluateSubtree(Expression subtree);
    private bool ContainsVariable(Expression expression);
    protected virtual Expression VisitConstant(ConstantExpression expression);
}
public class NHibernate.Linq.Visitors.NhQueryModelVisitorBase : QueryModelVisitorBase {
    public virtual void VisitNhHavingClause(NhHavingClause havingClause, QueryModel queryModel, int index);
    public virtual void VisitNhJoinClause(NhJoinClause joinClause, QueryModel queryModel, int index);
    public virtual void VisitNhWithClause(NhWithClause nhWhereClause, QueryModel queryModel, int index);
}
public class NHibernate.Linq.Visitors.NonAggregatingGroupJoinRewriter : object {
    private QueryModel _model;
    private IEnumerable`1<GroupJoinClause> _groupJoinClauses;
    private NonAggregatingGroupJoinRewriter(QueryModel model, IEnumerable`1<GroupJoinClause> groupJoinClauses);
    public static void ReWrite(QueryModel model);
    internal static void RewriteGroupJoins(IEnumerable`1<GroupJoinClause> groupJoins, QueryModel model);
    private void ReWrite();
    [IteratorStateMachineAttribute("NHibernate.Linq.Visitors.NonAggregatingGroupJoinRewriter/<GetNotUsedGroupJoins>d__6")]
private IEnumerable`1<GroupJoinClause> GetNotUsedGroupJoins(IsAggregatingResults aggregateDetectorResults);
    private static void ProcessFlattenedJoin(GroupJoinClause nonAggregatingJoin, QuerySourceUsageLocator locator, QueryModel model);
    private static void SwapClause(IBodyClause oldClause, IBodyClause newClause, QueryModel model);
    private static bool IsOuterJoin(QuerySourceUsageLocator locator);
    private static bool IsFlattenedJoin(QuerySourceUsageLocator locator);
    private static bool IsHierarchicalJoin(QuerySourceUsageLocator locator);
    private IsAggregatingResults GetGroupJoinInformation(IEnumerable`1<GroupJoinClause> clause);
}
internal class NHibernate.Linq.Visitors.NullableExpressionDetector : object {
    private static HashSet`1<Type> NotNullOperators;
    private Dictionary`2<BinaryExpression, List`1<MemberExpression>> _equalityNotNullMembers;
    private ISessionFactoryImplementor _sessionFactory;
    private ILinqToHqlGeneratorsRegistry _functionRegistry;
    public NullableExpressionDetector(ISessionFactoryImplementor sessionFactory, ILinqToHqlGeneratorsRegistry functionRegistry);
    private static NullableExpressionDetector();
    public void SearchForNotNullMemberChecks(BinaryExpression expression);
    public bool IsNullable(Expression expression, BinaryExpression equalityExpression);
    private bool IsNullable(MemberExpression memberExpression, BinaryExpression equalityExpression);
    private bool IsNullableExtension(Expression extensionExpression, BinaryExpression equalityExpression);
    private static bool TryGetMemberAccess(Expression expression, MemberExpression& memberExpression);
    private void FindAllNotNullMembers(Expression expression, List`1<MemberExpression> notNullMembers);
    private void FindAllNotNullMembers(BinaryExpression binaryExpression, List`1<MemberExpression> notNullMembers);
    private void FindNotNullMember(BinaryExpression binaryExpression, List`1<MemberExpression> notNullMembers);
    private static bool AreEqual(MemberExpression memberExpression, MemberExpression otherMemberExpression);
    private static bool IsAndOrAndAlso(Expression expression);
    private static bool IsEqualOrNotEqual(Expression expression);
}
internal class NHibernate.Linq.Visitors.PagingRewriterSelectClauseVisitor : RelinqExpressionVisitor {
    private FromClauseBase querySource;
    public PagingRewriterSelectClauseVisitor(FromClauseBase querySource);
    public Expression Swap(Expression expression);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    private Expression GetSubQuerySelectorOrNull(QuerySourceReferenceExpression expression);
}
public static class NHibernate.Linq.Visitors.ParameterTypeLocator : object {
    private static HashSet`1<ExpressionType> ValidBinaryExpressionTypes;
    private static HashSet`1<ExpressionType> NonVoidOperators;
    private static ParameterTypeLocator();
    public static void SetParameterTypes(IDictionary`2<ConstantExpression, NamedParameter> parameters, QueryModel queryModel, Type targetType, ISessionFactoryImplementor sessionFactory);
    internal static void SetParameterTypes(IDictionary`2<ConstantExpression, NamedParameter> parameters, QueryModel queryModel, Type targetType, ISessionFactoryImplementor sessionFactory, bool removeMappedAsCalls);
    private static IType GetCandidateType(ISessionFactoryImplementor sessionFactory, IEnumerable`1<ConstantExpression> constantExpressions, ConstantTypeLocatorVisitor visitor, Type constantType);
    private static IType GetParameterType(ISessionFactoryImplementor sessionFactory, HashSet`1<ConstantExpression> constantExpressions, ConstantTypeLocatorVisitor visitor, NamedParameter namedParameter, Boolean& tryProcessInHql);
    internal static Expression UnwrapUnary(Expression expression);
}
public class NHibernate.Linq.Visitors.PossibleValueSet : object {
    [CompilerGeneratedAttribute]
private Type <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsAllNonNullValues>k__BackingField;
    private List`1<object> _DistinctValues;
    private Type ExpressionType { get; private set; }
    private bool ContainsNull { get; private set; }
    private bool ContainsAllNonNullValues { get; private set; }
    private List`1<object> DistinctValues { get; }
    private bool ContainsAnyNonNullValues { get; }
    private PossibleValueSet(Type expressionType);
    [CompilerGeneratedAttribute]
private Type get_ExpressionType();
    [CompilerGeneratedAttribute]
private void set_ExpressionType(Type value);
    [CompilerGeneratedAttribute]
private bool get_ContainsNull();
    [CompilerGeneratedAttribute]
private void set_ContainsNull(bool value);
    [CompilerGeneratedAttribute]
private bool get_ContainsAllNonNullValues();
    [CompilerGeneratedAttribute]
private void set_ContainsAllNonNullValues(bool value);
    private List`1<object> get_DistinctValues();
    private bool get_ContainsAnyNonNullValues();
    public bool Contains(object obj);
    public PossibleValueSet Add(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet Divide(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet Modulo(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet Multiply(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet Power(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet Subtract(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet And(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet Or(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet ExclusiveOr(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet LeftShift(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet RightShift(PossibleValueSet pvs, Type resultType);
    private PossibleValueSet MathOperation(PossibleValueSet pvs, Type resultType);
    public PossibleValueSet AndAlso(PossibleValueSet pvs);
    public PossibleValueSet OrElse(PossibleValueSet pvs);
    public PossibleValueSet Equal(PossibleValueSet pvs);
    public PossibleValueSet NotEqual(PossibleValueSet pvs);
    public PossibleValueSet GreaterThanOrEqual(PossibleValueSet pvs);
    public PossibleValueSet GreaterThan(PossibleValueSet pvs);
    public PossibleValueSet LessThan(PossibleValueSet pvs);
    public PossibleValueSet LessThanOrEqual(PossibleValueSet pvs);
    private PossibleValueSet ComparisonOperation(PossibleValueSet pvs);
    public PossibleValueSet Coalesce(PossibleValueSet pvs);
    public PossibleValueSet Not();
    public PossibleValueSet BitwiseNot(Type resultType);
    public PossibleValueSet ArrayLength(Type resultType);
    public PossibleValueSet Convert(Type resultType);
    public PossibleValueSet Negate(Type resultType);
    public PossibleValueSet UnaryPlus(Type resultType);
    private PossibleValueSet UnaryMathOperation(Type resultType);
    public PossibleValueSet IsNull();
    public PossibleValueSet IsNotNull();
    public PossibleValueSet MemberAccess(Type resultType);
    private Type DetermineBoolType(PossibleValueSet otherSet);
    private void DetermineBoolType();
    public static PossibleValueSet CreateNull(Type expressionType);
    public static PossibleValueSet CreateAllNonNullValues(Type expressionType);
    public static PossibleValueSet CreateAllValues(Type expressionType);
    public static PossibleValueSet Create(Type expressionType, Object[] values);
}
public class NHibernate.Linq.Visitors.PreTransformationParameters : object {
    private static Func`2<Expression, Expression> DefaultPreTransformer;
    [CompilerGeneratedAttribute]
private QueryMode <QueryMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ISessionFactoryImplementor <SessionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Expression, Expression> <PreTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MinimizeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEvaluatableExpressionFilter <EvaluatableExpressionFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<ConstantExpression, QueryVariable> <QueryVariables>k__BackingField;
    public QueryMode QueryMode { get; }
    public ISessionFactoryImplementor SessionFactory { get; }
    internal Func`2<Expression, Expression> PreTransformer { get; }
    public bool MinimizeParameters { get; public set; }
    internal IEvaluatableExpressionFilter EvaluatableExpressionFilter { get; internal set; }
    internal IDictionary`2<ConstantExpression, QueryVariable> QueryVariables { get; internal set; }
    public PreTransformationParameters(QueryMode queryMode, ISessionFactoryImplementor sessionFactory);
    private static PreTransformationParameters();
    [CompilerGeneratedAttribute]
public QueryMode get_QueryMode();
    [CompilerGeneratedAttribute]
public ISessionFactoryImplementor get_SessionFactory();
    [CompilerGeneratedAttribute]
internal Func`2<Expression, Expression> get_PreTransformer();
    [CompilerGeneratedAttribute]
public bool get_MinimizeParameters();
    [CompilerGeneratedAttribute]
public void set_MinimizeParameters(bool value);
    [CompilerGeneratedAttribute]
internal IEvaluatableExpressionFilter get_EvaluatableExpressionFilter();
    [CompilerGeneratedAttribute]
internal void set_EvaluatableExpressionFilter(IEvaluatableExpressionFilter value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<ConstantExpression, QueryVariable> get_QueryVariables();
    [CompilerGeneratedAttribute]
internal void set_QueryVariables(IDictionary`2<ConstantExpression, QueryVariable> value);
}
public class NHibernate.Linq.Visitors.PreTransformationResult : object {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ISessionFactoryImplementor <SessionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<ConstantExpression, QueryVariable> <QueryVariables>k__BackingField;
    public Expression Expression { get; }
    public ISessionFactoryImplementor SessionFactory { get; }
    internal IDictionary`2<ConstantExpression, QueryVariable> QueryVariables { get; }
    internal PreTransformationResult(Expression expression, ISessionFactoryImplementor sessionFactory, IDictionary`2<ConstantExpression, QueryVariable> queryVariables);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public ISessionFactoryImplementor get_SessionFactory();
    [CompilerGeneratedAttribute]
internal IDictionary`2<ConstantExpression, QueryVariable> get_QueryVariables();
}
public class NHibernate.Linq.Visitors.QueryExpressionSourceIdentifer : RelinqExpressionVisitor {
    private QuerySourceIdentifier _identifier;
    public QueryExpressionSourceIdentifer(QuerySourceIdentifier identifier);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
}
public class NHibernate.Linq.Visitors.QueryModelVisitor : NhQueryModelVisitorBase {
    private QueryMode _queryMode;
    private IntermediateHqlTree _hqlTree;
    private Nullable`1<NhLinqExpressionReturnType> _rootReturnType;
    private static ResultOperatorMap ResultOperatorMap;
    private bool _serverSide;
    private bool _root;
    [CompilerGeneratedAttribute]
private VisitorParameters <VisitorParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IStreamedDataInfo <CurrentEvaluationType>k__BackingField;
    [CompilerGeneratedAttribute]
private IStreamedDataInfo <PreviousEvaluationType>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultOperatorRewriterResult <RewrittenOperatorResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<NhJoinClause, FetchOneRequest> <RelatedJoinFetchRequests>k__BackingField;
    public VisitorParameters VisitorParameters { get; }
    public IStreamedDataInfo CurrentEvaluationType { get; private set; }
    public IStreamedDataInfo PreviousEvaluationType { get; private set; }
    public QueryModel Model { get; }
    public ResultOperatorRewriterResult RewrittenOperatorResult { get; private set; }
    internal Dictionary`2<NhJoinClause, FetchOneRequest> RelatedJoinFetchRequests { get; }
    private static QueryModelVisitor();
    private QueryModelVisitor(VisitorParameters visitorParameters, bool root, QueryModel queryModel, Nullable`1<NhLinqExpressionReturnType> rootReturnType);
    public static ExpressionToHqlTranslationResults GenerateHqlQuery(QueryModel queryModel, VisitorParameters parameters, bool root, Nullable`1<NhLinqExpressionReturnType> rootReturnType);
    [CompilerGeneratedAttribute]
public VisitorParameters get_VisitorParameters();
    [CompilerGeneratedAttribute]
public IStreamedDataInfo get_CurrentEvaluationType();
    [CompilerGeneratedAttribute]
private void set_CurrentEvaluationType(IStreamedDataInfo value);
    [CompilerGeneratedAttribute]
public IStreamedDataInfo get_PreviousEvaluationType();
    [CompilerGeneratedAttribute]
private void set_PreviousEvaluationType(IStreamedDataInfo value);
    [CompilerGeneratedAttribute]
public QueryModel get_Model();
    [CompilerGeneratedAttribute]
public ResultOperatorRewriterResult get_RewrittenOperatorResult();
    [CompilerGeneratedAttribute]
private void set_RewrittenOperatorResult(ResultOperatorRewriterResult value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<NhJoinClause, FetchOneRequest> get_RelatedJoinFetchRequests();
    private void Visit();
    private void AddAdditionalPostExecuteTransformer();
    private void AddPostExecuteTransformerForCount();
    private void AddPostExecuteTransformerForResultAggregate(MethodInfo aggregateMethodTemplate);
    private void AddPostExecuteTransformerForSum();
    private MethodCallExpression GetAggregateMethodCall(MethodInfo aggregateMethodTemplate, Type inputListType, Type elementType, Expression inputList);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
    public virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    public virtual void VisitNhJoinClause(NhJoinClause joinClause, QueryModel queryModel, int index);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
    private FetchOneRequest GetRelatedFetchRequest(QueryModel queryModel, NhJoinClause joinClause);
    private static bool IsFetchSupported(QueryModel queryModel);
    private static IStreamedDataInfo GetOutputDataInfo(ResultOperatorBase resultOperator, IStreamedDataInfo evaluationType);
    public virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    private HqlSelect GetSelectClause(Expression selectClause);
    private void VisitInsertClause(Expression expression);
    private void VisitUpdateClause(Expression expression);
    private void VisitDeleteClause(Expression expression);
    public virtual void VisitWhereClause(WhereClause whereClause, QueryModel queryModel, int index);
    public virtual void VisitOrderByClause(OrderByClause orderByClause, QueryModel queryModel, int index);
    public virtual void VisitJoinClause(JoinClause joinClause, QueryModel queryModel, int index);
    public sealed virtual void VisitNhOuterJoinClause(NhOuterJoinClause outerJoinClause, QueryModel queryModel, int index);
    private void AddJoin(JoinClause joinClause, QueryModel queryModel, bool innerJoin);
    public virtual void VisitGroupJoinClause(GroupJoinClause groupJoinClause, QueryModel queryModel, int index);
    public virtual void VisitNhHavingClause(NhHavingClause havingClause, QueryModel queryModel, int index);
    public virtual void VisitNhWithClause(NhWithClause withClause, QueryModel queryModel, int index);
    private HqlTreeNode CreateCrossJoin(HqlTreeNode joinExpression, HqlAlias alias);
}
public class NHibernate.Linq.Visitors.QuerySourceIdentifier : NhQueryModelVisitorBase {
    private QuerySourceNamer _namer;
    public QuerySourceNamer Namer { get; }
    private QuerySourceIdentifier(QuerySourceNamer namer);
    public static void Visit(QuerySourceNamer namer, QueryModel queryModel);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
    public virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    public virtual void VisitJoinClause(JoinClause joinClause, QueryModel queryModel, GroupJoinClause groupJoinClause);
    public virtual void VisitGroupJoinClause(GroupJoinClause groupJoinClause, QueryModel queryModel, int index);
    public virtual void VisitJoinClause(JoinClause joinClause, QueryModel queryModel, int index);
    public virtual void VisitNhJoinClause(NhJoinClause joinClause, QueryModel queryModel, int index);
    public sealed virtual void VisitNhOuterJoinClause(NhOuterJoinClause outerJoinClause, QueryModel queryModel, int index);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
    public virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    public QuerySourceNamer get_Namer();
}
public class NHibernate.Linq.Visitors.QuerySourceLocator : NhQueryModelVisitorBase {
    private Type _type;
    private IQuerySource _querySource;
    private QuerySourceLocator(Type type);
    public static IQuerySource FindQuerySource(QueryModel queryModel, Type type);
    public virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    public virtual void VisitNhJoinClause(NhJoinClause joinClause, QueryModel queryModel, int index);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
}
internal class NHibernate.Linq.Visitors.QuerySourceUsageLocator : RelinqExpressionVisitor {
    private IQuerySource _querySource;
    private bool _references;
    [CompilerGeneratedAttribute]
private bool <LeftJoin>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IQuerySource> <Usages>k__BackingField;
    internal bool LeftJoin { get; private set; }
    public IList`1<IQuerySource> Usages { get; }
    public QuerySourceUsageLocator(IQuerySource querySource);
    [CompilerGeneratedAttribute]
internal bool get_LeftJoin();
    [CompilerGeneratedAttribute]
private void set_LeftJoin(bool value);
    [CompilerGeneratedAttribute]
public IList`1<IQuerySource> get_Usages();
    public void Search(IBodyClause clause);
    private Expression ExpressionSearcher(Expression arg);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    private static bool IsLeftJoin(QueryModel subQueryModel);
}
internal class NHibernate.Linq.Visitors.QueryVariable : ValueType {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ClosureContext>k__BackingField;
    public string Path { get; }
    public object ClosureContext { get; }
    public QueryVariable(string path, object closureContext);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_ClosureContext();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(QueryVariable other);
}
public interface NHibernate.Linq.Visitors.ResultOperatorProcessors.IResultOperatorProcessor`1 {
    public abstract virtual void Process(T resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessAggregate : object {
    public sealed virtual void Process(AggregateResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessAggregateFromSeed : object {
    public sealed virtual void Process(AggregateFromSeedResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessAll : object {
    public sealed virtual void Process(AllResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessAny : object {
    public sealed virtual void Process(AnyResultOperator anyOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
    internal static void Process(IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessAsQueryable : object {
    public sealed virtual void Process(AsQueryableResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessCast : object {
    public sealed virtual void Process(CastResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessClientSideSelect : object {
    public sealed virtual void Process(ClientSideSelect resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessClientSideSelect2 : object {
    public sealed virtual void Process(ClientSideSelect2 resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessContains : object {
    public sealed virtual void Process(ContainsResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
    private static HqlRange GetFromRangeClause(HqlTreeNode node);
    private static HqlExpression GetSelectExpression(HqlTreeNode node);
    private static bool IsEmptyList(HqlParameter source, VisitorParameters parameters);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessFetch : object {
    public void Process(FetchRequestBase resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
    public void Process(FetchRequestBase resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree, string sourceAlias);
    private void Process(FetchRequestBase resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree, HqlTreeNode currentNode, string sourceAlias);
    private void Process(FetchRequestBase resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree, HqlDot memberPath, HqlTreeNode currentNode, IType propType);
}
internal class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessFetchLazyProperties : object {
    public sealed virtual void Process(FetchLazyPropertiesResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessFetchMany : ProcessFetch {
    public sealed virtual void Process(FetchManyRequest resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessFetchOne : ProcessFetch {
    public sealed virtual void Process(FetchOneRequest resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessFirst : ProcessFirstOrSingleBase {
    private static MethodInfo FirstOrDefault;
    private static MethodInfo First;
    private static ProcessFirst();
    public sealed virtual void Process(FirstResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessFirstOrSingleBase : object {
    protected static void AddClientSideEval(MethodInfo target, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessGroupBy : object {
    public sealed virtual void Process(GroupResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
internal class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessLock : object {
    public sealed virtual void Process(LockResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessNonAggregatingGroupBy : object {
    public sealed virtual void Process(NonAggregatingGroupBy resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessOfType : object {
    public sealed virtual void Process(OfTypeResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessResultOperatorReturn : object {
    [CompilerGeneratedAttribute]
private HqlTreeNode <TreeNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>> <AdditionalCriteria>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <ListTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <PostExecuteTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private HqlBooleanExpression <WhereClause>k__BackingField;
    [CompilerGeneratedAttribute]
private HqlGroupBy <GroupBy>k__BackingField;
    [CompilerGeneratedAttribute]
private HqlTreeNode <AdditionalFrom>k__BackingField;
    public HqlTreeNode TreeNode { get; public set; }
    public Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>> AdditionalCriteria { get; public set; }
    public LambdaExpression ListTransformer { get; public set; }
    public LambdaExpression PostExecuteTransformer { get; public set; }
    public HqlBooleanExpression WhereClause { get; public set; }
    public HqlGroupBy GroupBy { get; public set; }
    public HqlTreeNode AdditionalFrom { get; public set; }
    [CompilerGeneratedAttribute]
public HqlTreeNode get_TreeNode();
    [CompilerGeneratedAttribute]
public void set_TreeNode(HqlTreeNode value);
    [CompilerGeneratedAttribute]
public Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>> get_AdditionalCriteria();
    [CompilerGeneratedAttribute]
public void set_AdditionalCriteria(Action`2<IQuery, IDictionary`2<string, Tuple`2<object, IType>>> value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_ListTransformer();
    [CompilerGeneratedAttribute]
public void set_ListTransformer(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_PostExecuteTransformer();
    [CompilerGeneratedAttribute]
public void set_PostExecuteTransformer(LambdaExpression value);
    [CompilerGeneratedAttribute]
public HqlBooleanExpression get_WhereClause();
    [CompilerGeneratedAttribute]
public void set_WhereClause(HqlBooleanExpression value);
    [CompilerGeneratedAttribute]
public HqlGroupBy get_GroupBy();
    [CompilerGeneratedAttribute]
public void set_GroupBy(HqlGroupBy value);
    [CompilerGeneratedAttribute]
public HqlTreeNode get_AdditionalFrom();
    [CompilerGeneratedAttribute]
public void set_AdditionalFrom(HqlTreeNode value);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessSingle : ProcessFirstOrSingleBase {
    private static MethodInfo SingleOrDefault;
    private static MethodInfo Single;
    private static ProcessSingle();
    public sealed virtual void Process(SingleResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessSkip : object {
    public sealed virtual void Process(SkipResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ProcessTake : object {
    public sealed virtual void Process(TakeResultOperator resultOperator, QueryModelVisitor queryModelVisitor, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ResultOperatorMap : object {
    private Dictionary`2<Type, ResultOperatorProcessorBase> _map;
    public void Add();
    public void Process(ResultOperatorBase resultOperator, QueryModelVisitor queryModel, IntermediateHqlTree tree);
}
public class NHibernate.Linq.Visitors.ResultOperatorProcessors.ResultOperatorProcessor`1 : ResultOperatorProcessorBase {
    private IResultOperatorProcessor`1<T> _processor;
    public ResultOperatorProcessor`1(IResultOperatorProcessor`1<T> processor);
    public virtual void Process(ResultOperatorBase resultOperator, QueryModelVisitor queryModel, IntermediateHqlTree tree);
}
public abstract class NHibernate.Linq.Visitors.ResultOperatorProcessors.ResultOperatorProcessorBase : object {
    public abstract virtual void Process(ResultOperatorBase resultOperator, QueryModelVisitor queryModel, IntermediateHqlTree tree);
}
internal class NHibernate.Linq.Visitors.SelectClauseHqlNominator : RelinqExpressionVisitor {
    private ILinqToHqlGeneratorsRegistry _functionRegistry;
    private ISessionFactoryImplementor _sessionFactory;
    private VisitorParameters _parameters;
    [CompilerGeneratedAttribute]
private HashSet`1<Expression> <HqlCandidates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsUntranslatedMethodCalls>k__BackingField;
    private bool _canBeCandidate;
    private Stack`1<bool> _stateStack;
    public HashSet`1<Expression> HqlCandidates { get; private set; }
    public bool ContainsUntranslatedMethodCalls { get; private set; }
    public SelectClauseHqlNominator(VisitorParameters parameters);
    [CompilerGeneratedAttribute]
public HashSet`1<Expression> get_HqlCandidates();
    [CompilerGeneratedAttribute]
private void set_HqlCandidates(HashSet`1<Expression> value);
    [CompilerGeneratedAttribute]
public bool get_ContainsUntranslatedMethodCalls();
    [CompilerGeneratedAttribute]
private void set_ContainsUntranslatedMethodCalls(bool value);
    internal Expression Nominate(Expression expression, bool isSubQuery);
    public virtual Expression Visit(Expression expression);
    private bool IsRegisteredFunction(Expression expression);
    private bool CanBeEvaluatedInHqlSelectStatement(Expression expression, bool projectConstantsInHql);
    private static bool CanBeEvaluatedInHqlStatementShortcut(Expression expression);
}
public class NHibernate.Linq.Visitors.SelectClauseVisitor : RelinqExpressionVisitor {
    private HqlTreeBuilder _hqlTreeBuilder;
    private HashSet`1<Expression> _hqlNodes;
    private ParameterExpression _inputParameter;
    private VisitorParameters _parameters;
    private int _iColumn;
    private List`1<HqlExpression> _hqlTreeNodes;
    private HqlGeneratorExpressionVisitor _hqlVisitor;
    [CompilerGeneratedAttribute]
private LambdaExpression <ProjectionExpression>k__BackingField;
    private static MethodInfo ConvertChangeType;
    public LambdaExpression ProjectionExpression { get; private set; }
    public SelectClauseVisitor(Type inputType, VisitorParameters parameters);
    private static SelectClauseVisitor();
    [CompilerGeneratedAttribute]
public LambdaExpression get_ProjectionExpression();
    [CompilerGeneratedAttribute]
private void set_ProjectionExpression(LambdaExpression value);
    public IEnumerable`1<HqlExpression> GetHqlNodes();
    public void VisitSelector(Expression expression);
    public void VisitSelector(Expression expression, bool isSubQuery);
    public virtual Expression Visit(Expression expression);
    private static Expression Convert(Expression expression, Type type);
}
internal class NHibernate.Linq.Visitors.SimplifyConditionalVisitor : RelinqExpressionVisitor {
    protected virtual Expression VisitConditional(ConditionalExpression expression);
    protected virtual Expression VisitBinary(BinaryExpression expression);
    private static bool IsConstruction(Expression expression);
    private static bool IsConstructionToNullComparison(Expression expression);
}
public class NHibernate.Linq.Visitors.SubQueryFromClauseFlattener : NhQueryModelVisitorBase {
    private static Type[] FlattenableResultOperators;
    private static SubQueryFromClauseFlattener();
    public static void ReWrite(QueryModel queryModel);
    public virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
    private static bool CheckFlattenable(QueryModel subQueryModel);
    private static bool HasJustAllFlattenableOperator(IEnumerable`1<ResultOperatorBase> resultOperators);
    private static void CopyFromClauseData(FromClauseBase source, FromClauseBase destination);
    private static void FlattenSubQuery(SubQueryExpression subQueryExpression, FromClauseBase fromClause, QueryModel queryModel, int destinationIndex);
    internal static void InsertResultOperators(IEnumerable`1<ResultOperatorBase> resultOperators, QueryModel queryModel);
    private static void InsertBodyClauses(IEnumerable`1<IBodyClause> bodyClauses, QueryModel queryModel, int destinationIndex);
}
public class NHibernate.Linq.Visitors.SwapQuerySourceVisitor : RelinqExpressionVisitor {
    private IQuerySource _oldClause;
    private IQuerySource _newClause;
    public SwapQuerySourceVisitor(IQuerySource oldClause, IQuerySource newClause);
    public Expression Swap(Expression expression);
    protected virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
}
internal class NHibernate.Linq.Visitors.TransparentIdentifierRemovingExpressionVisitor : RelinqExpressionVisitor {
    public static Expression ReplaceTransparentIdentifiers(Expression expression);
    protected virtual Expression VisitMember(MemberExpression memberExpression);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    private IEnumerable`1<MemberBinding> GetMemberBindingsCreatedByExpression(Expression expression);
    [IteratorStateMachineAttribute("NHibernate.Linq.Visitors.TransparentIdentifierRemovingExpressionVisitor/<GetMemberBindingsForNewExpression>d__5")]
private IEnumerable`1<MemberBinding> GetMemberBindingsForNewExpression(NewExpression newExpression);
    private static bool AreEqual(MemberInfo memberInfo, MemberInfo toComapre);
}
public class NHibernate.Linq.Visitors.VisitorParameters : object {
    [CompilerGeneratedAttribute]
private ISessionFactoryImplementor <SessionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<ConstantExpression, NamedParameter> <ConstantToParameterMap>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NamedParameterDescriptor> <RequiredHqlParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private QuerySourceNamer <QuerySourceNamer>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TargetEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryMode <RootQueryMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanCachePlan>k__BackingField;
    public ISessionFactoryImplementor SessionFactory { get; private set; }
    public IDictionary`2<ConstantExpression, NamedParameter> ConstantToParameterMap { get; private set; }
    public List`1<NamedParameterDescriptor> RequiredHqlParameters { get; private set; }
    public QuerySourceNamer QuerySourceNamer { get; public set; }
    public Type TargetEntityType { get; }
    public QueryMode RootQueryMode { get; }
    internal bool CanCachePlan { get; internal set; }
    public VisitorParameters(ISessionFactoryImplementor sessionFactory, IDictionary`2<ConstantExpression, NamedParameter> constantToParameterMap, List`1<NamedParameterDescriptor> requiredHqlParameters, QuerySourceNamer querySourceNamer, Type targetEntityType, QueryMode rootQueryMode);
    [CompilerGeneratedAttribute]
public ISessionFactoryImplementor get_SessionFactory();
    [CompilerGeneratedAttribute]
private void set_SessionFactory(ISessionFactoryImplementor value);
    [CompilerGeneratedAttribute]
public IDictionary`2<ConstantExpression, NamedParameter> get_ConstantToParameterMap();
    [CompilerGeneratedAttribute]
private void set_ConstantToParameterMap(IDictionary`2<ConstantExpression, NamedParameter> value);
    [CompilerGeneratedAttribute]
public List`1<NamedParameterDescriptor> get_RequiredHqlParameters();
    [CompilerGeneratedAttribute]
private void set_RequiredHqlParameters(List`1<NamedParameterDescriptor> value);
    [CompilerGeneratedAttribute]
public QuerySourceNamer get_QuerySourceNamer();
    [CompilerGeneratedAttribute]
public void set_QuerySourceNamer(QuerySourceNamer value);
    [CompilerGeneratedAttribute]
public Type get_TargetEntityType();
    [CompilerGeneratedAttribute]
public QueryMode get_RootQueryMode();
    [CompilerGeneratedAttribute]
internal bool get_CanCachePlan();
    [CompilerGeneratedAttribute]
internal void set_CanCachePlan(bool value);
}
[ExtensionAttribute]
public static class NHibernate.Linq.Visitors.VisitorUtil : object {
    public static bool IsDynamicComponentDictionaryGetter(MethodInfo method, Expression targetObject, IEnumerable`1<Expression> arguments, ISessionFactory sessionFactory, String& memberName);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public static bool IsDynamicComponentDictionaryGetter(MethodCallExpression expression, ISessionFactory sessionFactory, String& memberName);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
public static bool IsDynamicComponentDictionaryGetter(MethodCallExpression expression, ISessionFactory sessionFactory);
    public static bool IsNullConstant(Expression expression);
    public static bool IsBooleanConstant(Expression expression, Boolean& value);
    [ExtensionAttribute]
public static Expression Replace(Expression expression, Expression oldExpression, Expression newExpression);
    [ExtensionAttribute]
public static string GetMemberPath(MemberExpression memberExpression);
    internal static bool TryGetPotentialDynamicComponentDictionaryMember(MethodCallExpression expression, String& memberName);
    internal static bool TryGetPotentialDynamicComponentDictionaryMember(MethodInfo method, Expression targetObject, IEnumerable`1<Expression> arguments, String& memberName);
    internal static bool IsMappedAs(MethodInfo methodInfo);
}
internal class NHibernate.Linq.Visitors.WhereJoinDetector : RelinqExpressionVisitor {
    private IIsEntityDecider _isEntityDecider;
    private IJoiner _joiner;
    private ISessionFactoryImplementor _sessionFactory;
    private Stack`1<bool> _handled;
    private Stack`1<ExpressionValues> _values;
    private int _memberExpressionDepth;
    internal WhereJoinDetector(IIsEntityDecider isEntityDecider, IJoiner joiner, ISessionFactoryImplementor sessionFactory);
    public Expression Transform(Expression expression);
    public void Transform(IClause whereClause);
    private void PostTransform();
    public virtual Expression Visit(Expression expression);
    protected virtual Expression VisitBinary(BinaryExpression expression);
    protected virtual Expression VisitUnary(UnaryExpression expression);
    protected virtual Expression VisitSubQuery(SubQueryExpression expression);
    protected virtual Expression VisitMember(MemberExpression expression);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private void SetResultValues(ExpressionValues values);
    private void HandleBinaryOperation(Func`3<PossibleValueSet, PossibleValueSet, PossibleValueSet> operation);
    private void HandleUnaryOperation(Func`2<PossibleValueSet, PossibleValueSet> operation);
}
public abstract class NHibernate.Loader.AbstractEntityJoinWalker : JoinWalker {
    private IOuterJoinLoadable persister;
    private string alias;
    protected SqlString WhereFragment { get; }
    public string Comment { get; }
    protected IOuterJoinLoadable Persister { get; }
    protected string Alias { get; }
    public AbstractEntityJoinWalker(IOuterJoinLoadable persister, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public AbstractEntityJoinWalker(string rootSqlAlias, IOuterJoinLoadable persister, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected virtual void InitAll(SqlString whereString, SqlString orderByString, LockMode lockMode);
    protected virtual OuterJoinableAssociation CreateRootAssociation();
    [ObsoleteAttribute("Please use InitProjection(SqlString projectionString, SqlString whereString, SqlString orderByString, SqlString groupByString, SqlString havingString, IDictionary<string, IFilter> enabledFilters, LockMode lockMode, IList<EntityProjection> entityProjections) instead")]
protected void InitProjection(SqlString projectionString, SqlString whereString, SqlString orderByString, SqlString groupByString, SqlString havingString, IDictionary`2<string, IFilter> enabledFilters, LockMode lockMode);
    protected void InitProjection(SqlString projectionString, SqlString whereString, SqlString orderByString, SqlString groupByString, SqlString havingString, IDictionary`2<string, IFilter> enabledFilters, LockMode lockMode, IList`1<EntityProjection> entityProjections);
    protected virtual void AddAssociations();
    private OuterJoinableAssociation CreateAssociation(EntityType entityType, string tableAlias);
    private void InitStatementString(OuterJoinableAssociation rootAssociation, SqlString projection, SqlString condition, SqlString orderBy, SqlString groupBy, SqlString having, LockMode lockMode);
    protected virtual bool IsJoinedFetchEnabled(IAssociationType type, FetchMode config, CascadeStyle cascadeStyle);
    protected virtual SqlString get_WhereFragment();
    public abstract virtual string get_Comment();
    protected IOuterJoinLoadable get_Persister();
    protected string get_Alias();
    public virtual string ToString();
}
public abstract class NHibernate.Loader.BasicLoader : Loader {
    protected static String[] NoSuffix;
    private IEntityAliases[] descriptors;
    private ICollectionAliases[] collectionDescriptors;
    protected IEntityAliases[] EntityAliases { get; }
    protected ICollectionAliases[] CollectionAliases { get; }
    protected String[] Suffixes { get; }
    protected String[] CollectionSuffixes { get; }
    public BasicLoader(ISessionFactoryImplementor factory);
    private static BasicLoader();
    protected sealed virtual IEntityAliases[] get_EntityAliases();
    protected sealed virtual ICollectionAliases[] get_CollectionAliases();
    protected abstract virtual String[] get_Suffixes();
    protected abstract virtual String[] get_CollectionSuffixes();
    protected virtual void PostInstantiate();
    protected virtual IDictionary`2<string, String[]> GetCollectionUserProvidedAlias(int index);
    private static bool IsBag(ICollectionPersister collectionPersister);
    public static String[] GenerateSuffixes(int length);
    public static String[] GenerateSuffixes(int seed, int length);
    public static string GenerateSuffix(int index);
}
public enum NHibernate.Loader.BatchFetchStyle : Enum {
    public int value__;
    public static BatchFetchStyle Legacy;
    public static BatchFetchStyle Dynamic;
}
public abstract class NHibernate.Loader.Collection.AbstractBatchingCollectionInitializer : object {
    [CompilerGeneratedAttribute]
private IQueryableCollection <CollectionPersister>k__BackingField;
    protected IQueryableCollection CollectionPersister { get; }
    protected AbstractBatchingCollectionInitializer(IQueryableCollection collectionPersister);
    public abstract virtual Task InitializeAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
protected IQueryableCollection get_CollectionPersister();
    public abstract virtual void Initialize(object id, ISessionImplementor session);
}
public class NHibernate.Loader.Collection.BasicCollectionJoinWalker : CollectionJoinWalker {
    private IQueryableCollection collectionPersister;
    public BasicCollectionJoinWalker(IQueryableCollection collectionPersister, int batchSize, SqlString subquery, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    private void InitStatementString(string alias, int batchSize, SqlString subquery);
    public virtual string ToString();
}
public class NHibernate.Loader.Collection.BasicCollectionLoader : CollectionLoader {
    private static INHibernateLogger log;
    public BasicCollectionLoader(IQueryableCollection collectionPersister, ISessionFactoryImplementor session, IDictionary`2<string, IFilter> enabledFilters);
    public BasicCollectionLoader(IQueryableCollection collectionPersister, int batchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected BasicCollectionLoader(IQueryableCollection collectionPersister, int batchSize, SqlString subquery, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    private static BasicCollectionLoader();
    protected virtual void InitializeFromWalker(IQueryableCollection collectionPersister, SqlString subquery, int batchSize, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory);
}
public class NHibernate.Loader.Collection.BatchingCollectionInitializer : AbstractBatchingCollectionInitializer {
    private Loader[] loaders;
    private Int32[] batchSizes;
    [ObsoleteAttribute("Please use ctor with IQueryableCollection collectionPersister")]
public BatchingCollectionInitializer(ICollectionPersister collectionPersister, Int32[] batchSizes, Loader[] loaders);
    public BatchingCollectionInitializer(IQueryableCollection collectionPersister, Int32[] batchSizes, Loader[] loaders);
    [AsyncStateMachineAttribute("NHibernate.Loader.Collection.BatchingCollectionInitializer/<InitializeAsync>d__0")]
public virtual Task InitializeAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual void Initialize(object id, ISessionImplementor session);
    [ObsoleteAttribute("Please use overload with IQueryableCollection persister")]
public static ICollectionInitializer CreateBatchingOneToManyInitializer(OneToManyPersister persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public static ICollectionInitializer CreateBatchingOneToManyInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public static ICollectionInitializer CreateBatchingCollectionInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
public abstract class NHibernate.Loader.Collection.BatchingCollectionInitializerBuilder : object {
    public virtual ICollectionInitializer CreateBatchingCollectionInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected abstract virtual ICollectionInitializer CreateRealBatchingCollectionInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public virtual ICollectionInitializer CreateBatchingOneToManyInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected abstract virtual ICollectionInitializer CreateRealBatchingOneToManyInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
public abstract class NHibernate.Loader.Collection.CollectionJoinWalker : JoinWalker {
    public CollectionJoinWalker(ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected SqlStringBuilder WhereString(string alias, String[] columnNames, SqlString subselect, int batchSize);
}
public class NHibernate.Loader.Collection.CollectionLoader : OuterJoinLoader {
    private IQueryableCollection collectionPersister;
    private IParameterSpecification[] parametersSpecifications;
    public bool IsSubselectLoadingEnabled { get; }
    protected IQueryableCollection CollectionPersister { get; }
    protected IType KeyType { get; }
    public CollectionLoader(IQueryableCollection persister, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public virtual Task InitializeAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual bool get_IsSubselectLoadingEnabled();
    protected IQueryableCollection get_CollectionPersister();
    protected IType get_KeyType();
    public virtual void Initialize(object id, ISessionImplementor session);
    public virtual string ToString();
    protected virtual IEnumerable`1<IParameterSpecification> CreateParameterSpecificationsAndAssignBackTrack(IEnumerable`1<Parameter> sqlPatameters);
    protected virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
    protected SqlString GetSubSelectWithLimits(SqlString subquery, ICollection`1<IParameterSpecification> parameterSpecs, RowSelection processedRowSelection, IDictionary`2<string, TypedValue> parameters);
}
internal class NHibernate.Loader.Collection.DynamicBatchingCollectionInitializer : AbstractBatchingCollectionInitializer {
    private int _maxBatchSize;
    private Loader _singleKeyLoader;
    private DynamicBatchingCollectionLoader _batchLoader;
    public DynamicBatchingCollectionInitializer(IQueryableCollection collectionPersister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    [AsyncStateMachineAttribute("NHibernate.Loader.Collection.DynamicBatchingCollectionInitializer/<InitializeAsync>d__0")]
public virtual Task InitializeAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual void Initialize(object id, ISessionImplementor session);
}
public class NHibernate.Loader.Collection.DynamicBatchingCollectionInitializerBuilder : BatchingCollectionInitializerBuilder {
    protected virtual ICollectionInitializer CreateRealBatchingCollectionInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected virtual ICollectionInitializer CreateRealBatchingOneToManyInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
internal class NHibernate.Loader.Collection.DynamicBatchingCollectionLoader : CollectionLoader {
    private string _alias;
    public DynamicBatchingCollectionLoader(IQueryableCollection collectionPersister, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    private protected virtual SqlString TransformSql(SqlString sqlString, QueryParameters queryParameters, HashSet`1<IParameterSpecification> parameterSpecifications);
}
public interface NHibernate.Loader.Collection.ICollectionInitializer {
    public abstract virtual Task InitializeAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual void Initialize(object id, ISessionImplementor session);
}
public class NHibernate.Loader.Collection.LegacyBatchingCollectionInitializerBuilder : BatchingCollectionInitializerBuilder {
    protected virtual ICollectionInitializer CreateRealBatchingCollectionInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected virtual ICollectionInitializer CreateRealBatchingOneToManyInitializer(IQueryableCollection persister, int maxBatchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
public class NHibernate.Loader.Collection.OneToManyJoinWalker : CollectionJoinWalker {
    private IOuterJoinLoadable elementPersister;
    private IQueryableCollection oneToManyPersister;
    public OneToManyJoinWalker(IQueryableCollection oneToManyPersister, int batchSize, SqlString subquery, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected virtual bool IsDuplicateAssociation(string foreignKeyTable, String[] foreignKeyColumns);
    protected virtual string GenerateAliasForColumn(string rootAlias, string column);
    private void InitStatementString(IOuterJoinLoadable elementPersister, string alias, int batchSize, SqlString subquery);
    public virtual string ToString();
}
public class NHibernate.Loader.Collection.OneToManyLoader : CollectionLoader {
    private static INHibernateLogger log;
    public OneToManyLoader(IQueryableCollection oneToManyPersister, ISessionFactoryImplementor session, IDictionary`2<string, IFilter> enabledFilters);
    public OneToManyLoader(IQueryableCollection oneToManyPersister, int batchSize, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public OneToManyLoader(IQueryableCollection oneToManyPersister, int batchSize, SqlString subquery, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    private static OneToManyLoader();
    protected virtual void InitializeFromWalker(IQueryableCollection oneToManyPersister, SqlString subquery, int batchSize, IDictionary`2<string, IFilter> enabledFilters, ISessionFactoryImplementor factory);
}
public class NHibernate.Loader.Collection.SubselectCollectionLoader : BasicCollectionLoader {
    private static int BatchSizeForSubselectFetching;
    private Object[] keys;
    private IDictionary`2<string, TypedValue> namedParameters;
    private IType[] types;
    private Object[] values;
    private List`1<IParameterSpecification> parametersSpecifications;
    public SubselectCollectionLoader(IQueryableCollection persister, SqlString subquery, ICollection`1<EntityKey> entityKeys, QueryParameters queryParameters, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public virtual Task InitializeAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual void Initialize(object id, ISessionImplementor session);
    protected virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
}
public class NHibernate.Loader.Collection.SubselectOneToManyLoader : OneToManyLoader {
    private static int BatchSizeForSubselectFetching;
    private Object[] keys;
    private IDictionary`2<string, TypedValue> namedParameters;
    private IType[] types;
    private Object[] values;
    private List`1<IParameterSpecification> parametersSpecifications;
    public SubselectOneToManyLoader(IQueryableCollection persister, SqlString subquery, ICollection`1<EntityKey> entityKeys, QueryParameters queryParameters, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public virtual Task InitializeAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual void Initialize(object id, ISessionImplementor session);
    protected virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
}
public class NHibernate.Loader.Criteria.ComponentCollectionCriteriaInfoProvider : object {
    private IQueryableCollection persister;
    private Dictionary`2<string, IType> subTypes;
    public string Name { get; }
    public String[] Spaces { get; }
    public IPropertyMapping PropertyMapping { get; }
    private IPersister NHibernate.Loader.Criteria.IExtendedCriteriaInfoProvider.Persister { get; }
    public ComponentCollectionCriteriaInfoProvider(IQueryableCollection persister);
    public sealed virtual string get_Name();
    public sealed virtual String[] get_Spaces();
    public sealed virtual IPropertyMapping get_PropertyMapping();
    private sealed virtual override IPersister NHibernate.Loader.Criteria.IExtendedCriteriaInfoProvider.get_Persister();
    public sealed virtual IType GetType(string relativePath);
}
public class NHibernate.Loader.Criteria.CriteriaJoinWalker : AbstractEntityJoinWalker {
    private CriteriaQueryTranslator translator;
    private ISet`1<string> querySpaces;
    private IType[] resultTypes;
    private Boolean[] includeInResultRow;
    private String[] userAliases;
    private List`1<string> userAliasList;
    private List`1<IType> resultTypeList;
    private List`1<bool> includeInResultRowList;
    private static INHibernateLogger logger;
    public IType[] ResultTypes { get; }
    public String[] UserAliases { get; }
    public Boolean[] IncludeInResultRow { get; }
    protected SqlString WhereFragment { get; }
    public ISet`1<string> QuerySpaces { get; }
    public string Comment { get; }
    public CriteriaJoinWalker(IOuterJoinLoadable persister, CriteriaQueryTranslator translator, ISessionFactoryImplementor factory, ICriteria criteria, string rootEntityName, IDictionary`2<string, IFilter> enabledFilters);
    private static CriteriaJoinWalker();
    protected virtual void AddAssociations();
    protected virtual void WalkEntityTree(IOuterJoinLoadable persister, string alias, string path);
    protected virtual OuterJoinableAssociation CreateRootAssociation();
    protected virtual SelectMode GetSelectMode(string path);
    protected virtual ISet`1<string> GetEntityFetchLazyProperties(string path);
    private void WalkCompositeComponentIdTree(IOuterJoinLoadable persister, string alias, string path);
    public IType[] get_ResultTypes();
    public String[] get_UserAliases();
    public Boolean[] get_IncludeInResultRow();
    protected virtual SqlString get_WhereFragment();
    public ISet`1<string> get_QuerySpaces();
    public virtual string get_Comment();
    protected virtual IReadOnlyCollection`1<string> GetChildAliases(string parentSqlAlias, string childPath);
    protected virtual JoinType GetJoinType(IAssociationType type, FetchMode config, string path, string pathAlias, string lhsTable, String[] lhsColumns, bool nullable, int currentDepth, CascadeStyle cascadeStyle);
    protected virtual string GenerateTableAlias(int n, string path, string pathAlias, IJoinable joinable);
    private void IncludeInResultIfNeeded(IJoinable joinable, ICriteria subcriteria, string sqlAlias, string path);
    protected virtual string GenerateRootAlias(string tableName);
    protected virtual SqlString GetWithClause(string path, string pathAlias);
}
public class NHibernate.Loader.Criteria.CriteriaLoader : OuterJoinLoader {
    private CriteriaQueryTranslator translator;
    private ISet`1<string> querySpaces;
    private String[] userAliases;
    private Boolean[] includeInResultRow;
    private int resultRowLength;
    private ISet`1<ICollectionPersister> _uncacheableCollectionPersisters;
    private String[] cachedProjectedColumnAliases;
    private Boolean[] childFetchEntities;
    [CompilerGeneratedAttribute]
private ISet`1[] <EntityFetchLazyProperties>k__BackingField;
    public ISet`1<string> QuerySpaces { get; }
    public bool IsSubselectLoadingEnabled { get; }
    public CriteriaQueryTranslator Translator { get; }
    protected String[] ResultRowAliases { get; }
    protected Boolean[] IncludeInResultRow { get; }
    protected ISet`1[] EntityFetchLazyProperties { get; }
    public CriteriaLoader(IOuterJoinLoadable persister, ISessionFactoryImplementor factory, CriteriaImpl rootCriteria, string rootEntityName, IDictionary`2<string, IFilter> enabledFilters);
    public Task`1<IList> ListAsync(ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Criteria.CriteriaLoader/<GetResultColumnOrRowAsync>d__1")]
protected virtual Task`1<object> GetResultColumnOrRowAsync(Object[] row, IResultTransformer customResultTransformer, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Criteria.CriteriaLoader/<GetResultRowAsync>d__2")]
protected virtual Task`1<Object[]> GetResultRowAsync(Object[] row, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    public ISet`1<string> get_QuerySpaces();
    public virtual bool IsCacheable(QueryParameters queryParameters);
    public virtual bool get_IsSubselectLoadingEnabled();
    public CriteriaQueryTranslator get_Translator();
    protected virtual String[] get_ResultRowAliases();
    protected virtual Boolean[] get_IncludeInResultRow();
    protected virtual bool IsChildFetchEntity(int i);
    [CompilerGeneratedAttribute]
protected virtual ISet`1[] get_EntityFetchLazyProperties();
    public IList List(ISessionImplementor session);
    protected virtual IResultTransformer ResolveResultTransformer(IResultTransformer resultTransformer);
    protected virtual bool AreResultSetRowsTransformedImmediately();
    protected virtual object GetResultColumnOrRow(Object[] row, IResultTransformer customResultTransformer, DbDataReader rs, ISessionImplementor session);
    protected virtual Object[] GetResultRow(Object[] row, DbDataReader rs, ISessionImplementor session);
    private Object[] ToResultRow(Object[] row);
    protected virtual SqlString ApplyLocks(SqlString sqlSelectString, IDictionary`2<string, LockMode> lockModes, Dialect dialect);
    public virtual LockMode[] GetLockModes(IDictionary`2<string, LockMode> lockModes);
    public virtual IList GetResultList(IList results, IResultTransformer resultTransformer);
    protected virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
    protected virtual bool IsCollectionPersisterCacheable(ICollectionPersister collectionPersister);
}
[ExtensionAttribute]
internal static class NHibernate.Loader.Criteria.CriteriaLoaderExtensions : object {
    [AsyncStateMachineAttribute("NHibernate.Loader.Criteria.CriteriaLoaderExtensions/<LoadAllToListAsync>d__0`1")]
[ExtensionAttribute]
internal static Task`1<List`1<T>> LoadAllToListAsync(IList`1<CriteriaLoader> loaders, ISessionImplementor session, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static List`1<T> LoadAllToList(IList`1<CriteriaLoader> loaders, ISessionImplementor session);
}
public class NHibernate.Loader.Criteria.CriteriaQueryTranslator : object {
    public static string RootSqlAlias;
    private static INHibernateLogger logger;
    private static int AliasCount;
    private ICriteriaQuery outerQueryTranslator;
    private CriteriaImpl rootCriteria;
    private string rootSQLAlias;
    private int indexForAlias;
    private List`1<EntityProjection> entityProjections;
    private Dictionary`2<ICriteria, ICriteriaInfoProvider> criteriaInfoMap;
    private Dictionary`2<string, ICriteriaInfoProvider> nameCriteriaInfoMap;
    private HashSet`1<ICollectionPersister> uncacheableCollectionPersisters;
    private HashSet`1<ICollectionPersister> criteriaCollectionPersisters;
    private Dictionary`2<ICriteria, string> criteriaSQLAliasMap;
    private Dictionary`2<string, string> sqlAliasToCriteriaAliasMap;
    private Dictionary`2<string, HashSet`1<string>> associationAliasToChildrenAliasesMap;
    private Dictionary`2<string, ICriteria> aliasCriteriaMap;
    private Dictionary`2<AliasKey, Subcriteria> associationPathCriteriaMap;
    private Dictionary`2<AliasKey, JoinType> associationPathJoinTypesMap;
    private Dictionary`2<AliasKey, ICriterion> withClauseMap;
    private ISessionFactoryImplementor sessionFactory;
    private SessionFactoryHelper helper;
    private ICollection`1<IParameterSpecification> collectedParameterSpecifications;
    private ICollection`1<NamedParameter> namedParameters;
    private HashSet`1<string> subQuerySpaces;
    private HashSet`1<IPersister> subPersisters;
    private Dictionary`2<string, EntityJoinInfo> entityJoins;
    private IQueryable rootPersister;
    private bool supportsQueryCache;
    [CLSCompliantAttribute("False")]
public string RootSQLAlias { get; }
    internal bool SupportsQueryCache { get; }
    public int SQLAliasCount { get; }
    public CriteriaImpl RootCriteria { get; }
    private ICriteria NHibernate.Loader.Criteria.ISupportEntityProjectionCriteriaQuery.RootCriteria { get; }
    public IType[] ProjectedTypes { get; }
    public String[] ProjectedColumnAliases { get; }
    public String[] ProjectedAliases { get; }
    public ISet`1<ICollectionPersister> UncacheableCollectionPersisters { get; }
    public ISessionFactoryImplementor Factory { get; }
    public bool HasProjection { get; }
    public ICollection`1<IParameterSpecification> CollectedParameterSpecifications { get; }
    public ICollection`1<NamedParameter> CollectedParameters { get; }
    public CriteriaQueryTranslator(ISessionFactoryImplementor factory, CriteriaImpl criteria, string rootEntityName, string rootSQLAlias, ICriteriaQuery outerQuery);
    public CriteriaQueryTranslator(ISessionFactoryImplementor factory, CriteriaImpl criteria, string rootEntityName, string rootSQLAlias);
    private static CriteriaQueryTranslator();
    public string get_RootSQLAlias();
    public ISet`1<string> GetQuerySpaces();
    [IteratorStateMachineAttribute("NHibernate.Loader.Criteria.CriteriaQueryTranslator/<GetPersisters>d__35")]
internal IEnumerable`1<IPersister> GetPersisters();
    internal bool get_SupportsQueryCache();
    public int get_SQLAliasCount();
    public CriteriaImpl get_RootCriteria();
    private sealed virtual override ICriteria NHibernate.Loader.Criteria.ISupportEntityProjectionCriteriaQuery.get_RootCriteria();
    internal IReadOnlyDictionary`2<string, EntityJoinInfo> GetEntityJoins();
    public QueryParameters GetQueryParameters();
    public SqlString GetGroupBy();
    public SqlString GetSelect();
    internal IType ResultType(ICriteria criteria);
    public IType[] get_ProjectedTypes();
    public String[] get_ProjectedColumnAliases();
    public String[] get_ProjectedAliases();
    public ISet`1<ICollectionPersister> get_UncacheableCollectionPersisters();
    public IList`1<EntityProjection> GetEntityProjections();
    public sealed virtual void RegisterEntityProjection(EntityProjection projection);
    public SqlString GetWhereCondition();
    public SqlString GetOrderBy();
    public sealed virtual ISessionFactoryImplementor get_Factory();
    public sealed virtual string GenerateSQLAlias();
    private ICriteria GetAliasedCriteria(string alias);
    [ObsoleteAttribute("Use overload with a critAlias additional parameter", "True")]
public bool IsJoin(string path);
    public bool IsJoin(string path, string critAlias);
    public IReadOnlyCollection`1<string> GetChildAliases(string parentSqlAlias, string childPath);
    [ObsoleteAttribute("Use overload with a critAlias additional parameter", "True")]
public JoinType GetJoinType(string path);
    public JoinType GetJoinType(string path, string critAlias);
    [ObsoleteAttribute("Use overload with a critAlias additional parameter", "True")]
public ICriteria GetCriteria(string path);
    public ICriteria GetCriteria(string path, string critAlias);
    private void CreateAliasCriteriaMap();
    private void CreateAssociationPathCriteriaMap();
    private string GetWholeAssociationPath(Subcriteria subcriteria, String& parentAlias);
    private void CreateCriteriaEntityNameMap();
    private void CreateEntityJoinMap();
    private void CreateCriteriaCollectionPersisters();
    private IJoinable GetPathJoinable(string path);
    private ICriteriaInfoProvider GetPathInfo(string path, ICriteriaInfoProvider rootProvider);
    private void CreateCriteriaSQLAliasMap();
    public bool get_HasProjection();
    public sealed virtual string GetSQLAlias(ICriteria criteria);
    public sealed virtual string GetEntityName(ICriteria criteria);
    public sealed virtual string GetColumn(ICriteria criteria, string propertyName);
    public sealed virtual String[] GetColumnsUsingProjection(ICriteria subcriteria, string propertyName);
    public sealed virtual String[] GetIdentifierColumns(ICriteria subcriteria);
    public sealed virtual IType GetIdentifierType(ICriteria subcriteria);
    public sealed virtual TypedValue GetTypedIdentifierValue(ICriteria subcriteria, object value);
    public sealed virtual String[] GetColumns(ICriteria subcriteria, string propertyName);
    private bool TryGetColumns(ICriteria subcriteria, string path, bool verifyPropertyName, String[]& columns);
    public sealed virtual IType GetTypeUsingProjection(ICriteria subcriteria, string propertyName);
    public sealed virtual IType GetType(ICriteria subcriteria, string propertyName);
    public bool TryGetType(ICriteria subcriteria, string propertyName, IType& type);
    public sealed virtual TypedValue GetTypedValue(ICriteria subcriteria, string propertyName, object value);
    private IPropertyMapping GetPropertyMapping(string entityName);
    public sealed virtual string GetEntityName(ICriteria subcriteria, string propertyName);
    public SqlString RenderSQLAliases(SqlString sqlTemplate);
    public sealed virtual string GetSQLAlias(ICriteria criteria, string propertyName);
    public sealed virtual string GetPropertyName(string propertyName);
    [ObsoleteAttribute("Use overload with a critAlias additional parameter", "True")]
public SqlString GetWithClause(string path);
    public SqlString GetWithClause(string path, string pathAlias);
    public sealed virtual int GetIndexForAlias();
    public sealed virtual IEnumerable`1<Parameter> NewQueryParameter(TypedValue parameter);
    private IEnumerable`1<Parameter> NewQueryParameter(string parameterPrefix, TypedValue parameter);
    public sealed virtual ICollection`1<IParameterSpecification> get_CollectedParameterSpecifications();
    public sealed virtual ICollection`1<NamedParameter> get_CollectedParameters();
    public sealed virtual Parameter CreateSkipParameter(int value);
    public sealed virtual Parameter CreateTakeParameter(int value);
    public SqlString GetHavingCondition();
    protected static bool HasGroupedOrAggregateProjection(IProjection[] projections);
    public sealed virtual String[] GetColumnAliasesUsingProjection(ICriteria subcriteria, string propertyName);
    private void CreateSubQuerySpaces();
    private IQueryable GetQueryablePersister(string entityName);
    private bool TryParseCriteriaPath(ICriteria subcriteria, string path, String& entityName, String& propertyName, ICriteria& pathCriteria);
}
public class NHibernate.Loader.Criteria.EntityCriteriaInfoProvider : object {
    private IQueryable persister;
    public string Name { get; }
    public String[] Spaces { get; }
    public IPropertyMapping PropertyMapping { get; }
    private IPersister NHibernate.Loader.Criteria.IExtendedCriteriaInfoProvider.Persister { get; }
    public EntityCriteriaInfoProvider(IQueryable persister);
    public sealed virtual string get_Name();
    public sealed virtual String[] get_Spaces();
    public sealed virtual IPropertyMapping get_PropertyMapping();
    private sealed virtual override IPersister NHibernate.Loader.Criteria.IExtendedCriteriaInfoProvider.get_Persister();
    public sealed virtual IType GetType(string relativePath);
}
public interface NHibernate.Loader.Criteria.ICriteriaInfoProvider {
    public string Name { get; }
    public String[] Spaces { get; }
    public IPropertyMapping PropertyMapping { get; }
    public abstract virtual string get_Name();
    public abstract virtual String[] get_Spaces();
    public abstract virtual IPropertyMapping get_PropertyMapping();
    public abstract virtual IType GetType(string relativePath);
}
internal interface NHibernate.Loader.Criteria.IExtendedCriteriaInfoProvider {
    public IPersister Persister { get; }
    public abstract virtual IPersister get_Persister();
}
public interface NHibernate.Loader.Criteria.ISupportEntityProjectionCriteriaQuery {
    public ICriteria RootCriteria { get; }
    public abstract virtual void RegisterEntityProjection(EntityProjection projection);
    public abstract virtual ICriteria get_RootCriteria();
}
public class NHibernate.Loader.Criteria.ScalarCollectionCriteriaInfoProvider : object {
    private string role;
    private IQueryableCollection persister;
    private SessionFactoryHelper helper;
    public string Name { get; }
    public String[] Spaces { get; }
    public IPropertyMapping PropertyMapping { get; }
    private IPersister NHibernate.Loader.Criteria.IExtendedCriteriaInfoProvider.Persister { get; }
    public ScalarCollectionCriteriaInfoProvider(SessionFactoryHelper helper, string role);
    public sealed virtual string get_Name();
    public sealed virtual String[] get_Spaces();
    public sealed virtual IPropertyMapping get_PropertyMapping();
    private sealed virtual override IPersister NHibernate.Loader.Criteria.IExtendedCriteriaInfoProvider.get_Persister();
    public sealed virtual IType GetType(string relativePath);
}
public class NHibernate.Loader.Custom.CollectionFetchReturn : FetchReturn {
    private ICollectionAliases collectionAliases;
    private IEntityAliases elementEntityAliases;
    public ICollectionAliases CollectionAliases { get; }
    public IEntityAliases ElementEntityAliases { get; }
    public CollectionFetchReturn(string alias, NonScalarReturn owner, string ownerProperty, ICollectionAliases collectionAliases, IEntityAliases elementEntityAliases, LockMode lockMode);
    public ICollectionAliases get_CollectionAliases();
    public IEntityAliases get_ElementEntityAliases();
}
public class NHibernate.Loader.Custom.CollectionReturn : NonScalarReturn {
    private string ownerEntityName;
    private string ownerProperty;
    private ICollectionAliases collectionAliases;
    private IEntityAliases elementEntityAliases;
    public string OwnerEntityName { get; }
    public string OwnerProperty { get; }
    public ICollectionAliases CollectionAliases { get; }
    public IEntityAliases ElementEntityAliases { get; }
    public CollectionReturn(string alias, string ownerEntityName, string ownerProperty, ICollectionAliases collectionAliases, IEntityAliases elementEntityAliases, LockMode lockMode);
    public string get_OwnerEntityName();
    public string get_OwnerProperty();
    public ICollectionAliases get_CollectionAliases();
    public IEntityAliases get_ElementEntityAliases();
}
public class NHibernate.Loader.Custom.ColumnCollectionAliases : object {
    private String[] keyAliases;
    private String[] indexAliases;
    private String[] elementAliases;
    private string identifierAlias;
    public String[] SuffixedKeyAliases { get; }
    public String[] SuffixedIndexAliases { get; }
    public String[] SuffixedElementAliases { get; }
    public string SuffixedIdentifierAlias { get; }
    public string Suffix { get; }
    public ColumnCollectionAliases(IDictionary`2<string, String[]> userProvidedAliases, ISqlLoadableCollection persister);
    public sealed virtual String[] get_SuffixedKeyAliases();
    public sealed virtual String[] get_SuffixedIndexAliases();
    public sealed virtual String[] get_SuffixedElementAliases();
    public sealed virtual string get_SuffixedIdentifierAlias();
    public sealed virtual string get_Suffix();
    public virtual string ToString();
    private static string Join(String[] aliases);
    private static String[] GetUserProvidedAliases(IDictionary`2<string, String[]> userProvidedAliases, string propertyPath, String[] defaultAliases);
    private static string GetUserProvidedAlias(IDictionary`2<string, String[]> userProvidedAliases, string propertyPath, string defaultAlias);
}
public class NHibernate.Loader.Custom.ColumnEntityAliases : DefaultEntityAliases {
    public ColumnEntityAliases(IDictionary`2<string, String[]> returnProperties, ILoadable persister, string suffix);
    protected virtual String[] GetIdentifierAliases(ILoadable persister, string suffix);
    protected virtual string GetDiscriminatorAlias(ILoadable persister, string suffix);
    protected virtual String[] GetPropertyAliases(ILoadable persister, int j);
}
public class NHibernate.Loader.Custom.CustomLoader : Loader {
    private SqlString sql;
    private HashSet`1<string> querySpaces;
    private bool supportsQueryCache;
    private List`1<IParameterSpecification> parametersSpecifications;
    private IQueryable[] entityPersisters;
    private Int32[] entityOwners;
    private IEntityAliases[] entityAliases;
    private IQueryableCollection[] collectionPersisters;
    private Int32[] collectionOwners;
    private ICollectionAliases[] collectionAliases;
    private IPersister[] customPersisters;
    private LockMode[] lockModes;
    private ResultRowProcessor rowProcessor;
    private Boolean[] includeInResultRow;
    private String[] transformerAliases;
    [CompilerGeneratedAttribute]
private String[] <ResultRowAliases>k__BackingField;
    public ISet`1<string> QuerySpaces { get; }
    protected Int32[] CollectionOwners { get; }
    protected Int32[] Owners { get; }
    private String[] ReturnAliasesForTransformer { get; }
    protected IEntityAliases[] EntityAliases { get; }
    protected ICollectionAliases[] CollectionAliases { get; }
    public string QueryIdentifier { get; }
    public SqlString SqlString { get; }
    public ILoadable[] EntityPersisters { get; }
    protected internal ICollectionPersister[] CollectionPersisters { get; }
    protected String[] ResultRowAliases { get; }
    protected Boolean[] IncludeInResultRow { get; }
    public String[] ReturnAliases { get; }
    public IEnumerable`1<string> NamedParameters { get; }
    public CustomLoader(ICustomQuery customQuery, ISessionFactoryImplementor factory);
    public Task`1<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    protected virtual Task`1<object> GetResultColumnOrRowAsync(Object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    protected virtual Task`1<Object[]> GetResultRowAsync(Object[] row, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    public ISet`1<string> get_QuerySpaces();
    public virtual bool IsCacheable(QueryParameters queryParameters);
    protected virtual Int32[] get_CollectionOwners();
    protected virtual Int32[] get_Owners();
    private String[] get_ReturnAliasesForTransformer();
    protected virtual IEntityAliases[] get_EntityAliases();
    protected virtual ICollectionAliases[] get_CollectionAliases();
    private IQueryable DetermineAppropriateOwnerPersister(NonScalarReturn ownerDescriptor);
    public virtual string get_QueryIdentifier();
    public virtual SqlString get_SqlString();
    public virtual LockMode[] GetLockModes(IDictionary`2<string, LockMode> lockModesMap);
    public virtual ILoadable[] get_EntityPersisters();
    protected internal virtual ICollectionPersister[] get_CollectionPersisters();
    public IList List(ISessionImplementor session, QueryParameters queryParameters);
    protected virtual object GetResultColumnOrRow(Object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session);
    protected virtual Object[] GetResultRow(Object[] row, DbDataReader rs, ISessionImplementor session);
    [CompilerGeneratedAttribute]
protected virtual String[] get_ResultRowAliases();
    protected virtual IResultTransformer ResolveResultTransformer(IResultTransformer resultTransformer);
    protected virtual Boolean[] get_IncludeInResultRow();
    public virtual IList GetResultList(IList results, IResultTransformer resultTransformer);
    public virtual void AutoDiscoverTypes(DbDataReader rs, QueryParameters queryParameters, IResultTransformer forcedResultTransformer);
    protected virtual void ResetEffectiveExpectedType(IEnumerable`1<IParameterSpecification> parameterSpecs, QueryParameters queryParameters);
    protected virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
    public String[] get_ReturnAliases();
    public IEnumerable`1<string> get_NamedParameters();
}
public class NHibernate.Loader.Custom.EntityFetchReturn : FetchReturn {
    private IEntityAliases entityAliases;
    public IEntityAliases EntityAliases { get; }
    public EntityFetchReturn(string alias, IEntityAliases entityAliases, NonScalarReturn owner, string ownerProperty, LockMode lockMode);
    public IEntityAliases get_EntityAliases();
}
public abstract class NHibernate.Loader.Custom.FetchReturn : NonScalarReturn {
    private NonScalarReturn owner;
    private string ownerProperty;
    public NonScalarReturn Owner { get; }
    public string OwnerProperty { get; }
    public FetchReturn(NonScalarReturn owner, string ownerProperty, string alias, LockMode lockMode);
    public NonScalarReturn get_Owner();
    public string get_OwnerProperty();
}
public interface NHibernate.Loader.Custom.ICustomQuery {
    public SqlString SQL { get; }
    public ISet`1<string> QuerySpaces { get; }
    public IList`1<IReturn> CustomQueryReturns { get; }
    public IEnumerable`1<IParameterSpecification> CollectedParametersSpecifications { get; }
    public abstract virtual SqlString get_SQL();
    public abstract virtual ISet`1<string> get_QuerySpaces();
    public abstract virtual IList`1<IReturn> get_CustomQueryReturns();
    public abstract virtual IEnumerable`1<IParameterSpecification> get_CollectedParametersSpecifications();
}
public interface NHibernate.Loader.Custom.IReturn {
}
public abstract class NHibernate.Loader.Custom.NonScalarReturn : object {
    private string alias;
    private LockMode lockMode;
    public string Alias { get; }
    public LockMode LockMode { get; }
    public NonScalarReturn(string alias, LockMode lockMode);
    public string get_Alias();
    public LockMode get_LockMode();
}
public class NHibernate.Loader.Custom.RootReturn : NonScalarReturn {
    private string entityName;
    private IEntityAliases entityAliases;
    public string EntityName { get; }
    public IEntityAliases EntityAliases { get; }
    public RootReturn(string alias, string entityName, IEntityAliases entityAliases, LockMode lockMode);
    public string get_EntityName();
    public IEntityAliases get_EntityAliases();
}
public class NHibernate.Loader.Custom.ScalarReturn : object {
    private IType type;
    private string columnAlias;
    public IType Type { get; }
    public string ColumnAlias { get; }
    public ScalarReturn(IType type, string columnAlias);
    public IType get_Type();
    public string get_ColumnAlias();
}
public class NHibernate.Loader.Custom.Sql.SQLCustomQuery : object {
    private static INHibernateLogger log;
    private List`1<IReturn> customQueryReturns;
    private HashSet`1<string> querySpaces;
    private SqlString sql;
    private List`1<IParameterSpecification> parametersSpecifications;
    public IEnumerable`1<IParameterSpecification> CollectedParametersSpecifications { get; }
    public SqlString SQL { get; }
    public ISet`1<string> QuerySpaces { get; }
    public IList`1<IReturn> CustomQueryReturns { get; }
    public SQLCustomQuery(INativeSQLQueryReturn[] queryReturns, string sqlQuery, ICollection`1<string> additionalQuerySpaces, ISessionFactoryImplementor factory);
    private static SQLCustomQuery();
    public sealed virtual IEnumerable`1<IParameterSpecification> get_CollectedParametersSpecifications();
    public sealed virtual SqlString get_SQL();
    public sealed virtual ISet`1<string> get_QuerySpaces();
    public sealed virtual IList`1<IReturn> get_CustomQueryReturns();
}
public class NHibernate.Loader.Custom.Sql.SQLQueryParser : object {
    private ISessionFactoryImplementor factory;
    private string originalQueryString;
    private IParserContext context;
    private long aliasesFound;
    private IEnumerable`1<IParameterSpecification> parametersSpecifications;
    public bool QueryHasAliases { get; }
    public IEnumerable`1<IParameterSpecification> CollectedParametersSpecifications { get; }
    public SQLQueryParser(ISessionFactoryImplementor factory, string sqlQuery, IParserContext context);
    public bool get_QueryHasAliases();
    public SqlString Process();
    public IEnumerable`1<IParameterSpecification> get_CollectedParametersSpecifications();
    private string SubstituteBrackets();
    private string ResolveCollectionProperties(string aliasName, string propertyName);
    private string ResolveProperties(string aliasName, string propertyName);
    private SqlString SubstituteParams(string sqlString);
}
public class NHibernate.Loader.Custom.Sql.SQLQueryReturnProcessor : object {
    private static INHibernateLogger log;
    private INativeSQLQueryReturn[] queryReturns;
    private Dictionary`2<string, INativeSQLQueryReturn> alias2Return;
    private Dictionary`2<string, string> alias2OwnerAlias;
    private Dictionary`2<string, ISqlLoadable> alias2Persister;
    private Dictionary`2<string, string> alias2Suffix;
    private Dictionary`2<string, ISqlLoadableCollection> alias2CollectionPersister;
    private Dictionary`2<string, string> alias2CollectionSuffix;
    private Dictionary`2<string, IDictionary`2<string, String[]>> entityPropertyResultMaps;
    private Dictionary`2<string, IDictionary`2<string, String[]>> collectionPropertyResultMaps;
    private ISessionFactoryImplementor factory;
    private int entitySuffixSeed;
    private int collectionSuffixSeed;
    private ISessionFactoryImplementor Factory { get; }
    public SQLQueryReturnProcessor(INativeSQLQueryReturn[] queryReturns, ISessionFactoryImplementor factory);
    private static SQLQueryReturnProcessor();
    private ISessionFactoryImplementor get_Factory();
    private IDictionary`2<string, String[]> InternalGetPropertyResultsMap(string alias);
    private bool HasPropertyResultMap(string alias);
    public ResultAliasContext Process();
    private ISqlLoadable GetSQLLoadable(string entityName);
    private string GenerateEntitySuffix();
    private string GenerateCollectionSuffix();
    private void ProcessReturn(INativeSQLQueryReturn rtn);
    private void ProcessScalarReturn(NativeSQLQueryScalarReturn typeReturn);
    private void ProcessRootReturn(NativeSQLQueryRootReturn rootReturn);
    private void AddPersister(string alias, IDictionary`2<string, String[]> propertyResult, ISqlLoadable persister);
    private void AddCollection(string role, string alias, IDictionary`2<string, String[]> propertyResults);
    private IDictionary`2<string, String[]> Filter(IDictionary`2<string, String[]> propertyResults);
    private void ProcessCollectionReturn(NativeSQLQueryCollectionReturn collectionReturn);
    private void ProcessJoinReturn(NativeSQLQueryJoinReturn fetchReturn);
    public IList GenerateCustomReturns(bool queryHadAliases);
}
public class NHibernate.Loader.DefaultEntityAliases : object {
    private string _suffix;
    private IDictionary`2<string, String[]> _userProvidedAliases;
    private string _rowIdAlias;
    [CompilerGeneratedAttribute]
private String[] <SuffixedVersionAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private String[][] <SuffixedPropertyAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuffixedDiscriminatorAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SuffixedKeyAliases>k__BackingField;
    public String[] SuffixedVersionAliases { get; }
    public String[][] SuffixedPropertyAliases { get; }
    public string SuffixedDiscriminatorAlias { get; }
    public String[] SuffixedKeyAliases { get; }
    public string RowIdAlias { get; }
    public DefaultEntityAliases(ILoadable persister, string suffix);
    public DefaultEntityAliases(IDictionary`2<string, String[]> userProvidedAliases, ILoadable persister, string suffix);
    public sealed virtual String[][] GetSuffixedPropertyAliases(ILoadable persister);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_SuffixedVersionAliases();
    [CompilerGeneratedAttribute]
public sealed virtual String[][] get_SuffixedPropertyAliases();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SuffixedDiscriminatorAlias();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_SuffixedKeyAliases();
    public sealed virtual string get_RowIdAlias();
    private String[][] GetAllPropertyAliases(ILoadable persister);
    protected virtual string GetDiscriminatorAlias(ILoadable persister, string suffix);
    protected virtual String[] GetIdentifierAliases(ILoadable persister, string suffix);
    protected virtual String[] GetPropertyAliases(ILoadable persister, int j);
    private String[] DetermineKeyAliases(ILoadable persister);
    private String[][] DeterminePropertyAliases(ILoadable persister);
    private string DetermineDiscriminatorAlias(ILoadable persister);
    private String[] SafeGetUserProvidedAliases(string propertyPath);
    private String[] GetUserProvidedAliases(string propertyPath);
}
internal class NHibernate.Loader.DynamicBatchingHelper : object {
    private static string BatchIdPlaceholder;
    private static DynamicBatchingHelper();
    public static SqlStringBuilder BuildBatchFetchRestrictionFragment();
    public static SqlString ExpandBatchIdPlaceholder(SqlString sqlString, ISet`1<IParameterSpecification> specifications, String[] columns, IType[] types, ISessionFactoryImplementor factory);
    public static List`1<Parameter> GeneratePositionalParameters(ISet`1<IParameterSpecification> specifications, IType[] types, ISessionFactoryImplementor factory);
    public static int GetIdsToLoad(Object[] batch, Object[]& idsToLoad);
}
public abstract class NHibernate.Loader.Entity.AbstractBatchingEntityLoader : object {
    [CompilerGeneratedAttribute]
private IEntityPersister <Persister>k__BackingField;
    protected IEntityPersister Persister { get; }
    protected AbstractBatchingEntityLoader(IEntityPersister persister);
    public abstract virtual Task`1<object> LoadAsync(object id, object optionalObject, ISessionImplementor session, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
protected IEntityPersister get_Persister();
    protected virtual QueryParameters BuildQueryParameters(object id, Object[] ids, object optionalObject);
    protected object GetObjectFromList(IList results, object id, ISessionImplementor session);
    public abstract virtual object Load(object id, object optionalObject, ISessionImplementor session);
}
public abstract class NHibernate.Loader.Entity.AbstractEntityLoader : OuterJoinLoader {
    protected static INHibernateLogger log;
    protected IOuterJoinLoadable persister;
    protected string entityName;
    private IParameterSpecification[] parametersSpecifications;
    [CompilerGeneratedAttribute]
private IType <UniqueKeyType>k__BackingField;
    protected bool IsSingleRowLoader { get; }
    protected IType UniqueKeyType { get; private set; }
    protected AbstractEntityLoader(IOuterJoinLoadable persister, IType uniqueKeyType, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    private static AbstractEntityLoader();
    public sealed virtual Task`1<object> LoadAsync(object id, object optionalObject, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Entity.AbstractEntityLoader/<LoadAsync>d__1")]
protected virtual Task`1<object> LoadAsync(ISessionImplementor session, object id, object optionalObject, object optionalId, CancellationToken cancellationToken);
    protected virtual Task`1<object> GetResultColumnOrRowAsync(Object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    protected virtual bool get_IsSingleRowLoader();
    public sealed virtual object Load(object id, object optionalObject, ISessionImplementor session);
    protected virtual object Load(ISessionImplementor session, object id, object optionalObject, object optionalId);
    protected virtual object GetResultColumnOrRow(Object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session);
    [CompilerGeneratedAttribute]
protected IType get_UniqueKeyType();
    [CompilerGeneratedAttribute]
private void set_UniqueKeyType(IType value);
    private List`1<IParameterSpecification> CreateParameterSpecificationsAndAssignBackTrack(IEnumerable`1<Parameter> sqlPatameters);
    protected virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
}
public class NHibernate.Loader.Entity.BatchingEntityLoader : AbstractBatchingEntityLoader {
    private Loader[] loaders;
    private Int32[] batchSizes;
    private IType idType;
    public BatchingEntityLoader(IEntityPersister persister, Int32[] batchSizes, Loader[] loaders);
    [AsyncStateMachineAttribute("NHibernate.Loader.Entity.BatchingEntityLoader/<LoadAsync>d__0")]
public virtual Task`1<object> LoadAsync(object id, object optionalObject, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual object Load(object id, object optionalObject, ISessionImplementor session);
    public static IUniqueEntityLoader CreateBatchingEntityLoader(IOuterJoinLoadable persister, int maxBatchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
public abstract class NHibernate.Loader.Entity.BatchingEntityLoaderBuilder : object {
    public virtual IUniqueEntityLoader BuildLoader(IOuterJoinLoadable persister, int batchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected abstract virtual IUniqueEntityLoader BuildBatchingLoader(IOuterJoinLoadable persister, int batchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
public class NHibernate.Loader.Entity.CascadeEntityJoinWalker : AbstractEntityJoinWalker {
    private CascadingAction cascadeAction;
    protected bool IsTooManyCollections { get; }
    public string Comment { get; }
    public CascadeEntityJoinWalker(IOuterJoinLoadable persister, CascadingAction action, ISessionFactoryImplementor factory);
    protected virtual bool IsJoinedFetchEnabled(IAssociationType type, FetchMode config, CascadeStyle cascadeStyle);
    protected virtual bool get_IsTooManyCollections();
    public virtual string get_Comment();
}
public class NHibernate.Loader.Entity.CascadeEntityLoader : AbstractEntityLoader {
    public CascadeEntityLoader(IOuterJoinLoadable persister, CascadingAction action, ISessionFactoryImplementor factory);
}
public class NHibernate.Loader.Entity.CollectionElementLoader : OuterJoinLoader {
    private static INHibernateLogger log;
    private IOuterJoinLoadable persister;
    private IType keyType;
    private IType indexType;
    private string entityName;
    private IParameterSpecification[] parametersSpecifications;
    protected bool IsSingleRowLoader { get; }
    public CollectionElementLoader(IQueryableCollection collectionPersister, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    private static CollectionElementLoader();
    [AsyncStateMachineAttribute("NHibernate.Loader.Entity.CollectionElementLoader/<LoadElementAsync>d__0")]
public virtual Task`1<object> LoadElementAsync(ISessionImplementor session, object key, object index, CancellationToken cancellationToken);
    protected virtual Task`1<object> GetResultColumnOrRowAsync(Object[] row, IResultTransformer transformer, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    private IEnumerable`1<IParameterSpecification> CreateParameterSpecificationsAndAssignBackTrack(IEnumerable`1<Parameter> sqlPatameters);
    protected virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
    protected virtual bool get_IsSingleRowLoader();
    public virtual object LoadElement(ISessionImplementor session, object key, object index);
    protected virtual object GetResultColumnOrRow(Object[] row, IResultTransformer transformer, DbDataReader rs, ISessionImplementor session);
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CreateParameterSpecificationsAndAssignBackTrack>b__9_0(IParameterSpecification specification);
}
internal class NHibernate.Loader.Entity.DynamicBatchingEntityLoader : AbstractBatchingEntityLoader {
    private int _maxBatchSize;
    private IUniqueEntityLoader _singleKeyLoader;
    private DynamicEntityLoader _dynamicEntityLoader;
    public DynamicBatchingEntityLoader(IOuterJoinLoadable persister, int maxBatchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    [AsyncStateMachineAttribute("NHibernate.Loader.Entity.DynamicBatchingEntityLoader/<LoadAsync>d__0")]
public virtual Task`1<object> LoadAsync(object id, object optionalObject, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual object Load(object id, object optionalObject, ISessionImplementor session);
}
public class NHibernate.Loader.Entity.DynamicBatchingEntityLoaderBuilder : BatchingEntityLoaderBuilder {
    protected virtual IUniqueEntityLoader BuildBatchingLoader(IOuterJoinLoadable persister, int batchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
internal class NHibernate.Loader.Entity.DynamicEntityLoader : EntityLoader {
    private string _alias;
    protected bool IsSingleRowLoader { get; }
    public DynamicEntityLoader(IOuterJoinLoadable persister, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public virtual Task`1<IList> DoEntityBatchFetchAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    protected virtual bool get_IsSingleRowLoader();
    public virtual IList DoEntityBatchFetch(ISessionImplementor session, QueryParameters queryParameters);
    private protected virtual SqlString TransformSql(SqlString sqlString, QueryParameters queryParameters, HashSet`1<IParameterSpecification> parameterSpecifications);
}
public class NHibernate.Loader.Entity.EntityJoinWalker : AbstractEntityJoinWalker {
    private LockMode lockMode;
    public string Comment { get; }
    public EntityJoinWalker(IOuterJoinLoadable persister, String[] uniqueKey, int batchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected virtual string GenerateAliasForColumn(string rootAlias, string column);
    protected virtual bool IsJoinedFetchEnabled(IAssociationType type, FetchMode config, CascadeStyle cascadeStyle);
    public virtual string get_Comment();
}
public class NHibernate.Loader.Entity.EntityLoader : AbstractEntityLoader {
    private bool batchLoader;
    protected bool IsSingleRowLoader { get; }
    public EntityLoader(IOuterJoinLoadable persister, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public EntityLoader(IOuterJoinLoadable persister, int batchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public EntityLoader(IOuterJoinLoadable persister, String[] uniqueKey, IType uniqueKeyType, int batchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public Task`1<object> LoadByUniqueKeyAsync(ISessionImplementor session, object key, CancellationToken cancellationToken);
    public object LoadByUniqueKey(ISessionImplementor session, object key);
    protected virtual bool get_IsSingleRowLoader();
}
public interface NHibernate.Loader.Entity.IUniqueEntityLoader {
    public abstract virtual Task`1<object> LoadAsync(object id, object optionalObject, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual object Load(object id, object optionalObject, ISessionImplementor session);
}
public class NHibernate.Loader.Entity.LegacyBatchingEntityLoaderBuilder : BatchingEntityLoaderBuilder {
    protected virtual IUniqueEntityLoader BuildBatchingLoader(IOuterJoinLoadable persister, int batchSize, LockMode lockMode, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
public class NHibernate.Loader.GeneratedCollectionAliases : object {
    private string suffix;
    private String[] keyAliases;
    private String[] indexAliases;
    private String[] elementAliases;
    private string identifierAlias;
    public String[] SuffixedKeyAliases { get; }
    public String[] SuffixedIndexAliases { get; }
    public String[] SuffixedElementAliases { get; }
    public string SuffixedIdentifierAlias { get; }
    public string Suffix { get; }
    public GeneratedCollectionAliases(IDictionary`2<string, String[]> userProvidedAliases, ICollectionPersister persister, string suffix);
    public GeneratedCollectionAliases(ICollectionPersister persister, string str);
    private static String[] GetUserProvidedCompositeElementAliases(IDictionary`2<string, String[]> userProvidedAliases, String[] defaultAliases);
    public sealed virtual String[] get_SuffixedKeyAliases();
    public sealed virtual String[] get_SuffixedIndexAliases();
    public sealed virtual String[] get_SuffixedElementAliases();
    public sealed virtual string get_SuffixedIdentifierAlias();
    public sealed virtual string get_Suffix();
    public virtual string ToString();
    private static string Join(String[] aliases);
    private static String[] GetUserProvidedAliases(IDictionary`2<string, String[]> userProvidedAliases, string propertyPath, String[] defaultAliases);
    private static string GetUserProvidedAlias(IDictionary`2<string, String[]> userProvidedAliases, string propertyPath, string defaultAlias);
}
public interface NHibernate.Loader.Hql.IQueryLoader {
    public abstract virtual Task`1<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable> GetEnumerableAsync(QueryParameters queryParameters, IEventSource session, CancellationToken cancellationToken);
    public abstract virtual IList List(ISessionImplementor session, QueryParameters queryParameters);
    public abstract virtual IEnumerable GetEnumerable(QueryParameters queryParameters, IEventSource session);
}
public interface NHibernate.Loader.Hql.IQueryLoaderFactory {
    public abstract virtual IQueryLoader Create(QueryTranslatorImpl queryTranslator, ISessionFactoryImplementor factory, SelectClause selectClause);
}
[CLSCompliantAttribute("False")]
public class NHibernate.Loader.Hql.QueryLoader : BasicLoader {
    private QueryTranslatorImpl _queryTranslator;
    private bool _hasScalars;
    private String[][] _scalarColumnNames;
    private IResultTransformer _selectNewTransformer;
    private String[] _queryReturnAliases;
    private IQueryableCollection[] _collectionPersisters;
    private Int32[] _collectionOwners;
    private String[] _collectionSuffixes;
    private IQueryable[] _entityPersisters;
    private Boolean[] _entityEagerPropertyFetches;
    private HashSet`1[] _entityFetchLazyProperties;
    private String[] _entityAliases;
    private String[] _sqlAliases;
    private String[] _sqlAliasSuffixes;
    private Boolean[] _includeInSelect;
    private Int32[] _owners;
    private EntityType[] _ownerAssociationTypes;
    private NullableDictionary`2<string, string> _sqlAliasByEntityAlias;
    private int _selectLength;
    private LockMode[] _defaultLockModes;
    private ISet`1<ICollectionPersister> _uncacheableCollectionPersisters;
    private IReadOnlyDictionary`2<int, int> _entityByResultTypeDic;
    public bool IsSubselectLoadingEnabled { get; }
    protected String[] Aliases { get; }
    protected Int32[] CollectionOwners { get; }
    protected Boolean[] EntityEagerPropertyFetches { get; }
    protected ISet`1[] EntityFetchLazyProperties { get; }
    protected EntityType[] OwnerAssociationTypes { get; }
    protected Int32[] Owners { get; }
    public string QueryIdentifier { get; }
    public SqlString SqlString { get; }
    public ILoadable[] EntityPersisters { get; }
    protected String[] Suffixes { get; }
    protected String[] CollectionSuffixes { get; }
    protected internal ICollectionPersister[] CollectionPersisters { get; }
    private bool HasSelectNew { get; }
    protected String[] ResultRowAliases { get; }
    protected Boolean[] IncludeInResultRow { get; }
    [ObsoleteAttribute("Please use ResultTypes instead")]
public IType[] ReturnTypes { get; }
    public QueryLoader(QueryTranslatorImpl queryTranslator, ISessionFactoryImplementor factory, SelectClause selectClause);
    public sealed virtual Task`1<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Hql.QueryLoader/<GetResultColumnOrRowAsync>d__1")]
protected virtual Task`1<object> GetResultColumnOrRowAsync(Object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Hql.QueryLoader/<GetResultRowAsync>d__2")]
protected virtual Task`1<Object[]> GetResultRowAsync(Object[] row, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Hql.QueryLoader/<GetEnumerableAsync>d__3")]
public sealed virtual Task`1<IEnumerable> GetEnumerableAsync(QueryParameters queryParameters, IEventSource session, CancellationToken cancellationToken);
    public virtual bool get_IsSubselectLoadingEnabled();
    protected virtual SqlString ApplyLocks(SqlString sql, IDictionary`2<string, LockMode> lockModes, Dialect dialect);
    protected virtual String[] get_Aliases();
    public virtual bool IsCacheable(QueryParameters queryParameters);
    protected virtual Int32[] get_CollectionOwners();
    protected virtual Boolean[] get_EntityEagerPropertyFetches();
    protected virtual ISet`1[] get_EntityFetchLazyProperties();
    protected virtual EntityType[] get_OwnerAssociationTypes();
    protected virtual Int32[] get_Owners();
    public virtual string get_QueryIdentifier();
    protected virtual bool UpgradeLocks();
    public virtual LockMode[] GetLockModes(IDictionary`2<string, LockMode> lockModes);
    public virtual SqlString get_SqlString();
    public virtual ILoadable[] get_EntityPersisters();
    protected virtual String[] get_Suffixes();
    protected virtual String[] get_CollectionSuffixes();
    protected internal virtual ICollectionPersister[] get_CollectionPersisters();
    private void Initialize(SelectClause selectClause);
    public sealed virtual IList List(ISessionImplementor session, QueryParameters queryParameters);
    public virtual IList GetResultList(IList results, IResultTransformer resultTransformer);
    protected virtual bool IsCollectionPersisterCacheable(ICollectionPersister collectionPersister);
    protected virtual IResultTransformer ResolveResultTransformer(IResultTransformer resultTransformer);
    protected virtual object GetResultColumnOrRow(Object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session);
    protected virtual Object[] GetResultRow(Object[] row, DbDataReader rs, ISessionImplementor session);
    private Object[] ToResultRow(Object[] row);
    private void CheckQuery(QueryParameters queryParameters);
    private bool get_HasSelectNew();
    protected virtual String[] get_ResultRowAliases();
    protected virtual Boolean[] get_IncludeInResultRow();
    public IType[] get_ReturnTypes();
    public sealed virtual IEnumerable GetEnumerable(QueryParameters queryParameters, IEventSource session);
    protected virtual void ResetEffectiveExpectedType(IEnumerable`1<IParameterSpecification> parameterSpecs, QueryParameters queryParameters);
    protected virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
    private static IResultTransformer GetSelectNewTransformer(SelectClause selectClause);
}
public class NHibernate.Loader.Hql.QueryLoaderFactory : object {
    public sealed virtual IQueryLoader Create(QueryTranslatorImpl queryTranslator, ISessionFactoryImplementor factory, SelectClause selectClause);
}
public interface NHibernate.Loader.ICollectionAliases {
    public String[] SuffixedKeyAliases { get; }
    public String[] SuffixedIndexAliases { get; }
    public String[] SuffixedElementAliases { get; }
    public string SuffixedIdentifierAlias { get; }
    public string Suffix { get; }
    public abstract virtual String[] get_SuffixedKeyAliases();
    public abstract virtual String[] get_SuffixedIndexAliases();
    public abstract virtual String[] get_SuffixedElementAliases();
    public abstract virtual string get_SuffixedIdentifierAlias();
    public abstract virtual string get_Suffix();
}
public interface NHibernate.Loader.IEntityAliases {
    public String[] SuffixedKeyAliases { get; }
    public string SuffixedDiscriminatorAlias { get; }
    public String[] SuffixedVersionAliases { get; }
    public string RowIdAlias { get; }
    public String[][] SuffixedPropertyAliases { get; }
    public abstract virtual String[] get_SuffixedKeyAliases();
    public abstract virtual string get_SuffixedDiscriminatorAlias();
    public abstract virtual String[] get_SuffixedVersionAliases();
    public abstract virtual string get_RowIdAlias();
    public abstract virtual String[][] get_SuffixedPropertyAliases();
    public abstract virtual String[][] GetSuffixedPropertyAliases(ILoadable persister);
}
public interface NHibernate.Loader.ILoader {
    public bool IsSubselectLoadingEnabled { get; }
    public IType[] ResultTypes { get; }
    public IType[] CacheTypes { get; }
    public QueryCacheInfo CacheInfo { get; }
    public ISessionFactoryImplementor Factory { get; }
    public SqlString SqlString { get; }
    public ILoadable[] EntityPersisters { get; }
    public string QueryIdentifier { get; }
    public abstract virtual Task`1<object> GetRowFromResultSetAsync(DbDataReader resultSet, ISessionImplementor session, QueryParameters queryParameters, LockMode[] lockModeArray, EntityKey optionalObjectKey, IList hydratedObjects, EntityKey[] keys, bool returnProxies, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken);
    public abstract virtual Task InitializeEntitiesAndCollectionsAsync(IList hydratedObjects, DbDataReader reader, ISessionImplementor session, bool readOnly, CacheBatcher cacheBatcher, CancellationToken cancellationToken);
    public abstract virtual Task LoadCollectionAsync(ISessionImplementor session, object id, IType type, CancellationToken cancellationToken);
    public abstract virtual Task LoadCollectionBatchAsync(ISessionImplementor session, Object[] ids, IType type, CancellationToken cancellationToken);
    public abstract virtual bool get_IsSubselectLoadingEnabled();
    public abstract virtual IType[] get_ResultTypes();
    public abstract virtual IType[] get_CacheTypes();
    public abstract virtual QueryCacheInfo get_CacheInfo();
    public abstract virtual ISessionFactoryImplementor get_Factory();
    public abstract virtual SqlString get_SqlString();
    public abstract virtual ILoadable[] get_EntityPersisters();
    public abstract virtual string get_QueryIdentifier();
    public abstract virtual LockMode[] GetLockModes(IDictionary`2<string, LockMode> lockModes);
    public abstract virtual object GetRowFromResultSet(DbDataReader resultSet, ISessionImplementor session, QueryParameters queryParameters, LockMode[] lockModeArray, EntityKey optionalObjectKey, IList hydratedObjects, EntityKey[] keys, bool returnProxies, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler);
    public abstract virtual void CreateSubselects(List`1<EntityKey[]> keys, QueryParameters queryParameters, ISessionImplementor session);
    public abstract virtual void InitializeEntitiesAndCollections(IList hydratedObjects, DbDataReader reader, ISessionImplementor session, bool readOnly, CacheBatcher cacheBatcher);
    public abstract virtual IList GetResultList(IList results, IResultTransformer resultTransformer);
    public abstract virtual bool UseLimit(RowSelection selection, Dialect dialect);
    public abstract virtual void LoadCollection(ISessionImplementor session, object id, IType type);
    public abstract virtual void LoadCollectionBatch(ISessionImplementor session, Object[] ids, IType type);
    public abstract virtual bool IsCacheable(QueryParameters queryParameters);
    public abstract virtual bool IsCacheable(QueryParameters queryParameters, bool supportsQueryCache, IEnumerable`1<IPersister> persisters);
    public abstract virtual string ToString();
    public abstract virtual ISqlCommand CreateSqlCommand(QueryParameters queryParameters, ISessionImplementor session);
    public abstract virtual void AutoDiscoverTypes(DbDataReader rs, QueryParameters queryParameters, IResultTransformer forcedResultTransformer);
    public abstract virtual IList TransformCacheableResults(QueryParameters queryParameters, CacheableResultTransformer transformer, IList result);
    public abstract virtual void HandleEmptyCollections(Object[] keys, object resultSetId, ISessionImplementor session);
    public abstract virtual void StopLoadingCollections(ISessionImplementor session, DbDataReader reader);
    public abstract virtual QueryKey GenerateQueryKey(ISessionImplementor session, QueryParameters queryParameters);
}
public class NHibernate.Loader.JoinWalker : object {
    private ISessionFactoryImplementor factory;
    protected IList`1<OuterJoinableAssociation> associations;
    private HashSet`1<AssociationKey> visitedAssociationKeys;
    private IDictionary`2<string, IFilter> enabledFilters;
    private IDictionary`2<string, IFilter> enabledFiltersForManyToOne;
    private static Regex aliasRegex;
    private String[] suffixes;
    private String[] collectionSuffixes;
    private ILoadable[] persisters;
    private Int32[] owners;
    private EntityType[] ownerAssociationTypes;
    private ICollectionPersister[] collectionPersisters;
    private Int32[] collectionOwners;
    private String[] aliases;
    private LockMode[] lockModeArray;
    private SqlString sql;
    private Queue`1<IJoinQueueEntry> _joinQueue;
    private int _depth;
    [CompilerGeneratedAttribute]
private Boolean[] <EagerPropertyFetches>k__BackingField;
    [CompilerGeneratedAttribute]
private Boolean[] <ChildFetchEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1[] <EntityFetchLazyProperties>k__BackingField;
    private static IReadOnlyCollection`1<string> DefaultChildAliases;
    public String[] CollectionSuffixes { get; public set; }
    public LockMode[] LockModeArray { get; public set; }
    public String[] Suffixes { get; public set; }
    public String[] Aliases { get; public set; }
    public Boolean[] EagerPropertyFetches { get; public set; }
    public Boolean[] ChildFetchEntities { get; public set; }
    public ISet`1[] EntityFetchLazyProperties { get; public set; }
    public Int32[] CollectionOwners { get; public set; }
    public ICollectionPersister[] CollectionPersisters { get; public set; }
    public EntityType[] OwnerAssociationTypes { get; public set; }
    public Int32[] Owners { get; public set; }
    public ILoadable[] Persisters { get; public set; }
    public SqlString SqlString { get; public set; }
    protected ISessionFactoryImplementor Factory { get; }
    protected Dialect Dialect { get; }
    protected IDictionary`2<string, IFilter> EnabledFilters { get; }
    protected bool IsTooManyCollections { get; }
    protected JoinWalker(ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    private static JoinWalker();
    public String[] get_CollectionSuffixes();
    public void set_CollectionSuffixes(String[] value);
    public LockMode[] get_LockModeArray();
    public void set_LockModeArray(LockMode[] value);
    public String[] get_Suffixes();
    public void set_Suffixes(String[] value);
    public String[] get_Aliases();
    public void set_Aliases(String[] value);
    [CompilerGeneratedAttribute]
public Boolean[] get_EagerPropertyFetches();
    [CompilerGeneratedAttribute]
public void set_EagerPropertyFetches(Boolean[] value);
    [CompilerGeneratedAttribute]
public Boolean[] get_ChildFetchEntities();
    [CompilerGeneratedAttribute]
public void set_ChildFetchEntities(Boolean[] value);
    [CompilerGeneratedAttribute]
public ISet`1[] get_EntityFetchLazyProperties();
    [CompilerGeneratedAttribute]
public void set_EntityFetchLazyProperties(ISet`1[] value);
    public Int32[] get_CollectionOwners();
    public void set_CollectionOwners(Int32[] value);
    public ICollectionPersister[] get_CollectionPersisters();
    public void set_CollectionPersisters(ICollectionPersister[] value);
    public EntityType[] get_OwnerAssociationTypes();
    public void set_OwnerAssociationTypes(EntityType[] value);
    public Int32[] get_Owners();
    public void set_Owners(Int32[] value);
    public ILoadable[] get_Persisters();
    public void set_Persisters(ILoadable[] value);
    public SqlString get_SqlString();
    public void set_SqlString(SqlString value);
    protected ISessionFactoryImplementor get_Factory();
    protected Dialect get_Dialect();
    protected IDictionary`2<string, IFilter> get_EnabledFilters();
    protected virtual bool get_IsTooManyCollections();
    private void AddAssociationToJoinTreeIfNecessary(IAssociationType type, String[] aliasedLhsColumns, string alias, string path, string pathAlias, JoinType joinType);
    [ObsoleteAttribute("Use or override the overload taking a pathAlias additional parameter")]
protected virtual SqlString GetWithClause(string path);
    protected virtual SqlString GetWithClause(string path, string pathAlias);
    private void AddAssociationToJoinTree(IAssociationType type, String[] aliasedLhsColumns, string alias, string path, string pathAlias, JoinType joinType);
    protected virtual SelectMode GetSelectMode(string path);
    protected virtual ISet`1<string> GetEntityFetchLazyProperties(string path);
    private static Int32[] GetTopologicalSortOrder(IList`1<DependentAlias2> fields);
    private static List`1<DependentAlias2> GetDependentAliases(IList`1<OuterJoinableAssociation> associations);
    private static HashSet`1<string> GetDependsOn(OuterJoinableAssociation association);
    private void AddAssociation(OuterJoinableAssociation association);
    protected void WalkEntityTree(IOuterJoinLoadable persister, string alias);
    protected void WalkCollectionTree(IQueryableCollection persister, string alias);
    protected void ProcessJoins();
    private void WalkCollectionTree(IQueryableCollection persister, string alias, string path, string pathAlias);
    internal void AddExplicitEntityJoinAssociation(IOuterJoinLoadable persister, string tableAlias, JoinType joinType, string path, string pathAlias);
    internal OuterJoinableAssociation InitAssociation(OuterJoinableAssociation association, string path);
    private void WalkEntityAssociationTree(IAssociationType associationType, IOuterJoinLoadable persister, int propertyNumber, string alias, string path, bool nullable, ILhsAssociationTypeSqlInfo associationTypeSQLInfo);
    protected virtual void WalkEntityTree(IOuterJoinLoadable persister, string alias, string path);
    [ObsoleteAttribute("Use or override the overload without the currentDepth parameter")]
protected virtual void WalkEntityTree(IOuterJoinLoadable persister, string alias, string path, int currentDepth);
    protected void WalkComponentTree(IAbstractComponentType componentType, int begin, string alias, string path, ILhsAssociationTypeSqlInfo associationTypeSQLInfo);
    [ObsoleteAttribute("Use or override the overload without the currentDepth parameter")]
protected void WalkComponentTree(IAbstractComponentType componentType, int begin, string alias, string path, int currentDepth, ILhsAssociationTypeSqlInfo associationTypeSQLInfo);
    private void WalkCompositeElementTree(IAbstractComponentType compositeType, String[] cols, IQueryableCollection persister, string alias, string path);
    protected static string SubPath(string path, string property);
    [ObsoleteAttribute("Use or override the overload taking a pathAlias additional parameter")]
protected virtual JoinType GetJoinType(IAssociationType type, FetchMode config, string path, string lhsTable, String[] lhsColumns, bool nullable, int currentDepth, CascadeStyle cascadeStyle);
    protected virtual JoinType GetJoinType(IAssociationType type, FetchMode config, string path, string pathAlias, string lhsTable, String[] lhsColumns, bool nullable, int currentDepth, CascadeStyle cascadeStyle);
    protected virtual IReadOnlyCollection`1<string> GetChildAliases(string parentSqlAlias, string childPath);
    protected JoinType GetJoinType(bool nullable, int currentDepth);
    protected virtual bool IsTooDeep(int currentDepth);
    protected bool IsJoinedFetchEnabledInMapping(FetchMode config, IAssociationType type);
    protected virtual bool IsJoinedFetchEnabled(IAssociationType type, FetchMode config, CascadeStyle cascadeStyle);
    [ObsoleteAttribute("Use or override the overload taking a pathAlias additional parameter")]
protected virtual string GenerateTableAlias(int n, string path, IJoinable joinable);
    protected virtual string GenerateTableAlias(int n, string path, string pathAlias, IJoinable joinable);
    protected virtual string GenerateRootAlias(string description);
    protected virtual bool IsDuplicateAssociation(string foreignKeyTable, String[] foreignKeyColumns);
    protected virtual bool IsDuplicateAssociation(string lhsTable, String[] lhsColumnNames, IAssociationType type);
    protected bool IsJoinable(JoinType joinType, ISet`1<AssociationKey> visitedAssociationKeys, string lhsTable, String[] lhsColumnNames, IAssociationType type, int depth);
    protected SqlString OrderBy(IList`1<OuterJoinableAssociation> associations, SqlString orderBy);
    protected SqlString OrderBy(IList`1<OuterJoinableAssociation> associations, string orderBy);
    protected SqlString MergeOrderings(SqlString ass, SqlString orderBy);
    protected SqlString MergeOrderings(string ass, SqlString orderBy);
    protected SqlString MergeOrderings(string ass, string orderBy);
    protected JoinFragment MergeOuterJoins(IList`1<OuterJoinableAssociation> associations);
    private static IList`1<OuterJoinableAssociation> GetSortedAssociations(IList`1<OuterJoinableAssociation> associations);
    protected static int CountEntityPersisters(IList`1<OuterJoinableAssociation> associations);
    protected static int CountCollectionPersisters(IList`1<OuterJoinableAssociation> associations);
    protected SqlString OrderBy(IList`1<OuterJoinableAssociation> associations);
    protected virtual string GenerateAliasForColumn(string rootAlias, string column);
    protected virtual SqlStringBuilder WhereString(string alias, String[] columnNames, int batchSize);
    private void ColumnFragment(SqlStringBuilder builder, string alias, String[] columnNames);
    protected void InitPersisters(IList`1<OuterJoinableAssociation> associations, LockMode lockMode);
    private void FillEntityPersisterProperties(int i, OuterJoinableAssociation oj, ILoadable persister);
    public string SelectString(IList`1<OuterJoinableAssociation> associations);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
protected static string GetSelectFragment(OuterJoinableAssociation join, string entitySuffix, string collectionSuffix, OuterJoinableAssociation next);
}
public abstract class NHibernate.Loader.Loader : object {
    private static INHibernateLogger Log;
    private Lazy`1<QueryCacheInfo> _cacheInfo;
    private ISessionFactoryImplementor _factory;
    private SessionFactoryHelper _helper;
    private ColumnNameCache _columnNameCache;
    private Nullable`1<bool> _canUseLimits;
    private ConcurrentDictionary`2<Tuple`2<int, string>, String[][]> _subclassEntityAliasesMap;
    [CompilerGeneratedAttribute]
private IType[] <ResultTypes>k__BackingField;
    protected SessionFactoryHelper Helper { get; }
    protected Boolean[] EntityEagerPropertyFetches { get; }
    protected ISet`1[] EntityFetchLazyProperties { get; }
    protected Int32[] Owners { get; }
    protected EntityType[] OwnerAssociationTypes { get; }
    protected Int32[] CollectionOwners { get; }
    protected bool IsSingleRowLoader { get; }
    public bool IsSubselectLoadingEnabled { get; }
    protected IEntityAliases[] EntityAliases { get; }
    protected ICollectionAliases[] CollectionAliases { get; }
    public IType[] ResultTypes { get; protected set; }
    public IType[] CacheTypes { get; }
    public QueryCacheInfo CacheInfo { get; }
    public ISessionFactoryImplementor Factory { get; }
    public SqlString SqlString { get; }
    public ILoadable[] EntityPersisters { get; }
    protected internal ICollectionPersister[] CollectionPersisters { get; }
    protected String[] Aliases { get; }
    protected String[] ResultRowAliases { get; }
    protected Boolean[] IncludeInResultRow { get; }
    public string QueryIdentifier { get; }
    protected Loader(ISessionFactoryImplementor factory);
    private static Loader();
    private Task`1<IList> DoQueryAndInitializeNonLazyCollectionsAsync(ISessionImplementor session, QueryParameters queryParameters, bool returnProxies, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<DoQueryAndInitializeNonLazyCollectionsAsync>d__1")]
private Task`1<IList> DoQueryAndInitializeNonLazyCollectionsAsync(ISessionImplementor session, QueryParameters queryParameters, bool returnProxies, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<LoadSingleRowAsync>d__2")]
[ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
protected Task`1<object> LoadSingleRowAsync(DbDataReader resultSet, ISessionImplementor session, QueryParameters queryParameters, bool returnProxies, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<GetRowFromResultSetAsync>d__3")]
public sealed virtual Task`1<object> GetRowFromResultSetAsync(DbDataReader resultSet, ISessionImplementor session, QueryParameters queryParameters, LockMode[] lockModeArray, EntityKey optionalObjectKey, IList hydratedObjects, EntityKey[] keys, bool returnProxies, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<ReadCollectionElementsAsync>d__4")]
private Task`1<IPersistentCollection[]> ReadCollectionElementsAsync(Object[] row, DbDataReader resultSet, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<DoQueryAsync>d__5")]
private Task`1<IList> DoQueryAsync(ISessionImplementor session, QueryParameters queryParameters, bool returnProxies, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<InitializeEntitiesAndCollectionsAsync>d__6")]
public sealed virtual Task InitializeEntitiesAndCollectionsAsync(IList hydratedObjects, DbDataReader reader, ISessionImplementor session, bool readOnly, CacheBatcher cacheBatcher, CancellationToken cancellationToken);
    private Task EndCollectionLoadAsync(DbDataReader reader, ISessionImplementor session, ICollectionPersister collectionPersister, CacheBatcher cacheBatcher, CancellationToken cancellationToken);
    protected virtual Task`1<object> GetResultColumnOrRowAsync(Object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    protected virtual Task`1<Object[]> GetResultRowAsync(Object[] row, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<ReadCollectionElementAsync>d__10")]
private static Task`1<IPersistentCollection> ReadCollectionElementAsync(object optionalOwner, object optionalKey, ICollectionPersister persister, ICollectionAliases descriptor, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<GetKeyFromResultSetAsync>d__11")]
private Task`1<EntityKey> GetKeyFromResultSetAsync(int i, IEntityPersister persister, object id, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<CheckVersionAsync>d__12")]
private Task CheckVersionAsync(int i, IEntityPersister persister, object id, object entity, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<GetRowAsync>d__13")]
private Task`1<Object[]> GetRowAsync(DbDataReader rs, ILoadable[] persisters, EntityKey[] keys, object optionalObject, EntityKey optionalObjectKey, LockMode[] lockModes, IList hydratedObjects, ISessionImplementor session, bool mustLoadMissingEntity, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<InstanceAlreadyLoadedAsync>d__14")]
private Task InstanceAlreadyLoadedAsync(DbDataReader rs, int i, ILoadable persister, EntityKey key, object obj, LockMode lockMode, ISessionImplementor session, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<InstanceNotYetLoadedAsync>d__15")]
private Task`1<object> InstanceNotYetLoadedAsync(DbDataReader dr, int i, ILoadable persister, EntityKey key, LockMode lockMode, EntityKey optionalObjectKey, object optionalObject, IList hydratedObjects, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<UpdateLazyPropertiesFromResultSetAsync>d__16")]
private Task UpdateLazyPropertiesFromResultSetAsync(DbDataReader rs, int i, object obj, EntityKey key, EntityEntry optionalEntry, ILoadable rootPersister, ISessionImplementor session, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<UpdateCacheForEntityAsync>d__17")]
internal static Task UpdateCacheForEntityAsync(object obj, object id, EntityEntry entry, IEntityPersister persister, ISessionImplementor session, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<LoadFromResultSetAsync>d__18")]
private Task LoadFromResultSetAsync(DbDataReader rs, int i, object obj, ILoadable persister, EntityKey key, LockMode lockMode, ILoadable rootPersister, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<GetConcretePersisterAsync>d__19")]
private Task`1<ILoadable> GetConcretePersisterAsync(DbDataReader rs, int i, ILoadable persister, object id, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<AdvanceAsync>d__20")]
internal static Task AdvanceAsync(DbDataReader rs, RowSelection selection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<PrepareQueryCommandAsync>d__21")]
protected internal virtual Task`1<DbCommand> PrepareQueryCommandAsync(QueryParameters queryParameters, bool scroll, ISessionImplementor session, CancellationToken cancellationToken);
    [ObsoleteAttribute("Please use overload with a QueryParameter parameter.")]
protected Task`1<DbDataReader> GetResultSetAsync(DbCommand st, bool autoDiscoverTypes, bool callable, RowSelection selection, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<GetResultSetAsync>d__23")]
protected Task`1<DbDataReader> GetResultSetAsync(DbCommand st, QueryParameters queryParameters, ISessionImplementor session, IResultTransformer forcedResultTransformer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<LoadEntityAsync>d__24")]
protected Task`1<IList> LoadEntityAsync(ISessionImplementor session, object id, IType identifierType, object optionalObject, string optionalEntityName, object optionalIdentifier, IEntityPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<LoadEntityAsync>d__25")]
protected Task`1<IList> LoadEntityAsync(ISessionImplementor session, object key, object index, IType keyType, IType indexType, IEntityPersister persister, CancellationToken cancellationToken);
    protected internal Task`1<IList> LoadEntityBatchAsync(ISessionImplementor session, Object[] ids, IType idType, object optionalObject, string optionalEntityName, object optionalId, IEntityPersister persister, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<LoadEntityBatchAsync>d__27")]
protected internal Task`1<IList> LoadEntityBatchAsync(ISessionImplementor session, IEntityPersister persister, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<LoadCollectionAsync>d__28")]
public sealed virtual Task LoadCollectionAsync(ISessionImplementor session, object id, IType type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<LoadCollectionBatchAsync>d__29")]
public sealed virtual Task LoadCollectionBatchAsync(ISessionImplementor session, Object[] ids, IType type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<LoadCollectionSubselectAsync>d__30")]
protected Task LoadCollectionSubselectAsync(ISessionImplementor session, Object[] ids, Object[] parameterValues, IType[] parameterTypes, IDictionary`2<string, TypedValue> namedParameters, IType type, CancellationToken cancellationToken);
    [ObsoleteAttribute("Please use overload without resultTypes")]
protected Task`1<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces, IType[] resultTypes, CancellationToken cancellationToken);
    protected Task`1<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<ListIgnoreQueryCacheAsync>d__33")]
private Task`1<IList> ListIgnoreQueryCacheAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<ListUsingQueryCacheAsync>d__34")]
private Task`1<IList> ListUsingQueryCacheAsync(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<GetResultFromQueryCacheAsync>d__35")]
private Task`1<IList> GetResultFromQueryCacheAsync(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces, IQueryCache queryCache, QueryKey key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<PutResultInQueryCacheAsync>d__36")]
private Task PutResultInQueryCacheAsync(ISessionImplementor session, QueryParameters queryParameters, IQueryCache queryCache, QueryKey key, IList result, CancellationToken cancellationToken);
    protected Task`1<IList> DoListAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use the overload with queryCacheResultBuilder parameter")]
protected Task`1<IList> DoListAsync(ISessionImplementor session, QueryParameters queryParameters, IResultTransformer forcedResultTransformer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Loader.Loader/<DoListAsync>d__39")]
protected Task`1<IList> DoListAsync(ISessionImplementor session, QueryParameters queryParameters, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder, CancellationToken cancellationToken);
    protected SessionFactoryHelper get_Helper();
    protected virtual Boolean[] get_EntityEagerPropertyFetches();
    protected virtual ISet`1[] get_EntityFetchLazyProperties();
    protected virtual Int32[] get_Owners();
    protected virtual EntityType[] get_OwnerAssociationTypes();
    protected virtual Int32[] get_CollectionOwners();
    protected virtual bool get_IsSingleRowLoader();
    public virtual bool get_IsSubselectLoadingEnabled();
    protected abstract virtual IEntityAliases[] get_EntityAliases();
    protected abstract virtual ICollectionAliases[] get_CollectionAliases();
    [CompilerGeneratedAttribute]
public sealed virtual IType[] get_ResultTypes();
    [CompilerGeneratedAttribute]
protected void set_ResultTypes(IType[] value);
    public sealed virtual IType[] get_CacheTypes();
    public virtual QueryCacheInfo get_CacheInfo();
    protected void CachePersistersWithCollections(IEnumerable`1<int> resultTypePersisters);
    public sealed virtual ISessionFactoryImplementor get_Factory();
    public abstract virtual SqlString get_SqlString();
    public abstract virtual ILoadable[] get_EntityPersisters();
    protected internal virtual ICollectionPersister[] get_CollectionPersisters();
    public abstract virtual LockMode[] GetLockModes(IDictionary`2<string, LockMode> lockModes);
    protected virtual SqlString ApplyLocks(SqlString sql, IDictionary`2<string, LockMode> lockModes, Dialect dialect);
    protected virtual bool UpgradeLocks();
    protected virtual String[] get_Aliases();
    protected virtual SqlString PreprocessSQL(SqlString sql, QueryParameters parameters, Dialect dialect);
    private static SqlString PrependComment(SqlString sql, QueryParameters parameters);
    private IList DoQueryAndInitializeNonLazyCollections(ISessionImplementor session, QueryParameters queryParameters, bool returnProxies);
    private IList DoQueryAndInitializeNonLazyCollections(ISessionImplementor session, QueryParameters queryParameters, bool returnProxies, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version")]
protected object LoadSingleRow(DbDataReader resultSet, ISessionImplementor session, QueryParameters queryParameters, bool returnProxies);
    internal static EntityKey GetOptionalObjectKey(QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual object GetRowFromResultSet(DbDataReader resultSet, ISessionImplementor session, QueryParameters queryParameters, LockMode[] lockModeArray, EntityKey optionalObjectKey, IList hydratedObjects, EntityKey[] keys, bool returnProxies, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler);
    private IPersistentCollection[] ReadCollectionElements(Object[] row, DbDataReader resultSet, ISessionImplementor session);
    private IList DoQuery(ISessionImplementor session, QueryParameters queryParameters, bool returnProxies, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder);
    protected bool HasSubselectLoadableCollections();
    private static ISet`1[] Transpose(List`1<EntityKey[]> keys);
    public sealed virtual void CreateSubselects(List`1<EntityKey[]> keys, QueryParameters queryParameters, ISessionImplementor session);
    [IteratorStateMachineAttribute("NHibernate.Loader.Loader/<CreateSubselects>d__103")]
private IEnumerable`1<SubselectFetch> CreateSubselects(List`1<EntityKey[]> keys, QueryParameters queryParameters);
    public sealed virtual void InitializeEntitiesAndCollections(IList hydratedObjects, DbDataReader reader, ISessionImplementor session, bool readOnly, CacheBatcher cacheBatcher);
    public sealed virtual void StopLoadingCollections(ISessionImplementor session, DbDataReader reader);
    private void EndCollectionLoad(DbDataReader reader, ISessionImplementor session, ICollectionPersister collectionPersister, CacheBatcher cacheBatcher);
    protected virtual bool IsCollectionPersisterCacheable(ICollectionPersister collectionPersister);
    protected virtual IResultTransformer ResolveResultTransformer(IResultTransformer resultTransformer);
    protected virtual bool AreResultSetRowsTransformedImmediately();
    public virtual IList GetResultList(IList results, IResultTransformer resultTransformer);
    protected virtual String[] get_ResultRowAliases();
    protected virtual object GetResultColumnOrRow(Object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session);
    protected virtual Boolean[] get_IncludeInResultRow();
    protected virtual Object[] GetResultRow(Object[] row, DbDataReader rs, ISessionImplementor session);
    private void RegisterNonExists(EntityKey[] keys, ISessionImplementor session);
    private static IPersistentCollection ReadCollectionElement(object optionalOwner, object optionalKey, ICollectionPersister persister, ICollectionAliases descriptor, DbDataReader rs, ISessionImplementor session);
    public sealed virtual void HandleEmptyCollections(Object[] keys, object resultSetId, ISessionImplementor session);
    private EntityKey GetKeyFromResultSet(int i, IEntityPersister persister, object id, DbDataReader rs, ISessionImplementor session);
    private void CheckVersion(int i, IEntityPersister persister, object id, object entity, DbDataReader rs, ISessionImplementor session);
    private Object[] GetRow(DbDataReader rs, ILoadable[] persisters, EntityKey[] keys, object optionalObject, EntityKey optionalObjectKey, LockMode[] lockModes, IList hydratedObjects, ISessionImplementor session, bool mustLoadMissingEntity, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler);
    private void InstanceAlreadyLoaded(DbDataReader rs, int i, ILoadable persister, EntityKey key, object obj, LockMode lockMode, ISessionImplementor session, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler);
    private void CacheByUniqueKey(int i, IEntityPersister persister, object obj, ISessionImplementor session, bool alreadyLoaded);
    private object InstanceNotYetLoaded(DbDataReader dr, int i, ILoadable persister, EntityKey key, LockMode lockMode, EntityKey optionalObjectKey, object optionalObject, IList hydratedObjects, ISessionImplementor session);
    protected virtual bool IsChildFetchEntity(int i);
    private bool IsEagerPropertyFetchEnabled(int i);
    private ISet`1<string> GetFetchLazyProperties(int i);
    private void UpdateLazyPropertiesFromResultSet(DbDataReader rs, int i, object obj, EntityKey key, EntityEntry optionalEntry, ILoadable rootPersister, ISessionImplementor session, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler);
    internal static void UpdateCacheForEntity(object obj, object id, EntityEntry entry, IEntityPersister persister, ISessionImplementor session, Action`2<IEntityPersister, CachePutData> cacheBatchingHandler);
    private void LoadFromResultSet(DbDataReader rs, int i, object obj, ILoadable persister, EntityKey key, LockMode lockMode, ILoadable rootPersister, ISessionImplementor session);
    private String[][] GetSubclassEntityAliases(int i, ILoadable persister);
    private ILoadable GetConcretePersister(DbDataReader rs, int i, ILoadable persister, object id, ISessionImplementor session);
    internal static void Advance(DbDataReader rs, RowSelection selection);
    internal static bool HasMaxRows(RowSelection selection);
    private static bool HasOffset(RowSelection selection);
    internal static int GetFirstRow(RowSelection selection);
    public sealed virtual bool UseLimit(RowSelection selection, Dialect dialect);
    internal static Nullable`1<int> GetOffsetUsingDialect(RowSelection selection, Dialect dialect);
    internal static Nullable`1<int> GetLimitUsingDialect(RowSelection selection, Dialect dialect);
    protected internal virtual DbCommand PrepareQueryCommand(QueryParameters queryParameters, bool scroll, ISessionImplementor session);
    internal static int GetMaxOrLimit(Dialect dialect, RowSelection selection);
    [ObsoleteAttribute("Please use overload with a QueryParameter parameter.")]
protected DbDataReader GetResultSet(DbCommand st, bool autoDiscoverTypes, bool callable, RowSelection selection, ISessionImplementor session);
    protected DbDataReader GetResultSet(DbCommand st, QueryParameters queryParameters, ISessionImplementor session, IResultTransformer forcedResultTransformer);
    [ObsoleteAttribute("Please use overload with a QueryParameters parameter.")]
protected internal virtual void AutoDiscoverTypes(DbDataReader rs);
    public virtual void AutoDiscoverTypes(DbDataReader rs, QueryParameters queryParameters, IResultTransformer forcedResultTransformer);
    private DbDataReader WrapResultSet(DbDataReader rs);
    private ColumnNameCache RetreiveColumnNameToIndexCache(DbDataReader rs);
    protected IList LoadEntity(ISessionImplementor session, object id, IType identifierType, object optionalObject, string optionalEntityName, object optionalIdentifier, IEntityPersister persister);
    protected IList LoadEntity(ISessionImplementor session, object key, object index, IType keyType, IType indexType, IEntityPersister persister);
    protected internal IList LoadEntityBatch(ISessionImplementor session, Object[] ids, IType idType, object optionalObject, string optionalEntityName, object optionalId, IEntityPersister persister);
    protected internal IList LoadEntityBatch(ISessionImplementor session, IEntityPersister persister, QueryParameters queryParameters);
    public sealed virtual void LoadCollection(ISessionImplementor session, object id, IType type);
    public sealed virtual void LoadCollectionBatch(ISessionImplementor session, Object[] ids, IType type);
    protected void LoadCollectionSubselect(ISessionImplementor session, Object[] ids, Object[] parameterValues, IType[] parameterTypes, IDictionary`2<string, TypedValue> namedParameters, IType type);
    [ObsoleteAttribute("Please use overload without resultTypes")]
protected IList List(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces, IType[] resultTypes);
    protected IList List(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces);
    public virtual bool IsCacheable(QueryParameters queryParameters);
    public sealed virtual bool IsCacheable(QueryParameters queryParameters, bool supportsQueryCache, IEnumerable`1<IPersister> persisters);
    private IList ListIgnoreQueryCache(ISessionImplementor session, QueryParameters queryParameters);
    private IList ListUsingQueryCache(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces);
    public sealed virtual IList TransformCacheableResults(QueryParameters queryParameters, CacheableResultTransformer transformer, IList result);
    public sealed virtual QueryKey GenerateQueryKey(ISessionImplementor session, QueryParameters queryParameters);
    private CacheableResultTransformer CreateCacheableResultTransformer(QueryParameters queryParameters);
    private IList GetResultFromQueryCache(ISessionImplementor session, QueryParameters queryParameters, ISet`1<string> querySpaces, IQueryCache queryCache, QueryKey key);
    private void PutResultInQueryCache(ISessionImplementor session, QueryParameters queryParameters, IQueryCache queryCache, QueryKey key, IList result);
    protected IList DoList(ISessionImplementor session, QueryParameters queryParameters);
    [ObsoleteAttribute("Use the overload with queryCacheResultBuilder parameter")]
protected IList DoList(ISessionImplementor session, QueryParameters queryParameters, IResultTransformer forcedResultTransformer);
    protected IList DoList(ISessionImplementor session, QueryParameters queryParameters, IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder);
    protected virtual void PostInstantiate();
    public virtual string get_QueryIdentifier();
    public virtual string ToString();
    public virtual ISqlCommand CreateSqlCommand(QueryParameters queryParameters, ISessionImplementor session);
    private protected virtual SqlString TransformSql(SqlString sqlString, QueryParameters queryParameters, HashSet`1<IParameterSpecification> parameterSpecifications);
    protected virtual void ResetEffectiveExpectedType(IEnumerable`1<IParameterSpecification> parameterSpecs, QueryParameters queryParameters);
    protected abstract virtual IEnumerable`1<IParameterSpecification> GetParameterSpecifications();
    protected void AdjustQueryParametersForSubSelectFetching(SqlString filteredSqlString, IEnumerable`1<IParameterSpecification> parameterSpecsWithFilters, QueryParameters queryParameters);
    protected SqlString ExpandDynamicFilterParameters(SqlString sqlString, ICollection`1<IParameterSpecification> parameterSpecs, ISessionImplementor session);
    protected SqlString AddLimitsParametersIfNeeded(SqlString sqlString, ICollection`1<IParameterSpecification> parameterSpecs, QueryParameters queryParameters, ISessionImplementor session);
    protected bool TryGetLimitString(Dialect dialect, SqlString queryString, Nullable`1<int> offset, Nullable`1<int> limit, Parameter offsetParameter, Parameter limitParameter, SqlString& result);
    private QueryCacheInfo GetQueryCacheInfo(IEnumerable`1<int> resultTypePersisters);
    [CompilerGeneratedAttribute]
private EntityType <GetQueryCacheInfo>b__182_0(int i);
}
public class NHibernate.Loader.OuterJoinableAssociation : object {
    private IAssociationType joinableType;
    private IJoinable joinable;
    private string lhsAlias;
    private String[] lhsColumns;
    private string rhsAlias;
    private String[] rhsColumns;
    private JoinType joinType;
    private SqlString on;
    private IDictionary`2<string, IFilter> enabledFilters;
    private SelectMode _selectMode;
    [CompilerGeneratedAttribute]
private ISet`1<string> <EntityFetchLazyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFilter>k__BackingField;
    public JoinType JoinType { get; }
    public string RHSAlias { get; }
    public SqlString On { get; }
    private bool IsEntityType { get; }
    public IAssociationType JoinableType { get; }
    public string RHSUniqueKeyName { get; }
    public bool IsCollection { get; }
    public IJoinable Joinable { get; }
    public SelectMode SelectMode { get; }
    public ISet`1<string> EntityFetchLazyProperties { get; public set; }
    internal bool ForceFilter { get; internal set; }
    private String[] NHibernate.Engine.IJoin.LHSColumns { get; }
    private string NHibernate.Engine.IJoin.Alias { get; }
    private IAssociationType NHibernate.Engine.IJoin.AssociationType { get; }
    private String[] NHibernate.Engine.IJoin.RHSColumns { get; }
    public OuterJoinableAssociation(IAssociationType joinableType, string lhsAlias, String[] lhsColumns, string rhsAlias, JoinType joinType, SqlString withClause, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters, SelectMode selectMode);
    public OuterJoinableAssociation(IAssociationType joinableType, string lhsAlias, String[] lhsColumns, string rhsAlias, JoinType joinType, SqlString withClause, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public sealed virtual JoinType get_JoinType();
    public string get_RHSAlias();
    public SqlString get_On();
    private bool get_IsEntityType();
    public IAssociationType get_JoinableType();
    public string get_RHSUniqueKeyName();
    public bool get_IsCollection();
    public sealed virtual IJoinable get_Joinable();
    public SelectMode get_SelectMode();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_EntityFetchLazyProperties();
    [CompilerGeneratedAttribute]
public void set_EntityFetchLazyProperties(ISet`1<string> value);
    [CompilerGeneratedAttribute]
internal bool get_ForceFilter();
    [CompilerGeneratedAttribute]
internal void set_ForceFilter(bool value);
    private sealed virtual override String[] NHibernate.Engine.IJoin.get_LHSColumns();
    private sealed virtual override string NHibernate.Engine.IJoin.get_Alias();
    private sealed virtual override IAssociationType NHibernate.Engine.IJoin.get_AssociationType();
    private sealed virtual override String[] NHibernate.Engine.IJoin.get_RHSColumns();
    public int GetOwner(IList`1<OuterJoinableAssociation> associations);
    private static int GetPosition(string lhsAlias, IEnumerable`1<OuterJoinableAssociation> associations);
    public void AddJoins(JoinFragment outerjoin);
    public void ValidateJoin(string path);
    public bool IsManyToManyWith(OuterJoinableAssociation other);
    [ObsoleteAttribute("This method is not used anymore and will be removed in a next major version")]
public void AddManyToManyJoin(JoinFragment outerjoin, IQueryableCollection collection);
    internal bool ShouldFetchCollectionPersister();
    internal string GetSelectFragment(string entitySuffix, string collectionSuffix);
}
public abstract class NHibernate.Loader.OuterJoinLoader : BasicLoader {
    private ILoadable[] persisters;
    private ICollectionPersister[] collectionPersisters;
    private Int32[] collectionOwners;
    private String[] aliases;
    private LockMode[] lockModeArray;
    private Int32[] owners;
    private EntityType[] ownerAssociationTypes;
    private SqlString sql;
    private String[] suffixes;
    private String[] collectionSuffixes;
    private Boolean[] entityEagerPropertyFetches;
    private IDictionary`2<string, IFilter> enabledFilters;
    protected Dialect Dialect { get; }
    protected Int32[] Owners { get; }
    protected EntityType[] OwnerAssociationTypes { get; }
    public IDictionary`2<string, IFilter> EnabledFilters { get; }
    protected Int32[] CollectionOwners { get; }
    protected String[] Suffixes { get; }
    protected String[] CollectionSuffixes { get; }
    public SqlString SqlString { get; }
    public ILoadable[] EntityPersisters { get; }
    protected String[] Aliases { get; }
    protected internal ICollectionPersister[] CollectionPersisters { get; }
    protected Boolean[] EntityEagerPropertyFetches { get; }
    protected OuterJoinLoader(ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    protected Dialect get_Dialect();
    protected virtual Int32[] get_Owners();
    protected virtual EntityType[] get_OwnerAssociationTypes();
    public IDictionary`2<string, IFilter> get_EnabledFilters();
    protected virtual Int32[] get_CollectionOwners();
    protected virtual String[] get_Suffixes();
    protected virtual String[] get_CollectionSuffixes();
    public virtual SqlString get_SqlString();
    public virtual ILoadable[] get_EntityPersisters();
    public virtual LockMode[] GetLockModes(IDictionary`2<string, LockMode> lockModes);
    protected virtual String[] get_Aliases();
    protected internal virtual ICollectionPersister[] get_CollectionPersisters();
    protected virtual Boolean[] get_EntityEagerPropertyFetches();
    protected void InitFromWalker(JoinWalker walker);
}
internal class NHibernate.Loader.TopologicalSorter : object {
    private Int32[] _vertices;
    private Int32[0...,0...] _matrix;
    private int _numVerts;
    private Int32[] _sortedArray;
    public TopologicalSorter(int size);
    public int AddVertex(int vertex);
    public void AddEdge(int start, int end);
    public Int32[] Sort();
    private int noSuccessors();
    private void deleteVertex(int delVert);
    private void moveRowUp(int row, int length);
    private void moveColLeft(int col, int length);
}
public class NHibernate.LockMode : object {
    private int level;
    private string name;
    public static LockMode None;
    public static LockMode Read;
    public static LockMode Upgrade;
    public static LockMode UpgradeNoWait;
    public static LockMode Write;
    public static LockMode Force;
    private LockMode(int level, string name);
    private static LockMode();
    public virtual string ToString();
    public bool GreaterThan(LockMode mode);
    public bool LessThan(LockMode mode);
    public virtual bool Equals(object obj);
    public bool Equals(LockMode other);
    public virtual int GetHashCode();
}
public class NHibernate.Log4NetLogger : object {
    private static Func`2<object, bool> IsErrorEnabledDelegate;
    private static Func`2<object, bool> IsFatalEnabledDelegate;
    private static Func`2<object, bool> IsDebugEnabledDelegate;
    private static Func`2<object, bool> IsInfoEnabledDelegate;
    private static Func`2<object, bool> IsWarnEnabledDelegate;
    private static Action`2<object, object> ErrorDelegate;
    private static Action`3<object, object, Exception> ErrorExceptionDelegate;
    private static Action`3<object, string, Object[]> ErrorFormatDelegate;
    private static Action`2<object, object> FatalDelegate;
    private static Action`3<object, object, Exception> FatalExceptionDelegate;
    private static Action`2<object, object> DebugDelegate;
    private static Action`3<object, object, Exception> DebugExceptionDelegate;
    private static Action`3<object, string, Object[]> DebugFormatDelegate;
    private static Action`2<object, object> InfoDelegate;
    private static Action`3<object, object, Exception> InfoExceptionDelegate;
    private static Action`3<object, string, Object[]> InfoFormatDelegate;
    private static Action`2<object, object> WarnDelegate;
    private static Action`3<object, object, Exception> WarnExceptionDelegate;
    private static Action`3<object, string, Object[]> WarnFormatDelegate;
    private object _logger;
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    private static Log4NetLogger();
    public Log4NetLogger(object logger);
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
}
public class NHibernate.Log4NetLoggerFactory : object {
    internal static Assembly Log4NetAssembly;
    private static Type LogManagerType;
    private static Func`3<Assembly, string, object> GetLoggerByNameDelegate;
    private static Func`2<Type, object> GetLoggerByTypeDelegate;
    private static Log4NetLoggerFactory();
    private static Type GetLogManagerType();
    [ObsoleteAttribute("Use this as an INHibernateLoggerFactory instead.")]
public sealed virtual IInternalLogger LoggerFor(string keyName);
    [ObsoleteAttribute("Use this as an INHibernateLoggerFactory instead.")]
public sealed virtual IInternalLogger LoggerFor(Type type);
    private static Func`2<TParameter, object> GetGetLoggerMethodCall();
    private static Func`3<Assembly, string, object> GetGetLoggerByNameMethodCall();
}
[ObsoleteAttribute("Use NHibernateLogger instead.")]
public class NHibernate.LoggerProvider : object {
    [ObsoleteAttribute("Implement INHibernateLoggerFactory and use NHibernateLogger.SetLoggersFactory() instead")]
public static void SetLoggersFactory(ILoggerFactory loggerFactory);
    [ObsoleteAttribute("Use NHibernateLogger.For() instead.")]
public static IInternalLogger LoggerFor(string keyName);
    [ObsoleteAttribute("Use NHibernateLogger.For() instead.")]
public static IInternalLogger LoggerFor(Type type);
}
public abstract class NHibernate.Mapping.AbstractAuxiliaryDatabaseObject : object {
    private HashSet`1<string> dialectScopes;
    private IDictionary`2<string, string> parameters;
    public HashSet`1<string> DialectScopes { get; }
    public IDictionary`2<string, string> Parameters { get; }
    protected AbstractAuxiliaryDatabaseObject(HashSet`1<string> dialectScopes);
    public sealed virtual void AddDialectScope(string dialectName);
    public HashSet`1<string> get_DialectScopes();
    public IDictionary`2<string, string> get_Parameters();
    public sealed virtual bool AppliesToDialect(Dialect dialect);
    public abstract virtual string SqlCreateString(Dialect dialect, IMapping p, string defaultCatalog, string defaultSchema);
    public abstract virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
    public sealed virtual void SetParameterValues(IDictionary`2<string, string> parameters);
}
public class NHibernate.Mapping.Any : SimpleValue {
    private string identifierTypeName;
    private string metaTypeName;
    private IDictionary`2<object, string> metaValues;
    private Lazy`1<IType> _type;
    public string IdentifierTypeName { get; public set; }
    public IType Type { get; }
    public string MetaType { get; public set; }
    public IDictionary`2<object, string> MetaValues { get; public set; }
    public Any(Table table);
    public virtual string get_IdentifierTypeName();
    public virtual void set_IdentifierTypeName(string value);
    private Lazy`1<IType> GetLazyType();
    public virtual IType get_Type();
    public void ResetCachedType();
    public virtual void SetTypeUsingReflection(string className, string propertyName, string access);
    public virtual string get_MetaType();
    public virtual void set_MetaType(string value);
    public IDictionary`2<object, string> get_MetaValues();
    public void set_MetaValues(IDictionary`2<object, string> value);
    [CompilerGeneratedAttribute]
private IType <GetLazyType>b__7_0();
}
public class NHibernate.Mapping.Array : List {
    private Type elementClass;
    private string elementClassName;
    public Type ElementClass { get; }
    public CollectionType DefaultCollectionType { get; }
    public bool IsArray { get; }
    public string ElementClassName { get; public set; }
    public Array(PersistentClass owner);
    public Type get_ElementClass();
    public virtual CollectionType get_DefaultCollectionType();
    public virtual bool get_IsArray();
    public string get_ElementClassName();
    public void set_ElementClassName(string value);
}
public class NHibernate.Mapping.Backref : Property {
    private string collectionRole;
    private string entityName;
    public string CollectionRole { get; public set; }
    public string EntityName { get; public set; }
    public bool BackRef { get; }
    public bool IsBasicPropertyAccessor { get; }
    protected IPropertyAccessor PropertyAccessor { get; }
    public string get_CollectionRole();
    public void set_CollectionRole(string value);
    public string get_EntityName();
    public void set_EntityName(string value);
    public virtual bool get_BackRef();
    public virtual bool get_IsBasicPropertyAccessor();
    protected virtual IPropertyAccessor get_PropertyAccessor();
}
public class NHibernate.Mapping.Bag : Collection {
    public CollectionType DefaultCollectionType { get; }
    public Bag(PersistentClass owner);
    public virtual CollectionType get_DefaultCollectionType();
    public virtual void CreatePrimaryKey();
}
public abstract class NHibernate.Mapping.ByCode.AbstractExplicitlyDeclaredModel : object {
    private HashSet`1<MemberInfo> any;
    private HashSet`1<MemberInfo> arrays;
    private HashSet`1<MemberInfo> bags;
    private HashSet`1<Type> components;
    private HashSet`1<MemberInfo> dictionaries;
    private HashSet`1<MemberInfo> idBags;
    private HashSet`1<MemberInfo> lists;
    private HashSet`1<MemberInfo> keyManyToManyRelations;
    private HashSet`1<MemberInfo> itemManyToManyRelations;
    private HashSet`1<MemberInfo> manyToAnyRelations;
    private HashSet`1<MemberInfo> manyToOneRelations;
    private HashSet`1<MemberInfo> naturalIds;
    private HashSet`1<MemberInfo> composedIds;
    private HashSet`1<MemberInfo> oneToManyRelations;
    private HashSet`1<MemberInfo> oneToOneRelations;
    private HashSet`1<MemberInfo> poids;
    private HashSet`1<MemberInfo> properties;
    private HashSet`1<MemberInfo> dynamicComponents;
    private Dictionary`2<MemberInfo, Type> dynamicComponentTemplates;
    private HashSet`1<MemberInfo> persistentMembers;
    private HashSet`1<Type> rootEntities;
    private HashSet`1<MemberInfo> sets;
    private HashSet`1<Type> tablePerClassEntities;
    private HashSet`1<Type> tablePerClassHierarchyEntities;
    private HashSet`1<Type> tablePerConcreteClassEntities;
    private HashSet`1<MemberInfo> versionProperties;
    private Dictionary`2<Type, HashSet`1<string>> typeSplitGroups;
    private Dictionary`2<MemberInfo, string> memberSplitGroup;
    private HashSet`1<SplitDefinition> splitDefinitions;
    private Queue`1<Action> delayedRootEntityRegistrations;
    private Dictionary`2<Type, List`1<Action`1<Type>>> delayedEntityRegistrations;
    public IEnumerable`1<Type> RootEntities { get; }
    public IEnumerable`1<Type> Components { get; }
    public IEnumerable`1<Type> TablePerClassEntities { get; }
    public IEnumerable`1<Type> TablePerClassHierarchyEntities { get; }
    public IEnumerable`1<Type> TablePerConcreteClassEntities { get; }
    public IEnumerable`1<MemberInfo> OneToOneRelations { get; }
    public IEnumerable`1<MemberInfo> ManyToOneRelations { get; }
    public IEnumerable`1<MemberInfo> KeyManyToManyRelations { get; }
    public IEnumerable`1<MemberInfo> ItemManyToManyRelations { get; }
    public IEnumerable`1<MemberInfo> OneToManyRelations { get; }
    public IEnumerable`1<MemberInfo> ManyToAnyRelations { get; }
    public IEnumerable`1<MemberInfo> Any { get; }
    public IEnumerable`1<MemberInfo> Poids { get; }
    public IEnumerable`1<MemberInfo> ComposedIds { get; }
    public IEnumerable`1<MemberInfo> VersionProperties { get; }
    public IEnumerable`1<MemberInfo> NaturalIds { get; }
    public IEnumerable`1<MemberInfo> Sets { get; }
    public IEnumerable`1<MemberInfo> Bags { get; }
    public IEnumerable`1<MemberInfo> IdBags { get; }
    public IEnumerable`1<MemberInfo> Lists { get; }
    public IEnumerable`1<MemberInfo> Arrays { get; }
    public IEnumerable`1<MemberInfo> Dictionaries { get; }
    public IEnumerable`1<MemberInfo> Properties { get; }
    public IEnumerable`1<MemberInfo> DynamicComponents { get; }
    public IEnumerable`1<MemberInfo> PersistentMembers { get; }
    public IEnumerable`1<SplitDefinition> SplitDefinitions { get; }
    public sealed virtual IEnumerable`1<Type> get_RootEntities();
    public sealed virtual IEnumerable`1<Type> get_Components();
    public sealed virtual IEnumerable`1<Type> get_TablePerClassEntities();
    public sealed virtual IEnumerable`1<Type> get_TablePerClassHierarchyEntities();
    public sealed virtual IEnumerable`1<Type> get_TablePerConcreteClassEntities();
    public sealed virtual IEnumerable`1<MemberInfo> get_OneToOneRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ManyToOneRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_KeyManyToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ItemManyToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_OneToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ManyToAnyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_Any();
    public sealed virtual IEnumerable`1<MemberInfo> get_Poids();
    public sealed virtual IEnumerable`1<MemberInfo> get_ComposedIds();
    public sealed virtual IEnumerable`1<MemberInfo> get_VersionProperties();
    public sealed virtual IEnumerable`1<MemberInfo> get_NaturalIds();
    public sealed virtual IEnumerable`1<MemberInfo> get_Sets();
    public sealed virtual IEnumerable`1<MemberInfo> get_Bags();
    public sealed virtual IEnumerable`1<MemberInfo> get_IdBags();
    public sealed virtual IEnumerable`1<MemberInfo> get_Lists();
    public sealed virtual IEnumerable`1<MemberInfo> get_Arrays();
    public sealed virtual IEnumerable`1<MemberInfo> get_Dictionaries();
    public sealed virtual IEnumerable`1<MemberInfo> get_Properties();
    public sealed virtual IEnumerable`1<MemberInfo> get_DynamicComponents();
    public sealed virtual IEnumerable`1<MemberInfo> get_PersistentMembers();
    public sealed virtual IEnumerable`1<SplitDefinition> get_SplitDefinitions();
    public sealed virtual IEnumerable`1<string> GetSplitGroupsFor(Type type);
    public sealed virtual string GetSplitGroupFor(MemberInfo member);
    public sealed virtual void AddAsRootEntity(Type type);
    public abstract virtual bool IsComponent(Type type);
    public sealed virtual void AddAsComponent(Type type);
    public sealed virtual void AddAsTablePerClassEntity(Type type);
    protected virtual void AddAsTablePerClassEntity(Type type, bool rootEntityMustExists);
    public sealed virtual void AddAsTablePerClassHierarchyEntity(Type type);
    protected virtual void AddAsTablePerClassHierarchyEntity(Type type, bool rootEntityMustExists);
    public sealed virtual void AddAsTablePerConcreteClassEntity(Type type);
    protected virtual void AddAsTablePerConcreteClassEntity(Type type, bool rootEntityMustExists);
    public sealed virtual void AddAsOneToOneRelation(MemberInfo member);
    public sealed virtual void AddAsManyToOneRelation(MemberInfo member);
    public sealed virtual void AddAsManyToManyKeyRelation(MemberInfo member);
    public sealed virtual void AddAsManyToManyItemRelation(MemberInfo member);
    public sealed virtual void AddAsOneToManyRelation(MemberInfo member);
    public sealed virtual void AddAsManyToAnyRelation(MemberInfo member);
    public sealed virtual void AddAsAny(MemberInfo member);
    public sealed virtual void AddAsPoid(MemberInfo member);
    public sealed virtual void AddAsPartOfComposedId(MemberInfo member);
    public sealed virtual void AddAsVersionProperty(MemberInfo member);
    public sealed virtual void AddAsNaturalId(MemberInfo member);
    public sealed virtual void AddAsSet(MemberInfo member);
    public sealed virtual void AddAsBag(MemberInfo member);
    public sealed virtual void AddAsIdBag(MemberInfo member);
    public sealed virtual void AddAsList(MemberInfo member);
    public sealed virtual void AddAsArray(MemberInfo member);
    public sealed virtual void AddAsMap(MemberInfo member);
    public sealed virtual void AddAsProperty(MemberInfo member);
    public sealed virtual void AddAsPersistentMember(MemberInfo member);
    public sealed virtual void AddAsPropertySplit(SplitDefinition definition);
    public sealed virtual void AddAsDynamicComponent(MemberInfo member, Type componentTemplate);
    private void AddTypeSplits(Type propertyContainer, string splitGroupId);
    public virtual Type GetDynamicComponentTemplate(MemberInfo member);
    protected Type GetSingleRootEntityOrNull(Type entityType);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.AbstractExplicitlyDeclaredModel/<GetRootEntitiesOf>d__118")]
protected IEnumerable`1<Type> GetRootEntitiesOf(Type entityType);
    public abstract virtual bool IsRootEntity(Type entityType);
    protected bool IsMappedForTablePerClassEntities(Type type);
    protected bool IsMappedForTablePerClassHierarchyEntities(Type type);
    protected bool IsMappedForTablePerConcreteClassEntities(Type type);
    private bool IsMappedFor(ICollection`1<Type> explicitMappedEntities, Type type);
    protected void EnlistTypeRegistration(Type type, Action`1<Type> registration);
    protected void ExecuteDelayedTypeRegistration(Type type);
    protected void ExecuteDelayedRootEntitiesRegistrations();
    protected bool HasDelayedEntityRegistration(Type type);
}
public enum NHibernate.Mapping.ByCode.Accessor : Enum {
    public int value__;
    public static Accessor Property;
    public static Accessor Field;
    public static Accessor NoSetter;
    public static Accessor ReadOnly;
    public static Accessor None;
    public static Accessor Backfield;
}
public class NHibernate.Mapping.ByCode.AssignedGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.BasePlainPropertyContainerMapperExtensions : object {
    [ExtensionAttribute]
public static void Component(IBasePlainPropertyContainerMapper`1<TContainer> mapper, Expression`1<Func`2<TContainer, IDictionary`2<string, object>>> property, TComponent dynamicComponentTemplate, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
}
public abstract class NHibernate.Mapping.ByCode.CacheInclude : object {
    public static CacheInclude All;
    public static CacheInclude NonLazy;
    private static CacheInclude();
    internal abstract virtual HbmCacheInclude ToHbm();
}
public abstract class NHibernate.Mapping.ByCode.CacheUsage : object {
    public static CacheUsage ReadOnly;
    public static CacheUsage ReadWrite;
    public static CacheUsage NonstrictReadWrite;
    public static CacheUsage Transactional;
    public static CacheUsage Never;
    private static CacheUsage();
    internal abstract virtual HbmCacheUsage ToHbm();
}
[FlagsAttribute]
public enum NHibernate.Mapping.ByCode.Cascade : Enum {
    public int value__;
    public static Cascade None;
    public static Cascade Persist;
    public static Cascade Refresh;
    public static Cascade Merge;
    public static Cascade Remove;
    public static Cascade Detach;
    public static Cascade ReAttach;
    public static Cascade DeleteOrphans;
    public static Cascade All;
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.CascadeExtensions : object {
    private static Cascade AnyButOrphans;
    [ExtensionAttribute]
public static bool Has(Cascade source, Cascade value);
    [ExtensionAttribute]
public static Cascade Include(Cascade source, Cascade value);
    private static Cascade Cleanup(Cascade cascade);
    [ExtensionAttribute]
public static Cascade Exclude(Cascade source, Cascade value);
}
public abstract class NHibernate.Mapping.ByCode.CollectionFetchMode : object {
    public static CollectionFetchMode Select;
    public static CollectionFetchMode Join;
    public static CollectionFetchMode Subselect;
    private static CollectionFetchMode();
    internal abstract virtual HbmCollectionFetchMode ToHbm();
}
public enum NHibernate.Mapping.ByCode.CollectionLazy : Enum {
    public int value__;
    public static CollectionLazy Lazy;
    public static CollectionLazy NoLazy;
    public static CollectionLazy Extra;
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.CollectionPropertiesMapperExtensions : object {
    [ExtensionAttribute]
public static void Type(ICollectionPropertiesMapper`2<TEntity, TElement> mapper, string collectionType);
    [ExtensionAttribute]
public static void Type(ICollectionPropertiesMapper mapper, string collectionType);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.CollectionSqlsWithCheckMapperExtensions : object {
    [ExtensionAttribute]
public static void SqlInsert(ICollectionSqlsMapper mapper, string sql, SqlCheck sqlCheck);
    [ExtensionAttribute]
public static void SqlUpdate(ICollectionSqlsMapper mapper, string sql, SqlCheck sqlCheck);
    [ExtensionAttribute]
public static void SqlDelete(ICollectionSqlsMapper mapper, string sql, SqlCheck sqlCheck);
    [ExtensionAttribute]
public static void SqlDeleteAll(ICollectionSqlsMapper mapper, string sql, SqlCheck sqlCheck);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.ColumnsAndFormulasMapperExtensions : object {
    [ExtensionAttribute]
public static void ColumnsAndFormulas(IElementMapper mapper, Action`1[] columnOrFormulaMapper);
    [ExtensionAttribute]
public static void ColumnsAndFormulas(IManyToManyMapper mapper, Action`1[] columnOrFormulaMapper);
    [ExtensionAttribute]
public static void ColumnsAndFormulas(IManyToOneMapper mapper, Action`1[] columnOrFormulaMapper);
    [ExtensionAttribute]
public static void ColumnsAndFormulas(IMapKeyManyToManyMapper mapper, Action`1[] columnOrFormulaMapper);
    [ExtensionAttribute]
public static void ColumnsAndFormulas(IMapKeyMapper mapper, Action`1[] columnOrFormulaMapper);
    [ExtensionAttribute]
public static void ColumnsAndFormulas(IPropertyMapper mapper, Action`1[] columnOrFormulaMapper);
    private static void CallColumnsAndFormulas(object mapper, Action`1[] columnOrFormulaMapper);
    [ExtensionAttribute]
public static void Formulas(IElementMapper mapper, String[] formulas);
    [ExtensionAttribute]
public static void Formulas(IManyToManyMapper mapper, String[] formulas);
    [ExtensionAttribute]
public static void Formulas(IManyToOneMapper mapper, String[] formulas);
    [ExtensionAttribute]
public static void Formulas(IMapKeyManyToManyMapper mapper, String[] formulas);
    [ExtensionAttribute]
public static void Formulas(IMapKeyMapper mapper, String[] formulas);
    [ExtensionAttribute]
public static void Formulas(IPropertyMapper mapper, String[] formulas);
    private static void CallFormulas(object mapper, String[] formulas);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.ComponentAttributesMapperExtensions : object {
    [ExtensionAttribute]
public static void LazyGroup(IComponentAttributesMapper mapper, string name);
    [ExtensionAttribute]
public static void LazyGroup(IComponentAttributesMapper`1<TComponent> mapper, string name);
}
public class NHibernate.Mapping.ByCode.Conformist.ClassMapping`1 : ClassCustomizer`1<T> {
}
public class NHibernate.Mapping.ByCode.Conformist.ComponentMapping`1 : ComponentCustomizer`1<T> {
}
public class NHibernate.Mapping.ByCode.Conformist.JoinedSubclassMapping`1 : JoinedSubclassCustomizer`1<T> {
}
public class NHibernate.Mapping.ByCode.Conformist.SubclassMapping`1 : SubclassCustomizer`1<T> {
}
public class NHibernate.Mapping.ByCode.Conformist.UnionSubclassMapping`1 : UnionSubclassCustomizer`1<T> {
}
public class NHibernate.Mapping.ByCode.ConventionModelMapper : ModelMapper {
    protected SimpleModelInspector SimpleModelInspector { get; }
    protected virtual void AppendDefaultEvents();
    protected virtual void ComponentParentToFieldAccessor(IModelInspector modelInspector, PropertyPath member, IComponentAttributesMapper componentMapper);
    protected virtual void ComponentParentNoSetterToField(IModelInspector modelInspector, PropertyPath member, IComponentAttributesMapper componentMapper);
    protected virtual void MemberReadOnlyAccessor(IModelInspector modelInspector, PropertyPath member, IAccessorPropertyMapper propertyCustomizer);
    protected bool MatchReadOnlyProperty(MemberInfo subject);
    private bool CanReadCantWriteInsideType(PropertyInfo property);
    private bool CanReadCantWriteInBaseType(PropertyInfo property);
    protected virtual void MemberNoSetterToField(IModelInspector modelInspector, PropertyPath member, IAccessorPropertyMapper propertyCustomizer);
    protected virtual void MemberToFieldAccessor(IModelInspector modelInspector, PropertyPath member, IAccessorPropertyMapper propertyCustomizer);
    protected bool MatchPropertyToField(MemberInfo subject);
    protected virtual void NoSetterPoidToField(IModelInspector modelInspector, Type type, IClassAttributesMapper classCustomizer);
    protected bool MatchNoSetterProperty(MemberInfo subject);
    protected virtual void NoPoidGuid(IModelInspector modelInspector, Type type, IClassAttributesMapper classCustomizer);
    protected SimpleModelInspector get_SimpleModelInspector();
    public void IsRootEntity(Func`3<Type, bool, bool> match);
    public void IsComponent(Func`3<Type, bool, bool> match);
    public void IsEntity(Func`3<Type, bool, bool> match);
    public void IsTablePerClass(Func`3<Type, bool, bool> match);
    public void IsTablePerClassHierarchy(Func`3<Type, bool, bool> match);
    public void IsTablePerConcreteClass(Func`3<Type, bool, bool> match);
    public void IsOneToOne(Func`3<MemberInfo, bool, bool> match);
    public void IsManyToOne(Func`3<MemberInfo, bool, bool> match);
    public void IsManyToMany(Func`3<MemberInfo, bool, bool> match);
    public void IsOneToMany(Func`3<MemberInfo, bool, bool> match);
    public void IsAny(Func`3<MemberInfo, bool, bool> match);
    public void IsPersistentId(Func`3<MemberInfo, bool, bool> match);
    public void IsVersion(Func`3<MemberInfo, bool, bool> match);
    public void IsMemberOfNaturalId(Func`3<MemberInfo, bool, bool> match);
    public void IsPersistentProperty(Func`3<MemberInfo, bool, bool> match);
    public void IsSet(Func`3<MemberInfo, bool, bool> match);
    public void IsBag(Func`3<MemberInfo, bool, bool> match);
    public void IsIdBag(Func`3<MemberInfo, bool, bool> match);
    public void IsList(Func`3<MemberInfo, bool, bool> match);
    public void IsArray(Func`3<MemberInfo, bool, bool> match);
    public void IsDictionary(Func`3<MemberInfo, bool, bool> match);
    public void IsProperty(Func`3<MemberInfo, bool, bool> match);
    public void SplitsFor(Func`3<Type, IEnumerable`1<string>, IEnumerable`1<string>> getPropertiesSplitsId);
    public void IsTablePerClassSplit(Func`3<SplitDefinition, bool, bool> match);
    [CompilerGeneratedAttribute]
private bool <ComponentParentToFieldAccessor>b__2_0(MemberInfo p);
    [CompilerGeneratedAttribute]
private bool <ComponentParentNoSetterToField>b__3_0(MemberInfo p);
}
public class NHibernate.Mapping.ByCode.CounterGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.EnhancedSequenceGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.EnhancedTableGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.EntitySqlsWithCheckMapperExtensions : object {
    [ExtensionAttribute]
public static void SqlInsert(IEntitySqlsMapper mapper, string sql, SqlCheck sqlCheck);
    [ExtensionAttribute]
public static void SqlUpdate(IEntitySqlsMapper mapper, string sql, SqlCheck sqlCheck);
    [ExtensionAttribute]
public static void SqlDelete(IEntitySqlsMapper mapper, string sql, SqlCheck sqlCheck);
}
public class NHibernate.Mapping.ByCode.ExplicitlyDeclaredModel : AbstractExplicitlyDeclaredModel {
    public virtual bool IsRootEntity(Type type);
    public virtual bool IsComponent(Type type);
    public virtual bool IsEntity(Type type);
    public virtual bool IsTablePerClass(Type type);
    public virtual bool IsTablePerClassSplit(Type type, object splitGroupId, MemberInfo member);
    public virtual bool IsTablePerClassHierarchy(Type type);
    public virtual bool IsTablePerConcreteClass(Type type);
    public virtual bool IsOneToOne(MemberInfo member);
    public virtual bool IsManyToOne(MemberInfo member);
    public virtual bool IsManyToManyItem(MemberInfo member);
    public virtual bool IsManyToManyKey(MemberInfo member);
    public virtual bool IsOneToMany(MemberInfo member);
    public sealed virtual bool IsManyToAny(MemberInfo member);
    public virtual bool IsAny(MemberInfo member);
    public virtual bool IsPersistentId(MemberInfo member);
    public sealed virtual bool IsMemberOfComposedId(MemberInfo member);
    public virtual bool IsVersion(MemberInfo member);
    public virtual bool IsMemberOfNaturalId(MemberInfo member);
    public virtual bool IsPersistentProperty(MemberInfo member);
    public virtual bool IsSet(MemberInfo role);
    public virtual bool IsBag(MemberInfo role);
    public virtual bool IsIdBag(MemberInfo role);
    public virtual bool IsList(MemberInfo role);
    public virtual bool IsArray(MemberInfo role);
    public virtual bool IsDictionary(MemberInfo role);
    public virtual bool IsProperty(MemberInfo member);
    public virtual bool IsDynamicComponent(MemberInfo member);
    public virtual IEnumerable`1<string> GetPropertiesSplits(Type type);
    [CompilerGeneratedAttribute]
private bool <IsEntity>b__2_0(Type t);
}
public class NHibernate.Mapping.ByCode.FakeModelExplicitDeclarationsHolder : object {
    private IEnumerable`1<MemberInfo> any;
    private IEnumerable`1<MemberInfo> arrays;
    private IEnumerable`1<MemberInfo> bags;
    private IEnumerable`1<Type> components;
    private IEnumerable`1<MemberInfo> dictionaries;
    private IEnumerable`1<MemberInfo> idBags;
    private IEnumerable`1<MemberInfo> lists;
    private IEnumerable`1<MemberInfo> keyManyToManyRelations;
    private IEnumerable`1<MemberInfo> itemManyToManyRelations;
    private IEnumerable`1<MemberInfo> manyToOneRelations;
    private IEnumerable`1<MemberInfo> manyToAnyRelations;
    private IEnumerable`1<MemberInfo> naturalIds;
    private IEnumerable`1<MemberInfo> oneToManyRelations;
    private IEnumerable`1<MemberInfo> oneToOneRelations;
    private IEnumerable`1<MemberInfo> poids;
    private IEnumerable`1<MemberInfo> composedIds;
    private IEnumerable`1<MemberInfo> properties;
    private IEnumerable`1<MemberInfo> dynamicComponents;
    private IEnumerable`1<MemberInfo> persistentMembers;
    private IEnumerable`1<Type> rootEntities;
    private IEnumerable`1<MemberInfo> sets;
    private IEnumerable`1<Type> tablePerClassEntities;
    private IEnumerable`1<Type> tablePerClassHierarchyEntities;
    private IEnumerable`1<Type> tablePerClassHierarchyJoinEntities;
    private IEnumerable`1<Type> tablePerConcreteClassEntities;
    private IEnumerable`1<MemberInfo> versionProperties;
    private IEnumerable`1<SplitDefinition> splitDefinitions;
    public IEnumerable`1<Type> RootEntities { get; }
    public IEnumerable`1<Type> Components { get; }
    public IEnumerable`1<Type> TablePerClassEntities { get; }
    public IEnumerable`1<Type> TablePerClassHierarchyEntities { get; }
    public IEnumerable`1<Type> TablePerClassHierarchyJoinEntities { get; }
    public IEnumerable`1<Type> TablePerConcreteClassEntities { get; }
    public IEnumerable`1<MemberInfo> OneToOneRelations { get; }
    public IEnumerable`1<MemberInfo> ManyToOneRelations { get; }
    public IEnumerable`1<MemberInfo> KeyManyToManyRelations { get; }
    public IEnumerable`1<MemberInfo> ItemManyToManyRelations { get; }
    public IEnumerable`1<MemberInfo> OneToManyRelations { get; }
    public IEnumerable`1<MemberInfo> ManyToAnyRelations { get; }
    public IEnumerable`1<MemberInfo> Any { get; }
    public IEnumerable`1<MemberInfo> Poids { get; }
    public IEnumerable`1<MemberInfo> ComposedIds { get; }
    public IEnumerable`1<MemberInfo> VersionProperties { get; }
    public IEnumerable`1<MemberInfo> NaturalIds { get; }
    public IEnumerable`1<MemberInfo> Sets { get; }
    public IEnumerable`1<MemberInfo> Bags { get; }
    public IEnumerable`1<MemberInfo> IdBags { get; }
    public IEnumerable`1<MemberInfo> Lists { get; }
    public IEnumerable`1<MemberInfo> Arrays { get; }
    public IEnumerable`1<MemberInfo> Dictionaries { get; }
    public IEnumerable`1<MemberInfo> Properties { get; }
    public IEnumerable`1<MemberInfo> DynamicComponents { get; }
    public IEnumerable`1<MemberInfo> PersistentMembers { get; }
    public IEnumerable`1<SplitDefinition> SplitDefinitions { get; }
    public sealed virtual IEnumerable`1<Type> get_RootEntities();
    public sealed virtual IEnumerable`1<Type> get_Components();
    public sealed virtual IEnumerable`1<Type> get_TablePerClassEntities();
    public sealed virtual IEnumerable`1<Type> get_TablePerClassHierarchyEntities();
    public IEnumerable`1<Type> get_TablePerClassHierarchyJoinEntities();
    public sealed virtual IEnumerable`1<Type> get_TablePerConcreteClassEntities();
    public sealed virtual IEnumerable`1<MemberInfo> get_OneToOneRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ManyToOneRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_KeyManyToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ItemManyToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_OneToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ManyToAnyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_Any();
    public sealed virtual IEnumerable`1<MemberInfo> get_Poids();
    public sealed virtual IEnumerable`1<MemberInfo> get_ComposedIds();
    public sealed virtual IEnumerable`1<MemberInfo> get_VersionProperties();
    public sealed virtual IEnumerable`1<MemberInfo> get_NaturalIds();
    public sealed virtual IEnumerable`1<MemberInfo> get_Sets();
    public sealed virtual IEnumerable`1<MemberInfo> get_Bags();
    public sealed virtual IEnumerable`1<MemberInfo> get_IdBags();
    public sealed virtual IEnumerable`1<MemberInfo> get_Lists();
    public sealed virtual IEnumerable`1<MemberInfo> get_Arrays();
    public sealed virtual IEnumerable`1<MemberInfo> get_Dictionaries();
    public sealed virtual IEnumerable`1<MemberInfo> get_Properties();
    public sealed virtual IEnumerable`1<MemberInfo> get_DynamicComponents();
    public sealed virtual IEnumerable`1<MemberInfo> get_PersistentMembers();
    public sealed virtual IEnumerable`1<SplitDefinition> get_SplitDefinitions();
    public sealed virtual IEnumerable`1<string> GetSplitGroupsFor(Type type);
    public sealed virtual string GetSplitGroupFor(MemberInfo member);
    public sealed virtual Type GetDynamicComponentTemplate(MemberInfo member);
    public sealed virtual void AddAsRootEntity(Type type);
    public sealed virtual void AddAsComponent(Type type);
    public sealed virtual void AddAsTablePerClassEntity(Type type);
    public sealed virtual void AddAsTablePerClassHierarchyEntity(Type type);
    public sealed virtual void AddAsTablePerConcreteClassEntity(Type type);
    public sealed virtual void AddAsOneToOneRelation(MemberInfo member);
    public sealed virtual void AddAsManyToOneRelation(MemberInfo member);
    public sealed virtual void AddAsManyToManyKeyRelation(MemberInfo member);
    public sealed virtual void AddAsManyToManyItemRelation(MemberInfo member);
    public sealed virtual void AddAsOneToManyRelation(MemberInfo member);
    public sealed virtual void AddAsManyToAnyRelation(MemberInfo member);
    public sealed virtual void AddAsAny(MemberInfo member);
    public sealed virtual void AddAsPoid(MemberInfo member);
    public sealed virtual void AddAsPartOfComposedId(MemberInfo member);
    public sealed virtual void AddAsVersionProperty(MemberInfo member);
    public sealed virtual void AddAsNaturalId(MemberInfo member);
    public sealed virtual void AddAsSet(MemberInfo member);
    public sealed virtual void AddAsBag(MemberInfo member);
    public sealed virtual void AddAsIdBag(MemberInfo member);
    public sealed virtual void AddAsList(MemberInfo member);
    public sealed virtual void AddAsArray(MemberInfo member);
    public sealed virtual void AddAsMap(MemberInfo member);
    public sealed virtual void AddAsProperty(MemberInfo member);
    public sealed virtual void AddAsPersistentMember(MemberInfo member);
    public sealed virtual void AddAsPropertySplit(SplitDefinition definition);
    public sealed virtual void AddAsDynamicComponent(MemberInfo member, Type componentTemplate);
}
public abstract class NHibernate.Mapping.ByCode.FetchKind : object {
    public static FetchKind Select;
    public static FetchKind Join;
    private static FetchKind();
    internal abstract virtual HbmFetchMode ToHbm();
    internal abstract virtual HbmJoinFetch ToHbmJoinFetch();
}
public static class NHibernate.Mapping.ByCode.ForClass`1 : object {
    private static BindingFlags DefaultFlags;
    public static FieldInfo Field(string fieldName);
    private static FieldInfo GetField(Type type, string fieldName);
}
public class NHibernate.Mapping.ByCode.ForeignGeneratorDef : object {
    private object param;
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public ForeignGeneratorDef(MemberInfo foreignProperty);
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public static class NHibernate.Mapping.ByCode.Generators : object {
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Assigned>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Native>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <HighLow>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <GuidComb>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <EnhancedSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <EnhancedTable>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <NativeGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Select>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <SequenceHiLo>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <TriggerIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <SequenceIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private static IGeneratorDef <UUIDString>k__BackingField;
    public static IGeneratorDef Assigned { get; private set; }
    public static IGeneratorDef Native { get; private set; }
    public static IGeneratorDef HighLow { get; private set; }
    public static IGeneratorDef Guid { get; private set; }
    public static IGeneratorDef GuidComb { get; private set; }
    public static IGeneratorDef Sequence { get; private set; }
    public static IGeneratorDef Identity { get; private set; }
    public static IGeneratorDef EnhancedSequence { get; private set; }
    public static IGeneratorDef EnhancedTable { get; private set; }
    public static IGeneratorDef Counter { get; private set; }
    public static IGeneratorDef Increment { get; private set; }
    public static IGeneratorDef NativeGuid { get; private set; }
    public static IGeneratorDef Select { get; private set; }
    public static IGeneratorDef SequenceHiLo { get; private set; }
    public static IGeneratorDef Table { get; private set; }
    public static IGeneratorDef TriggerIdentity { get; private set; }
    public static IGeneratorDef SequenceIdentity { get; private set; }
    public static IGeneratorDef UUIDString { get; private set; }
    private static Generators();
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Assigned();
    [CompilerGeneratedAttribute]
private static void set_Assigned(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Native();
    [CompilerGeneratedAttribute]
private static void set_Native(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_HighLow();
    [CompilerGeneratedAttribute]
private static void set_HighLow(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Guid();
    [CompilerGeneratedAttribute]
private static void set_Guid(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_GuidComb();
    [CompilerGeneratedAttribute]
private static void set_GuidComb(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Sequence();
    [CompilerGeneratedAttribute]
private static void set_Sequence(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Identity();
    [CompilerGeneratedAttribute]
private static void set_Identity(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_EnhancedSequence();
    [CompilerGeneratedAttribute]
private static void set_EnhancedSequence(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_EnhancedTable();
    [CompilerGeneratedAttribute]
private static void set_EnhancedTable(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Counter();
    [CompilerGeneratedAttribute]
private static void set_Counter(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Increment();
    [CompilerGeneratedAttribute]
private static void set_Increment(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_NativeGuid();
    [CompilerGeneratedAttribute]
private static void set_NativeGuid(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Select();
    [CompilerGeneratedAttribute]
private static void set_Select(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_SequenceHiLo();
    [CompilerGeneratedAttribute]
private static void set_SequenceHiLo(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_Table();
    [CompilerGeneratedAttribute]
private static void set_Table(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_TriggerIdentity();
    [CompilerGeneratedAttribute]
private static void set_TriggerIdentity(IGeneratorDef value);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_SequenceIdentity();
    [CompilerGeneratedAttribute]
private static void set_SequenceIdentity(IGeneratorDef value);
    public static IGeneratorDef UUIDHex();
    public static IGeneratorDef UUIDHex(string format);
    public static IGeneratorDef UUIDHex(string format, string separator);
    [CompilerGeneratedAttribute]
public static IGeneratorDef get_UUIDString();
    [CompilerGeneratedAttribute]
private static void set_UUIDString(IGeneratorDef value);
    public static IGeneratorDef Foreign(Expression`1<Func`2<TEntity, object>> property);
    public static IGeneratorDef Foreign(MemberInfo property);
}
public class NHibernate.Mapping.ByCode.GuidCombGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.GuidGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.HighLowGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public interface NHibernate.Mapping.ByCode.IAccessorPropertyMapper {
    public abstract virtual void Access(Accessor accessor);
    public abstract virtual void Access(Type accessorType);
}
public interface NHibernate.Mapping.ByCode.IAnyMapper {
    public abstract virtual void MetaType(IType metaType);
    public abstract virtual void MetaType();
    public abstract virtual void MetaType(Type metaType);
    public abstract virtual void IdType(IType idType);
    public abstract virtual void IdType();
    public abstract virtual void IdType(Type idType);
    public abstract virtual void Columns(Action`1<IColumnMapper> idColumnMapping, Action`1<IColumnMapper> classColumnMapping);
    public abstract virtual void MetaValue(object value, Type entityType);
    public abstract virtual void Cascade(Cascade cascadeStyle);
    public abstract virtual void Index(string indexName);
    public abstract virtual void Lazy(bool isLazy);
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void Insert(bool consideredInInsertQuery);
}
public interface NHibernate.Mapping.ByCode.IBagPropertiesMapper {
}
public interface NHibernate.Mapping.ByCode.IBagPropertiesMapper`2 {
}
public interface NHibernate.Mapping.ByCode.IBasePlainPropertyContainerMapper {
    public abstract virtual void Component(MemberInfo property, Action`1<IComponentMapper> mapping);
    public abstract virtual void Component(MemberInfo property, Action`1<IDynamicComponentMapper> mapping);
    public abstract virtual void Any(MemberInfo property, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.IBasePlainPropertyContainerMapper`1 {
    public abstract virtual void Component(Expression`1<Func`2<TContainer, TComponent>> property, Action`1<IComponentMapper`1<TComponent>> mapping);
    public abstract virtual void Component(Expression`1<Func`2<TContainer, TComponent>> property);
    public abstract virtual void Component(Expression`1<Func`2<TContainer, IDictionary>> property, TComponent dynamicComponentTemplate, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    public abstract virtual void Component(string notVisiblePropertyOrFieldName, Action`1<IComponentMapper`1<TComponent>> mapping);
    public abstract virtual void Component(string notVisiblePropertyOrFieldName);
    public abstract virtual void Component(string notVisiblePropertyOrFieldName, TComponent dynamicComponentTemplate, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    public abstract virtual void Any(Expression`1<Func`2<TContainer, TProperty>> property, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
    public abstract virtual void Any(string notVisiblePropertyOrFieldName, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.ICacheMapper {
    public abstract virtual void Usage(CacheUsage cacheUsage);
    public abstract virtual void Region(string regionName);
    public abstract virtual void Include(CacheInclude cacheInclude);
}
public interface NHibernate.Mapping.ByCode.IClassAttributesMapper {
    public abstract virtual void Id(Action`1<IIdMapper> idMapper);
    public abstract virtual void Id(MemberInfo idProperty, Action`1<IIdMapper> idMapper);
    public abstract virtual void ComponentAsId(MemberInfo idProperty, Action`1<IComponentAsIdMapper> idMapper);
    public abstract virtual void ComposedId(Action`1<IComposedIdMapper> idPropertiesMapping);
    public abstract virtual void Abstract(bool isAbstract);
    public abstract virtual void Discriminator(Action`1<IDiscriminatorMapper> discriminatorMapping);
    public abstract virtual void DiscriminatorValue(object value);
    public abstract virtual void Table(string tableName);
    public abstract virtual void Check(string check);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Mutable(bool isMutable);
    public abstract virtual void Version(MemberInfo versionProperty, Action`1<IVersionMapper> versionMapping);
    public abstract virtual void NaturalId(Action`1<INaturalIdMapper> naturalIdMapping);
    public abstract virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public abstract virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public abstract virtual void Where(string whereClause);
    public abstract virtual void SchemaAction(SchemaAction action);
    public abstract virtual void Polymorphism(PolymorphismType type);
    public abstract virtual void OptimisticLock(OptimisticLockMode mode);
}
public interface NHibernate.Mapping.ByCode.IClassAttributesMapper`1 {
    public abstract virtual void Id(Expression`1<Func`2<TEntity, TProperty>> idProperty);
    public abstract virtual void Id(Expression`1<Func`2<TEntity, TProperty>> idProperty, Action`1<IIdMapper> idMapper);
    public abstract virtual void Id(string notVisiblePropertyOrFieldName, Action`1<IIdMapper> idMapper);
    public abstract virtual void ComponentAsId(Expression`1<Func`2<TEntity, TComponent>> idProperty);
    public abstract virtual void ComponentAsId(Expression`1<Func`2<TEntity, TComponent>> idProperty, Action`1<IComponentAsIdMapper`1<TComponent>> idMapper);
    public abstract virtual void ComponentAsId(string notVisiblePropertyOrFieldName);
    public abstract virtual void ComponentAsId(string notVisiblePropertyOrFieldName, Action`1<IComponentAsIdMapper`1<TComponent>> idMapper);
    public abstract virtual void ComposedId(Action`1<IComposedIdMapper`1<TEntity>> idPropertiesMapping);
    public abstract virtual void Abstract(bool isAbstract);
    public abstract virtual void Discriminator(Action`1<IDiscriminatorMapper> discriminatorMapping);
    public abstract virtual void DiscriminatorValue(object value);
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Mutable(bool isMutable);
    public abstract virtual void Version(Expression`1<Func`2<TEntity, TProperty>> versionProperty, Action`1<IVersionMapper> versionMapping);
    public abstract virtual void Version(string notVisiblePropertyOrFieldName, Action`1<IVersionMapper> versionMapping);
    public abstract virtual void NaturalId(Action`1<IBasePlainPropertyContainerMapper`1<TEntity>> naturalIdPropertiesMapping, Action`1<INaturalIdAttributesMapper> naturalIdMapping);
    public abstract virtual void NaturalId(Action`1<IBasePlainPropertyContainerMapper`1<TEntity>> naturalIdPropertiesMapping);
    public abstract virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public abstract virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public abstract virtual void Where(string whereClause);
    public abstract virtual void SchemaAction(SchemaAction action);
    public abstract virtual void Polymorphism(PolymorphismType type);
    public abstract virtual void OptimisticLock(OptimisticLockMode mode);
}
public interface NHibernate.Mapping.ByCode.IClassMapper {
    public abstract virtual void Join(string splitGroupId, Action`1<IJoinMapper> splitMapping);
}
public interface NHibernate.Mapping.ByCode.IClassMapper`1 {
    public abstract virtual void Join(string splitGroupId, Action`1<IJoinMapper`1<TEntity>> splitMapping);
}
public interface NHibernate.Mapping.ByCode.ICollectionElementRelation {
    public abstract virtual void Element(Action`1<IElementMapper> mapping);
    public abstract virtual void OneToMany(Action`1<IOneToManyMapper> mapping);
    public abstract virtual void ManyToMany(Action`1<IManyToManyMapper> mapping);
    public abstract virtual void Component(Action`1<IComponentElementMapper> mapping);
    public abstract virtual void ManyToAny(Type idTypeOfMetaType, Action`1<IManyToAnyMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.ICollectionElementRelation`1 {
    public abstract virtual void Element();
    public abstract virtual void Element(Action`1<IElementMapper> mapping);
    public abstract virtual void OneToMany();
    public abstract virtual void OneToMany(Action`1<IOneToManyMapper> mapping);
    public abstract virtual void ManyToMany();
    public abstract virtual void ManyToMany(Action`1<IManyToManyMapper> mapping);
    public abstract virtual void Component(Action`1<IComponentElementMapper`1<TElement>> mapping);
    public abstract virtual void ManyToAny(Type idTypeOfMetaType, Action`1<IManyToAnyMapper> mapping);
    public abstract virtual void ManyToAny(Action`1<IManyToAnyMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.ICollectionIdMapper {
    public abstract virtual void Generator(IGeneratorDef generator);
    public abstract virtual void Generator(IGeneratorDef generator, Action`1<IGeneratorMapper> generatorMapping);
    public abstract virtual void Type(IIdentifierType persistentType);
    public abstract virtual void Column(string name);
    public abstract virtual void Length(int length);
}
public interface NHibernate.Mapping.ByCode.ICollectionPropertiesContainerMapper {
    public abstract virtual void Set(MemberInfo property, Action`1<ISetPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public abstract virtual void Bag(MemberInfo property, Action`1<IBagPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public abstract virtual void List(MemberInfo property, Action`1<IListPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public abstract virtual void Map(MemberInfo property, Action`1<IMapPropertiesMapper> collectionMapping, Action`1<IMapKeyRelation> keyMapping, Action`1<ICollectionElementRelation> mapping);
    public abstract virtual void IdBag(MemberInfo property, Action`1<IIdBagPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
}
public interface NHibernate.Mapping.ByCode.ICollectionPropertiesContainerMapper`1 {
    public abstract virtual void Set(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void Set(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public abstract virtual void Set(string notVisiblePropertyOrFieldName, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void Set(string notVisiblePropertyOrFieldName, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public abstract virtual void Bag(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void Bag(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public abstract virtual void Bag(string notVisiblePropertyOrFieldName, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void Bag(string notVisiblePropertyOrFieldName, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public abstract virtual void List(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void List(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public abstract virtual void List(string notVisiblePropertyOrFieldName, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void List(string notVisiblePropertyOrFieldName, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public abstract virtual void Map(Expression`1<Func`2<TEntity, IDictionary`2<TKey, TElement>>> property, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<IMapKeyRelation`1<TKey>> keyMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void Map(Expression`1<Func`2<TEntity, IDictionary`2<TKey, TElement>>> property, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void Map(Expression`1<Func`2<TEntity, IDictionary`2<TKey, TElement>>> property, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping);
    public abstract virtual void Map(string notVisiblePropertyOrFieldName, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<IMapKeyRelation`1<TKey>> keyMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void Map(string notVisiblePropertyOrFieldName, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void Map(string notVisiblePropertyOrFieldName, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping);
    public abstract virtual void IdBag(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void IdBag(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public abstract virtual void IdBag(string notVisiblePropertyOrFieldName, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public abstract virtual void IdBag(string notVisiblePropertyOrFieldName, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping);
}
public interface NHibernate.Mapping.ByCode.ICollectionPropertiesMapper {
    public abstract virtual void Inverse(bool value);
    public abstract virtual void Mutable(bool value);
    public abstract virtual void Where(string sqlWhereClause);
    public abstract virtual void BatchSize(int value);
    public abstract virtual void Lazy(CollectionLazy collectionLazy);
    public abstract virtual void Key(Action`1<IKeyMapper> keyMapping);
    public abstract virtual void OrderBy(MemberInfo property);
    public abstract virtual void OrderBy(string sqlOrderByClause);
    public abstract virtual void Sort();
    public abstract virtual void Sort();
    public abstract virtual void Cascade(Cascade cascadeStyle);
    public abstract virtual void Type();
    public abstract virtual void Type(Type collectionType);
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public abstract virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public abstract virtual void Fetch(CollectionFetchMode fetchMode);
    public abstract virtual void Persister(Type persister);
}
public interface NHibernate.Mapping.ByCode.ICollectionPropertiesMapper`2 {
    public abstract virtual void Inverse(bool value);
    public abstract virtual void Mutable(bool value);
    public abstract virtual void Where(string sqlWhereClause);
    public abstract virtual void BatchSize(int value);
    public abstract virtual void Lazy(CollectionLazy collectionLazy);
    public abstract virtual void Key(Action`1<IKeyMapper`1<TEntity>> keyMapping);
    public abstract virtual void OrderBy(Expression`1<Func`2<TElement, TProperty>> property);
    public abstract virtual void OrderBy(string sqlOrderByClause);
    public abstract virtual void Sort();
    public abstract virtual void Sort();
    public abstract virtual void Cascade(Cascade cascadeStyle);
    public abstract virtual void Type();
    public abstract virtual void Type(Type collectionType);
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public abstract virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public abstract virtual void Fetch(CollectionFetchMode fetchMode);
    public abstract virtual void Persister();
}
public interface NHibernate.Mapping.ByCode.ICollectionSqlsMapper {
    public abstract virtual void Loader(string namedQueryReference);
    public abstract virtual void SqlInsert(string sql);
    public abstract virtual void SqlUpdate(string sql);
    public abstract virtual void SqlDelete(string sql);
    public abstract virtual void SqlDeleteAll(string sql);
    public abstract virtual void Subselect(string sql);
}
public interface NHibernate.Mapping.ByCode.ICollectionSqlsWithCheckMapper {
    public abstract virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public abstract virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public abstract virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public abstract virtual void SqlDeleteAll(string sql, SqlCheck sqlCheck);
}
public interface NHibernate.Mapping.ByCode.IColumnMapper {
    public abstract virtual void Name(string name);
    public abstract virtual void Length(int length);
    public abstract virtual void Precision(short precision);
    public abstract virtual void Scale(short scale);
    public abstract virtual void NotNullable(bool notnull);
    public abstract virtual void Unique(bool unique);
    public abstract virtual void UniqueKey(string uniquekeyName);
    public abstract virtual void SqlType(string sqltype);
    public abstract virtual void Index(string indexName);
    public abstract virtual void Check(string checkConstraint);
    public abstract virtual void Default(object defaultValue);
}
public interface NHibernate.Mapping.ByCode.IColumnOrFormulaMapper {
    public abstract virtual void Formula(string formula);
}
public interface NHibernate.Mapping.ByCode.IColumnsAndFormulasMapper {
    public abstract virtual void ColumnsAndFormulas(Action`1[] columnOrFormulaMapper);
    public abstract virtual void Formula(string formula);
    public abstract virtual void Formulas(String[] formulas);
}
public interface NHibernate.Mapping.ByCode.IColumnsMapper {
    public abstract virtual void Column(Action`1<IColumnMapper> columnMapper);
    public abstract virtual void Columns(Action`1[] columnMapper);
    public abstract virtual void Column(string name);
}
public interface NHibernate.Mapping.ByCode.IComponentAsIdAttributesMapper {
    public abstract virtual void Class(Type componentType);
    public abstract virtual void UnsavedValue(UnsavedValueType unsavedValueType);
}
public interface NHibernate.Mapping.ByCode.IComponentAsIdAttributesMapper`1 {
    public abstract virtual void Class();
    public abstract virtual void UnsavedValue(UnsavedValueType unsavedValueType);
}
public interface NHibernate.Mapping.ByCode.IComponentAsIdMapper {
}
public interface NHibernate.Mapping.ByCode.IComponentAsIdMapper`1 {
}
public interface NHibernate.Mapping.ByCode.IComponentAttributesMapper {
    public abstract virtual void Parent(MemberInfo parent);
    public abstract virtual void Parent(MemberInfo parent, Action`1<IComponentParentMapper> parentMapping);
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void Insert(bool consideredInInsertQuery);
    public abstract virtual void Lazy(bool isLazy);
    public abstract virtual void Unique(bool unique);
    public abstract virtual void Class(Type componentType);
}
public interface NHibernate.Mapping.ByCode.IComponentAttributesMapper`1 {
    public abstract virtual void Parent(Expression`1<Func`2<TComponent, TProperty>> parent);
    public abstract virtual void Parent(Expression`1<Func`2<TComponent, TProperty>> parent, Action`1<IComponentParentMapper> parentMapping);
    public abstract virtual void Parent(string notVisiblePropertyOrFieldName, Action`1<IComponentParentMapper> mapping);
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void Insert(bool consideredInInsertQuery);
    public abstract virtual void Lazy(bool isLazy);
    public abstract virtual void Unique(bool unique);
    public abstract virtual void Class();
}
public interface NHibernate.Mapping.ByCode.IComponentElementMapper {
    public abstract virtual void Component(MemberInfo property, Action`1<IComponentElementMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.IComponentElementMapper`1 {
    public abstract virtual void Component(Expression`1<Func`2<TComponent, TNestedComponent>> property, Action`1<IComponentElementMapper`1<TNestedComponent>> mapping);
    public abstract virtual void Component(string notVisiblePropertyOrFieldName, Action`1<IComponentElementMapper`1<TNestedComponent>> mapping);
}
public interface NHibernate.Mapping.ByCode.IComponentMapKeyMapper {
    public abstract virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    public abstract virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.IComponentMapKeyMapper`1 {
    public abstract virtual void Property(Expression`1<Func`2<TComponent, TProperty>> property, Action`1<IPropertyMapper> mapping);
    public abstract virtual void Property(Expression`1<Func`2<TComponent, TProperty>> property);
    public abstract virtual void ManyToOne(Expression`1<Func`2<TComponent, TProperty>> property, Action`1<IManyToOneMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.IComponentMapper {
}
public interface NHibernate.Mapping.ByCode.IComponentMapper`1 {
}
public interface NHibernate.Mapping.ByCode.IComponentParentMapper {
}
public interface NHibernate.Mapping.ByCode.IComposedIdMapper {
}
public interface NHibernate.Mapping.ByCode.IComposedIdMapper`1 {
}
public interface NHibernate.Mapping.ByCode.IConformistHoldersProvider {
    public ICustomizersHolder CustomizersHolder { get; }
    public IModelExplicitDeclarationsHolder ExplicitDeclarationsHolder { get; }
    public abstract virtual ICustomizersHolder get_CustomizersHolder();
    public abstract virtual IModelExplicitDeclarationsHolder get_ExplicitDeclarationsHolder();
}
public class NHibernate.Mapping.ByCode.IdentityGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public interface NHibernate.Mapping.ByCode.IDiscriminatorMapper {
    public abstract virtual void Column(string column);
    public abstract virtual void Column(Action`1<IColumnMapper> columnMapper);
    public abstract virtual void Type(IType persistentType);
    public abstract virtual void Type(IDiscriminatorType persistentType);
    public abstract virtual void Type();
    public abstract virtual void Type(Type persistentType);
    public abstract virtual void Formula(string formula);
    public abstract virtual void Force(bool force);
    public abstract virtual void Insert(bool applyOnApplyOnInsert);
    public abstract virtual void NotNullable(bool isNotNullable);
    public abstract virtual void Length(int length);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.IdMapperExtensions : object {
    [ExtensionAttribute]
public static void Type(IIdMapper idMapper);
    [ExtensionAttribute]
public static void Type(IIdMapper idMapper, object parameters);
    [ExtensionAttribute]
public static void Type(IIdMapper idMapper, Type persistentType, object parameters);
}
public interface NHibernate.Mapping.ByCode.IDynamicComponentAttributesMapper {
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void Insert(bool consideredInInsertQuery);
    public abstract virtual void Unique(bool unique);
}
public interface NHibernate.Mapping.ByCode.IDynamicComponentAttributesMapper`1 {
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void Insert(bool consideredInInsertQuery);
    public abstract virtual void Unique(bool unique);
}
public interface NHibernate.Mapping.ByCode.IDynamicComponentMapper {
}
public interface NHibernate.Mapping.ByCode.IDynamicComponentMapper`1 {
}
public interface NHibernate.Mapping.ByCode.IElementMapper {
    public abstract virtual void Type(IType persistentType);
    public abstract virtual void Type();
    public abstract virtual void Type(object parameters);
    public abstract virtual void Type(Type persistentType, object parameters);
    public abstract virtual void Length(int length);
    public abstract virtual void Precision(short precision);
    public abstract virtual void Scale(short scale);
    public abstract virtual void NotNullable(bool notnull);
    public abstract virtual void Unique(bool unique);
    public abstract virtual void Formula(string formula);
}
public interface NHibernate.Mapping.ByCode.IEntityAttributesMapper {
    public abstract virtual void EntityName(string value);
    public abstract virtual void Proxy(Type proxy);
    public abstract virtual void Lazy(bool value);
    public abstract virtual void DynamicUpdate(bool value);
    public abstract virtual void DynamicInsert(bool value);
    public abstract virtual void BatchSize(int value);
    public abstract virtual void SelectBeforeUpdate(bool value);
    public abstract virtual void Persister();
    public abstract virtual void Synchronize(String[] table);
}
public interface NHibernate.Mapping.ByCode.IEntityPropertyMapper {
    public abstract virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
}
public interface NHibernate.Mapping.ByCode.IEntitySqlsMapper {
    public abstract virtual void Loader(string namedQueryReference);
    public abstract virtual void SqlInsert(string sql);
    public abstract virtual void SqlUpdate(string sql);
    public abstract virtual void SqlDelete(string sql);
    public abstract virtual void Subselect(string sql);
}
public interface NHibernate.Mapping.ByCode.IEntitySqlsWithCheckMapper {
    public abstract virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public abstract virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public abstract virtual void SqlDelete(string sql, SqlCheck sqlCheck);
}
public interface NHibernate.Mapping.ByCode.IFilterMapper {
    public abstract virtual void Condition(string sqlCondition);
}
public interface NHibernate.Mapping.ByCode.IGenerator {
}
public interface NHibernate.Mapping.ByCode.IGeneratorDef {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public abstract virtual string get_Class();
    public abstract virtual object get_Params();
    public abstract virtual Type get_DefaultReturnType();
    public abstract virtual bool get_SupportedAsCollectionElementId();
}
public interface NHibernate.Mapping.ByCode.IGeneratorMapper {
    public abstract virtual void Params(object generatorParameters);
    public abstract virtual void Params(IDictionary`2<string, object> generatorParameters);
}
public interface NHibernate.Mapping.ByCode.IIdBagPropertiesMapper {
    public abstract virtual void Id(Action`1<ICollectionIdMapper> idMapping);
}
public interface NHibernate.Mapping.ByCode.IIdBagPropertiesMapper`2 {
    public abstract virtual void Id(Action`1<ICollectionIdMapper> idMapping);
}
public interface NHibernate.Mapping.ByCode.IIdMapper {
    public abstract virtual void Generator(IGeneratorDef generator);
    public abstract virtual void Generator(IGeneratorDef generator, Action`1<IGeneratorMapper> generatorMapping);
    public abstract virtual void Type(IIdentifierType persistentType);
    public abstract virtual void UnsavedValue(object value);
    public abstract virtual void Length(int length);
}
public interface NHibernate.Mapping.ByCode.IJoinAttributesMapper {
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Key(Action`1<IKeyMapper> keyMapping);
    public abstract virtual void Inverse(bool value);
    public abstract virtual void Optional(bool isOptional);
    public abstract virtual void Fetch(FetchKind fetchMode);
}
public interface NHibernate.Mapping.ByCode.IJoinAttributesMapper`1 {
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Inverse(bool value);
    public abstract virtual void Optional(bool isOptional);
    public abstract virtual void Fetch(FetchKind fetchMode);
    public abstract virtual void Key(Action`1<IKeyMapper`1<TEntity>> keyMapping);
}
public interface NHibernate.Mapping.ByCode.IJoinedSubclassAttributesMapper {
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Key(Action`1<IKeyMapper> keyMapping);
    public abstract virtual void Extends(Type baseType);
    public abstract virtual void SchemaAction(SchemaAction action);
    public abstract virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public abstract virtual void Abstract(bool isAbstract);
}
public interface NHibernate.Mapping.ByCode.IJoinedSubclassAttributesMapper`1 {
    public abstract virtual void Abstract(bool isAbstract);
    public abstract virtual void Extends(Type baseType);
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Key(Action`1<IKeyMapper`1<TEntity>> keyMapping);
    public abstract virtual void SchemaAction(SchemaAction action);
    public abstract virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
}
public interface NHibernate.Mapping.ByCode.IJoinedSubclassMapper {
}
public interface NHibernate.Mapping.ByCode.IJoinedSubclassMapper`1 {
}
public interface NHibernate.Mapping.ByCode.IJoinMapper {
}
public interface NHibernate.Mapping.ByCode.IJoinMapper`1 {
}
public interface NHibernate.Mapping.ByCode.IKeyMapper {
    public abstract virtual void OnDelete(OnDeleteAction deleteAction);
    public abstract virtual void PropertyRef(MemberInfo property);
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void NotNullable(bool notnull);
    public abstract virtual void Unique(bool unique);
    public abstract virtual void ForeignKey(string foreignKeyName);
}
public interface NHibernate.Mapping.ByCode.IKeyMapper`1 {
    public abstract virtual void OnDelete(OnDeleteAction deleteAction);
    public abstract virtual void PropertyRef(Expression`1<Func`2<TEntity, TProperty>> propertyGetter);
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void ForeignKey(string foreignKeyName);
    public abstract virtual void NotNullable(bool notnull);
    public abstract virtual void Unique(bool unique);
}
public interface NHibernate.Mapping.ByCode.IListIndexMapper {
    public abstract virtual void Column(string columnName);
    public abstract virtual void Base(int baseIndex);
    public abstract virtual void Column(Action`1<IColumnMapper> columnMapper);
}
public interface NHibernate.Mapping.ByCode.IListPropertiesMapper {
    public abstract virtual void Index(Action`1<IListIndexMapper> listIndexMapping);
}
public interface NHibernate.Mapping.ByCode.IListPropertiesMapper`2 {
    public abstract virtual void Index(Action`1<IListIndexMapper> listIndexMapping);
}
public interface NHibernate.Mapping.ByCode.IManyToAnyMapper {
    public abstract virtual void MetaType(IType metaType);
    public abstract virtual void MetaType();
    public abstract virtual void MetaType(Type metaType);
    public abstract virtual void IdType(IType idType);
    public abstract virtual void IdType();
    public abstract virtual void IdType(Type idType);
    public abstract virtual void Columns(Action`1<IColumnMapper> idColumnMapping, Action`1<IColumnMapper> classColumnMapping);
    public abstract virtual void MetaValue(object value, Type entityType);
}
public interface NHibernate.Mapping.ByCode.IManyToManyMapper {
    public abstract virtual void Class(Type entityType);
    public abstract virtual void EntityName(string entityName);
    public abstract virtual void NotFound(NotFoundMode mode);
    public abstract virtual void Formula(string formula);
    public abstract virtual void Lazy(LazyRelation lazyRelation);
    public abstract virtual void ForeignKey(string foreignKeyName);
    public abstract virtual void Where(string sqlWhereClause);
}
public interface NHibernate.Mapping.ByCode.IManyToOneMapper {
    public abstract virtual void Class(Type entityType);
    public abstract virtual void Cascade(Cascade cascadeStyle);
    public abstract virtual void NotNullable(bool notnull);
    public abstract virtual void Unique(bool unique);
    public abstract virtual void UniqueKey(string uniquekeyName);
    public abstract virtual void Index(string indexName);
    public abstract virtual void Fetch(FetchKind fetchMode);
    public abstract virtual void Formula(string formula);
    public abstract virtual void Lazy(LazyRelation lazyRelation);
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void Insert(bool consideredInInsertQuery);
    public abstract virtual void ForeignKey(string foreignKeyName);
    public abstract virtual void PropertyRef(string propertyReferencedName);
    public abstract virtual void NotFound(NotFoundMode mode);
}
public interface NHibernate.Mapping.ByCode.IMapKeyManyToManyMapper {
    public abstract virtual void ForeignKey(string foreignKeyName);
    public abstract virtual void Formula(string formula);
}
public interface NHibernate.Mapping.ByCode.IMapKeyMapper {
    public abstract virtual void Type(IType persistentType);
    public abstract virtual void Type();
    public abstract virtual void Type(Type persistentType);
    public abstract virtual void Length(int length);
    public abstract virtual void Formula(string formula);
}
public interface NHibernate.Mapping.ByCode.IMapKeyRelation {
    public abstract virtual void Element(Action`1<IMapKeyMapper> mapping);
    public abstract virtual void ManyToMany(Action`1<IMapKeyManyToManyMapper> mapping);
    public abstract virtual void Component(Action`1<IComponentMapKeyMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.IMapKeyRelation`1 {
    public abstract virtual void Element();
    public abstract virtual void Element(Action`1<IMapKeyMapper> mapping);
    public abstract virtual void ManyToMany();
    public abstract virtual void ManyToMany(Action`1<IMapKeyManyToManyMapper> mapping);
    public abstract virtual void Component(Action`1<IComponentMapKeyMapper`1<TKey>> mapping);
}
public interface NHibernate.Mapping.ByCode.IMapPropertiesMapper {
}
public interface NHibernate.Mapping.ByCode.IMapPropertiesMapper`3 {
}
public interface NHibernate.Mapping.ByCode.IMinimalPlainPropertyContainerMapper {
    public abstract virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    public abstract virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.IMinimalPlainPropertyContainerMapper`1 {
    public abstract virtual void Property(Expression`1<Func`2<TContainer, TProperty>> property);
    public abstract virtual void Property(Expression`1<Func`2<TContainer, TProperty>> property, Action`1<IPropertyMapper> mapping);
    public abstract virtual void Property(string notVisiblePropertyOrFieldName, Action`1<IPropertyMapper> mapping);
    public abstract virtual void ManyToOne(Expression`1<Func`2<TContainer, TProperty>> property, Action`1<IManyToOneMapper> mapping);
    public abstract virtual void ManyToOne(Expression`1<Func`2<TContainer, TProperty>> property);
    public abstract virtual void ManyToOne(string notVisiblePropertyOrFieldName, Action`1<IManyToOneMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder {
    public IEnumerable`1<Type> RootEntities { get; }
    public IEnumerable`1<Type> Components { get; }
    public IEnumerable`1<Type> TablePerClassEntities { get; }
    public IEnumerable`1<Type> TablePerClassHierarchyEntities { get; }
    public IEnumerable`1<Type> TablePerConcreteClassEntities { get; }
    public IEnumerable`1<MemberInfo> OneToOneRelations { get; }
    public IEnumerable`1<MemberInfo> ManyToOneRelations { get; }
    public IEnumerable`1<MemberInfo> KeyManyToManyRelations { get; }
    public IEnumerable`1<MemberInfo> ItemManyToManyRelations { get; }
    public IEnumerable`1<MemberInfo> OneToManyRelations { get; }
    public IEnumerable`1<MemberInfo> ManyToAnyRelations { get; }
    public IEnumerable`1<MemberInfo> Any { get; }
    public IEnumerable`1<MemberInfo> Poids { get; }
    public IEnumerable`1<MemberInfo> ComposedIds { get; }
    public IEnumerable`1<MemberInfo> VersionProperties { get; }
    public IEnumerable`1<MemberInfo> NaturalIds { get; }
    public IEnumerable`1<MemberInfo> Sets { get; }
    public IEnumerable`1<MemberInfo> Bags { get; }
    public IEnumerable`1<MemberInfo> IdBags { get; }
    public IEnumerable`1<MemberInfo> Lists { get; }
    public IEnumerable`1<MemberInfo> Arrays { get; }
    public IEnumerable`1<MemberInfo> Dictionaries { get; }
    public IEnumerable`1<MemberInfo> Properties { get; }
    public IEnumerable`1<MemberInfo> DynamicComponents { get; }
    public IEnumerable`1<MemberInfo> PersistentMembers { get; }
    public IEnumerable`1<SplitDefinition> SplitDefinitions { get; }
    public abstract virtual IEnumerable`1<Type> get_RootEntities();
    public abstract virtual IEnumerable`1<Type> get_Components();
    public abstract virtual IEnumerable`1<Type> get_TablePerClassEntities();
    public abstract virtual IEnumerable`1<Type> get_TablePerClassHierarchyEntities();
    public abstract virtual IEnumerable`1<Type> get_TablePerConcreteClassEntities();
    public abstract virtual IEnumerable`1<MemberInfo> get_OneToOneRelations();
    public abstract virtual IEnumerable`1<MemberInfo> get_ManyToOneRelations();
    public abstract virtual IEnumerable`1<MemberInfo> get_KeyManyToManyRelations();
    public abstract virtual IEnumerable`1<MemberInfo> get_ItemManyToManyRelations();
    public abstract virtual IEnumerable`1<MemberInfo> get_OneToManyRelations();
    public abstract virtual IEnumerable`1<MemberInfo> get_ManyToAnyRelations();
    public abstract virtual IEnumerable`1<MemberInfo> get_Any();
    public abstract virtual IEnumerable`1<MemberInfo> get_Poids();
    public abstract virtual IEnumerable`1<MemberInfo> get_ComposedIds();
    public abstract virtual IEnumerable`1<MemberInfo> get_VersionProperties();
    public abstract virtual IEnumerable`1<MemberInfo> get_NaturalIds();
    public abstract virtual IEnumerable`1<MemberInfo> get_Sets();
    public abstract virtual IEnumerable`1<MemberInfo> get_Bags();
    public abstract virtual IEnumerable`1<MemberInfo> get_IdBags();
    public abstract virtual IEnumerable`1<MemberInfo> get_Lists();
    public abstract virtual IEnumerable`1<MemberInfo> get_Arrays();
    public abstract virtual IEnumerable`1<MemberInfo> get_Dictionaries();
    public abstract virtual IEnumerable`1<MemberInfo> get_Properties();
    public abstract virtual IEnumerable`1<MemberInfo> get_DynamicComponents();
    public abstract virtual IEnumerable`1<MemberInfo> get_PersistentMembers();
    public abstract virtual IEnumerable`1<SplitDefinition> get_SplitDefinitions();
    public abstract virtual IEnumerable`1<string> GetSplitGroupsFor(Type type);
    public abstract virtual string GetSplitGroupFor(MemberInfo member);
    public abstract virtual Type GetDynamicComponentTemplate(MemberInfo member);
    public abstract virtual void AddAsRootEntity(Type type);
    public abstract virtual void AddAsComponent(Type type);
    public abstract virtual void AddAsTablePerClassEntity(Type type);
    public abstract virtual void AddAsTablePerClassHierarchyEntity(Type type);
    public abstract virtual void AddAsTablePerConcreteClassEntity(Type type);
    public abstract virtual void AddAsOneToOneRelation(MemberInfo member);
    public abstract virtual void AddAsManyToOneRelation(MemberInfo member);
    public abstract virtual void AddAsManyToManyKeyRelation(MemberInfo member);
    public abstract virtual void AddAsManyToManyItemRelation(MemberInfo member);
    public abstract virtual void AddAsOneToManyRelation(MemberInfo member);
    public abstract virtual void AddAsManyToAnyRelation(MemberInfo member);
    public abstract virtual void AddAsAny(MemberInfo member);
    public abstract virtual void AddAsPoid(MemberInfo member);
    public abstract virtual void AddAsPartOfComposedId(MemberInfo member);
    public abstract virtual void AddAsVersionProperty(MemberInfo member);
    public abstract virtual void AddAsNaturalId(MemberInfo member);
    public abstract virtual void AddAsSet(MemberInfo member);
    public abstract virtual void AddAsBag(MemberInfo member);
    public abstract virtual void AddAsIdBag(MemberInfo member);
    public abstract virtual void AddAsList(MemberInfo member);
    public abstract virtual void AddAsArray(MemberInfo member);
    public abstract virtual void AddAsMap(MemberInfo member);
    public abstract virtual void AddAsProperty(MemberInfo member);
    public abstract virtual void AddAsPersistentMember(MemberInfo member);
    public abstract virtual void AddAsPropertySplit(SplitDefinition definition);
    public abstract virtual void AddAsDynamicComponent(MemberInfo member, Type componentTemplate);
}
public interface NHibernate.Mapping.ByCode.IModelInspector {
    public abstract virtual bool IsRootEntity(Type type);
    public abstract virtual bool IsComponent(Type type);
    public abstract virtual bool IsEntity(Type type);
    public abstract virtual bool IsTablePerClass(Type type);
    public abstract virtual bool IsTablePerClassSplit(Type type, object splitGroupId, MemberInfo member);
    public abstract virtual bool IsTablePerClassHierarchy(Type type);
    public abstract virtual bool IsTablePerConcreteClass(Type type);
    public abstract virtual bool IsOneToOne(MemberInfo member);
    public abstract virtual bool IsManyToOne(MemberInfo member);
    public abstract virtual bool IsManyToManyItem(MemberInfo member);
    public abstract virtual bool IsManyToManyKey(MemberInfo member);
    public abstract virtual bool IsOneToMany(MemberInfo member);
    public abstract virtual bool IsManyToAny(MemberInfo member);
    public abstract virtual bool IsAny(MemberInfo member);
    public abstract virtual bool IsPersistentId(MemberInfo member);
    public abstract virtual bool IsMemberOfComposedId(MemberInfo member);
    public abstract virtual bool IsVersion(MemberInfo member);
    public abstract virtual bool IsMemberOfNaturalId(MemberInfo member);
    public abstract virtual bool IsPersistentProperty(MemberInfo member);
    public abstract virtual bool IsSet(MemberInfo role);
    public abstract virtual bool IsBag(MemberInfo role);
    public abstract virtual bool IsIdBag(MemberInfo role);
    public abstract virtual bool IsList(MemberInfo role);
    public abstract virtual bool IsArray(MemberInfo role);
    public abstract virtual bool IsDictionary(MemberInfo role);
    public abstract virtual bool IsProperty(MemberInfo member);
    public abstract virtual bool IsDynamicComponent(MemberInfo member);
    public abstract virtual Type GetDynamicComponentTemplate(MemberInfo member);
    public abstract virtual IEnumerable`1<string> GetPropertiesSplits(Type type);
}
public abstract class NHibernate.Mapping.ByCode.Impl.AbstractBasePropertyContainerMapper : object {
    protected Type container;
    protected HbmMapping mapDoc;
    protected HbmMapping MapDoc { get; }
    protected Type Container { get; }
    protected AbstractBasePropertyContainerMapper(Type container, HbmMapping mapDoc);
    protected HbmMapping get_MapDoc();
    protected Type get_Container();
    protected abstract virtual void AddProperty(object property);
    public virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    protected virtual bool IsMemberSupportedByMappedContainer(MemberInfo property);
    public virtual void Component(MemberInfo property, Action`1<IComponentMapper> mapping);
    public virtual void Component(MemberInfo property, Action`1<IDynamicComponentMapper> mapping);
    public virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
    public virtual void Any(MemberInfo property, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
}
public abstract class NHibernate.Mapping.ByCode.Impl.AbstractPropertyContainerMapper : AbstractBasePropertyContainerMapper {
    protected AbstractPropertyContainerMapper(Type container, HbmMapping mapDoc);
    public virtual void OneToOne(MemberInfo property, Action`1<IOneToOneMapper> mapping);
    public virtual void Set(MemberInfo property, Action`1<ISetPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public virtual void Bag(MemberInfo property, Action`1<IBagPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public virtual void List(MemberInfo property, Action`1<IListPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public virtual void Map(MemberInfo property, Action`1<IMapPropertiesMapper> collectionMapping, Action`1<IMapKeyRelation> keyMapping, Action`1<ICollectionElementRelation> mapping);
    public virtual void IdBag(MemberInfo property, Action`1<IIdBagPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.AccessorPropertyMapper : object {
    private static BindingFlags FieldBindingFlag;
    private bool canChangeAccessor;
    private Type declaringType;
    private IDictionary`2<string, IFieldNamingStrategy> fieldNamningStrategies;
    private string propertyName;
    private Action`1<string> setAccessor;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; public set; }
    public AccessorPropertyMapper(Type declaringType, string propertyName, Action`1<string> accesorValueSetter);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    private string GetNamingFieldStrategy();
    private static MemberInfo GetField(Type type, string fieldName);
    [CompilerGeneratedAttribute]
private bool <GetNamingFieldStrategy>b__13_0(KeyValuePair`2<string, IFieldNamingStrategy> p);
}
public class NHibernate.Mapping.ByCode.Impl.AnyMapper : object {
    private static string DefaultIdColumnNameWhenNoProperty;
    private static string DefaultMetaColumnNameWhenNoProperty;
    private HbmAny any;
    private ColumnMapper classColumnMapper;
    private IAccessorPropertyMapper entityPropertyMapper;
    private Type foreignIdType;
    private ColumnMapper idColumnMapper;
    private HbmMapping mapDoc;
    private MemberInfo member;
    public AnyMapper(MemberInfo member, Type foreignIdType, HbmAny any, HbmMapping mapDoc);
    public AnyMapper(MemberInfo member, Type foreignIdType, IAccessorPropertyMapper accessorMapper, HbmAny any, HbmMapping mapDoc);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void MetaType(IType metaType);
    public sealed virtual void MetaType();
    public sealed virtual void MetaType(Type metaType);
    public sealed virtual void IdType(IType idType);
    public sealed virtual void IdType();
    public sealed virtual void IdType(Type idType);
    public sealed virtual void Columns(Action`1<IColumnMapper> idColumnMapping, Action`1<IColumnMapper> classColumnMapping);
    public sealed virtual void MetaValue(object value, Type entityType);
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void Index(string indexName);
    public sealed virtual void Lazy(bool isLazy);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    private void CheckMetaTypeImmutability(string nhTypeName);
    private void CheckIdTypeImmutability(string nhTypeName);
}
public class NHibernate.Mapping.ByCode.Impl.AnyMappingHandler : MulticastDelegate {
    public AnyMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IAnyMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IAnyMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.BagMapper : object {
    private IAccessorPropertyMapper entityPropertyMapper;
    private KeyMapper keyMapper;
    private HbmBag mapping;
    private ICacheMapper cacheMapper;
    [CompilerGeneratedAttribute]
private Type <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    public Type OwnerType { get; private set; }
    public Type ElementType { get; private set; }
    public BagMapper(Type ownerType, Type elementType, HbmBag mapping);
    public BagMapper(Type ownerType, Type elementType, IAccessorPropertyMapper accessorMapper, HbmBag mapping);
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
private void set_OwnerType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(Type value);
    public sealed virtual void Inverse(bool value);
    public sealed virtual void Mutable(bool value);
    public sealed virtual void Where(string sqlWhereClause);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void Lazy(CollectionLazy collectionLazy);
    public sealed virtual void Key(Action`1<IKeyMapper> keyMapping);
    public sealed virtual void OrderBy(MemberInfo property);
    public sealed virtual void OrderBy(string sqlOrderByClause);
    public sealed virtual void Sort();
    public sealed virtual void Sort();
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void Type();
    public sealed virtual void Type(Type collectionType);
    public void Type(string collectionType);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public sealed virtual void Fetch(CollectionFetchMode fetchMode);
    public sealed virtual void Persister(Type persister);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDeleteAll(string sql);
    public sealed virtual void SqlDeleteAll(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
}
public class NHibernate.Mapping.ByCode.Impl.BagMappingHandler : MulticastDelegate {
    public BagMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IBagPropertiesMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IBagPropertiesMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.CacheMapper : object {
    private HbmCache cacheMapping;
    public CacheMapper(HbmCache cacheMapping);
    public sealed virtual void Usage(CacheUsage cacheUsage);
    public sealed virtual void Region(string regionName);
    public sealed virtual void Include(CacheInclude cacheInclude);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.Impl.CascadeConverter : object {
    [ExtensionAttribute]
public static string ToCascadeString(Cascade source);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.Impl.CascadeConverter/<CascadeDefinitions>d__1")]
[ExtensionAttribute]
private static IEnumerable`1<string> CascadeDefinitions(Cascade source);
}
public class NHibernate.Mapping.ByCode.Impl.ClassMapper : AbstractPropertyContainerMapper {
    private HbmClass classMapping;
    private IIdMapper idMapper;
    private bool simpleIdPropertyWasUsed;
    private bool composedIdWasUsed;
    private bool componentAsIdWasUsed;
    private Dictionary`2<string, IJoinMapper> joinMappers;
    private ICacheMapper cacheMapper;
    private IDiscriminatorMapper discriminatorMapper;
    private INaturalIdMapper naturalIdMapper;
    private IVersionMapper versionMapper;
    public Dictionary`2<string, IJoinMapper> JoinMappers { get; }
    public ClassMapper(Type rootClass, HbmMapping mapDoc, MemberInfo idProperty);
    protected virtual void AddProperty(object property);
    public Dictionary`2<string, IJoinMapper> get_JoinMappers();
    public sealed virtual void Abstract(bool isAbstract);
    public sealed virtual void OptimisticLock(OptimisticLockMode mode);
    public sealed virtual void Id(Action`1<IIdMapper> mapper);
    public sealed virtual void Id(MemberInfo idProperty, Action`1<IIdMapper> mapper);
    public sealed virtual void ComponentAsId(MemberInfo idProperty, Action`1<IComponentAsIdMapper> mapper);
    public sealed virtual void ComposedId(Action`1<IComposedIdMapper> idPropertiesMapping);
    public sealed virtual void Discriminator(Action`1<IDiscriminatorMapper> discriminatorMapping);
    public sealed virtual void DiscriminatorValue(object value);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Check(string check);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Mutable(bool isMutable);
    public sealed virtual void Version(MemberInfo versionProperty, Action`1<IVersionMapper> versionMapping);
    public sealed virtual void NaturalId(Action`1<INaturalIdMapper> naturalIdMapping);
    public sealed virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public sealed virtual void Where(string whereClause);
    public sealed virtual void SchemaAction(SchemaAction action);
    public sealed virtual void Join(string splitGroupId, Action`1<IJoinMapper> splitMapping);
    public sealed virtual void Polymorphism(PolymorphismType type);
    public sealed virtual void EntityName(string value);
    public sealed virtual void Proxy(Type proxy);
    public sealed virtual void Lazy(bool value);
    public sealed virtual void DynamicUpdate(bool value);
    public sealed virtual void DynamicInsert(bool value);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void SelectBeforeUpdate(bool value);
    public sealed virtual void Persister();
    public sealed virtual void Synchronize(String[] table);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
}
public class NHibernate.Mapping.ByCode.Impl.CollectionElementRelation : object {
    private Type collectionElementType;
    private Action`1<object> elementRelationshipAssing;
    private HbmMapping mapDoc;
    public CollectionElementRelation(Type collectionElementType, HbmMapping mapDoc, Action`1<object> elementRelationshipAssing);
    public sealed virtual void Element(Action`1<IElementMapper> mapping);
    public sealed virtual void OneToMany(Action`1<IOneToManyMapper> mapping);
    public sealed virtual void ManyToMany(Action`1<IManyToManyMapper> mapping);
    public sealed virtual void Component(Action`1<IComponentElementMapper> mapping);
    public sealed virtual void ManyToAny(Type idTypeOfMetaType, Action`1<IManyToAnyMapper> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.CollectionIdMapper : object {
    private HbmCollectionId hbmId;
    private static string DefaultColumnName;
    private string autosetType;
    public CollectionIdMapper(HbmCollectionId hbmId);
    public sealed virtual void Generator(IGeneratorDef generator);
    public sealed virtual void Generator(IGeneratorDef generator, Action`1<IGeneratorMapper> generatorMapping);
    public sealed virtual void Type(IIdentifierType persistentType);
    public sealed virtual void Column(string name);
    public sealed virtual void Length(int length);
    private void ApplyGenerator(IGeneratorDef generator);
    private void AutosetTypeThroughGeneratorDef(IGeneratorDef generator);
}
public class NHibernate.Mapping.ByCode.Impl.ColumnMapper : object {
    private HbmColumn mapping;
    public ColumnMapper(HbmColumn mapping, string memberName);
    public sealed virtual void Name(string name);
    public sealed virtual void Length(int length);
    public sealed virtual void Precision(short precision);
    public sealed virtual void Scale(short scale);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void UniqueKey(string uniquekeyName);
    public sealed virtual void SqlType(string sqltype);
    public sealed virtual void Index(string indexName);
    public sealed virtual void Check(string checkConstraint);
    public sealed virtual void Default(object defaultValue);
}
public class NHibernate.Mapping.ByCode.Impl.ColumnOrFormulaMapper : ColumnMapper {
    private HbmFormula _formulaMapping;
    public ColumnOrFormulaMapper(HbmColumn columnMapping, string memberName, HbmFormula formulaMapping);
    public sealed virtual void Formula(string formula);
    public static Object[] GetItemsFor(Action`1[] columnOrFormulaMapper, string baseDefaultColumnName);
}
public class NHibernate.Mapping.ByCode.Impl.ComponentAsIdLikeComponentAttributesMapper : object {
    private IComponentAsIdMapper _realMapper;
    public ComponentAsIdLikeComponentAttributesMapper(IComponentAsIdMapper realMapper);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Parent(MemberInfo parent);
    public sealed virtual void Parent(MemberInfo parent, Action`1<IComponentParentMapper> parentMapping);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Lazy(bool isLazy);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void Class(Type componentType);
}
public class NHibernate.Mapping.ByCode.Impl.ComponentAsIdMapper : object {
    private IAccessorPropertyMapper accessorPropertyMapper;
    private HbmCompositeId id;
    private HbmMapping mapDoc;
    public HbmCompositeId CompositeId { get; }
    public ComponentAsIdMapper(Type componentType, MemberInfo declaringTypeMember, HbmCompositeId id, HbmMapping mapDoc);
    public sealed virtual void UnsavedValue(UnsavedValueType unsavedValueType);
    public HbmCompositeId get_CompositeId();
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void Class(Type componentType);
    public sealed virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
    protected void AddProperty(object property);
}
public class NHibernate.Mapping.ByCode.Impl.ComponentElementMapper : object {
    private HbmCompositeElement _component;
    private Type _componentType;
    private HbmMapping _mapDoc;
    private IComponentParentMapper _parentMapper;
    public ComponentElementMapper(Type componentType, HbmMapping mapDoc, HbmCompositeElement component);
    public sealed virtual void Parent(MemberInfo parent);
    public sealed virtual void Parent(MemberInfo parent, Action`1<IComponentParentMapper> parentMapping);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Lazy(bool isLazy);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void Class(Type componentConcreteType);
    public sealed virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void Component(MemberInfo property, Action`1<IComponentElementMapper> mapping);
    public sealed virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    protected void AddProperty(object property);
    private IComponentParentMapper GetParentMapper(MemberInfo parent);
}
public class NHibernate.Mapping.ByCode.Impl.ComponentMapKeyMapper : object {
    private HbmCompositeMapKey component;
    private HbmMapping mapDoc;
    public HbmCompositeMapKey CompositeMapKeyMapping { get; }
    public ComponentMapKeyMapper(Type componentType, HbmCompositeMapKey component, HbmMapping mapDoc);
    public HbmCompositeMapKey get_CompositeMapKeyMapping();
    public sealed virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
    protected void AddProperty(object property);
}
public class NHibernate.Mapping.ByCode.Impl.ComponentMapper : AbstractPropertyContainerMapper {
    private IAccessorPropertyMapper _accessorPropertyMapper;
    private HbmComponent _component;
    private ComponentParentMapper _parentMapper;
    public ComponentMapper(HbmComponent component, Type componentType, MemberInfo declaringTypeMember, HbmMapping mapDoc);
    public ComponentMapper(HbmComponent component, Type componentType, IAccessorPropertyMapper accessorMapper, HbmMapping mapDoc);
    protected virtual void AddProperty(object property);
    public sealed virtual void Parent(MemberInfo parent);
    public sealed virtual void Parent(MemberInfo parent, Action`1<IComponentParentMapper> parentMapping);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Lazy(bool isLazy);
    public void LazyGroup(string name);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void Class(Type componentType);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    private IComponentParentMapper GetParentMapper(MemberInfo parent);
}
public class NHibernate.Mapping.ByCode.Impl.ComponentMappingHandler : MulticastDelegate {
    public ComponentMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IComponentAttributesMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IComponentAttributesMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.ComponentNestedElementMapper : object {
    private IAccessorPropertyMapper _accessorPropertyMapper;
    private HbmNestedCompositeElement _component;
    private Type _componentType;
    private HbmMapping _mapDoc;
    private IComponentParentMapper _parentMapper;
    public ComponentNestedElementMapper(Type componentType, HbmMapping mapDoc, HbmNestedCompositeElement component, MemberInfo declaringComponentMember);
    public sealed virtual void Parent(MemberInfo parent);
    public sealed virtual void Parent(MemberInfo parent, Action`1<IComponentParentMapper> parentMapping);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Lazy(bool isLazy);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void Class(Type componentConcreteType);
    public sealed virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void Component(MemberInfo property, Action`1<IComponentElementMapper> mapping);
    public sealed virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    protected void AddProperty(object property);
    private IComponentParentMapper GetParentMapper(MemberInfo parent);
}
public class NHibernate.Mapping.ByCode.Impl.ComponentParentMapper : object {
    private AccessorPropertyMapper accessorPropertyMapper;
    public ComponentParentMapper(HbmParent parent, MemberInfo member);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
}
public class NHibernate.Mapping.ByCode.Impl.ComposedIdMapper : object {
    private Type container;
    private HbmCompositeId id;
    private HbmMapping mapDoc;
    public HbmCompositeId ComposedId { get; }
    public ComposedIdMapper(Type container, HbmCompositeId id, HbmMapping mapDoc);
    public HbmCompositeId get_ComposedId();
    public sealed virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
    protected void AddProperty(object property);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersHolder : object {
    private Dictionary`2<PropertyPath, List`1<Action`1<IAnyMapper>>> anyCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IBagPropertiesMapper>>> bagCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IIdBagPropertiesMapper>>> idBagCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<ICollectionPropertiesMapper>>> collectionCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IElementMapper>>> collectionRelationElementCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IManyToManyMapper>>> collectionRelationManyToManyCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IManyToAnyMapper>>> collectionRelationManyToAnyCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IOneToManyMapper>>> collectionRelationOneToManyCustomizers;
    private Dictionary`2<Type, List`1<Action`1<IComponentAttributesMapper>>> componentClassCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IComponentAttributesMapper>>> componentPropertyCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IComponentAsIdAttributesMapper>>> componentAsIdPropertyCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IDynamicComponentAttributesMapper>>> dynamicComponentCustomizers;
    private Dictionary`2<Type, List`1<Action`1<IJoinedSubclassAttributesMapper>>> joinedClassCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IListPropertiesMapper>>> listCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IManyToOneMapper>>> manyToOneCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IMapPropertiesMapper>>> mapCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IMapKeyMapper>>> mapKeyElementCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IMapKeyManyToManyMapper>>> mapKeyManyToManyCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IOneToOneMapper>>> oneToOneCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<IPropertyMapper>>> propertyCustomizers;
    private Dictionary`2<Type, List`1<Action`1<IClassMapper>>> rootClassCustomizers;
    private Dictionary`2<PropertyPath, List`1<Action`1<ISetPropertiesMapper>>> setCustomizers;
    private Dictionary`2<Type, List`1<Action`1<ISubclassMapper>>> subclassCustomizers;
    private Dictionary`2<Type, List`1<Action`1<IUnionSubclassAttributesMapper>>> unionClassCustomizers;
    private Dictionary`2<Type, List`1<Action`1<IJoinAttributesMapper>>> joinCustomizers;
    public sealed virtual void AddCustomizer(Type type, Action`1<IClassMapper> classCustomizer);
    public sealed virtual void AddCustomizer(Type type, Action`1<ISubclassMapper> classCustomizer);
    public sealed virtual void AddCustomizer(Type type, Action`1<IJoinedSubclassAttributesMapper> classCustomizer);
    public sealed virtual void AddCustomizer(Type type, Action`1<IUnionSubclassAttributesMapper> classCustomizer);
    public sealed virtual void AddCustomizer(Type type, Action`1<IComponentAttributesMapper> classCustomizer);
    public sealed virtual void AddCustomizer(Type type, Action`1<IJoinAttributesMapper> joinCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IPropertyMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IManyToOneMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IOneToOneMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IAnyMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<ISetPropertiesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IBagPropertiesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IListPropertiesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IMapPropertiesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IIdBagPropertiesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<ICollectionPropertiesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IComponentAttributesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IComponentAsIdAttributesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IDynamicComponentAttributesMapper> propertyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IManyToManyMapper> collectionRelationManyToManyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IElementMapper> collectionRelationElementCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IOneToManyMapper> collectionRelationOneToManyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IManyToAnyMapper> collectionRelationManyToAnyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IMapKeyManyToManyMapper> mapKeyManyToManyCustomizer);
    public sealed virtual void AddCustomizer(PropertyPath member, Action`1<IMapKeyMapper> mapKeyElementCustomizer);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IManyToAnyMapper mapper);
    public sealed virtual IEnumerable`1<Type> GetAllCustomizedEntities();
    public sealed virtual void InvokeCustomizers(Type type, IClassMapper mapper);
    public sealed virtual void InvokeCustomizers(Type type, ISubclassMapper mapper);
    public sealed virtual void InvokeCustomizers(Type type, IJoinedSubclassAttributesMapper mapper);
    public sealed virtual void InvokeCustomizers(Type type, IUnionSubclassAttributesMapper mapper);
    public sealed virtual void InvokeCustomizers(Type type, IComponentAttributesMapper mapper);
    public sealed virtual void InvokeCustomizers(Type type, IJoinAttributesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IPropertyMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IManyToOneMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IOneToOneMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IAnyMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, ISetPropertiesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IBagPropertiesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IListPropertiesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IMapPropertiesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IIdBagPropertiesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IComponentAttributesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IComponentAsIdAttributesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IDynamicComponentAttributesMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IManyToManyMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IElementMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IOneToManyMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IMapKeyManyToManyMapper mapper);
    public sealed virtual void InvokeCustomizers(PropertyPath member, IMapKeyMapper mapper);
    public void Merge(CustomizersHolder source);
    private void MergeDictionary(Dictionary`2<TSubject, List`1<Action`1<TCustomizable>>> destination, Dictionary`2<TSubject, List`1<Action`1<TCustomizable>>> source);
    private void AddCustomizer(IDictionary`2<TSubject, List`1<Action`1<TCustomizable>>> customizers, TSubject member, Action`1<TCustomizable> customizer);
    private void InvokeCustomizers(IDictionary`2<TSubject, List`1<Action`1<TCustomizable>>> customizers, TSubject member, TCustomizable customizable);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.BagPropertiesCustomizer`2 : CollectionPropertiesCustomizer`2<TEntity, TElement> {
    public BagPropertiesCustomizer`2(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.ClassCustomizer`1 : PropertyContainerCustomizer`1<TEntity> {
    private Dictionary`2<string, IJoinMapper`1<TEntity>> joinCustomizers;
    private Dictionary`2<string, IJoinMapper`1<TEntity>> JoinCustomizers { get; }
    private ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.CustomizersHolder { get; }
    private IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.ExplicitDeclarationsHolder { get; }
    public ClassCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder);
    private Dictionary`2<string, IJoinMapper`1<TEntity>> get_JoinCustomizers();
    public sealed virtual void Abstract(bool isAbstract);
    public sealed virtual void OptimisticLock(OptimisticLockMode mode);
    public sealed virtual void Id(Expression`1<Func`2<TEntity, TProperty>> idProperty);
    public sealed virtual void Id(Expression`1<Func`2<TEntity, TProperty>> idProperty, Action`1<IIdMapper> idMapper);
    public sealed virtual void Id(string notVisiblePropertyOrFieldName, Action`1<IIdMapper> idMapper);
    public sealed virtual void ComponentAsId(Expression`1<Func`2<TEntity, TComponent>> idProperty);
    public sealed virtual void ComponentAsId(Expression`1<Func`2<TEntity, TComponent>> idProperty, Action`1<IComponentAsIdMapper`1<TComponent>> idMapper);
    public sealed virtual void ComponentAsId(string notVisiblePropertyOrFieldName);
    public sealed virtual void ComponentAsId(string notVisiblePropertyOrFieldName, Action`1<IComponentAsIdMapper`1<TComponent>> idMapper);
    private void RegisterComponentAsIdMapping(Action`1<IComponentAsIdMapper`1<TComponent>> idMapper, MemberInfo[] members);
    public sealed virtual void ComposedId(Action`1<IComposedIdMapper`1<TEntity>> idPropertiesMapping);
    public sealed virtual void Discriminator(Action`1<IDiscriminatorMapper> discriminatorMapping);
    public sealed virtual void DiscriminatorValue(object value);
    public sealed virtual void Table(string tableName);
    public void Check(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Polymorphism(PolymorphismType type);
    public sealed virtual void Mutable(bool isMutable);
    public sealed virtual void Version(Expression`1<Func`2<TEntity, TProperty>> versionProperty, Action`1<IVersionMapper> versionMapping);
    public sealed virtual void Version(string notVisiblePropertyOrFieldName, Action`1<IVersionMapper> versionMapping);
    public sealed virtual void NaturalId(Action`1<IBasePlainPropertyContainerMapper`1<TEntity>> naturalIdPropertiesMapping, Action`1<INaturalIdAttributesMapper> naturalIdMapping);
    public sealed virtual void NaturalId(Action`1<IBasePlainPropertyContainerMapper`1<TEntity>> naturalIdPropertiesMapping);
    public sealed virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public sealed virtual void Where(string whereClause);
    public sealed virtual void SchemaAction(SchemaAction action);
    public sealed virtual void Join(string splitGroupId, Action`1<IJoinMapper`1<TEntity>> splitMapping);
    public sealed virtual void EntityName(string value);
    public sealed virtual void Proxy(Type proxy);
    public sealed virtual void Lazy(bool value);
    public sealed virtual void DynamicUpdate(bool value);
    public sealed virtual void DynamicInsert(bool value);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void SelectBeforeUpdate(bool value);
    public sealed virtual void Persister();
    public sealed virtual void Synchronize(String[] table);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    private sealed virtual override ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_CustomizersHolder();
    private sealed virtual override IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_ExplicitDeclarationsHolder();
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.CollectionElementCustomizer : object {
    private PropertyPath propertyPath;
    [CompilerGeneratedAttribute]
private ICustomizersHolder <CustomizersHolder>k__BackingField;
    public ICustomizersHolder CustomizersHolder { get; private set; }
    public CollectionElementCustomizer(PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    [CompilerGeneratedAttribute]
public ICustomizersHolder get_CustomizersHolder();
    [CompilerGeneratedAttribute]
private void set_CustomizersHolder(ICustomizersHolder value);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void Type(IType persistentType);
    public sealed virtual void Type();
    public sealed virtual void Type(object parameters);
    public sealed virtual void Type(Type persistentType, object parameters);
    public sealed virtual void Length(int length);
    public sealed virtual void Precision(short precision);
    public sealed virtual void Scale(short scale);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void Formula(string formula);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.CollectionElementRelationCustomizer`1 : object {
    private ICustomizersHolder customizersHolder;
    private IModelExplicitDeclarationsHolder explicitDeclarationsHolder;
    private PropertyPath propertyPath;
    public CollectionElementRelationCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Element();
    public sealed virtual void Element(Action`1<IElementMapper> mapping);
    public sealed virtual void OneToMany();
    public sealed virtual void OneToMany(Action`1<IOneToManyMapper> mapping);
    public sealed virtual void ManyToMany();
    public sealed virtual void ManyToMany(Action`1<IManyToManyMapper> mapping);
    public sealed virtual void Component(Action`1<IComponentElementMapper`1<TElement>> mapping);
    public sealed virtual void ManyToAny(Type idTypeOfMetaType, Action`1<IManyToAnyMapper> mapping);
    public sealed virtual void ManyToAny(Action`1<IManyToAnyMapper> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.CollectionKeyCustomizer`1 : object {
    private PropertyPath propertyPath;
    [CompilerGeneratedAttribute]
private ICustomizersHolder <CustomizersHolder>k__BackingField;
    public ICustomizersHolder CustomizersHolder { get; private set; }
    public CollectionKeyCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    [CompilerGeneratedAttribute]
public ICustomizersHolder get_CustomizersHolder();
    [CompilerGeneratedAttribute]
private void set_CustomizersHolder(ICustomizersHolder value);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string columnName);
    public sealed virtual void OnDelete(OnDeleteAction deleteAction);
    public sealed virtual void PropertyRef(Expression`1<Func`2<TEntity, TProperty>> propertyGetter);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.CollectionPropertiesCustomizer`2 : object {
    private IKeyMapper`1<TEntity> keyMapper;
    [CompilerGeneratedAttribute]
private ICustomizersHolder <CustomizersHolder>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyPath <PropertyPath>k__BackingField;
    public ICustomizersHolder CustomizersHolder { get; private set; }
    public PropertyPath PropertyPath { get; private set; }
    public CollectionPropertiesCustomizer`2(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    [CompilerGeneratedAttribute]
public ICustomizersHolder get_CustomizersHolder();
    [CompilerGeneratedAttribute]
private void set_CustomizersHolder(ICustomizersHolder value);
    [CompilerGeneratedAttribute]
public PropertyPath get_PropertyPath();
    [CompilerGeneratedAttribute]
private void set_PropertyPath(PropertyPath value);
    public sealed virtual void Inverse(bool value);
    public sealed virtual void Mutable(bool value);
    public sealed virtual void Where(string sqlWhereClause);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void Lazy(CollectionLazy collectionLazy);
    public sealed virtual void Key(Action`1<IKeyMapper`1<TEntity>> keyMapping);
    public sealed virtual void OrderBy(Expression`1<Func`2<TElement, TProperty>> property);
    public sealed virtual void OrderBy(string sqlOrderByClause);
    public sealed virtual void Sort();
    public sealed virtual void Sort();
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void Type();
    public sealed virtual void Type(Type collectionType);
    public void Type(string collectionType);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public sealed virtual void Fetch(CollectionFetchMode fetchMode);
    public sealed virtual void Persister();
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDeleteAll(string sql);
    public sealed virtual void SqlDeleteAll(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.ComponentAsIdCustomizer`1 : PropertyContainerCustomizer`1<TComponent> {
    public ComponentAsIdCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder, PropertyPath propertyPath);
    public sealed virtual void UnsavedValue(UnsavedValueType unsavedValueType);
    public sealed virtual void Class();
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.ComponentCustomizer`1 : PropertyContainerCustomizer`1<TComponent> {
    private ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.CustomizersHolder { get; }
    private IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.ExplicitDeclarationsHolder { get; }
    public ComponentCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder);
    public ComponentCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder, PropertyPath propertyPath);
    public sealed virtual void Parent(Expression`1<Func`2<TComponent, TProperty>> parent);
    public sealed virtual void Parent(string notVisiblePropertyOrFieldName, Action`1<IComponentParentMapper> parentMapping);
    public sealed virtual void Parent(Expression`1<Func`2<TComponent, TProperty>> parent, Action`1<IComponentParentMapper> parentMapping);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Lazy(bool isLazy);
    public void LazyGroup(string name);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void Class();
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    private void AddCustomizer(Action`1<IComponentAttributesMapper> classCustomizer);
    private sealed virtual override ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_CustomizersHolder();
    private sealed virtual override IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_ExplicitDeclarationsHolder();
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.ComponentElementCustomizer`1 : object {
    private ICustomizersHolder _customizersHolder;
    private IModelExplicitDeclarationsHolder _explicitDeclarationsHolder;
    private PropertyPath _propertyPath;
    public ComponentElementCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Parent(string notVisiblePropertyOrFieldName, Action`1<IComponentParentMapper> parentMapping);
    public sealed virtual void Parent(Expression`1<Func`2<TComponent, TProperty>> parent);
    public sealed virtual void Parent(Expression`1<Func`2<TComponent, TProperty>> parent, Action`1<IComponentParentMapper> parentMapping);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Lazy(bool isLazy);
    public void LazyGroup(string name);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void Class();
    public sealed virtual void Property(string notVisiblePropertyOrFieldName, Action`1<IPropertyMapper> mapping);
    public static MemberInfo GetPropertyOrFieldMatchingNameOrThrow(string memberName);
    public sealed virtual void Property(Expression`1<Func`2<TComponent, TProperty>> property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void Property(Expression`1<Func`2<TComponent, TProperty>> property);
    public sealed virtual void Component(Expression`1<Func`2<TComponent, TNestedComponent>> property, Action`1<IComponentElementMapper`1<TNestedComponent>> mapping);
    public sealed virtual void Component(string notVisiblePropertyOrFieldName, Action`1<IComponentElementMapper`1<TNestedComponent>> mapping);
    public sealed virtual void ManyToOne(Expression`1<Func`2<TComponent, TProperty>> property, Action`1<IManyToOneMapper> mapping);
    public sealed virtual void ManyToOne(Expression`1<Func`2<TComponent, TProperty>> property);
    public sealed virtual void ManyToOne(string notVisiblePropertyOrFieldName, Action`1<IManyToOneMapper> mapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.ComposedIdCustomizer`1 : PropertyContainerCustomizer`1<TEntity> {
    public ComposedIdCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder);
    protected virtual void RegisterPropertyMapping(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IPropertyMapper> mapping);
    protected virtual void RegisterManyToOneMapping(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IManyToOneMapper> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.DynamicComponentCustomizer`1 : PropertyContainerCustomizer`1<TComponent> {
    private Type _componentType;
    public DynamicComponentCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder, PropertyPath propertyPath);
    internal DynamicComponentCustomizer`1(Type componentType, IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder, PropertyPath propertyPath);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Unique(bool unique);
    protected virtual MemberInfo GetRequiredPropertyOrFieldByName(string memberName);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.IdBagPropertiesCustomizer`2 : CollectionPropertiesCustomizer`2<TEntity, TElement> {
    public IdBagPropertiesCustomizer`2(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Id(Action`1<ICollectionIdMapper> idMapping);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.JoinCustomizer`1 : PropertyContainerCustomizer`1<TEntity> {
    private string splitGroupId;
    private IKeyMapper`1<TEntity> keyMapper;
    public JoinCustomizer`1(string splitGroupId, IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Key(Action`1<IKeyMapper`1<TEntity>> keyMapping);
    public sealed virtual void Inverse(bool value);
    public sealed virtual void Optional(bool isOptional);
    public sealed virtual void Fetch(FetchKind fetchMode);
    protected virtual void RegisterSetMapping(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected virtual void RegisterBagMapping(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected virtual void RegisterListMapping(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected virtual void RegisterMapMapping(Expression`1<Func`2<TEntity, IDictionary`2<TKey, TElement>>> property, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<IMapKeyRelation`1<TKey>> keyMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected virtual void RegisterPropertyMapping(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IPropertyMapper> mapping);
    protected virtual void RegisterNoVisiblePropertyMapping(string notVisiblePropertyOrFieldName, Action`1<IPropertyMapper> mapping);
    protected virtual void RegisterComponentMapping(Expression`1<Func`2<TEntity, TComponent>> property, Action`1<IComponentMapper`1<TComponent>> mapping);
    protected virtual void RegisterDynamicComponentMapping(Expression`1<Func`2<TEntity, IDictionary>> property, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    protected virtual void RegisterDynamicComponentMapping(Expression`1<Func`2<TEntity, IDictionary`2<string, object>>> property, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    protected virtual void RegisterManyToOneMapping(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IManyToOneMapper> mapping);
    protected virtual void RegisterAnyMapping(Expression`1<Func`2<TEntity, TProperty>> property, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
    protected virtual void RegisterIdBagMapping(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.JoinedSubclassCustomizer`1 : PropertyContainerCustomizer`1<TEntity> {
    private IKeyMapper`1<TEntity> keyMapper;
    private ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.CustomizersHolder { get; }
    private IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.ExplicitDeclarationsHolder { get; }
    public JoinedSubclassCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder);
    public sealed virtual void Key(Action`1<IKeyMapper`1<TEntity>> keyMapping);
    public sealed virtual void SchemaAction(SchemaAction action);
    public sealed virtual void EntityName(string value);
    public sealed virtual void Proxy(Type proxy);
    public sealed virtual void Lazy(bool value);
    public sealed virtual void DynamicUpdate(bool value);
    public sealed virtual void DynamicInsert(bool value);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void SelectBeforeUpdate(bool value);
    public sealed virtual void Persister();
    public sealed virtual void Synchronize(String[] table);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    public sealed virtual void Extends(Type baseType);
    public void Extends(string entityOrClassName);
    public sealed virtual void Abstract(bool isAbstract);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    private sealed virtual override ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_CustomizersHolder();
    private sealed virtual override IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_ExplicitDeclarationsHolder();
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.JoinedSubclassKeyCustomizer`1 : object {
    [CompilerGeneratedAttribute]
private ICustomizersHolder <CustomizersHolder>k__BackingField;
    public ICustomizersHolder CustomizersHolder { get; private set; }
    public JoinedSubclassKeyCustomizer`1(ICustomizersHolder customizersHolder);
    [CompilerGeneratedAttribute]
public ICustomizersHolder get_CustomizersHolder();
    [CompilerGeneratedAttribute]
private void set_CustomizersHolder(ICustomizersHolder value);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string columnName);
    public sealed virtual void OnDelete(OnDeleteAction deleteAction);
    public sealed virtual void PropertyRef(Expression`1<Func`2<TEntity, TProperty>> propertyGetter);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.JoinKeyCustomizer`1 : object {
    [CompilerGeneratedAttribute]
private ICustomizersHolder <CustomizersHolder>k__BackingField;
    public ICustomizersHolder CustomizersHolder { get; private set; }
    public JoinKeyCustomizer`1(ICustomizersHolder customizersHolder);
    [CompilerGeneratedAttribute]
public ICustomizersHolder get_CustomizersHolder();
    [CompilerGeneratedAttribute]
private void set_CustomizersHolder(ICustomizersHolder value);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string columnName);
    public sealed virtual void OnDelete(OnDeleteAction deleteAction);
    public sealed virtual void PropertyRef(Expression`1<Func`2<TEntity, TProperty>> propertyGetter);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.ListPropertiesCustomizer`2 : CollectionPropertiesCustomizer`2<TEntity, TElement> {
    public ListPropertiesCustomizer`2(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Index(Action`1<IListIndexMapper> listIndexMapping);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.ManyToAnyCustomizer : object {
    private ICustomizersHolder customizersHolder;
    private PropertyPath propertyPath;
    public ManyToAnyCustomizer(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void MetaType(IType metaType);
    public sealed virtual void MetaType();
    public sealed virtual void MetaType(Type metaType);
    public sealed virtual void IdType(IType idType);
    public sealed virtual void IdType();
    public sealed virtual void IdType(Type idType);
    public sealed virtual void Columns(Action`1<IColumnMapper> idColumnMapping, Action`1<IColumnMapper> classColumnMapping);
    public sealed virtual void MetaValue(object value, Type entityType);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.ManyToManyCustomizer : object {
    private ICustomizersHolder customizersHolder;
    private PropertyPath propertyPath;
    public ManyToManyCustomizer(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void Class(Type entityType);
    public sealed virtual void EntityName(string entityName);
    public sealed virtual void NotFound(NotFoundMode mode);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Lazy(LazyRelation lazyRelation);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void Where(string sqlWhereClause);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.MapKeyComponentCustomizer`1 : object {
    private ICustomizersHolder customizersHolder;
    private PropertyPath propertyPath;
    public MapKeyComponentCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Property(Expression`1<Func`2<TKey, TProperty>> property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void Property(Expression`1<Func`2<TKey, TProperty>> property);
    public sealed virtual void ManyToOne(Expression`1<Func`2<TKey, TProperty>> property, Action`1<IManyToOneMapper> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.MapKeyCustomizer : object {
    private ICustomizersHolder customizersHolder;
    private PropertyPath propertyPath;
    public MapKeyCustomizer(PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void Type(IType persistentType);
    public sealed virtual void Type();
    public sealed virtual void Type(Type persistentType);
    public sealed virtual void Length(int length);
    public sealed virtual void Formula(string formula);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.MapKeyManyToManyCustomizer : object {
    private ICustomizersHolder customizersHolder;
    private PropertyPath propertyPath;
    public MapKeyManyToManyCustomizer(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void Formula(string formula);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.MapKeyRelationCustomizer`1 : object {
    private ICustomizersHolder customizersHolder;
    private IModelExplicitDeclarationsHolder explicitDeclarationsHolder;
    private PropertyPath propertyPath;
    public MapKeyRelationCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Element();
    public sealed virtual void Element(Action`1<IMapKeyMapper> mapping);
    public sealed virtual void ManyToMany();
    public sealed virtual void ManyToMany(Action`1<IMapKeyManyToManyMapper> mapping);
    public sealed virtual void Component(Action`1<IComponentMapKeyMapper`1<TKey>> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.MapPropertiesCustomizer`3 : CollectionPropertiesCustomizer`2<TEntity, TElement> {
    public MapPropertiesCustomizer`3(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.NaturalIdCustomizer`1 : PropertyContainerCustomizer`1<TEntity> {
    public NaturalIdCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder);
    protected virtual void RegisterPropertyMapping(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IPropertyMapper> mapping);
    protected virtual void RegisterNoVisiblePropertyMapping(string notVisiblePropertyOrFieldName, Action`1<IPropertyMapper> mapping);
    protected virtual void RegisterComponentMapping(Expression`1<Func`2<TEntity, TComponent>> property, Action`1<IComponentMapper`1<TComponent>> mapping);
    protected virtual void RegisterAnyMapping(Expression`1<Func`2<TEntity, TProperty>> property, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
    protected virtual void RegisterManyToOneMapping(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IManyToOneMapper> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.OneToManyCustomizer : object {
    private ICustomizersHolder customizersHolder;
    private PropertyPath propertyPath;
    public OneToManyCustomizer(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
    public sealed virtual void Class(Type entityType);
    public sealed virtual void EntityName(string entityName);
    public sealed virtual void NotFound(NotFoundMode mode);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.PropertyContainerCustomizer`1 : object {
    private IModelExplicitDeclarationsHolder explicitDeclarationsHolder;
    [CompilerGeneratedAttribute]
private ICustomizersHolder <CustomizersHolder>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyPath <PropertyPath>k__BackingField;
    protected internal ICustomizersHolder CustomizersHolder { get; private set; }
    protected internal PropertyPath PropertyPath { get; private set; }
    protected internal IModelExplicitDeclarationsHolder ExplicitDeclarationsHolder { get; }
    public PropertyContainerCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder, PropertyPath propertyPath);
    [CompilerGeneratedAttribute]
protected internal ICustomizersHolder get_CustomizersHolder();
    [CompilerGeneratedAttribute]
private void set_CustomizersHolder(ICustomizersHolder value);
    [CompilerGeneratedAttribute]
protected internal PropertyPath get_PropertyPath();
    [CompilerGeneratedAttribute]
private void set_PropertyPath(PropertyPath value);
    protected internal IModelExplicitDeclarationsHolder get_ExplicitDeclarationsHolder();
    public sealed virtual void Property(Expression`1<Func`2<TEntity, TProperty>> property);
    public sealed virtual void Property(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IPropertyMapper> mapping);
    protected virtual void RegisterPropertyMapping(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void Property(string notVisiblePropertyOrFieldName, Action`1<IPropertyMapper> mapping);
    protected virtual void RegisterNoVisiblePropertyMapping(string notVisiblePropertyOrFieldName, Action`1<IPropertyMapper> mapping);
    protected void RegistePropertyMapping(Action`1<IPropertyMapper> mapping, MemberInfo[] members);
    public sealed virtual void Component(Expression`1<Func`2<TEntity, TComponent>> property, Action`1<IComponentMapper`1<TComponent>> mapping);
    public sealed virtual void Component(Expression`1<Func`2<TEntity, TComponent>> property);
    protected virtual void RegisterComponentMapping(Expression`1<Func`2<TEntity, TComponent>> property, Action`1<IComponentMapper`1<TComponent>> mapping);
    protected void RegisterComponentMapping(Action`1<IComponentMapper`1<TComponent>> mapping, MemberInfo[] members);
    public sealed virtual void Component(Expression`1<Func`2<TEntity, IDictionary>> property, TComponent dynamicComponentTemplate, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    public void Component(Expression`1<Func`2<TEntity, IDictionary`2<string, object>>> property, TComponent dynamicComponentTemplate, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    protected virtual void RegisterDynamicComponentMapping(Expression`1<Func`2<TEntity, IDictionary>> property, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    protected virtual void RegisterDynamicComponentMapping(Expression`1<Func`2<TEntity, IDictionary>> property, Type componentType, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    protected virtual void RegisterDynamicComponentMapping(Expression`1<Func`2<TEntity, IDictionary`2<string, object>>> property, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    protected virtual void RegisterDynamicComponentMapping(Expression`1<Func`2<TEntity, IDictionary`2<string, object>>> property, Type componentType, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    protected void RegisterDynamicComponentMapping(Type componentType, Action`1<IDynamicComponentMapper`1<TComponent>> mapping, MemberInfo[] members);
    protected void RegisterDynamicComponentMapping(Action`1<IDynamicComponentMapper`1<TComponent>> mapping, MemberInfo[] members);
    private static Type CreateDynamicComponentTypeFromTemplate(IEnumerable`1<KeyValuePair`2<string, Type>> template);
    public sealed virtual void ManyToOne(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IManyToOneMapper> mapping);
    protected virtual void RegisterManyToOneMapping(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IManyToOneMapper> mapping);
    protected void RegisterManyToOneMapping(Action`1<IManyToOneMapper> mapping, MemberInfo[] members);
    public sealed virtual void ManyToOne(Expression`1<Func`2<TEntity, TProperty>> property);
    public sealed virtual void OneToOne(Expression`1<Func`2<TEntity, TProperty>> property, Action`1<IOneToOneMapper`1<TProperty>> mapping);
    public sealed virtual void OneToOne(string notVisiblePropertyOrFieldName, Action`1<IOneToOneMapper`1<TProperty>> mapping);
    protected void RegisterOneToOneMapping(Action`1<IOneToOneMapper`1<TProperty>> mapping, MemberInfo[] members);
    public sealed virtual void Any(Expression`1<Func`2<TEntity, TProperty>> property, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
    protected virtual void RegisterAnyMapping(Expression`1<Func`2<TEntity, TProperty>> property, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
    protected void RegisterAnyMapping(Action`1<IAnyMapper> mapping, Type idTypeOfMetaType, MemberInfo[] members);
    public sealed virtual void Set(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void Set(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    protected virtual void RegisterSetMapping(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected void RegisterSetMapping(Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping, MemberInfo[] members);
    public sealed virtual void Bag(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void Bag(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    protected virtual void RegisterBagMapping(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected void RegisterBagMapping(Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping, MemberInfo[] members);
    public sealed virtual void List(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void List(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    protected virtual void RegisterListMapping(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected void RegisterListMapping(Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping, MemberInfo[] members);
    public sealed virtual void Map(Expression`1<Func`2<TEntity, IDictionary`2<TKey, TElement>>> property, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<IMapKeyRelation`1<TKey>> keyMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void Map(Expression`1<Func`2<TEntity, IDictionary`2<TKey, TElement>>> property, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping);
    protected virtual void RegisterMapMapping(Expression`1<Func`2<TEntity, IDictionary`2<TKey, TElement>>> property, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<IMapKeyRelation`1<TKey>> keyMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected virtual void RegisterMapMapping(Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<IMapKeyRelation`1<TKey>> keyMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping, MemberInfo[] members);
    public sealed virtual void Map(Expression`1<Func`2<TEntity, IDictionary`2<TKey, TElement>>> property, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void IdBag(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void IdBag(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    protected virtual void RegisterIdBagMapping(Expression`1<Func`2<TEntity, IEnumerable`1<TElement>>> property, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    protected virtual void RegisterIdBagMapping(Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping, MemberInfo[] members);
    public sealed virtual void Set(string notVisiblePropertyOrFieldName, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    private static void AssertCollectionElementType(string propertyOrFieldName, MemberInfo memberInfo);
    public sealed virtual void Set(string notVisiblePropertyOrFieldName, Action`1<ISetPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public sealed virtual void Bag(string notVisiblePropertyOrFieldName, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void Bag(string notVisiblePropertyOrFieldName, Action`1<IBagPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public sealed virtual void List(string notVisiblePropertyOrFieldName, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void List(string notVisiblePropertyOrFieldName, Action`1<IListPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public sealed virtual void Map(string notVisiblePropertyOrFieldName, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<IMapKeyRelation`1<TKey>> keyMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void Map(string notVisiblePropertyOrFieldName, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void Map(string notVisiblePropertyOrFieldName, Action`1<IMapPropertiesMapper`3<TEntity, TKey, TElement>> collectionMapping);
    public sealed virtual void IdBag(string notVisiblePropertyOrFieldName, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping, Action`1<ICollectionElementRelation`1<TElement>> mapping);
    public sealed virtual void IdBag(string notVisiblePropertyOrFieldName, Action`1<IIdBagPropertiesMapper`2<TEntity, TElement>> collectionMapping);
    public sealed virtual void ManyToOne(string notVisiblePropertyOrFieldName, Action`1<IManyToOneMapper> mapping);
    public sealed virtual void Component(string notVisiblePropertyOrFieldName, Action`1<IComponentMapper`1<TComponent>> mapping);
    public sealed virtual void Component(string notVisiblePropertyOrFieldName);
    public sealed virtual void Component(string notVisiblePropertyOrFieldName, TComponent dynamicComponentTemplate, Action`1<IDynamicComponentMapper`1<TComponent>> mapping);
    public sealed virtual void Any(string notVisiblePropertyOrFieldName, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
    protected virtual MemberInfo GetRequiredPropertyOrFieldByName(string memberName);
    [ObsoleteAttribute("Please use GetRequiredPropertyOrFieldByName instead.")]
public static MemberInfo GetPropertyOrFieldMatchingNameOrThrow(string memberName);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.SetPropertiesCustomizer`2 : CollectionPropertiesCustomizer`2<TEntity, TElement> {
    public SetPropertiesCustomizer`2(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, PropertyPath propertyPath, ICustomizersHolder customizersHolder);
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.SubclassCustomizer`1 : PropertyContainerCustomizer`1<TEntity> {
    private Dictionary`2<string, IJoinMapper`1<TEntity>> joinCustomizers;
    private Dictionary`2<string, IJoinMapper`1<TEntity>> JoinCustomizers { get; }
    private ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.CustomizersHolder { get; }
    private IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.ExplicitDeclarationsHolder { get; }
    public SubclassCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder);
    public sealed virtual void Extends(Type baseType);
    public void Extends(string entityOrClassName);
    public sealed virtual void Abstract(bool isAbstract);
    public sealed virtual void DiscriminatorValue(object value);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    private Dictionary`2<string, IJoinMapper`1<TEntity>> get_JoinCustomizers();
    public sealed virtual void Join(string splitGroupId, Action`1<IJoinMapper`1<TEntity>> splitMapping);
    public sealed virtual void EntityName(string value);
    public sealed virtual void Proxy(Type proxy);
    public sealed virtual void Lazy(bool value);
    public sealed virtual void DynamicUpdate(bool value);
    public sealed virtual void DynamicInsert(bool value);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void SelectBeforeUpdate(bool value);
    public sealed virtual void Persister();
    public sealed virtual void Synchronize(String[] table);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    private sealed virtual override ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_CustomizersHolder();
    private sealed virtual override IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_ExplicitDeclarationsHolder();
}
public class NHibernate.Mapping.ByCode.Impl.CustomizersImpl.UnionSubclassCustomizer`1 : PropertyContainerCustomizer`1<TEntity> {
    private ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.CustomizersHolder { get; }
    private IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.ExplicitDeclarationsHolder { get; }
    public UnionSubclassCustomizer`1(IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizersHolder);
    public sealed virtual void EntityName(string value);
    public sealed virtual void Proxy(Type proxy);
    public sealed virtual void Lazy(bool value);
    public sealed virtual void DynamicUpdate(bool value);
    public sealed virtual void DynamicInsert(bool value);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void SelectBeforeUpdate(bool value);
    public sealed virtual void Persister();
    public sealed virtual void Synchronize(String[] table);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    public sealed virtual void Extends(Type baseType);
    public void Extends(string entityOrClassName);
    public sealed virtual void Abstract(bool isAbstract);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    private sealed virtual override ICustomizersHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_CustomizersHolder();
    private sealed virtual override IModelExplicitDeclarationsHolder NHibernate.Mapping.ByCode.IConformistHoldersProvider.get_ExplicitDeclarationsHolder();
}
public class NHibernate.Mapping.ByCode.Impl.DefaultCandidatePersistentMembersProvider : object {
    internal static BindingFlags SubClassPropertiesBindingFlags;
    internal static BindingFlags RootClassPropertiesBindingFlags;
    internal static BindingFlags ComponentPropertiesBindingFlags;
    internal static BindingFlags ClassFieldsBindingFlags;
    public sealed virtual IEnumerable`1<MemberInfo> GetEntityMembersForPoid(Type entityClass);
    public sealed virtual IEnumerable`1<MemberInfo> GetRootEntityMembers(Type entityClass);
    public sealed virtual IEnumerable`1<MemberInfo> GetSubEntityMembers(Type entityClass, Type entitySuperclass);
    protected IEnumerable`1<FieldInfo> GetUserDeclaredFields(Type type);
    public sealed virtual IEnumerable`1<MemberInfo> GetComponentMembers(Type componentClass);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.Impl.DefaultCandidatePersistentMembersProvider/<GetFieldsOfHierarchy>d__9")]
private IEnumerable`1<MemberInfo> GetFieldsOfHierarchy(Type type);
    private IEnumerable`1<MemberInfo> GetCandidatePersistentProperties(Type type, BindingFlags propertiesBindingFlags);
}
public class NHibernate.Mapping.ByCode.Impl.DiscriminatorMapper : object {
    private HbmDiscriminator discriminatorMapping;
    public DiscriminatorMapper(HbmDiscriminator discriminatorMapping);
    public sealed virtual void Column(string column);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Type(IType persistentType);
    public sealed virtual void Type(IDiscriminatorType persistentType);
    public sealed virtual void Type();
    public sealed virtual void Type(Type persistentType);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Force(bool force);
    public sealed virtual void Insert(bool applyOnInsert);
    public sealed virtual void NotNullable(bool isNotNullable);
    public sealed virtual void Length(int length);
    private bool ColumnTagIsRequired(HbmColumn hbm);
    private void ResetColumnPlainValues();
}
public class NHibernate.Mapping.ByCode.Impl.DynamicComponentMapper : object {
    private HbmDynamicComponent component;
    private IAccessorPropertyMapper accessorPropertyMapper;
    [CompilerGeneratedAttribute]
private Type <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private HbmMapping <MapDoc>k__BackingField;
    private Type Container { get; private set; }
    private HbmMapping MapDoc { get; private set; }
    public DynamicComponentMapper(HbmDynamicComponent component, MemberInfo declaringTypeMember, HbmMapping mapDoc);
    private DynamicComponentMapper(HbmDynamicComponent component, MemberInfo declaringTypeMember, IAccessorPropertyMapper accessorMapper, HbmMapping mapDoc);
    [CompilerGeneratedAttribute]
private Type get_Container();
    [CompilerGeneratedAttribute]
private void set_Container(Type value);
    [CompilerGeneratedAttribute]
private HbmMapping get_MapDoc();
    [CompilerGeneratedAttribute]
private void set_MapDoc(HbmMapping value);
    protected void AddProperty(object property);
    public sealed virtual void Property(MemberInfo property, Action`1<IPropertyMapper> mapping);
    public sealed virtual void Component(MemberInfo property, Action`1<IComponentMapper> mapping);
    public sealed virtual void Component(MemberInfo property, Action`1<IDynamicComponentMapper> mapping);
    public sealed virtual void ManyToOne(MemberInfo property, Action`1<IManyToOneMapper> mapping);
    public sealed virtual void Any(MemberInfo property, Type idTypeOfMetaType, Action`1<IAnyMapper> mapping);
    public sealed virtual void OneToOne(MemberInfo property, Action`1<IOneToOneMapper> mapping);
    public sealed virtual void Bag(MemberInfo property, Action`1<IBagPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public sealed virtual void Set(MemberInfo property, Action`1<ISetPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public sealed virtual void List(MemberInfo property, Action`1<IListPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public sealed virtual void Map(MemberInfo property, Action`1<IMapPropertiesMapper> collectionMapping, Action`1<IMapKeyRelation> keyMapping, Action`1<ICollectionElementRelation> mapping);
    public sealed virtual void IdBag(MemberInfo property, Action`1<IIdBagPropertiesMapper> collectionMapping, Action`1<ICollectionElementRelation> mapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Unique(bool unique);
}
public class NHibernate.Mapping.ByCode.Impl.ElementMapper : object {
    private static string DefaultColumnName;
    private HbmElement elementMapping;
    private Type elementType;
    public ElementMapper(Type elementType, HbmElement elementMapping);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    private bool ColumnTagIsRequired(HbmColumn hbm);
    private void ResetColumnPlainValues();
    public sealed virtual void ColumnsAndFormulas(Action`1[] columnOrFormulaMapper);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Formulas(String[] formulas);
    public sealed virtual void Type(IType persistentType);
    public sealed virtual void Type();
    public sealed virtual void Type(object parameters);
    public sealed virtual void Type(Type persistentType, object parameters);
    public sealed virtual void Length(int length);
    public sealed virtual void Precision(short precision);
    public sealed virtual void Scale(short scale);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
}
public class NHibernate.Mapping.ByCode.Impl.ElementMappingHandler : MulticastDelegate {
    public ElementMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IElementMapper collectionRelationElementCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IElementMapper collectionRelationElementCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.ExplicitDeclarationsHolder : object {
    private HashSet`1<MemberInfo> any;
    private HashSet`1<MemberInfo> arrays;
    private HashSet`1<MemberInfo> bags;
    private HashSet`1<Type> components;
    private HashSet`1<MemberInfo> dictionaries;
    private HashSet`1<MemberInfo> idBags;
    private HashSet`1<MemberInfo> lists;
    private HashSet`1<MemberInfo> keyManyToManyRelations;
    private HashSet`1<MemberInfo> itemManyToManyRelations;
    private HashSet`1<MemberInfo> manyToOneRelations;
    private HashSet`1<MemberInfo> manyToAnyRelations;
    private HashSet`1<MemberInfo> naturalIds;
    private HashSet`1<MemberInfo> oneToManyRelations;
    private HashSet`1<MemberInfo> oneToOneRelations;
    private HashSet`1<MemberInfo> poids;
    private HashSet`1<MemberInfo> composedIds;
    private HashSet`1<MemberInfo> properties;
    private HashSet`1<MemberInfo> dynamicComponents;
    private Dictionary`2<MemberInfo, Type> dynamicComponentTemplates;
    private HashSet`1<MemberInfo> persistentMembers;
    private HashSet`1<Type> rootEntities;
    private HashSet`1<MemberInfo> sets;
    private HashSet`1<SplitDefinition> splitDefinitions;
    private HashSet`1<Type> tablePerClassEntities;
    private HashSet`1<Type> tablePerClassHierarchyEntities;
    private HashSet`1<Type> tablePerConcreteClassEntities;
    private HashSet`1<MemberInfo> versionProperties;
    public IEnumerable`1<Type> RootEntities { get; }
    public IEnumerable`1<Type> Components { get; }
    public IEnumerable`1<Type> TablePerClassEntities { get; }
    public IEnumerable`1<Type> TablePerClassHierarchyEntities { get; }
    public IEnumerable`1<Type> TablePerConcreteClassEntities { get; }
    public IEnumerable`1<MemberInfo> OneToOneRelations { get; }
    public IEnumerable`1<MemberInfo> ManyToOneRelations { get; }
    public IEnumerable`1<MemberInfo> KeyManyToManyRelations { get; }
    public IEnumerable`1<MemberInfo> ItemManyToManyRelations { get; }
    public IEnumerable`1<MemberInfo> OneToManyRelations { get; }
    public IEnumerable`1<MemberInfo> ManyToAnyRelations { get; }
    public IEnumerable`1<MemberInfo> Any { get; }
    public IEnumerable`1<MemberInfo> Poids { get; }
    public IEnumerable`1<MemberInfo> ComposedIds { get; }
    public IEnumerable`1<MemberInfo> VersionProperties { get; }
    public IEnumerable`1<MemberInfo> NaturalIds { get; }
    public IEnumerable`1<MemberInfo> Sets { get; }
    public IEnumerable`1<MemberInfo> Bags { get; }
    public IEnumerable`1<MemberInfo> IdBags { get; }
    public IEnumerable`1<MemberInfo> Lists { get; }
    public IEnumerable`1<MemberInfo> Arrays { get; }
    public IEnumerable`1<MemberInfo> Dictionaries { get; }
    public IEnumerable`1<MemberInfo> Properties { get; }
    public IEnumerable`1<MemberInfo> DynamicComponents { get; }
    public IEnumerable`1<MemberInfo> PersistentMembers { get; }
    public IEnumerable`1<SplitDefinition> SplitDefinitions { get; }
    public sealed virtual IEnumerable`1<Type> get_RootEntities();
    public sealed virtual IEnumerable`1<Type> get_Components();
    public sealed virtual IEnumerable`1<Type> get_TablePerClassEntities();
    public sealed virtual IEnumerable`1<Type> get_TablePerClassHierarchyEntities();
    public sealed virtual IEnumerable`1<Type> get_TablePerConcreteClassEntities();
    public sealed virtual IEnumerable`1<MemberInfo> get_OneToOneRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ManyToOneRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_KeyManyToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ItemManyToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_OneToManyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_ManyToAnyRelations();
    public sealed virtual IEnumerable`1<MemberInfo> get_Any();
    public sealed virtual IEnumerable`1<MemberInfo> get_Poids();
    public sealed virtual IEnumerable`1<MemberInfo> get_ComposedIds();
    public sealed virtual IEnumerable`1<MemberInfo> get_VersionProperties();
    public sealed virtual IEnumerable`1<MemberInfo> get_NaturalIds();
    public sealed virtual IEnumerable`1<MemberInfo> get_Sets();
    public sealed virtual IEnumerable`1<MemberInfo> get_Bags();
    public sealed virtual IEnumerable`1<MemberInfo> get_IdBags();
    public sealed virtual IEnumerable`1<MemberInfo> get_Lists();
    public sealed virtual IEnumerable`1<MemberInfo> get_Arrays();
    public sealed virtual IEnumerable`1<MemberInfo> get_Dictionaries();
    public sealed virtual IEnumerable`1<MemberInfo> get_Properties();
    public sealed virtual IEnumerable`1<MemberInfo> get_DynamicComponents();
    public sealed virtual IEnumerable`1<MemberInfo> get_PersistentMembers();
    public sealed virtual IEnumerable`1<SplitDefinition> get_SplitDefinitions();
    public sealed virtual IEnumerable`1<string> GetSplitGroupsFor(Type type);
    public sealed virtual string GetSplitGroupFor(MemberInfo member);
    public sealed virtual Type GetDynamicComponentTemplate(MemberInfo member);
    public sealed virtual void AddAsRootEntity(Type type);
    public sealed virtual void AddAsComponent(Type type);
    public sealed virtual void AddAsTablePerClassEntity(Type type);
    public sealed virtual void AddAsTablePerClassHierarchyEntity(Type type);
    public sealed virtual void AddAsTablePerConcreteClassEntity(Type type);
    public sealed virtual void AddAsOneToOneRelation(MemberInfo member);
    public sealed virtual void AddAsManyToOneRelation(MemberInfo member);
    public sealed virtual void AddAsManyToManyKeyRelation(MemberInfo member);
    public sealed virtual void AddAsManyToManyItemRelation(MemberInfo member);
    public sealed virtual void AddAsOneToManyRelation(MemberInfo member);
    public sealed virtual void AddAsManyToAnyRelation(MemberInfo member);
    public sealed virtual void AddAsAny(MemberInfo member);
    public sealed virtual void AddAsPoid(MemberInfo member);
    public sealed virtual void AddAsPartOfComposedId(MemberInfo member);
    public sealed virtual void AddAsVersionProperty(MemberInfo member);
    public sealed virtual void AddAsNaturalId(MemberInfo member);
    public sealed virtual void AddAsSet(MemberInfo member);
    public sealed virtual void AddAsBag(MemberInfo member);
    public sealed virtual void AddAsIdBag(MemberInfo member);
    public sealed virtual void AddAsList(MemberInfo member);
    public sealed virtual void AddAsArray(MemberInfo member);
    public sealed virtual void AddAsMap(MemberInfo member);
    public sealed virtual void AddAsProperty(MemberInfo member);
    public sealed virtual void AddAsPersistentMember(MemberInfo member);
    public sealed virtual void AddAsPropertySplit(SplitDefinition definition);
    public sealed virtual void AddAsDynamicComponent(MemberInfo member, Type componentTemplate);
}
public class NHibernate.Mapping.ByCode.Impl.FilterMapper : object {
    private HbmFilter filter;
    public FilterMapper(string filterName, HbmFilter filter);
    public sealed virtual void Condition(string sqlCondition);
}
public class NHibernate.Mapping.ByCode.Impl.GeneratorMapper : object {
    private HbmGenerator _generator;
    public GeneratorMapper(HbmGenerator generator);
    public sealed virtual void Params(object generatorParameters);
    public sealed virtual void Params(IDictionary`2<string, object> generatorParameters);
}
public interface NHibernate.Mapping.ByCode.Impl.ICandidatePersistentMembersProvider {
    public abstract virtual IEnumerable`1<MemberInfo> GetEntityMembersForPoid(Type entityClass);
    public abstract virtual IEnumerable`1<MemberInfo> GetRootEntityMembers(Type entityClass);
    public abstract virtual IEnumerable`1<MemberInfo> GetSubEntityMembers(Type entityClass, Type entitySuperclass);
    public abstract virtual IEnumerable`1<MemberInfo> GetComponentMembers(Type componentClass);
}
public interface NHibernate.Mapping.ByCode.Impl.ICustomizersHolder {
    public abstract virtual void AddCustomizer(Type type, Action`1<IClassMapper> classCustomizer);
    public abstract virtual void AddCustomizer(Type type, Action`1<ISubclassMapper> classCustomizer);
    public abstract virtual void AddCustomizer(Type type, Action`1<IJoinedSubclassAttributesMapper> classCustomizer);
    public abstract virtual void AddCustomizer(Type type, Action`1<IUnionSubclassAttributesMapper> classCustomizer);
    public abstract virtual void AddCustomizer(Type type, Action`1<IComponentAttributesMapper> classCustomizer);
    public abstract virtual void AddCustomizer(Type type, Action`1<IJoinAttributesMapper> classCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IPropertyMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IManyToOneMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IOneToOneMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IAnyMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<ISetPropertiesMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IBagPropertiesMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IListPropertiesMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IMapPropertiesMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IIdBagPropertiesMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<ICollectionPropertiesMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IComponentAttributesMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IComponentAsIdAttributesMapper> propertyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IDynamicComponentAttributesMapper> propertyCustomizer);
    public abstract virtual void InvokeCustomizers(Type type, IClassMapper mapper);
    public abstract virtual void InvokeCustomizers(Type type, ISubclassMapper mapper);
    public abstract virtual void InvokeCustomizers(Type type, IJoinedSubclassAttributesMapper mapper);
    public abstract virtual void InvokeCustomizers(Type type, IUnionSubclassAttributesMapper mapper);
    public abstract virtual void InvokeCustomizers(Type type, IComponentAttributesMapper mapper);
    public abstract virtual void InvokeCustomizers(Type type, IJoinAttributesMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IPropertyMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IManyToOneMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IOneToOneMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IAnyMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, ISetPropertiesMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IBagPropertiesMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IListPropertiesMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IMapPropertiesMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IIdBagPropertiesMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IComponentAttributesMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IComponentAsIdAttributesMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IDynamicComponentAttributesMapper mapper);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IMapKeyManyToManyMapper> mapKeyManyToManyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IMapKeyMapper> mapKeyElementCustomizer);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IMapKeyManyToManyMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IMapKeyMapper mapper);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IManyToManyMapper> collectionRelationManyToManyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IElementMapper> collectionRelationElementCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IOneToManyMapper> collectionRelationOneToManyCustomizer);
    public abstract virtual void AddCustomizer(PropertyPath member, Action`1<IManyToAnyMapper> collectionRelationManyToAnyCustomizer);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IManyToManyMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IElementMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IOneToManyMapper mapper);
    public abstract virtual void InvokeCustomizers(PropertyPath member, IManyToAnyMapper mapper);
    public abstract virtual IEnumerable`1<Type> GetAllCustomizedEntities();
}
public class NHibernate.Mapping.ByCode.Impl.IdBagMapper : object {
    private IAccessorPropertyMapper entityPropertyMapper;
    private KeyMapper keyMapper;
    private HbmIdbag mapping;
    private ICacheMapper cacheMapper;
    private CollectionIdMapper idMapper;
    [CompilerGeneratedAttribute]
private Type <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    public Type OwnerType { get; private set; }
    public Type ElementType { get; private set; }
    public IdBagMapper(Type ownerType, Type elementType, HbmIdbag mapping);
    public IdBagMapper(Type ownerType, Type elementType, IAccessorPropertyMapper accessorMapper, HbmIdbag mapping);
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
private void set_OwnerType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(Type value);
    public sealed virtual void Inverse(bool value);
    public sealed virtual void Mutable(bool value);
    public sealed virtual void Where(string sqlWhereClause);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void Lazy(CollectionLazy collectionLazy);
    public sealed virtual void Key(Action`1<IKeyMapper> keyMapping);
    public sealed virtual void OrderBy(MemberInfo property);
    public sealed virtual void OrderBy(string sqlOrderByClause);
    public sealed virtual void Sort();
    public sealed virtual void Sort();
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void Type();
    public sealed virtual void Type(Type collectionType);
    public void Type(string collectionType);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public sealed virtual void Fetch(CollectionFetchMode fetchMode);
    public sealed virtual void Persister(Type persister);
    public sealed virtual void Id(Action`1<ICollectionIdMapper> idMapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDeleteAll(string sql);
    public sealed virtual void SqlDeleteAll(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
}
public class NHibernate.Mapping.ByCode.Impl.IdBagMappingHandler : MulticastDelegate {
    public IdBagMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IIdBagPropertiesMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IIdBagPropertiesMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.IdMapper : object {
    private IAccessorPropertyMapper accessorMapper;
    private MemberInfo member;
    private HbmId hbmId;
    public IdMapper(HbmId hbmId);
    public IdMapper(MemberInfo member, HbmId hbmId);
    public sealed virtual void Generator(IGeneratorDef generator);
    public sealed virtual void Generator(IGeneratorDef generator, Action`1<IGeneratorMapper> generatorMapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void Type(IIdentifierType persistentType);
    public void Type(Type persistentType, object parameters);
    public sealed virtual void UnsavedValue(object value);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void Length(int length);
    private void ResetIdPlainValues();
    private void ApplyGenerator(IGeneratorDef generator);
}
public class NHibernate.Mapping.ByCode.Impl.JoinedSubclassMapper : AbstractPropertyContainerMapper {
    private HbmJoinedSubclass classMapping;
    private KeyMapper keyMapper;
    public JoinedSubclassMapper(Type subClass, HbmMapping mapDoc);
    protected virtual void AddProperty(object property);
    public sealed virtual void EntityName(string value);
    public sealed virtual void Proxy(Type proxy);
    public sealed virtual void Lazy(bool value);
    public sealed virtual void DynamicUpdate(bool value);
    public sealed virtual void DynamicInsert(bool value);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void SelectBeforeUpdate(bool value);
    public sealed virtual void Persister();
    public sealed virtual void Synchronize(String[] table);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    public sealed virtual void Abstract(bool isAbstract);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Key(Action`1<IKeyMapper> keyMapping);
    public sealed virtual void Extends(Type baseType);
    public void Extends(string entityOrClassName);
    public sealed virtual void SchemaAction(SchemaAction action);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
}
public class NHibernate.Mapping.ByCode.Impl.JoinedSubclassMappingHandler : MulticastDelegate {
    public JoinedSubclassMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, Type type, IJoinedSubclassAttributesMapper joinedSubclassCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, Type type, IJoinedSubclassAttributesMapper joinedSubclassCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.JoinMapper : AbstractPropertyContainerMapper {
    private HbmJoin hbmJoin;
    private KeyMapper keyMapper;
    [CompilerGeneratedAttribute]
private TableNameChangedHandler TableNameChanged;
    public JoinMapper(Type container, string splitGroupId, HbmJoin hbmJoin, HbmMapping mapDoc);
    [CompilerGeneratedAttribute]
public void add_TableNameChanged(TableNameChangedHandler value);
    [CompilerGeneratedAttribute]
public void remove_TableNameChanged(TableNameChangedHandler value);
    private void InvokeTableNameChanged(TableNameChangedEventArgs e);
    protected virtual void AddProperty(object property);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Key(Action`1<IKeyMapper> keyMapping);
    public sealed virtual void Inverse(bool value);
    public sealed virtual void Optional(bool isOptional);
    public sealed virtual void Fetch(FetchKind fetchMode);
}
public class NHibernate.Mapping.ByCode.Impl.KeyManyToOneMapper : object {
    private IAccessorPropertyMapper _entityPropertyMapper;
    private HbmKeyManyToOne _manyToOne;
    private HbmMapping _mapDoc;
    private MemberInfo _member;
    public KeyManyToOneMapper(MemberInfo member, HbmKeyManyToOne manyToOne, HbmMapping mapDoc);
    public sealed virtual void Class(Type entityType);
    public void EntityName(string entityName);
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void UniqueKey(string uniquekeyName);
    public sealed virtual void Index(string indexName);
    public sealed virtual void Fetch(FetchKind fetchMode);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Lazy(LazyRelation lazyRelation);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void PropertyRef(string propertyReferencedName);
    public sealed virtual void NotFound(NotFoundMode mode);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    private bool ColumnTagIsRequired(HbmColumn hbm);
    private void ResetColumnPlainValues();
}
public class NHibernate.Mapping.ByCode.Impl.KeyMapper : object {
    private HbmKey mapping;
    private Type ownerEntityType;
    public KeyMapper(Type ownerEntityType, HbmKey mapping);
    public static string DefaultColumnName(Type ownerEntityType);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void OnDelete(OnDeleteAction deleteAction);
    public sealed virtual void PropertyRef(MemberInfo property);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void ForeignKey(string foreignKeyName);
    private bool ColumnTagIsRequired(HbmColumn hbm);
    private void ResetColumnPlainValues();
}
public class NHibernate.Mapping.ByCode.Impl.KeyPropertyMapper : object {
    private IAccessorPropertyMapper entityPropertyMapper;
    private MemberInfo member;
    private HbmKeyProperty propertyMapping;
    public KeyPropertyMapper(MemberInfo member, HbmKeyProperty propertyMapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Type(IType persistentType);
    public sealed virtual void Type();
    public sealed virtual void Type(object parameters);
    public sealed virtual void Type(Type persistentType, object parameters);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void Length(int length);
    public sealed virtual void Precision(short precision);
    public sealed virtual void Scale(short scale);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void UniqueKey(string uniquekeyName);
    public sealed virtual void Index(string indexName);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Lazy(bool isLazy);
    public sealed virtual void Generated(PropertyGeneration generation);
    private bool ColumnTagIsRequired(HbmColumn hbm);
    private void ResetColumnPlainValues();
}
public class NHibernate.Mapping.ByCode.Impl.ListIndexMapper : object {
    private static string DefaultIndexColumnName;
    private HbmListIndex mapping;
    private Type ownerEntityType;
    public ListIndexMapper(Type ownerEntityType, HbmListIndex mapping);
    public sealed virtual void Column(string columnName);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    private void ResetColumnPlainValues();
    private bool ColumnTagIsRequired(HbmColumn hbm);
    public sealed virtual void Base(int baseIndex);
}
public class NHibernate.Mapping.ByCode.Impl.ListMapper : object {
    private IAccessorPropertyMapper entityPropertyMapper;
    private KeyMapper keyMapper;
    private IListIndexMapper listIndexMapper;
    private HbmList mapping;
    private ICacheMapper cacheMapper;
    [CompilerGeneratedAttribute]
private Type <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    public Type OwnerType { get; private set; }
    public Type ElementType { get; private set; }
    public ListMapper(Type ownerType, Type elementType, HbmList mapping);
    public ListMapper(Type ownerType, Type elementType, IAccessorPropertyMapper accessorMapper, HbmList mapping);
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
private void set_OwnerType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(Type value);
    public sealed virtual void Key(Action`1<IKeyMapper> keyMapping);
    public sealed virtual void Inverse(bool value);
    public sealed virtual void Mutable(bool value);
    public sealed virtual void Where(string sqlWhereClause);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void Lazy(CollectionLazy collectionLazy);
    public sealed virtual void OrderBy(MemberInfo property);
    public sealed virtual void OrderBy(string sqlOrderByClause);
    public sealed virtual void Sort();
    public sealed virtual void Sort();
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void Type();
    public sealed virtual void Type(Type collectionType);
    public void Type(string collectionType);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public sealed virtual void Fetch(CollectionFetchMode fetchMode);
    public sealed virtual void Persister(Type persister);
    public sealed virtual void Index(Action`1<IListIndexMapper> listIndexMapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDeleteAll(string sql);
    public sealed virtual void SqlDeleteAll(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
}
public class NHibernate.Mapping.ByCode.Impl.ListMappingHandler : MulticastDelegate {
    public ListMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IListPropertiesMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IListPropertiesMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.ManyToAnyMapper : object {
    private static string DefaultIdColumnNameWhenNoProperty;
    private static string DefaultMetaColumnNameWhenNoProperty;
    private Type elementType;
    private Type foreignIdType;
    private ColumnMapper classColumnMapper;
    private ColumnMapper idColumnMapper;
    private HbmManyToAny manyToAny;
    private HbmMapping mapDoc;
    public ManyToAnyMapper(Type elementType, Type foreignIdType, HbmManyToAny manyToAny, HbmMapping mapDoc);
    public sealed virtual void MetaType(IType metaType);
    public sealed virtual void MetaType();
    public sealed virtual void MetaType(Type metaType);
    public sealed virtual void IdType(IType idType);
    public sealed virtual void IdType();
    public sealed virtual void IdType(Type idType);
    public sealed virtual void Columns(Action`1<IColumnMapper> idColumnMapping, Action`1<IColumnMapper> classColumnMapping);
    public sealed virtual void MetaValue(object value, Type entityType);
    private void CheckMetaTypeImmutability(string nhTypeName);
    private void CheckIdTypeImmutability(string nhTypeName);
}
public class NHibernate.Mapping.ByCode.Impl.ManyToManyMapper : object {
    private Type elementType;
    private HbmManyToMany manyToMany;
    private HbmMapping mapDoc;
    public ManyToManyMapper(Type elementType, HbmManyToMany manyToMany, HbmMapping mapDoc);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    private bool ColumnTagIsRequired(HbmColumn hbm);
    private void ResetColumnPlainValues();
    public sealed virtual void ColumnsAndFormulas(Action`1[] columnOrFormulaMapper);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Formulas(String[] formulas);
    public sealed virtual void Class(Type entityType);
    public sealed virtual void EntityName(string entityName);
    public sealed virtual void NotFound(NotFoundMode mode);
    public sealed virtual void Lazy(LazyRelation lazyRelation);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void Where(string sqlWhereClause);
}
public class NHibernate.Mapping.ByCode.Impl.ManyToManyMappingHandler : MulticastDelegate {
    public ManyToManyMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IManyToManyMapper collectionRelationManyToManyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IManyToManyMapper collectionRelationManyToManyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.ManyToOneMapper : object {
    private IAccessorPropertyMapper _entityPropertyMapper;
    private HbmManyToOne _manyToOne;
    private HbmMapping _mapDoc;
    private MemberInfo _member;
    public ManyToOneMapper(MemberInfo member, HbmManyToOne manyToOne, HbmMapping mapDoc);
    public ManyToOneMapper(MemberInfo member, IAccessorPropertyMapper accessorPropertyMapper, HbmManyToOne manyToOne, HbmMapping mapDoc);
    public sealed virtual void Class(Type entityType);
    public void EntityName(string entityName);
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void UniqueKey(string uniquekeyName);
    public sealed virtual void Index(string indexName);
    public sealed virtual void Fetch(FetchKind fetchMode);
    public sealed virtual void Lazy(LazyRelation lazyRelation);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void PropertyRef(string propertyReferencedName);
    public sealed virtual void NotFound(NotFoundMode mode);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void ColumnsAndFormulas(Action`1[] columnOrFormulaMapper);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Formulas(String[] formulas);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    private void ResetColumnPlainValues();
}
public class NHibernate.Mapping.ByCode.Impl.ManyToOneMappingHandler : MulticastDelegate {
    public ManyToOneMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IManyToOneMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IManyToOneMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.MapKeyManyToManyMapper : object {
    private static string DefaultColumnName;
    private HbmMapKeyManyToMany mapping;
    public HbmMapKeyManyToMany MapKeyManyToManyMapping { get; }
    public MapKeyManyToManyMapper(HbmMapKeyManyToMany mapping);
    public HbmMapKeyManyToMany get_MapKeyManyToManyMapping();
    public sealed virtual void ForeignKey(string foreignKeyName);
    public sealed virtual void ColumnsAndFormulas(Action`1[] columnOrFormulaMapper);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Formulas(String[] formulas);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    private bool ColumnTagIsRequired(HbmColumn hbm);
    private void ResetColumnPlainValues();
}
public class NHibernate.Mapping.ByCode.Impl.MapKeyManyToManyMappingHandler : MulticastDelegate {
    public MapKeyManyToManyMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IMapKeyManyToManyMapper mapKeyManyToManyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IMapKeyManyToManyMapper mapKeyManyToManyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.MapKeyMapper : object {
    private HbmMapKey hbmMapKey;
    private static string DefaultColumnName;
    public HbmMapKey MapKeyMapping { get; }
    public MapKeyMapper(HbmMapKey hbmMapKey);
    public HbmMapKey get_MapKeyMapping();
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void Type(IType persistentType);
    public sealed virtual void Type();
    public sealed virtual void Type(Type persistentType);
    public sealed virtual void Length(int length);
    public sealed virtual void ColumnsAndFormulas(Action`1[] columnOrFormulaMapper);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Formulas(String[] formulas);
    private void ResetColumnPlainValues();
    private bool ColumnTagIsRequired(HbmColumn hbm);
}
public class NHibernate.Mapping.ByCode.Impl.MapKeyMappingHandler : MulticastDelegate {
    public MapKeyMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IMapKeyMapper mapKeyElementCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IMapKeyMapper mapKeyElementCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.MapKeyRelation : object {
    private Type dictionaryKeyType;
    private HbmMapping mapDoc;
    private HbmMap mapMapping;
    private ComponentMapKeyMapper componentMapKeyMapper;
    private MapKeyManyToManyMapper mapKeyManyToManyMapper;
    private MapKeyMapper mapKeyMapper;
    public MapKeyRelation(Type dictionaryKeyType, HbmMap mapMapping, HbmMapping mapDoc);
    public sealed virtual void Element(Action`1<IMapKeyMapper> mapping);
    public sealed virtual void ManyToMany(Action`1<IMapKeyManyToManyMapper> mapping);
    public sealed virtual void Component(Action`1<IComponentMapKeyMapper> mapping);
}
public class NHibernate.Mapping.ByCode.Impl.MapMapper : object {
    private IAccessorPropertyMapper entityPropertyMapper;
    private KeyMapper keyMapper;
    private HbmMapping mapDoc;
    private HbmMap mapping;
    private ICacheMapper cacheMapper;
    [CompilerGeneratedAttribute]
private Type <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ValueType>k__BackingField;
    public Type OwnerType { get; private set; }
    public Type KeyType { get; private set; }
    public Type ValueType { get; private set; }
    public MapMapper(Type ownerType, Type keyType, Type valueType, HbmMap mapping, HbmMapping mapDoc);
    public MapMapper(Type ownerType, Type keyType, Type valueType, IAccessorPropertyMapper accessorMapper, HbmMap mapping, HbmMapping mapDoc);
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
private void set_OwnerType(Type value);
    [CompilerGeneratedAttribute]
public Type get_KeyType();
    [CompilerGeneratedAttribute]
private void set_KeyType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ValueType();
    [CompilerGeneratedAttribute]
private void set_ValueType(Type value);
    public sealed virtual void Inverse(bool value);
    public sealed virtual void Mutable(bool value);
    public sealed virtual void Where(string sqlWhereClause);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void Lazy(CollectionLazy collectionLazy);
    public sealed virtual void Key(Action`1<IKeyMapper> keyMapping);
    public sealed virtual void OrderBy(MemberInfo property);
    public sealed virtual void OrderBy(string sqlOrderByClause);
    public sealed virtual void Sort();
    public sealed virtual void Sort();
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void Type();
    public sealed virtual void Type(Type collectionType);
    public void Type(string collectionType);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public sealed virtual void Fetch(CollectionFetchMode fetchMode);
    public sealed virtual void Persister(Type persister);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDeleteAll(string sql);
    public sealed virtual void SqlDeleteAll(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
}
public class NHibernate.Mapping.ByCode.Impl.MapMappingHandler : MulticastDelegate {
    public MapMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IMapPropertiesMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IMapPropertiesMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.NaturalIdMapper : AbstractBasePropertyContainerMapper {
    private HbmClass classMapping;
    private HbmNaturalId naturalIdmapping;
    public NaturalIdMapper(Type rootClass, HbmClass classMapping, HbmMapping mapDoc);
    protected virtual void AddProperty(object property);
    public sealed virtual void Mutable(bool isMutable);
}
public class NHibernate.Mapping.ByCode.Impl.NoMemberPropertyMapper : object {
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
}
public class NHibernate.Mapping.ByCode.Impl.OneToManyMapper : object {
    private Type collectionElementType;
    private HbmMapping mapDoc;
    private HbmOneToMany oneToManyMapping;
    public OneToManyMapper(Type collectionElementType, HbmOneToMany oneToManyMapping, HbmMapping mapDoc);
    public sealed virtual void Class(Type entityType);
    public sealed virtual void EntityName(string entityName);
    public sealed virtual void NotFound(NotFoundMode mode);
}
public class NHibernate.Mapping.ByCode.Impl.OneToManyMappingHandler : MulticastDelegate {
    public OneToManyMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IOneToManyMapper collectionRelationOneToManyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IOneToManyMapper collectionRelationOneToManyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.OneToOneMapper : object {
    private IAccessorPropertyMapper _entityPropertyMapper;
    private MemberInfo _member;
    private HbmOneToOne _oneToOne;
    public OneToOneMapper(MemberInfo member, HbmOneToOne oneToOne);
    public OneToOneMapper(MemberInfo member, IAccessorPropertyMapper accessorMapper, HbmOneToOne oneToOne);
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void Class(Type clazz);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Lazy(LazyRelation lazyRelation);
    public sealed virtual void Constrained(bool value);
    public sealed virtual void PropertyReference(MemberInfo propertyInTheOtherSide);
    public sealed virtual void Formula(string formula);
    public void Formulas(String[] formulas);
    public sealed virtual void ForeignKey(string foreignKeyName);
    public void Fetch(FetchKind fetchMode);
}
public class NHibernate.Mapping.ByCode.Impl.OneToOneMapper`1 : OneToOneMapper {
    public OneToOneMapper`1(MemberInfo member, HbmOneToOne oneToOne);
    public OneToOneMapper`1(MemberInfo member, IAccessorPropertyMapper accessorMapper, HbmOneToOne oneToOne);
    public sealed virtual void PropertyReference(Expression`1<Func`2<T, TProperty>> reference);
}
public class NHibernate.Mapping.ByCode.Impl.OneToOneMappingHandler : MulticastDelegate {
    public OneToOneMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IOneToOneMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IOneToOneMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.PropertyMapper : object {
    private IAccessorPropertyMapper entityPropertyMapper;
    private MemberInfo member;
    private HbmProperty propertyMapping;
    public PropertyMapper(MemberInfo member, HbmProperty propertyMapping, IAccessorPropertyMapper accessorMapper);
    public PropertyMapper(MemberInfo member, HbmProperty propertyMapping);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Type(IType persistentType);
    public sealed virtual void Type();
    public sealed virtual void Type(object parameters);
    public sealed virtual void Type(Type persistentType, object parameters);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    public sealed virtual void Length(int length);
    public sealed virtual void Precision(short precision);
    public sealed virtual void Scale(short scale);
    public sealed virtual void NotNullable(bool notnull);
    public sealed virtual void Unique(bool unique);
    public sealed virtual void UniqueKey(string uniquekeyName);
    public sealed virtual void Index(string indexName);
    public sealed virtual void Update(bool consideredInUpdateQuery);
    public sealed virtual void Insert(bool consideredInInsertQuery);
    public sealed virtual void Lazy(bool isLazy);
    public void FetchGroup(string name);
    public sealed virtual void Generated(PropertyGeneration generation);
    private void ResetColumnPlainValues();
    public sealed virtual void ColumnsAndFormulas(Action`1[] columnOrFormulaMapper);
    public sealed virtual void Formula(string formula);
    public sealed virtual void Formulas(String[] formulas);
}
public class NHibernate.Mapping.ByCode.Impl.PropertyMappingHandler : MulticastDelegate {
    public PropertyMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, IPropertyMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, IPropertyMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.RootClassMappingHandler : MulticastDelegate {
    public RootClassMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, Type type, IClassAttributesMapper classCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, Type type, IClassAttributesMapper classCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.SetMapper : object {
    private IAccessorPropertyMapper entityPropertyMapper;
    private KeyMapper keyMapper;
    private HbmSet mapping;
    private ICacheMapper cacheMapper;
    [CompilerGeneratedAttribute]
private Type <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    public Type OwnerType { get; private set; }
    public Type ElementType { get; private set; }
    public SetMapper(Type ownerType, Type elementType, HbmSet mapping);
    public SetMapper(Type ownerType, Type elementType, IAccessorPropertyMapper accessorMapper, HbmSet mapping);
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
private void set_OwnerType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(Type value);
    public sealed virtual void Inverse(bool value);
    public sealed virtual void Mutable(bool value);
    public sealed virtual void Where(string sqlWhereClause);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void Lazy(CollectionLazy collectionLazy);
    public sealed virtual void Key(Action`1<IKeyMapper> keyMapping);
    public sealed virtual void OrderBy(MemberInfo property);
    public sealed virtual void OrderBy(string sqlOrderByClause);
    public sealed virtual void Sort();
    public sealed virtual void Sort();
    public sealed virtual void Cascade(Cascade cascadeStyle);
    public sealed virtual void Type();
    public sealed virtual void Type(Type collectionType);
    public void Type(string collectionType);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Cache(Action`1<ICacheMapper> cacheMapping);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public sealed virtual void Fetch(CollectionFetchMode fetchMode);
    public sealed virtual void Persister(Type persister);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    public sealed virtual void OptimisticLock(bool takeInConsiderationForOptimisticLock);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDeleteAll(string sql);
    public sealed virtual void SqlDeleteAll(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
}
public class NHibernate.Mapping.ByCode.Impl.SetMappingHandler : MulticastDelegate {
    public SetMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, PropertyPath member, ISetPropertiesMapper propertyCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, PropertyPath member, ISetPropertiesMapper propertyCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.SubclassMapper : AbstractPropertyContainerMapper {
    private HbmSubclass classMapping;
    private Dictionary`2<string, IJoinMapper> joinMappers;
    public Dictionary`2<string, IJoinMapper> JoinMappers { get; }
    public SubclassMapper(Type subClass, HbmMapping mapDoc);
    protected virtual void AddProperty(object property);
    public Dictionary`2<string, IJoinMapper> get_JoinMappers();
    public sealed virtual void Abstract(bool isAbstract);
    public sealed virtual void DiscriminatorValue(object value);
    public sealed virtual void Extends(Type baseType);
    public void Extends(string entityOrClassName);
    public sealed virtual void Join(string splitGroupId, Action`1<IJoinMapper> splitMapping);
    public sealed virtual void EntityName(string value);
    public sealed virtual void Proxy(Type proxy);
    public sealed virtual void Lazy(bool value);
    public sealed virtual void DynamicUpdate(bool value);
    public sealed virtual void DynamicInsert(bool value);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void SelectBeforeUpdate(bool value);
    public sealed virtual void Persister();
    public sealed virtual void Synchronize(String[] table);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    public sealed virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
}
public class NHibernate.Mapping.ByCode.Impl.SubclassMappingHandler : MulticastDelegate {
    public SubclassMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, Type type, ISubclassAttributesMapper subclassCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, Type type, ISubclassAttributesMapper subclassCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.TableNameChangedEventArgs : object {
    [CompilerGeneratedAttribute]
private string <OldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    public string OldName { get; private set; }
    public string NewName { get; private set; }
    public TableNameChangedEventArgs(string oldName, string newName);
    [CompilerGeneratedAttribute]
public string get_OldName();
    [CompilerGeneratedAttribute]
private void set_OldName(string value);
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
private void set_NewName(string value);
}
public class NHibernate.Mapping.ByCode.Impl.TableNameChangedHandler : MulticastDelegate {
    public TableNameChangedHandler(object object, IntPtr method);
    public virtual void Invoke(IJoinMapper mapper, TableNameChangedEventArgs args);
    public virtual IAsyncResult BeginInvoke(IJoinMapper mapper, TableNameChangedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.Impl.TypeNameUtil : object {
    [ExtensionAttribute]
public static string GetNhTypeName(Type type);
    [ExtensionAttribute]
public static string GetShortClassName(Type type, HbmMapping mapDoc);
    private static string GetTypeNameForMapping(Type type);
}
public class NHibernate.Mapping.ByCode.Impl.UnionSubclassMapper : AbstractPropertyContainerMapper {
    private HbmUnionSubclass classMapping;
    public UnionSubclassMapper(Type subClass, HbmMapping mapDoc);
    protected virtual void AddProperty(object property);
    public sealed virtual void EntityName(string value);
    public sealed virtual void Proxy(Type proxy);
    public sealed virtual void Lazy(bool value);
    public sealed virtual void DynamicUpdate(bool value);
    public sealed virtual void DynamicInsert(bool value);
    public sealed virtual void BatchSize(int value);
    public sealed virtual void SelectBeforeUpdate(bool value);
    public sealed virtual void Persister();
    public sealed virtual void Synchronize(String[] table);
    public sealed virtual void Loader(string namedQueryReference);
    public sealed virtual void SqlInsert(string sql);
    public sealed virtual void SqlInsert(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlUpdate(string sql);
    public sealed virtual void SqlUpdate(string sql, SqlCheck sqlCheck);
    public sealed virtual void SqlDelete(string sql);
    public sealed virtual void SqlDelete(string sql, SqlCheck sqlCheck);
    public sealed virtual void Subselect(string sql);
    public sealed virtual void Abstract(bool isAbstract);
    public sealed virtual void Table(string tableName);
    public sealed virtual void Catalog(string catalogName);
    public sealed virtual void Schema(string schemaName);
    public sealed virtual void Extends(Type baseType);
    public void Extends(string entityOrClassName);
}
public class NHibernate.Mapping.ByCode.Impl.UnionSubclassMappingHandler : MulticastDelegate {
    public UnionSubclassMappingHandler(object object, IntPtr method);
    public virtual void Invoke(IModelInspector modelInspector, Type type, IUnionSubclassAttributesMapper unionSubclassCustomizer);
    public virtual IAsyncResult BeginInvoke(IModelInspector modelInspector, Type type, IUnionSubclassAttributesMapper unionSubclassCustomizer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NHibernate.Mapping.ByCode.Impl.VersionMapper : object {
    private IAccessorPropertyMapper entityPropertyMapper;
    private MemberInfo member;
    private HbmVersion versionMapping;
    public VersionMapper(MemberInfo member, HbmVersion hbmVersion);
    public sealed virtual void Column(Action`1<IColumnMapper> columnMapper);
    public sealed virtual void Columns(Action`1[] columnMapper);
    public sealed virtual void Column(string name);
    private bool ColumnTagIsRequired(HbmColumn hbm);
    private void ResetColumnPlainValues();
    public sealed virtual void Type(IVersionType persistentType);
    public sealed virtual void Type();
    public sealed virtual void Type(Type persistentType);
    public sealed virtual void UnsavedValue(object value);
    public sealed virtual void Insert(bool useInInsert);
    public sealed virtual void Generated(VersionGeneration generatedByDb);
    public sealed virtual void Access(Accessor accessor);
    public sealed virtual void Access(Type accessorType);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(string x);
}
public class NHibernate.Mapping.ByCode.Import : object {
    private Type importType;
    private string rename;
    public Import(Type importType, string rename);
    public void AddToMapping(HbmMapping hbmMapping);
}
public interface NHibernate.Mapping.ByCode.INaturalIdAttributesMapper {
    public abstract virtual void Mutable(bool isMutable);
}
public interface NHibernate.Mapping.ByCode.INaturalIdMapper {
}
public class NHibernate.Mapping.ByCode.IncrementGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public interface NHibernate.Mapping.ByCode.IOneToManyMapper {
    public abstract virtual void Class(Type entityType);
    public abstract virtual void EntityName(string entityName);
    public abstract virtual void NotFound(NotFoundMode mode);
}
public interface NHibernate.Mapping.ByCode.IOneToOneMapper {
    public abstract virtual void Cascade(Cascade cascadeStyle);
    public abstract virtual void Lazy(LazyRelation lazyRelation);
    public abstract virtual void Constrained(bool value);
    public abstract virtual void PropertyReference(MemberInfo propertyInTheOtherSide);
    public abstract virtual void Formula(string formula);
    public abstract virtual void ForeignKey(string foreignKeyName);
    public abstract virtual void Class(Type clazz);
}
public interface NHibernate.Mapping.ByCode.IOneToOneMapper`1 {
    public abstract virtual void PropertyReference(Expression`1<Func`2<T, TProperty>> reference);
}
public interface NHibernate.Mapping.ByCode.IPlainPropertyContainerMapper {
    public abstract virtual void OneToOne(MemberInfo property, Action`1<IOneToOneMapper> mapping);
}
public interface NHibernate.Mapping.ByCode.IPlainPropertyContainerMapper`1 {
    public abstract virtual void OneToOne(Expression`1<Func`2<TContainer, TProperty>> property, Action`1<IOneToOneMapper`1<TProperty>> mapping);
    public abstract virtual void OneToOne(string notVisiblePropertyOrFieldName, Action`1<IOneToOneMapper`1<TProperty>> mapping);
}
public interface NHibernate.Mapping.ByCode.IPropertyContainerMapper {
}
public interface NHibernate.Mapping.ByCode.IPropertyContainerMapper`1 {
}
public interface NHibernate.Mapping.ByCode.IPropertyMapper {
    public abstract virtual void Type(IType persistentType);
    public abstract virtual void Type();
    public abstract virtual void Type(object parameters);
    public abstract virtual void Type(Type persistentType, object parameters);
    public abstract virtual void Length(int length);
    public abstract virtual void Precision(short precision);
    public abstract virtual void Scale(short scale);
    public abstract virtual void NotNullable(bool notnull);
    public abstract virtual void Unique(bool unique);
    public abstract virtual void UniqueKey(string uniquekeyName);
    public abstract virtual void Index(string indexName);
    public abstract virtual void Formula(string formula);
    public abstract virtual void Update(bool consideredInUpdateQuery);
    public abstract virtual void Insert(bool consideredInInsertQuery);
    public abstract virtual void Lazy(bool isLazy);
    public abstract virtual void Generated(PropertyGeneration generation);
}
public interface NHibernate.Mapping.ByCode.ISetPropertiesMapper {
}
public interface NHibernate.Mapping.ByCode.ISetPropertiesMapper`2 {
}
public interface NHibernate.Mapping.ByCode.ISubclassAttributesMapper {
    public abstract virtual void DiscriminatorValue(object value);
    public abstract virtual void Extends(Type baseType);
    public abstract virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public abstract virtual void Abstract(bool isAbstract);
}
public interface NHibernate.Mapping.ByCode.ISubclassAttributesMapper`1 {
    public abstract virtual void DiscriminatorValue(object value);
    public abstract virtual void Filter(string filterName, Action`1<IFilterMapper> filterMapping);
    public abstract virtual void Extends(Type baseType);
    public abstract virtual void Abstract(bool isAbstract);
}
public interface NHibernate.Mapping.ByCode.ISubclassMapper {
    public abstract virtual void Join(string splitGroupId, Action`1<IJoinMapper> splitMapping);
}
public interface NHibernate.Mapping.ByCode.ISubclassMapper`1 {
    public abstract virtual void Join(string splitGroupId, Action`1<IJoinMapper`1<TEntity>> splitMapping);
}
public interface NHibernate.Mapping.ByCode.IUnionSubclassAttributesMapper {
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Extends(Type baseType);
    public abstract virtual void Abstract(bool isAbstract);
}
public interface NHibernate.Mapping.ByCode.IUnionSubclassAttributesMapper`1 {
    public abstract virtual void Table(string tableName);
    public abstract virtual void Catalog(string catalogName);
    public abstract virtual void Schema(string schemaName);
    public abstract virtual void Extends(Type baseType);
    public abstract virtual void Abstract(bool isAbstract);
}
public interface NHibernate.Mapping.ByCode.IUnionSubclassMapper {
}
public interface NHibernate.Mapping.ByCode.IUnionSubclassMapper`1 {
}
public interface NHibernate.Mapping.ByCode.IVersionMapper {
    public abstract virtual void Type(IVersionType persistentType);
    public abstract virtual void Type();
    public abstract virtual void Type(Type persistentType);
    public abstract virtual void UnsavedValue(object value);
    public abstract virtual void Insert(bool useInInsert);
    public abstract virtual void Generated(VersionGeneration generatedByDb);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.JoinedSubclassAttributesMapperExtensions : object {
    [ExtensionAttribute]
public static void Extends(IJoinedSubclassAttributesMapper`1<TEntity> mapper, string entityOrClassName);
    [ExtensionAttribute]
public static void Extends(IJoinedSubclassAttributesMapper mapper, string entityOrClassName);
}
public abstract class NHibernate.Mapping.ByCode.LazyRelation : object {
    public static LazyRelation Proxy;
    public static LazyRelation NoProxy;
    public static LazyRelation NoLazy;
    private static LazyRelation();
    public abstract virtual HbmLaziness ToHbm();
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.ManyToOneMapperExtensions : object {
    [ExtensionAttribute]
public static void EntityName(IManyToOneMapper mapper, string entityName);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.MappingsExtensions : object {
    [ExtensionAttribute]
public static void WriteAllXmlMapping(IEnumerable`1<HbmMapping> mappings);
    [ExtensionAttribute]
public static string AsString(HbmMapping mappings);
    private static string ArrangeMappingsFolderPath();
    private static string GetFileName(HbmMapping hbmMapping);
    private static string Serialize(HbmMapping hbmElement);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.ModelExplicitDeclarationsHolderExtensions : object {
    [ExtensionAttribute]
public static void Merge(IModelExplicitDeclarationsHolder destination, IModelExplicitDeclarationsHolder source);
}
public class NHibernate.Mapping.ByCode.ModelMapper : object {
    private ICustomizersHolder customizerHolder;
    private IModelExplicitDeclarationsHolder explicitDeclarationsHolder;
    private ICandidatePersistentMembersProvider membersProvider;
    private IModelInspector modelInspector;
    private List`1<Import> imports;
    [CompilerGeneratedAttribute]
private RootClassMappingHandler BeforeMapClass;
    [CompilerGeneratedAttribute]
private SubclassMappingHandler BeforeMapSubclass;
    [CompilerGeneratedAttribute]
private JoinedSubclassMappingHandler BeforeMapJoinedSubclass;
    [CompilerGeneratedAttribute]
private UnionSubclassMappingHandler BeforeMapUnionSubclass;
    [CompilerGeneratedAttribute]
private PropertyMappingHandler BeforeMapProperty;
    [CompilerGeneratedAttribute]
private ManyToOneMappingHandler BeforeMapManyToOne;
    [CompilerGeneratedAttribute]
private OneToOneMappingHandler BeforeMapOneToOne;
    [CompilerGeneratedAttribute]
private AnyMappingHandler BeforeMapAny;
    [CompilerGeneratedAttribute]
private ComponentMappingHandler BeforeMapComponent;
    [CompilerGeneratedAttribute]
private SetMappingHandler BeforeMapSet;
    [CompilerGeneratedAttribute]
private BagMappingHandler BeforeMapBag;
    [CompilerGeneratedAttribute]
private IdBagMappingHandler BeforeMapIdBag;
    [CompilerGeneratedAttribute]
private ListMappingHandler BeforeMapList;
    [CompilerGeneratedAttribute]
private MapMappingHandler BeforeMapMap;
    [CompilerGeneratedAttribute]
private ManyToManyMappingHandler BeforeMapManyToMany;
    [CompilerGeneratedAttribute]
private ElementMappingHandler BeforeMapElement;
    [CompilerGeneratedAttribute]
private OneToManyMappingHandler BeforeMapOneToMany;
    [CompilerGeneratedAttribute]
private MapKeyManyToManyMappingHandler BeforeMapMapKeyManyToMany;
    [CompilerGeneratedAttribute]
private MapKeyMappingHandler BeforeMapMapKey;
    [CompilerGeneratedAttribute]
private RootClassMappingHandler AfterMapClass;
    [CompilerGeneratedAttribute]
private SubclassMappingHandler AfterMapSubclass;
    [CompilerGeneratedAttribute]
private JoinedSubclassMappingHandler AfterMapJoinedSubclass;
    [CompilerGeneratedAttribute]
private UnionSubclassMappingHandler AfterMapUnionSubclass;
    [CompilerGeneratedAttribute]
private PropertyMappingHandler AfterMapProperty;
    [CompilerGeneratedAttribute]
private ManyToOneMappingHandler AfterMapManyToOne;
    [CompilerGeneratedAttribute]
private OneToOneMappingHandler AfterMapOneToOne;
    [CompilerGeneratedAttribute]
private AnyMappingHandler AfterMapAny;
    [CompilerGeneratedAttribute]
private ComponentMappingHandler AfterMapComponent;
    [CompilerGeneratedAttribute]
private SetMappingHandler AfterMapSet;
    [CompilerGeneratedAttribute]
private BagMappingHandler AfterMapBag;
    [CompilerGeneratedAttribute]
private IdBagMappingHandler AfterMapIdBag;
    [CompilerGeneratedAttribute]
private ListMappingHandler AfterMapList;
    [CompilerGeneratedAttribute]
private MapMappingHandler AfterMapMap;
    [CompilerGeneratedAttribute]
private ManyToManyMappingHandler AfterMapManyToMany;
    [CompilerGeneratedAttribute]
private ElementMappingHandler AfterMapElement;
    [CompilerGeneratedAttribute]
private OneToManyMappingHandler AfterMapOneToMany;
    [CompilerGeneratedAttribute]
private MapKeyManyToManyMappingHandler AfterMapMapKeyManyToMany;
    [CompilerGeneratedAttribute]
private MapKeyMappingHandler AfterMapMapKey;
    public IModelInspector ModelInspector { get; }
    protected ICandidatePersistentMembersProvider MembersProvider { get; }
    public ModelMapper(IModelInspector modelInspector);
    public ModelMapper(IModelInspector modelInspector, ICandidatePersistentMembersProvider membersProvider);
    public ModelMapper(IModelInspector modelInspector, IModelExplicitDeclarationsHolder explicitDeclarationsHolder);
    public ModelMapper(IModelInspector modelInspector, IModelExplicitDeclarationsHolder explicitDeclarationsHolder, ICustomizersHolder customizerHolder, ICandidatePersistentMembersProvider membersProvider);
    [CompilerGeneratedAttribute]
public void add_BeforeMapClass(RootClassMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapClass(RootClassMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapSubclass(SubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapSubclass(SubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapJoinedSubclass(JoinedSubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapJoinedSubclass(JoinedSubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapUnionSubclass(UnionSubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapUnionSubclass(UnionSubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapProperty(PropertyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapProperty(PropertyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapManyToOne(ManyToOneMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapManyToOne(ManyToOneMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapOneToOne(OneToOneMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapOneToOne(OneToOneMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapAny(AnyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapAny(AnyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapComponent(ComponentMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapComponent(ComponentMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapSet(SetMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapSet(SetMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapBag(BagMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapBag(BagMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapIdBag(IdBagMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapIdBag(IdBagMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapList(ListMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapList(ListMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapMap(MapMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapMap(MapMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapManyToMany(ManyToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapManyToMany(ManyToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapElement(ElementMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapElement(ElementMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapOneToMany(OneToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapOneToMany(OneToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapMapKeyManyToMany(MapKeyManyToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapMapKeyManyToMany(MapKeyManyToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_BeforeMapMapKey(MapKeyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeMapMapKey(MapKeyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapClass(RootClassMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapClass(RootClassMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapSubclass(SubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapSubclass(SubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapJoinedSubclass(JoinedSubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapJoinedSubclass(JoinedSubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapUnionSubclass(UnionSubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapUnionSubclass(UnionSubclassMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapProperty(PropertyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapProperty(PropertyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapManyToOne(ManyToOneMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapManyToOne(ManyToOneMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapOneToOne(OneToOneMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapOneToOne(OneToOneMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapAny(AnyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapAny(AnyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapComponent(ComponentMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapComponent(ComponentMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapSet(SetMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapSet(SetMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapBag(BagMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapBag(BagMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapIdBag(IdBagMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapIdBag(IdBagMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapList(ListMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapList(ListMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapMap(MapMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapMap(MapMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapManyToMany(ManyToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapManyToMany(ManyToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapElement(ElementMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapElement(ElementMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapOneToMany(OneToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapOneToMany(OneToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapMapKeyManyToMany(MapKeyManyToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapMapKeyManyToMany(MapKeyManyToManyMappingHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterMapMapKey(MapKeyMappingHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterMapMapKey(MapKeyMappingHandler value);
    private void InvokeBeforeMapUnionSubclass(Type type, IUnionSubclassAttributesMapper unionsubclasscustomizer);
    private void InvokeBeforeMapJoinedSubclass(Type type, IJoinedSubclassAttributesMapper joinedsubclasscustomizer);
    private void InvokeBeforeMapSubclass(Type type, ISubclassAttributesMapper subclasscustomizer);
    private void InvokeBeforeMapClass(Type type, IClassAttributesMapper classcustomizer);
    private void InvokeBeforeMapProperty(PropertyPath member, IPropertyMapper propertycustomizer);
    private void InvokeBeforeMapManyToOne(PropertyPath member, IManyToOneMapper propertycustomizer);
    private void InvokeBeforeMapOneToOne(PropertyPath member, IOneToOneMapper propertycustomizer);
    private void InvokeBeforeMapAny(PropertyPath member, IAnyMapper propertycustomizer);
    private void InvokeBeforeMapComponent(PropertyPath member, IComponentAttributesMapper propertycustomizer);
    private void InvokeBeforeMapSet(PropertyPath member, ISetPropertiesMapper propertycustomizer);
    private void InvokeBeforeMapBag(PropertyPath member, IBagPropertiesMapper propertycustomizer);
    private void InvokeBeforeMapIdBag(PropertyPath member, IIdBagPropertiesMapper propertycustomizer);
    private void InvokeBeforeMapList(PropertyPath member, IListPropertiesMapper propertycustomizer);
    private void InvokeBeforeMapMap(PropertyPath member, IMapPropertiesMapper propertycustomizer);
    private void InvokeBeforeMapManyToMany(PropertyPath member, IManyToManyMapper collectionrelationmanytomanycustomizer);
    private void InvokeBeforeMapElement(PropertyPath member, IElementMapper collectionrelationelementcustomizer);
    private void InvokeBeforeMapOneToMany(PropertyPath member, IOneToManyMapper collectionrelationonetomanycustomizer);
    private void InvokeBeforeMapMapKeyManyToMany(PropertyPath member, IMapKeyManyToManyMapper mapkeymanytomanycustomizer);
    private void InvokeBeforeMapMapKey(PropertyPath member, IMapKeyMapper mapkeyelementcustomizer);
    private void InvokeAfterMapUnionSubclass(Type type, IUnionSubclassAttributesMapper unionsubclasscustomizer);
    private void InvokeAfterMapJoinedSubclass(Type type, IJoinedSubclassAttributesMapper joinedsubclasscustomizer);
    private void InvokeAfterMapSubclass(Type type, ISubclassAttributesMapper subclasscustomizer);
    private void InvokeAfterMapClass(Type type, IClassAttributesMapper classcustomizer);
    private void InvokeAfterMapProperty(PropertyPath member, IPropertyMapper propertycustomizer);
    private void InvokeAfterMapManyToOne(PropertyPath member, IManyToOneMapper propertycustomizer);
    private void InvokeAfterMapOneToOne(PropertyPath member, IOneToOneMapper propertycustomizer);
    private void InvokeAfterMapAny(PropertyPath member, IAnyMapper propertycustomizer);
    private void InvokeAfterMapComponent(PropertyPath member, IComponentAttributesMapper propertycustomizer);
    private void InvokeAfterMapSet(PropertyPath member, ISetPropertiesMapper propertycustomizer);
    private void InvokeAfterMapBag(PropertyPath member, IBagPropertiesMapper propertycustomizer);
    private void InvokeAfterMapIdBag(PropertyPath member, IIdBagPropertiesMapper propertycustomizer);
    private void InvokeAfterMapList(PropertyPath member, IListPropertiesMapper propertycustomizer);
    private void InvokeAfterMapMap(PropertyPath member, IMapPropertiesMapper propertycustomizer);
    private void InvokeAfterMapManyToMany(PropertyPath member, IManyToManyMapper collectionrelationmanytomanycustomizer);
    private void InvokeAfterMapElement(PropertyPath member, IElementMapper collectionrelationelementcustomizer);
    private void InvokeAfterMapOneToMany(PropertyPath member, IOneToManyMapper collectionrelationonetomanycustomizer);
    private void InvokeAfterMapMapKeyManyToMany(PropertyPath member, IMapKeyManyToManyMapper mapkeymanytomanycustomizer);
    private void InvokeAfterMapMapKey(PropertyPath member, IMapKeyMapper mapkeyelementcustomizer);
    public IModelInspector get_ModelInspector();
    protected ICandidatePersistentMembersProvider get_MembersProvider();
    public void Class(Action`1<IClassMapper`1<TRootEntity>> customizeAction);
    public void Subclass(Action`1<ISubclassMapper`1<TEntity>> customizeAction);
    public void JoinedSubclass(Action`1<IJoinedSubclassMapper`1<TEntity>> customizeAction);
    public void UnionSubclass(Action`1<IUnionSubclassMapper`1<TEntity>> customizeAction);
    public void Component(Action`1<IComponentMapper`1<TComponent>> customizeAction);
    public void Import();
    public void Import(string rename);
    public HbmMapping CompileMappingFor(IEnumerable`1<Type> types);
    public IEnumerable`1<HbmMapping> CompileMappingForEach(IEnumerable`1<Type> types);
    private HbmMapping NewHbmMapping(string defaultAssemblyName, string defaultNamespace);
    private IEnumerable`1<Type> Subclasses(IEnumerable`1<Type> entities);
    private IEnumerable`1<Type> RootClasses(IEnumerable`1<Type> entities);
    private void AddSubclassMapping(HbmMapping mapping, Type type, ICollection`1<Type> mappedEntities);
    private void MapUnionSubclass(Type type, HbmMapping mapping, ICollection`1<Type> mappedEntities);
    private void MapSubclass(Type type, HbmMapping mapping, ICollection`1<Type> mappedEntities);
    private void MapJoinedSubclass(Type type, HbmMapping mapping, ICollection`1<Type> mappedEntities);
    private static Type GetEntityBaseType(Type type, ICollection`1<Type> mappedEntities);
    private void MapRootClass(Type type, HbmMapping mapping);
    private void MapSplitProperties(Type propertiesContainerType, IEnumerable`1<MemberInfo> propertiesToMap, IJoinMapper propertiesContainer);
    private void InvokeClassCustomizers(Type type, ClassMapper classMapper);
    private void InvokeAncestorsCustomizers(IEnumerable`1<Type> typeAncestors, IClassMapper classMapper);
    private void MapComposedIdProperties(IMinimalPlainPropertyContainerMapper composedIdMapper, PropertyPath propertyPath);
    private void MapNaturalIdProperties(Type rootEntityType, INaturalIdMapper naturalIdMapper, MemberInfo property);
    private void MapProperties(Type propertiesContainerType, IEnumerable`1<MemberInfo> propertiesToMap, IPropertyContainerMapper propertiesContainer);
    private void MapProperties(Type propertiesContainerType, IEnumerable`1<MemberInfo> propertiesToMap, IPropertyContainerMapper propertiesContainer, PropertyPath path);
    private void MapDynamicComponent(MemberInfo member, PropertyPath memberPath, Type propertyType, IBasePlainPropertyContainerMapper propertiesContainer);
    private void MapAny(MemberInfo member, PropertyPath memberPath, IBasePlainPropertyContainerMapper propertiesContainer);
    private void MapProperty(MemberInfo member, PropertyPath propertyPath, IMinimalPlainPropertyContainerMapper propertiesContainer);
    protected void ForEachMemberPath(MemberInfo member, PropertyPath progressivePath, Action`1<PropertyPath> invoke);
    private void MapComponent(MemberInfo member, PropertyPath memberPath, Type propertyType, IBasePlainPropertyContainerMapper propertiesContainer, Type propertiesContainerType);
    protected MemberInfo GetComponentParentReferenceProperty(IEnumerable`1<MemberInfo> persistentProperties, Type propertiesContainerType);
    private void MapBag(MemberInfo member, PropertyPath propertyPath, Type propertyType, ICollectionPropertiesContainerMapper propertiesContainer, Type propertiesContainerType);
    private void MapList(MemberInfo member, PropertyPath propertyPath, Type propertyType, ICollectionPropertiesContainerMapper propertiesContainer, Type propertiesContainerType);
    private void MapDictionary(MemberInfo member, PropertyPath propertyPath, Type propertyType, ICollectionPropertiesContainerMapper propertiesContainer, Type propertiesContainerType);
    private void MapSet(MemberInfo member, PropertyPath propertyPath, Type propertyType, ICollectionPropertiesContainerMapper propertiesContainer, Type propertiesContainerType);
    private void MapIdBag(MemberInfo member, PropertyPath propertyPath, Type propertyType, ICollectionPropertiesContainerMapper propertiesContainer, Type propertiesContainerType);
    private void MapOneToOne(MemberInfo member, PropertyPath propertyPath, IPlainPropertyContainerMapper propertiesContainer);
    private void MapManyToOne(MemberInfo member, PropertyPath propertyPath, IMinimalPlainPropertyContainerMapper propertiesContainer);
    private Type GetCollectionElementTypeOrThrow(Type type, MemberInfo property, Type propertyType);
    protected virtual ICollectionElementRelationMapper DetermineCollectionElementRelationType(MemberInfo property, PropertyPath propertyPath, Type collectionElementType);
    private IMapKeyRelationMapper DetermineMapKeyRelationType(MemberInfo member, PropertyPath propertyPath, Type dictionaryKeyType);
    public void AddMapping();
    public void AddMapping(IConformistHoldersProvider mapping);
    public void AddMapping(Type type);
    public void AddMappings(IEnumerable`1<Type> types);
    public HbmMapping CompileMappingForAllExplicitlyAddedEntities();
    public IEnumerable`1<HbmMapping> CompileMappingForEachExplicitlyAddedEntity();
    private List`1<Type> GetEntitiesToMapOrderedByHierarchy(IEnumerable`1<Type> types);
    [CompilerGeneratedAttribute]
private bool <Subclasses>b__176_0(Type type);
    [CompilerGeneratedAttribute]
private bool <RootClasses>b__177_0(Type type);
    [CompilerGeneratedAttribute]
private bool <MapUnionSubclass>b__179_0(MemberInfo p);
    [CompilerGeneratedAttribute]
private bool <MapJoinedSubclass>b__181_0(MemberInfo p);
    [CompilerGeneratedAttribute]
private bool <InvokeAncestorsCustomizers>b__186_0(Type t);
}
public class NHibernate.Mapping.ByCode.NativeGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.NativeGuidGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public abstract class NHibernate.Mapping.ByCode.NotFoundMode : object {
    public static NotFoundMode Ignore;
    public static NotFoundMode Exception;
    private static NotFoundMode();
    public abstract virtual HbmNotFoundMode ToHbm();
}
public enum NHibernate.Mapping.ByCode.OnDeleteAction : Enum {
    public int value__;
    public static OnDeleteAction NoAction;
    public static OnDeleteAction Cascade;
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.OneToOneMapperExtensions : object {
    [ExtensionAttribute]
public static void Formulas(IOneToOneMapper mapper, String[] formulas);
    [ExtensionAttribute]
public static void Fetch(IOneToOneMapper mapper, FetchKind fetchMode);
}
public enum NHibernate.Mapping.ByCode.OptimisticLockMode : Enum {
    public int value__;
    public static OptimisticLockMode None;
    public static OptimisticLockMode Version;
    public static OptimisticLockMode Dirty;
    public static OptimisticLockMode All;
}
public enum NHibernate.Mapping.ByCode.PolymorphismType : Enum {
    public int value__;
    public static PolymorphismType Implicit;
    public static PolymorphismType Explicit;
}
public abstract class NHibernate.Mapping.ByCode.PropertyGeneration : object {
    public static PropertyGeneration Never;
    public static PropertyGeneration Insert;
    public static PropertyGeneration Always;
    private static PropertyGeneration();
    internal abstract virtual HbmPropertyGeneration ToHbm();
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.PropertyMapperExtensions : object {
    [ExtensionAttribute]
public static void FetchGroup(IPropertyMapper mapper, string name);
}
public class NHibernate.Mapping.ByCode.PropertyPath : object {
    private int hashCode;
    private MemberInfo localMember;
    private PropertyPath previousPath;
    public PropertyPath PreviousPath { get; }
    public MemberInfo LocalMember { get; }
    public PropertyPath(PropertyPath previousPath, MemberInfo localMember);
    public PropertyPath get_PreviousPath();
    public MemberInfo get_LocalMember();
    public MemberInfo GetRootMember();
    public virtual bool Equals(object obj);
    public bool Equals(PropertyPath other);
    public virtual int GetHashCode();
    public string ToColumnName();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.PropertyPathExtensions : object {
    [ExtensionAttribute]
public static Type GetContainerEntity(PropertyPath propertyPath, IModelInspector domainInspector);
    [ExtensionAttribute]
public static string ToColumnName(PropertyPath propertyPath, string pathSeparator);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.PropertyPathExtensions/<InverseProgressivePath>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<PropertyPath> InverseProgressivePath(PropertyPath source);
    [ExtensionAttribute]
public static PropertyPath DepureFirstLevelIfCollection(PropertyPath source);
}
public class NHibernate.Mapping.ByCode.PropertyToField : object {
    private static Dictionary`2<string, IFieldNamingStrategy> FieldNamingStrategies;
    public static IDictionary`2<string, IFieldNamingStrategy> DefaultStrategies { get; }
    private static PropertyToField();
    public static IDictionary`2<string, IFieldNamingStrategy> get_DefaultStrategies();
    public static FieldInfo GetBackFieldInfo(PropertyInfo subject);
}
[FlagsAttribute]
public enum NHibernate.Mapping.ByCode.SchemaAction : Enum {
    public int value__;
    public static SchemaAction None;
    public static SchemaAction Drop;
    public static SchemaAction Update;
    public static SchemaAction Export;
    public static SchemaAction Validate;
    public static SchemaAction All;
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.SchemaActionConverter : object {
    [ExtensionAttribute]
public static string ToSchemaActionString(SchemaAction source);
    [ExtensionAttribute]
public static bool Has(SchemaAction source, SchemaAction value);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.SchemaActionConverter/<SchemaActionDefinitions>d__2")]
[ExtensionAttribute]
private static IEnumerable`1<string> SchemaActionDefinitions(SchemaAction source);
}
public class NHibernate.Mapping.ByCode.SelectGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.SequenceGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.SequenceHiLoGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.SequenceIdentityGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.SimpleModelInspector : object {
    private MixinDeclaredModel declaredModel;
    private Func`3<Type, bool, bool> isEntity;
    private Func`3<Type, bool, bool> isRootEntity;
    private Func`3<Type, bool, bool> isTablePerClass;
    private Func`3<SplitDefinition, bool, bool> isTablePerClassSplit;
    private Func`3<Type, bool, bool> isTablePerClassHierarchy;
    private Func`3<Type, bool, bool> isTablePerConcreteClass;
    private Func`3<Type, IEnumerable`1<string>, IEnumerable`1<string>> splitsForType;
    private Func`3<Type, bool, bool> isComponent;
    private Func`3<MemberInfo, bool, bool> isPersistentId;
    private Func`3<MemberInfo, bool, bool> isPersistentProperty;
    private Func`3<MemberInfo, bool, bool> isVersion;
    private Func`3<MemberInfo, bool, bool> isProperty;
    private Func`3<MemberInfo, bool, bool> isDynamicComponent;
    private Func`3<MemberInfo, bool, bool> isAny;
    private Func`3<MemberInfo, bool, bool> isManyToMany;
    private Func`3<MemberInfo, bool, bool> isManyToAny;
    private Func`3<MemberInfo, bool, bool> isManyToOne;
    private Func`3<MemberInfo, bool, bool> isMemberOfNaturalId;
    private Func`3<MemberInfo, bool, bool> isOneToMany;
    private Func`3<MemberInfo, bool, bool> isOneToOne;
    private Func`3<MemberInfo, bool, bool> isSet;
    private Func`3<MemberInfo, bool, bool> isArray;
    private Func`3<MemberInfo, bool, bool> isBag;
    private Func`3<MemberInfo, bool, bool> isDictionary;
    private Func`3<MemberInfo, bool, bool> isIdBag;
    private Func`3<MemberInfo, bool, bool> isList;
    private IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.RootEntities { get; }
    private IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Components { get; }
    private IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.TablePerClassEntities { get; }
    private IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.TablePerClassHierarchyEntities { get; }
    private IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.TablePerConcreteClassEntities { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.OneToOneRelations { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.ManyToOneRelations { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.KeyManyToManyRelations { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.ItemManyToManyRelations { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.OneToManyRelations { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.ManyToAnyRelations { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Any { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Poids { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.VersionProperties { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.NaturalIds { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Sets { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Bags { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.IdBags { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Lists { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Arrays { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Dictionaries { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.Properties { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.PersistentMembers { get; }
    private IEnumerable`1<SplitDefinition> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.SplitDefinitions { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.DynamicComponents { get; }
    private IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.ComposedIds { get; }
    private bool MatchRootEntity(Type type);
    private bool MatchTablePerClass(Type type);
    private bool MatchOneToMany(MemberInfo memberInfo);
    private bool MatchManyToOne(MemberInfo memberInfo);
    protected bool MatchArrayMember(MemberInfo subject);
    protected bool MatchDictionaryMember(MemberInfo subject);
    protected bool MatchBagMember(MemberInfo subject);
    protected bool MatchCollection(MemberInfo subject, Predicate`1<MemberInfo> specificCollectionPredicate);
    protected bool MatchSetMember(MemberInfo subject);
    protected bool MatchNoReadOnlyPropertyPattern(MemberInfo subject);
    protected bool IsReadOnlyProperty(MemberInfo subject);
    protected bool IsAutoproperty(PropertyInfo property);
    protected bool CanReadCantWriteInsideType(PropertyInfo property);
    protected bool CanReadCantWriteInBaseType(PropertyInfo property);
    protected bool MatchPoIdPattern(MemberInfo subject);
    protected bool MatchComponentPattern(Type subject);
    protected bool MatchEntity(Type subject);
    private sealed virtual override IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_RootEntities();
    private sealed virtual override IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Components();
    private sealed virtual override IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_TablePerClassEntities();
    private sealed virtual override IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_TablePerClassHierarchyEntities();
    private sealed virtual override IEnumerable`1<Type> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_TablePerConcreteClassEntities();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_OneToOneRelations();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_ManyToOneRelations();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_KeyManyToManyRelations();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_ItemManyToManyRelations();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_OneToManyRelations();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_ManyToAnyRelations();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Any();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Poids();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_VersionProperties();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_NaturalIds();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Sets();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Bags();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_IdBags();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Lists();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Arrays();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Dictionaries();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_Properties();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_PersistentMembers();
    private sealed virtual override IEnumerable`1<SplitDefinition> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_SplitDefinitions();
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_DynamicComponents();
    private sealed virtual override IEnumerable`1<string> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.GetSplitGroupsFor(Type type);
    private sealed virtual override string NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.GetSplitGroupFor(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsRootEntity(Type type);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsComponent(Type type);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsTablePerClassEntity(Type type);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsTablePerClassHierarchyEntity(Type type);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsTablePerConcreteClassEntity(Type type);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsOneToOneRelation(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsManyToOneRelation(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsManyToManyKeyRelation(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsManyToManyItemRelation(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsOneToManyRelation(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsManyToAnyRelation(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsAny(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsPoid(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsVersionProperty(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsNaturalId(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsSet(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsBag(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsIdBag(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsList(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsArray(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsMap(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsProperty(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsPersistentMember(MemberInfo member);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsPropertySplit(SplitDefinition definition);
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsDynamicComponent(MemberInfo member, Type componentTemplate);
    private sealed virtual override IEnumerable`1<MemberInfo> NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.get_ComposedIds();
    private sealed virtual override void NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.AddAsPartOfComposedId(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsRootEntity(Type type);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsComponent(Type type);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsEntity(Type type);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsTablePerClass(Type type);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsTablePerClassSplit(Type type, object splitGroupId, MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsTablePerClassHierarchy(Type type);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsTablePerConcreteClass(Type type);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsOneToOne(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsManyToOne(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsManyToManyItem(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsManyToManyKey(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsOneToMany(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsManyToAny(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsAny(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsPersistentId(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsMemberOfComposedId(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsVersion(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsMemberOfNaturalId(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsPersistentProperty(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsSet(MemberInfo role);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsBag(MemberInfo role);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsIdBag(MemberInfo role);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsList(MemberInfo role);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsArray(MemberInfo role);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsDictionary(MemberInfo role);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsProperty(MemberInfo member);
    private sealed virtual override bool NHibernate.Mapping.ByCode.IModelInspector.IsDynamicComponent(MemberInfo member);
    private sealed virtual override Type NHibernate.Mapping.ByCode.IModelInspector.GetDynamicComponentTemplate(MemberInfo member);
    private sealed virtual override Type NHibernate.Mapping.ByCode.IModelExplicitDeclarationsHolder.GetDynamicComponentTemplate(MemberInfo member);
    private sealed virtual override IEnumerable`1<string> NHibernate.Mapping.ByCode.IModelInspector.GetPropertiesSplits(Type type);
    protected virtual bool DeclaredPolymorphicMatch(MemberInfo member, Func`2<MemberInfo, bool> declaredMatch);
    public void IsRootEntity(Func`3<Type, bool, bool> match);
    public void IsComponent(Func`3<Type, bool, bool> match);
    public void IsEntity(Func`3<Type, bool, bool> match);
    public void IsTablePerClass(Func`3<Type, bool, bool> match);
    public void IsTablePerClassHierarchy(Func`3<Type, bool, bool> match);
    public void IsTablePerConcreteClass(Func`3<Type, bool, bool> match);
    public void IsOneToOne(Func`3<MemberInfo, bool, bool> match);
    public void IsManyToOne(Func`3<MemberInfo, bool, bool> match);
    public void IsManyToMany(Func`3<MemberInfo, bool, bool> match);
    public void IsOneToMany(Func`3<MemberInfo, bool, bool> match);
    public void IsManyToAny(Func`3<MemberInfo, bool, bool> match);
    public void IsAny(Func`3<MemberInfo, bool, bool> match);
    public void IsPersistentId(Func`3<MemberInfo, bool, bool> match);
    public void IsVersion(Func`3<MemberInfo, bool, bool> match);
    public void IsMemberOfNaturalId(Func`3<MemberInfo, bool, bool> match);
    public void IsPersistentProperty(Func`3<MemberInfo, bool, bool> match);
    public void IsSet(Func`3<MemberInfo, bool, bool> match);
    public void IsBag(Func`3<MemberInfo, bool, bool> match);
    public void IsIdBag(Func`3<MemberInfo, bool, bool> match);
    public void IsList(Func`3<MemberInfo, bool, bool> match);
    public void IsArray(Func`3<MemberInfo, bool, bool> match);
    public void IsDictionary(Func`3<MemberInfo, bool, bool> match);
    public void IsProperty(Func`3<MemberInfo, bool, bool> match);
    public void SplitsFor(Func`3<Type, IEnumerable`1<string>, IEnumerable`1<string>> getPropertiesSplitsId);
    public void IsTablePerClassSplit(Func`3<SplitDefinition, bool, bool> match);
    public void IsDynamicComponent(Func`3<MemberInfo, bool, bool> match);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_0(Type t, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_1(Type t, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_2(Type t, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_3(MemberInfo m, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_4(Type t, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_5(MemberInfo m, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_6(MemberInfo m, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_7(MemberInfo m, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_8(MemberInfo m, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_9(MemberInfo m, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_10(MemberInfo m, bool declared);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__28_11(MemberInfo m, bool declared);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsOneToOne>b__133_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsManyToOne>b__134_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsManyToManyItem>b__135_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsManyToManyKey>b__136_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsOneToMany>b__137_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsManyToAny>b__138_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsAny>b__139_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsPersistentId>b__140_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsVersion>b__142_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsMemberOfNaturalId>b__143_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsPersistentProperty>b__144_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsSet>b__145_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsBag>b__146_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsIdBag>b__147_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsList>b__148_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsArray>b__149_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsDictionary>b__150_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsProperty>b__151_0(MemberInfo m);
    [CompilerGeneratedAttribute]
private bool <NHibernate.Mapping.ByCode.IModelInspector.IsDynamicComponent>b__152_0(MemberInfo m);
}
public class NHibernate.Mapping.ByCode.SplitDefinition : object {
    [CompilerGeneratedAttribute]
private Type <On>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    public Type On { get; private set; }
    public string GroupId { get; private set; }
    public MemberInfo Member { get; private set; }
    public SplitDefinition(Type on, string groupId, MemberInfo member);
    [CompilerGeneratedAttribute]
public Type get_On();
    [CompilerGeneratedAttribute]
private void set_On(Type value);
    [CompilerGeneratedAttribute]
public string get_GroupId();
    [CompilerGeneratedAttribute]
private void set_GroupId(string value);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(MemberInfo value);
}
public enum NHibernate.Mapping.ByCode.SqlCheck : Enum {
    public int value__;
    public static SqlCheck None;
    public static SqlCheck RowCount;
    public static SqlCheck Param;
}
[ExtensionAttribute]
internal static class NHibernate.Mapping.ByCode.SqlCheckExtensions : object {
    [ExtensionAttribute]
public static HbmCustomSQLCheck ToHbmSqlCheck(SqlCheck check);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.SubclassAttributesMapperExtensions : object {
    [ExtensionAttribute]
public static void Extends(ISubclassAttributesMapper`1<TEntity> mapper, string entityOrClassName);
    [ExtensionAttribute]
public static void Extends(ISubclassAttributesMapper mapper, string entityOrClassName);
}
public class NHibernate.Mapping.ByCode.TableGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.TableHiLoGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.TriggerIdentityGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.TypeExtensions : object {
    private static BindingFlags PropertiesOfClassHierarchy;
    private static BindingFlags PropertiesOrFieldOfClass;
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.TypeExtensions/<GetBaseTypes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetBaseTypes(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetHierarchyFromBase(Type type);
    [ExtensionAttribute]
public static Type GetPropertyOrFieldType(MemberInfo propertyOrField);
    public static MemberInfo DecodeMemberAccessExpression(Expression`1<Func`2<TEntity, object>> expression);
    public static MemberInfo DecodeMemberAccessExpression(Expression`1<Func`2<TEntity, TProperty>> expression);
    public static MemberInfo DecodeMemberAccessExpressionOf(Expression`1<Func`2<TEntity, object>> expression);
    public static MemberInfo DecodeMemberAccessExpressionOf(Expression`1<Func`2<TEntity, TProperty>> expression);
    [ExtensionAttribute]
public static MemberInfo GetMemberFromDeclaringType(MemberInfo source);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetMemberFromDeclaringClasses(MemberInfo source);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.TypeExtensions/<GetPropertyFromInterfaces>d__11")]
[ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetPropertyFromInterfaces(MemberInfo source);
    [ExtensionAttribute]
public static Type DetermineCollectionElementType(Type genericCollection);
    [ExtensionAttribute]
public static Type DetermineRequiredCollectionElementType(MemberInfo collectionProperty);
    [ExtensionAttribute]
public static Type DetermineCollectionElementOrDictionaryValueType(Type genericCollection);
    [ExtensionAttribute]
public static Type DetermineDictionaryKeyType(Type genericDictionary);
    private static Type GetDictionaryInterface(Type genericDictionary);
    [ExtensionAttribute]
public static Type DetermineDictionaryValueType(Type genericDictionary);
    [ExtensionAttribute]
public static bool IsGenericCollection(Type source);
    [ExtensionAttribute]
public static MemberInfo GetFirstPropertyOfType(Type propertyContainerType, Type propertyType);
    [ExtensionAttribute]
public static MemberInfo GetFirstPropertyOfType(Type propertyContainerType, Type propertyType, Func`2<PropertyInfo, bool> acceptPropertyClauses);
    [ExtensionAttribute]
public static MemberInfo GetFirstPropertyOfType(Type propertyContainerType, Type propertyType, BindingFlags bindingFlags);
    [ExtensionAttribute]
public static MemberInfo GetFirstPropertyOfType(Type propertyContainerType, Type propertyType, BindingFlags bindingFlags, Func`2<PropertyInfo, bool> acceptPropertyClauses);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.TypeExtensions/<GetInterfaceProperties>d__23")]
[ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetInterfaceProperties(Type type);
    [ExtensionAttribute]
public static bool IsEnumOrNullableEnum(Type type);
    [ExtensionAttribute]
public static bool IsFlagEnumOrNullableFlagEnum(Type type);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.TypeExtensions/<GetGenericInterfaceTypeDefinitions>d__26")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetGenericInterfaceTypeDefinitions(Type type);
    [ExtensionAttribute]
public static Type GetFirstImplementorOf(Type source, Type abstractType);
    [ExtensionAttribute]
public static bool HasPublicPropertyOf(Type source, Type typeOfProperty);
    [ExtensionAttribute]
public static bool HasPublicPropertyOf(Type source, Type typeOfProperty, Func`2<PropertyInfo, bool> acceptPropertyClauses);
    [ExtensionAttribute]
public static MemberInfo GetMemberFromReflectedType(MemberInfo member, Type reflectedType);
    [ExtensionAttribute]
public static MemberInfo GetPropertyOrFieldMatchingName(Type source, string memberName);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.TypeExtensions/<GetPropertiesOfInterfacesImplemented>d__32")]
[ExtensionAttribute]
private static IEnumerable`1<MemberInfo> GetPropertiesOfInterfacesImplemented(Type source);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.TypeExtensions/<GetPropertiesOfHierarchy>d__33")]
[ExtensionAttribute]
internal static IEnumerable`1<MemberInfo> GetPropertiesOfHierarchy(Type type);
    [IteratorStateMachineAttribute("NHibernate.Mapping.ByCode.TypeExtensions/<GetFieldsOfHierarchy>d__34")]
[ExtensionAttribute]
private static IEnumerable`1<MemberInfo> GetFieldsOfHierarchy(Type type);
    private static IEnumerable`1<FieldInfo> GetUserDeclaredFields(Type type);
}
[ExtensionAttribute]
public static class NHibernate.Mapping.ByCode.UnionSubclassAttributesMapperExtensions : object {
    [ExtensionAttribute]
public static void Extends(IUnionSubclassAttributesMapper`1<TEntity> mapper, string entityOrClassName);
    [ExtensionAttribute]
public static void Extends(IUnionSubclassAttributesMapper mapper, string entityOrClassName);
}
public enum NHibernate.Mapping.ByCode.UnsavedValueType : Enum {
    public int value__;
    public static UnsavedValueType Undefined;
    public static UnsavedValueType Any;
    public static UnsavedValueType None;
}
public class NHibernate.Mapping.ByCode.UUIDHexGeneratorDef : object {
    private object param;
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public UUIDHexGeneratorDef(string format);
    public UUIDHexGeneratorDef(string format, string separator);
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public class NHibernate.Mapping.ByCode.UUIDStringGeneratorDef : object {
    public string Class { get; }
    public object Params { get; }
    public Type DefaultReturnType { get; }
    public bool SupportedAsCollectionElementId { get; }
    public sealed virtual string get_Class();
    public sealed virtual object get_Params();
    public sealed virtual Type get_DefaultReturnType();
    public sealed virtual bool get_SupportedAsCollectionElementId();
}
public abstract class NHibernate.Mapping.ByCode.VersionGeneration : object {
    public static VersionGeneration Never;
    public static VersionGeneration Always;
    private static VersionGeneration();
    public abstract virtual HbmVersionGeneration ToHbm();
}
public abstract class NHibernate.Mapping.Collection : object {
    private static IEnumerable`1<ISelectable> EmptyColumns;
    public static string DefaultElementColumnName;
    public static string DefaultKeyColumnName;
    private IKeyValue key;
    private IValue element;
    private Table collectionTable;
    private string role;
    private bool lazy;
    private bool extraLazy;
    private bool inverse;
    private bool mutable;
    private string cacheConcurrencyStrategy;
    private string cacheRegionName;
    private string orderBy;
    private string where;
    private PersistentClass owner;
    private bool sorted;
    private object comparer;
    private bool orphanDelete;
    private int batchSize;
    private FetchMode fetchMode;
    private Type collectionPersisterClass;
    private string referencedPropertyName;
    private string typeName;
    private string loaderName;
    private SqlString customSQLInsert;
    private bool customInsertCallable;
    private ExecuteUpdateResultCheckStyle insertCheckStyle;
    private SqlString customSQLDelete;
    private bool customDeleteCallable;
    private ExecuteUpdateResultCheckStyle deleteCheckStyle;
    private SqlString customSQLUpdate;
    private bool customUpdateCallable;
    private ExecuteUpdateResultCheckStyle updateCheckStyle;
    private SqlString customSQLDeleteAll;
    private bool customDeleteAllCallable;
    private ExecuteUpdateResultCheckStyle deleteAllCheckStyle;
    private bool isGeneric;
    private Type[] genericArguments;
    private Dictionary`2<string, string> filters;
    private Dictionary`2<string, string> manyToManyFilters;
    private bool subselectLoadable;
    private string manyToManyWhere;
    private string manyToManyOrderBy;
    private bool optimisticLocked;
    private HashSet`1<string> synchronizedTables;
    private IDictionary`2<string, string> typeParameters;
    [CompilerGeneratedAttribute]
private string <ComparerClassName>k__BackingField;
    public int ColumnSpan { get; }
    public bool IsSet { get; }
    public IKeyValue Key { get; public set; }
    public IValue Element { get; public set; }
    public bool IsIndexed { get; }
    public Table CollectionTable { get; public set; }
    public Table Table { get; }
    public bool IsSorted { get; public set; }
    public bool HasOrder { get; }
    public PersistentClass Owner { get; public set; }
    public Type CollectionPersisterClass { get; public set; }
    public object Comparer { get; public set; }
    public string ComparerClassName { get; public set; }
    public bool IsLazy { get; public set; }
    public string Role { get; public set; }
    public IEnumerable`1<ISelectable> ColumnIterator { get; }
    public Formula Formula { get; }
    public bool IsNullable { get; }
    public bool IsUnique { get; }
    public CollectionType CollectionType { get; }
    public CollectionType DefaultCollectionType { get; }
    public IType Type { get; }
    public bool IsPrimitiveArray { get; }
    public bool IsArray { get; }
    public bool HasFormula { get; }
    public bool IsIdentified { get; }
    public bool IsOneToMany { get; }
    public string CacheConcurrencyStrategy { get; public set; }
    public string CacheRegionName { get; public set; }
    public bool IsInverse { get; public set; }
    public string OwnerEntityName { get; }
    public string OrderBy { get; public set; }
    public string Where { get; public set; }
    public bool HasOrphanDelete { get; public set; }
    public int BatchSize { get; public set; }
    public FetchMode FetchMode { get; public set; }
    public bool IsGeneric { get; public set; }
    public Type[] GenericArguments { get; public set; }
    public bool IsSimpleValue { get; }
    public string ReferencedPropertyName { get; public set; }
    public Boolean[] ColumnInsertability { get; }
    public Boolean[] ColumnUpdateability { get; }
    public string TypeName { get; public set; }
    public SqlString CustomSQLInsert { get; }
    public SqlString CustomSQLDelete { get; }
    public SqlString CustomSQLUpdate { get; }
    public SqlString CustomSQLDeleteAll { get; }
    public bool IsCustomInsertCallable { get; }
    public bool IsCustomDeleteCallable { get; }
    public bool IsCustomUpdateCallable { get; }
    public bool IsCustomDeleteAllCallable { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLInsertCheckStyle { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLDeleteCheckStyle { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLUpdateCheckStyle { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLDeleteAllCheckStyle { get; }
    public IDictionary`2<string, string> FilterMap { get; }
    public IDictionary`2<string, string> ManyToManyFilterMap { get; }
    public string LoaderName { get; public set; }
    public bool IsSubselectLoadable { get; public set; }
    public string ManyToManyWhere { get; public set; }
    public string ManyToManyOrdering { get; public set; }
    public bool IsOptimisticLocked { get; public set; }
    public bool ExtraLazy { get; public set; }
    public bool IsAlternateUniqueKey { get; }
    public bool IsMap { get; }
    public bool IsMutable { get; public set; }
    public ISet`1<string> SynchronizedTables { get; }
    public IDictionary`2<string, string> TypeParameters { get; public set; }
    protected Collection(PersistentClass owner);
    private static Collection();
    public sealed virtual int get_ColumnSpan();
    public virtual bool get_IsSet();
    public IKeyValue get_Key();
    public void set_Key(IKeyValue value);
    public IValue get_Element();
    public void set_Element(IValue value);
    public virtual bool get_IsIndexed();
    public Table get_CollectionTable();
    public void set_CollectionTable(Table value);
    public sealed virtual Table get_Table();
    public bool get_IsSorted();
    public void set_IsSorted(bool value);
    public bool get_HasOrder();
    public PersistentClass get_Owner();
    public void set_Owner(PersistentClass value);
    public Type get_CollectionPersisterClass();
    public void set_CollectionPersisterClass(Type value);
    public object get_Comparer();
    public void set_Comparer(object value);
    [CompilerGeneratedAttribute]
public string get_ComparerClassName();
    [CompilerGeneratedAttribute]
public void set_ComparerClassName(string value);
    public sealed virtual bool get_IsLazy();
    public sealed virtual void set_IsLazy(bool value);
    public string get_Role();
    public void set_Role(string value);
    public sealed virtual IEnumerable`1<ISelectable> get_ColumnIterator();
    public Formula get_Formula();
    public sealed virtual bool get_IsNullable();
    public bool get_IsUnique();
    public virtual CollectionType get_CollectionType();
    public abstract virtual CollectionType get_DefaultCollectionType();
    public sealed virtual IType get_Type();
    public virtual bool get_IsPrimitiveArray();
    public virtual bool get_IsArray();
    public virtual bool get_HasFormula();
    public virtual bool get_IsIdentified();
    public bool get_IsOneToMany();
    public string get_CacheConcurrencyStrategy();
    public void set_CacheConcurrencyStrategy(string value);
    public string get_CacheRegionName();
    public void set_CacheRegionName(string value);
    public bool get_IsInverse();
    public void set_IsInverse(bool value);
    public string get_OwnerEntityName();
    public string get_OrderBy();
    public void set_OrderBy(string value);
    public string get_Where();
    public void set_Where(string value);
    public bool get_HasOrphanDelete();
    public void set_HasOrphanDelete(bool value);
    public int get_BatchSize();
    public void set_BatchSize(int value);
    public sealed virtual FetchMode get_FetchMode();
    public sealed virtual void set_FetchMode(FetchMode value);
    public bool get_IsGeneric();
    public void set_IsGeneric(bool value);
    public Type[] get_GenericArguments();
    public void set_GenericArguments(Type[] value);
    protected void CheckGenericArgumentsLength(int expectedLength);
    public sealed virtual void CreateForeignKey();
    private void CreateForeignKeys();
    public abstract virtual void CreatePrimaryKey();
    public virtual void CreateAllKeys();
    public sealed virtual bool get_IsSimpleValue();
    public sealed virtual bool IsValid(IMapping mapping);
    public string get_ReferencedPropertyName();
    public void set_ReferencedPropertyName(string value);
    public virtual void Validate(IMapping mapping);
    public sealed virtual Boolean[] get_ColumnInsertability();
    public sealed virtual Boolean[] get_ColumnUpdateability();
    public string get_TypeName();
    public void set_TypeName(string value);
    public SqlString get_CustomSQLInsert();
    public SqlString get_CustomSQLDelete();
    public SqlString get_CustomSQLUpdate();
    public SqlString get_CustomSQLDeleteAll();
    public bool get_IsCustomInsertCallable();
    public bool get_IsCustomDeleteCallable();
    public bool get_IsCustomUpdateCallable();
    public bool get_IsCustomDeleteAllCallable();
    public ExecuteUpdateResultCheckStyle get_CustomSQLInsertCheckStyle();
    public ExecuteUpdateResultCheckStyle get_CustomSQLDeleteCheckStyle();
    public ExecuteUpdateResultCheckStyle get_CustomSQLUpdateCheckStyle();
    public ExecuteUpdateResultCheckStyle get_CustomSQLDeleteAllCheckStyle();
    public void SetCustomSQLInsert(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public void SetCustomSQLDelete(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public void SetCustomSQLDeleteAll(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public void SetCustomSQLUpdate(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public sealed virtual void AddFilter(string name, string condition);
    public sealed virtual IDictionary`2<string, string> get_FilterMap();
    public void AddManyToManyFilter(string name, string condition);
    public IDictionary`2<string, string> get_ManyToManyFilterMap();
    public string get_LoaderName();
    public void set_LoaderName(string value);
    public bool get_IsSubselectLoadable();
    public void set_IsSubselectLoadable(bool value);
    public string get_ManyToManyWhere();
    public void set_ManyToManyWhere(string value);
    public string get_ManyToManyOrdering();
    public void set_ManyToManyOrdering(string value);
    public bool get_IsOptimisticLocked();
    public void set_IsOptimisticLocked(bool value);
    public bool get_ExtraLazy();
    public void set_ExtraLazy(bool value);
    private void CheckColumnDuplication();
    private void CheckColumnDuplication(ISet`1<string> distinctColumns, IEnumerable`1<ISelectable> columns);
    public virtual bool get_IsAlternateUniqueKey();
    public sealed virtual void SetTypeUsingReflection(string className, string propertyName, string access);
    public sealed virtual object Accept(IValueVisitor visitor);
    public virtual bool get_IsMap();
    public bool get_IsMutable();
    public void set_IsMutable(bool value);
    public ISet`1<string> get_SynchronizedTables();
    public IDictionary`2<string, string> get_TypeParameters();
    public void set_TypeParameters(IDictionary`2<string, string> value);
    public virtual string ToString();
}
public class NHibernate.Mapping.Column : object {
    public static int DefaultLength;
    public static int DefaultPrecision;
    public static int DefaultScale;
    private Nullable`1<int> _length;
    private Nullable`1<int> _precision;
    private Nullable`1<int> _scale;
    private IValue _value;
    private int _typeIndex;
    private string _name;
    private bool _nullable;
    private bool _unique;
    private string _sqlType;
    private SqlType _sqlTypeCode;
    private bool _quoted;
    internal int UniqueInteger;
    private string _checkConstraint;
    private string _comment;
    private string _defaultValue;
    private static int _charactersLeftCount;
    public int Length { get; public set; }
    public string Name { get; public set; }
    public string CanonicalName { get; }
    public bool IsNullable { get; public set; }
    public int TypeIndex { get; public set; }
    public bool IsUnique { get; public set; }
    public string SqlType { get; public set; }
    public bool IsQuoted { get; public set; }
    public bool Unique { get; public set; }
    public string CheckConstraint { get; public set; }
    public bool HasCheckConstraint { get; }
    public string Text { get; }
    public bool IsFormula { get; }
    public int Precision { get; public set; }
    public int Scale { get; public set; }
    public IValue Value { get; public set; }
    public SqlType SqlTypeCode { get; public set; }
    public string Comment { get; public set; }
    public string DefaultValue { get; public set; }
    public Column(string columnName);
    public int get_Length();
    public void set_Length(int value);
    public string get_Name();
    public void set_Name(string value);
    public string get_CanonicalName();
    public string GetQuotedName(Dialect d);
    public sealed virtual string GetAlias(Dialect dialect);
    private string GetAlias(int maxAliasLength);
    public sealed virtual string GetAlias(Dialect dialect, Table table);
    public bool get_IsNullable();
    public void set_IsNullable(bool value);
    public int get_TypeIndex();
    public void set_TypeIndex(int value);
    public bool get_IsUnique();
    public void set_IsUnique(bool value);
    public string GetSqlType(Dialect dialect, IMapping mapping);
    private string GetDialectTypeName(Dialect dialect, IMapping mapping);
    public virtual bool Equals(object obj);
    public bool Equals(Column column);
    public virtual int GetHashCode();
    public string get_SqlType();
    public void set_SqlType(string value);
    public bool get_IsQuoted();
    public void set_IsQuoted(bool value);
    public bool get_Unique();
    public void set_Unique(bool value);
    public string get_CheckConstraint();
    public void set_CheckConstraint(string value);
    public bool get_HasCheckConstraint();
    public sealed virtual string get_Text();
    public sealed virtual string GetText(Dialect dialect);
    public sealed virtual bool get_IsFormula();
    public int get_Precision();
    public void set_Precision(int value);
    public int get_Scale();
    public void set_Scale(int value);
    public IValue get_Value();
    public void set_Value(IValue value);
    public SqlType get_SqlTypeCode();
    public void set_SqlTypeCode(SqlType value);
    public string get_Comment();
    public void set_Comment(string value);
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public sealed virtual string GetTemplate(Dialect dialect, SQLFunctionRegistry functionRegistry);
    public virtual string ToString();
    public SqlType GetSqlTypeCode(IMapping mapping);
    public string GetQuotedName();
    public bool IsCaracteristicsDefined();
    public bool IsPrecisionDefined();
    public bool IsScaleDefined();
    public bool IsLengthDefined();
    public sealed virtual object Clone();
}
public class NHibernate.Mapping.Component : SimpleValue {
    private List`1<Property> properties;
    private Type componentClass;
    private bool embedded;
    private Property parentProperty;
    private PersistentClass owner;
    private bool dynamic;
    private bool isKey;
    private string roleName;
    private Dictionary`2<EntityMode, string> tuplizerImpls;
    private string componentClassName;
    private IType type;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, MetaAttribute> <MetaAttributes>k__BackingField;
    public int PropertySpan { get; }
    public IEnumerable`1<Property> PropertyIterator { get; }
    public int ColumnSpan { get; }
    public IEnumerable`1<ISelectable> ColumnIterator { get; }
    public bool IsEmbedded { get; public set; }
    public bool IsDynamic { get; public set; }
    public Type ComponentClass { get; public set; }
    public PersistentClass Owner { get; public set; }
    public Property ParentProperty { get; public set; }
    public Boolean[] ColumnInsertability { get; }
    public Boolean[] ColumnUpdateability { get; }
    public string ComponentClassName { get; public set; }
    public bool IsKey { get; public set; }
    public string RoleName { get; public set; }
    public IDictionary`2<EntityMode, string> TuplizerMap { get; }
    public bool HasPocoRepresentation { get; }
    public IType Type { get; }
    public IDictionary`2<string, MetaAttribute> MetaAttributes { get; public set; }
    public Component(PersistentClass owner);
    public Component(Table table, PersistentClass owner);
    public Component(Collection collection);
    public Component(Component component);
    public int get_PropertySpan();
    public IEnumerable`1<Property> get_PropertyIterator();
    public void AddProperty(Property p);
    public virtual void AddColumn(Column column);
    public virtual int get_ColumnSpan();
    public virtual IEnumerable`1<ISelectable> get_ColumnIterator();
    public virtual void SetTypeUsingReflection(string className, string propertyName, string accesorName);
    public bool get_IsEmbedded();
    public void set_IsEmbedded(bool value);
    public bool get_IsDynamic();
    public void set_IsDynamic(bool value);
    public Type get_ComponentClass();
    public void set_ComponentClass(Type value);
    public PersistentClass get_Owner();
    public void set_Owner(PersistentClass value);
    public Property get_ParentProperty();
    public void set_ParentProperty(Property value);
    public virtual Boolean[] get_ColumnInsertability();
    public virtual Boolean[] get_ColumnUpdateability();
    public string get_ComponentClassName();
    public void set_ComponentClassName(string value);
    public bool get_IsKey();
    public void set_IsKey(bool value);
    public string get_RoleName();
    public void set_RoleName(string value);
    public Property GetProperty(string propertyName);
    public virtual void AddTuplizer(EntityMode entityMode, string implClassName);
    public virtual string GetTuplizerImplClassName(EntityMode mode);
    public virtual IDictionary`2<EntityMode, string> get_TuplizerMap();
    public bool get_HasPocoRepresentation();
    public virtual IType get_Type();
    private IType BuildType();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, MetaAttribute> get_MetaAttributes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MetaAttributes(IDictionary`2<string, MetaAttribute> value);
    public sealed virtual MetaAttribute GetMetaAttribute(string attributeName);
}
public abstract class NHibernate.Mapping.Constraint : object {
    private string name;
    private List`1<Column> columns;
    private Table table;
    public string Name { get; public set; }
    public IEnumerable`1<Column> ColumnIterator { get; }
    public int ColumnSpan { get; }
    public IList`1<Column> Columns { get; }
    public Table Table { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public IEnumerable`1<Column> get_ColumnIterator();
    public static string GenerateName(string prefix, Table table, Table referencedTable, IEnumerable`1<Column> columns);
    public void AddColumn(Column column);
    public void AddColumns(IEnumerable`1<Column> columnIterator);
    public void AddColumns(IEnumerable`1<ISelectable> columnIterator);
    public int get_ColumnSpan();
    public IList`1<Column> get_Columns();
    public Table get_Table();
    public void set_Table(Table value);
    public virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
    public virtual string SqlCreateString(Dialect dialect, IMapping p, string defaultCatalog, string defaultSchema);
    public abstract virtual string SqlConstraintString(Dialect d, string constraintName, string defaultCatalog, string defaultSchema);
    public virtual bool IsGenerated(Dialect dialect);
    public virtual string ToString();
}
public class NHibernate.Mapping.DenormalizedTable : Table {
    private Table includedTable;
    public IEnumerable`1<Column> ColumnIterator { get; }
    public IEnumerable`1<UniqueKey> UniqueKeyIterator { get; }
    public IEnumerable`1<Index> IndexIterator { get; }
    public PrimaryKey PrimaryKey { get; public set; }
    public DenormalizedTable(Table includedTable);
    public virtual IEnumerable`1<Column> get_ColumnIterator();
    public virtual IEnumerable`1<UniqueKey> get_UniqueKeyIterator();
    [IteratorStateMachineAttribute("NHibernate.Mapping.DenormalizedTable/<get_IndexIterator>d__7")]
public virtual IEnumerable`1<Index> get_IndexIterator();
    public virtual void CreateForeignKeys();
    public virtual Column GetColumn(Column column);
    public virtual bool ContainsColumn(Column column);
    public virtual PrimaryKey get_PrimaryKey();
    public virtual void set_PrimaryKey(PrimaryKey value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<Index> <>n__0();
}
public class NHibernate.Mapping.DependantValue : SimpleValue {
    private IKeyValue wrappedValue;
    private bool isNullable;
    private bool isUpdateable;
    public IType Type { get; }
    public bool IsNullable { get; }
    public bool IsUpdateable { get; }
    public DependantValue(Table table, IKeyValue prototype);
    public virtual IType get_Type();
    public void SetTypeUsingReflection(string className, string propertyName);
    public virtual bool get_IsNullable();
    public void SetNullable(bool nullable);
    public virtual bool get_IsUpdateable();
    public virtual void SetUpdateable(bool updateable);
}
public class NHibernate.Mapping.ForeignKey : Constraint {
    private Table referencedTable;
    private string referencedEntityName;
    private bool cascadeDeleteEnabled;
    private List`1<Column> referencedColumns;
    public Table ReferencedTable { get; public set; }
    public bool CascadeDeleteEnabled { get; public set; }
    public bool HasPhysicalConstraint { get; }
    public IList`1<Column> ReferencedColumns { get; }
    public string ReferencedEntityName { get; public set; }
    public bool IsReferenceToPrimaryKey { get; }
    public string GeneratedConstraintNamePrefix { get; }
    public virtual string SqlConstraintString(Dialect d, string constraintName, string defaultCatalog, string defaultSchema);
    public Table get_ReferencedTable();
    public void set_ReferencedTable(Table value);
    public bool get_CascadeDeleteEnabled();
    public void set_CascadeDeleteEnabled(bool value);
    public virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
    public void AlignColumns();
    private void AlignColumns(Table referencedTable);
    internal static void AlignColumns(IEnumerable`1<Column> fk, IEnumerable`1<Column> pk);
    private static void AppendColumns(StringBuilder buf, IEnumerable`1<Column> columns);
    public virtual void AddReferencedColumns(IEnumerable`1<Column> referencedColumnsIterator);
    private void AddReferencedColumn(Column column);
    internal void AddReferencedTable(PersistentClass referencedClass);
    public virtual string ToString();
    public bool get_HasPhysicalConstraint();
    public IList`1<Column> get_ReferencedColumns();
    public string get_ReferencedEntityName();
    public void set_ReferencedEntityName(string value);
    public bool get_IsReferenceToPrimaryKey();
    public string get_GeneratedConstraintNamePrefix();
    public virtual bool IsGenerated(Dialect dialect);
}
public class NHibernate.Mapping.Formula : object {
    private static int formulaUniqueInteger;
    private string formula;
    private int uniqueInteger;
    public string FormulaString { get; public set; }
    public string Text { get; }
    public bool IsFormula { get; }
    public sealed virtual string GetTemplate(Dialect dialect, SQLFunctionRegistry functionRegistry);
    public string get_FormulaString();
    public void set_FormulaString(string value);
    public sealed virtual string GetText(Dialect dialect);
    public sealed virtual string get_Text();
    public sealed virtual string GetAlias(Dialect dialect);
    public sealed virtual string GetAlias(Dialect dialect, Table table);
    public sealed virtual bool get_IsFormula();
    public virtual string ToString();
}
public interface NHibernate.Mapping.IAuxiliaryDatabaseObject {
    public abstract virtual void AddDialectScope(string dialectName);
    public abstract virtual bool AppliesToDialect(Dialect dialect);
    public abstract virtual void SetParameterValues(IDictionary`2<string, string> parameters);
}
public class NHibernate.Mapping.IdentifierBag : IdentifierCollection {
    public CollectionType DefaultCollectionType { get; }
    public IdentifierBag(PersistentClass owner);
    public virtual CollectionType get_DefaultCollectionType();
}
public abstract class NHibernate.Mapping.IdentifierCollection : Collection {
    public static string DefaultIdentifierColumnName;
    private IKeyValue identifier;
    public IKeyValue Identifier { get; public set; }
    public bool IsIdentified { get; }
    protected IdentifierCollection(PersistentClass owner);
    public IKeyValue get_Identifier();
    public void set_Identifier(IKeyValue value);
    public virtual bool get_IsIdentified();
    public virtual void CreatePrimaryKey();
    public virtual void Validate(IMapping mapping);
}
public interface NHibernate.Mapping.IFetchable {
    public FetchMode FetchMode { get; public set; }
    public bool IsLazy { get; public set; }
    public abstract virtual FetchMode get_FetchMode();
    public abstract virtual void set_FetchMode(FetchMode value);
    public abstract virtual bool get_IsLazy();
    public abstract virtual void set_IsLazy(bool value);
}
public interface NHibernate.Mapping.IFilterable {
    public IDictionary`2<string, string> FilterMap { get; }
    public abstract virtual void AddFilter(string name, string condition);
    public abstract virtual IDictionary`2<string, string> get_FilterMap();
}
public interface NHibernate.Mapping.IKeyValue {
    public bool IsCascadeDeleteEnabled { get; }
    public string NullValue { get; }
    public bool IsUpdateable { get; }
    public abstract virtual void CreateForeignKeyOfEntity(string entityName);
    public abstract virtual bool get_IsCascadeDeleteEnabled();
    public abstract virtual bool IsIdentityColumn(Dialect dialect);
    public abstract virtual string get_NullValue();
    public abstract virtual bool get_IsUpdateable();
    public abstract virtual IIdentifierGenerator CreateIdentifierGenerator(Dialect dialect, string defaultCatalog, string defaultSchema, RootClass rootClass);
}
public interface NHibernate.Mapping.IMetaAttributable {
    public IDictionary`2<string, MetaAttribute> MetaAttributes { get; public set; }
    public abstract virtual IDictionary`2<string, MetaAttribute> get_MetaAttributes();
    public abstract virtual void set_MetaAttributes(IDictionary`2<string, MetaAttribute> value);
    public abstract virtual MetaAttribute GetMetaAttribute(string attributeName);
}
public class NHibernate.Mapping.Index : object {
    private Table table;
    private List`1<Column> columns;
    private string name;
    [CompilerGeneratedAttribute]
private bool <IsInherited>k__BackingField;
    public Table Table { get; public set; }
    public IEnumerable`1<Column> ColumnIterator { get; }
    public int ColumnSpan { get; }
    public string Name { get; public set; }
    public bool IsInherited { get; public set; }
    public static string BuildSqlCreateIndexString(Dialect dialect, string name, Table table, IEnumerable`1<Column> columns, bool unique, string defaultCatalog, string defaultSchema);
    public static string BuildSqlDropIndexString(Dialect dialect, Table table, string name, string defaultCatalog, string defaultSchema);
    public sealed virtual string SqlCreateString(Dialect dialect, IMapping p, string defaultCatalog, string defaultSchema);
    public sealed virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
    public Table get_Table();
    public void set_Table(Table value);
    public IEnumerable`1<Column> get_ColumnIterator();
    public int get_ColumnSpan();
    public void AddColumn(Column column);
    public void AddColumns(IEnumerable`1<Column> extraColumns);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsInherited();
    [CompilerGeneratedAttribute]
public void set_IsInherited(bool value);
    public bool ContainsColumn(Column column);
    public virtual string ToString();
}
public class NHibernate.Mapping.IndexBackref : Property {
    private string collectionRole;
    private string entityName;
    public string CollectionRole { get; public set; }
    public string EntityName { get; public set; }
    public bool BackRef { get; }
    public bool IsBasicPropertyAccessor { get; }
    protected IPropertyAccessor PropertyAccessor { get; }
    public string get_CollectionRole();
    public void set_CollectionRole(string value);
    public string get_EntityName();
    public void set_EntityName(string value);
    public virtual bool get_BackRef();
    public virtual bool get_IsBasicPropertyAccessor();
    protected virtual IPropertyAccessor get_PropertyAccessor();
}
public abstract class NHibernate.Mapping.IndexedCollection : Collection {
    public static string DefaultIndexColumnName;
    private SimpleValue index;
    public SimpleValue Index { get; public set; }
    public bool IsIndexed { get; }
    public bool IsList { get; }
    protected IndexedCollection(PersistentClass owner);
    public SimpleValue get_Index();
    public void set_Index(SimpleValue value);
    public virtual bool get_IsIndexed();
    public virtual bool get_IsList();
    public virtual void CreatePrimaryKey();
    public virtual void Validate(IMapping mapping);
}
public interface NHibernate.Mapping.IPersistentClassVisitor {
    public abstract virtual object Accept(PersistentClass clazz);
}
public interface NHibernate.Mapping.IPersistentClassVisitor`1 {
    public abstract virtual object Accept(T clazz);
}
public interface NHibernate.Mapping.IRelationalModel {
    public abstract virtual string SqlCreateString(Dialect dialect, IMapping p, string defaultCatalog, string defaultSchema);
    public abstract virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
}
public interface NHibernate.Mapping.ISelectable {
    public bool IsFormula { get; }
    public string Text { get; }
    public abstract virtual string GetAlias(Dialect dialect);
    public abstract virtual string GetAlias(Dialect dialect, Table table);
    public abstract virtual bool get_IsFormula();
    public abstract virtual string GetTemplate(Dialect dialect, SQLFunctionRegistry functionRegistry);
    public abstract virtual string GetText(Dialect dialect);
    public abstract virtual string get_Text();
}
public interface NHibernate.Mapping.ISqlCustomizable {
    public abstract virtual void SetCustomSQLInsert(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public abstract virtual void SetCustomSQLUpdate(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public abstract virtual void SetCustomSQLDelete(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
}
public interface NHibernate.Mapping.ITableOwner {
    unknown Table Table {public set; }
    public abstract virtual void set_Table(Table value);
}
public interface NHibernate.Mapping.IValue {
    public int ColumnSpan { get; }
    public IEnumerable`1<ISelectable> ColumnIterator { get; }
    public IType Type { get; }
    public Table Table { get; }
    public bool HasFormula { get; }
    public bool IsAlternateUniqueKey { get; }
    public bool IsNullable { get; }
    public Boolean[] ColumnUpdateability { get; }
    public Boolean[] ColumnInsertability { get; }
    public bool IsSimpleValue { get; }
    public FetchMode FetchMode { get; }
    public abstract virtual int get_ColumnSpan();
    public abstract virtual IEnumerable`1<ISelectable> get_ColumnIterator();
    public abstract virtual IType get_Type();
    public abstract virtual Table get_Table();
    public abstract virtual bool get_HasFormula();
    public abstract virtual bool get_IsAlternateUniqueKey();
    public abstract virtual bool get_IsNullable();
    public abstract virtual Boolean[] get_ColumnUpdateability();
    public abstract virtual Boolean[] get_ColumnInsertability();
    public abstract virtual bool get_IsSimpleValue();
    public abstract virtual void CreateForeignKey();
    public abstract virtual bool IsValid(IMapping mapping);
    public abstract virtual FetchMode get_FetchMode();
    public abstract virtual void SetTypeUsingReflection(string className, string propertyName, string accesorName);
    public abstract virtual object Accept(IValueVisitor visitor);
}
public interface NHibernate.Mapping.IValueVisitor {
    public abstract virtual object Accept(IValue visited);
}
public interface NHibernate.Mapping.IValueVisitor`1 {
    public abstract virtual object Accept(T visited);
}
public class NHibernate.Mapping.Join : object {
    private static Alias PK_ALIAS;
    private List`1<Property> properties;
    private Table table;
    private IKeyValue key;
    private PersistentClass persistentClass;
    private bool isSequentialSelect;
    private bool isInverse;
    private bool isOptional;
    private Nullable`1<bool> isLazy;
    private SqlString customSQLInsert;
    private bool customInsertCallable;
    private ExecuteUpdateResultCheckStyle insertCheckStyle;
    private SqlString customSQLUpdate;
    private bool customUpdateCallable;
    private ExecuteUpdateResultCheckStyle updateCheckStyle;
    private SqlString customSQLDelete;
    private bool customDeleteCallable;
    private ExecuteUpdateResultCheckStyle deleteCheckStyle;
    [CompilerGeneratedAttribute]
private Property <RefIdProperty>k__BackingField;
    public Property RefIdProperty { get; public set; }
    public IEnumerable`1<Property> PropertyIterator { get; }
    public Table Table { get; public set; }
    public IKeyValue Key { get; public set; }
    public PersistentClass PersistentClass { get; public set; }
    public int PropertySpan { get; }
    public SqlString CustomSQLInsert { get; }
    public SqlString CustomSQLDelete { get; }
    public SqlString CustomSQLUpdate { get; }
    public bool IsCustomInsertCallable { get; }
    public bool IsCustomDeleteCallable { get; }
    public bool IsCustomUpdateCallable { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLInsertCheckStyle { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLDeleteCheckStyle { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLUpdateCheckStyle { get; }
    public bool IsSequentialSelect { get; public set; }
    public bool IsInverse { get; public set; }
    public bool IsLazy { get; }
    public bool IsOptional { get; public set; }
    private static Join();
    public void AddProperty(Property prop);
    [CompilerGeneratedAttribute]
public Property get_RefIdProperty();
    [CompilerGeneratedAttribute]
public void set_RefIdProperty(Property value);
    public bool ContainsProperty(Property prop);
    public IEnumerable`1<Property> get_PropertyIterator();
    public virtual Table get_Table();
    public virtual void set_Table(Table value);
    public virtual IKeyValue get_Key();
    public virtual void set_Key(IKeyValue value);
    public virtual PersistentClass get_PersistentClass();
    public virtual void set_PersistentClass(PersistentClass value);
    public void CreateForeignKey();
    [ObsoleteAttribute("Please use overload without dialect parameter.")]
public void CreatePrimaryKey(Dialect dialect);
    public void CreatePrimaryKey();
    public int get_PropertySpan();
    public SqlString get_CustomSQLInsert();
    public SqlString get_CustomSQLDelete();
    public SqlString get_CustomSQLUpdate();
    public bool get_IsCustomInsertCallable();
    public bool get_IsCustomDeleteCallable();
    public bool get_IsCustomUpdateCallable();
    public ExecuteUpdateResultCheckStyle get_CustomSQLInsertCheckStyle();
    public ExecuteUpdateResultCheckStyle get_CustomSQLDeleteCheckStyle();
    public ExecuteUpdateResultCheckStyle get_CustomSQLUpdateCheckStyle();
    public sealed virtual void SetCustomSQLInsert(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public sealed virtual void SetCustomSQLDelete(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public sealed virtual void SetCustomSQLUpdate(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public virtual bool get_IsSequentialSelect();
    public virtual void set_IsSequentialSelect(bool value);
    public virtual bool get_IsInverse();
    public virtual void set_IsInverse(bool value);
    public bool get_IsLazy();
    public virtual bool get_IsOptional();
    public virtual void set_IsOptional(bool value);
}
public class NHibernate.Mapping.JoinedSubclass : Subclass {
    private Table table;
    private IKeyValue key;
    public Table Table { get; }
    unknown Table NHibernate.Mapping.ITableOwner.Table {private set; }
    public IKeyValue Key { get; public set; }
    public JoinedSubclass(PersistentClass superclass);
    public virtual Table get_Table();
    private sealed virtual override void NHibernate.Mapping.ITableOwner.set_Table(Table value);
    public virtual IKeyValue get_Key();
    public virtual void set_Key(IKeyValue value);
    public virtual void Validate(IMapping mapping);
}
public class NHibernate.Mapping.List : IndexedCollection {
    private int baseIndex;
    public CollectionType DefaultCollectionType { get; }
    public int BaseIndex { get; public set; }
    public bool IsList { get; }
    public List(PersistentClass owner);
    public virtual CollectionType get_DefaultCollectionType();
    public int get_BaseIndex();
    public void set_BaseIndex(int value);
    public virtual bool get_IsList();
}
public class NHibernate.Mapping.ManyToOne : ToOne {
    private bool isIgnoreNotFound;
    private bool isLogicalOneToOne;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    private IType type;
    public bool IsIgnoreNotFound { get; public set; }
    public bool IsLogicalOneToOne { get; public set; }
    public string PropertyName { get; public set; }
    public IType Type { get; }
    public ManyToOne(Table table);
    public virtual void CreateForeignKey();
    public bool get_IsIgnoreNotFound();
    public void set_IsIgnoreNotFound(bool value);
    public bool get_IsLogicalOneToOne();
    public void set_IsLogicalOneToOne(bool value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public virtual IType get_Type();
    public void CreatePropertyRefConstraints(IDictionary`2<string, PersistentClass> persistentClasses);
}
public class NHibernate.Mapping.Map : IndexedCollection {
    public bool IsMap { get; }
    public CollectionType CollectionType { get; }
    public CollectionType DefaultCollectionType { get; }
    public Map(PersistentClass owner);
    public virtual bool get_IsMap();
    public virtual CollectionType get_CollectionType();
    public virtual CollectionType get_DefaultCollectionType();
    public virtual void CreateAllKeys();
}
public class NHibernate.Mapping.MetaAttribute : object {
    private string name;
    private List`1<string> values;
    public string Name { get; }
    public IList`1<string> Values { get; }
    public string Value { get; }
    public bool IsMultiValued { get; }
    public MetaAttribute(string name);
    public string get_Name();
    public IList`1<string> get_Values();
    public string get_Value();
    public bool get_IsMultiValued();
    public void AddValue(string value);
    public void AddValues(IEnumerable`1<string> range);
    public virtual string ToString();
}
public class NHibernate.Mapping.OneToMany : object {
    private string referencedEntityName;
    private Table referencingTable;
    private PersistentClass associatedClass;
    private bool ignoreNotFound;
    private EntityType EntityType { get; }
    public bool IsIgnoreNotFound { get; public set; }
    public IEnumerable`1<ISelectable> ColumnIterator { get; }
    public int ColumnSpan { get; }
    public string ReferencedEntityName { get; public set; }
    public Table ReferencingTable { get; }
    public IType Type { get; }
    public PersistentClass AssociatedClass { get; public set; }
    public Formula Formula { get; }
    public Table Table { get; }
    public bool IsNullable { get; }
    public bool IsSimpleValue { get; }
    public bool HasFormula { get; }
    public bool IsUnique { get; }
    public FetchMode FetchMode { get; }
    public bool IsAlternateUniqueKey { get; }
    public Boolean[] ColumnInsertability { get; }
    public Boolean[] ColumnUpdateability { get; }
    public OneToMany(PersistentClass owner);
    private EntityType get_EntityType();
    public bool get_IsIgnoreNotFound();
    public void set_IsIgnoreNotFound(bool value);
    public sealed virtual IEnumerable`1<ISelectable> get_ColumnIterator();
    public sealed virtual int get_ColumnSpan();
    public string get_ReferencedEntityName();
    public void set_ReferencedEntityName(string value);
    public Table get_ReferencingTable();
    public sealed virtual IType get_Type();
    public PersistentClass get_AssociatedClass();
    public void set_AssociatedClass(PersistentClass value);
    public Formula get_Formula();
    public sealed virtual Table get_Table();
    public sealed virtual bool get_IsNullable();
    public sealed virtual bool get_IsSimpleValue();
    public sealed virtual bool get_HasFormula();
    public bool get_IsUnique();
    public sealed virtual bool IsValid(IMapping mapping);
    public sealed virtual FetchMode get_FetchMode();
    public sealed virtual bool get_IsAlternateUniqueKey();
    public sealed virtual void SetTypeUsingReflection(string className, string propertyName, string accesorName);
    public sealed virtual object Accept(IValueVisitor visitor);
    public sealed virtual void CreateForeignKey();
    public sealed virtual Boolean[] get_ColumnInsertability();
    public sealed virtual Boolean[] get_ColumnUpdateability();
}
public class NHibernate.Mapping.OneToOne : ToOne {
    private bool constrained;
    private ForeignKeyDirection foreignKeyType;
    private IKeyValue identifier;
    private string propertyName;
    private string entityName;
    public IEnumerable`1<Column> ConstraintColumns { get; }
    public bool IsConstrained { get; public set; }
    public ForeignKeyDirection ForeignKeyType { get; public set; }
    public IKeyValue Identifier { get; public set; }
    public bool IsNullable { get; }
    public string EntityName { get; public set; }
    public string PropertyName { get; public set; }
    public IType Type { get; }
    public OneToOne(Table table, PersistentClass owner);
    public virtual void CreateForeignKey();
    public virtual IEnumerable`1<Column> get_ConstraintColumns();
    public bool get_IsConstrained();
    public void set_IsConstrained(bool value);
    public ForeignKeyDirection get_ForeignKeyType();
    public void set_ForeignKeyType(ForeignKeyDirection value);
    public IKeyValue get_Identifier();
    public void set_Identifier(IKeyValue value);
    public virtual bool get_IsNullable();
    public string get_EntityName();
    public void set_EntityName(string value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public virtual IType get_Type();
}
public abstract class NHibernate.Mapping.PersistentClass : object {
    private static Alias PKAlias;
    public static string NullDiscriminatorMapping;
    public static string NotNullDiscriminatorMapping;
    private string entityName;
    private string className;
    private string proxyInterfaceName;
    private string discriminatorValue;
    private bool lazy;
    private List`1<Property> properties;
    private List`1<Subclass> subclasses;
    private List`1<Property> subclassProperties;
    private List`1<Table> subclassTables;
    private bool dynamicInsert;
    private bool dynamicUpdate;
    private Nullable`1<int> batchSize;
    private bool selectBeforeUpdate;
    private IDictionary`2<string, MetaAttribute> metaAttributes;
    private List`1<Join> joins;
    private List`1<Join> subclassJoins;
    private Dictionary`2<string, string> filters;
    private HashSet`1<string> synchronizedTables;
    private string loaderName;
    private Nullable`1<bool> isAbstract;
    private bool hasSubselectLoadableCollections;
    private Component identifierMapper;
    private SqlString customSQLInsert;
    private bool customInsertCallable;
    private ExecuteUpdateResultCheckStyle insertCheckStyle;
    private SqlString customSQLUpdate;
    private bool customUpdateCallable;
    private ExecuteUpdateResultCheckStyle updateCheckStyle;
    private SqlString customSQLDelete;
    private bool customDeleteCallable;
    private ExecuteUpdateResultCheckStyle deleteCheckStyle;
    private string temporaryIdTableName;
    private string temporaryIdTableDDL;
    private IDictionary`2<EntityMode, string> tuplizerImpls;
    private OptimisticLock optimisticLockMode;
    private Type mappedClass;
    private Type proxyInterface;
    public string ClassName { get; public set; }
    public string ProxyInterfaceName { get; public set; }
    public Type MappedClass { get; }
    public Type ProxyInterface { get; }
    public int SubclassId { get; }
    public bool DynamicInsert { get; public set; }
    public bool DynamicUpdate { get; public set; }
    public string DiscriminatorValue { get; public set; }
    public int SubclassSpan { get; }
    public IEnumerable`1<Subclass> SubclassIterator { get; }
    public IEnumerable`1<PersistentClass> SubclassClosureIterator { get; }
    public Table IdentityTable { get; }
    public IEnumerable`1<Subclass> DirectSubclasses { get; }
    public string EntityName { get; public set; }
    public bool IsInherited { get; }
    public bool IsVersioned { get; }
    public IEnumerable`1<Property> PropertyClosureIterator { get; }
    public IEnumerable`1<Table> TableClosureIterator { get; }
    public IEnumerable`1<IKeyValue> KeyClosureIterator { get; }
    public IEnumerable`1<Property> SubclassPropertyClosureIterator { get; }
    public IEnumerable`1<Join> SubclassJoinClosureIterator { get; }
    public IEnumerable`1<Table> SubclassTableClosureIterator { get; }
    public bool IsLazy { get; public set; }
    public Type EntityPersisterClass { get; public set; }
    public Table RootTable { get; }
    public Nullable`1<int> BatchSize { get; public set; }
    public bool SelectBeforeUpdate { get; public set; }
    public IEnumerable`1<Property> ReferenceablePropertyIterator { get; }
    public bool IsDiscriminatorValueNotNull { get; }
    public bool IsDiscriminatorValueNull { get; }
    public IDictionary`2<string, MetaAttribute> MetaAttributes { get; public set; }
    public IEnumerable`1<Join> JoinIterator { get; }
    public IEnumerable`1<Join> JoinClosureIterator { get; }
    public int JoinClosureSpan { get; }
    public int PropertyClosureSpan { get; }
    public IEnumerable`1<Property> PropertyIterator { get; }
    public IEnumerable`1<Property> UnjoinedPropertyIterator { get; }
    public bool IsCustomInsertCallable { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLInsertCheckStyle { get; }
    public bool IsCustomUpdateCallable { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLUpdateCheckStyle { get; }
    public bool IsCustomDeleteCallable { get; }
    public ExecuteUpdateResultCheckStyle CustomSQLDeleteCheckStyle { get; }
    public IDictionary`2<string, string> FilterMap { get; }
    public bool IsJoinedSubclass { get; }
    public string LoaderName { get; public set; }
    public ISet`1<string> SynchronizedTables { get; }
    protected internal IEnumerable`1<Property> NonDuplicatedPropertyIterator { get; }
    protected internal IEnumerable`1<ISelectable> DiscriminatorColumnIterator { get; }
    public bool HasSubselectLoadableCollections { get; public set; }
    public string TemporaryIdTableName { get; }
    public string TemporaryIdTableDDL { get; }
    public IDictionary`2<EntityMode, string> TuplizerMap { get; }
    public bool HasSubclasses { get; }
    public Table Table { get; }
    public bool IsMutable { get; public set; }
    public bool HasIdentifierProperty { get; }
    public Property IdentifierProperty { get; public set; }
    public IKeyValue Identifier { get; public set; }
    public Property Version { get; public set; }
    public IValue Discriminator { get; public set; }
    public bool IsPolymorphic { get; public set; }
    public string CacheConcurrencyStrategy { get; public set; }
    public PersistentClass Superclass { get; public set; }
    public bool IsExplicitPolymorphism { get; public set; }
    public bool IsDiscriminatorInsertable { get; public set; }
    public bool HasEmbeddedIdentifier { get; public set; }
    public RootClass RootClazz { get; }
    public IKeyValue Key { get; public set; }
    public string Where { get; public set; }
    public OptimisticLock OptimisticLockMode { get; public set; }
    public SqlString CustomSQLInsert { get; }
    public SqlString CustomSQLUpdate { get; }
    public SqlString CustomSQLDelete { get; }
    public bool IsForceDiscriminator { get; public set; }
    public Nullable`1<bool> IsAbstract { get; public set; }
    public bool HasPocoRepresentation { get; }
    public Component IdentifierMapper { get; public set; }
    public bool HasIdentifierMapper { get; }
    public bool IsLazyPropertiesCacheable { get; }
    private static PersistentClass();
    public string get_ClassName();
    public void set_ClassName(string value);
    public string get_ProxyInterfaceName();
    public void set_ProxyInterfaceName(string value);
    public virtual Type get_MappedClass();
    public virtual Type get_ProxyInterface();
    public abstract virtual int get_SubclassId();
    public virtual bool get_DynamicInsert();
    public virtual void set_DynamicInsert(bool value);
    public virtual bool get_DynamicUpdate();
    public virtual void set_DynamicUpdate(bool value);
    public virtual string get_DiscriminatorValue();
    public virtual void set_DiscriminatorValue(string value);
    public virtual int get_SubclassSpan();
    public virtual IEnumerable`1<Subclass> get_SubclassIterator();
    public virtual IEnumerable`1<PersistentClass> get_SubclassClosureIterator();
    public virtual Table get_IdentityTable();
    public virtual IEnumerable`1<Subclass> get_DirectSubclasses();
    public virtual string get_EntityName();
    public virtual void set_EntityName(string value);
    public abstract virtual bool get_IsInherited();
    public abstract virtual bool get_IsVersioned();
    public abstract virtual IEnumerable`1<Property> get_PropertyClosureIterator();
    public abstract virtual IEnumerable`1<Table> get_TableClosureIterator();
    public abstract virtual IEnumerable`1<IKeyValue> get_KeyClosureIterator();
    public virtual IEnumerable`1<Property> get_SubclassPropertyClosureIterator();
    public virtual IEnumerable`1<Join> get_SubclassJoinClosureIterator();
    public virtual IEnumerable`1<Table> get_SubclassTableClosureIterator();
    public bool get_IsLazy();
    public void set_IsLazy(bool value);
    public abstract virtual Type get_EntityPersisterClass();
    public abstract virtual void set_EntityPersisterClass(Type value);
    public abstract virtual Table get_RootTable();
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public bool get_SelectBeforeUpdate();
    public void set_SelectBeforeUpdate(bool value);
    public virtual IEnumerable`1<Property> get_ReferenceablePropertyIterator();
    public bool get_IsDiscriminatorValueNotNull();
    public bool get_IsDiscriminatorValueNull();
    public sealed virtual IDictionary`2<string, MetaAttribute> get_MetaAttributes();
    public sealed virtual void set_MetaAttributes(IDictionary`2<string, MetaAttribute> value);
    public virtual IEnumerable`1<Join> get_JoinIterator();
    public virtual IEnumerable`1<Join> get_JoinClosureIterator();
    public virtual int get_JoinClosureSpan();
    public virtual int get_PropertyClosureSpan();
    public virtual IEnumerable`1<Property> get_PropertyIterator();
    public virtual IEnumerable`1<Property> get_UnjoinedPropertyIterator();
    public bool get_IsCustomInsertCallable();
    public ExecuteUpdateResultCheckStyle get_CustomSQLInsertCheckStyle();
    public bool get_IsCustomUpdateCallable();
    public ExecuteUpdateResultCheckStyle get_CustomSQLUpdateCheckStyle();
    public bool get_IsCustomDeleteCallable();
    public ExecuteUpdateResultCheckStyle get_CustomSQLDeleteCheckStyle();
    public virtual IDictionary`2<string, string> get_FilterMap();
    public abstract virtual bool get_IsJoinedSubclass();
    public string get_LoaderName();
    public void set_LoaderName(string value);
    public virtual ISet`1<string> get_SynchronizedTables();
    protected internal virtual IEnumerable`1<Property> get_NonDuplicatedPropertyIterator();
    protected internal virtual IEnumerable`1<ISelectable> get_DiscriminatorColumnIterator();
    public virtual bool get_HasSubselectLoadableCollections();
    public virtual void set_HasSubselectLoadableCollections(bool value);
    public string get_TemporaryIdTableName();
    public string get_TemporaryIdTableDDL();
    public virtual IDictionary`2<EntityMode, string> get_TuplizerMap();
    internal abstract virtual int NextSubclassId();
    public virtual void AddSubclass(Subclass subclass);
    public virtual bool get_HasSubclasses();
    public virtual void AddProperty(Property p);
    public abstract virtual Table get_Table();
    public abstract virtual bool get_IsMutable();
    public abstract virtual void set_IsMutable(bool value);
    public abstract virtual bool get_HasIdentifierProperty();
    public abstract virtual Property get_IdentifierProperty();
    public abstract virtual void set_IdentifierProperty(Property value);
    public abstract virtual IKeyValue get_Identifier();
    public abstract virtual void set_Identifier(IKeyValue value);
    public abstract virtual Property get_Version();
    public abstract virtual void set_Version(Property value);
    public abstract virtual IValue get_Discriminator();
    public abstract virtual void set_Discriminator(IValue value);
    public abstract virtual bool get_IsPolymorphic();
    public abstract virtual void set_IsPolymorphic(bool value);
    public abstract virtual string get_CacheConcurrencyStrategy();
    public abstract virtual void set_CacheConcurrencyStrategy(string value);
    public abstract virtual PersistentClass get_Superclass();
    public abstract virtual void set_Superclass(PersistentClass value);
    public abstract virtual bool get_IsExplicitPolymorphism();
    public abstract virtual void set_IsExplicitPolymorphism(bool value);
    public abstract virtual bool get_IsDiscriminatorInsertable();
    public abstract virtual void set_IsDiscriminatorInsertable(bool value);
    public virtual void AddSubclassProperty(Property p);
    public virtual void AddSubclassJoin(Join join);
    public virtual void AddSubclassTable(Table table);
    public virtual bool IsClassOrSuperclassJoin(Join join);
    public virtual bool IsClassOrSuperclassTable(Table closureTable);
    public abstract virtual bool get_HasEmbeddedIdentifier();
    public abstract virtual void set_HasEmbeddedIdentifier(bool value);
    public abstract virtual RootClass get_RootClazz();
    public abstract virtual IKeyValue get_Key();
    public abstract virtual void set_Key(IKeyValue value);
    [ObsoleteAttribute("Please use overload without delegate parameter")]
public virtual void CreatePrimaryKey(Dialect dialect);
    public virtual void CreatePrimaryKey();
    public abstract virtual string get_Where();
    public abstract virtual void set_Where(string value);
    public Property GetReferencedProperty(string propertyPath);
    public Property GetRecursiveProperty(string propertyPath);
    private Property GetRecursiveProperty(string propertyPath, IEnumerable`1<Property> iter);
    private Property GetProperty(string propertyName, IEnumerable`1<Property> iter);
    public Property GetProperty(string propertyName);
    public virtual OptimisticLock get_OptimisticLockMode();
    public virtual void set_OptimisticLockMode(OptimisticLock value);
    public virtual void Validate(IMapping mapping);
    private void CheckPropertyDuplication();
    public sealed virtual MetaAttribute GetMetaAttribute(string attributeName);
    public virtual string ToString();
    public virtual void AddJoin(Join join);
    public virtual int GetJoinNumber(Property prop);
    public sealed virtual void SetCustomSQLInsert(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public SqlString get_CustomSQLInsert();
    public sealed virtual void SetCustomSQLUpdate(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public SqlString get_CustomSQLUpdate();
    public sealed virtual void SetCustomSQLDelete(string sql, bool callable, ExecuteUpdateResultCheckStyle checkStyle);
    public SqlString get_CustomSQLDelete();
    public sealed virtual void AddFilter(string name, string condition);
    public virtual bool get_IsForceDiscriminator();
    public virtual void set_IsForceDiscriminator(bool value);
    public void AddSynchronizedTable(string table);
    public Nullable`1<bool> get_IsAbstract();
    public void set_IsAbstract(Nullable`1<bool> value);
    protected internal void CheckColumnDuplication(ISet`1<string> distinctColumns, IEnumerable`1<ISelectable> columns);
    protected internal void CheckPropertyColumnDuplication(ISet`1<string> distinctColumns, IEnumerable`1<Property> properties);
    protected internal virtual void CheckColumnDuplication();
    public abstract virtual object Accept(IPersistentClassVisitor mv);
    public bool get_HasPocoRepresentation();
    public void PrepareTemporaryTables(IMapping mapping, Dialect dialect);
    public virtual Component get_IdentifierMapper();
    public virtual void set_IdentifierMapper(Component value);
    public bool get_HasIdentifierMapper();
    public void AddTuplizer(EntityMode entityMode, string implClass);
    public virtual string GetTuplizerImplClassName(EntityMode mode);
    public bool HasNaturalId();
    public abstract virtual bool get_IsLazyPropertiesCacheable();
}
public class NHibernate.Mapping.PrimaryKey : Constraint {
    public string SqlConstraintString(Dialect d, string defaultSchema);
    public virtual string SqlConstraintString(Dialect d, string constraintName, string defaultCatalog, string defaultSchema);
    public virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
}
public class NHibernate.Mapping.PrimitiveArray : Array {
    public bool IsPrimitiveArray { get; }
    public PrimitiveArray(PersistentClass owner);
    public virtual bool get_IsPrimitiveArray();
}
public class NHibernate.Mapping.Property : object {
    private string name;
    private IValue propertyValue;
    private string cascade;
    private bool updateable;
    private bool insertable;
    private bool selectable;
    private string propertyAccessorName;
    private bool optional;
    private IDictionary`2<string, MetaAttribute> metaAttributes;
    private PersistentClass persistentClass;
    private bool isOptimisticLocked;
    private PropertyGeneration generation;
    private bool isLazy;
    private bool isNaturalIdentifier;
    [CompilerGeneratedAttribute]
private string <LazyGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnwrapProxy>k__BackingField;
    public IType Type { get; }
    public int ColumnSpan { get; }
    public IEnumerable`1<ISelectable> ColumnIterator { get; }
    public string Name { get; public set; }
    public bool IsComposite { get; }
    public IValue Value { get; public set; }
    public CascadeStyle CascadeStyle { get; }
    public string Cascade { get; public set; }
    public bool IsUpdateable { get; public set; }
    public bool IsInsertable { get; public set; }
    public bool IsNullable { get; }
    public bool IsOptional { get; public set; }
    public string PropertyAccessorName { get; public set; }
    protected IPropertyAccessor PropertyAccessor { get; }
    public bool IsBasicPropertyAccessor { get; }
    public IDictionary`2<string, MetaAttribute> MetaAttributes { get; public set; }
    public string NullValue { get; }
    public PersistentClass PersistentClass { get; public set; }
    public bool IsSelectable { get; public set; }
    public bool IsOptimisticLocked { get; public set; }
    public PropertyGeneration Generation { get; public set; }
    public bool IsLazy { get; public set; }
    public string LazyGroup { get; public set; }
    public bool BackRef { get; }
    public bool IsNaturalIdentifier { get; public set; }
    public bool UnwrapProxy { get; public set; }
    public bool IsEntityRelation { get; }
    public Property(IValue propertyValue);
    public IType get_Type();
    public int get_ColumnSpan();
    public IEnumerable`1<ISelectable> get_ColumnIterator();
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsComposite();
    public IValue get_Value();
    public void set_Value(IValue value);
    public CascadeStyle get_CascadeStyle();
    public string get_Cascade();
    public void set_Cascade(string value);
    public bool get_IsUpdateable();
    public void set_IsUpdateable(bool value);
    public bool get_IsInsertable();
    public void set_IsInsertable(bool value);
    public bool get_IsNullable();
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public string get_PropertyAccessorName();
    public void set_PropertyAccessorName(string value);
    public IGetter GetGetter(Type clazz);
    public ISetter GetSetter(Type clazz);
    protected virtual IPropertyAccessor get_PropertyAccessor();
    public virtual bool get_IsBasicPropertyAccessor();
    public sealed virtual IDictionary`2<string, MetaAttribute> get_MetaAttributes();
    public sealed virtual void set_MetaAttributes(IDictionary`2<string, MetaAttribute> value);
    public sealed virtual MetaAttribute GetMetaAttribute(string attributeName);
    public bool IsValid(IMapping mapping);
    public string get_NullValue();
    public PersistentClass get_PersistentClass();
    public void set_PersistentClass(PersistentClass value);
    public bool get_IsSelectable();
    public void set_IsSelectable(bool value);
    public bool get_IsOptimisticLocked();
    public void set_IsOptimisticLocked(bool value);
    public PropertyGeneration get_Generation();
    public void set_Generation(PropertyGeneration value);
    public bool get_IsLazy();
    public void set_IsLazy(bool value);
    [CompilerGeneratedAttribute]
public string get_LazyGroup();
    [CompilerGeneratedAttribute]
public void set_LazyGroup(string value);
    public virtual bool get_BackRef();
    public bool get_IsNaturalIdentifier();
    public void set_IsNaturalIdentifier(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnwrapProxy();
    [CompilerGeneratedAttribute]
public void set_UnwrapProxy(bool value);
    public bool get_IsEntityRelation();
}
public enum NHibernate.Mapping.PropertyGeneration : Enum {
    public int value__;
    public static PropertyGeneration Never;
    public static PropertyGeneration Insert;
    public static PropertyGeneration Always;
}
public class NHibernate.Mapping.ReferenceDependantValue : DependantValue {
    private SimpleValue _prototype;
    public IEnumerable`1<Column> ReferenceColumns { get; }
    public ReferenceDependantValue(Table table, SimpleValue prototype);
    public IEnumerable`1<Column> get_ReferenceColumns();
    public virtual void CreateForeignKeyOfEntity(string entityName);
}
public class NHibernate.Mapping.RootClass : PersistentClass {
    private static INHibernateLogger log;
    public static string DefaultIdentifierColumnName;
    public static string DefaultDiscriminatorColumnName;
    private Property identifierProperty;
    private IKeyValue identifier;
    private Property version;
    private bool polymorphic;
    private string cacheConcurrencyStrategy;
    private string cacheRegionName;
    private bool lazyPropertiesCacheable;
    private IValue discriminator;
    private bool mutable;
    private bool embeddedIdentifier;
    private bool explicitPolymorphism;
    private Type entityPersisterClass;
    private bool forceDiscriminator;
    private string where;
    private Table table;
    private bool discriminatorInsertable;
    private int nextSubclassId;
    public int SubclassId { get; }
    public bool IsInherited { get; }
    public IEnumerable`1<Property> PropertyClosureIterator { get; }
    public IEnumerable`1<Table> TableClosureIterator { get; }
    public IEnumerable`1<IKeyValue> KeyClosureIterator { get; }
    public bool IsVersioned { get; }
    public Type EntityPersisterClass { get; public set; }
    public Table RootTable { get; }
    public bool HasEmbeddedIdentifier { get; public set; }
    public string CacheRegionName { get; public set; }
    public bool IsJoinedSubclass { get; }
    public ISet`1<Table> IdentityTables { get; }
    public Table Table { get; }
    unknown Table NHibernate.Mapping.ITableOwner.Table {private set; }
    public Property IdentifierProperty { get; public set; }
    public IKeyValue Identifier { get; public set; }
    public bool HasIdentifierProperty { get; }
    public IValue Discriminator { get; public set; }
    public bool IsPolymorphic { get; public set; }
    public RootClass RootClazz { get; }
    public bool IsExplicitPolymorphism { get; public set; }
    public Property Version { get; public set; }
    public bool IsMutable { get; public set; }
    public PersistentClass Superclass { get; public set; }
    public IKeyValue Key { get; public set; }
    public bool IsDiscriminatorInsertable { get; public set; }
    public bool IsForceDiscriminator { get; public set; }
    public string Where { get; public set; }
    public string CacheConcurrencyStrategy { get; public set; }
    public bool IsLazyPropertiesCacheable { get; }
    private static RootClass();
    public virtual int get_SubclassId();
    public virtual bool get_IsInherited();
    public virtual IEnumerable`1<Property> get_PropertyClosureIterator();
    public virtual IEnumerable`1<Table> get_TableClosureIterator();
    public virtual IEnumerable`1<IKeyValue> get_KeyClosureIterator();
    public virtual bool get_IsVersioned();
    public virtual Type get_EntityPersisterClass();
    public virtual void set_EntityPersisterClass(Type value);
    public virtual Table get_RootTable();
    public virtual bool get_HasEmbeddedIdentifier();
    public virtual void set_HasEmbeddedIdentifier(bool value);
    public string get_CacheRegionName();
    public void set_CacheRegionName(string value);
    public virtual bool get_IsJoinedSubclass();
    public virtual ISet`1<Table> get_IdentityTables();
    internal virtual int NextSubclassId();
    public virtual Table get_Table();
    private sealed virtual override void NHibernate.Mapping.ITableOwner.set_Table(Table value);
    public virtual Property get_IdentifierProperty();
    public virtual void set_IdentifierProperty(Property value);
    public virtual IKeyValue get_Identifier();
    public virtual void set_Identifier(IKeyValue value);
    public virtual bool get_HasIdentifierProperty();
    public virtual IValue get_Discriminator();
    public virtual void set_Discriminator(IValue value);
    public virtual bool get_IsPolymorphic();
    public virtual void set_IsPolymorphic(bool value);
    public virtual RootClass get_RootClazz();
    public virtual void AddSubclass(Subclass subclass);
    public virtual bool get_IsExplicitPolymorphism();
    public virtual void set_IsExplicitPolymorphism(bool value);
    public virtual Property get_Version();
    public virtual void set_Version(Property value);
    public virtual bool get_IsMutable();
    public virtual void set_IsMutable(bool value);
    public virtual PersistentClass get_Superclass();
    public virtual void set_Superclass(PersistentClass value);
    public virtual IKeyValue get_Key();
    public virtual void set_Key(IKeyValue value);
    public virtual bool get_IsDiscriminatorInsertable();
    public virtual void set_IsDiscriminatorInsertable(bool value);
    public virtual bool get_IsForceDiscriminator();
    public virtual void set_IsForceDiscriminator(bool value);
    public virtual string get_Where();
    public virtual void set_Where(string value);
    public virtual void Validate(IMapping mapping);
    private void CheckCompositeIdentifier();
    public virtual string get_CacheConcurrencyStrategy();
    public virtual void set_CacheConcurrencyStrategy(string value);
    public virtual bool get_IsLazyPropertiesCacheable();
    public void SetLazyPropertiesCacheable(bool isLazyPropertiesCacheable);
    public virtual object Accept(IPersistentClassVisitor mv);
}
[FlagsAttribute]
public enum NHibernate.Mapping.SchemaAction : Enum {
    public int value__;
    public static SchemaAction None;
    public static SchemaAction Drop;
    public static SchemaAction Update;
    public static SchemaAction Export;
    public static SchemaAction Validate;
    public static SchemaAction All;
}
public class NHibernate.Mapping.Set : Collection {
    public bool IsSet { get; }
    public CollectionType DefaultCollectionType { get; }
    public Set(PersistentClass owner);
    public virtual bool get_IsSet();
    public virtual CollectionType get_DefaultCollectionType();
    public virtual void CreatePrimaryKey();
}
public class NHibernate.Mapping.SimpleAuxiliaryDatabaseObject : AbstractAuxiliaryDatabaseObject {
    private string sqlCreateString;
    private string sqlDropString;
    public SimpleAuxiliaryDatabaseObject(string sqlCreateString, string sqlDropString);
    public SimpleAuxiliaryDatabaseObject(string sqlCreateString, string sqlDropString, HashSet`1<string> dialectScopes);
    public virtual string SqlCreateString(Dialect dialect, IMapping p, string defaultCatalog, string defaultSchema);
    public virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
    private static string InjectCatalogAndSchema(string ddlString, string defaultCatalog, string defaultSchema);
}
public class NHibernate.Mapping.SimpleValue : object {
    private List`1<ISelectable> columns;
    private IType type;
    private IDictionary`2<string, string> typeParameters;
    private IDictionary`2<string, string> identifierGeneratorProperties;
    private string identifierGeneratorStrategy;
    private string nullValue;
    private Table table;
    private string foreignKeyName;
    private bool cascadeDeleteEnabled;
    private bool isAlternateUniqueKey;
    private string typeName;
    public IEnumerable`1<Column> ConstraintColumns { get; }
    public string ForeignKeyName { get; public set; }
    public Table Table { get; public set; }
    public IDictionary`2<string, string> IdentifierGeneratorProperties { get; public set; }
    public string IdentifierGeneratorStrategy { get; public set; }
    public bool IsComposite { get; }
    public bool IsCascadeDeleteEnabled { get; public set; }
    public string NullValue { get; public set; }
    public bool IsUpdateable { get; }
    public bool IsTypeSpecified { get; }
    public IDictionary`2<string, string> TypeParameters { get; public set; }
    public string TypeName { get; public set; }
    public int ColumnSpan { get; }
    public IEnumerable`1<ISelectable> ColumnIterator { get; }
    public IType Type { get; }
    public bool HasFormula { get; }
    public bool IsNullable { get; }
    public Boolean[] ColumnUpdateability { get; }
    public Boolean[] ColumnInsertability { get; }
    public bool IsSimpleValue { get; }
    public FetchMode FetchMode { get; public set; }
    public bool IsAlternateUniqueKey { get; public set; }
    public SimpleValue(Table table);
    public virtual IEnumerable`1<Column> get_ConstraintColumns();
    public string get_ForeignKeyName();
    public void set_ForeignKeyName(string value);
    public sealed virtual Table get_Table();
    public void set_Table(Table value);
    public IDictionary`2<string, string> get_IdentifierGeneratorProperties();
    public void set_IdentifierGeneratorProperties(IDictionary`2<string, string> value);
    public string get_IdentifierGeneratorStrategy();
    public void set_IdentifierGeneratorStrategy(string value);
    public virtual bool get_IsComposite();
    public virtual void CreateForeignKeyOfEntity(string entityName);
    public sealed virtual bool get_IsCascadeDeleteEnabled();
    public void set_IsCascadeDeleteEnabled(bool value);
    public sealed virtual bool IsIdentityColumn(Dialect dialect);
    public sealed virtual string get_NullValue();
    public void set_NullValue(string value);
    public virtual bool get_IsUpdateable();
    public virtual bool get_IsTypeSpecified();
    public IDictionary`2<string, string> get_TypeParameters();
    public void set_TypeParameters(IDictionary`2<string, string> value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public sealed virtual IIdentifierGenerator CreateIdentifierGenerator(Dialect dialect, string defaultCatalog, string defaultSchema, RootClass rootClass);
    public virtual int get_ColumnSpan();
    public virtual IEnumerable`1<ISelectable> get_ColumnIterator();
    public virtual IType get_Type();
    private IType GetHeuristicType();
    public sealed virtual bool get_HasFormula();
    public virtual bool get_IsNullable();
    public virtual Boolean[] get_ColumnUpdateability();
    public virtual Boolean[] get_ColumnInsertability();
    public sealed virtual bool get_IsSimpleValue();
    public virtual bool IsValid(IMapping mapping);
    public virtual void CreateForeignKey();
    public virtual FetchMode get_FetchMode();
    public virtual void set_FetchMode(FetchMode value);
    public sealed virtual bool get_IsAlternateUniqueKey();
    public void set_IsAlternateUniqueKey(bool value);
    public virtual void SetTypeUsingReflection(string className, string propertyName, string accesorName);
    public virtual object Accept(IValueVisitor visitor);
    public virtual void AddColumn(Column column);
    public virtual void AddFormula(Formula formula);
    public virtual string ToString();
}
public class NHibernate.Mapping.SingleTableSubclass : Subclass {
    protected internal IEnumerable`1<Property> NonDuplicatedPropertyIterator { get; }
    protected internal IEnumerable`1<ISelectable> DiscriminatorColumnIterator { get; }
    public SingleTableSubclass(PersistentClass superclass);
    protected internal virtual IEnumerable`1<Property> get_NonDuplicatedPropertyIterator();
    protected internal virtual IEnumerable`1<ISelectable> get_DiscriminatorColumnIterator();
    public virtual void Validate(IMapping mapping);
}
public class NHibernate.Mapping.Subclass : PersistentClass {
    private PersistentClass superclass;
    private Type classPersisterClass;
    private int subclassId;
    public int SubclassId { get; }
    public bool IsInherited { get; }
    public IEnumerable`1<Property> PropertyClosureIterator { get; }
    public IEnumerable`1<Table> TableClosureIterator { get; }
    public IEnumerable`1<IKeyValue> KeyClosureIterator { get; }
    public bool IsVersioned { get; }
    public Type EntityPersisterClass { get; public set; }
    public Table RootTable { get; }
    public bool IsJoinedSubclass { get; }
    public int JoinClosureSpan { get; }
    public int PropertyClosureSpan { get; }
    public IEnumerable`1<Join> JoinClosureIterator { get; }
    public ISet`1<string> SynchronizedTables { get; }
    public IDictionary`2<string, string> FilterMap { get; }
    public IDictionary`2<EntityMode, string> TuplizerMap { get; }
    public string CacheConcurrencyStrategy { get; public set; }
    public RootClass RootClazz { get; }
    public PersistentClass Superclass { get; public set; }
    public Property IdentifierProperty { get; public set; }
    public IKeyValue Identifier { get; public set; }
    public bool HasIdentifierProperty { get; }
    public IValue Discriminator { get; public set; }
    public bool IsMutable { get; public set; }
    public bool IsPolymorphic { get; public set; }
    public Property Version { get; public set; }
    public bool HasEmbeddedIdentifier { get; public set; }
    public IKeyValue Key { get; public set; }
    public bool IsExplicitPolymorphism { get; public set; }
    public string Where { get; public set; }
    public bool IsLazyPropertiesCacheable { get; }
    public Table Table { get; }
    public bool IsForceDiscriminator { get; }
    public bool IsDiscriminatorInsertable { get; public set; }
    public bool HasSubselectLoadableCollections { get; public set; }
    public Component IdentifierMapper { get; }
    public OptimisticLock OptimisticLockMode { get; }
    public Subclass(PersistentClass superclass);
    public virtual int get_SubclassId();
    public virtual bool get_IsInherited();
    public virtual IEnumerable`1<Property> get_PropertyClosureIterator();
    public virtual IEnumerable`1<Table> get_TableClosureIterator();
    public virtual IEnumerable`1<IKeyValue> get_KeyClosureIterator();
    public virtual bool get_IsVersioned();
    public virtual Type get_EntityPersisterClass();
    public virtual void set_EntityPersisterClass(Type value);
    public virtual Table get_RootTable();
    public virtual bool get_IsJoinedSubclass();
    public virtual int get_JoinClosureSpan();
    public virtual int get_PropertyClosureSpan();
    public virtual IEnumerable`1<Join> get_JoinClosureIterator();
    public virtual ISet`1<string> get_SynchronizedTables();
    public virtual IDictionary`2<string, string> get_FilterMap();
    public virtual IDictionary`2<EntityMode, string> get_TuplizerMap();
    internal virtual int NextSubclassId();
    public virtual string get_CacheConcurrencyStrategy();
    public virtual void set_CacheConcurrencyStrategy(string value);
    public virtual RootClass get_RootClazz();
    public virtual PersistentClass get_Superclass();
    public virtual void set_Superclass(PersistentClass value);
    public virtual Property get_IdentifierProperty();
    public virtual void set_IdentifierProperty(Property value);
    public virtual IKeyValue get_Identifier();
    public virtual void set_Identifier(IKeyValue value);
    public virtual bool get_HasIdentifierProperty();
    public virtual IValue get_Discriminator();
    public virtual void set_Discriminator(IValue value);
    public virtual bool get_IsMutable();
    public virtual void set_IsMutable(bool value);
    public virtual bool get_IsPolymorphic();
    public virtual void set_IsPolymorphic(bool value);
    public virtual void AddProperty(Property p);
    public virtual void AddJoin(Join join);
    public virtual void AddSubclassProperty(Property p);
    public virtual void AddSubclassJoin(Join join);
    public virtual void AddSubclassTable(Table table);
    public virtual Property get_Version();
    public virtual void set_Version(Property value);
    public virtual bool get_HasEmbeddedIdentifier();
    public virtual void set_HasEmbeddedIdentifier(bool value);
    public virtual IKeyValue get_Key();
    public virtual void set_Key(IKeyValue value);
    public virtual bool get_IsExplicitPolymorphism();
    public virtual void set_IsExplicitPolymorphism(bool value);
    public virtual string get_Where();
    public virtual void set_Where(string value);
    public void CreateForeignKey();
    public virtual bool get_IsLazyPropertiesCacheable();
    public virtual bool IsClassOrSuperclassJoin(Join join);
    public virtual bool IsClassOrSuperclassTable(Table closureTable);
    public virtual Table get_Table();
    public virtual bool get_IsForceDiscriminator();
    public virtual bool get_IsDiscriminatorInsertable();
    public virtual void set_IsDiscriminatorInsertable(bool value);
    public virtual object Accept(IPersistentClassVisitor mv);
    public virtual bool get_HasSubselectLoadableCollections();
    public virtual void set_HasSubselectLoadableCollections(bool value);
    public virtual string GetTuplizerImplClassName(EntityMode mode);
    public virtual Component get_IdentifierMapper();
    public virtual OptimisticLock get_OptimisticLockMode();
}
public class NHibernate.Mapping.Table : object {
    private List`1<string> checkConstraints;
    private LinkedHashMap`2<string, Column> columns;
    private Dictionary`2<ForeignKeyKey, ForeignKey> foreignKeys;
    private Dictionary`2<string, Index> indexes;
    private Nullable`1<int> uniqueInteger;
    private Dictionary`2<string, UniqueKey> uniqueKeys;
    private string catalog;
    private string comment;
    private bool hasDenormalizedTables;
    private IKeyValue idValue;
    private bool isAbstract;
    private bool isSchemaQuoted;
    private bool isCatalogQuoted;
    private string name;
    private bool quoted;
    private string schema;
    private SchemaAction schemaActions;
    private string subselect;
    [CompilerGeneratedAttribute]
private PrimaryKey <PrimaryKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RowId>k__BackingField;
    public string Name { get; public set; }
    public int ColumnSpan { get; }
    public IEnumerable`1<Column> ColumnIterator { get; }
    public IEnumerable`1<Index> IndexIterator { get; }
    public IEnumerable`1<ForeignKey> ForeignKeyIterator { get; }
    public IEnumerable`1<UniqueKey> UniqueKeyIterator { get; }
    public PrimaryKey PrimaryKey { get; public set; }
    public string Schema { get; public set; }
    public int UniqueInteger { get; public set; }
    public bool IsQuoted { get; public set; }
    public IEnumerable`1<string> CheckConstraintsIterator { get; }
    public bool IsAbstractUnionTable { get; }
    public bool HasDenormalizedTables { get; }
    public bool IsAbstract { get; public set; }
    internal IDictionary`2<string, UniqueKey> UniqueKeys { get; }
    public bool HasPrimaryKey { get; }
    public string Catalog { get; public set; }
    public string Comment { get; public set; }
    public string Subselect { get; public set; }
    public IKeyValue IdentifierValue { get; public set; }
    public bool IsSubselect { get; }
    public bool IsPhysicalTable { get; }
    public SchemaAction SchemaActions { get; public set; }
    public string RowId { get; public set; }
    public bool IsSchemaQuoted { get; }
    public bool IsCatalogQuoted { get; }
    public Table(string name);
    public string get_Name();
    public void set_Name(string value);
    public int get_ColumnSpan();
    public virtual IEnumerable`1<Column> get_ColumnIterator();
    public virtual IEnumerable`1<Index> get_IndexIterator();
    public IEnumerable`1<ForeignKey> get_ForeignKeyIterator();
    public virtual IEnumerable`1<UniqueKey> get_UniqueKeyIterator();
    [CompilerGeneratedAttribute]
public virtual PrimaryKey get_PrimaryKey();
    [CompilerGeneratedAttribute]
public virtual void set_PrimaryKey(PrimaryKey value);
    public string get_Schema();
    public void set_Schema(string value);
    public int get_UniqueInteger();
    public void set_UniqueInteger(int value);
    public bool get_IsQuoted();
    public void set_IsQuoted(bool value);
    public IEnumerable`1<string> get_CheckConstraintsIterator();
    public bool get_IsAbstractUnionTable();
    public bool get_HasDenormalizedTables();
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    internal IDictionary`2<string, UniqueKey> get_UniqueKeys();
    public bool get_HasPrimaryKey();
    public string get_Catalog();
    public void set_Catalog(string value);
    public string get_Comment();
    public void set_Comment(string value);
    public string get_Subselect();
    public void set_Subselect(string value);
    public IKeyValue get_IdentifierValue();
    public void set_IdentifierValue(IKeyValue value);
    public bool get_IsSubselect();
    public bool get_IsPhysicalTable();
    public SchemaAction get_SchemaActions();
    public void set_SchemaActions(SchemaAction value);
    [CompilerGeneratedAttribute]
public string get_RowId();
    [CompilerGeneratedAttribute]
public void set_RowId(string value);
    public bool get_IsSchemaQuoted();
    public bool get_IsCatalogQuoted();
    public sealed virtual string SqlCreateString(Dialect dialect, IMapping p, string defaultCatalog, string defaultSchema);
    public sealed virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
    public string GetQualifiedName(Dialect dialect);
    public virtual string GetQualifiedName(Dialect dialect, string defaultCatalog, string defaultSchema);
    public string GetQuotedName();
    public string GetQuotedName(Dialect dialect);
    public string GetQuotedSchema();
    public string GetQuotedSchema(Dialect dialect);
    public string GetQuotedSchema(Dialect dialect, string defaultQuotedSchema);
    public string GetQuotedCatalog();
    public string GetQuotedCatalog(Dialect dialect);
    public string GetQuotedCatalog(Dialect dialect, string defaultQuotedCatalog);
    [ObsoleteAttribute("This method is no-op and has no usages")]
public string GetQuotedSchemaName(Dialect dialect);
    public Column GetColumn(int n);
    public void AddColumn(Column column);
    public String[] SqlAlterStrings(Dialect dialect, IMapping p, ITableMetadata tableInfo, string defaultCatalog, string defaultSchema);
    public Index GetIndex(string indexName);
    public Index AddIndex(Index index);
    public Index GetOrCreateIndex(string indexName);
    public UniqueKey GetUniqueKey(string keyName);
    public UniqueKey AddUniqueKey(UniqueKey uniqueKey);
    public UniqueKey GetOrCreateUniqueKey(string keyName);
    public virtual void CreateForeignKeys();
    public virtual ForeignKey CreateForeignKey(string keyName, IEnumerable`1<Column> keyColumns, string referencedEntityName);
    public virtual ForeignKey CreateForeignKey(string keyName, IEnumerable`1<Column> keyColumns, string referencedEntityName, IEnumerable`1<Column> referencedColumns);
    public virtual UniqueKey CreateUniqueKey(IList`1<Column> keyColumns);
    [ObsoleteAttribute("Use Constraint.GenerateName instead.")]
public string UniqueColumnString(IEnumerable uniqueColumns);
    [ObsoleteAttribute("Use Constraint.GenerateName instead.")]
public string UniqueColumnString(IEnumerable iterator, string referencedEntityName);
    public void SetIdentifierValue(SimpleValue identifierValue);
    public void AddCheckConstraint(string constraint);
    internal void SetHasDenormalizedTables();
    public virtual bool ContainsColumn(Column column);
    public virtual Column GetColumn(Column column);
    private static bool AreSameColumns(ICollection`1<Column> col1, ICollection`1<Column> col2);
    public virtual String[] SqlCommentStrings(Dialect dialect, string defaultCatalog, string defaultSchema);
    public virtual string SqlTemporaryTableCreateString(Dialect dialect, IMapping mapping);
    public virtual string ToString();
    public IEnumerable`1<string> ValidateColumns(Dialect dialect, IMapping mapping, ITableMetadata tableInfo);
}
public abstract class NHibernate.Mapping.ToOne : SimpleValue {
    private FetchMode fetchMode;
    private bool lazy;
    internal string referencedPropertyName;
    private string referencedEntityName;
    private bool unwrapProxy;
    public FetchMode FetchMode { get; public set; }
    public string ReferencedPropertyName { get; public set; }
    public string ReferencedEntityName { get; public set; }
    public bool IsLazy { get; public set; }
    public IType Type { get; }
    public bool IsTypeSpecified { get; }
    public bool UnwrapProxy { get; public set; }
    public ToOne(Table table);
    public virtual FetchMode get_FetchMode();
    public virtual void set_FetchMode(FetchMode value);
    public string get_ReferencedPropertyName();
    public void set_ReferencedPropertyName(string value);
    public string get_ReferencedEntityName();
    public void set_ReferencedEntityName(string value);
    public sealed virtual bool get_IsLazy();
    public sealed virtual void set_IsLazy(bool value);
    public abstract virtual void CreateForeignKey();
    public virtual void SetTypeUsingReflection(string className, string propertyName, string accesorName);
    public virtual bool IsValid(IMapping mapping);
    public abstract virtual IType get_Type();
    public virtual bool get_IsTypeSpecified();
    public bool get_UnwrapProxy();
    public void set_UnwrapProxy(bool value);
}
public class NHibernate.Mapping.TypeDef : object {
    private string typeClass;
    private IDictionary`2<string, string> parameters;
    public string TypeClass { get; }
    public IDictionary`2<string, string> Parameters { get; }
    public TypeDef(string typeClass, IDictionary`2<string, string> parameters);
    public string get_TypeClass();
    public IDictionary`2<string, string> get_Parameters();
}
public class NHibernate.Mapping.UnionSubclass : Subclass {
    private Table table;
    unknown Table NHibernate.Mapping.ITableOwner.Table {private set; }
    public Table Table { get; }
    protected internal IEnumerable`1<Property> NonDuplicatedPropertyIterator { get; }
    public Table IdentityTable { get; }
    public UnionSubclass(PersistentClass superclass);
    private sealed virtual override void NHibernate.Mapping.ITableOwner.set_Table(Table value);
    public virtual Table get_Table();
    protected internal virtual IEnumerable`1<Property> get_NonDuplicatedPropertyIterator();
    public virtual Table get_IdentityTable();
}
public class NHibernate.Mapping.UniqueKey : Constraint {
    public string SqlConstraintString(Dialect dialect);
    public virtual string SqlConstraintString(Dialect dialect, string constraintName, string defaultCatalog, string defaultSchema);
    public virtual string SqlCreateString(Dialect dialect, IMapping p, string defaultCatalog, string defaultSchema);
    public virtual string SqlDropString(Dialect dialect, string defaultCatalog, string defaultSchema);
    public virtual bool IsGenerated(Dialect dialect);
}
public class NHibernate.MappingException : HibernateException {
    public MappingException(string message);
    public MappingException(Exception innerException);
    public MappingException(string message, Exception innerException);
    protected MappingException(SerializationInfo info, StreamingContext context);
}
public interface NHibernate.Metadata.IClassMetadata {
    public string EntityName { get; }
    public string IdentifierPropertyName { get; }
    public String[] PropertyNames { get; }
    public IType IdentifierType { get; }
    public IType[] PropertyTypes { get; }
    public bool IsMutable { get; }
    public bool IsVersioned { get; }
    public int VersionProperty { get; }
    public Boolean[] PropertyNullability { get; }
    public Boolean[] PropertyLaziness { get; }
    public Int32[] NaturalIdentifierProperties { get; }
    public bool IsInherited { get; }
    public bool HasProxy { get; }
    public bool HasIdentifierProperty { get; }
    public bool HasNaturalIdentifier { get; }
    public bool HasSubclasses { get; }
    public Type MappedClass { get; }
    public bool ImplementsLifecycle { get; }
    public bool ImplementsValidatable { get; }
    public abstract virtual string get_EntityName();
    public abstract virtual string get_IdentifierPropertyName();
    public abstract virtual String[] get_PropertyNames();
    public abstract virtual IType get_IdentifierType();
    public abstract virtual IType[] get_PropertyTypes();
    public abstract virtual bool get_IsMutable();
    public abstract virtual bool get_IsVersioned();
    public abstract virtual int get_VersionProperty();
    public abstract virtual Boolean[] get_PropertyNullability();
    public abstract virtual Boolean[] get_PropertyLaziness();
    public abstract virtual Int32[] get_NaturalIdentifierProperties();
    public abstract virtual bool get_IsInherited();
    public abstract virtual IType GetPropertyType(string propertyName);
    public abstract virtual bool get_HasProxy();
    public abstract virtual bool get_HasIdentifierProperty();
    public abstract virtual bool get_HasNaturalIdentifier();
    public abstract virtual bool get_HasSubclasses();
    public abstract virtual Object[] GetPropertyValuesToInsert(object entity, IDictionary mergeMap, ISessionImplementor session);
    public abstract virtual Type get_MappedClass();
    public abstract virtual object Instantiate(object id);
    public abstract virtual object GetPropertyValue(object obj, string propertyName);
    public abstract virtual Object[] GetPropertyValues(object entity);
    public abstract virtual void SetPropertyValue(object obj, string propertyName, object value);
    public abstract virtual void SetPropertyValues(object entity, Object[] values);
    public abstract virtual object GetIdentifier(object entity);
    public abstract virtual void SetIdentifier(object entity, object id);
    public abstract virtual bool get_ImplementsLifecycle();
    public abstract virtual bool get_ImplementsValidatable();
    public abstract virtual object GetVersion(object obj);
}
public interface NHibernate.Metadata.ICollectionMetadata {
    public IType KeyType { get; }
    public IType ElementType { get; }
    public IType IndexType { get; }
    public bool HasIndex { get; }
    public string Role { get; }
    public bool IsArray { get; }
    public bool IsPrimitiveArray { get; }
    public bool IsLazy { get; }
    public abstract virtual IType get_KeyType();
    public abstract virtual IType get_ElementType();
    public abstract virtual IType get_IndexType();
    public abstract virtual bool get_HasIndex();
    public abstract virtual string get_Role();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsPrimitiveArray();
    public abstract virtual bool get_IsLazy();
}
[ExtensionAttribute]
internal static class NHibernate.Multi.CachingInformationExtensions : object {
    [ExtensionAttribute]
public static IType[] GetCacheTypes(ICachingInformation cachingInformation);
}
public class NHibernate.Multi.CriteriaBatchItem`1 : QueryBatchItemBase`1<T> {
    private CriteriaImpl _criteria;
    public CriteriaBatchItem`1(ICriteria query);
    protected virtual Task`1<IList`1<T>> GetResultsNonBatchedAsync(CancellationToken cancellationToken);
    protected virtual List`1<QueryInfo<T>> GetQueryInformation(ISessionImplementor session);
    protected virtual IList`1<T> GetResultsNonBatched();
    protected virtual List`1<T> DoGetResults();
}
public interface NHibernate.Multi.ICachingInformation {
    public bool IsCacheable { get; }
    public QueryKey CacheKey { get; }
    public QueryParameters Parameters { get; }
    public ISet`1<string> QuerySpaces { get; }
    public bool CanGetFromCache { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public IType[] ResultTypes { get; }
    public IList ResultToCache { get; }
    public string QueryIdentifier { get; }
    public abstract virtual bool get_IsCacheable();
    public abstract virtual QueryKey get_CacheKey();
    public abstract virtual QueryParameters get_Parameters();
    public abstract virtual ISet`1<string> get_QuerySpaces();
    public abstract virtual bool get_CanGetFromCache();
    public abstract virtual IType[] get_ResultTypes();
    public abstract virtual IList get_ResultToCache();
    public abstract virtual string get_QueryIdentifier();
    public abstract virtual void SetCachedResult(IList result);
    public abstract virtual void SetCacheBatcher(CacheBatcher cacheBatcher);
}
internal interface NHibernate.Multi.ICachingInformationWithFetches {
    public IType[] CacheTypes { get; }
    public abstract virtual IType[] get_CacheTypes();
}
internal interface NHibernate.Multi.IFutureList`1 {
}
internal interface NHibernate.Multi.ILinqBatchItem {
    public abstract virtual List`1<TResult> GetTypedResults();
}
public interface NHibernate.Multi.IQueryBatch {
    public bool IsExecutedOrEmpty { get; }
    public Nullable`1<int> Timeout { get; public set; }
    public Nullable`1<FlushMode> FlushMode { get; public set; }
    public abstract virtual Task ExecuteAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<TResult>> GetResultAsync(int queryIndex, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<TResult>> GetResultAsync(string querykey, CancellationToken cancellationToken);
    public abstract virtual void Execute();
    public abstract virtual bool get_IsExecutedOrEmpty();
    public abstract virtual void Add(IQueryBatchItem query);
    public abstract virtual void Add(string key, IQueryBatchItem query);
    public abstract virtual IList`1<TResult> GetResult(int queryIndex);
    public abstract virtual IList`1<TResult> GetResult(string querykey);
    public abstract virtual Nullable`1<int> get_Timeout();
    public abstract virtual void set_Timeout(Nullable`1<int> value);
    public abstract virtual Nullable`1<FlushMode> get_FlushMode();
    public abstract virtual void set_FlushMode(Nullable`1<FlushMode> value);
}
public interface NHibernate.Multi.IQueryBatchItem {
    public IEnumerable`1<ICachingInformation> CachingInformation { get; }
    public abstract virtual Task`1<int> ProcessResultsSetAsync(DbDataReader reader, CancellationToken cancellationToken);
    public abstract virtual Task ExecuteNonBatchedAsync(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ICachingInformation> get_CachingInformation();
    public abstract virtual void Init(ISessionImplementor session);
    public abstract virtual IEnumerable`1<string> GetQuerySpaces();
    public abstract virtual IEnumerable`1<ISqlCommand> GetCommands();
    public abstract virtual int ProcessResultsSet(DbDataReader reader);
    public abstract virtual void ProcessResults();
    public abstract virtual void ExecuteNonBatched();
}
public interface NHibernate.Multi.IQueryBatchItem`1 {
    public Action`1<IList`1<TResult>> AfterLoadCallback { get; public set; }
    public abstract virtual IList`1<TResult> GetResults();
    public abstract virtual Action`1<IList`1<TResult>> get_AfterLoadCallback();
    public abstract virtual void set_AfterLoadCallback(Action`1<IList`1<TResult>> value);
}
internal interface NHibernate.Multi.IQueryBatchItemWithAsyncProcessResults {
    public abstract virtual Task ProcessResultsAsync(CancellationToken cancellationToken);
    public abstract virtual void ProcessResults();
}
public static class NHibernate.Multi.LinqBatchItem : object {
    public static LinqBatchItem`1<TResult> Create(IQueryable`1<T> query, Expression`1<Func`2<IQueryable`1<T>, TResult>> selector);
    public static LinqBatchItem`1<T> Create(IQueryable`1<T> query);
    private static LinqBatchItem`1<TResult> GetForQuery(IQueryable query, Expression ex);
}
public class NHibernate.Multi.LinqBatchItem`1 : QueryBatchItem`1<T> {
    private Delegate _postExecuteTransformer;
    private Type _resultTypeOverride;
    public LinqBatchItem`1(IQuery query);
    internal LinqBatchItem`1(IQuery query, NhLinqExpression linq);
    [AsyncStateMachineAttribute("NHibernate.Multi.LinqBatchItem`1/<GetResultsNonBatchedAsync>d__0")]
protected virtual Task`1<IList`1<T>> GetResultsNonBatchedAsync(CancellationToken cancellationToken);
    protected virtual IList`1<T> GetResultsNonBatched();
    protected virtual List`1<T> DoGetResults();
    private List`1<T> GetTransformedResults(IList transformerList);
    private sealed virtual override List`1<TResult> NHibernate.Multi.ILinqBatchItem.GetTypedResults();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<IList`1<T>> <>n__0(CancellationToken cancellationToken);
}
internal static class NHibernate.Multi.LinqBatchReflectHelper : object {
    private static ConcurrentDictionary`2<Type, Func`2<ILinqBatchItem, IList>> GetResultsForTypeDic;
    private static MethodInfo GetTypedResultsMethod;
    private static LinqBatchReflectHelper();
    internal static IList GetTypedResults(ILinqBatchItem batchItem, Type type);
    private static Func`2<ILinqBatchItem, IList> CompileDelegate(Type type);
}
public class NHibernate.Multi.QueryBatch : object {
    private static INHibernateLogger Log;
    private bool _autoReset;
    private List`1<IQueryBatchItem> _queries;
    private Dictionary`2<string, IQueryBatchItem> _queriesByKey;
    private bool _executed;
    [CompilerGeneratedAttribute]
private ISessionImplementor <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FlushMode> <FlushMode>k__BackingField;
    protected ISessionImplementor Session { get; }
    public Nullable`1<int> Timeout { get; public set; }
    public Nullable`1<FlushMode> FlushMode { get; public set; }
    public bool IsExecutedOrEmpty { get; }
    public QueryBatch(ISessionImplementor session, bool autoReset);
    private static QueryBatch();
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatch/<ExecuteAsync>d__0")]
public sealed virtual Task ExecuteAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<IList`1<TResult>> GetResultAsync(int queryIndex, CancellationToken cancellationToken);
    public sealed virtual Task`1<IList`1<TResult>> GetResultAsync(string querykey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatch/<GetResultsAsync>d__3`1")]
private Task`1<IList`1<TResult>> GetResultsAsync(IQueryBatchItem query, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatch/<ExecuteBatchedAsync>d__4")]
protected Task ExecuteBatchedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatch/<GetCachedResultsAsync>d__5")]
private Task GetCachedResultsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatch/<PutCacheableResultsAsync>d__6")]
private Task PutCacheableResultsAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
protected ISessionImplementor get_Session();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_Timeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<FlushMode> get_FlushMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FlushMode(Nullable`1<FlushMode> value);
    public sealed virtual void Execute();
    public sealed virtual bool get_IsExecutedOrEmpty();
    public sealed virtual void Add(IQueryBatchItem query);
    public sealed virtual void Add(string key, IQueryBatchItem query);
    public sealed virtual IList`1<TResult> GetResult(int queryIndex);
    public sealed virtual IList`1<TResult> GetResult(string querykey);
    private IList`1<TResult> GetResults(IQueryBatchItem query);
    private void Init();
    protected void ExecuteBatched();
    private void GetCachedResults();
    private void CombineQueries(IResultSetsCommand resultSetsCommand);
    private void PutCacheableResults();
    private IEnumerable`1<IGrouping`2<IQueryCache, ICachingInformation>> GetQueriesByCaches(Func`2<ICachingInformation, bool> cachingInformationFilter);
}
[ExtensionAttribute]
public static class NHibernate.Multi.QueryBatchExtensions : object {
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, IQueryOver query, Action`1<IList`1<TResult>> afterLoad);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, string key, IQueryOver query);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, IQueryOver`1<TResult> query, Action`1<IList`1<TResult>> afterLoad);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, string key, IQueryOver`1<TResult> query);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, ICriteria query, Action`1<IList`1<TResult>> afterLoad);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, string key, ICriteria query);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, DetachedCriteria query, Action`1<IList`1<TResult>> afterLoad);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, string key, DetachedCriteria query);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, IQuery query, Action`1<IList`1<TResult>> afterLoad);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, string key, IQuery query);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, IQueryable`1<TResult> query, Action`1<IList`1<TResult>> afterLoad);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, string key, IQueryable`1<TResult> query);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, IQueryable`1<TSource> query, Expression`1<Func`2<IQueryable`1<TSource>, TResult>> selector, Action`1<TResult> afterLoad);
    [ExtensionAttribute]
public static IQueryBatch Add(IQueryBatch batch, string key, IQueryable`1<TSource> query, Expression`1<Func`2<IQueryable`1<TSource>, TResult>> selector);
    [ExtensionAttribute]
public static IQueryBatch SetTimeout(IQueryBatch batch, Nullable`1<int> timeout);
    [ExtensionAttribute]
public static IQueryBatch SetFlushMode(IQueryBatch batch, FlushMode mode);
    [ExtensionAttribute]
public static IFutureEnumerable`1<TResult> AddAsFuture(IQueryBatch batch, IQueryOver query);
    [ExtensionAttribute]
public static IFutureEnumerable`1<TResult> AddAsFuture(IQueryBatch batch, IQueryOver`1<TResult> query);
    [ExtensionAttribute]
public static IFutureEnumerable`1<TResult> AddAsFuture(IQueryBatch batch, ICriteria query);
    [ExtensionAttribute]
public static IFutureEnumerable`1<TResult> AddAsFuture(IQueryBatch batch, DetachedCriteria query);
    [ExtensionAttribute]
public static IFutureEnumerable`1<TResult> AddAsFuture(IQueryBatch batch, IQuery query);
    [ExtensionAttribute]
public static IFutureEnumerable`1<TResult> AddAsFuture(IQueryBatch batch, IQueryable`1<TResult> query);
    [ExtensionAttribute]
public static IFutureEnumerable`1<TResult> AddAsFuture(IQueryBatch batch, IQueryBatchItem`1<TResult> query);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> AddAsFutureValue(IQueryBatch batch, IQueryable`1<TSource> query, Expression`1<Func`2<IQueryable`1<TSource>, TResult>> selector);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> AddAsFutureValue(IQueryBatch batch, IQueryable`1<TResult> query);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> AddAsFutureValue(IQueryBatch batch, ICriteria query);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> AddAsFutureValue(IQueryBatch batch, DetachedCriteria query);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> AddAsFutureValue(IQueryBatch batch, IQueryOver query);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> AddAsFutureValue(IQueryBatch batch, IQueryOver`1<TResult> query);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> AddAsFutureValue(IQueryBatch batch, IQuery query);
    [ExtensionAttribute]
public static IFutureValue`1<TResult> AddAsFutureValue(IQueryBatch batch, IQueryBatchItem`1<TResult> query);
    private static LinqBatchItem`1<TResult> For(IQueryable`1<TResult> query);
    private static LinqBatchItem`1<TResult> For(IQueryable`1<TSource> query, Expression`1<Func`2<IQueryable`1<TSource>, TResult>> selector);
    private static QueryBatchItem`1<TResult> For(IQuery query);
    private static CriteriaBatchItem`1<TResult> For(ICriteria query);
    private static CriteriaBatchItem`1<TResult> For(DetachedCriteria query);
    private static CriteriaBatchItem`1<TResult> For(IQueryOver query);
    [ExtensionAttribute]
private static IQueryBatch Add(IQueryBatch batch, IQueryBatchItem`1<TResult> query, Action`1<IList`1<TResult>> afterLoad);
}
public class NHibernate.Multi.QueryBatchItem`1 : QueryBatchItemBase`1<TResult> {
    protected AbstractQueryImpl Query;
    public QueryBatchItem`1(IQuery query);
    protected virtual Task`1<IList`1<TResult>> GetResultsNonBatchedAsync(CancellationToken cancellationToken);
    protected virtual List`1<QueryInfo<TResult>> GetQueryInformation(ISessionImplementor session);
    protected virtual IList`1<TResult> GetResultsNonBatched();
    protected virtual List`1<TResult> DoGetResults();
}
public abstract class NHibernate.Multi.QueryBatchItemBase`1 : object {
    private static INHibernateLogger Log;
    protected ISessionImplementor Session;
    private List`1[] _subselectResultKeys;
    private List`1<QueryInfo<TResult>> _queryInfos;
    private Nullable`1<CacheMode> _cacheMode;
    private IList`1<TResult> _finalResults;
    private DbDataReader _reader;
    private List`1[] _hydratedObjects;
    [CompilerGeneratedAttribute]
private Action`1<IList`1<TResult>> <AfterLoadCallback>k__BackingField;
    public IEnumerable`1<ICachingInformation> CachingInformation { get; }
    public Action`1<IList`1<TResult>> AfterLoadCallback { get; public set; }
    private static QueryBatchItemBase`1();
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatchItemBase`1/<ProcessResultsSetAsync>d__0")]
public sealed virtual Task`1<int> ProcessResultsSetAsync(DbDataReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatchItemBase`1/<ProcessResultsAsync>d__1")]
public sealed virtual Task ProcessResultsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatchItemBase`1/<ExecuteNonBatchedAsync>d__2")]
public sealed virtual Task ExecuteNonBatchedAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<IList`1<TResult>> GetResultsNonBatchedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Multi.QueryBatchItemBase`1/<InitializeEntitiesAndCollectionsAsync>d__4")]
private Task InitializeEntitiesAndCollectionsAsync(DbDataReader reader, List`1[] hydratedObjects, CancellationToken cancellationToken);
    protected abstract virtual List`1<QueryInfo<TResult>> GetQueryInformation(ISessionImplementor session);
    public sealed virtual IEnumerable`1<ICachingInformation> get_CachingInformation();
    public virtual void Init(ISessionImplementor session);
    public sealed virtual IEnumerable`1<string> GetQuerySpaces();
    [IteratorStateMachineAttribute("NHibernate.Multi.QueryBatchItemBase`1/<GetCommands>d__19")]
public sealed virtual IEnumerable`1<ISqlCommand> GetCommands();
    public sealed virtual int ProcessResultsSet(DbDataReader reader);
    public sealed virtual void ProcessResults();
    public sealed virtual void ExecuteNonBatched();
    protected abstract virtual IList`1<TResult> GetResultsNonBatched();
    protected List`1<T> GetTypedResults();
    public sealed virtual IList`1<TResult> GetResults();
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<IList`1<TResult>> get_AfterLoadCallback();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AfterLoadCallback(Action`1<IList`1<TResult>> value);
    protected abstract virtual List`1<TResult> DoGetResults();
    private void InitializeEntitiesAndCollections(DbDataReader reader, List`1[] hydratedObjects);
    private void StopLoadingCollections(DbDataReader reader);
    private void ThrowIfNotInitialized();
}
[ExtensionAttribute]
[ObsoleteAttribute("Use Multi.IQueryBatch instead, obtainable with ISession.CreateQueryBatch.")]
public static class NHibernate.MultiCriteriaExtensions : object {
    [ExtensionAttribute]
public static IMultiCriteria SetTimeout(IMultiCriteria multiCriteria, int timeout);
}
public abstract class NHibernate.MultiTenancy.AbstractMultiTenancyConnectionProvider : object {
    public sealed virtual IConnectionAccess GetConnectionAccess(TenantConfiguration tenantConfiguration, ISessionFactoryImplementor sessionFactory);
    protected abstract virtual string GetTenantConnectionString(TenantConfiguration tenantConfiguration, ISessionFactoryImplementor sessionFactory);
}
public interface NHibernate.MultiTenancy.IMultiTenancyConnectionProvider {
    public abstract virtual IConnectionAccess GetConnectionAccess(TenantConfiguration tenantConfiguration, ISessionFactoryImplementor sessionFactory);
}
public enum NHibernate.MultiTenancy.MultiTenancyStrategy : Enum {
    public int value__;
    public static MultiTenancyStrategy None;
    public static MultiTenancyStrategy Database;
}
public class NHibernate.MultiTenancy.TenantConfiguration : object {
    [CompilerGeneratedAttribute]
private string <TenantIdentifier>k__BackingField;
    public string TenantIdentifier { get; }
    public TenantConfiguration(string tenantIdentifier);
    [CompilerGeneratedAttribute]
public string get_TenantIdentifier();
}
public static class NHibernate.NHibernateLogger : object {
    private static INHibernateLoggerFactory _loggerFactory;
    private static ILoggerFactory _legacyLoggerFactory;
    internal static ILoggerFactory LegacyLoggerFactory { get; }
    internal static ILoggerFactory get_LegacyLoggerFactory();
    public static void SetLoggersFactory(INHibernateLoggerFactory loggerFactory);
    public static INHibernateLogger For(string keyName);
    public static INHibernateLogger For(Type type);
    private static string GetNhibernateLoggerClass();
    private static INHibernateLoggerFactory GetLoggerFactory(string nhibernateLoggerClass);
}
[ExtensionAttribute]
public static class NHibernate.NHibernateLoggerExtensions : object {
    [ExtensionAttribute]
public static bool IsDebugEnabled(INHibernateLogger logger);
    [ExtensionAttribute]
public static bool IsInfoEnabled(INHibernateLogger logger);
    [ExtensionAttribute]
public static bool IsWarnEnabled(INHibernateLogger logger);
    [ExtensionAttribute]
public static bool IsErrorEnabled(INHibernateLogger logger);
    [ExtensionAttribute]
public static bool IsFatalEnabled(INHibernateLogger logger);
    [ExtensionAttribute]
public static void Fatal(INHibernateLogger logger, Exception exception, string format, Object[] args);
    [ExtensionAttribute]
public static void Fatal(INHibernateLogger logger, Exception exception, string message);
    [ExtensionAttribute]
public static void Fatal(INHibernateLogger logger, string format, Object[] args);
    [ExtensionAttribute]
public static void Fatal(INHibernateLogger logger, string message);
    [ExtensionAttribute]
public static void Error(INHibernateLogger logger, Exception exception, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(INHibernateLogger logger, Exception exception, string message);
    [ExtensionAttribute]
public static void Error(INHibernateLogger logger, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(INHibernateLogger logger, string message);
    [ExtensionAttribute]
public static void Warn(INHibernateLogger logger, Exception exception, string format, Object[] args);
    [ExtensionAttribute]
public static void Warn(INHibernateLogger logger, Exception exception, string message);
    [ExtensionAttribute]
public static void Warn(INHibernateLogger logger, string format, Object[] args);
    [ExtensionAttribute]
public static void Warn(INHibernateLogger logger, string message);
    [ExtensionAttribute]
public static void Info(INHibernateLogger logger, Exception exception, string format, Object[] args);
    [ExtensionAttribute]
public static void Info(INHibernateLogger logger, Exception exception, string message);
    [ExtensionAttribute]
public static void Info(INHibernateLogger logger, string format, Object[] args);
    [ExtensionAttribute]
public static void Info(INHibernateLogger logger, string message);
    [ExtensionAttribute]
public static void Debug(INHibernateLogger logger, Exception exception, string format, Object[] args);
    [ExtensionAttribute]
public static void Debug(INHibernateLogger logger, Exception exception, string message);
    [ExtensionAttribute]
public static void Debug(INHibernateLogger logger, string format, Object[] args);
    [ExtensionAttribute]
public static void Debug(INHibernateLogger logger, string message);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Fatal(Exception, string, params object[])", "True")]
public static void Fatal(INHibernateLogger logger, string message, Exception ex);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Error(Exception, string, params object[])", "True")]
public static void Error(INHibernateLogger logger, string message, Exception ex);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Warn(Exception, string, params object[])", "True")]
public static void Warn(INHibernateLogger logger, string message, Exception ex);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Info(Exception, string, params object[])", "True")]
public static void Info(INHibernateLogger logger, string message, Exception ex);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Debug(Exception, string, params object[])", "True")]
public static void Debug(INHibernateLogger logger, string message, Exception ex);
    private static void ThrowNotImplemented();
}
[ObsoleteAttribute("Used only in Obsolete functions to thunk to INHibernateLoggerFactory")]
internal class NHibernate.NHibernateLoggerThunk : object {
    private IInternalLogger _internalLogger;
    public NHibernateLoggerThunk(IInternalLogger internalLogger);
    public sealed virtual void Log(NHibernateLogLevel logLevel, NHibernateLogValues state, Exception exception);
    public sealed virtual bool IsEnabled(NHibernateLogLevel logLevel);
}
public enum NHibernate.NHibernateLogLevel : Enum {
    public int value__;
    public static NHibernateLogLevel Trace;
    public static NHibernateLogLevel Debug;
    public static NHibernateLogLevel Info;
    public static NHibernateLogLevel Warn;
    public static NHibernateLogLevel Error;
    public static NHibernateLogLevel Fatal;
    public static NHibernateLogLevel None;
}
public class NHibernate.NHibernateLogValues : ValueType {
    private string _format;
    private Object[] _args;
    public string Format { get; }
    public Object[] Args { get; }
    public NHibernateLogValues(string format, Object[] args);
    public string get_Format();
    public Object[] get_Args();
    public virtual string ToString();
}
public static class NHibernate.NHibernateUtil : object {
    public static AnsiStringType AnsiString;
    public static BinaryType Binary;
    public static BinaryBlobType BinaryBlob;
    public static BooleanType Boolean;
    public static ByteType Byte;
    public static CharType Character;
    public static CultureInfoType CultureInfo;
    public static DateTimeType DateTime;
    public static DateTimeNoMsType DateTimeNoMs;
    [ObsoleteAttribute("Use DateTimeType instead, it uses DateTime2 with dialects supporting it.")]
public static DateTime2Type DateTime2;
    public static LocalDateTimeType LocalDateTime;
    public static UtcDateTimeType UtcDateTime;
    public static LocalDateTimeNoMsType LocalDateTimeNoMs;
    public static UtcDateTimeNoMsType UtcDateTimeNoMs;
    public static DateTimeOffsetType DateTimeOffset;
    public static DateType Date;
    public static DateType LocalDate;
    public static DecimalType Decimal;
    public static DoubleType Double;
    public static CurrencyType Currency;
    public static GuidType Guid;
    public static Int16Type Int16;
    public static Int32Type Int32;
    public static Int64Type Int64;
    public static SByteType SByte;
    public static UInt16Type UInt16;
    public static UInt32Type UInt32;
    public static UInt64Type UInt64;
    public static SingleType Single;
    public static StringType String;
    public static StringClobType StringClob;
    public static TimeType Time;
    public static TicksType Ticks;
    public static UtcTicksType UtcTicks;
    public static TimeAsTimeSpanType TimeAsTimeSpan;
    public static TimeSpanType TimeSpan;
    [ObsoleteAttribute("Use DateTime instead.")]
public static TimestampType Timestamp;
    public static DbTimestampType DbTimestamp;
    public static UtcDbTimestampType UtcDbTimestamp;
    public static TrueFalseType TrueFalse;
    public static YesNoType YesNo;
    public static TypeType Class;
    [ObsoleteAttribute("Use MetaType without meta-values instead.")]
public static ClassMetaType ClassMetaType;
    public static MetaType MetaType;
    public static SerializableType Serializable;
    public static AnyType Object;
    public static AnsiCharType AnsiChar;
    public static XmlDocType XmlDoc;
    public static XDocType XDoc;
    public static UriType Uri;
    private static NHibernateUtil();
    public static Task InitializeAsync(object proxy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.NHibernateUtil/<GetClassAsync>d__1")]
public static Task`1<Type> GetClassAsync(object proxy, CancellationToken cancellationToken);
    public static IType GuessType(object obj);
    public static IType GuessType(Type type);
    public static IType Enum(Type enumClass);
    public static IType GetSerializable(Type serializableClass);
    public static IType Any(IType metaType, IType identifierType);
    public static IType Entity(Type persistentClass);
    public static IType Entity(string entityName);
    public static IType Custom(Type userTypeClass);
    public static void Initialize(object proxy);
    public static bool IsInitialized(object proxy);
    public static Type GetClass(object proxy);
    public static void Close(IEnumerator enumerator);
    public static void Close(IEnumerable enumerable);
    public static bool IsPropertyInitialized(object proxy, string propertyName);
}
[ObsoleteAttribute("To set no-logging, use NHibernateLogger.SetLoggersFactory(default(INHibernateLoggerFactory))")]
public class NHibernate.NoLoggingInternalLogger : object {
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
}
[ObsoleteAttribute("To set no-logging, use NHibernateLogger.SetLoggersFactory(default(INHibernateLoggerFactory))")]
public class NHibernate.NoLoggingLoggerFactory : object {
    private static IInternalLogger Nologging;
    private static NoLoggingLoggerFactory();
    public sealed virtual IInternalLogger LoggerFor(string keyName);
    public sealed virtual IInternalLogger LoggerFor(Type type);
}
internal class NHibernate.NoLoggingNHibernateLogger : object {
    public sealed virtual void Log(NHibernateLogLevel logLevel, NHibernateLogValues state, Exception exception);
    public sealed virtual bool IsEnabled(NHibernateLogLevel logLevel);
}
internal class NHibernate.NoLoggingNHibernateLoggerFactory : object {
    private static INHibernateLogger Nologging;
    private static NoLoggingNHibernateLoggerFactory();
    public sealed virtual INHibernateLogger LoggerFor(string keyName);
    public sealed virtual INHibernateLogger LoggerFor(Type type);
}
public class NHibernate.NonUniqueObjectException : HibernateException {
    private object identifier;
    private string entityName;
    public object Identifier { get; }
    public string Message { get; }
    public string EntityName { get; }
    public NonUniqueObjectException(string message, object id, string entityName);
    public NonUniqueObjectException(object id, string entityName);
    protected NonUniqueObjectException(SerializationInfo info, StreamingContext context);
    public object get_Identifier();
    public virtual string get_Message();
    public string get_EntityName();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class NHibernate.NonUniqueResultException : HibernateException {
    public NonUniqueResultException(int resultCount);
    protected NonUniqueResultException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.ObjectDeletedException : UnresolvableObjectException {
    public ObjectDeletedException(string message, object identifier, string clazz);
    protected ObjectDeletedException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.ObjectNotFoundByUniqueKeyException : HibernateException {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public string PropertyName { get; }
    public object Key { get; }
    public ObjectNotFoundByUniqueKeyException(string entityName, string propertyName, object key);
    protected ObjectNotFoundByUniqueKeyException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public object get_Key();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class NHibernate.ObjectNotFoundException : UnresolvableObjectException {
    public ObjectNotFoundException(object identifier, Type type);
    public ObjectNotFoundException(object identifier, string entityName);
    protected ObjectNotFoundException(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.Param.AbstractExplicitParameterSpecification : object {
    private int sourceColumn;
    private int sourceLine;
    private bool isSkipParameter;
    private bool isTakeParameter;
    private IPageableParameterSpecification skipParameter;
    [CompilerGeneratedAttribute]
private IType <ExpectedType>k__BackingField;
    public int SourceLine { get; }
    public int SourceColumn { get; }
    public IType ExpectedType { get; public set; }
    protected AbstractExplicitParameterSpecification(int sourceLine, int sourceColumn);
    public abstract virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual int get_SourceLine();
    public sealed virtual int get_SourceColumn();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpectedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpectedType(IType value);
    public abstract virtual string RenderDisplayInfo();
    public abstract virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    public abstract virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public abstract virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public abstract virtual void SetEffectiveType(QueryParameters queryParameters);
    public abstract virtual int GetSkipValue(QueryParameters queryParameters);
    public sealed virtual void IsSkipParameter();
    public sealed virtual void IsTakeParameterWithSkipParameter(IPageableParameterSpecification skipParameter);
    protected int GetParemeterSpan(IMapping sessionFactory);
    protected object GetPagingValue(object value, Dialect dialect, QueryParameters queryParameters);
}
public class NHibernate.Param.AggregatedIndexCollectionSelectorParameterSpecifications : object {
    private IList`1<IParameterSpecification> _paramSpecs;
    public IType ExpectedType { get; public set; }
    public AggregatedIndexCollectionSelectorParameterSpecifications(IList`1<IParameterSpecification> paramSpecs);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public sealed virtual string RenderDisplayInfo();
    public sealed virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    private string CollectDisplayInfo();
}
public class NHibernate.Param.CollectionFilterKeyParameterSpecification : object {
    private static string CollectionFilterParameterIdTemplate;
    private string collectionRole;
    private IType keyType;
    private int queryParameterPosition;
    public IType ExpectedType { get; public set; }
    public CollectionFilterKeyParameterSpecification(string collectionRole, IType keyType, int queryParameterPosition);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public sealed virtual string RenderDisplayInfo();
    [IteratorStateMachineAttribute("NHibernate.Param.CollectionFilterKeyParameterSpecification/<GetIdsForBackTrack>d__12")]
public sealed virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public virtual bool Equals(object obj);
    public bool Equals(CollectionFilterKeyParameterSpecification other);
    public virtual int GetHashCode();
}
public class NHibernate.Param.CriteriaNamedParameterSpecification : object {
    private static string CriteriaNamedParameterIdTemplate;
    private string name;
    [CompilerGeneratedAttribute]
private IType <ExpectedType>k__BackingField;
    public IType ExpectedType { get; public set; }
    public CriteriaNamedParameterSpecification(string name, IType expectedType);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Param.CriteriaNamedParameterSpecification/<BindAsync>d__1")]
public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpectedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpectedType(IType value);
    public sealed virtual string RenderDisplayInfo();
    [IteratorStateMachineAttribute("NHibernate.Param.CriteriaNamedParameterSpecification/<GetIdsForBackTrack>d__12")]
public sealed virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    protected int GetParemeterSpan(IMapping sessionFactory);
    public virtual bool Equals(object obj);
    public bool Equals(CriteriaNamedParameterSpecification other);
    public virtual int GetHashCode();
}
public class NHibernate.Param.DynamicFilterParameterSpecification : object {
    private static string DynamicFilterParameterIdTemplate;
    private IType expectedDefinedType;
    private string filterParameterFullName;
    private IType elementType;
    public string FilterParameterFullName { get; }
    public IType ElementType { get; }
    public IType ExpectedType { get; public set; }
    public DynamicFilterParameterSpecification(string filterName, string parameterName, IType expectedDefinedType, Nullable`1<int> collectionSpan);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Param.DynamicFilterParameterSpecification/<BindAsync>d__1")]
public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public string get_FilterParameterFullName();
    public IType get_ElementType();
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public sealed virtual string RenderDisplayInfo();
    [IteratorStateMachineAttribute("NHibernate.Param.DynamicFilterParameterSpecification/<GetIdsForBackTrack>d__18")]
public sealed virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    public virtual bool Equals(object obj);
    public bool Equals(DynamicFilterParameterSpecification other);
    public virtual int GetHashCode();
}
public interface NHibernate.Param.IExplicitParameterSpecification {
    public int SourceLine { get; }
    public int SourceColumn { get; }
    public abstract virtual int get_SourceLine();
    public abstract virtual int get_SourceColumn();
    public abstract virtual void SetEffectiveType(QueryParameters queryParameters);
}
public interface NHibernate.Param.IPageableParameterSpecification {
    public abstract virtual void IsSkipParameter();
    public abstract virtual void IsTakeParameterWithSkipParameter(IPageableParameterSpecification skipParameter);
    public abstract virtual int GetSkipValue(QueryParameters queryParameters);
}
public interface NHibernate.Param.IParameterSpecification {
    public IType ExpectedType { get; public set; }
    public abstract virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public abstract virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public abstract virtual IType get_ExpectedType();
    public abstract virtual void set_ExpectedType(IType value);
    public abstract virtual string RenderDisplayInfo();
    public abstract virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
}
public class NHibernate.Param.NamedParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGuessedType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCollection>k__BackingField;
    public string Name { get; private set; }
    public object Value { get; internal set; }
    public IType Type { get; internal set; }
    internal bool IsGuessedType { get; internal set; }
    public bool IsCollection { get; }
    public NamedParameter(string name, object value, IType type);
    internal NamedParameter(string name, object value, IType type, bool isCollection);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(object value);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(IType value);
    [CompilerGeneratedAttribute]
internal bool get_IsGuessedType();
    [CompilerGeneratedAttribute]
internal void set_IsGuessedType(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsCollection();
    public bool Equals(NamedParameter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NHibernate.Param.NamedParameterSpecification : AbstractExplicitParameterSpecification {
    private static string NamedParameterIdTemplate;
    private string name;
    public string Name { get; }
    public NamedParameterSpecification(int sourceLine, int sourceColumn, string name);
    public virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Param.NamedParameterSpecification/<BindAsync>d__1")]
public virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public string get_Name();
    public virtual string RenderDisplayInfo();
    [IteratorStateMachineAttribute("NHibernate.Param.NamedParameterSpecification/<GetIdsForBackTrack>d__8")]
public virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    public virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public virtual int GetSkipValue(QueryParameters queryParameters);
    public virtual void SetEffectiveType(QueryParameters queryParameters);
    public virtual bool Equals(object obj);
    public bool Equals(NamedParameterSpecification other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class NHibernate.Param.ParametersBackTrackExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<int> GetEffectiveParameterLocations(IList`1<Parameter> sqlParameters, string backTrackId);
    [IteratorStateMachineAttribute("NHibernate.Param.ParametersBackTrackExtensions/<GetEffectiveParameterLocationsSlow>d__1")]
private static IEnumerable`1<int> GetEffectiveParameterLocationsSlow(IList`1<Parameter> sqlParameters, string backTrackId);
    [ExtensionAttribute]
internal static BackTrackCacheParameterList ToBackTrackCacheParameterList(IEnumerable`1<Parameter> sqlParameters);
    [ExtensionAttribute]
public static SqlType[] GetQueryParameterTypes(IEnumerable`1<IParameterSpecification> parameterSpecs, IList`1<Parameter> sqlQueryParametersList, ISessionFactoryImplementor factory);
    [ExtensionAttribute]
public static void ResetEffectiveExpectedType(IEnumerable`1<IParameterSpecification> parameterSpecs, QueryParameters queryParameters);
}
public class NHibernate.Param.PositionalParameterSpecification : AbstractExplicitParameterSpecification {
    private static string PositionalParameterIdTemplate;
    private int hqlPosition;
    public int HqlPosition { get; }
    public PositionalParameterSpecification(int sourceLine, int sourceColumn, int hqlPosition);
    public virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Param.PositionalParameterSpecification/<BindAsync>d__1")]
public virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public int get_HqlPosition();
    public virtual string RenderDisplayInfo();
    [IteratorStateMachineAttribute("NHibernate.Param.PositionalParameterSpecification/<GetIdsForBackTrack>d__8")]
public virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    public virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public virtual int GetSkipValue(QueryParameters queryParameters);
    public virtual void SetEffectiveType(QueryParameters queryParameters);
    public virtual bool Equals(object obj);
    public bool Equals(PositionalParameterSpecification other);
    public virtual int GetHashCode();
}
public class NHibernate.Param.QuerySkipParameterSpecification : object {
    private String[] idTrack;
    private string limitParametersNameForThisQuery;
    private IType type;
    public IType ExpectedType { get; public set; }
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public sealed virtual string RenderDisplayInfo();
    public sealed virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    public virtual bool Equals(object obj);
    public bool Equals(QuerySkipParameterSpecification other);
    public virtual int GetHashCode();
}
public class NHibernate.Param.QueryTakeParameterSpecification : object {
    private String[] idTrack;
    private string limitParametersNameForThisQuery;
    private IType type;
    public IType ExpectedType { get; public set; }
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public sealed virtual string RenderDisplayInfo();
    public sealed virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
    public virtual bool Equals(object obj);
    public bool Equals(QueryTakeParameterSpecification other);
    public virtual int GetHashCode();
}
public class NHibernate.Param.VersionTypeSeedParameterSpecification : object {
    private static string IdBackTrack;
    private String[] idForBackTracks;
    private IVersionType type;
    public IType ExpectedType { get; public set; }
    public VersionTypeSeedParameterSpecification(IVersionType type);
    [AsyncStateMachineAttribute("NHibernate.Param.VersionTypeSeedParameterSpecification/<BindAsync>d__0")]
public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> multiSqlQueryParametersList, int singleSqlParametersOffset, IList`1<Parameter> sqlQueryParametersList, QueryParameters queryParameters, ISessionImplementor session);
    public sealed virtual IType get_ExpectedType();
    public sealed virtual void set_ExpectedType(IType value);
    public sealed virtual string RenderDisplayInfo();
    public sealed virtual IEnumerable`1<string> GetIdsForBackTrack(IMapping sessionFactory);
}
public class NHibernate.PersistentObjectException : HibernateException {
    public PersistentObjectException(string message);
    protected PersistentObjectException(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.Persister.Collection.AbstractCollectionPersister : object {
    protected static object NotFoundPlaceHolder;
    private string role;
    private SqlCommandInfo sqlDeleteString;
    private SqlCommandInfo sqlInsertRowString;
    private SqlCommandInfo sqlUpdateRowString;
    private SqlCommandInfo sqlDeleteRowString;
    private ConcurrentDictionary`2<Boolean[], SqlCommandInfo> sqlDeleteRowStringByNullness;
    private SqlString sqlSelectRowByIndexString;
    private SqlString sqlDetectRowByIndexString;
    private SqlString sqlDetectRowByElementString;
    private string sqlOrderByString;
    protected string sqlWhereString;
    private string sqlOrderByStringTemplate;
    private string sqlWhereStringTemplate;
    private bool hasOrder;
    private bool hasWhere;
    private int baseIndex;
    protected internal bool indexContainsFormula;
    protected internal bool elementIsPureFormula;
    private IType keyType;
    private IType indexType;
    private IType elementType;
    private IType identifierType;
    private String[] keyColumnNames;
    private String[] indexColumnNames;
    protected String[] indexFormulaTemplates;
    private String[] indexFormulas;
    protected Boolean[] indexColumnIsSettable;
    private String[] elementColumnNames;
    protected String[] elementFormulaTemplates;
    protected String[] elementFormulas;
    protected Boolean[] elementColumnIsSettable;
    protected Boolean[] elementColumnIsInPrimaryKey;
    private String[] indexColumnAliases;
    protected String[] elementColumnAliases;
    private String[] keyColumnAliases;
    private string identifierColumnName;
    private string identifierColumnAlias;
    protected string qualifiedTableName;
    private string queryLoaderName;
    private bool supportsQueryCache;
    private bool isPrimitiveArray;
    private bool isArray;
    private bool hasIndex;
    protected bool hasIdentifier;
    protected IInsertGeneratedIdentifierDelegate identityDelegate;
    private bool isLazy;
    private bool isExtraLazy;
    private bool isInverse;
    private bool isMutable;
    private bool isVersioned;
    protected int batchSize;
    private FetchMode fetchMode;
    private bool hasOrphanDelete;
    private bool subselectLoadable;
    private Type elementClass;
    private string entityName;
    private Dialect dialect;
    private ISQLExceptionConverter sqlExceptionConverter;
    private ISessionFactoryImplementor factory;
    private IEntityPersister ownerPersister;
    private IIdentifierGenerator identifierGenerator;
    private IPropertyMapping elementPropertyMapping;
    private IEntityPersister elementPersister;
    private ICacheConcurrencyStrategy cache;
    private CollectionType collectionType;
    private ICollectionInitializer initializer;
    private ICacheEntryStructure cacheEntryStructure;
    private FilterHelper filterHelper;
    private FilterHelper manyToManyFilterHelper;
    private string manyToManyWhereString;
    private string manyToManyWhereTemplate;
    private string manyToManyOrderByString;
    private string manyToManyOrderByTemplate;
    private bool insertCallable;
    private bool updateCallable;
    private bool deleteCallable;
    private bool deleteAllCallable;
    private ExecuteUpdateResultCheckStyle insertCheckStyle;
    private ExecuteUpdateResultCheckStyle updateCheckStyle;
    private ExecuteUpdateResultCheckStyle deleteCheckStyle;
    private ExecuteUpdateResultCheckStyle deleteAllCheckStyle;
    private String[] spaces;
    private Dictionary`2<string, object> collectionPropertyColumnAliases;
    private Dictionary`2<string, object> collectionPropertyColumnNames;
    private static INHibernateLogger log;
    private string identitySelectString;
    private bool isCollectionIntegerIndex;
    public bool HasCache { get; }
    public bool SupportsQueryCache { get; }
    public bool HasOrdering { get; }
    public bool HasManyToManyOrdering { get; }
    public bool HasWhere { get; }
    public String[] IndexColumnNames { get; }
    public String[] ElementColumnNames { get; }
    public bool HasIndex { get; }
    public string TableName { get; }
    public bool HasOrphanDelete { get; }
    public object NotFoundObject { get; }
    public ICacheConcurrencyStrategy Cache { get; }
    public CollectionType CollectionType { get; }
    public FetchMode FetchMode { get; }
    protected SqlCommandInfo SqlDeleteString { get; }
    protected SqlCommandInfo SqlInsertRowString { get; }
    protected SqlCommandInfo SqlUpdateRowString { get; }
    protected SqlCommandInfo SqlDeleteRowString { get; }
    public IType KeyType { get; }
    public IType IndexType { get; }
    public IType ElementType { get; }
    public Type ElementClass { get; }
    public bool IsPrimitiveArray { get; }
    public bool IsArray { get; }
    public string IdentifierColumnName { get; }
    public String[] IndexFormulas { get; }
    public String[] KeyColumnNames { get; }
    [ObsoleteAttribute("Use KeyColumnNames instead")]
public String[] JoinColumnNames { get; }
    protected String[] KeyColumnAliases { get; }
    public bool IsLazy { get; }
    public bool IsInverse { get; }
    protected bool RowDeleteEnabled { get; }
    protected bool RowInsertEnabled { get; }
    public string Role { get; }
    public string OwnerEntityName { get; }
    public IEntityPersister OwnerEntityPersister { get; }
    public IIdentifierGenerator IdentifierGenerator { get; }
    public IType IdentifierType { get; }
    public bool IsManyToMany { get; }
    public IType Type { get; }
    public string Name { get; }
    public IEntityPersister ElementPersister { get; }
    public bool IsCollection { get; }
    public String[] CollectionSpaces { get; }
    public ICollectionMetadata CollectionMetadata { get; }
    public ISessionFactoryImplementor Factory { get; }
    protected bool InsertCallable { get; }
    protected ExecuteUpdateResultCheckStyle InsertCheckStyle { get; }
    protected bool UpdateCallable { get; }
    protected ExecuteUpdateResultCheckStyle UpdateCheckStyle { get; }
    protected bool DeleteCallable { get; }
    protected ExecuteUpdateResultCheckStyle DeleteCheckStyle { get; }
    protected bool DeleteAllCallable { get; }
    protected ExecuteUpdateResultCheckStyle DeleteAllCheckStyle { get; }
    public bool IsVersioned { get; }
    protected ISQLExceptionConverter SQLExceptionConverter { get; }
    public ICacheEntryStructure CacheEntryStructure { get; }
    public bool IsSubselectLoadable { get; }
    public bool IsMutable { get; }
    public bool IsExtraLazy { get; }
    protected Dialect Dialect { get; }
    public bool CascadeDeleteEnabled { get; }
    public bool IsOneToMany { get; }
    public bool IsIdentifierAssignedByInsert { get; }
    public string IdentitySelectString { get; }
    public String[] RootTableKeyColumnNames { get; }
    public AbstractCollectionPersister(Collection collection, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory);
    private static AbstractCollectionPersister();
    public sealed virtual Task InitializeAsync(object key, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> ReadElementAsync(DbDataReader rs, object owner, String[] aliases, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<ReadIndexAsync>d__2")]
public sealed virtual Task`1<object> ReadIndexAsync(DbDataReader rs, String[] aliases, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<ReadIdentifierAsync>d__3")]
public sealed virtual Task`1<object> ReadIdentifierAsync(DbDataReader rs, string alias, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> ReadKeyAsync(DbDataReader dr, String[] aliases, ISessionImplementor session, CancellationToken cancellationToken);
    protected Task`1<int> WriteKeyAsync(DbCommand st, object id, int i, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<WriteElementAsync>d__6")]
protected Task`1<int> WriteElementAsync(DbCommand st, object elt, int i, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<WriteIndexAsync>d__7")]
protected Task`1<int> WriteIndexAsync(DbCommand st, object idx, int i, ISessionImplementor session, CancellationToken cancellationToken);
    protected Task`1<int> WriteElementToWhereAsync(DbCommand st, object elt, Boolean[] columnNullness, int i, ISessionImplementor session, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use overload with columnNullness instead")]
protected Task`1<int> WriteElementToWhereAsync(DbCommand st, object elt, int i, ISessionImplementor session, CancellationToken cancellationToken);
    protected Task`1<int> WriteIndexToWhereAsync(DbCommand st, object index, int i, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<WriteIdentifierAsync>d__11")]
protected Task`1<int> WriteIdentifierAsync(DbCommand st, object idx, int i, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<RemoveAsync>d__12")]
public sealed virtual Task RemoveAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<RecreateAsync>d__13")]
public sealed virtual Task RecreateAsync(IPersistentCollection collection, object id, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<DeleteRowsAsync>d__14")]
public sealed virtual Task DeleteRowsAsync(IPersistentCollection collection, object id, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<InsertRowsAsync>d__15")]
public sealed virtual Task InsertRowsAsync(IPersistentCollection collection, object id, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<UpdateRowsAsync>d__16")]
public sealed virtual Task UpdateRowsAsync(IPersistentCollection collection, object id, ISessionImplementor session, CancellationToken cancellationToken);
    protected abstract virtual Task`1<int> DoUpdateRowsAsync(object key, IPersistentCollection collection, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.AbstractCollectionPersister/<PerformInsertAsync>d__18")]
protected Task`1<object> PerformInsertAsync(object ownerId, IPersistentCollection collection, IExpectation expectation, object entry, int index, bool useBatch, bool callable, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task BindSelectByUniqueKeyAsync(ISessionImplementor session, DbCommand selectCommand, IBinder binder, String[] suppliedPropertyNames, CancellationToken cancellationToken);
    protected Task`1<object> PerformInsertAsync(object ownerId, IPersistentCollection collection, object entry, int index, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void PostInstantiate();
    protected void LogStaticSQL();
    public sealed virtual void Initialize(object key, ISessionImplementor session);
    protected ICollectionInitializer GetAppropriateInitializer(object key, ISessionImplementor session);
    private ICollectionInitializer GetSubselectInitializer(object key, ISessionImplementor session);
    protected abstract virtual ICollectionInitializer CreateSubselectInitializer(SubselectFetch subselect, ISessionImplementor session);
    protected abstract virtual ICollectionInitializer CreateCollectionInitializer(IDictionary`2<string, IFilter> enabledFilters);
    public sealed virtual bool get_HasCache();
    public sealed virtual bool get_SupportsQueryCache();
    public sealed virtual string GetSQLWhereString(string alias);
    public sealed virtual string GetSQLOrderByString(string alias);
    public sealed virtual string GetManyToManyOrderByString(string alias);
    public sealed virtual bool get_HasOrdering();
    public sealed virtual bool get_HasManyToManyOrdering();
    public sealed virtual bool get_HasWhere();
    public sealed virtual object ReadElement(DbDataReader rs, object owner, String[] aliases, ISessionImplementor session);
    public sealed virtual object ReadIndex(DbDataReader rs, String[] aliases, ISessionImplementor session);
    public object DecrementIndexByBase(object index);
    public sealed virtual object ReadIdentifier(DbDataReader rs, string alias, ISessionImplementor session);
    public sealed virtual object ReadKey(DbDataReader dr, String[] aliases, ISessionImplementor session);
    protected int WriteKey(DbCommand st, object id, int i, ISessionImplementor session);
    protected int WriteElement(DbCommand st, object elt, int i, ISessionImplementor session);
    protected int WriteIndex(DbCommand st, object idx, int i, ISessionImplementor session);
    protected object IncrementIndexByBase(object index);
    protected int WriteElementToWhere(DbCommand st, object elt, Boolean[] columnNullness, int i, ISessionImplementor session);
    [ObsoleteAttribute("Use overload with columnNullness instead")]
protected int WriteElementToWhere(DbCommand st, object elt, int i, ISessionImplementor session);
    protected static Boolean[] Combine(Boolean[] settable, Boolean[] columnNullness);
    protected int WriteIndexToWhere(DbCommand st, object index, int i, ISessionImplementor session);
    protected int WriteIdentifier(DbCommand st, object idx, int i, ISessionImplementor session);
    public sealed virtual String[] GetKeyColumnAliases(string suffix);
    public sealed virtual String[] GetElementColumnAliases(string suffix);
    public sealed virtual String[] GetIndexColumnAliases(string suffix);
    public sealed virtual string GetIdentifierColumnAlias(string suffix);
    [ObsoleteAttribute("Use GetSelectFragment method instead.")]
public sealed virtual string SelectFragment(string alias, string columnSuffix);
    public SelectFragment GetSelectFragment(string alias, string columnSuffix);
    private void AddWhereFragment(SqlSimpleSelectBuilder sql);
    private SqlString GenerateSelectSizeString(ISessionImplementor sessionImplementor);
    protected virtual string GetCountSqlSelectClause();
    private string GetIndexCountExpression();
    private SqlString GenerateDetectRowByIndexString();
    private SqlString GenerateSelectRowByIndexString();
    private SqlString GenerateDetectRowByElementString();
    protected virtual SelectFragment GenerateSelectFragment(string alias, string columnSuffix);
    protected virtual void AppendElementColumns(SelectFragment frag, string elemAlias);
    protected virtual void AppendIndexColumns(SelectFragment frag, string alias);
    protected virtual void AppendIdentifierColumns(SelectFragment frag, string alias);
    public sealed virtual String[] get_IndexColumnNames();
    public sealed virtual String[] GetIndexColumnNames(string alias);
    public sealed virtual String[] GetElementColumnNames(string alias);
    private static String[] Qualify(string alias, String[] columnNames, String[] formulaTemplates);
    public sealed virtual String[] get_ElementColumnNames();
    public sealed virtual bool get_HasIndex();
    public virtual string get_TableName();
    public sealed virtual void Remove(object id, ISessionImplementor session);
    public sealed virtual void Recreate(IPersistentCollection collection, object id, ISessionImplementor session);
    public sealed virtual void DeleteRows(IPersistentCollection collection, object id, ISessionImplementor session);
    private SqlCommandInfo GetDeleteCommand(bool deleteByIndex, object entry, Boolean[]& columnNullness);
    public sealed virtual void InsertRows(IPersistentCollection collection, object id, ISessionImplementor session);
    public sealed virtual bool get_HasOrphanDelete();
    public sealed virtual IType ToType(string propertyName);
    public sealed virtual bool TryToType(string propertyName, IType& type);
    public sealed virtual string GetManyToManyFilterFragment(string alias, IDictionary`2<string, IFilter> enabledFilters);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public bool IsManyToManyFiltered(IDictionary`2<string, IFilter> enabledFilters);
    public sealed virtual String[] ToColumns(string alias, string propertyName);
    public sealed virtual String[] ToColumns(string propertyName);
    protected abstract virtual SqlCommandInfo GenerateDeleteString();
    protected abstract virtual SqlCommandInfo GenerateUpdateRowString();
    protected abstract virtual SqlCommandInfo GenerateInsertRowString();
    protected abstract virtual SqlCommandInfo GenerateIdentityInsertRowString();
    [ObsoleteAttribute("Use or override overload with columnNullness instead")]
protected virtual SqlCommandInfo GenerateDeleteRowString();
    protected virtual SqlCommandInfo GenerateDeleteRowString(Boolean[] columnNullness);
    public sealed virtual void UpdateRows(IPersistentCollection collection, object id, ISessionImplementor session);
    protected abstract virtual int DoUpdateRows(object key, IPersistentCollection collection, ISessionImplementor session);
    protected virtual string FilterFragment(string alias);
    public virtual string FilterFragment(string alias, IDictionary`2<string, IFilter> enabledFilters);
    public sealed virtual string OneToManyFilterFragment(string alias);
    public virtual string ToString();
    public sealed virtual bool IsAffectedByEnabledFilters(ISessionImplementor session);
    public sealed virtual String[] GetCollectionPropertyColumnAliases(string propertyName, string suffix);
    public void InitCollectionPropertyMap();
    private void InitCollectionPropertyMap(string aliasName, IType type, String[] columnAliases, String[] columnNames);
    private static void CalcPropertyColumnSpan(IType propertyType, Int32& count);
    public sealed virtual int GetSize(object key, ISessionImplementor session);
    public sealed virtual bool IndexExists(object key, object index, ISessionImplementor session);
    public sealed virtual bool ElementExists(object key, object element, ISessionImplementor session);
    private bool Exists(object key, object indexOrElement, IType indexOrElementType, SqlString sql, ISessionImplementor session);
    public virtual object GetElementByIndex(object key, object index, ISessionImplementor session, object owner);
    public sealed virtual object get_NotFoundObject();
    public abstract virtual bool ConsumesEntityAlias();
    public abstract virtual SqlString FromJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    public abstract virtual SqlString WhereJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    [ObsoleteAttribute("Please use overload taking EntityLoadInfo")]
public virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string currentEntitySuffix, string currentCollectionSuffix, bool includeCollectionColumns);
    [ObsoleteAttribute("Please use overload taking EntityLoadInfo")]
public virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string entitySuffix, string collectionSuffix, bool includeCollectionColumns, bool includeLazyProperties);
    [ObsoleteAttribute("Please use overload without rhs and rhsAlias parameters")]
public virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string currentCollectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
    public virtual string SelectFragment(string lhsAlias, string collectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
    public virtual string IdentifierSelectFragment(string name, string suffix);
    public abstract virtual bool ConsumesCollectionAlias();
    private void CheckColumnDuplication(HashSet`1<string> distinctColumns, IEnumerable`1<ISelectable> columns);
    public sealed virtual ICacheConcurrencyStrategy get_Cache();
    public sealed virtual CollectionType get_CollectionType();
    public sealed virtual FetchMode get_FetchMode();
    protected SqlCommandInfo get_SqlDeleteString();
    protected SqlCommandInfo get_SqlInsertRowString();
    protected SqlCommandInfo get_SqlUpdateRowString();
    protected SqlCommandInfo get_SqlDeleteRowString();
    public sealed virtual IType get_KeyType();
    public sealed virtual IType get_IndexType();
    public sealed virtual IType get_ElementType();
    public sealed virtual Type get_ElementClass();
    public sealed virtual bool get_IsPrimitiveArray();
    public sealed virtual bool get_IsArray();
    public sealed virtual string get_IdentifierColumnName();
    public sealed virtual String[] get_IndexFormulas();
    public sealed virtual String[] get_KeyColumnNames();
    public sealed virtual String[] get_JoinColumnNames();
    protected String[] get_KeyColumnAliases();
    public sealed virtual bool get_IsLazy();
    public sealed virtual bool get_IsInverse();
    protected virtual bool get_RowDeleteEnabled();
    protected virtual bool get_RowInsertEnabled();
    public sealed virtual string get_Role();
    public virtual string get_OwnerEntityName();
    public sealed virtual IEntityPersister get_OwnerEntityPersister();
    public sealed virtual IIdentifierGenerator get_IdentifierGenerator();
    public sealed virtual IType get_IdentifierType();
    public abstract virtual bool get_IsManyToMany();
    public sealed virtual IType get_Type();
    public sealed virtual string get_Name();
    public sealed virtual IEntityPersister get_ElementPersister();
    public sealed virtual bool get_IsCollection();
    public sealed virtual String[] get_CollectionSpaces();
    public sealed virtual ICollectionMetadata get_CollectionMetadata();
    public sealed virtual ISessionFactoryImplementor get_Factory();
    protected virtual bool get_InsertCallable();
    protected ExecuteUpdateResultCheckStyle get_InsertCheckStyle();
    protected virtual bool get_UpdateCallable();
    protected ExecuteUpdateResultCheckStyle get_UpdateCheckStyle();
    protected virtual bool get_DeleteCallable();
    protected ExecuteUpdateResultCheckStyle get_DeleteCheckStyle();
    protected virtual bool get_DeleteAllCallable();
    protected ExecuteUpdateResultCheckStyle get_DeleteAllCheckStyle();
    public sealed virtual bool get_IsVersioned();
    protected virtual ISQLExceptionConverter get_SQLExceptionConverter();
    public sealed virtual ICacheEntryStructure get_CacheEntryStructure();
    public bool get_IsSubselectLoadable();
    public sealed virtual bool get_IsMutable();
    public sealed virtual bool get_IsExtraLazy();
    protected Dialect get_Dialect();
    public abstract virtual bool get_CascadeDeleteEnabled();
    public abstract virtual bool get_IsOneToMany();
    [ObsoleteAttribute("Use directly the alias parameter value instead")]
public virtual string GenerateTableAliasForKeyColumns(string alias);
    protected object PerformInsert(object ownerId, IPersistentCollection collection, IExpectation expectation, object entry, int index, bool useBatch, bool callable, ISessionImplementor session);
    public bool get_IsIdentifierAssignedByInsert();
    protected bool UseInsertSelectIdentity();
    protected bool UseGetGeneratedKeys();
    public sealed virtual string get_IdentitySelectString();
    public sealed virtual String[] get_RootTableKeyColumnNames();
    public int GetBatchSize();
    [ObsoleteAttribute("Use GetSelectByUniqueKeyString(string[] suppliedPropertyNames, out IType[] parameterTypes) instead.")]
public sealed virtual SqlString GetSelectByUniqueKeyString(string propertyName);
    public virtual SqlString GetSelectByUniqueKeyString(String[] suppliedPropertyNames, IType[]& parameterTypes);
    public sealed virtual void BindSelectByUniqueKey(ISessionImplementor session, DbCommand selectCommand, IBinder binder, String[] suppliedPropertyNames);
    public sealed virtual string GetInfoString();
    protected object PerformInsert(object ownerId, IPersistentCollection collection, object entry, int index, ISessionImplementor session);
}
public class NHibernate.Persister.Collection.BasicCollectionPersister : AbstractCollectionPersister {
    public bool CascadeDeleteEnabled { get; }
    public bool IsOneToMany { get; }
    public bool IsManyToMany { get; }
    public BasicCollectionPersister(Collection collection, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.BasicCollectionPersister/<DoUpdateRowsAsync>d__0")]
protected virtual Task`1<int> DoUpdateRowsAsync(object id, IPersistentCollection collection, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual bool get_CascadeDeleteEnabled();
    public virtual bool get_IsOneToMany();
    public virtual bool get_IsManyToMany();
    protected virtual SqlCommandInfo GenerateDeleteString();
    protected virtual SqlCommandInfo GenerateInsertRowString();
    protected virtual SqlCommandInfo GenerateUpdateRowString();
    protected virtual SqlCommandInfo GenerateDeleteRowString(Boolean[] columnNullness);
    public virtual bool ConsumesEntityAlias();
    public virtual bool ConsumesCollectionAlias();
    protected virtual int DoUpdateRows(object id, IPersistentCollection collection, ISessionImplementor session);
    [ObsoleteAttribute("Please use overload without rhs and rhsAlias parameters")]
public virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string collectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
    public virtual string SelectFragment(string lhsAlias, string collectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
    protected virtual ICollectionInitializer CreateCollectionInitializer(IDictionary`2<string, IFilter> enabledFilters);
    public virtual SqlString FromJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    public virtual SqlString WhereJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    protected virtual ICollectionInitializer CreateSubselectInitializer(SubselectFetch subselect, ISessionImplementor session);
    protected virtual SqlCommandInfo GenerateIdentityInsertRowString();
}
internal static class NHibernate.Persister.Collection.CollectionPersister : object {
    public static string PropId;
    public static string PropElement;
    public static string PropKey;
    public static string PropIndex;
}
[ExtensionAttribute]
public static class NHibernate.Persister.Collection.CollectionPersisterExtensions : object {
    [ExtensionAttribute]
public static int GetBatchSize(ICollectionPersister persister);
    [ExtensionAttribute]
internal static bool SupportsQueryCache(ICollectionPersister persister);
}
public class NHibernate.Persister.Collection.CollectionPropertyMapping : object {
    private IQueryableCollection memberPersister;
    public IType Type { get; }
    public CollectionPropertyMapping(IQueryableCollection memberPersister);
    public sealed virtual IType ToType(string propertyName);
    public sealed virtual bool TryToType(string propertyName, IType& type);
    public sealed virtual String[] ToColumns(string alias, string propertyName);
    public sealed virtual String[] ToColumns(string propertyName);
    public sealed virtual IType get_Type();
}
public class NHibernate.Persister.Collection.CollectionPropertyNames : object {
    public static string Size;
    public static string Elements;
    public static string Indices;
    public static string MaxIndex;
    public static string MinIndex;
    public static string MaxElement;
    public static string MinElement;
    public static string Index;
}
public class NHibernate.Persister.Collection.CompositeElementPropertyMapping : AbstractPropertyMapping {
    private IAbstractComponentType compositeType;
    public IType Type { get; }
    protected string EntityName { get; }
    public CompositeElementPropertyMapping(String[] elementColumns, String[] elementFormulaTemplates, IAbstractComponentType compositeType, IMapping factory);
    public virtual IType get_Type();
    protected virtual string get_EntityName();
}
public class NHibernate.Persister.Collection.ElementPropertyMapping : object {
    private String[] elementColumns;
    private IType type;
    public IType Type { get; }
    public ElementPropertyMapping(String[] elementColumns, IType type);
    public sealed virtual IType ToType(string propertyName);
    public sealed virtual bool TryToType(string propertyName, IType& outType);
    public sealed virtual String[] ToColumns(string alias, string propertyName);
    public sealed virtual String[] ToColumns(string propertyName);
    public sealed virtual IType get_Type();
}
public interface NHibernate.Persister.Collection.ICollectionPersister {
    public ICacheConcurrencyStrategy Cache { get; }
    public ICacheEntryStructure CacheEntryStructure { get; }
    public CollectionType CollectionType { get; }
    public IType KeyType { get; }
    public IType IndexType { get; }
    public IType ElementType { get; }
    public Type ElementClass { get; }
    public bool IsPrimitiveArray { get; }
    public bool IsArray { get; }
    public bool IsOneToMany { get; }
    public bool IsManyToMany { get; }
    public bool IsLazy { get; }
    public bool IsInverse { get; }
    public string Role { get; }
    public IEntityPersister OwnerEntityPersister { get; }
    public IIdentifierGenerator IdentifierGenerator { get; }
    public IType IdentifierType { get; }
    public String[] CollectionSpaces { get; }
    public ICollectionMetadata CollectionMetadata { get; }
    public bool CascadeDeleteEnabled { get; }
    public bool IsVersioned { get; }
    public bool IsMutable { get; }
    public ISessionFactoryImplementor Factory { get; }
    public bool IsExtraLazy { get; }
    public bool HasCache { get; }
    public bool HasIndex { get; }
    public bool HasOrphanDelete { get; }
    public bool HasOrdering { get; }
    public bool HasManyToManyOrdering { get; }
    public object NotFoundObject { get; }
    public abstract virtual Task InitializeAsync(object key, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReadKeyAsync(DbDataReader rs, String[] keyAliases, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReadElementAsync(DbDataReader rs, object owner, String[] columnAliases, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReadIndexAsync(DbDataReader rs, String[] columnAliases, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReadIdentifierAsync(DbDataReader rs, string columnAlias, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task RemoveAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task RecreateAsync(IPersistentCollection collection, object key, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task DeleteRowsAsync(IPersistentCollection collection, object key, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task UpdateRowsAsync(IPersistentCollection collection, object key, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task InsertRowsAsync(IPersistentCollection collection, object key, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual ICacheConcurrencyStrategy get_Cache();
    public abstract virtual ICacheEntryStructure get_CacheEntryStructure();
    public abstract virtual CollectionType get_CollectionType();
    public abstract virtual IType get_KeyType();
    public abstract virtual IType get_IndexType();
    public abstract virtual IType get_ElementType();
    public abstract virtual Type get_ElementClass();
    public abstract virtual bool get_IsPrimitiveArray();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsOneToMany();
    public abstract virtual bool get_IsManyToMany();
    public abstract virtual bool get_IsLazy();
    public abstract virtual bool get_IsInverse();
    public abstract virtual string get_Role();
    public abstract virtual IEntityPersister get_OwnerEntityPersister();
    public abstract virtual IIdentifierGenerator get_IdentifierGenerator();
    public abstract virtual IType get_IdentifierType();
    public abstract virtual String[] get_CollectionSpaces();
    public abstract virtual ICollectionMetadata get_CollectionMetadata();
    public abstract virtual bool get_CascadeDeleteEnabled();
    public abstract virtual bool get_IsVersioned();
    public abstract virtual bool get_IsMutable();
    public abstract virtual ISessionFactoryImplementor get_Factory();
    public abstract virtual bool get_IsExtraLazy();
    public abstract virtual void Initialize(object key, ISessionImplementor session);
    public abstract virtual bool get_HasCache();
    public abstract virtual object ReadKey(DbDataReader rs, String[] keyAliases, ISessionImplementor session);
    public abstract virtual object ReadElement(DbDataReader rs, object owner, String[] columnAliases, ISessionImplementor session);
    public abstract virtual object ReadIndex(DbDataReader rs, String[] columnAliases, ISessionImplementor session);
    public abstract virtual object ReadIdentifier(DbDataReader rs, string columnAlias, ISessionImplementor session);
    public abstract virtual string GetManyToManyFilterFragment(string alias, IDictionary`2<string, IFilter> enabledFilters);
    public abstract virtual bool get_HasIndex();
    public abstract virtual void Remove(object id, ISessionImplementor session);
    public abstract virtual void Recreate(IPersistentCollection collection, object key, ISessionImplementor session);
    public abstract virtual void DeleteRows(IPersistentCollection collection, object key, ISessionImplementor session);
    public abstract virtual void UpdateRows(IPersistentCollection collection, object key, ISessionImplementor session);
    public abstract virtual void InsertRows(IPersistentCollection collection, object key, ISessionImplementor session);
    public abstract virtual bool get_HasOrphanDelete();
    public abstract virtual bool get_HasOrdering();
    public abstract virtual bool get_HasManyToManyOrdering();
    public abstract virtual void PostInstantiate();
    public abstract virtual bool IsAffectedByEnabledFilters(ISessionImplementor session);
    public abstract virtual String[] GetKeyColumnAliases(string suffix);
    public abstract virtual String[] GetIndexColumnAliases(string suffix);
    public abstract virtual String[] GetElementColumnAliases(string suffix);
    public abstract virtual string GetIdentifierColumnAlias(string suffix);
    public abstract virtual int GetSize(object key, ISessionImplementor session);
    public abstract virtual bool IndexExists(object key, object index, ISessionImplementor session);
    public abstract virtual bool ElementExists(object key, object element, ISessionImplementor session);
    public abstract virtual object GetElementByIndex(object key, object index, ISessionImplementor session, object owner);
    public abstract virtual object get_NotFoundObject();
}
public interface NHibernate.Persister.Collection.IQueryableCollection {
    public String[] IndexFormulas { get; }
    public IEntityPersister ElementPersister { get; }
    public FetchMode FetchMode { get; }
    public String[] IndexColumnNames { get; }
    public String[] ElementColumnNames { get; }
    public bool HasWhere { get; }
    public abstract virtual String[] get_IndexFormulas();
    public abstract virtual IEntityPersister get_ElementPersister();
    public abstract virtual FetchMode get_FetchMode();
    public abstract virtual String[] get_IndexColumnNames();
    public abstract virtual String[] get_ElementColumnNames();
    public abstract virtual bool get_HasWhere();
    [ObsoleteAttribute("Use GetSelectFragment extension method instead.")]
public abstract virtual string SelectFragment(string alias, string columnSuffix);
    public abstract virtual String[] GetIndexColumnNames(string alias);
    public abstract virtual String[] GetElementColumnNames(string alias);
    public abstract virtual string GetSQLWhereString(string alias);
    public abstract virtual string GetSQLOrderByString(string alias);
    public abstract virtual string GetManyToManyOrderByString(string alias);
    [ObsoleteAttribute("Use directly the alias parameter value instead")]
public abstract virtual string GenerateTableAliasForKeyColumns(string alias);
}
public interface NHibernate.Persister.Collection.ISqlLoadableCollection {
    public string IdentifierColumnName { get; }
    public abstract virtual String[] GetCollectionPropertyColumnAliases(string propertyName, string str);
    public abstract virtual string get_IdentifierColumnName();
}
public class NHibernate.Persister.Collection.NamedQueryCollectionInitializer : object {
    private string queryName;
    private ICollectionPersister persister;
    private static INHibernateLogger log;
    public NamedQueryCollectionInitializer(string queryName, ICollectionPersister persister);
    private static NamedQueryCollectionInitializer();
    public sealed virtual Task InitializeAsync(object key, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual void Initialize(object key, ISessionImplementor session);
}
public class NHibernate.Persister.Collection.OneToManyPersister : AbstractCollectionPersister {
    private bool _cascadeDeleteEnabled;
    private bool _keyIsNullable;
    private bool _keyIsUpdateable;
    protected bool RowDeleteEnabled { get; }
    protected bool RowInsertEnabled { get; }
    public bool CascadeDeleteEnabled { get; }
    public bool IsOneToMany { get; }
    public bool IsManyToMany { get; }
    public string TableName { get; }
    public OneToManyPersister(Collection collection, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory);
    [AsyncStateMachineAttribute("NHibernate.Persister.Collection.OneToManyPersister/<DoUpdateRowsAsync>d__0")]
protected virtual Task`1<int> DoUpdateRowsAsync(object id, IPersistentCollection collection, ISessionImplementor session, CancellationToken cancellationToken);
    protected virtual bool get_RowDeleteEnabled();
    protected virtual bool get_RowInsertEnabled();
    public virtual bool get_CascadeDeleteEnabled();
    public virtual bool get_IsOneToMany();
    public virtual bool get_IsManyToMany();
    protected virtual SqlCommandInfo GenerateDeleteString();
    protected virtual SqlCommandInfo GenerateInsertRowString();
    protected virtual SqlCommandInfo GenerateUpdateRowString();
    protected virtual SqlCommandInfo GenerateDeleteRowString(Boolean[] columnNullness);
    public virtual bool ConsumesEntityAlias();
    public virtual bool ConsumesCollectionAlias();
    protected virtual int DoUpdateRows(object id, IPersistentCollection collection, ISessionImplementor session);
    [ObsoleteAttribute("Please use overload without rhs and rhsAlias parameters")]
public virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string collectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
    public virtual string SelectFragment(string lhsAlias, string collectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
    protected virtual SelectFragment GenerateSelectFragment(string alias, string columnSuffix);
    protected virtual ICollectionInitializer CreateCollectionInitializer(IDictionary`2<string, IFilter> enabledFilters);
    public virtual SqlString FromJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    public virtual SqlString WhereJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    public virtual string get_TableName();
    protected virtual string FilterFragment(string alias);
    protected virtual ICollectionInitializer CreateSubselectInitializer(SubselectFetch subselect, ISessionImplementor session);
    public virtual object GetElementByIndex(object key, object index, ISessionImplementor session, object owner);
    protected virtual SqlCommandInfo GenerateIdentityInsertRowString();
}
[ExtensionAttribute]
public static class NHibernate.Persister.Collection.QueryableCollectionExtensions : object {
    [ExtensionAttribute]
public static SelectFragment GetSelectFragment(IQueryableCollection queryable, string alias, string columnSuffix);
}
public abstract class NHibernate.Persister.Entity.AbstractEntityPersister : object {
    private static INHibernateLogger log;
    public static string EntityClass;
    protected static string Discriminator_Alias;
    private ISessionFactoryImplementor factory;
    private ICacheConcurrencyStrategy cache;
    private bool isLazyPropertiesCacheable;
    private ICacheEntryStructure cacheEntryStructure;
    private EntityMetamodel entityMetamodel;
    private Dictionary`2<Type, string> entityNameBySubclass;
    private String[] rootTableKeyColumnNames;
    private String[] identifierAliases;
    private int identifierColumnSpan;
    private string versionColumnName;
    private bool hasFormulaProperties;
    private int batchSize;
    private bool hasSubselectLoadableCollections;
    protected internal string rowIdName;
    private HashSet`1<string> lazyProperties;
    private string sqlWhereString;
    private string sqlWhereStringTemplate;
    private Int32[] propertyColumnSpans;
    private String[] propertySubclassNames;
    private String[][] propertyColumnAliases;
    private String[][] propertyColumnNames;
    private String[][] propertyColumnFormulaTemplates;
    private Boolean[][] propertyColumnUpdateable;
    private Boolean[][] propertyColumnInsertable;
    private Boolean[] propertyUniqueness;
    private Boolean[] propertySelectable;
    private String[] lazyPropertyNames;
    private Int32[] lazyPropertyNumbers;
    private IType[] lazyPropertyTypes;
    private String[][] lazyPropertyColumnAliases;
    private String[] subclassPropertyNameClosure;
    private String[] subclassPropertySubclassNameClosure;
    private IType[] subclassPropertyTypeClosure;
    private String[][] subclassPropertyFormulaTemplateClosure;
    private String[][] subclassPropertyColumnNameClosure;
    private FetchMode[] subclassPropertyFetchModeClosure;
    private Boolean[] subclassPropertyNullabilityClosure;
    protected Boolean[] propertyDefinedOnSubclass;
    private Int32[][] subclassPropertyColumnNumberClosure;
    private Int32[][] subclassPropertyFormulaNumberClosure;
    private CascadeStyle[] subclassPropertyCascadeStyleClosure;
    private String[] subclassColumnClosure;
    private Boolean[] subclassColumnLazyClosure;
    private String[] subclassColumnAliasClosure;
    private Boolean[] subclassColumnSelectableClosure;
    private String[] subclassFormulaClosure;
    private String[] subclassFormulaTemplateClosure;
    private String[] subclassFormulaAliasClosure;
    private Boolean[] subclassFormulaLazyClosure;
    private FilterHelper filterHelper;
    private Dictionary`2<string, EntityLoader> uniqueKeyLoaders;
    private Dictionary`2<LockMode, ILockingStrategy> lockers;
    private Dictionary`2<string, IUniqueEntityLoader> loaders;
    private SqlString sqlVersionSelectString;
    private SqlString sqlSnapshotSelectString;
    private SqlString sqlLazySelectString;
    private IDictionary`2<string, SqlString> _sqlLazySelectStringsByFetchGroup;
    private SqlCommandInfo sqlIdentityInsertString;
    private SqlCommandInfo sqlUpdateByRowIdString;
    private SqlCommandInfo sqlLazyUpdateByRowIdString;
    private SqlCommandInfo[] sqlDeleteStrings;
    private SqlCommandInfo[] sqlInsertStrings;
    private SqlCommandInfo[] sqlUpdateStrings;
    private SqlCommandInfo[] sqlLazyUpdateStrings;
    private SqlString sqlInsertGeneratedValuesSelectString;
    private SqlString sqlUpdateGeneratedValuesSelectString;
    private string identitySelectString;
    protected internal Boolean[] insertCallable;
    protected internal Boolean[] updateCallable;
    protected internal Boolean[] deleteCallable;
    protected internal SqlString[] customSQLInsert;
    protected internal SqlString[] customSQLUpdate;
    protected internal SqlString[] customSQLDelete;
    protected internal ExecuteUpdateResultCheckStyle[] insertResultCheckStyles;
    protected internal ExecuteUpdateResultCheckStyle[] updateResultCheckStyles;
    protected internal ExecuteUpdateResultCheckStyle[] deleteResultCheckStyles;
    private IInsertGeneratedIdentifierDelegate identityDelegate;
    private Boolean[] tableHasColumns;
    private string loaderName;
    private bool supportsQueryCache;
    private IUniqueEntityLoader queryLoader;
    private string temporaryIdTableName;
    private string temporaryIdTableDDL;
    private Dictionary`2<string, String[]> subclassPropertyAliases;
    private Dictionary`2<string, String[]> subclassPropertyColumnNames;
    protected BasicEntityPropertyMapping propertyMapping;
    private Lazy`1<String[]> defaultUniqueKeyPropertyNamesForSelectId;
    private Dictionary`2<string, int> propertySubclassJoinTableNumbersByName;
    private SqlType[] idAndVersionSqlTypes;
    protected Int32[] SubclassColumnTableNumberClosure { get; }
    protected Int32[] SubclassFormulaTableNumberClosure { get; }
    protected internal Int32[] PropertyTableNumbersInSelect { get; }
    protected internal Int32[] PropertyTableNumbers { get; }
    public string DiscriminatorColumnName { get; }
    protected string DiscriminatorFormulaTemplate { get; }
    public String[] RootTableKeyColumnNames { get; }
    protected internal SqlCommandInfo[] SQLUpdateByRowIdStrings { get; }
    protected internal SqlCommandInfo[] SQLLazyUpdateByRowIdStrings { get; }
    protected SqlString SQLSnapshotSelectString { get; }
    [ObsoleteAttribute("Use GetSQLLazySelectString method instead")]
protected SqlString SQLLazySelectString { get; }
    protected SqlCommandInfo[] SqlDeleteStrings { get; }
    protected SqlCommandInfo[] SqlInsertStrings { get; }
    protected SqlCommandInfo[] SqlUpdateStrings { get; }
    protected internal SqlCommandInfo[] SQLLazyUpdateStrings { get; }
    protected internal SqlCommandInfo SQLIdentityInsertString { get; }
    protected SqlString VersionSelectString { get; }
    public bool IsBatchable { get; }
    public String[] QuerySpaces { get; }
    protected internal ISet`1<string> LazyProperties { get; }
    public bool IsBatchLoadable { get; }
    public int BatchSize { get; }
    public String[] IdentifierColumnNames { get; }
    protected int IdentifierColumnSpan { get; }
    public string VersionColumnName { get; }
    public IBytecodeEnhancementMetadata InstrumentationMetadata { get; }
    [ObsoleteAttribute("Please use RootTableName instead.")]
protected internal string VersionedTableName { get; }
    protected internal Boolean[] SubclassColumnLaziness { get; }
    protected internal Boolean[] SubclassFormulaLaziness { get; }
    public bool IsCacheInvalidationRequired { get; }
    public bool IsLazyPropertiesCacheable { get; }
    public string RootTableName { get; }
    public String[] RootTableIdentifierColumnNames { get; }
    protected internal String[] PropertySubclassNames { get; }
    protected String[][] SubclassPropertyFormulaTemplateClosure { get; }
    protected IType[] SubclassPropertyTypeClosure { get; }
    protected String[][] SubclassPropertyColumnNameClosure { get; }
    protected String[] SubclassPropertyNameClosure { get; }
    protected String[] SubclassPropertySubclassNameClosure { get; }
    protected String[] SubclassColumnClosure { get; }
    protected String[] SubclassColumnAliasClosure { get; }
    protected String[] SubclassFormulaClosure { get; }
    protected String[] SubclassFormulaTemplateClosure { get; }
    protected String[] SubclassFormulaAliasClosure { get; }
    public string IdentitySelectString { get; }
    private string RootAlias { get; }
    public ISessionFactoryImplementor Factory { get; }
    public EntityMetamodel EntityMetamodel { get; }
    public ICacheConcurrencyStrategy Cache { get; }
    public ICacheEntryStructure CacheEntryStructure { get; }
    public IComparer VersionComparator { get; }
    public string EntityName { get; }
    public EntityType EntityType { get; }
    public bool IsPolymorphic { get; }
    public bool IsInherited { get; }
    public IVersionType VersionType { get; }
    public int VersionProperty { get; }
    public bool IsVersioned { get; }
    public bool IsIdentifierAssignedByInsert { get; }
    public bool IsMutable { get; }
    public bool IsAbstract { get; }
    public IIdentifierGenerator IdentifierGenerator { get; }
    public string RootEntityName { get; }
    public IClassMetadata ClassMetadata { get; }
    public string MappedSuperclass { get; }
    public bool IsExplicitPolymorphism { get; }
    public String[] KeyColumnNames { get; }
    [ObsoleteAttribute("Use KeyColumnNames instead")]
public String[] JoinColumnNames { get; }
    public string Name { get; }
    public bool IsCollection { get; }
    public IType Type { get; }
    public bool IsSelectBeforeUpdateRequired { get; }
    public bool IsVersionPropertyGenerated { get; }
    public bool VersionPropertyInsertable { get; }
    public String[] PropertyNames { get; }
    public IType[] PropertyTypes { get; }
    public Boolean[] PropertyLaziness { get; }
    public Boolean[] PropertyCheckability { get; }
    public Boolean[] NonLazyPropertyUpdateability { get; }
    public Boolean[] PropertyInsertability { get; }
    public ValueInclusion[] PropertyInsertGenerationInclusions { get; }
    public ValueInclusion[] PropertyUpdateGenerationInclusions { get; }
    public Boolean[] PropertyNullability { get; }
    public Boolean[] PropertyVersionability { get; }
    public CascadeStyle[] PropertyCascadeStyles { get; }
    public bool IsMultiTable { get; }
    public string TemporaryIdTableName { get; }
    public string TemporaryIdTableDDL { get; }
    protected int PropertySpan { get; }
    public string IdentifierPropertyName { get; }
    public IType IdentifierType { get; }
    public Int32[] NaturalIdentifierProperties { get; }
    public String[][] ConstraintOrderedTableKeyColumnClosure { get; }
    public IType DiscriminatorType { get; }
    public String[] ConstraintOrderedTableNameClosure { get; }
    public string DiscriminatorSQLValue { get; }
    public object DiscriminatorValue { get; }
    public String[] SubclassClosure { get; }
    public String[] PropertySpaces { get; }
    protected int SubclassTableSpan { get; }
    protected int TableSpan { get; }
    protected internal string DiscriminatorAlias { get; }
    protected Boolean[] TableHasColumns { get; }
    [ObsoleteAttribute("This property has no more usage in NHibernate and will be removed in a future version.")]
public bool HasSequentialSelect { get; }
    public bool HasRowId { get; }
    public String[] IdentifierAliases { get; }
    protected bool HasFormulaProperties { get; }
    protected bool HasWhere { get; }
    public bool HasCache { get; }
    public bool SupportsQueryCache { get; }
    public bool HasCascades { get; }
    public bool HasIdentifierProperty { get; }
    public bool HasLazyProperties { get; }
    public bool HasCollections { get; }
    public bool HasMutableProperties { get; }
    public bool HasSubclasses { get; }
    public bool HasProxy { get; }
    protected bool UseDynamicUpdate { get; }
    protected bool UseDynamicInsert { get; }
    protected bool HasEmbeddedCompositeIdentifier { get; }
    public bool CanExtractIdOutOfEntity { get; }
    protected OptimisticLock OptimisticLockMode { get; }
    public bool IsInstrumented { get; }
    public bool HasInsertGeneratedProperties { get; }
    public bool HasUpdateGeneratedProperties { get; }
    public Boolean[] PropertyUpdateability { get; }
    public Type MappedClass { get; }
    public bool ImplementsLifecycle { get; }
    public bool ImplementsValidatable { get; }
    public Type ConcreteProxyClass { get; }
    public bool HasSubselectLoadableCollections { get; }
    public bool HasNaturalIdentifier { get; }
    public EntityMode EntityMode { get; }
    public IEntityTuplizer EntityTuplizer { get; }
    public string TableName { get; }
    public SqlType[] IdAndVersionSqlTypes { get; }
    protected AbstractEntityPersister(PersistentClass persistentClass, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory);
    private static AbstractEntityPersister();
    public Task InitializeLazyPropertiesAsync(DbDataReader rs, object id, object entity, String[][] suffixedPropertyColumns, String[] uninitializedLazyProperties, bool allLazyProperties, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<GetDatabaseSnapshotAsync>d__2")]
public sealed virtual Task`1<Object[]> GetDatabaseSnapshotAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> ForceVersionIncrementAsync(object id, object currentVersion, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<GetCurrentVersionAsync>d__4")]
public sealed virtual Task`1<object> GetCurrentVersionAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task LockAsync(object id, object version, object obj, LockMode lockMode, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> LoadByUniqueKeyAsync(string propertyName, object uniqueKey, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<CacheByUniqueKeysAsync>d__7")]
public Task CacheByUniqueKeysAsync(object entity, ISessionImplementor session, CancellationToken cancellationToken);
    protected Task`1<int> DehydrateAsync(object id, Object[] fields, Boolean[] includeProperty, Boolean[][] includeColumns, int j, DbCommand st, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<DehydrateAsync>d__9")]
protected Task`1<int> DehydrateAsync(object id, Object[] fields, object rowId, Boolean[] includeProperty, Boolean[][] includeColumns, int table, DbCommand statement, ISessionImplementor session, int index, CancellationToken cancellationToken);
    public Task`1<Object[]> HydrateAsync(DbDataReader rs, object id, object obj, String[][] suffixedPropertyColumns, ISet`1<string> fetchedLazyProperties, bool allProperties, ISessionImplementor session, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use the overload with fetchedLazyProperties parameter instead")]
public sealed virtual Task`1<Object[]> HydrateAsync(DbDataReader rs, object id, object obj, ILoadable rootLoadable, String[][] suffixedPropertyColumns, bool allProperties, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<HydrateAsync>d__12")]
private Task`1<Object[]> HydrateAsync(DbDataReader rs, object id, object obj, String[][] suffixedPropertyColumns, ISet`1<string> fetchedLazyProperties, bool allProperties, Int32[] indexes, ISessionImplementor session, CancellationToken cancellationToken);
    protected Task`1<object> InsertAsync(Object[] fields, Boolean[] notNull, SqlCommandInfo sql, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<BindSelectByUniqueKeyAsync>d__14")]
public sealed virtual Task BindSelectByUniqueKeyAsync(ISessionImplementor session, DbCommand selectCommand, IBinder binder, String[] suppliedPropertyNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<InsertAsync>d__15")]
protected Task InsertAsync(object id, Object[] fields, Boolean[] notNull, int j, SqlCommandInfo sql, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<UpdateOrInsertAsync>d__16")]
protected internal virtual Task UpdateOrInsertAsync(object id, Object[] fields, Object[] oldFields, object rowId, Boolean[] includeProperty, int j, object oldVersion, object obj, SqlCommandInfo sql, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<UpdateAsync>d__17")]
protected Task`1<bool> UpdateAsync(object id, Object[] fields, Object[] oldFields, object rowId, Boolean[] includeProperty, int j, object oldVersion, object obj, SqlCommandInfo sql, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<DeleteAsync>d__18")]
public Task DeleteAsync(object id, object version, int j, object obj, SqlCommandInfo sql, ISessionImplementor session, Object[] loadedState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<UpdateAsync>d__19")]
public sealed virtual Task UpdateAsync(object id, Object[] fields, Int32[] dirtyFields, bool hasDirtyCollection, Object[] oldFields, object oldVersion, object obj, object rowId, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<InsertAsync>d__20")]
public sealed virtual Task`1<object> InsertAsync(Object[] fields, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<InsertAsync>d__21")]
public sealed virtual Task InsertAsync(object id, Object[] fields, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<DeleteAsync>d__22")]
public sealed virtual Task DeleteAsync(object id, object version, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> LoadAsync(object id, object optionalObject, LockMode lockMode, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<FindDirtyAsync>d__24")]
public virtual Task`1<Int32[]> FindDirtyAsync(Object[] currentState, Object[] previousState, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<FindModifiedAsync>d__25")]
public virtual Task`1<Int32[]> FindModifiedAsync(Object[] old, Object[] current, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<IsTransientAsync>d__26")]
public virtual Task`1<Nullable`1<bool>> IsTransientAsync(object entity, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task ProcessInsertGeneratedPropertiesAsync(object id, object entity, Object[] state, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task ProcessUpdateGeneratedPropertiesAsync(object id, object entity, Object[] state, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.AbstractEntityPersister/<ProcessGeneratedPropertiesWithGeneratedSqlAsync>d__29")]
private Task ProcessGeneratedPropertiesWithGeneratedSqlAsync(object id, object entity, Object[] state, ISessionImplementor session, SqlString selectionSQL, ValueInclusion[] generationInclusions, CancellationToken cancellationToken);
    private Task ProcessGeneratedPropertiesWithLoaderAsync(object id, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<Object[]> GetNaturalIdentifierSnapshotAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    protected abstract virtual Int32[] get_SubclassColumnTableNumberClosure();
    protected abstract virtual Int32[] get_SubclassFormulaTableNumberClosure();
    protected internal abstract virtual Int32[] get_PropertyTableNumbersInSelect();
    protected internal abstract virtual Int32[] get_PropertyTableNumbers();
    public virtual string get_DiscriminatorColumnName();
    protected virtual string get_DiscriminatorFormulaTemplate();
    public sealed virtual String[] get_RootTableKeyColumnNames();
    protected internal SqlCommandInfo[] get_SQLUpdateByRowIdStrings();
    protected internal SqlCommandInfo[] get_SQLLazyUpdateByRowIdStrings();
    protected SqlString get_SQLSnapshotSelectString();
    protected SqlString get_SQLLazySelectString();
    protected SqlString GetSQLLazySelectString(string fetchGroup);
    protected SqlCommandInfo[] get_SqlDeleteStrings();
    protected SqlCommandInfo[] get_SqlInsertStrings();
    protected SqlCommandInfo[] get_SqlUpdateStrings();
    protected internal SqlCommandInfo[] get_SQLLazyUpdateStrings();
    protected internal SqlCommandInfo get_SQLIdentityInsertString();
    protected SqlString get_VersionSelectString();
    public bool get_IsBatchable();
    public virtual String[] get_QuerySpaces();
    protected internal ISet`1<string> get_LazyProperties();
    public sealed virtual bool get_IsBatchLoadable();
    public int get_BatchSize();
    public virtual String[] get_IdentifierColumnNames();
    protected int get_IdentifierColumnSpan();
    public virtual string get_VersionColumnName();
    public IBytecodeEnhancementMetadata get_InstrumentationMetadata();
    protected internal string get_VersionedTableName();
    protected internal Boolean[] get_SubclassColumnLaziness();
    protected internal Boolean[] get_SubclassFormulaLaziness();
    public sealed virtual bool get_IsCacheInvalidationRequired();
    public sealed virtual bool get_IsLazyPropertiesCacheable();
    public virtual string get_RootTableName();
    public virtual String[] get_RootTableIdentifierColumnNames();
    protected internal String[] get_PropertySubclassNames();
    protected String[][] get_SubclassPropertyFormulaTemplateClosure();
    protected IType[] get_SubclassPropertyTypeClosure();
    protected String[][] get_SubclassPropertyColumnNameClosure();
    protected String[] get_SubclassPropertyNameClosure();
    protected String[] get_SubclassPropertySubclassNameClosure();
    protected String[] get_SubclassColumnClosure();
    protected String[] get_SubclassColumnAliasClosure();
    protected String[] get_SubclassFormulaClosure();
    protected String[] get_SubclassFormulaTemplateClosure();
    protected String[] get_SubclassFormulaAliasClosure();
    public sealed virtual string get_IdentitySelectString();
    private string get_RootAlias();
    public sealed virtual ISessionFactoryImplementor get_Factory();
    public sealed virtual EntityMetamodel get_EntityMetamodel();
    public sealed virtual ICacheConcurrencyStrategy get_Cache();
    public sealed virtual ICacheEntryStructure get_CacheEntryStructure();
    public sealed virtual IComparer get_VersionComparator();
    public sealed virtual string get_EntityName();
    public sealed virtual EntityType get_EntityType();
    public virtual bool get_IsPolymorphic();
    public virtual bool get_IsInherited();
    public virtual IVersionType get_VersionType();
    public virtual int get_VersionProperty();
    public virtual bool get_IsVersioned();
    public virtual bool get_IsIdentifierAssignedByInsert();
    public virtual bool get_IsMutable();
    public virtual bool get_IsAbstract();
    public virtual IIdentifierGenerator get_IdentifierGenerator();
    public virtual string get_RootEntityName();
    public virtual IClassMetadata get_ClassMetadata();
    public virtual string get_MappedSuperclass();
    public virtual bool get_IsExplicitPolymorphism();
    public sealed virtual String[] get_KeyColumnNames();
    public sealed virtual String[] get_JoinColumnNames();
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsCollection();
    public sealed virtual IType get_Type();
    public sealed virtual bool get_IsSelectBeforeUpdateRequired();
    public sealed virtual bool get_IsVersionPropertyGenerated();
    public sealed virtual bool get_VersionPropertyInsertable();
    public virtual String[] get_PropertyNames();
    public virtual IType[] get_PropertyTypes();
    public sealed virtual Boolean[] get_PropertyLaziness();
    public virtual Boolean[] get_PropertyCheckability();
    public Boolean[] get_NonLazyPropertyUpdateability();
    public virtual Boolean[] get_PropertyInsertability();
    public sealed virtual ValueInclusion[] get_PropertyInsertGenerationInclusions();
    public sealed virtual ValueInclusion[] get_PropertyUpdateGenerationInclusions();
    public virtual Boolean[] get_PropertyNullability();
    public virtual Boolean[] get_PropertyVersionability();
    public virtual CascadeStyle[] get_PropertyCascadeStyles();
    public virtual bool get_IsMultiTable();
    public sealed virtual string get_TemporaryIdTableName();
    public sealed virtual string get_TemporaryIdTableDDL();
    protected int get_PropertySpan();
    public virtual string get_IdentifierPropertyName();
    public virtual IType GetIdentifierType(int j);
    public virtual IType get_IdentifierType();
    public sealed virtual Int32[] get_NaturalIdentifierProperties();
    public abstract virtual String[][] get_ConstraintOrderedTableKeyColumnClosure();
    public abstract virtual IType get_DiscriminatorType();
    public abstract virtual String[] get_ConstraintOrderedTableNameClosure();
    public abstract virtual string get_DiscriminatorSQLValue();
    public abstract virtual object get_DiscriminatorValue();
    public abstract virtual String[] get_SubclassClosure();
    public abstract virtual String[] get_PropertySpaces();
    protected virtual void AddDiscriminatorToInsert(SqlInsertBuilder insert);
    protected virtual void AddDiscriminatorToSelect(SelectFragment select, string name, string suffix);
    public abstract virtual string GetSubclassTableName(int j);
    protected virtual object GetJoinTableId(int j, Object[] fields);
    protected virtual object GetJoinTableId(int table, object obj);
    protected virtual String[] GetJoinIdKeyColumns(int j);
    protected abstract virtual String[] GetSubclassTableKeyColumns(int j);
    protected abstract virtual bool IsClassOrSuperclassTable(int j);
    protected abstract virtual int get_SubclassTableSpan();
    protected abstract virtual int get_TableSpan();
    protected abstract virtual bool IsTableCascadeDeleteEnabled(int j);
    protected abstract virtual string GetTableName(int table);
    protected abstract virtual String[] GetKeyColumns(int table);
    protected abstract virtual bool IsPropertyOfTable(int property, int table);
    protected virtual Nullable`1<int> GetRefIdColumnOfTable(int table);
    protected virtual Property GetIdentiferProperty(int table);
    protected virtual bool IsIdOfTable(int property, int table);
    protected abstract virtual int GetSubclassPropertyTableNumber(int i);
    internal int GetSubclassJoinPropertyTableNumber(string propertyName, string entityName);
    public abstract virtual string FilterFragment(string alias);
    protected internal virtual string get_DiscriminatorAlias();
    protected virtual bool IsInverseTable(int j);
    protected virtual bool IsNullableTable(int j);
    protected virtual bool IsNullableSubclassTable(int j);
    protected virtual bool IsInverseSubclassTable(int j);
    public virtual bool IsSubclassEntityName(string entityName);
    protected Boolean[] get_TableHasColumns();
    protected bool IsInsertCallable(int j);
    protected bool IsUpdateCallable(int j);
    protected bool IsDeleteCallable(int j);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
protected virtual bool IsSubclassPropertyDeferred(string propertyName, string entityName);
    protected virtual bool IsPropertyDeferred(int propertyIndex);
    protected virtual bool IsSubclassTableSequentialSelect(int table);
    public virtual bool get_HasSequentialSelect();
    protected virtual Boolean[] GetTableUpdateNeeded(Int32[] dirtyProperties, bool hasDirtyCollection);
    public virtual bool get_HasRowId();
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
protected internal virtual SqlString GenerateLazySelectString();
    protected virtual IDictionary`2<string, SqlString> GenerateLazySelectStringsByFetchGroup();
    public virtual object InitializeLazyProperty(string fieldName, object entity, ISessionImplementor session);
    public void InitializeLazyProperties(DbDataReader rs, object id, object entity, String[][] suffixedPropertyColumns, String[] uninitializedLazyProperties, bool allLazyProperties, ISessionImplementor session);
    private object InitializeLazyPropertiesFromDatastore(string fieldName, object entity, ISessionImplementor session, object id, EntityEntry entry, ISet`1<string> uninitializedLazyProperties);
    private object InitializeLazyPropertiesFromCache(string fieldName, object entity, ISessionImplementor session, EntityEntry entry, CacheEntry cacheEntry, ISet`1<string> uninitializedLazyProperties);
    private bool InitializeLazyProperty(string fieldName, object entity, Object[] snapshot, int lazyIndex, object propValue, ISet`1<string> uninitializedLazyProperties);
    private void InitializeLazyProperty(object entity, Object[] snapshot, int lazyIndex, object propValue, ISet`1<string> uninitializedLazyProperties);
    public String[] get_IdentifierAliases();
    public sealed virtual string SelectFragment(string alias, string suffix);
    public string SelectFragment(string alias, string suffix, bool fetchLazyProperties);
    public sealed virtual String[] GetIdentifierAliases(string suffix);
    public sealed virtual String[] GetPropertyAliases(string suffix, int i);
    public sealed virtual string GetDiscriminatorAlias(string suffix);
    [ObsoleteAttribute("Use GetIdentifierSelectFragment method instead.")]
public virtual string IdentifierSelectFragment(string name, string suffix);
    public virtual SelectFragment GetIdentifierSelectFragment(string alias, string suffix);
    [ObsoleteAttribute("Use GetPropertiesSelectFragment method instead.")]
public sealed virtual string PropertySelectFragment(string name, string suffix, bool allProperties);
    public SelectFragment GetPropertiesSelectFragment(string alias, string suffix, bool allProperties);
    [ObsoleteAttribute("Use GetPropertiesSelectFragment method instead.")]
public string PropertySelectFragment(string name, string suffix, ICollection`1<string> fetchProperties);
    public SelectFragment GetPropertiesSelectFragment(string alias, string suffix, ICollection`1<string> fetchProperties);
    private SelectFragment GetPropertiesSelectFragment(string alias, string suffix, ICollection`1<string> fetchProperties, bool allProperties);
    public sealed virtual Object[] GetDatabaseSnapshot(object id, ISessionImplementor session);
    protected SqlString GenerateSelectVersionString();
    protected SqlString GenerateInsertGeneratedValuesSelectString();
    protected SqlString GenerateUpdateGeneratedValuesSelectString();
    private SqlString GenerateGeneratedValuesSelectString(ValueInclusion[] inclusions);
    protected string ConcretePropertySelectFragment(string alias, ValueInclusion[] inclusions);
    protected string ConcretePropertySelectFragment(string alias, Boolean[] includeProperty);
    protected string ConcretePropertySelectFragment(string alias, IInclusionChecker inclusionChecker);
    protected virtual SqlString GenerateSnapshotSelectString();
    public sealed virtual object ForceVersionIncrement(object id, object currentVersion, ISessionImplementor session);
    private SqlCommandInfo GenerateVersionIncrementUpdateString();
    public sealed virtual object GetCurrentVersion(object id, ISessionImplementor session);
    protected internal virtual void InitLockers();
    protected internal virtual ILockingStrategy GenerateLocker(LockMode lockMode);
    private ILockingStrategy GetLocker(LockMode lockMode);
    public virtual void Lock(object id, object version, object obj, LockMode lockMode, ISessionImplementor session);
    public virtual string GetRootTableAlias(string drivingAlias);
    public virtual String[] ToColumns(string alias, string propertyName);
    public sealed virtual String[] ToColumns(string propertyName);
    public sealed virtual IType ToType(string propertyName);
    public sealed virtual bool TryToType(string propertyName, IType& type);
    public sealed virtual String[] GetPropertyColumnNames(string propertyName);
    public virtual int GetSubclassPropertyTableNumber(string propertyPath);
    public virtual Declarer GetSubclassPropertyDeclarer(string propertyPath);
    public virtual string GenerateTableAliasForColumn(string rootAlias, string column);
    private int GetColumnTableNumber(string column);
    public string GenerateTableAlias(string rootAlias, int tableNumber);
    private string GetSubclassAliasedColumn(string rootAlias, int tableNumber, string columnName);
    public sealed virtual String[] ToColumns(string name, int i);
    public sealed virtual String[] ToIdentifierColumns(string name);
    private int GetSubclassPropertyIndex(string propertyName);
    public sealed virtual String[] GetPropertyColumnNames(int i);
    protected int GetPropertyColumnSpan(int i);
    protected bool get_HasFormulaProperties();
    public sealed virtual FetchMode GetFetchMode(int i);
    public sealed virtual CascadeStyle GetCascadeStyle(int i);
    public sealed virtual IType GetSubclassPropertyType(int i);
    public sealed virtual string GetSubclassPropertyName(int i);
    public sealed virtual int CountSubclassProperties();
    public sealed virtual String[] GetSubclassPropertyColumnNames(int i);
    public sealed virtual bool IsDefinedOnSubclass(int i);
    public sealed virtual String[] GetSubclassPropertyColumnAliases(string propertyName, string suffix);
    public sealed virtual String[] GetSubclassPropertyColumnNames(string propertyName);
    protected void InitSubclassPropertyAliasesMap(PersistentClass model);
    private void InternalInitSubclassPropertyAliasesMap(string path, IEnumerable`1<Property> col);
    public sealed virtual object LoadByUniqueKey(string propertyName, object uniqueKey, ISessionImplementor session);
    public void CacheByUniqueKeys(object entity, ISessionImplementor session);
    private EntityLoader GetAppropriateUniqueKeyLoader(string propertyName, IDictionary`2<string, IFilter> enabledFilters);
    public sealed virtual int GetPropertyIndex(string propertyName);
    protected void CreateUniqueKeyLoaders();
    private EntityLoader CreateUniqueKeyLoader(IType uniqueKeyType, String[] columns, IDictionary`2<string, IFilter> enabledFilters);
    protected string GetSQLWhereString(string alias);
    protected bool get_HasWhere();
    private void InitOrdinaryPropertyPaths(IMapping mapping);
    private void InitIdentifierPropertyPaths(IMapping mapping);
    private void InitDiscriminatorPropertyPath();
    private void InitPropertyPaths(IMapping mapping);
    protected IUniqueEntityLoader CreateEntityLoader(LockMode lockMode, IDictionary`2<string, IFilter> enabledFilters);
    protected IUniqueEntityLoader CreateEntityLoader(LockMode lockMode);
    protected bool Check(int rows, object id, int tableNumber, IExpectation expectation, DbCommand statement);
    protected bool Check(int rows, object id, int tableNumber, IExpectation expectation, DbCommand statement, bool forceThrowStaleException);
    protected virtual SqlCommandInfo GenerateUpdateString(Boolean[] includeProperty, int j, bool useRowId);
    protected internal SqlCommandInfo GenerateUpdateString(Boolean[] includeProperty, int j, Object[] oldFields, bool useRowId);
    private bool IsPropertyBasedOptimisticLocking(Object[] oldFields);
    private bool CheckVersion(Boolean[] includeProperty);
    protected SqlCommandInfo GenerateInsertString(Boolean[] includeProperty, int j);
    protected SqlCommandInfo GenerateInsertString(bool identityInsert, Boolean[] includeProperty);
    protected virtual SqlCommandInfo GenerateInsertString(bool identityInsert, Boolean[] includeProperty, int j);
    protected virtual SqlCommandInfo GenerateIdentityInsertString(Boolean[] includeProperty);
    protected virtual SqlCommandInfo GenerateDeleteString(int j);
    protected int Dehydrate(object id, Object[] fields, Boolean[] includeProperty, Boolean[][] includeColumns, int j, DbCommand st, ISessionImplementor session);
    protected int Dehydrate(object id, Object[] fields, object rowId, Boolean[] includeProperty, Boolean[][] includeColumns, int table, DbCommand statement, ISessionImplementor session, int index);
    public Object[] Hydrate(DbDataReader rs, object id, object obj, String[][] suffixedPropertyColumns, ISet`1<string> fetchedLazyProperties, bool allProperties, ISessionImplementor session);
    [ObsoleteAttribute("Use the overload with fetchedLazyProperties parameter instead")]
public sealed virtual Object[] Hydrate(DbDataReader rs, object id, object obj, ILoadable rootLoadable, String[][] suffixedPropertyColumns, bool allProperties, ISessionImplementor session);
    private Object[] Hydrate(DbDataReader rs, object id, object obj, String[][] suffixedPropertyColumns, ISet`1<string> fetchedLazyProperties, bool allProperties, Int32[] indexes, ISessionImplementor session);
    protected bool UseInsertSelectIdentity();
    protected bool UseGetGeneratedKeys();
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
protected virtual SqlString GetSequentialSelect(string entityName);
    protected virtual SqlString GetSequentialSelect();
    protected object Insert(Object[] fields, Boolean[] notNull, SqlCommandInfo sql, object obj, ISessionImplementor session);
    [ObsoleteAttribute("Use GetSelectByUniqueKeyString(string[] suppliedPropertyNames, out IType[] parameterTypes) instead.")]
public virtual SqlString GetSelectByUniqueKeyString(string propertyName);
    public virtual SqlString GetSelectByUniqueKeyString(String[] suppliedPropertyNames, IType[]& parameterTypes);
    public sealed virtual void BindSelectByUniqueKey(ISessionImplementor session, DbCommand selectCommand, IBinder binder, String[] suppliedPropertyNames);
    private String[] GetUniqueKeyPropertyNames(String[] suppliedPropertyNames);
    protected void Insert(object id, Object[] fields, Boolean[] notNull, int j, SqlCommandInfo sql, object obj, ISessionImplementor session);
    protected internal virtual void UpdateOrInsert(object id, Object[] fields, Object[] oldFields, object rowId, Boolean[] includeProperty, int j, object oldVersion, object obj, SqlCommandInfo sql, ISessionImplementor session);
    protected bool Update(object id, Object[] fields, Object[] oldFields, object rowId, Boolean[] includeProperty, int j, object oldVersion, object obj, SqlCommandInfo sql, ISessionImplementor session);
    public void Delete(object id, object version, int j, object obj, SqlCommandInfo sql, ISessionImplementor session, Object[] loadedState);
    private SqlCommandInfo[] GetUpdateStrings(bool byRowId, bool lazy);
    public sealed virtual void Update(object id, Object[] fields, Int32[] dirtyFields, bool hasDirtyCollection, Object[] oldFields, object oldVersion, object obj, object rowId, ISessionImplementor session);
    private bool HasDirtyLazyProperties(Int32[] dirtyFields, object obj);
    public sealed virtual object Insert(Object[] fields, object obj, ISessionImplementor session);
    public sealed virtual void Insert(object id, Object[] fields, object obj, ISessionImplementor session);
    public sealed virtual void Delete(object id, object version, object obj, ISessionImplementor session);
    protected SqlCommandInfo[] GenerateSQLDeleteStrings(Object[] loadedState);
    protected void LogStaticSQL();
    public virtual string FilterFragment(string alias, IDictionary`2<string, IFilter> enabledFilters);
    public virtual string FilterFragment(FilterHelper filterHelper, string alias, IDictionary`2<string, IFilter> enabledFilters, string filterFragment);
    private IDictionary`2<string, string> GetColumnsToTableAliasMap(string rootAlias);
    public virtual string GenerateFilterConditionAlias(string rootAlias);
    public virtual string OneToManyFilterFragment(string alias);
    public virtual SqlString FromJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    public virtual SqlString WhereJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    protected internal virtual bool IsSubclassTableLazy(int j);
    private JoinFragment CreateJoin(string name, bool innerjoin, bool includeSubclasses);
    internal bool ColumnsDependOnSubclassJoins(String[] columns);
    internal bool HasSubclassJoins(bool includeSubclasses);
    private bool IsJoinIncluded(bool includeSubclasses, int j);
    private JoinFragment CreateJoin(Int32[] tableNumbers, string drivingAlias);
    protected SelectFragment CreateSelect(Int32[] subclassColumnNumbers, Int32[] subclassFormulaNumbers);
    protected string CreateFrom(int tableNumber, string alias);
    protected SqlString CreateWhereByKey(int tableNumber, string alias);
    protected SqlString RenderSelect(Int32[] tableNumbers, Int32[] columnNumbers, Int32[] formulaNumbers);
    protected void PostConstruct(IMapping mapping);
    public virtual void PostInstantiate();
    private void CreateLoaders();
    protected void CreateQueryLoader();
    public sealed virtual object Load(object id, object optionalObject, LockMode lockMode, ISessionImplementor session);
    private IUniqueEntityLoader GetAppropriateLoader(LockMode lockMode, ISessionImplementor session);
    private bool IsAllNull(Object[] array, int tableNumber);
    public sealed virtual bool IsSubclassPropertyNullable(int i);
    protected virtual Boolean[] GetPropertiesToUpdate(Int32[] dirtyProperties, bool hasDirtyCollection);
    protected Boolean[] GetPropertiesToInsert(Object[] fields);
    public virtual Int32[] FindDirty(Object[] currentState, Object[] previousState, object entity, ISessionImplementor session);
    public virtual Int32[] FindModified(Object[] old, Object[] current, object entity, ISessionImplementor session);
    protected Boolean[] GetPropertyUpdateability(object entity);
    private void LogDirtyProperties(Int32[] props);
    protected internal IEntityTuplizer GetTuplizer(ISessionImplementor session);
    public virtual bool get_HasCache();
    public sealed virtual bool get_SupportsQueryCache();
    private string GetSubclassEntityName(Type clazz);
    public virtual bool get_HasCascades();
    public virtual bool get_HasIdentifierProperty();
    private IVersionType LocateVersionType();
    public virtual bool get_HasLazyProperties();
    public virtual void AfterReassociate(object entity, ISessionImplementor session);
    public virtual Nullable`1<bool> IsTransient(object entity, ISessionImplementor session);
    public virtual bool IsModifiableEntity(EntityEntry entry);
    public virtual bool get_HasCollections();
    public virtual bool get_HasMutableProperties();
    public virtual bool get_HasSubclasses();
    public virtual bool get_HasProxy();
    protected virtual bool get_UseDynamicUpdate();
    protected virtual bool get_UseDynamicInsert();
    protected virtual bool get_HasEmbeddedCompositeIdentifier();
    public virtual bool get_CanExtractIdOutOfEntity();
    private bool HasIdentifierMapper();
    public sealed virtual bool ConsumesEntityAlias();
    public sealed virtual bool ConsumesCollectionAlias();
    public virtual IType GetPropertyType(string path);
    protected OptimisticLock get_OptimisticLockMode();
    public sealed virtual object CreateProxy(object id, ISessionImplementor session);
    public virtual string ToString();
    [ObsoleteAttribute("Use overload taking entityInfo parameter")]
public sealed virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string entitySuffix, string collectionSuffix, bool includeCollectionColumns);
    [ObsoleteAttribute("Use overload taking entityInfo parameter")]
public sealed virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string entitySuffix, string collectionSuffix, bool includeCollectionColumns, bool includeLazyProperties);
    [ObsoleteAttribute("Please use overload without rhs and rhsAlias parameters")]
public string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string collectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
    public sealed virtual string SelectFragment(string lhsAlias, string collectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
    public sealed virtual bool get_IsInstrumented();
    public sealed virtual bool get_HasInsertGeneratedProperties();
    public sealed virtual bool get_HasUpdateGeneratedProperties();
    [ObsoleteAttribute("Use overload without lazyPropertiesAreUnfetched parameter")]
public sealed virtual void AfterInitialize(object entity, bool lazyPropertiesAreUnfetched, ISessionImplementor session);
    public void AfterInitialize(object entity, ISessionImplementor session);
    public virtual Boolean[] get_PropertyUpdateability();
    public sealed virtual Type get_MappedClass();
    public sealed virtual bool get_ImplementsLifecycle();
    public sealed virtual bool get_ImplementsValidatable();
    public sealed virtual Type get_ConcreteProxyClass();
    public sealed virtual void SetPropertyValues(object obj, Object[] values);
    public sealed virtual void SetPropertyValue(object obj, int i, object value);
    public sealed virtual Object[] GetPropertyValues(object obj);
    public sealed virtual object GetPropertyValue(object obj, int i);
    public sealed virtual object GetPropertyValue(object obj, string propertyName);
    public virtual object GetIdentifier(object obj);
    public virtual void SetIdentifier(object obj, object id);
    public virtual object GetVersion(object obj);
    public virtual object Instantiate(object id);
    public sealed virtual bool IsInstance(object entity);
    public virtual bool HasUninitializedLazyProperties(object obj);
    public virtual void ResetIdentifier(object entity, object currentId, object currentVersion);
    public sealed virtual IEntityPersister GetSubclassEntityPersister(object instance, ISessionFactoryImplementor factory);
    public virtual Object[] GetPropertyValuesToInsert(object obj, IDictionary mergeMap, ISessionImplementor session);
    public sealed virtual void ProcessInsertGeneratedProperties(object id, object entity, Object[] state, ISessionImplementor session);
    public sealed virtual void ProcessUpdateGeneratedProperties(object id, object entity, Object[] state, ISessionImplementor session);
    private void ProcessGeneratedPropertiesWithGeneratedSql(object id, object entity, Object[] state, ISessionImplementor session, SqlString selectionSQL, ValueInclusion[] generationInclusions);
    private void ProcessGeneratedPropertiesWithLoader(object id, object entity, ISessionImplementor session);
    public sealed virtual bool get_HasSubselectLoadableCollections();
    public virtual Object[] GetNaturalIdentifierSnapshot(object id, ISessionImplementor session);
    protected string ConcretePropertySelectFragmentSansLeadingComma(string alias, Boolean[] include);
    public virtual bool get_HasNaturalIdentifier();
    public virtual void SetPropertyValue(object obj, string propertyName, object value);
    public sealed virtual EntityMode get_EntityMode();
    public sealed virtual IEntityTuplizer get_EntityTuplizer();
    public abstract virtual string GetPropertyTableName(string propertyName);
    public abstract virtual string FromTableFragment(string alias);
    public abstract virtual string GetSubclassForDiscriminatorValue(object value);
    public abstract virtual string GetSubclassPropertyTableName(int i);
    public abstract virtual string get_TableName();
    public sealed virtual Nullable`1<bool> IsUnsavedVersion(object version);
    public virtual SqlType[] get_IdAndVersionSqlTypes();
    public sealed virtual string GetInfoString();
    internal SqlString GenerateSequentialSelect(AbstractEntityPersister subclassPersister);
    [CompilerGeneratedAttribute]
private IType <BindSelectByUniqueKeyAsync>b__14_0(string p);
    [CompilerGeneratedAttribute]
private String[] <.ctor>b__126_0();
    [CompilerGeneratedAttribute]
private IType <GetSelectByUniqueKeyString>b__474_0(string p);
    [CompilerGeneratedAttribute]
private IType <BindSelectByUniqueKey>b__475_0(string p);
    [CompilerGeneratedAttribute]
private bool <HasDirtyLazyProperties>b__483_0(int i);
}
[ExtensionAttribute]
public static class NHibernate.Persister.Entity.AbstractEntityPersisterExtensions : object {
    [ExtensionAttribute]
internal static SelectFragment GetPropertiesSelectFragment(IQueryable query, string alias, string suffix, ICollection`1<string> fetchProperties);
    [ExtensionAttribute]
public static SelectFragment GetIdentifierSelectFragment(IQueryable queryable, string alias, string suffix);
    [ExtensionAttribute]
public static SelectFragment GetPropertiesSelectFragment(IQueryable queryable, string alias, string suffix, bool allProperties);
}
public abstract class NHibernate.Persister.Entity.AbstractPropertyMapping : object {
    private Dictionary`2<string, IType> typesByPropertyPath;
    private Dictionary`2<string, String[]> columnsByPropertyPath;
    private Dictionary`2<string, String[]> formulaTemplatesByPropertyPath;
    public String[] IdentifierColumnNames { get; }
    protected string EntityName { get; }
    public IType Type { get; }
    public virtual String[] get_IdentifierColumnNames();
    protected abstract virtual string get_EntityName();
    protected QueryException PropertyException(string propertyName);
    public sealed virtual IType ToType(string propertyName);
    public sealed virtual bool TryToType(string propertyName, IType& type);
    public virtual String[] ToColumns(string alias, string propertyName);
    private String[] GetColumns(string propertyName);
    public virtual String[] ToColumns(string propertyName);
    public abstract virtual IType get_Type();
    protected void AddPropertyPath(string path, IType type, String[] columns, String[] formulaTemplates);
    protected internal void InitPropertyPaths(string path, IType type, String[] columns, String[] formulaTemplates, IMapping factory);
    protected void InitIdentifierPropertyPaths(string path, EntityType etype, String[] columns, IMapping factory);
    private bool HasNonIdentifierPropertyNamedId(EntityType entityType, IMapping factory);
    protected void InitComponentPropertyPaths(string path, IAbstractComponentType type, String[] columns, String[] formulaTemplates, IMapping factory);
    private static string ExtendPath(string path, string property);
    public String[] GetColumnNames(string propertyName);
}
public class NHibernate.Persister.Entity.BasicEntityPropertyMapping : AbstractPropertyMapping {
    private AbstractEntityPersister persister;
    public String[] IdentifierColumnNames { get; }
    protected string EntityName { get; }
    public IType Type { get; }
    public BasicEntityPropertyMapping(AbstractEntityPersister persister);
    public virtual String[] get_IdentifierColumnNames();
    protected virtual string get_EntityName();
    public virtual IType get_Type();
    public virtual String[] ToColumns(string alias, string propertyName);
}
public enum NHibernate.Persister.Entity.Declarer : Enum {
    public int value__;
    public static Declarer Class;
    public static Declarer SubClass;
    public static Declarer SuperClass;
}
public class NHibernate.Persister.Entity.EntityLoadInfo : object {
    [CompilerGeneratedAttribute]
private bool <IncludeLazyProps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntitySuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <LazyProperties>k__BackingField;
    public bool IncludeLazyProps { get; public set; }
    public string EntitySuffix { get; }
    public ISet`1<string> LazyProperties { get; public set; }
    public EntityLoadInfo(string entitySuffix);
    [CompilerGeneratedAttribute]
public bool get_IncludeLazyProps();
    [CompilerGeneratedAttribute]
public void set_IncludeLazyProps(bool value);
    [CompilerGeneratedAttribute]
public string get_EntitySuffix();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_LazyProperties();
    [CompilerGeneratedAttribute]
public void set_LazyProperties(ISet`1<string> value);
}
public class NHibernate.Persister.Entity.EntityPersister : ValueType {
    public static string EntityID;
    private static EntityPersister();
}
[ExtensionAttribute]
internal static class NHibernate.Persister.Entity.EntityPersisterExtensions : object {
    [ExtensionAttribute]
public static int GetBatchSize(IEntityPersister persister);
    [ExtensionAttribute]
public static void AfterInitialize(IEntityPersister persister, object entity, ISessionImplementor session);
    [ExtensionAttribute]
internal static bool SupportsQueryCache(IEntityPersister persister);
}
public interface NHibernate.Persister.Entity.IEntityPersister {
    public ISessionFactoryImplementor Factory { get; }
    public string RootEntityName { get; }
    public string EntityName { get; }
    public EntityMetamodel EntityMetamodel { get; }
    public String[] PropertySpaces { get; }
    public String[] QuerySpaces { get; }
    public bool IsMutable { get; }
    public bool IsInherited { get; }
    public bool IsIdentifierAssignedByInsert { get; }
    public bool IsVersioned { get; }
    public IVersionType VersionType { get; }
    public int VersionProperty { get; }
    public Int32[] NaturalIdentifierProperties { get; }
    public IIdentifierGenerator IdentifierGenerator { get; }
    public IType[] PropertyTypes { get; }
    public String[] PropertyNames { get; }
    public Boolean[] PropertyInsertability { get; }
    public ValueInclusion[] PropertyInsertGenerationInclusions { get; }
    public ValueInclusion[] PropertyUpdateGenerationInclusions { get; }
    public Boolean[] PropertyCheckability { get; }
    public Boolean[] PropertyNullability { get; }
    public Boolean[] PropertyVersionability { get; }
    public Boolean[] PropertyLaziness { get; }
    public CascadeStyle[] PropertyCascadeStyles { get; }
    public IType IdentifierType { get; }
    public string IdentifierPropertyName { get; }
    public bool IsCacheInvalidationRequired { get; }
    public bool IsLazyPropertiesCacheable { get; }
    public ICacheConcurrencyStrategy Cache { get; }
    public ICacheEntryStructure CacheEntryStructure { get; }
    public IClassMetadata ClassMetadata { get; }
    public bool IsBatchLoadable { get; }
    public bool IsSelectBeforeUpdateRequired { get; }
    public bool IsVersionPropertyGenerated { get; }
    public bool HasProxy { get; }
    public bool HasCollections { get; }
    public bool HasMutableProperties { get; }
    public bool HasSubselectLoadableCollections { get; }
    public bool HasCascades { get; }
    public bool HasIdentifierProperty { get; }
    public bool CanExtractIdOutOfEntity { get; }
    public bool HasNaturalIdentifier { get; }
    public bool HasLazyProperties { get; }
    public Boolean[] PropertyUpdateability { get; }
    public bool HasCache { get; }
    public bool IsInstrumented { get; }
    public bool HasInsertGeneratedProperties { get; }
    public bool HasUpdateGeneratedProperties { get; }
    public Type MappedClass { get; }
    public bool ImplementsLifecycle { get; }
    public bool ImplementsValidatable { get; }
    public Type ConcreteProxyClass { get; }
    public EntityMode EntityMode { get; }
    public IEntityTuplizer EntityTuplizer { get; }
    public abstract virtual Task`1<Int32[]> FindDirtyAsync(Object[] currentState, Object[] previousState, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<Int32[]> FindModifiedAsync(Object[] old, Object[] current, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<Object[]> GetNaturalIdentifierSnapshotAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> LoadAsync(object id, object optionalObject, LockMode lockMode, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task LockAsync(object id, object version, object obj, LockMode lockMode, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task InsertAsync(object id, Object[] fields, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> InsertAsync(Object[] fields, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(object id, object version, object obj, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task UpdateAsync(object id, Object[] fields, Int32[] dirtyFields, bool hasDirtyCollection, Object[] oldFields, object oldVersion, object obj, object rowId, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<Object[]> GetDatabaseSnapshotAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetCurrentVersionAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ForceVersionIncrementAsync(object id, object currentVersion, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<bool>> IsTransientAsync(object obj, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task ProcessInsertGeneratedPropertiesAsync(object id, object entity, Object[] state, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task ProcessUpdateGeneratedPropertiesAsync(object id, object entity, Object[] state, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual ISessionFactoryImplementor get_Factory();
    public abstract virtual string get_RootEntityName();
    public abstract virtual string get_EntityName();
    public abstract virtual EntityMetamodel get_EntityMetamodel();
    public abstract virtual String[] get_PropertySpaces();
    public abstract virtual String[] get_QuerySpaces();
    public abstract virtual bool get_IsMutable();
    public abstract virtual bool get_IsInherited();
    public abstract virtual bool get_IsIdentifierAssignedByInsert();
    public abstract virtual bool get_IsVersioned();
    public abstract virtual IVersionType get_VersionType();
    public abstract virtual int get_VersionProperty();
    public abstract virtual Int32[] get_NaturalIdentifierProperties();
    public abstract virtual IIdentifierGenerator get_IdentifierGenerator();
    public abstract virtual IType[] get_PropertyTypes();
    public abstract virtual String[] get_PropertyNames();
    public abstract virtual Boolean[] get_PropertyInsertability();
    public abstract virtual ValueInclusion[] get_PropertyInsertGenerationInclusions();
    public abstract virtual ValueInclusion[] get_PropertyUpdateGenerationInclusions();
    public abstract virtual Boolean[] get_PropertyCheckability();
    public abstract virtual Boolean[] get_PropertyNullability();
    public abstract virtual Boolean[] get_PropertyVersionability();
    public abstract virtual Boolean[] get_PropertyLaziness();
    public abstract virtual CascadeStyle[] get_PropertyCascadeStyles();
    public abstract virtual IType get_IdentifierType();
    public abstract virtual string get_IdentifierPropertyName();
    public abstract virtual bool get_IsCacheInvalidationRequired();
    public abstract virtual bool get_IsLazyPropertiesCacheable();
    public abstract virtual ICacheConcurrencyStrategy get_Cache();
    public abstract virtual ICacheEntryStructure get_CacheEntryStructure();
    public abstract virtual IClassMetadata get_ClassMetadata();
    public abstract virtual bool get_IsBatchLoadable();
    public abstract virtual bool get_IsSelectBeforeUpdateRequired();
    public abstract virtual bool get_IsVersionPropertyGenerated();
    public abstract virtual void PostInstantiate();
    public abstract virtual bool IsSubclassEntityName(string entityName);
    public abstract virtual bool get_HasProxy();
    public abstract virtual bool get_HasCollections();
    public abstract virtual bool get_HasMutableProperties();
    public abstract virtual bool get_HasSubselectLoadableCollections();
    public abstract virtual bool get_HasCascades();
    public abstract virtual IType GetPropertyType(string propertyName);
    public abstract virtual Int32[] FindDirty(Object[] currentState, Object[] previousState, object entity, ISessionImplementor session);
    public abstract virtual Int32[] FindModified(Object[] old, Object[] current, object entity, ISessionImplementor session);
    public abstract virtual bool get_HasIdentifierProperty();
    public abstract virtual bool get_CanExtractIdOutOfEntity();
    public abstract virtual bool get_HasNaturalIdentifier();
    public abstract virtual Object[] GetNaturalIdentifierSnapshot(object id, ISessionImplementor session);
    public abstract virtual bool get_HasLazyProperties();
    public abstract virtual object Load(object id, object optionalObject, LockMode lockMode, ISessionImplementor session);
    public abstract virtual void Lock(object id, object version, object obj, LockMode lockMode, ISessionImplementor session);
    public abstract virtual void Insert(object id, Object[] fields, object obj, ISessionImplementor session);
    public abstract virtual object Insert(Object[] fields, object obj, ISessionImplementor session);
    public abstract virtual void Delete(object id, object version, object obj, ISessionImplementor session);
    public abstract virtual void Update(object id, Object[] fields, Int32[] dirtyFields, bool hasDirtyCollection, Object[] oldFields, object oldVersion, object obj, object rowId, ISessionImplementor session);
    public abstract virtual Boolean[] get_PropertyUpdateability();
    public abstract virtual bool get_HasCache();
    public abstract virtual Object[] GetDatabaseSnapshot(object id, ISessionImplementor session);
    public abstract virtual object GetCurrentVersion(object id, ISessionImplementor session);
    public abstract virtual object ForceVersionIncrement(object id, object currentVersion, ISessionImplementor session);
    public abstract virtual bool get_IsInstrumented();
    public abstract virtual bool get_HasInsertGeneratedProperties();
    public abstract virtual bool get_HasUpdateGeneratedProperties();
    [ObsoleteAttribute("Use the extension method instead")]
public abstract virtual void AfterInitialize(object entity, bool lazyPropertiesAreUnfetched, ISessionImplementor session);
    public abstract virtual void AfterReassociate(object entity, ISessionImplementor session);
    public abstract virtual object CreateProxy(object id, ISessionImplementor session);
    public abstract virtual Nullable`1<bool> IsTransient(object obj, ISessionImplementor session);
    public abstract virtual Object[] GetPropertyValuesToInsert(object obj, IDictionary mergeMap, ISessionImplementor session);
    public abstract virtual void ProcessInsertGeneratedProperties(object id, object entity, Object[] state, ISessionImplementor session);
    public abstract virtual void ProcessUpdateGeneratedProperties(object id, object entity, Object[] state, ISessionImplementor session);
    public abstract virtual Type get_MappedClass();
    public abstract virtual bool get_ImplementsLifecycle();
    public abstract virtual bool get_ImplementsValidatable();
    public abstract virtual Type get_ConcreteProxyClass();
    public abstract virtual void SetPropertyValues(object obj, Object[] values);
    public abstract virtual void SetPropertyValue(object obj, int i, object value);
    public abstract virtual Object[] GetPropertyValues(object obj);
    public abstract virtual object GetPropertyValue(object obj, int i);
    public abstract virtual object GetPropertyValue(object obj, string name);
    public abstract virtual object GetIdentifier(object obj);
    public abstract virtual void SetIdentifier(object obj, object id);
    public abstract virtual object GetVersion(object obj);
    public abstract virtual object Instantiate(object id);
    public abstract virtual bool IsInstance(object entity);
    public abstract virtual bool HasUninitializedLazyProperties(object obj);
    public abstract virtual void ResetIdentifier(object entity, object currentId, object currentVersion);
    public abstract virtual IEntityPersister GetSubclassEntityPersister(object instance, ISessionFactoryImplementor factory);
    public abstract virtual Nullable`1<bool> IsUnsavedVersion(object version);
    public abstract virtual EntityMode get_EntityMode();
    public abstract virtual IEntityTuplizer get_EntityTuplizer();
}
public interface NHibernate.Persister.Entity.IJoinable {
    public string Name { get; }
    public String[] KeyColumnNames { get; }
    [ObsoleteAttribute("Use KeyColumnNames instead")]
public String[] JoinColumnNames { get; }
    public bool IsCollection { get; }
    public string TableName { get; }
    public abstract virtual string get_Name();
    public abstract virtual String[] get_KeyColumnNames();
    public abstract virtual String[] get_JoinColumnNames();
    public abstract virtual bool get_IsCollection();
    public abstract virtual string get_TableName();
    [ObsoleteAttribute("Have ISupportSelectModeJoinable implemented and use ISupportSelectModeJoinable.SelectFragment instead")]
public abstract virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string currentEntitySuffix, string currentCollectionSuffix, bool includeCollectionColumns);
    public abstract virtual SqlString WhereJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    public abstract virtual SqlString FromJoinFragment(string alias, bool innerJoin, bool includeSubclasses);
    public abstract virtual string FilterFragment(string alias, IDictionary`2<string, IFilter> enabledFilters);
    public abstract virtual string OneToManyFilterFragment(string alias);
    public abstract virtual bool ConsumesEntityAlias();
    public abstract virtual bool ConsumesCollectionAlias();
}
public interface NHibernate.Persister.Entity.ILoadable {
    public IType DiscriminatorType { get; }
    public String[] IdentifierColumnNames { get; }
    public string DiscriminatorColumnName { get; }
    public bool IsAbstract { get; }
    public bool HasSubclasses { get; }
    public bool HasRowId { get; }
    [ObsoleteAttribute("Use the extension method with fetchedLazyProperties parameter instead")]
public abstract virtual Task`1<Object[]> HydrateAsync(DbDataReader rs, object id, object obj, ILoadable rootLoadable, String[][] suffixedPropertyColumns, bool allProperties, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual IType get_DiscriminatorType();
    public abstract virtual String[] get_IdentifierColumnNames();
    public abstract virtual string get_DiscriminatorColumnName();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_HasSubclasses();
    public abstract virtual string GetSubclassForDiscriminatorValue(object value);
    public abstract virtual String[] GetIdentifierAliases(string suffix);
    public abstract virtual String[] GetPropertyAliases(string suffix, int i);
    public abstract virtual String[] GetPropertyColumnNames(int i);
    public abstract virtual string GetDiscriminatorAlias(string suffix);
    public abstract virtual bool get_HasRowId();
    [ObsoleteAttribute("Use the extension method with fetchedLazyProperties parameter instead")]
public abstract virtual Object[] Hydrate(DbDataReader rs, object id, object obj, ILoadable rootLoadable, String[][] suffixedPropertyColumns, bool allProperties, ISessionImplementor session);
}
public interface NHibernate.Persister.Entity.ILockable {
    public string RootTableName { get; }
    public String[] RootTableIdentifierColumnNames { get; }
    public string VersionColumnName { get; }
    public SqlType[] IdAndVersionSqlTypes { get; }
    public abstract virtual string get_RootTableName();
    public abstract virtual String[] get_RootTableIdentifierColumnNames();
    public abstract virtual string get_VersionColumnName();
    public abstract virtual string GetRootTableAlias(string drivingAlias);
    public abstract virtual SqlType[] get_IdAndVersionSqlTypes();
}
public interface NHibernate.Persister.Entity.IOuterJoinLoadable {
    public EntityType EntityType { get; }
    public abstract virtual EntityType get_EntityType();
    public abstract virtual string SelectFragment(string alias, string suffix);
    public abstract virtual int CountSubclassProperties();
    public abstract virtual FetchMode GetFetchMode(int i);
    public abstract virtual CascadeStyle GetCascadeStyle(int i);
    public abstract virtual bool IsDefinedOnSubclass(int i);
    public abstract virtual IType GetSubclassPropertyType(int i);
    public abstract virtual string GetSubclassPropertyName(int i);
    public abstract virtual bool IsSubclassPropertyNullable(int i);
    public abstract virtual String[] GetSubclassPropertyColumnNames(int i);
    public abstract virtual string GetSubclassPropertyTableName(int i);
    public abstract virtual String[] ToColumns(string name, int i);
    public abstract virtual string FromTableFragment(string alias);
    public abstract virtual String[] GetPropertyColumnNames(string propertyPath);
    public abstract virtual string GetPropertyTableName(string propertyName);
    public abstract virtual String[] ToIdentifierColumns(string alias);
    public abstract virtual string GenerateTableAliasForColumn(string rootAlias, string column);
}
public interface NHibernate.Persister.Entity.IPropertyMapping {
    public IType Type { get; }
    public abstract virtual IType get_Type();
    public abstract virtual IType ToType(string propertyName);
    public abstract virtual bool TryToType(string propertyName, IType& type);
    public abstract virtual String[] ToColumns(string alias, string propertyName);
    public abstract virtual String[] ToColumns(string propertyName);
}
public interface NHibernate.Persister.Entity.IQueryable {
    public bool IsExplicitPolymorphism { get; }
    public string MappedSuperclass { get; }
    public string DiscriminatorSQLValue { get; }
    public object DiscriminatorValue { get; }
    public bool IsMultiTable { get; }
    public String[] ConstraintOrderedTableNameClosure { get; }
    public String[][] ConstraintOrderedTableKeyColumnClosure { get; }
    public string TemporaryIdTableName { get; }
    public string TemporaryIdTableDDL { get; }
    public bool VersionPropertyInsertable { get; }
    public abstract virtual bool get_IsExplicitPolymorphism();
    public abstract virtual string get_MappedSuperclass();
    public abstract virtual string get_DiscriminatorSQLValue();
    public abstract virtual object get_DiscriminatorValue();
    public abstract virtual bool get_IsMultiTable();
    public abstract virtual String[] get_ConstraintOrderedTableNameClosure();
    public abstract virtual String[][] get_ConstraintOrderedTableKeyColumnClosure();
    public abstract virtual string get_TemporaryIdTableName();
    public abstract virtual string get_TemporaryIdTableDDL();
    public abstract virtual bool get_VersionPropertyInsertable();
    [ObsoleteAttribute("Use GetIdentifierSelectFragment extension method instead.")]
public abstract virtual string IdentifierSelectFragment(string name, string suffix);
    [ObsoleteAttribute("Use GetPropertiesSelectFragment extension method instead.")]
public abstract virtual string PropertySelectFragment(string alias, string suffix, bool allProperties);
    public abstract virtual int GetSubclassPropertyTableNumber(string propertyPath);
    public abstract virtual Declarer GetSubclassPropertyDeclarer(string propertyPath);
    public abstract virtual string GetSubclassTableName(int number);
    public abstract virtual string GenerateFilterConditionAlias(string rootAlias);
}
public interface NHibernate.Persister.Entity.ISqlLoadable {
    public IType Type { get; }
    public abstract virtual IType get_Type();
    public abstract virtual String[] GetSubclassPropertyColumnAliases(string propertyName, string suffix);
    public abstract virtual String[] GetSubclassPropertyColumnNames(string propertyName);
    public abstract virtual string SelectFragment(string alias, string suffix);
}
internal interface NHibernate.Persister.Entity.ISupportLazyPropsJoinable {
    public abstract virtual string SelectFragment(string lhsAlias, string collectionSuffix, bool includeCollectionColumns, EntityLoadInfo entityInfo);
}
public interface NHibernate.Persister.Entity.ISupportSelectModeJoinable {
    public abstract virtual string IdentifierSelectFragment(string name, string suffix);
    [ObsoleteAttribute("Please use overload taking EntityLoadInfo")]
public abstract virtual string SelectFragment(IJoinable rhs, string rhsAlias, string lhsAlias, string entitySuffix, string currentCollectionSuffix, bool includeCollectionColumns, bool includeLazyProperties);
}
public interface NHibernate.Persister.Entity.IUniqueKeyLoadable {
    public abstract virtual Task`1<object> LoadByUniqueKeyAsync(string propertyName, object uniqueKey, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual object LoadByUniqueKey(string propertyName, object uniqueKey, ISessionImplementor session);
    public abstract virtual int GetPropertyIndex(string propertyName);
}
public class NHibernate.Persister.Entity.JoinedSubclassEntityPersister : AbstractEntityPersister {
    private int tableSpan;
    private String[] tableNames;
    private String[] naturalOrderTableNames;
    private String[][] tableKeyColumns;
    private String[][] naturalOrderTableKeyColumns;
    private Boolean[] naturalOrderCascadeDeleteEnabled;
    private String[] spaces;
    private String[] subclassClosure;
    private String[] subclassTableNameClosure;
    private String[][] subclassTableKeyColumnClosure;
    private Boolean[] isClassOrSuperclassTable;
    private Int32[] naturalOrderPropertyTableNumbers;
    private Int32[] propertyTableNumbers;
    private Int32[] subclassPropertyTableNumberClosure;
    private Int32[] subclassColumnTableNumberClosure;
    private Int32[] subclassFormulaTableNumberClosure;
    private Dictionary`2<object, string> subclassesByDiscriminatorValue;
    private String[] discriminatorValues;
    private String[] notNullColumnNames;
    private Int32[] notNullColumnTableNumbers;
    private String[] constraintOrderedTableNames;
    private String[][] constraintOrderedKeyColumnNames;
    private string discriminatorSQLString;
    private object discriminatorValue;
    public IType DiscriminatorType { get; }
    public string DiscriminatorSQLValue { get; }
    public object DiscriminatorValue { get; }
    public String[] SubclassClosure { get; }
    public String[] PropertySpaces { get; }
    public String[] IdentifierColumnNames { get; }
    protected internal Int32[] PropertyTableNumbersInSelect { get; }
    public bool IsMultiTable { get; }
    protected Int32[] SubclassColumnTableNumberClosure { get; }
    protected Int32[] SubclassFormulaTableNumberClosure { get; }
    protected internal Int32[] PropertyTableNumbers { get; }
    public String[] ConstraintOrderedTableNameClosure { get; }
    public String[][] ConstraintOrderedTableKeyColumnClosure { get; }
    public string RootTableName { get; }
    public string TableName { get; }
    protected int TableSpan { get; }
    protected int SubclassTableSpan { get; }
    public JoinedSubclassEntityPersister(PersistentClass persistentClass, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory, IMapping mapping);
    public virtual IType get_DiscriminatorType();
    public virtual string get_DiscriminatorSQLValue();
    public virtual object get_DiscriminatorValue();
    public virtual String[] get_SubclassClosure();
    public virtual String[] get_PropertySpaces();
    public virtual String[] get_IdentifierColumnNames();
    protected internal virtual Int32[] get_PropertyTableNumbersInSelect();
    public virtual bool get_IsMultiTable();
    protected virtual Int32[] get_SubclassColumnTableNumberClosure();
    protected virtual Int32[] get_SubclassFormulaTableNumberClosure();
    protected internal virtual Int32[] get_PropertyTableNumbers();
    public virtual String[] get_ConstraintOrderedTableNameClosure();
    public virtual String[][] get_ConstraintOrderedTableKeyColumnClosure();
    public virtual string get_RootTableName();
    public virtual string GetSubclassPropertyTableName(int i);
    public virtual string GetSubclassForDiscriminatorValue(object value);
    protected virtual string GetTableName(int table);
    protected virtual String[] GetKeyColumns(int table);
    protected virtual bool IsTableCascadeDeleteEnabled(int j);
    protected virtual bool IsPropertyOfTable(int property, int table);
    private static void Reverse(Object[] objects, int len);
    private static String[] Reverse(String[] objects);
    private static String[][] Reverse(String[][] objects);
    public virtual string FromTableFragment(string alias);
    public virtual string get_TableName();
    private static int GetTableId(string tableName, String[] tables);
    protected virtual void AddDiscriminatorToSelect(SelectFragment select, string name, string suffix);
    private CaseFragment DiscriminatorFragment(string alias);
    public virtual string FilterFragment(string alias);
    public virtual string GenerateFilterConditionAlias(string rootAlias);
    public virtual String[] ToColumns(string alias, string propertyName);
    protected virtual int GetSubclassPropertyTableNumber(int i);
    protected virtual int get_TableSpan();
    protected virtual String[] GetSubclassTableKeyColumns(int j);
    public virtual string GetSubclassTableName(int j);
    protected virtual int get_SubclassTableSpan();
    protected virtual bool IsClassOrSuperclassTable(int j);
    public virtual string GetPropertyTableName(string propertyName);
    public virtual string GetRootTableAlias(string drivingAlias);
    public virtual Declarer GetSubclassPropertyDeclarer(string propertyPath);
    protected virtual Boolean[] GetTableUpdateNeeded(Int32[] dirtyProperties, bool hasDirtyCollection);
    protected virtual Boolean[] GetPropertiesToUpdate(Int32[] dirtyProperties, bool hasDirtyCollection);
}
public class NHibernate.Persister.Entity.Loadable : ValueType {
    public static string RowIdAlias;
    private static Loadable();
}
[ExtensionAttribute]
public static class NHibernate.Persister.Entity.LoadableExtensions : object {
    [ExtensionAttribute]
public static Task`1<Object[]> HydrateAsync(ILoadable loadable, DbDataReader rs, object id, object obj, String[][] suffixedPropertyColumns, ISet`1<string> fetchedLazyProperties, bool allProperties, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.LoadableExtensions/<InitializeLazyPropertiesAsync>d__1")]
[ExtensionAttribute]
internal static Task`1<bool> InitializeLazyPropertiesAsync(ILoadable loadable, DbDataReader rs, object id, object entity, String[][] suffixedPropertyColumns, String[] uninitializedLazyProperties, bool allLazyProperties, ISessionImplementor session, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Object[] Hydrate(ILoadable loadable, DbDataReader rs, object id, object obj, String[][] suffixedPropertyColumns, ISet`1<string> fetchedLazyProperties, bool allProperties, ISessionImplementor session);
    [ExtensionAttribute]
internal static bool InitializeLazyProperties(ILoadable loadable, DbDataReader rs, object id, object entity, String[][] suffixedPropertyColumns, String[] uninitializedLazyProperties, bool allLazyProperties, ISessionImplementor session);
}
public class NHibernate.Persister.Entity.NamedQueryLoader : object {
    private string queryName;
    private IEntityPersister persister;
    private static INHibernateLogger log;
    public NamedQueryLoader(string queryName, IEntityPersister persister);
    private static NamedQueryLoader();
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.NamedQueryLoader/<LoadAsync>d__0")]
public sealed virtual Task`1<object> LoadAsync(object id, object optionalObject, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual object Load(object id, object optionalObject, ISessionImplementor session);
}
public class NHibernate.Persister.Entity.SingleTableEntityPersister : AbstractEntityPersister {
    private int joinSpan;
    private IType[] identifierTypes;
    private String[] qualifiedTableNames;
    private Boolean[] isInverseTable;
    private Boolean[] isNullableTable;
    private String[][] keyColumnNames;
    private Boolean[] cascadeDeleteEnabled;
    private bool hasSequentialSelects;
    private bool _hasSequentialSelect;
    private String[] spaces;
    private String[] subclassClosure;
    private String[] subclassTableNameClosure;
    private Boolean[] subclassTableIsLazyClosure;
    private Boolean[] isInverseSubclassTable;
    private Boolean[] isNullableSubclassTable;
    private Boolean[] subclassTableSequentialSelect;
    private String[][] subclassTableKeyColumnClosure;
    private Boolean[] isClassOrSuperclassTable;
    private Int32[] propertyTableNumbers;
    private Dictionary`2<int, int> tableIdPropertyNumbers;
    private Int32[] subclassPropertyTableNumberClosure;
    private Int32[] subclassColumnTableNumberClosure;
    private Int32[] subclassFormulaTableNumberClosure;
    private Dictionary`2<object, string> subclassesByDiscriminatorValue;
    private bool forceDiscriminator;
    private string discriminatorColumnName;
    private string discriminatorFormula;
    private string discriminatorFormulaTemplate;
    private string discriminatorAlias;
    private IType discriminatorType;
    private string discriminatorSQLValue;
    private object discriminatorValue;
    private bool discriminatorInsertable;
    private String[] constraintOrderedTableNames;
    private String[][] constraintOrderedKeyColumnNames;
    private SqlString _sequentialSelectString;
    private static object NullDiscriminator;
    private static object NotNullDiscriminator;
    private Dictionary`2<int, String[]> joinToKeyColumns;
    public string DiscriminatorColumnName { get; }
    protected string DiscriminatorFormulaTemplate { get; }
    public IType DiscriminatorType { get; }
    public string DiscriminatorSQLValue { get; }
    public object DiscriminatorValue { get; }
    public String[] SubclassClosure { get; }
    public String[] PropertySpaces { get; }
    protected internal Int32[] PropertyTableNumbersInSelect { get; }
    protected Int32[] SubclassColumnTableNumberClosure { get; }
    protected Int32[] SubclassFormulaTableNumberClosure { get; }
    protected internal Int32[] PropertyTableNumbers { get; }
    public bool IsMultiTable { get; }
    public String[] ConstraintOrderedTableNameClosure { get; }
    public String[][] ConstraintOrderedTableKeyColumnClosure { get; }
    protected internal string DiscriminatorAlias { get; }
    public string TableName { get; }
    protected bool IsDiscriminatorFormula { get; }
    protected string DiscriminatorFormula { get; }
    private bool NeedsDiscriminator { get; }
    protected int TableSpan { get; }
    [ObsoleteAttribute("This property has no more usage in NHibernate and will be removed in a future version.")]
public bool HasSequentialSelect { get; }
    protected int SubclassTableSpan { get; }
    public SingleTableEntityPersister(PersistentClass persistentClass, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory, IMapping mapping);
    private static SingleTableEntityPersister();
    public virtual string get_DiscriminatorColumnName();
    protected virtual string get_DiscriminatorFormulaTemplate();
    public virtual IType get_DiscriminatorType();
    public virtual string get_DiscriminatorSQLValue();
    public virtual object get_DiscriminatorValue();
    public virtual String[] get_SubclassClosure();
    public virtual String[] get_PropertySpaces();
    protected internal virtual Int32[] get_PropertyTableNumbersInSelect();
    protected virtual Int32[] get_SubclassColumnTableNumberClosure();
    protected virtual Int32[] get_SubclassFormulaTableNumberClosure();
    protected internal virtual Int32[] get_PropertyTableNumbers();
    public virtual bool get_IsMultiTable();
    public virtual String[] get_ConstraintOrderedTableNameClosure();
    public virtual IType GetIdentifierType(int j);
    public virtual String[][] get_ConstraintOrderedTableKeyColumnClosure();
    protected virtual bool IsInverseTable(int j);
    protected virtual bool IsInverseSubclassTable(int j);
    protected internal virtual string get_DiscriminatorAlias();
    public virtual string get_TableName();
    public virtual string GetSubclassForDiscriminatorValue(object value);
    protected bool get_IsDiscriminatorFormula();
    protected string get_DiscriminatorFormula();
    protected virtual string GetTableName(int table);
    protected virtual String[] GetKeyColumns(int table);
    protected virtual bool IsTableCascadeDeleteEnabled(int j);
    protected virtual object GetJoinTableId(int table, object obj);
    protected virtual object GetJoinTableId(int table, Object[] fields);
    private static object GetJoinTableId(int table, Nullable`1<int> index, Object[] fields);
    protected virtual Nullable`1<int> GetRefIdColumnOfTable(int table);
    protected virtual bool IsIdOfTable(int property, int table);
    protected virtual bool IsPropertyOfTable(int property, int table);
    protected virtual bool IsSubclassTableSequentialSelect(int table);
    public virtual string FromTableFragment(string name);
    public virtual string FilterFragment(string alias);
    public virtual string OneToManyFilterFragment(string alias);
    private string DiscriminatorFilterFragment(string alias);
    private bool get_NeedsDiscriminator();
    public virtual string GetSubclassPropertyTableName(int i);
    protected virtual void AddDiscriminatorToSelect(SelectFragment select, string name, string suffix);
    protected virtual int GetSubclassPropertyTableNumber(int i);
    protected virtual int get_TableSpan();
    protected virtual void AddDiscriminatorToInsert(SqlInsertBuilder insert);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
protected virtual bool IsSubclassPropertyDeferred(string propertyName, string entityName);
    protected virtual bool IsPropertyDeferred(int propertyIndex);
    public virtual bool get_HasSequentialSelect();
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public int GetSubclassPropertyTableNumber(string propertyName, string entityName);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
protected virtual SqlString GetSequentialSelect(string entityName);
    protected virtual SqlString GetSequentialSelect();
    protected virtual String[] GetJoinIdKeyColumns(int j);
    protected virtual String[] GetSubclassTableKeyColumns(int j);
    public virtual string GetSubclassTableName(int j);
    protected virtual int get_SubclassTableSpan();
    protected virtual bool IsClassOrSuperclassTable(int j);
    protected internal virtual bool IsSubclassTableLazy(int j);
    protected virtual bool IsNullableTable(int j);
    protected virtual bool IsNullableSubclassTable(int j);
    public virtual string GetPropertyTableName(string propertyName);
    public virtual void PostInstantiate();
}
internal class NHibernate.Persister.Entity.SubqueryPropertyMapping : object {
    private Dictionary`2<string, String[]> _propertyColumns;
    private Dictionary`2<string, IType> _propertyTypes;
    private Dictionary`2<string, IPropertyMapping> _propertyAliasMappings;
    private Dictionary`2<string, string> _propertyMappingSuffixes;
    private Dictionary`2<IPropertyMapping, string> _propertyMappings;
    private Dictionary`2<string, ISelectExpression> _aliasSelectExpressions;
    private HashSet`1<FromElement> _nonScalarFromElements;
    private SelectClause _selectClause;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public IType Type { get; }
    public SubqueryPropertyMapping(IType type, SelectClause selectClause);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    public List`1<ISelectExpression> GetRelatedSelectExpressions(string path, SelectClause& selectClause);
    public bool ContainsEntityAlias(string alias, IType type);
    public sealed virtual IType ToType(string propertyName);
    public sealed virtual bool TryToType(string propertyName, IType& type);
    public sealed virtual String[] ToColumns(string alias, string propertyName);
    public List`1<string> GetPropertiesColumns(string alias);
    public List`1<string> GetIdentifiersColumns(string alias);
    private bool TryGetColumns(string alias, string propertyName, String[]& columns);
    private bool TryGetQualifiedColumns(IPropertyMapping propertyMapping, string propertyName, string alias, string suffix, String[]& columns);
    private static String[] QualifyColumns(String[] columns, string alias);
    private static string JoinPaths(IEnumerable`1<string> paths);
    public sealed virtual String[] ToColumns(string propertyName);
}
public class NHibernate.Persister.Entity.UnionSubclassEntityPersister : AbstractEntityPersister {
    private string subquery;
    private string tableName;
    private String[] subclassClosure;
    private String[] spaces;
    private String[] subclassSpaces;
    private string discriminatorSQLValue;
    private object discriminatorValue;
    private Dictionary`2<int, string> subclassByDiscriminatorValue;
    private String[] constraintOrderedTableNames;
    private String[][] constraintOrderedKeyColumnNames;
    public String[] QuerySpaces { get; }
    public IType DiscriminatorType { get; }
    public string DiscriminatorSQLValue { get; }
    public object DiscriminatorValue { get; }
    public String[] SubclassClosure { get; }
    public String[] PropertySpaces { get; }
    protected internal Int32[] PropertyTableNumbersInSelect { get; }
    public bool IsMultiTable { get; }
    protected Int32[] SubclassColumnTableNumberClosure { get; }
    protected Int32[] SubclassFormulaTableNumberClosure { get; }
    protected internal Int32[] PropertyTableNumbers { get; }
    public String[] ConstraintOrderedTableNameClosure { get; }
    public String[][] ConstraintOrderedTableKeyColumnClosure { get; }
    public string TableName { get; }
    protected int TableSpan { get; }
    protected int SubclassTableSpan { get; }
    public UnionSubclassEntityPersister(PersistentClass persistentClass, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory, IMapping mapping);
    public virtual String[] get_QuerySpaces();
    public virtual IType get_DiscriminatorType();
    public virtual string get_DiscriminatorSQLValue();
    public virtual object get_DiscriminatorValue();
    public virtual String[] get_SubclassClosure();
    public virtual String[] get_PropertySpaces();
    protected internal virtual Int32[] get_PropertyTableNumbersInSelect();
    public virtual bool get_IsMultiTable();
    protected virtual Int32[] get_SubclassColumnTableNumberClosure();
    protected virtual Int32[] get_SubclassFormulaTableNumberClosure();
    protected internal virtual Int32[] get_PropertyTableNumbers();
    public virtual String[] get_ConstraintOrderedTableNameClosure();
    public virtual String[][] get_ConstraintOrderedTableKeyColumnClosure();
    public virtual string get_TableName();
    public virtual string GetSubclassForDiscriminatorValue(object value);
    protected virtual string GetTableName(int table);
    protected virtual String[] GetKeyColumns(int table);
    protected virtual bool IsTableCascadeDeleteEnabled(int j);
    protected virtual bool IsPropertyOfTable(int property, int j);
    public virtual string FromTableFragment(string name);
    public virtual string FilterFragment(string alias);
    public virtual string GetSubclassPropertyTableName(int i);
    protected virtual void AddDiscriminatorToSelect(SelectFragment select, string name, string suffix);
    protected virtual int GetSubclassPropertyTableNumber(int i);
    public virtual int GetSubclassPropertyTableNumber(string propertyName);
    protected virtual int get_TableSpan();
    protected string GenerateSubquery(PersistentClass model, IMapping mapping);
    [IteratorStateMachineAttribute("NHibernate.Persister.Entity.UnionSubclassEntityPersister/<PersistentClasses>d__53")]
private static IEnumerable`1<PersistentClass> PersistentClasses(PersistentClass model);
    protected virtual String[] GetSubclassTableKeyColumns(int j);
    public virtual string GetSubclassTableName(int j);
    protected virtual int get_SubclassTableSpan();
    protected virtual bool IsClassOrSuperclassTable(int j);
    public virtual string GetPropertyTableName(string propertyName);
}
[ExtensionAttribute]
public static class NHibernate.Persister.Entity.UniqueKeyLoadableExtensions : object {
    private static INHibernateLogger Logger;
    private static UniqueKeyLoadableExtensions();
    [AsyncStateMachineAttribute("NHibernate.Persister.Entity.UniqueKeyLoadableExtensions/<CacheByUniqueKeysAsync>d__0")]
[ExtensionAttribute]
public static Task CacheByUniqueKeysAsync(IUniqueKeyLoadable ukLoadable, object entity, ISessionImplementor session, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void CacheByUniqueKeys(IUniqueKeyLoadable ukLoadable, object entity, ISessionImplementor session);
}
public interface NHibernate.Persister.IPersister {
    public string Name { get; }
    public bool SupportsQueryCache { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_SupportsQueryCache();
}
public static class NHibernate.Persister.PersisterFactory : object {
    private static Type[] PersisterConstructorArgs;
    private static Type[] CollectionPersisterConstructorArgs;
    private static PersisterFactory();
    public static IEntityPersister CreateClassPersister(PersistentClass model, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory, IMapping cfg);
    public static ICollectionPersister CreateCollectionPersister(Collection model, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory);
    public static IEntityPersister Create(Type persisterClass, PersistentClass model, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory, IMapping cfg);
    public static ICollectionPersister Create(Type persisterClass, Collection model, ICacheConcurrencyStrategy cache, ISessionFactoryImplementor factory);
}
public class NHibernate.Properties.BackFieldStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
public class NHibernate.Properties.BackrefPropertyAccessor : object {
    public static object Unknown;
    private string propertyName;
    private string entityName;
    public bool CanAccessThroughReflectionOptimizer { get; }
    public BackrefPropertyAccessor(string collectionRole, string entityName);
    private static BackrefPropertyAccessor();
    public sealed virtual IGetter GetGetter(Type theClass, string propertyName);
    public sealed virtual ISetter GetSetter(Type theClass, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
}
public class NHibernate.Properties.BasicPropertyAccessor : object {
    public bool CanAccessThroughReflectionOptimizer { get; }
    public sealed virtual IGetter GetGetter(Type type, string propertyName);
    public sealed virtual ISetter GetSetter(Type type, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
    internal static BasicGetter GetGetterOrNull(Type type, string propertyName);
    internal static BasicSetter GetSetterOrNull(Type type, string propertyName);
}
public class NHibernate.Properties.CamelCaseMUnderscoreStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
public class NHibernate.Properties.CamelCaseStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
public class NHibernate.Properties.CamelCaseUnderscoreStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
[ObsoleteAttribute("This class has no more usages in NHibernate and will be removed in a future version.")]
public class NHibernate.Properties.ChainedPropertyAccessor : object {
    private IPropertyAccessor[] chain;
    public bool CanAccessThroughReflectionOptimizer { get; }
    public ChainedPropertyAccessor(IPropertyAccessor[] chain);
    public sealed virtual IGetter GetGetter(Type theClass, string propertyName);
    public sealed virtual ISetter GetSetter(Type theClass, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
}
public class NHibernate.Properties.EmbeddedPropertyAccessor : object {
    public bool CanAccessThroughReflectionOptimizer { get; }
    public sealed virtual IGetter GetGetter(Type theClass, string propertyName);
    public sealed virtual ISetter GetSetter(Type theClass, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
}
public class NHibernate.Properties.FieldAccessor : object {
    private IFieldNamingStrategy namingStrategy;
    public IFieldNamingStrategy NamingStrategy { get; }
    public bool CanAccessThroughReflectionOptimizer { get; }
    public FieldAccessor(IFieldNamingStrategy namingStrategy);
    public IFieldNamingStrategy get_NamingStrategy();
    public sealed virtual IGetter GetGetter(Type theClass, string propertyName);
    public sealed virtual ISetter GetSetter(Type theClass, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
    private static FieldInfo GetField(Type type, string fieldName, Type originalType);
    internal static FieldInfo GetField(Type type, string fieldName);
    private string GetFieldName(string propertyName);
}
public interface NHibernate.Properties.IFieldNamingStrategy {
    public abstract virtual string GetFieldName(string propertyName);
}
public interface NHibernate.Properties.IGetter {
    public Type ReturnType { get; }
    public string PropertyName { get; }
    public MethodInfo Method { get; }
    public abstract virtual object Get(object target);
    public abstract virtual Type get_ReturnType();
    public abstract virtual string get_PropertyName();
    public abstract virtual MethodInfo get_Method();
    public abstract virtual object GetForInsert(object owner, IDictionary mergeMap, ISessionImplementor session);
}
public class NHibernate.Properties.IndexPropertyAccessor : object {
    private string propertyName;
    private string entityName;
    public bool CanAccessThroughReflectionOptimizer { get; }
    public IndexPropertyAccessor(string collectionRole, string entityName);
    public sealed virtual IGetter GetGetter(Type theClass, string propertyName);
    public sealed virtual ISetter GetSetter(Type theClass, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
}
public interface NHibernate.Properties.IOptimizableGetter {
    public abstract virtual void Emit(ILGenerator il);
}
public interface NHibernate.Properties.IOptimizableSetter {
    public Type Type { get; }
    public abstract virtual Type get_Type();
    public abstract virtual void Emit(ILGenerator il);
}
public interface NHibernate.Properties.IPropertyAccessor {
    public bool CanAccessThroughReflectionOptimizer { get; }
    public abstract virtual IGetter GetGetter(Type theClass, string propertyName);
    public abstract virtual ISetter GetSetter(Type theClass, string propertyName);
    public abstract virtual bool get_CanAccessThroughReflectionOptimizer();
}
public interface NHibernate.Properties.ISetter {
    public string PropertyName { get; }
    public MethodInfo Method { get; }
    public abstract virtual void Set(object target, object value);
    public abstract virtual string get_PropertyName();
    public abstract virtual MethodInfo get_Method();
}
public class NHibernate.Properties.LowerCaseStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
public class NHibernate.Properties.LowerCaseUnderscoreStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
public class NHibernate.Properties.MapAccessor : object {
    public bool CanAccessThroughReflectionOptimizer { get; }
    public sealed virtual IGetter GetGetter(Type theClass, string propertyName);
    public sealed virtual ISetter GetSetter(Type theClass, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
}
public class NHibernate.Properties.NoopAccessor : object {
    public bool CanAccessThroughReflectionOptimizer { get; }
    public sealed virtual IGetter GetGetter(Type theClass, string propertyName);
    public sealed virtual ISetter GetSetter(Type theClass, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
}
public class NHibernate.Properties.NoSetterAccessor : object {
    private IFieldNamingStrategy namingStrategy;
    public bool CanAccessThroughReflectionOptimizer { get; }
    public NoSetterAccessor(IFieldNamingStrategy namingStrategy);
    public sealed virtual IGetter GetGetter(Type type, string propertyName);
    public sealed virtual ISetter GetSetter(Type type, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
}
public class NHibernate.Properties.PascalCaseMStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
public class NHibernate.Properties.PascalCaseMUnderscoreStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
public class NHibernate.Properties.PascalCaseUnderscoreStrategy : object {
    public sealed virtual string GetFieldName(string propertyName);
}
public static class NHibernate.Properties.PropertyAccessorFactory : object {
    private static IDictionary`2<string, IPropertyAccessor> accessors;
    private static string DefaultAccessorName;
    private static IPropertyAccessor MapAccessor;
    public static IPropertyAccessor DynamicMapPropertyAccessor { get; }
    private static PropertyAccessorFactory();
    public static IPropertyAccessor GetPropertyAccessor(string type);
    public static IPropertyAccessor GetPropertyAccessor(Property property, Nullable`1<EntityMode> mode);
    private static IPropertyAccessor GetPocoPropertyAccessor(string accessorName);
    private static IPropertyAccessor ResolveCustomAccessor(string accessorName);
    public static IPropertyAccessor get_DynamicMapPropertyAccessor();
}
public class NHibernate.Properties.ReadOnlyAccessor : object {
    public bool CanAccessThroughReflectionOptimizer { get; }
    public sealed virtual IGetter GetGetter(Type type, string propertyName);
    public sealed virtual ISetter GetSetter(Type type, string propertyName);
    public sealed virtual bool get_CanAccessThroughReflectionOptimizer();
}
public class NHibernate.Properties.UnknownBackrefProperty : ValueType {
}
public class NHibernate.PropertyAccessException : HibernateException {
    private Type persistentType;
    private string propertyName;
    private bool wasSetter;
    public Type PersistentType { get; }
    public string Message { get; }
    public PropertyAccessException(Exception innerException, string message, bool wasSetter, Type persistentType, string propertyName);
    public PropertyAccessException(Exception innerException, string message, bool wasSetter, Type persistentType);
    protected PropertyAccessException(SerializationInfo info, StreamingContext context);
    public Type get_PersistentType();
    public virtual string get_Message();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class NHibernate.PropertyNotFoundException : MappingException {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessorType>k__BackingField;
    public Type TargetType { get; }
    public string PropertyName { get; }
    public string AccessorType { get; }
    public PropertyNotFoundException(Type targetType, string propertyName, string accessorType);
    public PropertyNotFoundException(Type targetType, string propertyName);
    public PropertyNotFoundException(string propertyName, string fieldName, Type targetType);
    protected PropertyNotFoundException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public string get_AccessorType();
}
public class NHibernate.PropertyValueException : HibernateException {
    private string entityName;
    private string propertyName;
    public string EntityName { get; }
    public string PropertyName { get; }
    public string Message { get; }
    public PropertyValueException(string message, string entityName, string propertyName);
    public PropertyValueException(string message, string entityName, string propertyName, Exception innerException);
    protected PropertyValueException(SerializationInfo info, StreamingContext context);
    public string get_EntityName();
    public string get_PropertyName();
    public virtual string get_Message();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.Proxy.AbstractLazyInitializer : object {
    protected static object InvokeImplementation;
    private object _target;
    private bool initialized;
    private object _id;
    private ISessionImplementor _session;
    private bool unwrap;
    private string _entityName;
    private bool readOnly;
    protected internal bool IsConnectedToSession { get; }
    public object Identifier { get; public set; }
    public Type PersistentClass { get; }
    public bool IsUninitialized { get; }
    public bool Unwrap { get; public set; }
    public ISessionImplementor Session { get; public set; }
    public string EntityName { get; }
    protected internal object Target { get; }
    public bool IsReadOnlySettingAvailable { get; }
    public bool ReadOnly { get; public set; }
    protected internal AbstractLazyInitializer(string entityName, object id, ISessionImplementor session);
    private static AbstractLazyInitializer();
    [AsyncStateMachineAttribute("NHibernate.Proxy.AbstractLazyInitializer/<InitializeAsync>d__0")]
public virtual Task InitializeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Proxy.AbstractLazyInitializer/<GetImplementationAsync>d__1")]
public sealed virtual Task`1<object> GetImplementationAsync(CancellationToken cancellationToken);
    public sealed virtual void SetSession(ISessionImplementor s);
    public sealed virtual void UnsetSession();
    protected internal bool get_IsConnectedToSession();
    public virtual void Initialize();
    public sealed virtual object get_Identifier();
    public sealed virtual void set_Identifier(object value);
    public abstract virtual Type get_PersistentClass();
    public sealed virtual bool get_IsUninitialized();
    public sealed virtual bool get_Unwrap();
    public sealed virtual void set_Unwrap(bool value);
    public sealed virtual ISessionImplementor get_Session();
    public sealed virtual void set_Session(ISessionImplementor value);
    public sealed virtual string get_EntityName();
    protected internal object get_Target();
    public sealed virtual object GetImplementation();
    public sealed virtual object GetImplementation(ISessionImplementor s);
    public sealed virtual void SetImplementation(object target);
    public sealed virtual bool get_IsReadOnlySettingAvailable();
    public sealed virtual bool get_ReadOnly();
    public sealed virtual void set_ReadOnly(bool value);
    private void ErrorIfReadOnlySettingNotAvailable();
    private static EntityKey GenerateEntityKeyOrNull(object id, ISessionImplementor s, string entityName);
    private void CheckTargetState();
    private object GetProxyOrNull();
    private void SetReadOnly(bool readOnly);
}
public abstract class NHibernate.Proxy.AbstractProxyFactory : object {
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PersistentClass>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Interfaces>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <GetIdentifierMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <SetIdentifierMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IAbstractComponentType <ComponentIdType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClassProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverridesEquals>k__BackingField;
    protected string EntityName { get; private set; }
    protected Type PersistentClass { get; private set; }
    protected Type[] Interfaces { get; private set; }
    protected MethodInfo GetIdentifierMethod { get; private set; }
    protected MethodInfo SetIdentifierMethod { get; private set; }
    protected IAbstractComponentType ComponentIdType { get; private set; }
    protected bool IsClassProxy { get; private set; }
    protected bool OverridesEquals { get; protected set; }
    [CompilerGeneratedAttribute]
protected virtual string get_EntityName();
    [CompilerGeneratedAttribute]
private void set_EntityName(string value);
    [CompilerGeneratedAttribute]
protected virtual Type get_PersistentClass();
    [CompilerGeneratedAttribute]
private void set_PersistentClass(Type value);
    [CompilerGeneratedAttribute]
protected virtual Type[] get_Interfaces();
    [CompilerGeneratedAttribute]
private void set_Interfaces(Type[] value);
    [CompilerGeneratedAttribute]
protected virtual MethodInfo get_GetIdentifierMethod();
    [CompilerGeneratedAttribute]
private void set_GetIdentifierMethod(MethodInfo value);
    [CompilerGeneratedAttribute]
protected virtual MethodInfo get_SetIdentifierMethod();
    [CompilerGeneratedAttribute]
private void set_SetIdentifierMethod(MethodInfo value);
    [CompilerGeneratedAttribute]
protected virtual IAbstractComponentType get_ComponentIdType();
    [CompilerGeneratedAttribute]
private void set_ComponentIdType(IAbstractComponentType value);
    [CompilerGeneratedAttribute]
protected virtual bool get_IsClassProxy();
    [CompilerGeneratedAttribute]
private void set_IsClassProxy(bool value);
    [CompilerGeneratedAttribute]
protected virtual bool get_OverridesEquals();
    [CompilerGeneratedAttribute]
protected virtual void set_OverridesEquals(bool value);
    public virtual void PostInstantiate(string entityName, Type persistentClass, ISet`1<Type> interfaces, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType, bool isClassProxy);
    [ObsoleteAttribute("Override PostInstantiate method with isClassProxy parameter instead.")]
public virtual void PostInstantiate(string entityName, Type persistentClass, ISet`1<Type> interfaces, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType);
    public abstract virtual INHibernateProxy GetProxy(object id, ISessionImplementor session);
    [ObsoleteAttribute("Use ProxyFactoryExtensions.GetFieldInterceptionProxy extension method instead.")]
public virtual object GetFieldInterceptionProxy(object instanceToWrap);
}
[ExtensionAttribute]
public static class NHibernate.Proxy.DefaultDynamicProxyMethodCheckerExtensions : object {
    [ExtensionAttribute]
public static bool IsProxiable(MethodInfo method);
    [ExtensionAttribute]
public static bool ShouldBeProxiable(MethodInfo method);
    [ExtensionAttribute]
public static bool ShouldBeProxiable(PropertyInfo propertyInfo);
    private static bool IsDisposeMethod(MethodInfo method);
    private static bool IsFinalizeMethod(MethodInfo method);
}
[ObsoleteAttribute("Dynamic proxy has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Proxy.DefaultLazyInitializer : BasicLazyInitializer {
    public DefaultLazyInitializer(string entityName, Type persistentClass, object id, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType, ISessionImplementor session, bool overridesEquals);
    public sealed virtual object Intercept(InvocationInfo info);
}
[ObsoleteAttribute("Use StaticProxyFactory instead")]
public class NHibernate.Proxy.DefaultProxyFactory : AbstractProxyFactory {
    private ProxyFactory factory;
    protected static INHibernateLogger log;
    private static DefaultProxyFactory();
    public virtual INHibernateProxy GetProxy(object id, ISessionImplementor session);
    [ObsoleteAttribute("Use ProxyFactoryExtensions.GetFieldInterceptionProxy extension method instead.")]
public virtual object GetFieldInterceptionProxy(object instanceToWrap);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
internal class NHibernate.Proxy.DynamicProxy.DefaultArgumentHandler : object {
    public sealed virtual void PushArguments(ParameterInfo[] methodParameters, ILGenerator IL, bool isStatic);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
internal class NHibernate.Proxy.DynamicProxy.DefaultMethodEmitter : object {
    private static MethodInfo handlerMethod;
    private static MethodInfo getArguments;
    private static ConstructorInfo infoConstructor;
    private IArgumentHandler _argumentHandler;
    public DefaultMethodEmitter(IArgumentHandler argumentHandler);
    private static DefaultMethodEmitter();
    public sealed virtual void EmitMethodBody(MethodBuilder proxyMethod, MethodBuilder callbackMethod, MethodInfo method, FieldInfo field);
    private static void EmitBaseMethodCall(ILGenerator IL, MethodInfo method);
    private static void SaveRefArguments(ILGenerator IL, ParameterInfo[] parameters);
    private static void PushTargetMethodInfo(ILGenerator IL, MethodBuilder generatedMethod, MethodInfo method);
    private void PushStackTrace(ILGenerator IL);
    private void PushGenericArguments(MethodInfo method, ILGenerator IL);
    private void PackageReturnType(MethodInfo method, ILGenerator IL);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Proxy.DynamicProxy.DefaultProxyAssemblyBuilder : object {
    public sealed virtual AssemblyBuilder DefineDynamicAssembly(AppDomain appDomain, AssemblyName name);
    public sealed virtual ModuleBuilder DefineDynamicModule(AssemblyBuilder assemblyBuilder, string moduleName);
    public sealed virtual void Save(AssemblyBuilder assemblyBuilder);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
internal class NHibernate.Proxy.DynamicProxy.DefaultyProxyMethodBuilder : object {
    [CompilerGeneratedAttribute]
private IMethodBodyEmitter <MethodBodyEmitter>k__BackingField;
    public IMethodBodyEmitter MethodBodyEmitter { get; private set; }
    public DefaultyProxyMethodBuilder(IMethodBodyEmitter emitter);
    [CompilerGeneratedAttribute]
public IMethodBodyEmitter get_MethodBodyEmitter();
    [CompilerGeneratedAttribute]
private void set_MethodBodyEmitter(IMethodBodyEmitter value);
    public sealed virtual void CreateProxiedMethod(FieldInfo field, MethodInfo method, TypeBuilder typeBuilder);
}
[ExtensionAttribute]
[ObsoleteAttribute("This class is not used anymore and will be removed in a next major version")]
public static class NHibernate.Proxy.DynamicProxy.HashSetExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This method is not used anymore and will be removed in a next major version")]
public static HashSet`1<T> Merge(HashSet`1<T> source, IEnumerable`1<T> toMerge);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public interface NHibernate.Proxy.DynamicProxy.IArgumentHandler {
    public abstract virtual void PushArguments(ParameterInfo[] parameters, ILGenerator IL, bool isStatic);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public interface NHibernate.Proxy.DynamicProxy.IInterceptor {
    public abstract virtual object Intercept(InvocationInfo info);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public interface NHibernate.Proxy.DynamicProxy.IMethodBodyEmitter {
    public abstract virtual void EmitMethodBody(MethodBuilder proxyMethod, MethodBuilder callbackMethod, MethodInfo method, FieldInfo field);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Proxy.DynamicProxy.InterceptorHandler : MulticastDelegate {
    public InterceptorHandler(object object, IntPtr method);
    public virtual object Invoke(object proxy, MethodInfo targetMethod, StackTrace trace, Type[] genericTypeArgs, Object[] args);
    public virtual IAsyncResult BeginInvoke(object proxy, MethodInfo targetMethod, StackTrace trace, Type[] genericTypeArgs, Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Proxy.DynamicProxy.InvocationHandler : MulticastDelegate {
    public InvocationHandler(object object, IntPtr method);
    public virtual object Invoke(InvocationInfo info);
    public virtual IAsyncResult BeginInvoke(InvocationInfo info, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Proxy.DynamicProxy.InvocationInfo : object {
    private Object[] args;
    private object proxy;
    private MethodInfo _targetMethod;
    private MethodInfo _callbackMethod;
    private StackTrace trace;
    private Type[] typeArgs;
    public object Target { get; }
    public MethodInfo TargetMethod { get; }
    public StackTrace StackTrace { get; }
    public Type[] TypeArguments { get; }
    public Object[] Arguments { get; }
    public InvocationInfo(object proxy, MethodInfo targetMethod, MethodInfo callbackMethod, StackTrace trace, Type[] genericTypeArgs, Object[] args);
    public object get_Target();
    public MethodInfo get_TargetMethod();
    public StackTrace get_StackTrace();
    public Type[] get_TypeArguments();
    public Object[] get_Arguments();
    public void SetArgument(int position, object arg);
    public virtual string ToString();
    private string GetMethodName(MethodInfo method);
    public virtual object InvokeMethodOnTarget();
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public interface NHibernate.Proxy.DynamicProxy.IProxy {
    public IInterceptor Interceptor { get; public set; }
    public abstract virtual IInterceptor get_Interceptor();
    public abstract virtual void set_Interceptor(IInterceptor value);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public interface NHibernate.Proxy.DynamicProxy.IProxyAssemblyBuilder {
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AppDomain appDomain, AssemblyName name);
    public abstract virtual ModuleBuilder DefineDynamicModule(AssemblyBuilder assemblyBuilder, string moduleName);
    public abstract virtual void Save(AssemblyBuilder assemblyBuilder);
}
[ObsoleteAttribute("This interface is not used anymore and will be removed in a next major version")]
public interface NHibernate.Proxy.DynamicProxy.IProxyCache {
    public abstract virtual bool Contains(Type baseType, Type[] baseInterfaces);
    public abstract virtual TypeInfo GetProxyType(Type baseType, Type[] baseInterfaces);
    public abstract virtual bool TryGetProxyType(Type baseType, Type[] baseInterfaces, TypeInfo& proxyType);
    public abstract virtual void StoreProxyType(TypeInfo result, Type baseType, Type[] baseInterfaces);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public interface NHibernate.Proxy.DynamicProxy.IProxyMethodBuilder {
    public abstract virtual void CreateProxiedMethod(FieldInfo field, MethodInfo method, TypeBuilder typeBuilder);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public static class NHibernate.Proxy.DynamicProxy.OpCodesMap : object {
    private static Dictionary`2<Type, OpCode> LdindMap;
    private static Dictionary`2<Type, OpCode> StindMap;
    private static OpCodesMap();
    public static bool TryGetLdindOpCode(Type valueType, OpCode& opCode);
    public static bool TryGetStindOpCode(Type valueType, OpCode& opCode);
}
[ObsoleteAttribute("This class is not used anymore and will be removed in a next major version")]
public class NHibernate.Proxy.DynamicProxy.ProxyCache : object {
    public sealed virtual bool Contains(Type baseType, Type[] baseInterfaces);
    public sealed virtual TypeInfo GetProxyType(Type baseType, Type[] baseInterfaces);
    public sealed virtual bool TryGetProxyType(Type baseType, Type[] baseInterfaces, TypeInfo& proxyType);
    public sealed virtual void StoreProxyType(TypeInfo result, Type baseType, Type[] baseInterfaces);
}
[ObsoleteAttribute("Use NHibernate.Proxy.ProxyCacheEntry instead")]
public class NHibernate.Proxy.DynamicProxy.ProxyCacheEntry : ProxyCacheEntry {
    public ProxyCacheEntry(Type baseType, Type[] interfaces);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Proxy.DynamicProxy.ProxyDummy : object {
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Proxy.DynamicProxy.ProxyFactory : object {
    internal static ConcurrentDictionary`2<ProxyCacheEntry, TypeInfo> _cache;
    private static ConstructorInfo defaultBaseConstructor;
    private static MethodInfo getValue;
    private static MethodInfo setType;
    private static MethodInfo addValue;
    [CompilerGeneratedAttribute]
private IProxyCache <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private IProxyMethodBuilder <ProxyMethodBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IProxyAssemblyBuilder <ProxyAssemblyBuilder>k__BackingField;
    [ObsoleteAttribute("This property is not used anymore and will be removed in a next major version")]
public IProxyCache Cache { get; }
    public IProxyMethodBuilder ProxyMethodBuilder { get; }
    public IProxyAssemblyBuilder ProxyAssemblyBuilder { get; }
    public ProxyFactory(IProxyAssemblyBuilder proxyAssemblyBuilder);
    public ProxyFactory(IProxyMethodBuilder proxyMethodBuilder);
    public ProxyFactory(IProxyMethodBuilder proxyMethodBuilder, IProxyAssemblyBuilder proxyAssemblyBuilder);
    private static ProxyFactory();
    [CompilerGeneratedAttribute]
public IProxyCache get_Cache();
    [CompilerGeneratedAttribute]
public IProxyMethodBuilder get_ProxyMethodBuilder();
    [CompilerGeneratedAttribute]
public IProxyAssemblyBuilder get_ProxyAssemblyBuilder();
    public object CreateProxy(Type instanceType, IInterceptor interceptor, Type[] baseInterfaces);
    public Type CreateProxyType(Type baseType, Type[] interfaces);
    private TypeInfo CreateUncachedProxyType(Type baseType, IReadOnlyCollection`1<Type> baseInterfaces);
    private static ConstructorBuilder DefineConstructor(TypeBuilder typeBuilder, Type parentType);
    private static void ImplementGetObjectData(Type baseType, IReadOnlyCollection`1<Type> baseInterfaces, TypeBuilder typeBuilder, FieldInfo interceptorField);
    private static void DefineSerializationConstructor(TypeBuilder typeBuilder, FieldInfo interceptorField, ConstructorBuilder defaultConstructor);
    private static void AddSerializationSupport(Type baseType, IReadOnlyCollection`1<Type> baseInterfaces, TypeBuilder typeBuilder, FieldInfo interceptorField, ConstructorBuilder defaultConstructor);
    [CompilerGeneratedAttribute]
private TypeInfo <CreateProxyType>b__19_0(ProxyCacheEntry k);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
internal class NHibernate.Proxy.DynamicProxy.ProxyImplementor : object {
    private static MethodAttributes InterceptorMethodsAttributes;
    private static MethodInfo OriginalSetter;
    private static MethodInfo OriginalGetter;
    private FieldBuilder field;
    public FieldBuilder InterceptorField { get; }
    private static ProxyImplementor();
    public FieldBuilder get_InterceptorField();
    public void ImplementProxy(TypeBuilder typeBuilder);
}
[ObsoleteAttribute("DynamicProxy namespace has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public class NHibernate.Proxy.DynamicProxy.ProxyObjectReference : object {
    private Type _baseType;
    private IProxy _proxy;
    protected ProxyObjectReference(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class NHibernate.Proxy.DynProxyTypeValidator : object {
    private List`1<string> errors;
    public sealed virtual ICollection`1<string> ValidateType(Type type);
    protected void EnlistError(Type type, string text);
    protected virtual void CheckHasVisibleDefaultConstructor(Type type);
    protected virtual void CheckAccessibleMembersAreVirtual(Type type);
    private bool IsPropertyMethod(MethodInfo methodInfo);
    protected virtual void CheckMethodIsVirtual(Type type, MethodInfo method);
    public virtual bool IsProxeable(MethodInfo method);
    protected virtual bool HasVisibleDefaultConstructor(Type type);
    protected void CheckNotSealed(Type type);
}
[ExtensionAttribute]
internal static class NHibernate.Proxy.EntityNotFoundDelegateExtension : object {
    [ExtensionAttribute]
public static void HandleEntityNotFound(IEntityNotFoundDelegate interceptor, string entityName, string propertyName, object key);
}
public class NHibernate.Proxy.FieldInterceptorObjectReference : object {
    private NHibernateProxyFactoryInfo _proxyFactoryInfo;
    private IFieldInterceptor _fieldInterceptor;
    private object _deserializedProxy;
    private static string HasAdditionalDataName;
    public FieldInterceptorObjectReference(NHibernateProxyFactoryInfo proxyFactoryInfo, IFieldInterceptor fieldInterceptorField);
    private FieldInterceptorObjectReference(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public void GetBaseData(SerializationInfo info, StreamingContext context, object proxy, Type proxyBaseType);
    [SecurityCriticalAttribute]
public void SetNoAdditionalData(SerializationInfo info);
    private static string GetAdditionalMemberName(FieldInfo fieldInfo);
    private static string GetAdditionalMemberName(PropertyInfo propertyInfo);
}
internal static class NHibernate.Proxy.FieldInterceptorProxyBuilder : object {
    private static MethodAttributes constructorAttributes;
    private static Type FieldInterceptorAccessorType;
    private static PropertyInfo AccessorTypeFieldInterceptorProperty;
    private static Type FieldInterceptorType;
    private static Type FieldInterceptorExtensionsType;
    private static MethodInfo FieldInterceptorInterceptMethod;
    private static MethodInfo FieldInterceptorMarkDirtyMethod;
    private static MethodInfo FieldInterceptorInterceptExtensionMethod;
    private static Type AbstractFieldInterceptorType;
    private static FieldInfo AbstractFieldInterceptorInvokeImplementationField;
    private static Type FieldInterceptorObjectReferenceType;
    private static ConstructorInfo FieldInterceptorObjectReferenceConstructor;
    private static MethodInfo FieldInterceptorObjectReferenceGetBaseDataMethod;
    private static MethodInfo FieldInterceptorObjectReferenceSetNoAdditionalDataMethod;
    private static ConstructorInfo InvalidOperationWithMessageConstructor;
    private static FieldInterceptorProxyBuilder();
    public static TypeInfo CreateProxyType(Type baseType);
    private static void CreateProxiedMethod(TypeBuilder typeBuilder, MethodInfo method, FieldInfo fieldInterceptorField);
    private static void ImplementConstructor(TypeBuilder typeBuilder, Type parentType, FieldInfo proxyInfoField);
    private static void ImplementISerializable(TypeBuilder typeBuilder, FieldInfo proxyInfoField, FieldInfo fieldInterceptorField, Type baseType);
    private static void ImplementDeserializationConstructor(TypeBuilder typeBuilder, Type parentType);
    private static void ImplementGetObjectData(TypeBuilder typeBuilder, FieldInfo proxyInfoField, FieldInfo fieldInterceptorField, Type parentType);
    private static void ImplementIFieldInterceptorAccessor(TypeBuilder typeBuilder, FieldInfo fieldInterceptorField);
    private static void ImplementGetFieldInterceptor(TypeBuilder typeBuilder, FieldInfo fieldInterceptorField);
    private static void ImplementSetFieldInterceptor(TypeBuilder typeBuilder, FieldInfo fieldInterceptorField);
    private static void ImplementGet(TypeBuilder typeBuilder, MethodInfo getter, FieldInfo fieldInterceptorField);
    private static void ImplementSet(TypeBuilder typeBuilder, MethodInfo setter, FieldInfo fieldInterceptorField);
}
public interface NHibernate.Proxy.IEntityNotFoundDelegate {
    public abstract virtual void HandleEntityNotFound(string entityName, object id);
}
public interface NHibernate.Proxy.ILazyInitializer {
    public object Identifier { get; public set; }
    public string EntityName { get; }
    public Type PersistentClass { get; }
    public bool IsUninitialized { get; }
    public bool Unwrap { get; public set; }
    public ISessionImplementor Session { get; public set; }
    public bool IsReadOnlySettingAvailable { get; }
    public bool ReadOnly { get; public set; }
    public abstract virtual Task InitializeAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetImplementationAsync(CancellationToken cancellationToken);
    public abstract virtual void Initialize();
    public abstract virtual object get_Identifier();
    public abstract virtual void set_Identifier(object value);
    public abstract virtual string get_EntityName();
    public abstract virtual Type get_PersistentClass();
    public abstract virtual bool get_IsUninitialized();
    public abstract virtual bool get_Unwrap();
    public abstract virtual void set_Unwrap(bool value);
    public abstract virtual ISessionImplementor get_Session();
    public abstract virtual void set_Session(ISessionImplementor value);
    public abstract virtual bool get_IsReadOnlySettingAvailable();
    public abstract virtual bool get_ReadOnly();
    public abstract virtual void set_ReadOnly(bool value);
    public abstract virtual object GetImplementation();
    public abstract virtual object GetImplementation(ISessionImplementor s);
    public abstract virtual void SetImplementation(object target);
    public abstract virtual void SetSession(ISessionImplementor s);
    public abstract virtual void UnsetSession();
}
public interface NHibernate.Proxy.INHibernateProxy {
    public ILazyInitializer HibernateLazyInitializer { get; }
    public abstract virtual ILazyInitializer get_HibernateLazyInitializer();
}
public interface NHibernate.Proxy.IProxyFactory {
    [ObsoleteAttribute("Use ProxyFactoryExtensions.PostInstantiate extension method instead.")]
public abstract virtual void PostInstantiate(string entityName, Type persistentClass, ISet`1<Type> interfaces, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType);
    public abstract virtual INHibernateProxy GetProxy(object id, ISessionImplementor session);
    [ObsoleteAttribute("Use ProxyFactoryExtensions.GetFieldInterceptionProxy extension method instead.")]
public abstract virtual object GetFieldInterceptionProxy(object instanceToWrap);
}
public interface NHibernate.Proxy.IProxyValidator {
    public abstract virtual ICollection`1<string> ValidateType(Type type);
    public abstract virtual bool IsProxeable(MethodInfo method);
}
internal class NHibernate.Proxy.LiteLazyInitializer : AbstractLazyInitializer {
    [CompilerGeneratedAttribute]
private Type <PersistentClass>k__BackingField;
    public Type PersistentClass { get; }
    internal LiteLazyInitializer(string entityName, object id, ISessionImplementor session, Type persistentClass);
    [CompilerGeneratedAttribute]
public virtual Type get_PersistentClass();
}
public class NHibernate.Proxy.Map.MapLazyInitializer : AbstractLazyInitializer {
    public IDictionary Map { get; }
    public IDictionary`2<string, object> GenericMap { get; }
    public Type PersistentClass { get; }
    public MapLazyInitializer(string entityName, object id, ISessionImplementor session);
    public IDictionary get_Map();
    public IDictionary`2<string, object> get_GenericMap();
    public virtual Type get_PersistentClass();
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Proxy.Map.MapProxy : DynamicObject {
    private MapLazyInitializer li;
    public ILazyInitializer HibernateLazyInitializer { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    internal MapProxy(MapLazyInitializer li);
    public sealed virtual ILazyInitializer get_HibernateLazyInitializer();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
}
public class NHibernate.Proxy.Map.MapProxyFactory : object {
    private string entityName;
    public MapProxyFactory(string entityName);
    [ObsoleteAttribute("Please use constructor accepting entityName instead.")]
public sealed virtual void PostInstantiate(string entityName, Type persistentClass, ISet`1<Type> interfaces, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType);
    public sealed virtual INHibernateProxy GetProxy(object id, ISessionImplementor session);
    public sealed virtual object GetFieldInterceptionProxy(object getInstance);
}
internal class NHibernate.Proxy.NHibernateProxyBuilder : object {
    private static MethodAttributes constructorAttributes;
    private static Type NHibernateProxyType;
    private static PropertyInfo NHibernateProxyTypeLazyInitializerProperty;
    private static Type LazyInitializerType;
    private static PropertyInfo LazyInitializerIdentifierProperty;
    private static MethodInfo LazyInitializerInitializeMethod;
    private static MethodInfo LazyInitializerGetImplementationMethod;
    private static PropertyInfo LazyInitializerIsUninitializedProperty;
    private MethodInfo _getIdentifierMethod;
    private MethodInfo _setIdentifierMethod;
    private IAbstractComponentType _componentIdType;
    private bool _overridesEquals;
    public NHibernateProxyBuilder(MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType, bool overridesEquals);
    private static NHibernateProxyBuilder();
    public TypeInfo CreateProxyType(Type baseType, IReadOnlyCollection`1<Type> baseInterfaces);
    private void CreateProxiedMethod(TypeBuilder typeBuilder, MethodInfo method, FieldInfo lazyInitializerField, Type parentType);
    private static void ImplementConstructor(TypeBuilder typeBuilder, Type parentType, FieldInfo lazyInitializerField, FieldInfo proxyInfoField);
    private static void ImplementDeserializationConstructor(TypeBuilder typeBuilder, Type parentType);
    private static void ImplementGetObjectData(TypeBuilder typeBuilder, FieldInfo proxyInfoField, FieldInfo lazyInitializerField);
    private static void ImplementGetLazyInitializer(TypeBuilder typeBuilder, MethodInfo method, FieldInfo lazyInitializerField);
    private static void ImplementGetIdentifier(TypeBuilder typeBuilder, MethodInfo method, FieldInfo lazyInitializerField, Type parentType);
    private static void ImplementSetIdentifier(TypeBuilder typeBuilder, MethodInfo method, FieldInfo lazyInitializerField, Type parentType);
    private static void ImplementCallMethodOnEmbeddedComponentId(TypeBuilder typeBuilder, MethodInfo method, FieldInfo lazyInitializerField, Type parentType);
    private static void ImplementCallMethodOnImplementation(TypeBuilder typeBuilder, MethodInfo method, FieldInfo lazyInitializerField, Type parentType);
    private static void EmitCallBaseIfLazyInitializerIsNull(ILGenerator IL, MethodInfo method, FieldInfo lazyInitializerField, Type parentType);
    private static void EmitCallMethod(ILGenerator IL, OpCode opCode, MethodInfo method);
    private static void EmitCallImplementation(ILGenerator IL, MethodInfo method, FieldInfo lazyInitializerField);
}
public class NHibernate.Proxy.NHibernateProxyFactoryInfo : object {
    private string _entityName;
    private Type _persistentClass;
    private Type[] _interfaces;
    private MethodInfo _getIdentifierMethod;
    private MethodInfo _setIdentifierMethod;
    private IAbstractComponentType _componentIdType;
    private bool _isClassProxy;
    internal Type PersistentClass { get; }
    internal NHibernateProxyFactoryInfo(string entityName, Type persistentClass, Type[] interfaces, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType, bool isClassProxy);
    private NHibernateProxyFactoryInfo(SerializationInfo info, StreamingContext context);
    internal Type get_PersistentClass();
    public IProxyFactory CreateProxyFactory();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal NHibernateProxyFactoryInfo Clone();
}
[ExtensionAttribute]
public static class NHibernate.Proxy.NHibernateProxyHelper : object {
    public static Type GetClassWithoutInitializingProxy(object obj);
    public static Type GuessClass(object entity);
    [ExtensionAttribute]
public static bool IsProxy(object entity);
}
public class NHibernate.Proxy.NHibernateProxyObjectReference : object {
    private NHibernateProxyFactoryInfo _proxyFactoryInfo;
    private object _identifier;
    private object _implementation;
    [ObsoleteAttribute("Use overload taking an implementation parameter")]
public NHibernateProxyObjectReference(NHibernateProxyFactoryInfo proxyFactoryInfo, object identifier);
    public NHibernateProxyObjectReference(NHibernateProxyFactoryInfo proxyFactoryInfo, object identifier, object implementation);
    private NHibernateProxyObjectReference(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("DynamicProxy has been obsoleted, use static proxies instead (see StaticProxyFactory)")]
public abstract class NHibernate.Proxy.Poco.BasicLazyInitializer : AbstractLazyInitializer {
    internal Type persistentClass;
    protected internal MethodInfo getIdentifierMethod;
    protected internal MethodInfo setIdentifierMethod;
    protected internal bool overridesEquals;
    protected internal IAbstractComponentType componentIdType;
    public Type PersistentClass { get; }
    protected internal BasicLazyInitializer(string entityName, Type persistentClass, object id, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType, ISessionImplementor session, bool overridesEquals);
    protected virtual void AddSerializationInfo(SerializationInfo info, StreamingContext context);
    public virtual Type get_PersistentClass();
    public virtual object Invoke(MethodInfo method, Object[] args, object proxy);
    private bool IsEqualToIdentifierMethod(MethodInfo method);
}
internal static class NHibernate.Proxy.ProxyBuilderHelper : object {
    private static BindingFlags ProxiableMethodsBindingFlags;
    private static ConstructorInfo ObjectConstructor;
    private static ConstructorInfo SecurityCriticalAttributeConstructor;
    private static ConstructorInfo IgnoresAccessChecksToAttributeConstructor;
    internal static MethodInfo SerializableGetObjectDataMethod;
    internal static MethodInfo SerializationInfoSetTypeMethod;
    private static ProxyBuilderHelper();
    internal static AssemblyBuilder DefineDynamicAssembly(AppDomain appDomain, AssemblyName name);
    internal static ModuleBuilder DefineDynamicModule(AssemblyBuilder assemblyBuilder, string moduleName);
    internal static void Save(AssemblyBuilder assemblyBuilder);
    internal static void CallDefaultBaseConstructor(ILGenerator il, Type parentType);
    internal static IEnumerable`1<MethodInfo> GetProxiableMethods(Type type);
    internal static IEnumerable`1<MethodInfo> GetProxiableMethods(Type type, IEnumerable`1<Type> interfaces);
    internal static void MakeProxySerializable(TypeBuilder typeBuilder);
    internal static MethodBuilder GetObjectDataMethodBuilder(TypeBuilder typeBuilder);
    internal static MethodBuilder GenerateMethodSignature(string name, MethodInfo method, TypeBuilder typeBuilder);
    private static bool IsGetHashCode(MethodBase method);
    private static bool IsEquals(MethodBase method);
    internal static void GenerateInstanceOfIgnoresAccessChecksToAttribute(AssemblyBuilder assemblyBuilder, string assemblyName);
    private static Type ResolveTypeConstraint(MethodInfo method, Type typeConstraint);
    private static Type BuildTypeConstraint(Type typeConstraint, Type declaringType);
    private static String[] GenerateTypeNames(int count);
}
public class NHibernate.Proxy.ProxyCacheEntry : object {
    private int _hashCode;
    private HashSet`1<Type> _uniqueInterfaces;
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    public Type BaseType { get; }
    public IReadOnlyCollection`1<Type> Interfaces { get; }
    public ProxyCacheEntry(Type baseType, Type[] interfaces);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    public IReadOnlyCollection`1<Type> get_Interfaces();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProxyCacheEntry other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class NHibernate.Proxy.ProxyFactoryExtensions : object {
    [ExtensionAttribute]
internal static object GetFieldInterceptionProxy(IProxyFactory proxyFactory, Func`1<object> instantiateFunc);
    [ExtensionAttribute]
public static object GetFieldInterceptionProxy(IProxyFactory proxyFactory);
    [ExtensionAttribute]
public static void PostInstantiate(IProxyFactory pf, string entityName, Type persistentClass, HashSet`1<Type> interfaces, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType, bool isClassProxy);
}
public class NHibernate.Proxy.StaticProxyFactory : AbstractProxyFactory {
    private static ConcurrentDictionary`2<ProxyCacheEntry, Func`3<ILazyInitializer, NHibernateProxyFactoryInfo, INHibernateProxy>> Cache;
    private static ConcurrentDictionary`2<Type, Func`2<NHibernateProxyFactoryInfo, IFieldInterceptorAccessor>> FieldInterceptorCache;
    private static INHibernateLogger Log;
    private NHibernateProxyFactoryInfo _proxyFactoryInfo;
    private ProxyCacheEntry _cacheEntry;
    private static StaticProxyFactory();
    public virtual INHibernateProxy GetProxy(object id, ISessionImplementor session);
    public virtual void PostInstantiate(string entityName, Type persistentClass, ISet`1<Type> interfaces, MethodInfo getIdentifierMethod, MethodInfo setIdentifierMethod, IAbstractComponentType componentIdType, bool isClassProxy);
    private Func`3<ILazyInitializer, NHibernateProxyFactoryInfo, INHibernateProxy> CreateProxyActivator(ProxyCacheEntry pke);
    [ObsoleteAttribute("Use ProxyFactoryExtensions.GetFieldInterceptionProxy extension method instead.")]
public virtual object GetFieldInterceptionProxy(object instanceToWrap);
    public object GetFieldInterceptionProxy();
    private Func`2<NHibernateProxyFactoryInfo, IFieldInterceptorAccessor> CreateFieldInterceptionProxyActivator(Type baseType);
    [CompilerGeneratedAttribute]
private Func`3<ILazyInitializer, NHibernateProxyFactoryInfo, INHibernateProxy> <GetProxy>b__5_0(ProxyCacheEntry pke);
}
public class NHibernate.QueryException : HibernateException {
    private string queryString;
    public string QueryString { get; public set; }
    public string Message { get; }
    public QueryException(string message);
    public QueryException(string message, Exception innerException);
    public QueryException(string message, string queryString);
    public QueryException(string message, string queryString, Exception innerException);
    public QueryException(Exception innerException);
    protected QueryException(SerializationInfo info, StreamingContext context);
    public string get_QueryString();
    public void set_QueryString(string value);
    public virtual string get_Message();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class NHibernate.QueryExtensions : object {
    [ExtensionAttribute]
public static void SetParameter(IQuery query, string name, object val, IType type, bool preferMetadataType);
}
[ExtensionAttribute]
public static class NHibernate.QueryOverExtensions : object {
    [ExtensionAttribute]
public static TQueryOver SetTimeout(TQueryOver queryOver, int timeout);
    [ExtensionAttribute]
public static TQueryOver SetFetchSize(TQueryOver queryOver, int fetchSize);
    [ExtensionAttribute]
public static TQueryOver SetComment(TQueryOver queryOver, string comment);
    [ExtensionAttribute]
public static TQueryOver SetFlushMode(TQueryOver queryOver, FlushMode flushMode);
}
public class NHibernate.QueryParameterException : QueryException {
    public QueryParameterException(string message);
    public QueryParameterException(string message, Exception inner);
    protected QueryParameterException(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.ReplicationMode : object {
    public static ReplicationMode Exception;
    public static ReplicationMode Ignore;
    public static ReplicationMode LatestVersion;
    public static ReplicationMode Overwrite;
    private string name;
    protected ReplicationMode(string name);
    private static ReplicationMode();
    public virtual string ToString();
    public abstract virtual bool ShouldOverwriteCurrentVersion(object entity, object currentVersion, object newVersion, IVersionType versionType);
}
public class NHibernate.SchemaValidationException : HibernateException {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <ValidationErrors>k__BackingField;
    public ReadOnlyCollection`1<string> ValidationErrors { get; }
    public SchemaValidationException(string msg, IList`1<string> validationErrors);
    protected SchemaValidationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_ValidationErrors();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum NHibernate.SelectMode : Enum {
    public int value__;
    public static SelectMode Undefined;
    public static SelectMode Fetch;
    public static SelectMode FetchLazyProperties;
    public static SelectMode ChildFetch;
    public static SelectMode JoinOnly;
    public static SelectMode Skip;
    public static SelectMode FetchLazyPropertyGroup;
}
[ExtensionAttribute]
public static class NHibernate.SelectModeExtensions : object {
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> Fetch(IQueryOver`2<TRoot, TSubType> queryOver, SelectMode mode, Expression`1[] associationPaths);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> Fetch(QueryOver`2<TRoot, TSubType> queryOver, SelectMode mode, Expression`1[] associationPaths);
    [ExtensionAttribute]
public static QueryOver`2<TRoot, TSubType> Fetch(QueryOver`2<TRoot, TSubType> queryOver, Expression`1[] associationPaths);
    [ExtensionAttribute]
public static IQueryOver`2<TRoot, TSubType> Fetch(IQueryOver`2<TRoot, TSubType> queryOver, Expression`1[] associationPaths);
    [ExtensionAttribute]
public static TThis Fetch(TThis queryOver, SelectMode mode, Expression`1[] aliasedAssociationPaths);
    [ExtensionAttribute]
public static ICriteria Fetch(ICriteria criteria, SelectMode mode, string associationPath, string alias);
    [ExtensionAttribute]
public static ICriteria Fetch(ICriteria criteria, string associationPath, string alias);
    [ExtensionAttribute]
public static DetachedCriteria Fetch(DetachedCriteria criteria, string associationPath, string alias);
    [ExtensionAttribute]
public static DetachedCriteria Fetch(DetachedCriteria criteria, SelectMode mode, string associationPath, string alias);
    private static T CastOrThrow(object obj);
}
[ExtensionAttribute]
public static class NHibernate.SessionBuilderExtensions : object {
    [ExtensionAttribute]
public static T Tenant(T builder, string tenantIdentifier);
    [ExtensionAttribute]
public static T Tenant(T builder, TenantConfiguration tenantConfig);
}
public class NHibernate.SessionException : HibernateException {
    public SessionException(string message);
    protected SessionException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class NHibernate.SessionExtensions : object {
    [ExtensionAttribute]
public static Task`1<object> GetAsync(ISession session, string entityName, object id, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.SessionExtensions/<GetAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<T> GetAsync(ISession session, string entityName, object id, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.SessionExtensions/<GetAsync>d__2`1")]
[ExtensionAttribute]
public static Task`1<T> GetAsync(ISession session, string entityName, object id, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISharedStatelessSessionBuilder StatelessSessionWithOptions(ISession session);
    [ExtensionAttribute]
public static IQueryBatch CreateQueryBatch(ISession session);
    [ExtensionAttribute]
public static ITransaction GetCurrentTransaction(ISession session);
    [ExtensionAttribute]
public static object Get(ISession session, string entityName, object id, LockMode lockMode);
    [ExtensionAttribute]
public static T Get(ISession session, string entityName, object id, LockMode lockMode);
    [ExtensionAttribute]
public static T Get(ISession session, string entityName, object id);
}
[ExtensionAttribute]
public static class NHibernate.SessionFactoryExtension : object {
    [AsyncStateMachineAttribute("NHibernate.SessionFactoryExtension/<EvictEntityAsync>d__0")]
[ExtensionAttribute]
public static Task EvictEntityAsync(ISessionFactory factory, string entityName, object id, string tenantIdentifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.SessionFactoryExtension/<EvictCollectionAsync>d__1")]
[ExtensionAttribute]
public static Task EvictCollectionAsync(ISessionFactory factory, string roleName, object id, string tenantIdentifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.SessionFactoryExtension/<EvictAsync>d__2")]
[ExtensionAttribute]
public static Task EvictAsync(ISessionFactory factory, IEnumerable`1<Type> persistentClasses, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.SessionFactoryExtension/<EvictEntityAsync>d__3")]
[ExtensionAttribute]
public static Task EvictEntityAsync(ISessionFactory factory, IEnumerable`1<string> entityNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.SessionFactoryExtension/<EvictCollectionAsync>d__4")]
[ExtensionAttribute]
public static Task EvictCollectionAsync(ISessionFactory factory, IEnumerable`1<string> roleNames, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void EvictEntity(ISessionFactory factory, string entityName, object id, string tenantIdentifier);
    [ExtensionAttribute]
public static void EvictCollection(ISessionFactory factory, string roleName, object id, string tenantIdentifier);
    [ExtensionAttribute]
public static void Evict(ISessionFactory factory, IEnumerable`1<Type> persistentClasses);
    [ExtensionAttribute]
public static void EvictEntity(ISessionFactory factory, IEnumerable`1<string> entityNames);
    [ExtensionAttribute]
public static void EvictCollection(ISessionFactory factory, IEnumerable`1<string> roleNames);
}
public class NHibernate.SqlCommand.Alias : object {
    private int length;
    private string suffix;
    private static Char[] Quotes;
    public Alias(int length, string suffix);
    public Alias(string suffix);
    private static Alias();
    public string ToAliasString(string sqlIdentifier, Dialect dialect);
    public string ToAliasString(string sqlIdentifier);
    private static bool IsQuoted(string sqlIdentifier, Char& openQuote, Char& closeQuote);
    public string ToUnquotedAliasString(string sqlIdentifier, Dialect dialect);
    public String[] ToUnquotedAliasStrings(String[] sqlIdentifiers, Dialect dialect);
    public String[] ToAliasStrings(String[] sqlIdentifiers, Dialect dialect);
}
public class NHibernate.SqlCommand.ANSICaseFragment : CaseFragment {
    public ANSICaseFragment(Dialect dialect);
    public virtual string ToSqlStringFragment();
}
public class NHibernate.SqlCommand.ANSIJoinFragment : JoinFragment {
    private SqlStringBuilder _fromFragment;
    private SqlStringBuilder _whereFragment;
    public SqlString ToFromFragmentString { get; }
    public SqlString ToWhereFragmentString { get; }
    public virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType);
    public virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType, SqlString on);
    internal static string GetJoinString(JoinType joinType);
    public virtual SqlString get_ToFromFragmentString();
    public virtual SqlString get_ToWhereFragmentString();
    public virtual void AddJoins(SqlString fromFragment, SqlString whereFragment);
    public JoinFragment Copy();
    public virtual void AddCrossJoin(string tableName, string alias);
    public virtual bool AddCondition(string condition);
    public virtual bool AddCondition(SqlString condition);
    public virtual void AddFromFragmentString(SqlString fromFragmentString);
}
internal class NHibernate.SqlCommand.BackTrackCacheParameterList : Collection`1<Parameter> {
    private Dictionary`2<string, SortedSet`1<int>> _indexesByBackTrace;
    private void AddIndex(Parameter parameter, int index);
    private void RemoveIndexes(Parameter parameter);
    private Dictionary`2<string, SortedSet`1<int>> BuildBackTrackCache();
    protected virtual void InsertItem(int index, Parameter item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, Parameter item);
    protected virtual void ClearItems();
    public IEnumerable`1<int> GetEffectiveParameterLocations(string backTrace);
}
public abstract class NHibernate.SqlCommand.CaseFragment : object {
    protected internal Dialect dialect;
    protected internal string returnColumnName;
    protected internal IDictionary`2<string, string> cases;
    protected CaseFragment(Dialect dialect);
    public virtual CaseFragment SetReturnColumnName(string returnColumnName);
    public virtual CaseFragment SetReturnColumnName(string returnColumnName, string suffix);
    public virtual CaseFragment AddWhenColumnNotNull(string alias, string columnName, string value);
    public abstract virtual string ToSqlStringFragment();
}
public class NHibernate.SqlCommand.ConditionalFragment : object {
    private string tableAlias;
    private String[] lhs;
    private Object[] rhs;
    private string op;
    public ConditionalFragment SetOp(string op);
    public ConditionalFragment SetTableAlias(string tableAlias);
    public ConditionalFragment SetCondition(String[] lhs, String[] rhs);
    public ConditionalFragment SetCondition(String[] lhs, Parameter[] rhs);
    public ConditionalFragment SetCondition(String[] lhs, string rhs);
    public SqlString ToSqlStringFragment();
}
public class NHibernate.SqlCommand.DecodeCaseFragment : CaseFragment {
    public DecodeCaseFragment(Dialect dialect);
    public virtual string ToSqlStringFragment();
}
public class NHibernate.SqlCommand.DisjunctionFragment : object {
    private SqlStringBuilder buffer;
    public DisjunctionFragment(IEnumerable`1<ConditionalFragment> fragments);
    public DisjunctionFragment AddCondition(ConditionalFragment fragment);
    public SqlString ToFragmentString();
}
public class NHibernate.SqlCommand.ForUpdateFragment : object {
    private Dialect dialect;
    private StringBuilder aliases;
    private bool isNoWaitEnabled;
    public bool IsNoWaitEnabled { get; public set; }
    public ForUpdateFragment(Dialect dialect);
    public ForUpdateFragment(Dialect dialect, IDictionary`2<string, LockMode> lockModes, IDictionary`2<string, String[]> keyColumnNames);
    public bool get_IsNoWaitEnabled();
    public void set_IsNoWaitEnabled(bool value);
    public ForUpdateFragment AddTableAlias(string alias);
    public string ToSqlStringFragment();
}
public class NHibernate.SqlCommand.InformixJoinFragment : JoinFragment {
    private SqlStringBuilder afterFrom;
    private SqlStringBuilder afterWhere;
    public SqlString ToFromFragmentString { get; }
    public SqlString ToWhereFragmentString { get; }
    public virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType);
    public virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType, SqlString on);
    public virtual SqlString get_ToFromFragmentString();
    public virtual SqlString get_ToWhereFragmentString();
    public virtual void AddJoins(SqlString fromFragment, SqlString whereFragment);
    public virtual void AddCrossJoin(string tableName, string alias);
    public virtual bool AddCondition(string condition);
    public virtual bool AddCondition(SqlString condition);
    public virtual void AddFromFragmentString(SqlString fromFragmentString);
    private static int GetPrevTableInsertPoint(SqlString text);
}
public class NHibernate.SqlCommand.InFragment : object {
    public static string NotNull;
    public static string Null;
    private List`1<object> values;
    private string columnName;
    private static InFragment();
    public InFragment AddValue(object value);
    public InFragment SetColumn(string colName);
    public InFragment SetColumn(string alias, string colName);
    public InFragment SetFormula(string alias, string formulaTemplate);
    public SqlString ToFragmentString();
}
public class NHibernate.SqlCommand.InsertSelect : object {
    private static INHibernateLogger log;
    private string tableName;
    private string comment;
    private List`1<string> columnNames;
    private SqlSelectBuilder select;
    private static InsertSelect();
    public virtual InsertSelect SetTableName(string tableName);
    public virtual InsertSelect SetComment(string comment);
    public virtual InsertSelect AddColumn(string columnName);
    public virtual InsertSelect AddColumns(String[] columnNames);
    public virtual InsertSelect SetSelect(SqlSelectBuilder select);
    public sealed virtual SqlString ToSqlString();
}
public interface NHibernate.SqlCommand.ISqlCommand {
    public SqlType[] ParameterTypes { get; }
    public SqlString Query { get; }
    public QueryParameters QueryParameters { get; }
    public abstract virtual Task BindAsync(DbCommand command, IList`1<Parameter> commandQueryParametersList, int singleSqlParametersOffset, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task BindAsync(DbCommand command, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual SqlType[] get_ParameterTypes();
    public abstract virtual SqlString get_Query();
    public abstract virtual QueryParameters get_QueryParameters();
    public abstract virtual void ResetParametersIndexesForTheCommand(int singleSqlParametersOffset);
    public abstract virtual void Bind(DbCommand command, IList`1<Parameter> commandQueryParametersList, int singleSqlParametersOffset, ISessionImplementor session);
    public abstract virtual void Bind(DbCommand command, ISessionImplementor session);
}
public interface NHibernate.SqlCommand.ISqlStringBuilder {
    public abstract virtual SqlString ToSqlString();
}
public interface NHibernate.SqlCommand.ISqlStringVisitor {
    public abstract virtual void String(string text);
    public abstract virtual void String(SqlString sqlString);
    public abstract virtual void Parameter(Parameter parameter);
}
public abstract class NHibernate.SqlCommand.JoinFragment : object {
    [CompilerGeneratedAttribute]
private bool <HasFilterCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasThetaJoins>k__BackingField;
    public SqlString ToFromFragmentString { get; }
    public SqlString ToWhereFragmentString { get; }
    public bool HasFilterCondition { get; public set; }
    public bool HasThetaJoins { get; public set; }
    public abstract virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType);
    public abstract virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType, SqlString on);
    public abstract virtual void AddCrossJoin(string tableName, string alias);
    public abstract virtual void AddJoins(SqlString fromFragment, SqlString whereFragment);
    public abstract virtual SqlString get_ToFromFragmentString();
    public abstract virtual SqlString get_ToWhereFragmentString();
    public abstract virtual bool AddCondition(string condition);
    public abstract virtual bool AddCondition(SqlString condition);
    public abstract virtual void AddFromFragmentString(SqlString fromFragmentString);
    public virtual void AddFragment(JoinFragment ojf);
    protected bool AddCondition(SqlStringBuilder buffer, string on);
    protected void AddBareCondition(SqlStringBuilder buffer, SqlString condition);
    protected bool AddCondition(SqlStringBuilder buffer, SqlString on);
    [CompilerGeneratedAttribute]
public bool get_HasFilterCondition();
    [CompilerGeneratedAttribute]
public void set_HasFilterCondition(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasThetaJoins();
    [CompilerGeneratedAttribute]
public void set_HasThetaJoins(bool value);
}
public enum NHibernate.SqlCommand.JoinType : Enum {
    public int value__;
    public static JoinType None;
    public static JoinType InnerJoin;
    public static JoinType FullJoin;
    public static JoinType LeftOuterJoin;
    public static JoinType RightOuterJoin;
    public static JoinType CrossJoin;
}
public class NHibernate.SqlCommand.OracleJoinFragment : JoinFragment {
    private SqlStringBuilder afterFrom;
    private SqlStringBuilder afterWhere;
    private static HashSet`1<char> Operators;
    public SqlString ToFromFragmentString { get; }
    public SqlString ToWhereFragmentString { get; }
    private static OracleJoinFragment();
    public virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType);
    public virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType, SqlString on);
    private void AddLeftOuterJoinCondition(SqlString on);
    public virtual SqlString get_ToFromFragmentString();
    public virtual SqlString get_ToWhereFragmentString();
    public virtual void AddJoins(SqlString fromFragment, SqlString whereFragment);
    public virtual void AddCrossJoin(string tableName, string alias);
    public virtual bool AddCondition(string condition);
    public virtual bool AddCondition(SqlString condition);
    public virtual void AddFromFragmentString(SqlString fromFragmentString);
}
public class NHibernate.SqlCommand.Parameter : object {
    private Nullable`1<int> parameterPosition;
    [CompilerGeneratedAttribute]
private object <BackTrack>k__BackingField;
    public Nullable`1<int> ParameterPosition { get; public set; }
    public object BackTrack { get; public set; }
    public static Parameter Placeholder { get; }
    public Nullable`1<int> get_ParameterPosition();
    public void set_ParameterPosition(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public object get_BackTrack();
    [CompilerGeneratedAttribute]
public void set_BackTrack(object value);
    public static Parameter get_Placeholder();
    public static Parameter WithIndex(int position);
    public Parameter Clone();
    public static Parameter[] GenerateParameters(int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Parameter a, Parameter b);
    public static bool op_Equality(object a, Parameter b);
    public static bool op_Equality(Parameter a, object b);
    public static bool op_Inequality(Parameter a, object b);
    public static bool op_Inequality(object a, Parameter b);
    public static bool op_Inequality(Parameter a, Parameter b);
}
internal class NHibernate.SqlCommand.Parser.MsSqlSelectParser : object {
    private List`1<ColumnDefinition> _columns;
    private List`1<OrderDefinition> _orders;
    private int _nextOrderAliasIndex;
    [CompilerGeneratedAttribute]
private SqlString <Sql>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SelectIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FromIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OrderByIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDistinct>k__BackingField;
    public SqlString Sql { get; }
    public int SelectIndex { get; }
    public int FromIndex { get; }
    public int OrderByIndex { get; }
    public bool IsDistinct { get; }
    public IEnumerable`1<ColumnDefinition> SelectColumns { get; }
    public IEnumerable`1<ColumnDefinition> NonSelectColumns { get; }
    public IEnumerable`1<OrderDefinition> Orders { get; }
    public SqlString SelectClause { get; }
    public SqlString FromAndWhereClause { get; }
    public MsSqlSelectParser(SqlString sql);
    [CompilerGeneratedAttribute]
public SqlString get_Sql();
    [CompilerGeneratedAttribute]
public int get_SelectIndex();
    [CompilerGeneratedAttribute]
public int get_FromIndex();
    [CompilerGeneratedAttribute]
public int get_OrderByIndex();
    [CompilerGeneratedAttribute]
public bool get_IsDistinct();
    public IEnumerable`1<ColumnDefinition> get_SelectColumns();
    public IEnumerable`1<ColumnDefinition> get_NonSelectColumns();
    public IEnumerable`1<OrderDefinition> get_Orders();
    public SqlString get_SelectClause();
    public SqlString get_FromAndWhereClause();
    public SqlString ColumnExpression(ColumnDefinition column);
    [IteratorStateMachineAttribute("NHibernate.SqlCommand.Parser.MsSqlSelectParser/<ParseColumnDefinitions>d__30")]
private IEnumerable`1<ColumnDefinition> ParseColumnDefinitions(IEnumerator`1<SqlToken> tokenEnum);
    private ColumnDefinition ParseSelectColumnDefinition(SqlToken beginToken, SqlToken endToken, SqlToken aliasToken);
    private ColumnDefinition ParseOrderColumnDefinition(SqlToken beginToken, SqlToken endToken, string alias);
    [IteratorStateMachineAttribute("NHibernate.SqlCommand.Parser.MsSqlSelectParser/<ParseOrderDefinitions>d__33")]
private IEnumerable`1<OrderDefinition> ParseOrderDefinitions(IEnumerator`1<SqlToken> tokenEnum);
    private OrderDefinition ParseOrderDefinition(SqlToken beginToken, SqlToken endToken, SqlToken directionToken);
    private bool TryGetColumnDefinition(string columnNameOrIndex, ColumnDefinition& result, SqlToken beginToken, SqlToken endToken);
}
internal static class NHibernate.SqlCommand.Parser.SqlParserUtils : object {
    public static int ReadDelimitedText(string text, int maxOffset, int offset);
    public static int ReadLineComment(string text, int maxOffset, int offset);
    public static int ReadMultilineComment(string text, int maxOffset, int offset);
    public static int ReadWhitespace(string text, int maxOffset, int offset);
}
public class NHibernate.SqlCommand.Parser.SqlToken : object {
    private SqlTokenType _tokenType;
    private SqlString _sql;
    private int _sqlIndex;
    private int _length;
    private string _value;
    public SqlTokenType TokenType { get; }
    public int SqlIndex { get; }
    public int Length { get; }
    public string Value { get; }
    public string UnquotedValue { get; }
    public SqlToken(SqlTokenType tokenType, SqlString sql, int sqlIndex, int length);
    public SqlTokenType get_TokenType();
    public int get_SqlIndex();
    public int get_Length();
    public string get_Value();
    public string get_UnquotedValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(string value);
    public bool Equals(string value, StringComparison stringComparison);
    public virtual string ToString();
}
public class NHibernate.SqlCommand.Parser.SqlTokenizer : object {
    private SqlString _sql;
    private SqlTokenType _includeTokens;
    public bool IgnoreWhitespace { get; public set; }
    public bool IgnoreComments { get; public set; }
    public SqlTokenizer(SqlString sql);
    public bool get_IgnoreWhitespace();
    public void set_IgnoreWhitespace(bool value);
    public bool get_IgnoreComments();
    public void set_IgnoreComments(bool value);
    private bool CanYield(SqlTokenType tokenType);
    private void Ignore(SqlTokenType tokenType, bool canYield);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("NHibernate.SqlCommand.Parser.SqlTokenizer/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<SqlToken> GetEnumerator();
}
[ExtensionAttribute]
internal static class NHibernate.SqlCommand.Parser.SqlTokenizerExtensions : object {
    [ExtensionAttribute]
public static bool TryParseUntil(IEnumerator`1<SqlToken> tokenEnum, string keyword);
    [ExtensionAttribute]
public static bool TryParseUntilFirstMsSqlSelectColumn(IEnumerator`1<SqlToken> tokenEnum);
    [ExtensionAttribute]
public static bool TryParseUntilFirstMsSqlSelectColumn(IEnumerator`1<SqlToken> tokenEnum, SqlToken& selectToken, Boolean& isDistinct);
    [ExtensionAttribute]
public static bool TryParseUntilFirstOrderColumn(IEnumerator`1<SqlToken> tokenEnum, SqlToken& orderToken);
}
[FlagsAttribute]
public enum NHibernate.SqlCommand.Parser.SqlTokenType : Enum {
    public int value__;
    public static SqlTokenType Whitespace;
    public static SqlTokenType Comment;
    public static SqlTokenType Text;
    public static SqlTokenType DelimitedText;
    public static SqlTokenType Parameter;
    public static SqlTokenType Comma;
    public static SqlTokenType BracketOpen;
    public static SqlTokenType BracketClose;
    public static SqlTokenType AllBrackets;
    public static SqlTokenType AllExceptWhitespaceOrComment;
    public static SqlTokenType AllExceptWhitespace;
    public static SqlTokenType All;
}
public class NHibernate.SqlCommand.QueryJoinFragment : JoinFragment {
    private SqlStringBuilder afterFrom;
    private SqlStringBuilder afterWhere;
    private Dialect dialect;
    private bool useThetaStyleInnerJoins;
    public SqlString ToFromFragmentString { get; }
    public SqlString ToWhereFragmentString { get; }
    public QueryJoinFragment(Dialect dialect, bool useThetaStyleInnerJoins);
    public virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType);
    private void AddJoin(string tableName, string alias, string concreteAlias, String[] fkColumns, String[] pkColumns, JoinType joinType, SqlString on);
    public virtual void AddJoin(string tableName, string alias, String[] fkColumns, String[] pkColumns, JoinType joinType, SqlString on);
    public virtual SqlString get_ToFromFragmentString();
    public virtual SqlString get_ToWhereFragmentString();
    public virtual void AddJoins(SqlString fromFragment, SqlString whereFragment);
    public virtual void AddCrossJoin(string tableName, string alias);
    private void AddCondition(string alias, String[] fkColumns, String[] pkColumns);
    public virtual bool AddCondition(string condition);
    public virtual bool AddCondition(SqlString condition);
    public virtual void AddFromFragmentString(SqlString fromFragmentString);
    public void ClearWherePart();
}
public class NHibernate.SqlCommand.QuerySelect : object {
    private JoinFragment joins;
    private SqlStringBuilder selectBuilder;
    private SqlStringBuilder whereBuilder;
    private SqlStringBuilder groupBy;
    private SqlStringBuilder orderBy;
    private SqlStringBuilder having;
    private bool distinct;
    private static HashSet`1<object> dontSpace;
    public JoinFragment JoinFragment { get; }
    public bool Distinct { get; public set; }
    private static QuerySelect();
    public QuerySelect(Dialect dialect);
    public JoinFragment get_JoinFragment();
    public void AddSelectFragmentString(SqlString fragment);
    public void AddSelectColumn(string columnName, string alias);
    public bool get_Distinct();
    public void set_Distinct(bool value);
    public void SetWhereTokens(IEnumerable tokens);
    public void SetGroupByTokens(IEnumerable tokens);
    public void SetOrderByTokens(IEnumerable tokens);
    public void SetHavingTokens(IEnumerable tokens);
    public void AddOrderBy(string orderBySql);
    public SqlString ToQuerySqlString();
    private static void AppendTokens(SqlStringBuilder builder, IEnumerable iter);
}
public class NHibernate.SqlCommand.SelectFragment : object {
    private string suffix;
    private List`1<string> columns;
    private List`1<string> columnAliases;
    private Dialect dialect;
    private String[] usedAliases;
    private string extraSelectList;
    private String[] _extraAliases;
    private bool _useAliasesAsColumns;
    private string _renderedText;
    internal List`1<string> Columns { get; }
    public SelectFragment(Dialect d);
    internal SelectFragment(Dialect d, string renderedText, List`1<string> columnAliases);
    internal List`1<string> get_Columns();
    public SelectFragment SetUsedAliases(String[] usedAliases);
    public SelectFragment SetSuffix(string suffix);
    public SelectFragment AddColumn(string columnName);
    public SelectFragment AddColumns(String[] columnNames);
    public SelectFragment AddColumn(string tableAlias, string columnName);
    public SelectFragment AddColumn(string tableAlias, string columnName, string columnAlias);
    public SelectFragment AddColumns(string tableAlias, String[] columnNames);
    internal SelectFragment AddColumns(IEnumerable`1<string> columnNames);
    public SelectFragment AddColumns(string tableAlias, String[] columnNames, String[] columnAliases);
    public SelectFragment AddFormulas(string tableAlias, String[] formulas, String[] formulaAliases);
    public SelectFragment AddFormula(string tableAlias, string formula, string formulaAlias);
    public string ToFragmentString();
    public string ToSqlStringFragment();
    public string ToSqlStringFragment(bool includeLeadingComma);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public SelectFragment SetExtraSelectList(string extraSelectList);
    public SelectFragment SetExtraSelectList(CaseFragment caseFragment, string fragmentAlias);
    internal IEnumerable`1<string> GetColumnAliases();
    internal SelectFragment UseAliasesAsColumns(bool value);
    [CompilerGeneratedAttribute]
private string <GetColumnAliases>b__29_0(string o, int i);
}
public abstract class NHibernate.SqlCommand.SqlBaseBuilder : object {
    private Dialect dialect;
    private IMapping mapping;
    protected IMapping Mapping { get; }
    public Dialect Dialect { get; }
    protected SqlBaseBuilder(Dialect dialect, IMapping mapping);
    protected IMapping get_Mapping();
    public Dialect get_Dialect();
    protected SqlString ToWhereString(String[] columnNames);
    protected SqlString ToWhereString(string tableAlias, String[] columnNames);
    protected SqlString ToWhereString(String[] columnNames, string op);
    protected SqlString ToWhereString(string tableAlias, String[] columnNames, string op);
    protected SqlString ToWhereString(string columnName, string op);
}
public class NHibernate.SqlCommand.SqlCommandImpl : object {
    private SqlString query;
    private ICollection`1<IParameterSpecification> specifications;
    private QueryParameters queryParameters;
    private ISessionFactoryImplementor factory;
    private SqlType[] parameterTypes;
    private IList`1<Parameter> sqlQueryParametersList;
    public IList`1<Parameter> SqlQueryParametersList { get; }
    public SqlType[] ParameterTypes { get; }
    public SqlString Query { get; }
    public IEnumerable`1<IParameterSpecification> Specifications { get; }
    public QueryParameters QueryParameters { get; }
    public SqlCommandImpl(SqlString query, ICollection`1<IParameterSpecification> specifications, QueryParameters queryParameters, ISessionFactoryImplementor factory);
    [AsyncStateMachineAttribute("NHibernate.SqlCommand.SqlCommandImpl/<BindAsync>d__0")]
public sealed virtual Task BindAsync(DbCommand command, IList`1<Parameter> commandQueryParametersList, int singleSqlParametersOffset, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.SqlCommand.SqlCommandImpl/<BindAsync>d__1")]
public sealed virtual Task BindAsync(DbCommand command, ISessionImplementor session, CancellationToken cancellationToken);
    public IList`1<Parameter> get_SqlQueryParametersList();
    public sealed virtual SqlType[] get_ParameterTypes();
    public sealed virtual SqlString get_Query();
    public IEnumerable`1<IParameterSpecification> get_Specifications();
    public sealed virtual QueryParameters get_QueryParameters();
    public sealed virtual void ResetParametersIndexesForTheCommand(int singleSqlParametersOffset);
    public sealed virtual void Bind(DbCommand command, IList`1<Parameter> commandQueryParametersList, int singleSqlParametersOffset, ISessionImplementor session);
    public sealed virtual void Bind(DbCommand command, ISessionImplementor session);
}
public class NHibernate.SqlCommand.SqlCommandInfo : object {
    private SqlString text;
    private SqlType[] parameterTypes;
    public CommandType CommandType { get; }
    public SqlString Text { get; }
    public SqlType[] ParameterTypes { get; }
    public SqlCommandInfo(SqlString text, SqlType[] parameterTypes);
    public CommandType get_CommandType();
    public SqlString get_Text();
    public SqlType[] get_ParameterTypes();
    public virtual string ToString();
}
public class NHibernate.SqlCommand.SqlDeleteBuilder : SqlBaseBuilder {
    private static INHibernateLogger log;
    private string tableName;
    private List`1<SqlString> whereStrings;
    private List`1<SqlType> parameterTypes;
    private string comment;
    public SqlDeleteBuilder(Dialect dialect, IMapping mapping);
    private static SqlDeleteBuilder();
    public SqlDeleteBuilder SetTableName(string tableName);
    public SqlDeleteBuilder SetComment(string comment);
    public SqlDeleteBuilder SetIdentityColumn(String[] columnNames, IType identityType);
    public SqlDeleteBuilder SetVersionColumn(String[] columnNames, IVersionType versionType);
    public SqlDeleteBuilder AddWhereFragment(String[] columnNames, IType type, string op);
    public SqlDeleteBuilder AddWhereFragment(String[] columnNames, SqlType[] types, string op);
    public SqlDeleteBuilder AddWhereFragment(string columnName, SqlType type, string op);
    public SqlDeleteBuilder AddWhereFragment(string whereSql);
    public virtual SqlDeleteBuilder SetWhere(string whereSql);
    public sealed virtual SqlString ToSqlString();
    public SqlCommandInfo ToSqlCommandInfo();
}
public class NHibernate.SqlCommand.SqlInsertBuilder : object {
    private static INHibernateLogger log;
    private ISessionFactoryImplementor factory;
    private string tableName;
    private string comment;
    private LinkedHashMap`2<string, object> columns;
    protected internal Dialect Dialect { get; }
    public SqlInsertBuilder(ISessionFactoryImplementor factory);
    private static SqlInsertBuilder();
    protected internal Dialect get_Dialect();
    public virtual SqlInsertBuilder SetComment(string comment);
    public SqlInsertBuilder SetTableName(string tableName);
    public virtual SqlInsertBuilder AddColumn(string columnName, IType propertyType);
    [ObsoleteAttribute("This method is unsafe and has no more usages. Use the overload with a property type and use a parameterized query.")]
public SqlInsertBuilder AddColumn(string columnName, object val, ILiteralType literalType);
    public SqlInsertBuilder AddColumn(string columnName, string val);
    public SqlInsertBuilder AddColumns(String[] columnNames, Boolean[] insertable, IType propertyType);
    private void AddColumnWithValueOrType(string columnName, object valueOrType);
    public virtual SqlInsertBuilder AddIdentityColumn(string columnName);
    public virtual SqlString ToSqlString();
    public SqlCommandInfo ToSqlCommandInfo();
    public SqlType[] GetParametersTypeArray();
}
public class NHibernate.SqlCommand.SqlSelectBuilder : SqlBaseBuilder {
    private static INHibernateLogger log;
    private SqlString selectClause;
    private string fromClause;
    private SqlString outerJoinsAfterFrom;
    private SqlString whereClause;
    private SqlString outerJoinsAfterWhere;
    private SqlString orderByClause;
    private SqlString groupByClause;
    private SqlString havingClause;
    private LockMode lockMode;
    private string mainTableAlias;
    private string comment;
    public SqlSelectBuilder(ISessionFactoryImplementor factory);
    private static SqlSelectBuilder();
    public SqlSelectBuilder SetComment(string comment);
    public SqlSelectBuilder SetFromClause(string fromClause);
    public SqlSelectBuilder SetFromClause(string tableName, string alias);
    public SqlSelectBuilder SetFromClause(SqlString fromClause);
    public SqlSelectBuilder SetOrderByClause(SqlString orderByClause);
    public SqlSelectBuilder SetGroupByClause(SqlString groupByClause);
    public SqlSelectBuilder SetOuterJoins(SqlString outerJoinsAfterFrom, SqlString outerJoinsAfterWhere);
    public SqlSelectBuilder SetSelectClause(SqlString selectClause);
    public SqlSelectBuilder SetSelectClause(string selectClause);
    public SqlSelectBuilder SetWhereClause(string tableAlias, String[] columnNames, IType whereType);
    public SqlSelectBuilder SetWhereClause(SqlString whereSqlString);
    public SqlSelectBuilder SetHavingClause(string tableAlias, String[] columnNames, IType whereType);
    public SqlSelectBuilder SetHavingClause(SqlString havingSqlString);
    [ObsoleteAttribute("For some DBMS's such as PostgreSQL, a lock on query with OUTER JOIN is not possible without specifying the not-null side. Use the new method SetLockMode(LockMode, mainTableAlias) instead.")]
public SqlSelectBuilder SetLockMode(LockMode lockMode);
    public SqlSelectBuilder SetLockMode(LockMode lockMode, string mainTableAlias);
    public SqlString ToStatementString();
    public sealed virtual SqlString ToSqlString();
    private string GetForUpdateString();
    [CompilerGeneratedAttribute]
private bool <GetForUpdateString>g__HasOuterJoin|30_0();
}
public class NHibernate.SqlCommand.SqlSimpleSelectBuilder : SqlBaseBuilder {
    private string tableName;
    private List`1<string> columnNames;
    private Dictionary`2<string, string> aliases;
    private LockMode lockMode;
    private string comment;
    private List`1<SqlString> whereStrings;
    private string orderBy;
    public SqlSimpleSelectBuilder(Dialect dialect, IMapping factory);
    public SqlSimpleSelectBuilder SetTableName(string tableName);
    public SqlSimpleSelectBuilder AddColumn(string columnName);
    public SqlSimpleSelectBuilder AddColumn(string columnName, string alias);
    public SqlSimpleSelectBuilder AddColumns(String[] columnNames);
    public SqlSimpleSelectBuilder AddColumns(String[] columnNames, String[] aliases);
    public SqlSimpleSelectBuilder AddColumns(String[] columns, String[] aliases, Boolean[] ignore);
    public virtual SqlSimpleSelectBuilder SetLockMode(LockMode lockMode);
    public string GetAlias(string columnName);
    public SqlSimpleSelectBuilder SetIdentityColumn(String[] columnNames, IType identityType);
    public SqlSimpleSelectBuilder SetVersionColumn(String[] columnNames, IVersionType versionType);
    public SqlSimpleSelectBuilder SetOrderBy(string orderBy);
    public SqlSimpleSelectBuilder AddWhereFragment(String[] columnNames, IType type, string op);
    public SqlSimpleSelectBuilder AddWhereFragment(string fragment);
    public virtual SqlSimpleSelectBuilder SetComment(string comment);
    public sealed virtual SqlString ToSqlString();
}
public class NHibernate.SqlCommand.SqlString : object {
    public static SqlString Empty;
    private List`1<Part> _parts;
    private SortedList`2<int, Parameter> _parameters;
    private int _firstPartIndex;
    private int _lastPartIndex;
    private int _sqlStartIndex;
    private int _length;
    public int Count { get; }
    public int Length { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private SqlString(SqlString other);
    private SqlString(SqlString other, int sqlStartIndex, int length);
    public SqlString(string sql);
    public SqlString(Parameter parameter);
    public SqlString(Object[] parts);
    internal SqlString(IEnumerable`1<object> parts);
    private static SqlString();
    public static SqlString Parse(string sql);
    [IteratorStateMachineAttribute("NHibernate.SqlCommand.SqlString/<ParseParts>d__14")]
private static IEnumerable`1<object> ParseParts(string text);
    public sealed virtual int get_Count();
    public int get_Length();
    public static SqlString op_Addition(SqlString lhs, SqlString rhs);
    public SqlString Append(SqlString sql);
    public SqlString Append(string text);
    public SqlString Append(Object[] parts);
    [IteratorStateMachineAttribute("NHibernate.SqlCommand.SqlString/<GetAppendParts>d__23")]
private IEnumerable`1<object> GetAppendParts(Object[] parts);
    public SqlString Copy();
    public bool EndsWith(string value);
    public bool EndsWithCaseInsensitive(string value);
    public IEnumerable`1<Parameter> GetParameters();
    public int GetParameterCount();
    public int IndexOfCaseInsensitive(string text);
    internal int IndexOfOrdinal(string text);
    internal bool Contains(string text);
    public int IndexOf(string text, int startIndex, int length, StringComparison stringComparison);
    public SqlString Insert(int index, string text);
    public SqlString Insert(int index, SqlString sql);
    public int LastIndexOfCaseInsensitive(string text);
    internal int LastIndexOf(string text, StringComparison comparison);
    private int LastIndexOf(string text, int startIndex, int length, StringComparison stringComparison);
    public SqlString Replace(string oldValue, string newValue);
    [IteratorStateMachineAttribute("NHibernate.SqlCommand.SqlString/<ReplaceParts>d__39")]
private IEnumerable`1<object> ReplaceParts(string oldValue, string newValue);
    public SqlString[] Split(string splitter);
    internal SqlString[] SplitWithRegex(string pattern);
    [IteratorStateMachineAttribute("NHibernate.SqlCommand.SqlString/<SplitParts>d__42")]
private IEnumerable`1<SqlString> SplitParts(string splitter);
    public bool StartsWithCaseInsensitive(string value);
    public bool EqualsCaseInsensitive(string value);
    public SqlString Substring(int startIndex);
    public SqlString Substring(int startIndex, int length);
    public SqlString SubstringStartingWithLast(string text);
    public bool IsEmptyOrWhitespace();
    public SqlString Trim();
    private void GetTrimmedIndexes(Int32& sqlStartIndex, Int32& length);
    public void Visit(ISqlStringVisitor visitor);
    private int GetPartIndexForSqlIndex(int sqlIndex);
    private void Add(object part, StringBuilder pendingContent, Int32& sqlIndex);
    private void AppendAndResetPendingContent(StringBuilder pendingContent, Int32& sqlIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("NHibernate.SqlCommand.SqlString/<GetEnumerator>d__61")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(int startIndex);
    public string ToString(int startIndex, int length);
    public SqlString GetSubselectString();
    internal void SubstituteBogusParameters(IReadOnlyList`1<Parameter> actualParams, Parameter bogusParam);
    internal SqlString ReplaceLast(string from, SqlString to);
}
[DefaultMemberAttribute("Item")]
public class NHibernate.SqlCommand.SqlStringBuilder : object {
    private List`1<object> sqlParts;
    private AddingSqlStringVisitor addingVisitor;
    private AddingSqlStringVisitor AddingVisitor { get; }
    public int Count { get; }
    public object Item { get; public set; }
    public SqlStringBuilder(int partsCapacity);
    public SqlStringBuilder(SqlString sqlString);
    private AddingSqlStringVisitor get_AddingVisitor();
    public SqlStringBuilder Add(string sql);
    public SqlStringBuilder Add(Parameter parameter);
    public SqlStringBuilder AddParameter();
    public SqlStringBuilder AddObject(object part);
    public SqlStringBuilder Add(SqlString sqlString);
    public SqlStringBuilder Add(SqlString sqlString, string prefix, string op, string postfix);
    public SqlStringBuilder Add(SqlString[] sqlStrings, string prefix, string op, string postfix);
    public SqlStringBuilder Add(SqlString[] sqlStrings, string prefix, string op, string postfix, bool wrapStatement);
    public int get_Count();
    public object get_Item(int index);
    public void set_Item(int index, object value);
    public SqlStringBuilder Insert(int index, string sql);
    public SqlStringBuilder Insert(int index, Parameter param);
    public SqlStringBuilder RemoveAt(int index);
    public sealed virtual SqlString ToSqlString();
    public virtual string ToString();
    public void Clear();
}
public static class NHibernate.SqlCommand.SqlStringHelper : object {
    public static SqlString Join(SqlString separator, IEnumerable objects);
    internal static SqlString JoinParts(object separator, IList`1<object> parts);
    internal static SqlString Join(string separator, IList`1<SqlString> strings);
    public static SqlString[] Add(SqlString[] x, string sep, SqlString[] y);
    public static SqlString RemoveAsAliasesFromSql(SqlString sql);
    public static bool IsNotEmpty(SqlString str);
    public static bool IsEmpty(SqlString str);
    internal static SqlString ParametersList(List`1<Parameter> parameters);
    internal static SqlString Repeat(SqlString placeholder, int count, string separator, bool wrapInParens);
}
public class NHibernate.SqlCommand.SqlUpdateBuilder : SqlBaseBuilder {
    private static INHibernateLogger log;
    private string tableName;
    private string comment;
    private LinkedHashMap`2<string, object> columns;
    private List`1<SqlString> whereStrings;
    private List`1<SqlType> whereParameterTypes;
    private SqlString assignments;
    public SqlUpdateBuilder(Dialect dialect, IMapping mapping);
    private static SqlUpdateBuilder();
    public SqlUpdateBuilder SetTableName(string tableName);
    public SqlUpdateBuilder SetComment(string comment);
    [ObsoleteAttribute("This method is unsafe and has no more usages. Use the overload with a property type and use a parameterized query.")]
public SqlUpdateBuilder AddColumn(string columnName, object val, ILiteralType literalType);
    public SqlUpdateBuilder AddColumn(string columnName, string val);
    public SqlUpdateBuilder AddColumns(String[] columnsName, string val);
    public virtual SqlUpdateBuilder AddColumn(string columnName, IType propertyType);
    public SqlUpdateBuilder AddColumns(String[] columnNames, IType propertyType);
    public SqlUpdateBuilder AddColumns(String[] columnNames, Boolean[] updateable, IType propertyType);
    private void AddColumnWithValueOrType(string columnName, object valueOrType);
    public SqlUpdateBuilder AppendAssignmentFragment(SqlString fragment);
    [ObsoleteAttribute("This method has no more usage.")]
public SqlUpdateBuilder SetJoin(string joinTableName, String[] keyColumnNames, IType identityType, String[] lhsColumnNames, String[] rhsColumnNames);
    public SqlUpdateBuilder SetWhere(string whereSql);
    public SqlUpdateBuilder SetIdentityColumn(String[] columnNames, IType identityType);
    public SqlUpdateBuilder SetVersionColumn(String[] columnNames, IVersionType versionType);
    public SqlUpdateBuilder AddWhereFragment(String[] columnNames, IType type, string op);
    public SqlUpdateBuilder AddWhereFragment(String[] columnNames, SqlType[] types, string op);
    public SqlUpdateBuilder AddWhereFragment(string columnName, SqlType type, string op);
    public SqlUpdateBuilder AddWhereFragment(string whereSql);
    public sealed virtual SqlString ToSqlString();
    public SqlCommandInfo ToSqlCommandInfo();
}
public class NHibernate.SqlCommand.SubselectClauseExtractor : object {
    private static string FromClauseToken;
    private static string OrderByToken;
    private int lastOrderByIndex;
    private int lastOrderByPartIndex;
    private int parenNestCount;
    private SqlString sql;
    private SqlStringBuilder builder;
    public SubselectClauseExtractor(SqlString sql);
    private bool ProcessPartBeforeFrom(object part);
    public SqlString GetSqlString();
    public static bool HasOrderBy(SqlString subselect);
    private int FindFromClauseInPart(string part);
    private void AddPart(object part);
    private void CheckLastPartForOrderByClause();
    private void IgnoreOrderByInSubselect(string partString);
    private bool ParenIsAfterLastOrderBy(int index);
    private void RemoveLastOrderByClause();
}
public static class NHibernate.SqlCommand.Template : object {
    private static HashSet`1<string> Keywords;
    private static HashSet`1<string> BeforeTableKeywords;
    private static HashSet`1<string> FunctionKeywords;
    public static string Placeholder;
    private static Template();
    public static string RenderWhereStringTemplate(string sqlWhereString, Dialect dialect, SQLFunctionRegistry functionRegistry);
    public static string RenderWhereStringTemplate(string sqlWhereString, string placeholder, Dialect dialect, SQLFunctionRegistry functionRegistry);
    public static string RenderOrderByStringTemplate(string sqlOrderByString, Dialect dialect, SQLFunctionRegistry functionRegistry);
    internal static string ReplacePlaceholder(string template, string alias);
    private static bool IsNamedParameter(string token);
    private static bool IsFunctionOrKeyword(string lcToken, string nextToken, Dialect dialect, SQLFunctionRegistry functionRegistry);
    private static bool IsIdentifier(string token, Dialect dialect);
}
public class NHibernate.SqlCommand.WhereBuilder : SqlBaseBuilder {
    public WhereBuilder(Dialect dialect, ISessionFactoryImplementor factory);
    public SqlString WhereClause(string alias, String[] columnNames, IType whereType);
}
[ExtensionAttribute]
public static class NHibernate.SQLQueryExtension : object {
    [ExtensionAttribute]
public static ISQLQuery AddSynchronizedQuerySpace(ISQLQuery sqlQuery, string querySpace);
    [ExtensionAttribute]
public static ISQLQuery AddSynchronizedEntityName(ISQLQuery sqlQuery, string entityName);
    [ExtensionAttribute]
public static ISQLQuery AddSynchronizedEntityClass(ISQLQuery sqlQuery, Type entityType);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<string> GetSynchronizedQuerySpaces(ISQLQuery sqlQuery);
}
public class NHibernate.SqlTypes.AnsiStringFixedLengthSqlType : SqlType {
    public AnsiStringFixedLengthSqlType(int length);
}
public class NHibernate.SqlTypes.AnsiStringSqlType : SqlType {
    public AnsiStringSqlType(int length);
}
public class NHibernate.SqlTypes.BinaryBlobSqlType : BinarySqlType {
    public BinaryBlobSqlType(int length);
}
public class NHibernate.SqlTypes.BinarySqlType : SqlType {
    public BinarySqlType(int length);
}
public class NHibernate.SqlTypes.DateTime2SqlType : SqlType {
    public DateTime2SqlType(byte fractionalSecondsPrecision);
}
public class NHibernate.SqlTypes.DateTimeOffsetSqlType : SqlType {
    public DateTimeOffsetSqlType(byte fractionalSecondsPrecision);
}
public class NHibernate.SqlTypes.DateTimeSqlType : SqlType {
    public DateTimeSqlType(byte fractionalSecondsPrecision);
}
public class NHibernate.SqlTypes.SqlType : object {
    private DbType dbType;
    private int length;
    private byte precision;
    private byte scale;
    private bool lengthDefined;
    private bool precisionDefined;
    [CompilerGeneratedAttribute]
private bool <ScaleDefined>k__BackingField;
    public DbType DbType { get; }
    public int Length { get; }
    public byte Precision { get; }
    public byte Scale { get; }
    public bool LengthDefined { get; }
    public bool PrecisionDefined { get; }
    public bool ScaleDefined { get; }
    public SqlType(DbType dbType);
    public SqlType(DbType dbType, int length);
    public SqlType(DbType dbType, byte precision, byte scale);
    public SqlType(DbType dbType, byte scale);
    public DbType get_DbType();
    public int get_Length();
    public byte get_Precision();
    public byte get_Scale();
    public bool get_LengthDefined();
    public bool get_PrecisionDefined();
    [CompilerGeneratedAttribute]
public bool get_ScaleDefined();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SqlType rhsSqlType);
    public virtual string ToString();
}
public static class NHibernate.SqlTypes.SqlTypeFactory : object {
    private static ConcurrentDictionary`2<string, SqlType> SqlTypes;
    public static SqlType Guid;
    public static SqlType Boolean;
    public static SqlType Byte;
    public static SqlType Currency;
    public static SqlType Date;
    public static SqlType DateTime;
    public static SqlType DateTime2;
    public static SqlType DateTimeOffSet;
    public static SqlType Decimal;
    public static SqlType Double;
    public static SqlType Int16;
    public static SqlType Int32;
    public static SqlType Int64;
    public static SqlType SByte;
    public static SqlType Single;
    public static SqlType Time;
    public static SqlType UInt16;
    public static SqlType UInt32;
    public static SqlType UInt64;
    public static SqlType[] NoTypes;
    private static SqlTypeFactory();
    private static T GetTypeWithLenOrScale(TDim lengthOrScale, TypeWithLenOrScaleCreateDelegate`2<T, TDim> createDelegate);
    private static SqlType GetTypeWithPrecision(DbType dbType, byte precision, byte scale);
    public static AnsiStringSqlType GetAnsiString(int length);
    public static BinarySqlType GetBinary(int length);
    public static BinaryBlobSqlType GetBinaryBlob(int length);
    public static StringSqlType GetString(int length);
    public static StringClobSqlType GetStringClob(int length);
    public static DateTimeSqlType GetDateTime(byte fractionalSecondsPrecision);
    public static DateTime2SqlType GetDateTime2(byte fractionalSecondsPrecision);
    public static DateTimeOffsetSqlType GetDateTimeOffset(byte fractionalSecondsPrecision);
    public static TimeSqlType GetTime(byte fractionalSecondsPrecision);
    public static SqlType GetSqlType(DbType dbType, byte precision, byte scale);
    private static string GetKeyForLengthOrScaleBased(string name, T lengthOrScale);
    private static string GetKeyForPrecisionScaleBased(string name, byte precision, byte scale);
}
public class NHibernate.SqlTypes.StringClobSqlType : StringSqlType {
    public StringClobSqlType(int length);
}
public class NHibernate.SqlTypes.StringFixedLengthSqlType : SqlType {
    public StringFixedLengthSqlType(int length);
}
public class NHibernate.SqlTypes.StringSqlType : SqlType {
    public StringSqlType(int length);
}
public class NHibernate.SqlTypes.TimeSqlType : SqlType {
    public TimeSqlType(byte fractionalSecondsPrecision);
}
public class NHibernate.SqlTypes.XmlSqlType : SqlType {
    public XmlSqlType(int length);
}
public class NHibernate.StaleObjectStateException : StaleStateException {
    private string entityName;
    private object identifier;
    public string EntityName { get; }
    public object Identifier { get; }
    public string Message { get; }
    public StaleObjectStateException(string entityName, object identifier);
    public StaleObjectStateException(string entityName, object identifier, Exception innerException);
    protected StaleObjectStateException(SerializationInfo info, StreamingContext context);
    public string get_EntityName();
    public object get_Identifier();
    public virtual string get_Message();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class NHibernate.StaleStateException : HibernateException {
    public StaleStateException(string message);
    public StaleStateException(string message, Exception innerException);
    protected StaleStateException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.Stat.CategorizedStatistics : object {
    private string categoryName;
    public string CategoryName { get; }
    internal CategorizedStatistics(string categoryName);
    public string get_CategoryName();
}
public class NHibernate.Stat.CollectionStatistics : CategorizedStatistics {
    internal long loadCount;
    internal long fetchCount;
    internal long updateCount;
    internal long removeCount;
    internal long recreateCount;
    public long LoadCount { get; }
    public long FetchCount { get; }
    public long UpdateCount { get; }
    public long RemoveCount { get; }
    public long RecreateCount { get; }
    internal CollectionStatistics(string categoryName);
    public long get_LoadCount();
    public long get_FetchCount();
    public long get_UpdateCount();
    public long get_RemoveCount();
    public long get_RecreateCount();
    public virtual string ToString();
}
public class NHibernate.Stat.EntityStatistics : CategorizedStatistics {
    internal long loadCount;
    internal long updateCount;
    internal long insertCount;
    internal long deleteCount;
    internal long fetchCount;
    internal long optimisticFailureCount;
    public long LoadCount { get; }
    public long UpdateCount { get; }
    public long InsertCount { get; }
    public long DeleteCount { get; }
    public long FetchCount { get; }
    public long OptimisticFailureCount { get; }
    internal EntityStatistics(string categoryName);
    public long get_LoadCount();
    public long get_UpdateCount();
    public long get_InsertCount();
    public long get_DeleteCount();
    public long get_FetchCount();
    public long get_OptimisticFailureCount();
    public virtual string ToString();
}
public interface NHibernate.Stat.ISessionStatistics {
    public int EntityCount { get; }
    public int CollectionCount { get; }
    public IList`1<EntityKey> EntityKeys { get; }
    public IList`1<CollectionKey> CollectionKeys { get; }
    public abstract virtual int get_EntityCount();
    public abstract virtual int get_CollectionCount();
    public abstract virtual IList`1<EntityKey> get_EntityKeys();
    public abstract virtual IList`1<CollectionKey> get_CollectionKeys();
}
public interface NHibernate.Stat.IStatistics {
    public long EntityDeleteCount { get; }
    public long EntityInsertCount { get; }
    public long EntityLoadCount { get; }
    public long EntityFetchCount { get; }
    public long EntityUpdateCount { get; }
    public long QueryExecutionCount { get; }
    public TimeSpan QueryExecutionMaxTime { get; }
    public string QueryExecutionMaxTimeQueryString { get; }
    public long QueryCacheHitCount { get; }
    public long QueryCacheMissCount { get; }
    public long QueryCachePutCount { get; }
    public long FlushCount { get; }
    public long ConnectCount { get; }
    public long SecondLevelCacheHitCount { get; }
    public long SecondLevelCacheMissCount { get; }
    public long SecondLevelCachePutCount { get; }
    public long SessionCloseCount { get; }
    public long SessionOpenCount { get; }
    public long CollectionLoadCount { get; }
    public long CollectionFetchCount { get; }
    public long CollectionUpdateCount { get; }
    public long CollectionRemoveCount { get; }
    public long CollectionRecreateCount { get; }
    public DateTime StartTime { get; }
    public bool IsStatisticsEnabled { get; public set; }
    public String[] Queries { get; }
    public String[] EntityNames { get; }
    public String[] CollectionRoleNames { get; }
    public String[] SecondLevelCacheRegionNames { get; }
    public long SuccessfulTransactionCount { get; }
    public long TransactionCount { get; }
    public long PrepareStatementCount { get; }
    public long CloseStatementCount { get; }
    public long OptimisticFailureCount { get; }
    public TimeSpan OperationThreshold { get; public set; }
    public abstract virtual long get_EntityDeleteCount();
    public abstract virtual long get_EntityInsertCount();
    public abstract virtual long get_EntityLoadCount();
    public abstract virtual long get_EntityFetchCount();
    public abstract virtual long get_EntityUpdateCount();
    public abstract virtual long get_QueryExecutionCount();
    public abstract virtual TimeSpan get_QueryExecutionMaxTime();
    public abstract virtual string get_QueryExecutionMaxTimeQueryString();
    public abstract virtual long get_QueryCacheHitCount();
    public abstract virtual long get_QueryCacheMissCount();
    public abstract virtual long get_QueryCachePutCount();
    public abstract virtual long get_FlushCount();
    public abstract virtual long get_ConnectCount();
    public abstract virtual long get_SecondLevelCacheHitCount();
    public abstract virtual long get_SecondLevelCacheMissCount();
    public abstract virtual long get_SecondLevelCachePutCount();
    public abstract virtual long get_SessionCloseCount();
    public abstract virtual long get_SessionOpenCount();
    public abstract virtual long get_CollectionLoadCount();
    public abstract virtual long get_CollectionFetchCount();
    public abstract virtual long get_CollectionUpdateCount();
    public abstract virtual long get_CollectionRemoveCount();
    public abstract virtual long get_CollectionRecreateCount();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual bool get_IsStatisticsEnabled();
    public abstract virtual void set_IsStatisticsEnabled(bool value);
    public abstract virtual String[] get_Queries();
    public abstract virtual String[] get_EntityNames();
    public abstract virtual String[] get_CollectionRoleNames();
    public abstract virtual String[] get_SecondLevelCacheRegionNames();
    public abstract virtual long get_SuccessfulTransactionCount();
    public abstract virtual long get_TransactionCount();
    public abstract virtual long get_PrepareStatementCount();
    public abstract virtual long get_CloseStatementCount();
    public abstract virtual long get_OptimisticFailureCount();
    public abstract virtual void Clear();
    public abstract virtual EntityStatistics GetEntityStatistics(string entityName);
    public abstract virtual CollectionStatistics GetCollectionStatistics(string role);
    public abstract virtual SecondLevelCacheStatistics GetSecondLevelCacheStatistics(string regionName);
    public abstract virtual QueryStatistics GetQueryStatistics(string queryString);
    public abstract virtual void LogSummary();
    public abstract virtual TimeSpan get_OperationThreshold();
    public abstract virtual void set_OperationThreshold(TimeSpan value);
}
public interface NHibernate.Stat.IStatisticsImplementor {
    public abstract virtual void OpenSession();
    public abstract virtual void CloseSession();
    public abstract virtual void Flush();
    public abstract virtual void Connect();
    public abstract virtual void LoadEntity(string entityName, TimeSpan time);
    public abstract virtual void FetchEntity(string entityName, TimeSpan time);
    public abstract virtual void UpdateEntity(string entityName, TimeSpan time);
    public abstract virtual void InsertEntity(string entityName, TimeSpan time);
    public abstract virtual void DeleteEntity(string entityName, TimeSpan time);
    public abstract virtual void LoadCollection(string role, TimeSpan time);
    public abstract virtual void FetchCollection(string role, TimeSpan time);
    public abstract virtual void UpdateCollection(string role, TimeSpan time);
    public abstract virtual void RecreateCollection(string role, TimeSpan time);
    public abstract virtual void RemoveCollection(string role, TimeSpan time);
    public abstract virtual void SecondLevelCachePut(string regionName);
    public abstract virtual void SecondLevelCacheHit(string regionName);
    public abstract virtual void SecondLevelCacheMiss(string regionName);
    public abstract virtual void QueryExecuted(string hql, int rows, TimeSpan time);
    public abstract virtual void QueryCacheHit(string hql, string regionName);
    public abstract virtual void QueryCacheMiss(string hql, string regionName);
    public abstract virtual void QueryCachePut(string hql, string regionName);
    public abstract virtual void EndTransaction(bool success);
    public abstract virtual void CloseStatement();
    public abstract virtual void PrepareStatement();
    public abstract virtual void OptimisticFailure(string entityName);
}
public class NHibernate.Stat.QueryStatistics : CategorizedStatistics {
    internal long cacheHitCount;
    internal long cacheMissCount;
    internal long cachePutCount;
    private long executionCount;
    private long executionRowCount;
    private TimeSpan executionAvgTime;
    private TimeSpan executionMaxTime;
    private TimeSpan executionMinTime;
    public long CacheHitCount { get; }
    public long CacheMissCount { get; }
    public long CachePutCount { get; }
    public long ExecutionCount { get; }
    public long ExecutionRowCount { get; }
    public TimeSpan ExecutionAvgTime { get; }
    public TimeSpan ExecutionMaxTime { get; }
    public TimeSpan ExecutionMinTime { get; }
    public QueryStatistics(string categoryName);
    public long get_CacheHitCount();
    public long get_CacheMissCount();
    public long get_CachePutCount();
    public long get_ExecutionCount();
    public long get_ExecutionRowCount();
    public TimeSpan get_ExecutionAvgTime();
    public TimeSpan get_ExecutionMaxTime();
    public TimeSpan get_ExecutionMinTime();
    internal void Executed(long rows, TimeSpan time);
    public virtual string ToString();
}
public class NHibernate.Stat.SecondLevelCacheStatistics : CategorizedStatistics {
    private ICache cache;
    internal long hitCount;
    internal long missCount;
    internal long putCount;
    public long HitCount { get; }
    public long MissCount { get; }
    public long PutCount { get; }
    public long ElementCountInMemory { get; }
    public long ElementCountOnDisk { get; }
    public long SizeInMemory { get; }
    public IDictionary Entries { get; }
    public SecondLevelCacheStatistics(ICache cache);
    public long get_HitCount();
    public long get_MissCount();
    public long get_PutCount();
    public long get_ElementCountInMemory();
    public long get_ElementCountOnDisk();
    public long get_SizeInMemory();
    public IDictionary get_Entries();
    public virtual string ToString();
}
public class NHibernate.Stat.SessionStatisticsImpl : object {
    private ISessionImplementor session;
    public int EntityCount { get; }
    public int CollectionCount { get; }
    public IList`1<EntityKey> EntityKeys { get; }
    public IList`1<CollectionKey> CollectionKeys { get; }
    public SessionStatisticsImpl(ISessionImplementor session);
    public sealed virtual int get_EntityCount();
    public sealed virtual int get_CollectionCount();
    public sealed virtual IList`1<EntityKey> get_EntityKeys();
    public sealed virtual IList`1<CollectionKey> get_CollectionKeys();
    public virtual string ToString();
}
public class NHibernate.Stat.StatisticsImpl : object {
    private object _syncRoot;
    private static INHibernateLogger log;
    private ISessionFactoryImplementor sessionFactory;
    private long entityDeleteCount;
    private long entityInsertCount;
    private long entityLoadCount;
    private long entityFetchCount;
    private long entityUpdateCount;
    private TimeSpan operationThreshold;
    private long queryExecutionCount;
    private TimeSpan queryExecutionMaxTime;
    private string queryExecutionMaxTimeQueryString;
    private long queryCacheHitCount;
    private long queryCacheMissCount;
    private long queryCachePutCount;
    private long flushCount;
    private long connectCount;
    private long secondLevelCacheHitCount;
    private long secondLevelCacheMissCount;
    private long secondLevelCachePutCount;
    private long sessionCloseCount;
    private long sessionOpenCount;
    private long collectionLoadCount;
    private long collectionFetchCount;
    private long collectionUpdateCount;
    private long collectionRemoveCount;
    private long collectionRecreateCount;
    private DateTime startTime;
    private long commitedTransactionCount;
    private long transactionCount;
    private long prepareStatementCount;
    private long closeStatementCount;
    private long optimisticFailureCount;
    private Dictionary`2<string, SecondLevelCacheStatistics> secondLevelCacheStatistics;
    private Dictionary`2<string, EntityStatistics> entityStatistics;
    private Dictionary`2<string, CollectionStatistics> collectionStatistics;
    private Dictionary`2<string, QueryStatistics> queryStatistics;
    internal static string OperationLoad;
    internal static string OperationFetch;
    internal static string OperationUpdate;
    internal static string OperationInsert;
    internal static string OperationDelete;
    internal static string OperationLoadCollection;
    internal static string OperationFetchCollection;
    internal static string OperationUpdateCollection;
    internal static string OperationRecreateCollection;
    internal static string OperationRemoveCollection;
    internal static string OperationExecuteQuery;
    internal static string OperationEndTransaction;
    [CompilerGeneratedAttribute]
private bool <IsStatisticsEnabled>k__BackingField;
    public long EntityDeleteCount { get; }
    public long EntityInsertCount { get; }
    public long EntityLoadCount { get; }
    public long EntityFetchCount { get; }
    public long EntityUpdateCount { get; }
    public long QueryExecutionCount { get; }
    public TimeSpan QueryExecutionMaxTime { get; }
    public string QueryExecutionMaxTimeQueryString { get; }
    public long QueryCacheHitCount { get; }
    public long QueryCacheMissCount { get; }
    public long QueryCachePutCount { get; }
    public long FlushCount { get; }
    public long ConnectCount { get; }
    public long SecondLevelCacheHitCount { get; }
    public long SecondLevelCacheMissCount { get; }
    public long SecondLevelCachePutCount { get; }
    public long SessionCloseCount { get; }
    public long SessionOpenCount { get; }
    public long CollectionLoadCount { get; }
    public long CollectionFetchCount { get; }
    public long CollectionUpdateCount { get; }
    public long CollectionRemoveCount { get; }
    public long CollectionRecreateCount { get; }
    public DateTime StartTime { get; }
    public bool IsStatisticsEnabled { get; public set; }
    public String[] Queries { get; }
    public String[] EntityNames { get; }
    public String[] CollectionRoleNames { get; }
    public String[] SecondLevelCacheRegionNames { get; }
    public long SuccessfulTransactionCount { get; }
    public long TransactionCount { get; }
    public long PrepareStatementCount { get; }
    public long CloseStatementCount { get; }
    public long OptimisticFailureCount { get; }
    public TimeSpan OperationThreshold { get; public set; }
    public StatisticsImpl(ISessionFactoryImplementor sessionFactory);
    private static StatisticsImpl();
    public sealed virtual long get_EntityDeleteCount();
    public sealed virtual long get_EntityInsertCount();
    public sealed virtual long get_EntityLoadCount();
    public sealed virtual long get_EntityFetchCount();
    public sealed virtual long get_EntityUpdateCount();
    public sealed virtual long get_QueryExecutionCount();
    public sealed virtual TimeSpan get_QueryExecutionMaxTime();
    public sealed virtual string get_QueryExecutionMaxTimeQueryString();
    public sealed virtual long get_QueryCacheHitCount();
    public sealed virtual long get_QueryCacheMissCount();
    public sealed virtual long get_QueryCachePutCount();
    public sealed virtual long get_FlushCount();
    public sealed virtual long get_ConnectCount();
    public sealed virtual long get_SecondLevelCacheHitCount();
    public sealed virtual long get_SecondLevelCacheMissCount();
    public sealed virtual long get_SecondLevelCachePutCount();
    public sealed virtual long get_SessionCloseCount();
    public sealed virtual long get_SessionOpenCount();
    public sealed virtual long get_CollectionLoadCount();
    public sealed virtual long get_CollectionFetchCount();
    public sealed virtual long get_CollectionUpdateCount();
    public sealed virtual long get_CollectionRemoveCount();
    public sealed virtual long get_CollectionRecreateCount();
    public sealed virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStatisticsEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsStatisticsEnabled(bool value);
    public sealed virtual String[] get_Queries();
    public sealed virtual String[] get_EntityNames();
    public sealed virtual String[] get_CollectionRoleNames();
    public sealed virtual String[] get_SecondLevelCacheRegionNames();
    public sealed virtual long get_SuccessfulTransactionCount();
    public sealed virtual long get_TransactionCount();
    public sealed virtual long get_PrepareStatementCount();
    public sealed virtual long get_CloseStatementCount();
    public sealed virtual long get_OptimisticFailureCount();
    public sealed virtual void Clear();
    public sealed virtual EntityStatistics GetEntityStatistics(string entityName);
    public sealed virtual CollectionStatistics GetCollectionStatistics(string role);
    public sealed virtual SecondLevelCacheStatistics GetSecondLevelCacheStatistics(string regionName);
    public sealed virtual QueryStatistics GetQueryStatistics(string queryString);
    public sealed virtual void LogSummary();
    public sealed virtual TimeSpan get_OperationThreshold();
    public sealed virtual void set_OperationThreshold(TimeSpan value);
    public sealed virtual void OpenSession();
    public sealed virtual void CloseSession();
    public sealed virtual void Flush();
    public sealed virtual void Connect();
    public sealed virtual void LoadEntity(string entityName, TimeSpan time);
    public sealed virtual void FetchEntity(string entityName, TimeSpan time);
    public sealed virtual void UpdateEntity(string entityName, TimeSpan time);
    public sealed virtual void InsertEntity(string entityName, TimeSpan time);
    public sealed virtual void DeleteEntity(string entityName, TimeSpan time);
    public sealed virtual void LoadCollection(string role, TimeSpan time);
    public sealed virtual void FetchCollection(string role, TimeSpan time);
    public sealed virtual void UpdateCollection(string role, TimeSpan time);
    public sealed virtual void RecreateCollection(string role, TimeSpan time);
    public sealed virtual void RemoveCollection(string role, TimeSpan time);
    public sealed virtual void SecondLevelCachePut(string regionName);
    public sealed virtual void SecondLevelCacheHit(string regionName);
    public sealed virtual void SecondLevelCacheMiss(string regionName);
    public sealed virtual void QueryExecuted(string hql, int rows, TimeSpan time);
    public sealed virtual void QueryCacheHit(string hql, string regionName);
    public sealed virtual void QueryCacheMiss(string hql, string regionName);
    public sealed virtual void QueryCachePut(string hql, string regionName);
    public sealed virtual void EndTransaction(bool success);
    public sealed virtual void CloseStatement();
    public sealed virtual void PrepareStatement();
    public sealed virtual void OptimisticFailure(string entityName);
    private static void LogOperation(string operation, string entityName, TimeSpan time);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class NHibernate.StatelessSessionBuilderExtensions : object {
    [ExtensionAttribute]
public static T Tenant(T builder, string tenantIdentifier);
    [ExtensionAttribute]
public static IStatelessSessionBuilder Tenant(IStatelessSessionBuilder builder, TenantConfiguration tenantConfig);
}
[ExtensionAttribute]
public static class NHibernate.StatelessSessionExtensions : object {
    [AsyncStateMachineAttribute("NHibernate.StatelessSessionExtensions/<GetAsync>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> GetAsync(IStatelessSession session, string entityName, object id, LockMode lockMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.StatelessSessionExtensions/<GetAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<T> GetAsync(IStatelessSession session, string entityName, object id, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task FlushBatcherAsync(IStatelessSession session, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IQueryBatch CreateQueryBatch(IStatelessSession session);
    [ExtensionAttribute]
public static ITransaction GetCurrentTransaction(IStatelessSession session);
    [ExtensionAttribute]
public static T Get(IStatelessSession session, string entityName, object id, LockMode lockMode);
    [ExtensionAttribute]
public static T Get(IStatelessSession session, string entityName, object id);
    [ExtensionAttribute]
public static void FlushBatcher(IStatelessSession session);
    [ExtensionAttribute]
public static void CancelQuery(IStatelessSession session);
}
public class NHibernate.Tool.hbm2ddl.DatabaseMetadata : object {
    private static INHibernateLogger log;
    private Dictionary`2<string, ITableMetadata> tables;
    private HashSet`1<string> sequences;
    private bool extras;
    private Dialect dialect;
    private IDataBaseSchema meta;
    private ISQLExceptionConverter sqlExceptionConverter;
    private static String[] Types;
    public DatabaseMetadata(DbConnection connection, Dialect dialect);
    public DatabaseMetadata(DbConnection connection, Dialect dialect, bool extras);
    private static DatabaseMetadata();
    public sealed virtual ITableMetadata GetTableMetadata(string name, string schema, string catalog, bool isQuoted);
    private string Identifier(string catalog, string schema, string name);
    private void InitSequences(DbConnection connection, Dialect dialect);
    public sealed virtual bool IsSequence(object key);
    public sealed virtual bool IsTable(object key);
    public virtual string ToString();
}
public interface NHibernate.Tool.hbm2ddl.IConnectionHelper {
    public DbConnection Connection { get; }
    public abstract virtual Task PrepareAsync(CancellationToken cancellationToken);
    public abstract virtual void Prepare();
    public abstract virtual DbConnection get_Connection();
    public abstract virtual void Release();
}
public interface NHibernate.Tool.hbm2ddl.IDatabaseMetadata {
    public abstract virtual ITableMetadata GetTableMetadata(string name, string schema, string catalog, bool isQuoted);
    public abstract virtual bool IsSequence(object key);
    public abstract virtual bool IsTable(object key);
}
public class NHibernate.Tool.hbm2ddl.ManagedProviderConnectionHelper : object {
    private IDictionary`2<string, string> cfgProperties;
    private IConnectionProvider connectionProvider;
    private DbConnection connection;
    public DbConnection Connection { get; }
    public ManagedProviderConnectionHelper(IDictionary`2<string, string> cfgProperties);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.ManagedProviderConnectionHelper/<PrepareAsync>d__0")]
public sealed virtual Task PrepareAsync(CancellationToken cancellationToken);
    public sealed virtual void Prepare();
    public sealed virtual DbConnection get_Connection();
    public sealed virtual void Release();
}
public class NHibernate.Tool.hbm2ddl.SchemaExport : object {
    private static INHibernateLogger log;
    private bool wasInitialized;
    private Configuration cfg;
    private IDictionary`2<string, string> configProperties;
    private String[] createSQL;
    private Dialect dialect;
    private String[] dropSQL;
    private IFormatter formatter;
    private string delimiter;
    private string outputFile;
    private bool _requireTenantConnection;
    public SchemaExport(Configuration cfg);
    public SchemaExport(Configuration cfg, IDictionary`2<string, string> configProperties);
    private static SchemaExport();
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaExport/<InitializeAsync>d__0")]
private Task InitializeAsync(CancellationToken cancellationToken);
    public Task CreateAsync(bool useStdOut, bool execute, CancellationToken cancellationToken);
    public Task CreateAsync(bool useStdOut, bool execute, DbConnection connection, CancellationToken cancellationToken);
    public Task CreateAsync(Action`1<string> scriptAction, bool execute, CancellationToken cancellationToken);
    public Task CreateAsync(Action`1<string> scriptAction, bool execute, DbConnection connection, CancellationToken cancellationToken);
    public Task CreateAsync(TextWriter exportOutput, bool execute, CancellationToken cancellationToken);
    public Task CreateAsync(TextWriter exportOutput, bool execute, DbConnection connection, CancellationToken cancellationToken);
    public Task DropAsync(bool useStdOut, bool execute, CancellationToken cancellationToken);
    public Task DropAsync(bool useStdOut, bool execute, DbConnection connection, CancellationToken cancellationToken);
    public Task DropAsync(TextWriter exportOutput, bool execute, CancellationToken cancellationToken);
    public Task DropAsync(TextWriter exportOutput, bool execute, DbConnection connection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaExport/<ExecuteInitializedAsync>d__11")]
private Task ExecuteInitializedAsync(Action`1<string> scriptAction, bool execute, bool throwOnError, TextWriter exportOutput, DbCommand statement, string sql, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaExport/<ExecuteSqlAsync>d__12")]
private Task ExecuteSqlAsync(DbCommand cmd, string sql, CancellationToken cancellationToken);
    public Task ExecuteAsync(bool useStdOut, bool execute, bool justDrop, DbConnection connection, TextWriter exportOutput, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaExport/<ExecuteAsync>d__14")]
public Task ExecuteAsync(Action`1<string> scriptAction, bool execute, bool justDrop, DbConnection connection, TextWriter exportOutput, CancellationToken cancellationToken);
    public Task ExecuteAsync(bool useStdOut, bool execute, bool justDrop, CancellationToken cancellationToken);
    public Task ExecuteAsync(Action`1<string> scriptAction, bool execute, bool justDrop, CancellationToken cancellationToken);
    public Task ExecuteAsync(Action`1<string> scriptAction, bool execute, bool justDrop, TextWriter exportOutput, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaExport/<InitConnectionAndExecuteAsync>d__18")]
private Task InitConnectionAndExecuteAsync(Action`1<string> scriptAction, bool execute, bool justDrop, DbConnection connection, TextWriter exportOutput, CancellationToken cancellationToken);
    private void Initialize();
    public SchemaExport SetOutputFile(string filename);
    public SchemaExport SetDelimiter(string delimiter);
    public void Create(bool useStdOut, bool execute);
    public void Create(bool useStdOut, bool execute, DbConnection connection);
    public void Create(Action`1<string> scriptAction, bool execute);
    public void Create(Action`1<string> scriptAction, bool execute, DbConnection connection);
    public void Create(TextWriter exportOutput, bool execute);
    public void Create(TextWriter exportOutput, bool execute, DbConnection connection);
    public void Drop(bool useStdOut, bool execute);
    public void Drop(bool useStdOut, bool execute, DbConnection connection);
    public void Drop(TextWriter exportOutput, bool execute);
    public void Drop(TextWriter exportOutput, bool execute, DbConnection connection);
    private void ExecuteInitialized(Action`1<string> scriptAction, bool execute, bool throwOnError, TextWriter exportOutput, DbCommand statement, string sql);
    private void ExecuteSql(DbCommand cmd, string sql);
    public void Execute(bool useStdOut, bool execute, bool justDrop, DbConnection connection, TextWriter exportOutput);
    public void Execute(Action`1<string> scriptAction, bool execute, bool justDrop, DbConnection connection, TextWriter exportOutput);
    public void Execute(bool useStdOut, bool execute, bool justDrop);
    public void Execute(Action`1<string> scriptAction, bool execute, bool justDrop);
    public void Execute(Action`1<string> scriptAction, bool execute, bool justDrop, TextWriter exportOutput);
    private void InitConnectionAndExecute(Action`1<string> scriptAction, bool execute, bool justDrop, DbConnection connection, TextWriter exportOutput);
    private static Action`1<string> GetAction(bool useStdOut);
}
public static class NHibernate.Tool.hbm2ddl.SchemaMetadataUpdater : object {
    public static Task UpdateAsync(ISessionFactoryImplementor sessionFactory, CancellationToken cancellationToken);
    public static Task UpdateAsync(Configuration configuration, Dialect dialect, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaMetadataUpdater/<UpdateDialectKeywordsAsync>d__2")]
private static Task UpdateDialectKeywordsAsync(Dialect dialect, IConnectionHelper connectionHelper, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaMetadataUpdater/<GetReservedWordsAsync>d__3")]
private static Task`1<IEnumerable`1<string>> GetReservedWordsAsync(Dialect dialect, IConnectionHelper connectionHelper, CancellationToken cancellationToken);
    public static void Update(ISessionFactoryImplementor sessionFactory);
    public static void Update(Configuration configuration, Dialect dialect);
    private static void UpdateDialectKeywords(Dialect dialect, IConnectionHelper connectionHelper);
    private static IEnumerable`1<string> GetReservedWords(Dialect dialect, IConnectionHelper connectionHelper);
    [ObsoleteAttribute("Use the overload that passes dialect so keywords will be updated and persisted before auto-quoting")]
public static void QuoteTableAndColumns(Configuration configuration);
    public static void QuoteTableAndColumns(Configuration configuration, Dialect dialect);
    private static void QuoteTable(Table table, Dialect dialect);
    private static void QuoteColumns(IValue value, Dialect dialect);
    private static void QuoteColumns(IEnumerable`1<Column> columns, Dialect dialect);
}
public class NHibernate.Tool.hbm2ddl.SchemaUpdate : object {
    private static INHibernateLogger log;
    private bool wasInitialized;
    private Configuration configuration;
    private IConnectionHelper connectionHelper;
    private Dialect dialect;
    private List`1<Exception> exceptions;
    private IFormatter formatter;
    public IList`1<Exception> Exceptions { get; }
    public SchemaUpdate(Configuration cfg);
    public SchemaUpdate(Configuration cfg, IDictionary`2<string, string> configProperties);
    public SchemaUpdate(Configuration cfg, Settings settings);
    private static SchemaUpdate();
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaUpdate/<InitializeAsync>d__0")]
private Task InitializeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaUpdate/<MainAsync>d__1")]
public static Task MainAsync(String[] args, CancellationToken cancellationToken);
    public Task ExecuteAsync(bool useStdOut, bool doUpdate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaUpdate/<ExecuteAsync>d__3")]
public Task ExecuteAsync(Action`1<string> scriptAction, bool doUpdate, CancellationToken cancellationToken);
    private void Initialize();
    public IList`1<Exception> get_Exceptions();
    public static void Main(String[] args);
    public void Execute(bool useStdOut, bool doUpdate);
    public void Execute(Action`1<string> scriptAction, bool doUpdate);
}
public class NHibernate.Tool.hbm2ddl.SchemaValidator : object {
    private static INHibernateLogger log;
    private Configuration configuration;
    private IConnectionHelper connectionHelper;
    private Dialect dialect;
    public SchemaValidator(Configuration cfg);
    public SchemaValidator(Configuration cfg, IDictionary`2<string, string> connectionProperties);
    public SchemaValidator(Configuration cfg, Settings settings);
    private static SchemaValidator();
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaValidator/<MainAsync>d__0")]
public static Task MainAsync(String[] args, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SchemaValidator/<ValidateAsync>d__1")]
public Task ValidateAsync(CancellationToken cancellationToken);
    public static void Main(String[] args);
    public void Validate();
}
internal abstract class NHibernate.Tool.hbm2ddl.ScriptReader : object {
    protected ScriptSplitter Splitter;
    protected bool HasNext { get; }
    protected bool WhiteSpace { get; }
    protected bool EndOfLine { get; }
    protected bool IsQuote { get; }
    protected char Current { get; }
    protected char LastChar { get; }
    private bool BeginDashDashComment { get; }
    private bool BeginSlashStarComment { get; }
    private bool EndSlashStarComment { get; }
    protected ScriptReader(ScriptSplitter splitter);
    public bool ReadNextSection();
    protected virtual bool ReadDashDashComment();
    protected virtual void ReadSlashStarComment();
    private bool ReadSlashStarCommentWithResult();
    protected virtual void ReadQuotedString();
    protected abstract virtual bool ReadNext();
    protected bool get_HasNext();
    protected bool get_WhiteSpace();
    protected bool get_EndOfLine();
    protected bool get_IsQuote();
    protected char get_Current();
    protected char get_LastChar();
    private bool get_BeginDashDashComment();
    private bool get_BeginSlashStarComment();
    private bool get_EndSlashStarComment();
    protected static bool CharEquals(char expected, char actual);
    protected bool CharEquals(char compare);
    protected char Peek();
}
public class NHibernate.Tool.hbm2ddl.ScriptSplitter : object {
    private TextReader _reader;
    private StringBuilder _builder;
    private char _current;
    private char _lastChar;
    private ScriptReader _scriptReader;
    internal bool HasNext { get; }
    internal char Current { get; }
    internal char LastChar { get; }
    public ScriptSplitter(string script);
    internal bool get_HasNext();
    internal char get_Current();
    internal char get_LastChar();
    [IteratorStateMachineAttribute("NHibernate.Tool.hbm2ddl.ScriptSplitter/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal bool Next();
    internal int Peek();
    private bool Split();
    internal void SetParser(ScriptReader newReader);
    internal void Append(string text);
    internal void Append(char c);
    private void Reset();
}
internal class NHibernate.Tool.hbm2ddl.SeparatorLineReader : ScriptReader {
    private StringBuilder _builder;
    private bool _foundGo;
    private bool _gFound;
    public SeparatorLineReader(ScriptSplitter splitter);
    private void Reset();
    protected virtual bool ReadDashDashComment();
    protected virtual void ReadSlashStarComment();
    protected virtual bool ReadNext();
    private void FoundNonEmptyCharacter(char c);
}
internal class NHibernate.Tool.hbm2ddl.SqlScriptReader : ScriptReader {
    public SqlScriptReader(ScriptSplitter splitter);
    protected virtual bool ReadNext();
}
public class NHibernate.Tool.hbm2ddl.SuppliedConnectionHelper : object {
    private DbConnection connection;
    public DbConnection Connection { get; }
    public SuppliedConnectionHelper(DbConnection connection);
    public sealed virtual Task PrepareAsync(CancellationToken cancellationToken);
    public sealed virtual void Prepare();
    public sealed virtual DbConnection get_Connection();
    public sealed virtual void Release();
}
public class NHibernate.Tool.hbm2ddl.SuppliedConnectionProviderConnectionHelper : object {
    private IConnectionProvider provider;
    private DbConnection connection;
    public DbConnection Connection { get; }
    public SuppliedConnectionProviderConnectionHelper(IConnectionProvider provider);
    [AsyncStateMachineAttribute("NHibernate.Tool.hbm2ddl.SuppliedConnectionProviderConnectionHelper/<PrepareAsync>d__0")]
public sealed virtual Task PrepareAsync(CancellationToken cancellationToken);
    public sealed virtual void Prepare();
    public sealed virtual DbConnection get_Connection();
    public sealed virtual void Release();
}
public class NHibernate.Transaction.AdoNetTransactionFactory : object {
    private static INHibernateLogger _isolatorLog;
    private static AdoNetTransactionFactory();
    public virtual Task ExecuteWorkInIsolationAsync(ISessionImplementor session, IIsolatedWork work, bool transacted, CancellationToken cancellationToken);
    public virtual ITransaction CreateTransaction(ISessionImplementor session);
    public virtual void EnlistInSystemTransactionIfNeeded(ISessionImplementor session);
    public virtual void ExplicitJoinSystemTransaction(ISessionImplementor session);
    public virtual bool IsInActiveSystemTransaction(ISessionImplementor session);
    public virtual void ExecuteWorkInIsolation(ISessionImplementor session, IIsolatedWork work, bool transacted);
    public virtual void Configure(IDictionary`2<string, string> props);
}
public class NHibernate.Transaction.AdoNetWithSystemTransactionFactory : AdoNetTransactionFactory {
    private static INHibernateLogger _logger;
    [CompilerGeneratedAttribute]
private int <SystemTransactionCompletionLockTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseConnectionOnSystemTransactionPrepare>k__BackingField;
    protected int SystemTransactionCompletionLockTimeout { get; private set; }
    protected bool UseConnectionOnSystemTransactionPrepare { get; private set; }
    private static AdoNetWithSystemTransactionFactory();
    [AsyncStateMachineAttribute("NHibernate.Transaction.AdoNetWithSystemTransactionFactory/<ExecuteWorkInIsolationAsync>d__0")]
public virtual Task ExecuteWorkInIsolationAsync(ISessionImplementor session, IIsolatedWork work, bool transacted, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
protected int get_SystemTransactionCompletionLockTimeout();
    [CompilerGeneratedAttribute]
private void set_SystemTransactionCompletionLockTimeout(int value);
    [CompilerGeneratedAttribute]
protected bool get_UseConnectionOnSystemTransactionPrepare();
    [CompilerGeneratedAttribute]
private void set_UseConnectionOnSystemTransactionPrepare(bool value);
    public virtual void Configure(IDictionary`2<string, string> props);
    public virtual void EnlistInSystemTransactionIfNeeded(ISessionImplementor session);
    private static bool ShouldAutoJoinSystemTransaction(ISessionImplementor session);
    public virtual void ExplicitJoinSystemTransaction(ISessionImplementor session);
    protected virtual void JoinSystemTransaction(ISessionImplementor session, Transaction transaction);
    protected virtual ITransactionContext CreateAndEnlistMainContext(ISessionImplementor session, Transaction transaction);
    private void EnlistDependentSession(ISessionImplementor dependentSession, ITransactionContext mainContext);
    protected virtual ITransactionContext CreateDependentContext(ISessionImplementor dependentSession, ITransactionContext mainContext);
    public virtual bool IsInActiveSystemTransaction(ISessionImplementor session);
    public virtual void ExecuteWorkInIsolation(ISessionImplementor session, IIsolatedWork work, bool transacted);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(ISessionImplementor session, IIsolatedWork work, bool transacted, CancellationToken cancellationToken);
}
public class NHibernate.Transaction.AdoTransaction : object {
    private static INHibernateLogger log;
    private ISessionImplementor session;
    private DbTransaction trans;
    private bool begun;
    private bool committed;
    private bool rolledBack;
    private bool commitFailed;
    [ObsoleteAttribute]
private List`1<ISynchronization> synchronizations;
    private List`1<ITransactionCompletionSynchronization> _completionSynchronizations;
    private bool _isAlreadyDisposed;
    private Guid sessionId;
    public bool WasRolledBack { get; }
    public bool WasCommitted { get; }
    public bool IsActive { get; }
    public IsolationLevel IsolationLevel { get; }
    public AdoTransaction(ISessionImplementor session);
    private static AdoTransaction();
    [AsyncStateMachineAttribute("NHibernate.Transaction.AdoTransaction/<AfterTransactionCompletionAsync>d__0")]
private Task AfterTransactionCompletionAsync(bool successful, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Transaction.AdoTransaction/<CommitAsync>d__1")]
public sealed virtual Task CommitAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Transaction.AdoTransaction/<RollbackAsync>d__2")]
public sealed virtual Task RollbackAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Transaction.AdoTransaction/<DisposeAsync>d__3")]
protected virtual Task DisposeAsync(bool isDisposing, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Transaction.AdoTransaction/<NotifyLocalSynchsBeforeTransactionCompletionAsync>d__4")]
private Task NotifyLocalSynchsBeforeTransactionCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Transaction.AdoTransaction/<NotifyLocalSynchsAfterTransactionCompletionAsync>d__5")]
private Task NotifyLocalSynchsAfterTransactionCompletionAsync(bool success, CancellationToken cancellationToken);
    public sealed virtual void Enlist(DbCommand command);
    [ObsoleteAttribute("Use RegisterSynchronization(ITransactionCompletionSynchronization) instead")]
public sealed virtual void RegisterSynchronization(ISynchronization sync);
    public void RegisterSynchronization(ITransactionCompletionSynchronization synchronization);
    public sealed virtual void Begin();
    public sealed virtual void Begin(IsolationLevel isolationLevel);
    private void AfterTransactionCompletion(bool successful);
    public sealed virtual void Commit();
    public sealed virtual void Rollback();
    public sealed virtual bool get_WasRolledBack();
    public sealed virtual bool get_WasCommitted();
    public sealed virtual bool get_IsActive();
    public IsolationLevel get_IsolationLevel();
    private void CloseIfRequired();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    private void CheckNotDisposed();
    private void CheckBegun();
    private void CheckNotZombied();
    private void NotifyLocalSynchsBeforeTransactionCompletion();
    private void NotifyLocalSynchsAfterTransactionCompletion(bool success);
}
[ObsoleteAttribute("This class has no more usages and will be removed in a future version")]
public class NHibernate.Transaction.AfterTransactionCompletes : object {
    private Action`1<bool> _whenCompleted;
    public AfterTransactionCompletes(Action`1<bool> whenCompleted);
    public sealed virtual void BeforeCompletion();
    public sealed virtual void AfterCompletion(bool success);
}
[ObsoleteAttribute("Implement ITransactionCompletionSynchronization instead. If implementing ITransaction, implement a 'public void RegisterSynchronization(ITransactionCompletionSynchronization)': the TransactionExtensions extension method will call it.")]
public interface NHibernate.Transaction.ISynchronization {
    public abstract virtual void BeforeCompletion();
    public abstract virtual void AfterCompletion(bool success);
}
public interface NHibernate.Transaction.ITransactionCompletionSynchronization {
}
public interface NHibernate.Transaction.ITransactionContext {
    public bool IsInActiveTransaction { get; }
    public bool ShouldCloseSessionOnSystemTransactionCompleted { get; public set; }
    public bool CanFlushOnSystemTransactionCompleted { get; }
    public abstract virtual bool get_IsInActiveTransaction();
    public abstract virtual bool get_ShouldCloseSessionOnSystemTransactionCompleted();
    public abstract virtual void set_ShouldCloseSessionOnSystemTransactionCompleted(bool value);
    public abstract virtual bool get_CanFlushOnSystemTransactionCompleted();
    public abstract virtual void Wait();
}
public interface NHibernate.Transaction.ITransactionFactory {
    public abstract virtual Task ExecuteWorkInIsolationAsync(ISessionImplementor session, IIsolatedWork work, bool transacted, CancellationToken cancellationToken);
    public abstract virtual void Configure(IDictionary`2<string, string> props);
    public abstract virtual ITransaction CreateTransaction(ISessionImplementor session);
    public abstract virtual void EnlistInSystemTransactionIfNeeded(ISessionImplementor session);
    public abstract virtual void ExplicitJoinSystemTransaction(ISessionImplementor session);
    public abstract virtual bool IsInActiveSystemTransaction(ISessionImplementor session);
    public abstract virtual void ExecuteWorkInIsolation(ISessionImplementor session, IIsolatedWork work, bool transacted);
}
public class NHibernate.TransactionException : HibernateException {
    public TransactionException(string message);
    public TransactionException(string message, Exception innerException);
    protected TransactionException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class NHibernate.TransactionExtensions : object {
    [ExtensionAttribute]
public static void RegisterSynchronization(ITransaction transaction, ITransactionCompletionSynchronization synchronization);
}
public abstract class NHibernate.Transform.AliasedTupleSubsetResultTransformer : object {
    public abstract virtual bool IsTransformedValueATupleElement(String[] aliases, int tupleLength);
    public sealed virtual Boolean[] IncludeInTransform(String[] aliases, int tupleLength);
    public abstract virtual object TransformTuple(Object[] tuple, String[] aliases);
    public abstract virtual IList TransformList(IList collection);
}
public class NHibernate.Transform.AliasToBeanConstructorResultTransformer : object {
    private ConstructorInfo constructor;
    public AliasToBeanConstructorResultTransformer(ConstructorInfo constructor);
    public sealed virtual object TransformTuple(Object[] tuple, String[] aliases);
    public sealed virtual IList TransformList(IList collection);
    public bool Equals(AliasToBeanConstructorResultTransformer other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NHibernate.Transform.AliasToBeanResultTransformer : AliasedTupleSubsetResultTransformer {
    private Dictionary`2<string, NamedMember`1<FieldInfo>> _fieldsByNameCaseSensitive;
    private Dictionary`2<string, NamedMember`1<FieldInfo>> _fieldsByNameCaseInsensitive;
    private Dictionary`2<string, NamedMember`1<PropertyInfo>> _propertiesByNameCaseSensitive;
    private Dictionary`2<string, NamedMember`1<PropertyInfo>> _propertiesByNameCaseInsensitive;
    [CompilerGeneratedAttribute]
private Type <ResultClass>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <BeanConstructor>k__BackingField;
    protected Type ResultClass { get; }
    protected ConstructorInfo BeanConstructor { get; }
    public AliasToBeanResultTransformer(Type resultClass);
    [CompilerGeneratedAttribute]
protected Type get_ResultClass();
    [CompilerGeneratedAttribute]
protected ConstructorInfo get_BeanConstructor();
    public virtual bool IsTransformedValueATupleElement(String[] aliases, int tupleLength);
    public virtual object TransformTuple(Object[] tuple, String[] aliases);
    public virtual IList TransformList(IList collection);
    protected virtual void OnPropertyNotFound(string propertyName);
    protected void SetProperty(string alias, object value, object resultObj);
    private bool TrySet(string alias, object value, object resultObj, Dictionary`2<string, NamedMember`1<FieldInfo>> fieldsMap);
    private bool TrySet(string alias, object value, object resultObj, Dictionary`2<string, NamedMember`1<PropertyInfo>> propertiesMap);
    private void CheckMember(NamedMember`1<T> member, string alias);
    private void FetchFieldsAndProperties(List`1<RankedMember`1<FieldInfo>> fields, List`1<RankedMember`1<PropertyInfo>> properties);
    private int GetFieldVisibilityRank(FieldInfo field);
    private int GetPropertyVisibilityRank(PropertyInfo property);
    private Dictionary`2<string, NamedMember`1<T>> GetMapByName(IEnumerable`1<RankedMember`1<T>> members, StringComparer comparer);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AliasToBeanResultTransformer other);
    public virtual int GetHashCode();
}
public class NHibernate.Transform.AliasToEntityMapResultTransformer : AliasedTupleSubsetResultTransformer {
    internal static AliasToEntityMapResultTransformer Instance;
    private static AliasToEntityMapResultTransformer();
    public virtual object TransformTuple(Object[] tuple, String[] aliases);
    public virtual IList TransformList(IList collection);
    public virtual bool IsTransformedValueATupleElement(String[] aliases, int tupleLength);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NHibernate.Transform.CacheableResultTransformer : object {
    private PassThroughResultTransformer _actualTransformer;
    [CompilerGeneratedAttribute]
private bool <AutoDiscoverTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AutoDiscoveredAliases>k__BackingField;
    private SqlString _autoDiscoveredQuery;
    private bool _skipTransformer;
    private int _tupleLength;
    private int _tupleSubsetLength;
    private Boolean[] _includeInTuple;
    private Int32[] _includeInTransformIndex;
    public bool AutoDiscoverTypes { get; }
    public String[] AutoDiscoveredAliases { get; private set; }
    private CacheableResultTransformer(Boolean[] includeInTuple, Boolean[] includeInTransform, bool skipTransformer);
    private CacheableResultTransformer(SqlString autoDiscoveredQuery);
    [CompilerGeneratedAttribute]
public bool get_AutoDiscoverTypes();
    [CompilerGeneratedAttribute]
public String[] get_AutoDiscoveredAliases();
    [CompilerGeneratedAttribute]
private void set_AutoDiscoveredAliases(String[] value);
    [ObsoleteAttribute("Please use overload with skipTransformer parameter.")]
public static CacheableResultTransformer Create(IResultTransformer transformer, String[] aliases, Boolean[] includeInTuple);
    [ObsoleteAttribute("Please use overload with skipTransformer parameter.")]
public static CacheableResultTransformer Create(IResultTransformer transformer, String[] aliases, Boolean[] includeInTuple, bool autoDiscoverTypes, SqlString autoDiscoveredQuery);
    public static CacheableResultTransformer Create(IResultTransformer transformer, String[] aliases, Boolean[] includeInTuple, bool autoDiscoverTypes, SqlString autoDiscoveredQuery, bool skipTransformer);
    private static CacheableResultTransformer Create(Boolean[] includeInTuple, Boolean[] includeInTransform, bool skipTransformer);
    private static CacheableResultTransformer Create(SqlString autoDiscoveredQuery);
    private static Boolean[] GetIncludeInTransform(IResultTransformer transformer, String[] aliases, Boolean[] includeInTuple);
    private void InitializeTransformer(Boolean[] includeInTuple, Boolean[] includeInTransform);
    internal void SupplyAutoDiscoveredParameters(IResultTransformer transformer, String[] aliases);
    public sealed virtual object TransformTuple(Object[] tuple, String[] aliases);
    public IList RetransformResults(IList transformedResults, String[] aliases, IResultTransformer transformer, Boolean[] includeInTuple);
    public IList UntransformToTuples(IList results);
    public IType[] GetCachedResultTypes(IType[] tupleResultTypes);
    public sealed virtual IList TransformList(IList list);
    private T[] Index(T[] objects);
    private T[] Unindex(T[] objects);
    public virtual bool Equals(object o);
    private bool HasSameParameters(CacheableResultTransformer other);
    public virtual int GetHashCode();
}
public class NHibernate.Transform.DistinctRootEntityResultTransformer : object {
    private static INHibernateLogger log;
    internal static DistinctRootEntityResultTransformer Instance;
    private static DistinctRootEntityResultTransformer();
    public sealed virtual object TransformTuple(Object[] tuple, String[] aliases);
    public sealed virtual IList TransformList(IList list);
    internal static List`1<T> TransformList(IEnumerable`1<T> list);
    public sealed virtual Boolean[] IncludeInTransform(String[] aliases, int tupleLength);
    public sealed virtual bool IsTransformedValueATupleElement(String[] aliases, int tupleLength);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface NHibernate.Transform.IResultTransformer {
    public abstract virtual object TransformTuple(Object[] tuple, String[] aliases);
    public abstract virtual IList TransformList(IList collection);
}
public interface NHibernate.Transform.ITupleSubsetResultTransformer {
    public abstract virtual bool IsTransformedValueATupleElement(String[] aliases, int tupleLength);
    public abstract virtual Boolean[] IncludeInTransform(String[] aliases, int tupleLength);
}
public class NHibernate.Transform.PassThroughResultTransformer : object {
    internal static PassThroughResultTransformer Instance;
    private static PassThroughResultTransformer();
    public sealed virtual object TransformTuple(Object[] tuple, String[] aliases);
    public sealed virtual IList TransformList(IList collection);
    public sealed virtual bool IsTransformedValueATupleElement(String[] aliases, int tupleLength);
    public sealed virtual Boolean[] IncludeInTransform(String[] aliases, int tupleLength);
    internal IList UntransformToTuples(IList results, bool isSingleResult);
    internal Object[] UntransformToTuple(object transformed, bool isSingleResult);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NHibernate.Transform.RootEntityResultTransformer : object {
    internal static RootEntityResultTransformer Instance;
    private static RootEntityResultTransformer();
    public sealed virtual object TransformTuple(Object[] tuple, String[] aliases);
    public sealed virtual IList TransformList(IList collection);
    public sealed virtual bool IsTransformedValueATupleElement(String[] aliases, int tupleLength);
    public sealed virtual Boolean[] IncludeInTransform(String[] aliases, int tupleLength);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NHibernate.Transform.ToListResultTransformer : object {
    internal static ToListResultTransformer Instance;
    private static ToListResultTransformer();
    public sealed virtual object TransformTuple(Object[] tuple, String[] aliases);
    public sealed virtual IList TransformList(IList list);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NHibernate.Transform.Transformers : object {
    public static IResultTransformer AliasToEntityMap;
    public static ToListResultTransformer ToList;
    public static IResultTransformer DistinctRootEntity;
    public static IResultTransformer PassThrough;
    public static IResultTransformer RootEntity;
    private static Transformers();
    public static IResultTransformer AliasToBean(Type target);
    public static IResultTransformer AliasToBean();
    public static IResultTransformer AliasToBeanConstructor(ConstructorInfo constructor);
}
public class NHibernate.TransientObjectException : HibernateException {
    public TransientObjectException(string message);
    protected TransientObjectException(SerializationInfo info, StreamingContext context);
}
public abstract class NHibernate.Tuple.Component.AbstractComponentTuplizer : object {
    private static INHibernateLogger log;
    protected internal int propertySpan;
    protected internal IGetter[] getters;
    protected internal ISetter[] setters;
    protected internal IInstantiator instantiator;
    protected internal bool hasCustomAccessors;
    public bool HasParentProperty { get; }
    public Type MappedClass { get; }
    protected internal AbstractComponentTuplizer(Component component);
    private static AbstractComponentTuplizer();
    public virtual object GetParent(object component);
    public virtual void SetParent(object component, object parent, ISessionFactoryImplementor factory);
    public virtual bool get_HasParentProperty();
    public abstract virtual Type get_MappedClass();
    public virtual Object[] GetPropertyValues(object component);
    public virtual void SetPropertyValues(object component, Object[] values);
    public virtual object GetPropertyValue(object component, int i);
    public virtual object Instantiate();
    public virtual bool IsInstance(object obj);
    protected internal abstract virtual IInstantiator BuildInstantiator(Component component);
    protected internal abstract virtual IGetter BuildGetter(Component component, Property prop);
    protected internal abstract virtual ISetter BuildSetter(Component component, Property prop);
}
public class NHibernate.Tuple.Component.ComponentMetamodel : object {
    private string role;
    private bool isKey;
    private int propertySpan;
    private StandardProperty[] properties;
    private Dictionary`2<string, int> propertyIndexes;
    [CompilerGeneratedAttribute]
private EntityMode <EntityMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentTuplizer <ComponentTuplizer>k__BackingField;
    public string Role { get; }
    public bool IsKey { get; }
    public int PropertySpan { get; }
    public StandardProperty[] Properties { get; }
    public EntityMode EntityMode { get; }
    public IComponentTuplizer ComponentTuplizer { get; }
    public ComponentMetamodel(Component component);
    public string get_Role();
    public bool get_IsKey();
    public int get_PropertySpan();
    public StandardProperty[] get_Properties();
    public StandardProperty GetProperty(int index);
    public int GetPropertyIndex(string propertyName);
    public StandardProperty GetProperty(string propertyName);
    [CompilerGeneratedAttribute]
public EntityMode get_EntityMode();
    [CompilerGeneratedAttribute]
public IComponentTuplizer get_ComponentTuplizer();
}
public class NHibernate.Tuple.Component.ComponentTuplizerFactory : object {
    private static Type[] ComponentTuplizerCtorSignature;
    private static ComponentTuplizerFactory();
    public IComponentTuplizer BuildDefaultComponentTuplizer(EntityMode entityMode, Component component);
    public IComponentTuplizer BuildComponentTuplizer(string tuplizerImpl, Component component);
}
internal class NHibernate.Tuple.Component.DynamicComponentInstantiator : object {
    public sealed virtual object Instantiate(object id);
    public sealed virtual object Instantiate();
    public sealed virtual bool IsInstance(object obj);
}
public class NHibernate.Tuple.Component.DynamicMapComponentTuplizer : AbstractComponentTuplizer {
    public Type MappedClass { get; }
    public DynamicMapComponentTuplizer(Component component);
    public virtual Type get_MappedClass();
    protected internal virtual IInstantiator BuildInstantiator(Component component);
    protected internal virtual IGetter BuildGetter(Component component, Property prop);
    protected internal virtual ISetter BuildSetter(Component component, Property prop);
}
public interface NHibernate.Tuple.Component.IComponentTuplizer {
    public bool HasParentProperty { get; }
    public abstract virtual object GetParent(object component);
    public abstract virtual void SetParent(object component, object parent, ISessionFactoryImplementor factory);
    public abstract virtual bool get_HasParentProperty();
}
public class NHibernate.Tuple.Component.PocoComponentTuplizer : AbstractComponentTuplizer {
    private Type componentClass;
    private ISetter parentSetter;
    private IGetter parentGetter;
    private IReflectionOptimizer optimizer;
    private bool isBytecodeProviderImpl;
    public Type MappedClass { get; }
    public bool HasParentProperty { get; }
    public PocoComponentTuplizer(Component component);
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext context);
    public virtual Type get_MappedClass();
    public virtual Object[] GetPropertyValues(object component);
    public virtual void SetPropertyValues(object component, Object[] values);
    public virtual object GetPropertyValue(object component, int i);
    public virtual object GetParent(object component);
    public virtual void SetParent(object component, object parent, ISessionFactoryImplementor factory);
    public virtual bool get_HasParentProperty();
    protected internal virtual IInstantiator BuildInstantiator(Component component);
    protected internal virtual IGetter BuildGetter(Component component, Property prop);
    protected internal virtual ISetter BuildSetter(Component component, Property prop);
    protected void SetReflectionOptimizer();
    protected void ClearOptimizerWhenUsingCustomAccessors();
}
public class NHibernate.Tuple.DynamicEntityInstantiator : object {
    public static string Key;
    private string _entityName;
    private HashSet`1<string> _isInstanceEntityNames;
    public DynamicEntityInstantiator(PersistentClass mappingInfo);
    public sealed virtual object Instantiate(object id);
    public sealed virtual object Instantiate();
    public sealed virtual bool IsInstance(object obj);
}
[ObsoleteAttribute("This class is not used and will be removed in a future version.")]
public class NHibernate.Tuple.DynamicMapInstantiator : object {
    public static string KEY;
    private string entityName;
    private HashSet`1<string> isInstanceEntityNames;
    public DynamicMapInstantiator(PersistentClass mappingInfo);
    public sealed virtual object Instantiate(object id);
    public sealed virtual object Instantiate();
    protected virtual IDictionary GenerateMap();
    public sealed virtual bool IsInstance(object obj);
}
public abstract class NHibernate.Tuple.Entity.AbstractEntityTuplizer : object {
    private static INHibernateLogger log;
    private EntityMetamodel entityMetamodel;
    protected IGetter idGetter;
    protected ISetter idSetter;
    protected int propertySpan;
    protected IGetter[] getters;
    protected ISetter[] setters;
    protected bool hasCustomAccessors;
    private IProxyFactory proxyFactory;
    private IAbstractComponentType identifierMapperType;
    [CompilerGeneratedAttribute]
private IInstantiator <Instantiator>k__BackingField;
    public bool IsLifecycleImplementor { get; }
    public bool IsValidatableImplementor { get; }
    public Type ConcreteProxyClass { get; }
    public bool IsInstrumented { get; }
    public bool HasProxy { get; }
    public Type MappedClass { get; }
    public EntityMode EntityMode { get; }
    protected IInstantiator Instantiator { get; protected set; }
    protected string EntityName { get; }
    protected ISet`1<string> SubclassEntityNames { get; }
    protected IProxyFactory ProxyFactory { get; }
    protected EntityMetamodel EntityMetamodel { get; }
    protected AbstractEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappingInfo);
    private static AbstractEntityTuplizer();
    public virtual bool get_IsLifecycleImplementor();
    public virtual bool get_IsValidatableImplementor();
    public abstract virtual Type get_ConcreteProxyClass();
    public abstract virtual bool get_IsInstrumented();
    public sealed virtual object Instantiate(object id);
    public sealed virtual object GetIdentifier(object entity);
    public sealed virtual void SetIdentifier(object entity, object id);
    public sealed virtual void ResetIdentifier(object entity, object currentId, object currentVersion);
    public sealed virtual object GetVersion(object entity);
    public virtual void SetPropertyValue(object entity, int i, object value);
    public sealed virtual void SetPropertyValue(object entity, string propertyName, object value);
    public virtual Object[] GetPropertyValuesToInsert(object entity, IDictionary mergeMap, ISessionImplementor session);
    public sealed virtual object GetPropertyValue(object entity, string propertyPath);
    [ObsoleteAttribute("Use overload without lazyPropertiesAreUnfetched parameter")]
public virtual void AfterInitialize(object entity, bool lazyPropertiesAreUnfetched, ISessionImplementor session);
    public virtual void AfterInitialize(object entity, ISessionImplementor session);
    public sealed virtual bool get_HasProxy();
    public sealed virtual object CreateProxy(object id, ISessionImplementor session);
    public virtual bool HasUninitializedLazyProperties(object entity);
    internal virtual ISet`1<string> GetUninitializedLazyProperties(object entity);
    public abstract virtual Type get_MappedClass();
    public virtual Object[] GetPropertyValues(object entity);
    public virtual void SetPropertyValues(object entity, Object[] values);
    public virtual object GetPropertyValue(object entity, int i);
    public sealed virtual object Instantiate();
    public sealed virtual bool IsInstance(object obj);
    protected virtual object GetIdentifierPropertyValue(object entity);
    protected virtual void SetIdentifierPropertyValue(object entity, object value);
    public abstract virtual EntityMode get_EntityMode();
    [CompilerGeneratedAttribute]
protected virtual IInstantiator get_Instantiator();
    [CompilerGeneratedAttribute]
protected virtual void set_Instantiator(IInstantiator value);
    protected virtual string get_EntityName();
    protected virtual ISet`1<string> get_SubclassEntityNames();
    protected abstract virtual IGetter BuildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity);
    protected abstract virtual ISetter BuildPropertySetter(Property mappedProperty, PersistentClass mappedEntity);
    protected abstract virtual IInstantiator BuildInstantiator(PersistentClass mappingInfo);
    protected abstract virtual IProxyFactory BuildProxyFactory(PersistentClass mappingInfo, IGetter idGetter, ISetter idSetter);
    protected virtual object GetComponentValue(ComponentType type, object component, string propertyPath);
    protected virtual IProxyFactory get_ProxyFactory();
    protected virtual bool ShouldGetAllProperties(object entity);
    protected EntityMetamodel get_EntityMetamodel();
}
public class NHibernate.Tuple.Entity.BytecodeEnhancementMetadataNonPocoImpl : object {
    private string _errorMessage;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyPropertiesMetadata <LazyPropertiesMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private UnwrapProxyPropertiesMetadata <UnwrapProxyPropertiesMetadata>k__BackingField;
    public string EntityName { get; }
    public bool EnhancedForLazyLoading { get; }
    public LazyPropertiesMetadata LazyPropertiesMetadata { get; }
    public UnwrapProxyPropertiesMetadata UnwrapProxyPropertiesMetadata { get; }
    public BytecodeEnhancementMetadataNonPocoImpl(string entityName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EntityName();
    public sealed virtual bool get_EnhancedForLazyLoading();
    [CompilerGeneratedAttribute]
public sealed virtual LazyPropertiesMetadata get_LazyPropertiesMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual UnwrapProxyPropertiesMetadata get_UnwrapProxyPropertiesMetadata();
    public sealed virtual IFieldInterceptor InjectInterceptor(object entity, ISessionImplementor session);
    public sealed virtual IFieldInterceptor ExtractInterceptor(object entity);
    public sealed virtual ISet`1<string> GetUninitializedLazyProperties(object entity);
    public sealed virtual ISet`1<string> GetUninitializedLazyProperties(Object[] entityState);
    public sealed virtual bool HasAnyUninitializedLazyProperties(object entity);
}
public class NHibernate.Tuple.Entity.BytecodeEnhancementMetadataPocoImpl : object {
    private Type _entityType;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnhancedForLazyLoading>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyPropertiesMetadata <LazyPropertiesMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private UnwrapProxyPropertiesMetadata <UnwrapProxyPropertiesMetadata>k__BackingField;
    public string EntityName { get; }
    public bool EnhancedForLazyLoading { get; }
    public LazyPropertiesMetadata LazyPropertiesMetadata { get; }
    public UnwrapProxyPropertiesMetadata UnwrapProxyPropertiesMetadata { get; }
    public BytecodeEnhancementMetadataPocoImpl(string entityName, Type entityType, bool enhancedForLazyLoading, LazyPropertiesMetadata lazyPropertiesMetadata, UnwrapProxyPropertiesMetadata unwrapProxyPropertiesMetadata);
    public static IBytecodeEnhancementMetadata From(PersistentClass persistentClass, ICollection`1<LazyPropertyDescriptor> lazyPropertyDescriptors, ICollection`1<UnwrapProxyPropertyDescriptor> unwrapProxyPropertyDescriptors);
    private static bool IsEnhancedForLazyLoading(PersistentClass persistentClass);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EntityName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnhancedForLazyLoading();
    [CompilerGeneratedAttribute]
public sealed virtual LazyPropertiesMetadata get_LazyPropertiesMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual UnwrapProxyPropertiesMetadata get_UnwrapProxyPropertiesMetadata();
    public sealed virtual IFieldInterceptor InjectInterceptor(object entity, ISessionImplementor session);
    public sealed virtual IFieldInterceptor ExtractInterceptor(object entity);
    public sealed virtual ISet`1<string> GetUninitializedLazyProperties(object entity);
    public sealed virtual ISet`1<string> GetUninitializedLazyProperties(Object[] entityState);
    public sealed virtual bool HasAnyUninitializedLazyProperties(object entity);
}
public class NHibernate.Tuple.Entity.DynamicMapEntityTuplizer : AbstractEntityTuplizer {
    private static INHibernateLogger log;
    public Type ConcreteProxyClass { get; }
    public bool IsInstrumented { get; }
    public Type MappedClass { get; }
    public EntityMode EntityMode { get; }
    internal DynamicMapEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappingInfo);
    private static DynamicMapEntityTuplizer();
    public virtual Type get_ConcreteProxyClass();
    public virtual bool get_IsInstrumented();
    public virtual Type get_MappedClass();
    public virtual EntityMode get_EntityMode();
    protected virtual IGetter BuildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity);
    private IPropertyAccessor BuildPropertyAccessor(Property property);
    protected virtual ISetter BuildPropertySetter(Property mappedProperty, PersistentClass mappedEntity);
    protected virtual IInstantiator BuildInstantiator(PersistentClass mappingInfo);
    protected virtual IProxyFactory BuildProxyFactory(PersistentClass mappingInfo, IGetter idGetter, ISetter idSetter);
}
public class NHibernate.Tuple.Entity.EntityMetamodel : object {
    private static INHibernateLogger log;
    private static int NoVersionIndex;
    private ISessionFactoryImplementor sessionFactory;
    private string name;
    private string rootName;
    private Type type;
    private Type rootType;
    private string rootTypeAssemblyQualifiedName;
    private EntityType entityType;
    private IdentifierProperty identifierProperty;
    private bool versioned;
    private int propertySpan;
    private int versionPropertyIndex;
    private StandardProperty[] properties;
    private String[] propertyNames;
    private IType[] propertyTypes;
    private Boolean[] propertyLaziness;
    private Boolean[] propertyUpdateability;
    private Boolean[] nonlazyPropertyUpdateability;
    private Boolean[] propertyCheckability;
    private Boolean[] propertyInsertability;
    private ValueInclusion[] insertInclusions;
    private ValueInclusion[] updateInclusions;
    private Boolean[] propertyNullability;
    private Boolean[] propertyVersionability;
    private CascadeStyle[] cascadeStyles;
    private Dictionary`2<string, Nullable`1<int>> propertyIndexes;
    private IDictionary`2<string, IType> _identifierPropertyTypes;
    private IDictionary`2<string, IType> _propertyTypes;
    private bool hasCollections;
    private bool hasMutableProperties;
    private bool hasLazyProperties;
    private Int32[] naturalIdPropertyNumbers;
    private bool lazy;
    private bool hasCascades;
    private bool hasNonIdentifierPropertyNamedId;
    private bool mutable;
    private bool isAbstract;
    private bool selectBeforeUpdate;
    private bool dynamicUpdate;
    private bool dynamicInsert;
    private OptimisticLock optimisticLockMode;
    private bool polymorphic;
    private string superclass;
    private Type superclassType;
    private bool explicitPolymorphism;
    private bool inherited;
    private bool hasSubclasses;
    private HashSet`1<string> subclassEntityNames;
    private bool hasInsertGeneratedValues;
    private bool hasUpdateGeneratedValues;
    [CompilerGeneratedAttribute]
private bool <HasPocoRepresentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverridesEquals>k__BackingField;
    private bool hasUnwrapProxyForProperties;
    [CompilerGeneratedAttribute]
private IEntityTuplizer <Tuplizer>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityMode <EntityMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IBytecodeEnhancementMetadata <BytecodeEnhancementMetadata>k__BackingField;
    public bool HasPocoRepresentation { get; private set; }
    public ISet`1<string> SubclassEntityNames { get; }
    public ISessionFactoryImplementor SessionFactory { get; }
    public Type Type { get; }
    public Type RootType { get; }
    public string RootTypeAssemblyQualifiedName { get; }
    public string Name { get; }
    public string RootName { get; }
    public EntityType EntityType { get; }
    public IdentifierProperty IdentifierProperty { get; }
    public int PropertySpan { get; }
    public int VersionPropertyIndex { get; }
    public VersionProperty VersionProperty { get; }
    public StandardProperty[] Properties { get; }
    internal bool OverridesEquals { get; private set; }
    public bool HasCollections { get; }
    public bool HasMutableProperties { get; }
    public bool HasLazyProperties { get; }
    public bool HasCascades { get; }
    public bool IsMutable { get; }
    public bool IsSelectBeforeUpdate { get; }
    public bool IsDynamicUpdate { get; }
    public bool IsDynamicInsert { get; }
    public OptimisticLock OptimisticLockMode { get; }
    public bool IsPolymorphic { get; }
    public string Superclass { get; }
    public Type SuperclassType { get; }
    public bool IsExplicitPolymorphism { get; }
    public bool IsInherited { get; }
    public bool HasSubclasses { get; }
    public bool IsLazy { get; public set; }
    public bool IsVersioned { get; }
    public bool IsAbstract { get; }
    public String[] PropertyNames { get; }
    public IType[] PropertyTypes { get; }
    public Boolean[] PropertyLaziness { get; }
    public Boolean[] PropertyUpdateability { get; }
    public Boolean[] PropertyCheckability { get; }
    public Boolean[] NonlazyPropertyUpdateability { get; }
    public Boolean[] PropertyInsertability { get; }
    public Boolean[] PropertyNullability { get; }
    public Boolean[] PropertyVersionability { get; }
    public CascadeStyle[] CascadeStyles { get; }
    public ValueInclusion[] PropertyInsertGenerationInclusions { get; }
    public ValueInclusion[] PropertyUpdateGenerationInclusions { get; }
    public bool HasInsertGeneratedValues { get; }
    public bool HasUpdateGeneratedValues { get; }
    public IEntityTuplizer Tuplizer { get; }
    public EntityMode EntityMode { get; }
    public bool HasNaturalIdentifier { get; }
    public bool HasUnwrapProxyForProperties { get; }
    public bool HasNonIdentifierPropertyNamedId { get; }
    public Int32[] NaturalIdentifierProperties { get; }
    public IBytecodeEnhancementMetadata BytecodeEnhancementMetadata { get; }
    public EntityMetamodel(PersistentClass persistentClass, ISessionFactoryImplementor sessionFactory);
    private static EntityMetamodel();
    [CompilerGeneratedAttribute]
public bool get_HasPocoRepresentation();
    [CompilerGeneratedAttribute]
private void set_HasPocoRepresentation(bool value);
    private ValueInclusion DetermineInsertValueGenerationType(Property mappingProperty, StandardProperty runtimeProperty);
    private bool HasPartialInsertComponentGeneration(Component component);
    private ValueInclusion DetermineUpdateValueGenerationType(Property mappingProperty, StandardProperty runtimeProperty);
    private bool HasPartialUpdateComponentGeneration(Component component);
    private void MapPropertyToIndex(Property prop, int i);
    private void MapPropertyToIndex(string path, Property prop, int i);
    private void MapIdentifierPropertyTypes(IdentifierProperty identifier);
    private void MapIdentifierPropertyTypes(string path, IType propertyType);
    public ISet`1<string> get_SubclassEntityNames();
    private bool IndicatesCollection(IType type);
    public ISessionFactoryImplementor get_SessionFactory();
    public Type get_Type();
    public Type get_RootType();
    public string get_RootTypeAssemblyQualifiedName();
    public string get_Name();
    public string get_RootName();
    public EntityType get_EntityType();
    public IdentifierProperty get_IdentifierProperty();
    public int get_PropertySpan();
    public int get_VersionPropertyIndex();
    public VersionProperty get_VersionProperty();
    public StandardProperty[] get_Properties();
    [CompilerGeneratedAttribute]
internal bool get_OverridesEquals();
    [CompilerGeneratedAttribute]
private void set_OverridesEquals(bool value);
    public int GetPropertyIndex(string propertyName);
    public Nullable`1<int> GetPropertyIndexOrNull(string propertyName);
    internal IType GetIdentifierPropertyType(string memberPath);
    internal IType GetPropertyType(string memberPath);
    public bool get_HasCollections();
    public bool get_HasMutableProperties();
    public bool get_HasLazyProperties();
    public bool get_HasCascades();
    public bool get_IsMutable();
    public bool get_IsSelectBeforeUpdate();
    public bool get_IsDynamicUpdate();
    public bool get_IsDynamicInsert();
    public OptimisticLock get_OptimisticLockMode();
    public bool get_IsPolymorphic();
    public string get_Superclass();
    public Type get_SuperclassType();
    public bool get_IsExplicitPolymorphism();
    public bool get_IsInherited();
    public bool get_HasSubclasses();
    public bool get_IsLazy();
    public void set_IsLazy(bool value);
    public bool get_IsVersioned();
    public bool get_IsAbstract();
    public virtual string ToString();
    public String[] get_PropertyNames();
    public IType[] get_PropertyTypes();
    public Boolean[] get_PropertyLaziness();
    public Boolean[] get_PropertyUpdateability();
    public Boolean[] get_PropertyCheckability();
    public Boolean[] get_NonlazyPropertyUpdateability();
    public Boolean[] get_PropertyInsertability();
    public Boolean[] get_PropertyNullability();
    public Boolean[] get_PropertyVersionability();
    public CascadeStyle[] get_CascadeStyles();
    public ValueInclusion[] get_PropertyInsertGenerationInclusions();
    public ValueInclusion[] get_PropertyUpdateGenerationInclusions();
    public bool get_HasInsertGeneratedValues();
    public bool get_HasUpdateGeneratedValues();
    [CompilerGeneratedAttribute]
public IEntityTuplizer get_Tuplizer();
    [CompilerGeneratedAttribute]
public EntityMode get_EntityMode();
    public bool get_HasNaturalIdentifier();
    public bool get_HasUnwrapProxyForProperties();
    public bool get_HasNonIdentifierPropertyNamedId();
    public Int32[] get_NaturalIdentifierProperties();
    [CompilerGeneratedAttribute]
public IBytecodeEnhancementMetadata get_BytecodeEnhancementMetadata();
}
[ExtensionAttribute]
public static class NHibernate.Tuple.Entity.EntityTuplizerExtensions : object {
    [ExtensionAttribute]
public static void AfterInitialize(IEntityTuplizer entityTuplizer, object entity, ISessionImplementor session);
}
public class NHibernate.Tuple.Entity.EntityTuplizerFactory : object {
    private static Type[] EntityTuplizerCtorSignature;
    private static EntityTuplizerFactory();
    public IEntityTuplizer BuildEntityTuplizer(string className, EntityMetamodel em, PersistentClass pc);
    public IEntityTuplizer BuildDefaultEntityTuplizer(EntityMode entityMode, EntityMetamodel entityMetamodel, PersistentClass persistentClass);
}
public interface NHibernate.Tuple.Entity.IEntityTuplizer {
    public bool IsLifecycleImplementor { get; }
    public bool IsValidatableImplementor { get; }
    public Type ConcreteProxyClass { get; }
    [ObsoleteAttribute("This property is not used and will be removed in a future version.")]
public bool IsInstrumented { get; }
    public bool HasProxy { get; }
    public abstract virtual bool get_IsLifecycleImplementor();
    public abstract virtual bool get_IsValidatableImplementor();
    public abstract virtual Type get_ConcreteProxyClass();
    public abstract virtual bool get_IsInstrumented();
    public abstract virtual object Instantiate(object id);
    public abstract virtual object GetIdentifier(object entity);
    public abstract virtual void SetIdentifier(object entity, object id);
    public abstract virtual void ResetIdentifier(object entity, object currentId, object currentVersion);
    public abstract virtual object GetVersion(object entity);
    public abstract virtual void SetPropertyValue(object entity, int i, object value);
    public abstract virtual void SetPropertyValue(object entity, string propertyName, object value);
    public abstract virtual Object[] GetPropertyValuesToInsert(object entity, IDictionary mergeMap, ISessionImplementor session);
    public abstract virtual object GetPropertyValue(object entity, string propertyName);
    [ObsoleteAttribute("Use the extension method instead")]
public abstract virtual void AfterInitialize(object entity, bool lazyPropertiesAreUnfetched, ISessionImplementor session);
    public abstract virtual bool get_HasProxy();
    public abstract virtual object CreateProxy(object id, ISessionImplementor session);
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public abstract virtual bool HasUninitializedLazyProperties(object entity);
}
public class NHibernate.Tuple.Entity.PocoEntityInstantiator : PocoInstantiator {
    private EntityMetamodel _entityMetamodel;
    private Type _proxyInterface;
    private bool _enhancedForLazyLoading;
    private IProxyFactory _proxyFactory;
    public PocoEntityInstantiator(EntityMetamodel entityMetamodel, PersistentClass persistentClass, IInstantiationOptimizer optimizer, IProxyFactory proxyFactory);
    protected virtual object CreateInstance();
    public virtual bool IsInstance(object obj);
}
public class NHibernate.Tuple.Entity.PocoEntityTuplizer : AbstractEntityTuplizer {
    private static INHibernateLogger log;
    private Type mappedClass;
    private Type proxyInterface;
    private bool islifecycleImplementor;
    private bool isValidatableImplementor;
    private IReflectionOptimizer optimizer;
    private IProxyValidator proxyValidator;
    private IBytecodeEnhancementMetadata _enhancementMetadata;
    private bool isBytecodeProviderImpl;
    public Type ConcreteProxyClass { get; }
    public bool IsInstrumented { get; }
    public Type MappedClass { get; }
    public bool IsLifecycleImplementor { get; }
    public bool IsValidatableImplementor { get; }
    public EntityMode EntityMode { get; }
    public PocoEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity);
    private static PocoEntityTuplizer();
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext context);
    protected void SetReflectionOptimizer();
    public virtual Type get_ConcreteProxyClass();
    public virtual bool get_IsInstrumented();
    public virtual Type get_MappedClass();
    protected virtual IGetter BuildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity);
    protected virtual ISetter BuildPropertySetter(Property mappedProperty, PersistentClass mappedEntity);
    protected virtual IInstantiator BuildInstantiator(PersistentClass persistentClass);
    protected virtual IProxyFactory BuildProxyFactory(PersistentClass persistentClass, IGetter idGetter, ISetter idSetter);
    private void LogPropertyAccessorsErrors(PersistentClass persistentClass);
    protected virtual IProxyFactory BuildProxyFactoryInternal(PersistentClass class, IGetter getter, ISetter setter);
    public virtual void AfterInitialize(object entity, ISessionImplementor session);
    public virtual object GetPropertyValue(object entity, int i);
    public virtual Object[] GetPropertyValues(object entity);
    private Object[] GetPropertyValuesWithOptimizer(object entity);
    public virtual Object[] GetPropertyValuesToInsert(object entity, IDictionary mergeMap, ISessionImplementor session);
    public virtual bool HasUninitializedLazyProperties(object entity);
    internal virtual ISet`1<string> GetUninitializedLazyProperties(object entity);
    public virtual bool get_IsLifecycleImplementor();
    public virtual void SetPropertyValue(object entity, int i, object value);
    public virtual void SetPropertyValues(object entity, Object[] values);
    private void SetPropertyValuesWithOptimizer(object entity, Object[] values);
    public virtual bool get_IsValidatableImplementor();
    public virtual EntityMode get_EntityMode();
    protected void ClearOptimizerWhenUsingCustomAccessors();
    protected virtual object GetIdentifierPropertyValue(object entity);
    protected virtual void SetIdentifierPropertyValue(object entity, object value);
}
public class NHibernate.Tuple.IdentifierProperty : Property {
    private bool isVirtual;
    private bool embedded;
    private IdentifierValue unsavedValue;
    private IIdentifierGenerator identifierGenerator;
    private bool identifierAssignedByInsert;
    private bool hasIdentifierMapper;
    public bool IsVirtual { get; }
    public bool IsEmbedded { get; }
    public IdentifierValue UnsavedValue { get; }
    public IIdentifierGenerator IdentifierGenerator { get; }
    public bool IsIdentifierAssignedByInsert { get; }
    public bool HasIdentifierMapper { get; }
    public IdentifierProperty(string name, IType type, bool embedded, IdentifierValue unsavedValue, IIdentifierGenerator identifierGenerator);
    public IdentifierProperty(IType type, bool embedded, bool hasIdentifierMapper, IdentifierValue unsavedValue, IIdentifierGenerator identifierGenerator);
    public bool get_IsVirtual();
    public bool get_IsEmbedded();
    public IdentifierValue get_UnsavedValue();
    public IIdentifierGenerator get_IdentifierGenerator();
    public bool get_IsIdentifierAssignedByInsert();
    public bool get_HasIdentifierMapper();
}
public interface NHibernate.Tuple.IInstantiator {
    public abstract virtual object Instantiate(object id);
    public abstract virtual object Instantiate();
    public abstract virtual bool IsInstance(object obj);
}
public interface NHibernate.Tuple.ITuplizer {
    public Type MappedClass { get; }
    public abstract virtual Type get_MappedClass();
    public abstract virtual Object[] GetPropertyValues(object entity);
    public abstract virtual void SetPropertyValues(object entity, Object[] values);
    public abstract virtual object GetPropertyValue(object entity, int i);
    public abstract virtual object Instantiate();
    public abstract virtual bool IsInstance(object obj);
}
public class NHibernate.Tuple.PocoInstantiator : object {
    private static INHibernateLogger log;
    private Type mappedClass;
    private IInstantiationOptimizer optimizer;
    private IProxyFactory proxyFactory;
    private bool generateFieldInterceptionProxy;
    private bool embeddedIdentifier;
    private bool _isAbstract;
    private ConstructorInfo constructor;
    private Type proxyInterface;
    public PocoInstantiator(Component component, IInstantiationOptimizer optimizer);
    [ObsoleteAttribute("Use PocoEntityInstantiator class instead.")]
public PocoInstantiator(PersistentClass persistentClass, IInstantiationOptimizer optimizer, IProxyFactory proxyFactory, bool generateFieldInterceptionProxy);
    public PocoInstantiator(Type mappedClass, IInstantiationOptimizer optimizer, bool embeddedIdentifier);
    private static PocoInstantiator();
    public sealed virtual object Instantiate(object id);
    public sealed virtual object Instantiate();
    protected virtual object CreateInstance();
    public virtual bool IsInstance(object obj);
    public sealed virtual void OnDeserialization(object sender);
    public void SetOptimizer(IInstantiationOptimizer optimizer);
}
public abstract class NHibernate.Tuple.Property : object {
    private string name;
    private IType type;
    public string Name { get; }
    public IType Type { get; }
    protected Property(string name, IType type);
    public string get_Name();
    public IType get_Type();
    public virtual string ToString();
}
public class NHibernate.Tuple.PropertyFactory : object {
    public static IdentifierProperty BuildIdentifierProperty(PersistentClass mappedEntity, IIdentifierGenerator generator);
    public static VersionProperty BuildVersionProperty(Property property, bool lazyAvailable);
    public static StandardProperty BuildStandardProperty(Property property, bool lazyAvailable);
    private static ConstructorInfo GetConstructor(PersistentClass persistentClass);
    private static IGetter GetGetter(Property mappingProperty);
}
public class NHibernate.Tuple.StandardProperty : Property {
    private bool lazy;
    private bool insertable;
    private bool updateable;
    private bool insertGenerated;
    private bool updateGenerated;
    private bool nullable;
    private bool dirtyCheckable;
    private bool versionable;
    private CascadeStyle cascadeStyle;
    private Nullable`1<FetchMode> fetchMode;
    public bool IsLazy { get; }
    public bool IsInsertable { get; }
    public bool IsUpdateable { get; }
    public bool IsInsertGenerated { get; }
    public bool IsUpdateGenerated { get; }
    public bool IsNullable { get; }
    public bool IsVersionable { get; }
    public CascadeStyle CascadeStyle { get; }
    public Nullable`1<FetchMode> FetchMode { get; }
    public StandardProperty(string name, IType type, bool lazy, bool insertable, bool updateable, bool insertGenerated, bool updateGenerated, bool nullable, bool checkable, bool versionable, CascadeStyle cascadeStyle, Nullable`1<FetchMode> fetchMode);
    public bool get_IsLazy();
    public bool get_IsInsertable();
    public bool get_IsUpdateable();
    public bool get_IsInsertGenerated();
    public bool get_IsUpdateGenerated();
    public bool get_IsNullable();
    [ObsoleteAttribute("This method has no more usage in NHibernate and will be removed in a future version.")]
public bool IsDirtyCheckable(bool hasUninitializedProperties);
    public bool IsDirtyCheckable();
    public bool get_IsVersionable();
    public CascadeStyle get_CascadeStyle();
    public Nullable`1<FetchMode> get_FetchMode();
}
public class NHibernate.Tuple.VersionProperty : StandardProperty {
    private VersionValue unsavedValue;
    public VersionValue UnsavedValue { get; }
    public VersionProperty(string name, IType type, bool lazy, bool insertable, bool updateable, bool insertGenerated, bool updateGenerated, bool nullable, bool checkable, bool versionable, CascadeStyle cascadeStyle, VersionValue unsavedValue);
    public VersionValue get_UnsavedValue();
}
public abstract class NHibernate.Type.AbstractBinaryType : MutableType {
    public IComparer Comparator { get; }
    public string Name { get; }
    internal AbstractBinaryType(BinarySqlType sqlType);
    public sealed virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual object Next(object current, ISessionImplementor session);
    public sealed virtual object Seed(ISessionImplementor session);
    public virtual bool IsEqual(object x, object y);
    public sealed virtual IComparer get_Comparator();
    public abstract virtual string get_Name();
    protected internal abstract virtual object ToExternalFormat(Byte[] bytes);
    protected internal abstract virtual Byte[] ToInternalFormat(object bytes);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual int GetHashCode(object x);
    public virtual int Compare(object x, object y);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public virtual object DeepCopyNotNull(object value);
    public virtual object FromStringValue(string xml);
}
public abstract class NHibernate.Type.AbstractCharType : PrimitiveType {
    public object DefaultValue { get; }
    public Type PrimitiveClass { get; }
    public Type ReturnedClass { get; }
    public AbstractCharType(SqlType sqlType);
    public virtual object get_DefaultValue();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_PrimitiveClass();
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
    public virtual object StringToObject(string xml);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
}
public abstract class NHibernate.Type.AbstractDateTimeType : PrimitiveType {
    private static DateTime BaseDateValue;
    protected DateTimeKind Kind { get; }
    public Type ReturnedClass { get; }
    protected DateTime Now { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    protected AbstractDateTimeType(SqlType sqlTypeDateTime);
    private static AbstractDateTimeType();
    public sealed virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    protected virtual DateTimeKind get_Kind();
    public virtual Type get_ReturnedClass();
    protected virtual DateTime get_Now();
    protected virtual DateTime AdjustDateTime(DateTime dateValue);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    protected virtual DateTime GetDateTime(DbDataReader rs, int index, ISessionImplementor session);
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public sealed virtual object Next(object current, ISessionImplementor session);
    public static DateTime Round(DateTime value, long resolution);
    public virtual object Seed(ISessionImplementor session);
    public virtual IComparer get_Comparator();
    public virtual bool IsEqual(object x, object y);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public sealed virtual object StringToObject(string xml);
    public virtual object FromStringValue(string xml);
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public abstract class NHibernate.Type.AbstractEnumType : PrimitiveType {
    private object defaultValue;
    private Type enumType;
    public Type ReturnedClass { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    protected AbstractEnumType(SqlType sqlType, Type enumType);
    public virtual Type get_ReturnedClass();
    public sealed virtual object StringToObject(string xml);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
}
public abstract class NHibernate.Type.AbstractStringType : ImmutableType {
    private static StringComparer _defaultComparer;
    private StringComparer _comparer;
    public static string ComparerCultureParameterName;
    public static string IgnoreCaseParameterName;
    public static StringComparer DefaultComparer { get; public set; }
    protected StringComparer Comparer { get; protected set; }
    public Type ReturnedClass { get; }
    public AbstractStringType(SqlType sqlType);
    private static AbstractStringType();
    public static StringComparer get_DefaultComparer();
    public static void set_DefaultComparer(StringComparer value);
    protected StringComparer get_Comparer();
    protected void set_Comparer(StringComparer value);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual bool IsEqual(object x, object y);
    public virtual int GetHashCode(object x);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual Type get_ReturnedClass();
    public sealed virtual object StringToObject(string xml);
    public sealed virtual string ObjectToSQLString(object value, Dialect dialect);
    public sealed virtual void SetParameterValues(IDictionary`2<string, string> parameters);
    private static StringComparer GetComparer(string cultureName, bool ignoreCase);
    private static CultureInfo GetCultureInfo(string cultureName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class NHibernate.Type.AbstractType : object {
    public bool IsAssociationType { get; }
    public bool IsCollectionType { get; }
    public bool IsComponentType { get; }
    public bool IsEntityType { get; }
    public bool IsAnyType { get; }
    public bool IsMutable { get; }
    public string Name { get; }
    public Type ReturnedClass { get; }
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task BeforeAssembleAsync(object cached, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDirtyAsync(object old, object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> ResolveIdentifierAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> SemiResolveAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsModifiedAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReplaceAsync(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task NullSafeSetAsync(DbCommand st, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual bool get_IsAssociationType();
    public virtual bool get_IsCollectionType();
    public virtual bool get_IsComponentType();
    public virtual bool get_IsEntityType();
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual void BeforeAssemble(object cached, ISessionImplementor session);
    public virtual bool IsDirty(object old, object current, ISessionImplementor session);
    public virtual object Hydrate(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual object ResolveIdentifier(object value, ISessionImplementor session, object owner);
    public virtual object SemiResolve(object value, ISessionImplementor session, object owner);
    public virtual bool get_IsAnyType();
    public virtual bool IsModified(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public abstract virtual object DeepCopy(object val, ISessionFactoryImplementor factory);
    public abstract virtual SqlType[] SqlTypes(IMapping mapping);
    public abstract virtual int GetColumnSpan(IMapping mapping);
    public virtual object Replace(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection);
    public virtual bool IsSame(object x, object y);
    public virtual bool IsEqual(object x, object y);
    public virtual bool IsEqual(object x, object y, ISessionFactoryImplementor factory);
    public virtual int GetHashCode(object x);
    public virtual int GetHashCode(object x, ISessionFactoryImplementor factory);
    public virtual int Compare(object x, object y);
    public virtual IType GetSemiResolvedType(ISessionFactoryImplementor factory);
    public abstract virtual object Replace(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public abstract virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
    public abstract virtual bool get_IsMutable();
    public abstract virtual string get_Name();
    public abstract virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public abstract virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public abstract virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public abstract virtual void NullSafeSet(DbCommand st, object value, int index, ISessionImplementor session);
    public abstract virtual Type get_ReturnedClass();
    public abstract virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public abstract virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
}
public class NHibernate.Type.AnsiCharType : AbstractCharType {
    public string Name { get; }
    public virtual string get_Name();
}
public class NHibernate.Type.AnsiStringType : AbstractStringType {
    public string Name { get; }
    internal AnsiStringType(AnsiStringSqlType sqlType);
    public virtual string get_Name();
}
public class NHibernate.Type.AnyType : AbstractType {
    private IType identifierType;
    private IType metaType;
    private static INHibernateLogger Log;
    private static String[] PROPERTY_NAMES;
    public string Name { get; }
    public bool IsMutable { get; }
    public Type ReturnedClass { get; }
    public bool IsAnyType { get; }
    public bool IsEmbedded { get; }
    public String[] PropertyNames { get; }
    public IType[] Subtypes { get; }
    public bool IsComponentType { get; }
    public ForeignKeyDirection ForeignKeyDirection { get; }
    public bool IsAssociationType { get; }
    public bool UseLHSPrimaryKey { get; }
    public string LHSPropertyName { get; }
    public string RHSUniqueKeyPropertyName { get; }
    public bool IsAlwaysDirtyChecked { get; }
    public Boolean[] PropertyNullability { get; }
    public bool ReferenceToPrimaryKey { get; }
    internal AnyType(IType metaType, IType identifierType);
    private static AnyType();
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.AnyType/<NullSafeGetAsync>d__1")]
public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.AnyType/<HydrateAsync>d__2")]
public virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> ResolveIdentifierAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> SemiResolveAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.AnyType/<NullSafeSetAsync>d__5")]
public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.AnyType/<DisassembleAsync>d__8")]
public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.AnyType/<ReplaceAsync>d__9")]
public virtual Task`1<object> ReplaceAsync(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> GetPropertyValueAsync(object component, int i, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.AnyType/<GetPropertyValuesAsync>d__11")]
public sealed virtual Task`1<Object[]> GetPropertyValuesAsync(object component, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.AnyType/<IdAsync>d__12")]
private static Task`1<object> IdAsync(object component, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.AnyType/<IsModifiedAsync>d__14")]
public virtual Task`1<bool> IsModifiedAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    private Task`1<object> ResolveAnyAsync(string entityName, object id, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
    public virtual int GetColumnSpan(IMapping session);
    public virtual string get_Name();
    public virtual bool get_IsMutable();
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual object Hydrate(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual object ResolveIdentifier(object value, ISessionImplementor session, object owner);
    public virtual object SemiResolve(object value, ISessionImplementor session, object owner);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual object Replace(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public virtual bool get_IsAnyType();
    public sealed virtual CascadeStyle GetCascadeStyle(int i);
    public sealed virtual FetchMode GetFetchMode(int i);
    public sealed virtual bool get_IsEmbedded();
    public sealed virtual String[] get_PropertyNames();
    public sealed virtual object GetPropertyValue(object component, int i, ISessionImplementor session);
    public sealed virtual Object[] GetPropertyValues(object component);
    public sealed virtual Object[] GetPropertyValues(object component, ISessionImplementor session);
    private static object Id(object component, ISessionImplementor session);
    public sealed virtual IType[] get_Subtypes();
    public sealed virtual void SetPropertyValues(object component, Object[] values);
    public virtual bool get_IsComponentType();
    public sealed virtual ForeignKeyDirection get_ForeignKeyDirection();
    public virtual bool get_IsAssociationType();
    public sealed virtual bool get_UseLHSPrimaryKey();
    public sealed virtual IJoinable GetAssociatedJoinable(ISessionFactoryImplementor factory);
    public String[] GetReferencedColumns(ISessionFactoryImplementor factory);
    public sealed virtual string GetAssociatedEntityName(ISessionFactoryImplementor factory);
    public sealed virtual string get_LHSPropertyName();
    public sealed virtual string get_RHSUniqueKeyPropertyName();
    public virtual int GetHashCode();
    public sealed virtual bool get_IsAlwaysDirtyChecked();
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public virtual bool IsModified(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public sealed virtual Boolean[] get_PropertyNullability();
    public sealed virtual string GetOnCondition(string alias, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public virtual int Compare(object x, object y);
    public virtual bool IsMethodOf(MethodBase method);
    public virtual bool IsSame(object x, object y);
    public bool get_ReferenceToPrimaryKey();
    private object ResolveAny(string entityName, object id, ISessionImplementor session);
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
}
public class NHibernate.Type.ArrayType : CollectionType {
    private Type elementClass;
    private Type arrayClass;
    public Type ReturnedClass { get; }
    public bool IsArrayType { get; }
    public ArrayType(string role, string propertyRef, Type elementClass);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ArrayType/<ReplaceElementsAsync>d__1")]
public virtual Task`1<object> ReplaceElementsAsync(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Type get_ReturnedClass();
    public virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister, object key);
    public virtual void NullSafeSet(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual IEnumerable GetElementsIterator(object collection);
    public virtual IPersistentCollection Wrap(ISessionImplementor session, object array);
    public virtual bool get_IsArrayType();
    public virtual object InstantiateResult(object original);
    public virtual object Instantiate(int anticipatedSize);
    public virtual bool HasHolder();
    public virtual object IndexOf(object collection, object element);
    protected internal virtual bool InitializeImmediately();
    public virtual object ReplaceElements(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
}
public class NHibernate.Type.BinaryBlobType : BinaryType {
    public string Name { get; }
    internal BinaryBlobType(BinarySqlType sqlType);
    public virtual string get_Name();
}
public class NHibernate.Type.BinaryType : AbstractBinaryType {
    public Type ReturnedClass { get; }
    public string Name { get; }
    internal BinaryType(BinarySqlType sqlType);
    public virtual Type get_ReturnedClass();
    public virtual string get_Name();
    protected internal virtual object ToExternalFormat(Byte[] bytes);
    protected internal virtual Byte[] ToInternalFormat(object bytes);
    public virtual int Compare(object x, object y);
}
public class NHibernate.Type.BooleanType : PrimitiveType {
    protected static object TrueObject;
    protected static object FalseObject;
    public Type PrimitiveClass { get; }
    public Type ReturnedClass { get; }
    public string Name { get; }
    public object DefaultValue { get; }
    public BooleanType(AnsiStringFixedLengthSqlType sqlType);
    private static BooleanType();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_PrimitiveClass();
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
    public virtual object StringToObject(string xml);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    internal static object GetBooleanAsObject(bool value);
}
public class NHibernate.Type.ByteType : PrimitiveType {
    private static byte ZERO;
    public Type ReturnedClass { get; }
    public Type PrimitiveClass { get; }
    public string Name { get; }
    public IComparer Comparator { get; }
    public object DefaultValue { get; }
    public virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual Type get_PrimitiveClass();
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual string get_Name();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
    public virtual object StringToObject(string xml);
    public virtual object FromStringValue(string xml);
    public virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    public sealed virtual IComparer get_Comparator();
    public virtual object get_DefaultValue();
}
public abstract class NHibernate.Type.CharBooleanType : BooleanType {
    protected string TrueString { get; }
    protected string FalseString { get; }
    protected CharBooleanType(AnsiStringFixedLengthSqlType sqlType);
    protected abstract virtual string get_TrueString();
    protected abstract virtual string get_FalseString();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    private string ToCharacter(object value);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
    public virtual object StringToObject(string xml);
}
public class NHibernate.Type.CharType : AbstractCharType {
    public string Name { get; }
    public virtual string get_Name();
}
[ObsoleteAttribute("Use MetaType without meta-values instead.")]
public class NHibernate.Type.ClassMetaType : AbstractType {
    public Type ReturnedClass { get; }
    public string Name { get; }
    public bool IsMutable { get; }
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ClassMetaType/<IsDirtyAsync>d__4")]
public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> ReplaceAsync(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual int GetColumnSpan(IMapping mapping);
    public virtual Type get_ReturnedClass();
    public virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public virtual string get_Name();
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
    public virtual bool get_IsMutable();
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public virtual object Replace(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
}
public abstract class NHibernate.Type.CollectionType : AbstractType {
    private static INHibernateLogger log;
    private static object NotNullCollection;
    public static object UnfetchedCollection;
    private string role;
    private string foreignKeyPropertyName;
    private static SqlType[] NoSqlTypes;
    public string Role { get; }
    public bool IsCollectionType { get; }
    public string Name { get; }
    public bool IsMutable { get; }
    public bool IsAssociationType { get; }
    public ForeignKeyDirection ForeignKeyDirection { get; }
    public bool IsArrayType { get; }
    public bool UseLHSPrimaryKey { get; }
    public string LHSPropertyName { get; }
    public string RHSUniqueKeyPropertyName { get; }
    public bool IsAlwaysDirtyChecked { get; }
    protected CollectionType(string role, string foreignKeyPropertyName);
    private static CollectionType();
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand cmd, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<DisassembleAsync>d__4")]
public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<BeforeAssembleAsync>d__5")]
public virtual Task BeforeAssembleAsync(object oid, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<AssembleAsync>d__6")]
public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<IsDirtyAsync>d__7")]
public virtual Task`1<bool> IsDirtyAsync(object old, object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<ResolveIdentifierAsync>d__9")]
public virtual Task`1<object> ResolveIdentifierAsync(object key, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    private Task`1<object> ResolveKeyAsync(object key, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<GetCollectionAsync>d__11")]
public Task`1<object> GetCollectionAsync(object key, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> SemiResolveAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<ReplaceAsync>d__13")]
public virtual Task`1<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<ReplaceElementsAsync>d__14")]
public virtual Task`1<object> ReplaceElementsAsync(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsModifiedAsync(object oldHydratedState, object currentState, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CollectionType/<GetKeyOfOwnerAsync>d__17")]
public Task`1<object> GetKeyOfOwnerAsync(object owner, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Role();
    public virtual bool get_IsCollectionType();
    public virtual bool IsEqual(object x, object y);
    public virtual int GetHashCode(object x);
    public abstract virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister, object key);
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public virtual object NullSafeGet(DbDataReader rs, String[] name, ISessionImplementor session, object owner);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual int GetColumnSpan(IMapping session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
    public virtual string get_Name();
    public virtual bool get_IsMutable();
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual void BeforeAssemble(object oid, ISessionImplementor session);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    private bool IsOwnerVersioned(ISessionImplementor session);
    private ICollectionPersister GetPersister(ISessionImplementor session);
    public virtual bool IsDirty(object old, object current, ISessionImplementor session);
    public abstract virtual IPersistentCollection Wrap(ISessionImplementor session, object collection);
    public virtual bool get_IsAssociationType();
    public virtual ForeignKeyDirection get_ForeignKeyDirection();
    public virtual object Hydrate(DbDataReader rs, String[] name, ISessionImplementor session, object owner);
    public virtual object ResolveIdentifier(object key, ISessionImplementor session, object owner);
    private object ResolveKey(object key, ISessionImplementor session, object owner);
    public object GetCollection(object key, ISessionImplementor session, object owner);
    public virtual object SemiResolve(object value, ISessionImplementor session, object owner);
    public virtual bool get_IsArrayType();
    public sealed virtual bool get_UseLHSPrimaryKey();
    public sealed virtual IJoinable GetAssociatedJoinable(ISessionFactoryImplementor factory);
    public String[] GetReferencedColumns(ISessionFactoryImplementor factory);
    public sealed virtual string GetAssociatedEntityName(ISessionFactoryImplementor factory);
    public virtual object InstantiateResult(object original);
    public virtual object Replace(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache);
    public virtual object ReplaceElements(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session);
    internal bool ShouldTargetsDirtyFlagBeCleared(IPersistentCollection targetPc, IPersistentCollection originalPc, IEnumerable original);
    protected virtual bool AreCollectionElementsEqual(IEnumerable original, IEnumerable target);
    public IType GetElementType(ISessionFactoryImplementor factory);
    public virtual string ToString();
    protected virtual void Clear(object collection);
    protected virtual void Add(object collection, object element);
    public sealed virtual string get_LHSPropertyName();
    public sealed virtual string get_RHSUniqueKeyPropertyName();
    public sealed virtual bool get_IsAlwaysDirtyChecked();
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public virtual bool IsModified(object oldHydratedState, object currentState, Boolean[] checkable, ISessionImplementor session);
    public object GetKeyOfOwner(object owner, ISessionImplementor session);
    public virtual object GetIdOfOwnerOrNull(object key, ISessionImplementor session);
    public abstract virtual object Instantiate(int anticipatedSize);
    public sealed virtual string GetOnCondition(string alias, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
    public virtual int Compare(object x, object y);
    public virtual bool Contains(object collection, object childObject, ISessionImplementor session);
    public virtual IEnumerable GetElementsIterator(object collection, ISessionImplementor session);
    public virtual IEnumerable GetElementsIterator(object collection);
    public virtual bool HasHolder();
    protected internal virtual bool InitializeImmediately();
    public virtual object IndexOf(object collection, object element);
    protected internal virtual string RenderLoggableString(object value, ISessionFactoryImplementor factory);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<bool> <>n__0(object old, object current, ISessionImplementor session, CancellationToken cancellationToken);
}
public class NHibernate.Type.ComponentType : AbstractType {
    private IType[] propertyTypes;
    private String[] propertyNames;
    private Boolean[] propertyNullability;
    private int propertySpan;
    private CascadeStyle[] cascade;
    private Nullable`1[] joinedFetch;
    private bool isKey;
    private bool overridesGetHashCode;
    [CompilerGeneratedAttribute]
private EntityMode <EntityMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentTuplizer <ComponentTuplizer>k__BackingField;
    public bool IsCollectionType { get; }
    public bool IsComponentType { get; }
    public bool IsEntityType { get; }
    public Type ReturnedClass { get; }
    public IType[] Subtypes { get; }
    public string Name { get; }
    public String[] PropertyNames { get; }
    public bool IsMutable { get; }
    public bool IsEmbedded { get; }
    public Boolean[] PropertyNullability { get; }
    public EntityMode EntityMode { get; }
    public IComponentTuplizer ComponentTuplizer { get; }
    public ComponentType(ComponentMetamodel metamodel);
    internal ComponentType(IType[] propertyTypes, String[] propertyNames, Boolean[] propertyNullability, int propertySpan, CascadeStyle[] cascade, Nullable`1[] joinedFetch, bool isKey, bool overridesGetHashCode, IComponentTuplizer tuplizer, EntityMode entityMode);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<IsDirtyAsync>d__0")]
public virtual Task`1<bool> IsDirtyAsync(object x, object y, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<IsDirtyAsync>d__1")]
public virtual Task`1<bool> IsDirtyAsync(object x, object y, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<NullSafeGetAsync>d__2")]
public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<NullSafeSetAsync>d__3")]
public virtual Task NullSafeSetAsync(DbCommand st, object value, int begin, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<NullSafeSetAsync>d__4")]
public virtual Task NullSafeSetAsync(DbCommand st, object value, int begin, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> GetPropertyValueAsync(object component, int i, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<Object[]> GetPropertyValuesAsync(object component, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<ReplaceAsync>d__8")]
public virtual Task`1<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<ReplaceAsync>d__9")]
public virtual Task`1<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<DisassembleAsync>d__10")]
public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<AssembleAsync>d__11")]
public virtual Task`1<object> AssembleAsync(object obj, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<HydrateAsync>d__12")]
public virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<ResolveIdentifierAsync>d__13")]
public virtual Task`1<object> ResolveIdentifierAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> SemiResolveAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ComponentType/<IsModifiedAsync>d__15")]
public virtual Task`1<bool> IsModifiedAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual int GetColumnSpan(IMapping mapping);
    public virtual bool get_IsCollectionType();
    public virtual bool get_IsComponentType();
    public virtual bool get_IsEntityType();
    public virtual Type get_ReturnedClass();
    public virtual int GetHashCode(object x, ISessionFactoryImplementor factory);
    public virtual int GetHashCode(object x);
    public virtual bool IsDirty(object x, object y, ISessionImplementor session);
    public virtual bool IsDirty(object x, object y, Boolean[] checkable, ISessionImplementor session);
    public virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual void NullSafeSet(DbCommand st, object value, int begin, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand st, object value, int begin, Boolean[] settable, ISessionImplementor session);
    private Object[] NullSafeGetValues(object value);
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public object GetPropertyValue(object component, int i);
    public sealed virtual object GetPropertyValue(object component, int i, ISessionImplementor session);
    public sealed virtual Object[] GetPropertyValues(object component);
    public sealed virtual Object[] GetPropertyValues(object component, ISessionImplementor session);
    public virtual void SetPropertyValues(object component, Object[] values);
    public sealed virtual IType[] get_Subtypes();
    public virtual string get_Name();
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public sealed virtual String[] get_PropertyNames();
    public virtual object DeepCopy(object component, ISessionFactoryImplementor factory);
    public virtual object Replace(object original, object target, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public virtual object Replace(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection);
    public object Instantiate();
    public virtual object Instantiate(object parent, ISessionImplementor session);
    public sealed virtual CascadeStyle GetCascadeStyle(int i);
    public virtual bool get_IsMutable();
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual object Assemble(object obj, ISessionImplementor session, object owner);
    public sealed virtual FetchMode GetFetchMode(int i);
    public virtual bool get_IsEmbedded();
    public virtual object Hydrate(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual object ResolveIdentifier(object value, ISessionImplementor session, object owner);
    public virtual object SemiResolve(object value, ISessionImplementor session, object owner);
    public virtual bool IsModified(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public sealed virtual Boolean[] get_PropertyNullability();
    public virtual int Compare(object x, object y);
    public virtual bool IsEqual(object x, object y);
    public virtual bool IsEqual(object x, object y, ISessionFactoryImplementor factory);
    private Nullable`1<bool> IsEqualFast(object x, object y);
    public virtual bool IsMethodOf(MethodBase method);
    public virtual bool IsSame(object x, object y);
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
    [CompilerGeneratedAttribute]
public EntityMode get_EntityMode();
    [CompilerGeneratedAttribute]
public IComponentTuplizer get_ComponentTuplizer();
    public int GetPropertyIndex(string name);
}
public class NHibernate.Type.CompositeCustomType : AbstractType {
    private ICompositeUserType userType;
    private string name;
    public ICompositeUserType UserType { get; }
    public IType[] Subtypes { get; }
    public String[] PropertyNames { get; }
    public bool IsEmbedded { get; }
    public bool IsComponentType { get; }
    public string Name { get; }
    public Type ReturnedClass { get; }
    public bool IsMutable { get; }
    public Boolean[] PropertyNullability { get; }
    public CompositeCustomType(Type userTypeClass, IDictionary`2<string, string> parameters);
    public virtual Task`1<Object[]> GetPropertyValuesAsync(object component, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> GetPropertyValueAsync(object component, int i, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand cmd, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> ReplaceAsync(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public ICompositeUserType get_UserType();
    public virtual IType[] get_Subtypes();
    public virtual String[] get_PropertyNames();
    public virtual Object[] GetPropertyValues(object component, ISessionImplementor session);
    public virtual Object[] GetPropertyValues(object component);
    public virtual void SetPropertyValues(object component, Object[] values);
    public virtual object GetPropertyValue(object component, int i, ISessionImplementor session);
    public object GetPropertyValue(object component, int i);
    public virtual CascadeStyle GetCascadeStyle(int i);
    public virtual FetchMode GetFetchMode(int i);
    public sealed virtual bool get_IsEmbedded();
    public virtual bool get_IsComponentType();
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual int GetColumnSpan(IMapping mapping);
    public virtual string get_Name();
    public virtual Type get_ReturnedClass();
    public virtual bool get_IsMutable();
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public sealed virtual Boolean[] get_PropertyNullability();
    public virtual object Replace(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public virtual bool IsEqual(object x, object y);
    public virtual bool IsMethodOf(MethodBase method);
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
}
public class NHibernate.Type.CultureInfoType : ImmutableType {
    public Type ReturnedClass { get; }
    public string Name { get; }
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object value);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual Type get_ReturnedClass();
    public virtual string get_Name();
    public sealed virtual string ObjectToSQLString(object value, Dialect dialect);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    private static string GetStringRepresentation(object value);
    private static object ParseStringRepresentation(object value);
}
public class NHibernate.Type.CurrencyType : DecimalType {
    public string Name { get; }
    internal CurrencyType(SqlType sqlType);
    public virtual string get_Name();
}
public class NHibernate.Type.CustomCollectionType : CollectionType {
    private IUserCollectionType userType;
    public IUserCollectionType UserType { get; }
    public Type ReturnedClass { get; }
    public CustomCollectionType(Type userTypeClass, string role, string foreignKeyPropertyName);
    public virtual Task`1<object> ReplaceElementsAsync(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session, CancellationToken cancellationToken);
    public IUserCollectionType get_UserType();
    public virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister, object key);
    private static void EnsureNotInitialized(IPersistentCollection createdCollection);
    public virtual IPersistentCollection Wrap(ISessionImplementor session, object collection);
    public virtual Type get_ReturnedClass();
    public virtual object Instantiate(int anticipatedSize);
    public virtual IEnumerable GetElementsIterator(object collection);
    public virtual bool Contains(object collection, object entity, ISessionImplementor session);
    public virtual object IndexOf(object collection, object entity);
    public virtual object ReplaceElements(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session);
}
public class NHibernate.Type.CustomType : AbstractType {
    private IUserType userType;
    private string name;
    private SqlType[] sqlTypes;
    public IUserType UserType { get; }
    public Type ReturnedClass { get; }
    public string Name { get; }
    public bool IsMutable { get; }
    public IComparer Comparator { get; }
    public CustomType(Type userTypeClass, IDictionary`2<string, string> parameters);
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand cmd, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.CustomType/<IsDirtyAsync>d__4")]
public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> ReplaceAsync(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public IUserType get_UserType();
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual int GetColumnSpan(IMapping session);
    public virtual Type get_ReturnedClass();
    public virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public virtual string get_Name();
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
    public virtual bool get_IsMutable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual int GetHashCode(object x);
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public sealed virtual object StringToObject(string xml);
    public sealed virtual object FromStringValue(string xml);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
    public sealed virtual object Next(object current, ISessionImplementor session);
    public sealed virtual object Seed(ISessionImplementor session);
    public sealed virtual IComparer get_Comparator();
    public virtual object Replace(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual bool IsEqual(object x, object y);
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
}
[ObsoleteAttribute("Use DateTimeType instead, it uses DateTime2 with dialects supporting it.")]
public class NHibernate.Type.DateTime2Type : AbstractDateTimeType {
    public string Name { get; }
    public DateTime2Type(DateTime2SqlType sqlType);
    public virtual string get_Name();
}
public class NHibernate.Type.DateTimeNoMsType : AbstractDateTimeType {
    public string Name { get; }
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    protected virtual DateTime AdjustDateTime(DateTime dateValue);
    public virtual object Seed(ISessionImplementor session);
    public virtual bool IsEqual(object x, object y);
    public virtual int GetHashCode(object x);
}
public class NHibernate.Type.DateTimeOffsetType : PrimitiveType {
    private static DateTimeOffset BaseDateValue;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public IComparer Comparator { get; }
    public DateTimeOffsetType(DateTimeOffsetSqlType sqlType);
    private static DateTimeOffsetType();
    public sealed virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual Type get_ReturnedClass();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public sealed virtual IComparer get_Comparator();
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public sealed virtual object Next(object current, ISessionImplementor session);
    public static DateTimeOffset Round(DateTimeOffset value, long resolution);
    public virtual object Seed(ISessionImplementor session);
    public virtual bool IsEqual(object x, object y);
    public sealed virtual object StringToObject(string xml);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public virtual object FromStringValue(string xml);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.DateTimeType : AbstractDateTimeType {
    public string Name { get; }
    public DateTimeType(DateTimeSqlType sqlType);
    public virtual string get_Name();
}
public class NHibernate.Type.DateType : AbstractDateTimeType {
    private static INHibernateLogger _log;
    [ObsoleteAttribute("Explicitly affect your values to your entities properties instead.")]
public static string BaseValueParameterName;
    [ObsoleteAttribute("Use DateTime.MinValue.")]
public static DateTime BaseDateValue;
    private DateTime customBaseDate;
    private static DateTime _baseDateValue;
    public string Name { get; }
    public object DefaultValue { get; }
    private static DateType();
    public virtual string get_Name();
    protected virtual DateTime AdjustDateTime(DateTime dateValue);
    public virtual bool IsEqual(object x, object y);
    public virtual int GetHashCode(object x);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
    [ObsoleteAttribute("Its only parameter, BaseValue, is obsolete.")]
public sealed virtual void SetParameterValues(IDictionary`2<string, string> parameters);
}
public class NHibernate.Type.DbTimestampType : AbstractDateTimeType {
    private static INHibernateLogger log;
    private static SqlType[] EmptyParams;
    public string Name { get; }
    private static DbTimestampType();
    [AsyncStateMachineAttribute("NHibernate.Type.DbTimestampType/<SeedAsync>d__0")]
public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.DbTimestampType/<GetCurrentTimestampAsync>d__1")]
protected virtual Task`1<DateTime> GetCurrentTimestampAsync(ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.DbTimestampType/<UsePreparedStatementAsync>d__2")]
protected virtual Task`1<DateTime> UsePreparedStatementAsync(string timestampSelectString, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Seed(ISessionImplementor session);
    protected virtual bool SupportsCurrentTimestampSelection(Dialect dialect);
    protected virtual DateTime GetCurrentTimestamp(ISessionImplementor session);
    protected virtual string GetCurrentTimestampSelectString(Dialect dialect);
    protected virtual DateTime UsePreparedStatement(string timestampSelectString, ISessionImplementor session);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<object> <>n__0(ISessionImplementor session, CancellationToken cancellationToken);
}
public class NHibernate.Type.DecimalType : PrimitiveType {
    public Type ReturnedClass { get; }
    public string Name { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public DecimalType(SqlType sqlType);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual string get_Name();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
    public sealed virtual object StringToObject(string xml);
}
public class NHibernate.Type.DefaultCollectionTypeFactory : object {
    public virtual CollectionType Array(string role, string propertyRef, Type elementClass);
    public virtual CollectionType Bag(string role, string propertyRef);
    public virtual CollectionType List(string role, string propertyRef);
    public virtual CollectionType IdBag(string role, string propertyRef);
    public virtual CollectionType Set(string role, string propertyRef);
    public virtual CollectionType SortedSet(string role, string propertyRef, IComparer`1<T> comparer);
    public virtual CollectionType OrderedSet(string role, string propertyRef);
    public virtual CollectionType Map(string role, string propertyRef);
    public virtual CollectionType SortedDictionary(string role, string propertyRef, IComparer`1<TKey> comparer);
    public virtual CollectionType SortedList(string role, string propertyRef, IComparer`1<TKey> comparer);
}
public class NHibernate.Type.DoubleType : PrimitiveType {
    public Type ReturnedClass { get; }
    public string Name { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public DoubleType(SqlType sqlType);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual string get_Name();
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.EmbeddedComponentType : ComponentType {
    public bool IsEmbedded { get; }
    public EmbeddedComponentType(ComponentMetamodel metamodel);
    public virtual bool get_IsEmbedded();
    public virtual object Instantiate(object parent, ISessionImplementor session);
}
public abstract class NHibernate.Type.EntityType : AbstractType {
    protected string uniqueKeyPropertyName;
    private bool eager;
    private string associatedEntityName;
    private bool unwrapProxy;
    private Type returnedClass;
    public bool IsEntityType { get; }
    public Type ReturnedClass { get; }
    public string Name { get; }
    public bool IsMutable { get; }
    public bool IsOneToOne { get; }
    public bool IsAssociationType { get; }
    public bool IsUniqueKeyReference { get; }
    public bool IsNullable { get; }
    public ForeignKeyDirection ForeignKeyDirection { get; }
    public bool UseLHSPrimaryKey { get; }
    public string LHSPropertyName { get; }
    public string RHSUniqueKeyPropertyName { get; }
    public string PropertyName { get; }
    public bool IsAlwaysDirtyChecked { get; }
    public bool IsReferenceToPrimaryKey { get; }
    protected internal EntityType(string entityName, string uniqueKeyPropertyName, bool eager, bool unwrapProxy);
    public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    protected internal Task`1<object> GetIdentifierAsync(object value, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.EntityType/<GetReferenceValueAsync>d__2")]
protected internal Task`1<object> GetReferenceValueAsync(object value, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.EntityType/<GetReferenceValueAsync>d__3")]
protected internal Task`1<object> GetReferenceValueAsync(object value, ISessionImplementor session, bool forbidDelayed, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.EntityType/<ReplaceAsync>d__4")]
public virtual Task`1<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.EntityType/<NullSafeGetAsync>d__5")]
public sealed virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.EntityType/<ResolveIdentifierAsync>d__7")]
protected Task`1<object> ResolveIdentifierAsync(object id, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> ResolveIdentifierAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.EntityType/<LoadByUniqueKeyAsync>d__9")]
public Task`1<object> LoadByUniqueKeyAsync(string entityName, string uniqueKeyPropertyName, object key, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual bool get_IsEntityType();
    public virtual bool IsEqual(object x, object y, ISessionFactoryImplementor factory);
    public virtual bool IsNull(object owner, ISessionImplementor session);
    public virtual bool IsSame(object x, object y);
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public virtual Type get_ReturnedClass();
    private static object GetIdentifier(object obj, IEntityPersister persister);
    public virtual int GetOwnerColumnSpan(IMapping session);
    protected internal object GetIdentifier(object value, ISessionImplementor session);
    protected internal object GetReferenceValue(object value, ISessionImplementor session);
    protected internal object GetReferenceValue(object value, ISessionImplementor session, bool forbidDelayed);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public virtual string get_Name();
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
    public virtual bool get_IsMutable();
    public abstract virtual bool get_IsOneToOne();
    public virtual bool IsLogicalOneToOne();
    public virtual object Replace(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache);
    public virtual bool get_IsAssociationType();
    public sealed virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public abstract virtual object Hydrate(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public bool get_IsUniqueKeyReference();
    public abstract virtual bool get_IsNullable();
    public sealed virtual IJoinable GetAssociatedJoinable(ISessionFactoryImplementor factory);
    public IType GetIdentifierOrUniqueKeyType(IMapping factory);
    public string GetIdentifierOrUniqueKeyPropertyName(IMapping factory);
    internal virtual IType GetIdentifierType(IMapping factory);
    internal virtual IType GetIdentifierType(ISessionImplementor session);
    protected object ResolveIdentifier(object id, ISessionImplementor session);
    public virtual object ResolveIdentifier(object value, ISessionImplementor session, object owner);
    public virtual string GetAssociatedEntityName(ISessionFactoryImplementor factory);
    public string GetAssociatedEntityName();
    public abstract virtual ForeignKeyDirection get_ForeignKeyDirection();
    public abstract virtual bool get_UseLHSPrimaryKey();
    public sealed virtual string get_LHSPropertyName();
    public sealed virtual string get_RHSUniqueKeyPropertyName();
    public virtual string get_PropertyName();
    public virtual int GetHashCode(object x, ISessionFactoryImplementor factory);
    public abstract virtual bool get_IsAlwaysDirtyChecked();
    public bool get_IsReferenceToPrimaryKey();
    public sealed virtual string GetOnCondition(string alias, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
    public virtual IType GetSemiResolvedType(ISessionFactoryImplementor factory);
    public object LoadByUniqueKey(string entityName, string uniqueKeyPropertyName, object key, ISessionImplementor session);
    public virtual int Compare(object x, object y);
    private Type DetermineAssociatedEntityClass();
    public virtual string ToString();
}
public class NHibernate.Type.EnumCharType`1 : AbstractEnumType {
    public string Name { get; }
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual object GetInstance(object code);
    private object GetInstanceFromString(string s);
    private object GetInstanceFromChar(char c);
    private char Alternate(char c);
    public virtual object GetValue(object instance);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual string get_Name();
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object value);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public abstract class NHibernate.Type.EnumStringType : AbstractEnumType {
    public static int MaxLengthForEnumString;
    public string Name { get; }
    protected EnumStringType(Type enumClass);
    protected EnumStringType(Type enumClass, int length);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object GetInstance(object code);
    public virtual object GetValue(object code);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object value);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.EnumStringType`1 : EnumStringType {
    private string typeName;
    public string Name { get; }
    public virtual string get_Name();
}
public class NHibernate.Type.EnumType`1 : PersistentEnumType {
    private string typeName;
    public string Name { get; }
    public virtual string get_Name();
}
public abstract class NHibernate.Type.ForeignKeyDirection : object {
    public static ForeignKeyDirection ForeignKeyFromParent;
    public static ForeignKeyDirection ForeignKeyToParent;
    private static ForeignKeyDirection();
    public abstract virtual bool CascadeNow(CascadePoint cascadePoint);
}
public class NHibernate.Type.GenericBagType`1 : CollectionType {
    public Type ReturnedClass { get; }
    public GenericBagType`1(string role, string propertyRef);
    public virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister, object key);
    public virtual Type get_ReturnedClass();
    public virtual IPersistentCollection Wrap(ISessionImplementor session, object collection);
    protected virtual void Add(object collection, object element);
    protected virtual void Clear(object collection);
    public virtual object Instantiate(int anticipatedSize);
    protected virtual bool AreCollectionElementsEqual(IEnumerable original, IEnumerable target);
}
public class NHibernate.Type.GenericIdentifierBagType`1 : CollectionType {
    public Type ReturnedClass { get; }
    public GenericIdentifierBagType`1(string role, string propertyRef);
    [AsyncStateMachineAttribute("NHibernate.Type.GenericIdentifierBagType`1/<ReplaceElementsAsync>d__0")]
public virtual Task`1<object> ReplaceElementsAsync(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister, object key);
    public virtual IPersistentCollection Wrap(ISessionImplementor session, object collection);
    public virtual Type get_ReturnedClass();
    public virtual object Instantiate(int anticipatedSize);
    protected virtual void Clear(object collection);
    protected virtual void Add(object collection, object element);
    public virtual object ReplaceElements(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session);
    protected virtual bool AreCollectionElementsEqual(IEnumerable original, IEnumerable target);
}
public class NHibernate.Type.GenericListType`1 : CollectionType {
    public Type ReturnedClass { get; }
    public GenericListType`1(string role, string propertyRef);
    public virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister, object key);
    public virtual Type get_ReturnedClass();
    public virtual IPersistentCollection Wrap(ISessionImplementor session, object collection);
    protected virtual void Add(object collection, object element);
    protected virtual void Clear(object collection);
    public virtual object Instantiate(int anticipatedSize);
    public virtual object IndexOf(object collection, object element);
}
public class NHibernate.Type.GenericMapType`2 : CollectionType {
    public Type ReturnedClass { get; }
    public GenericMapType`2(string role, string propertyRef);
    [AsyncStateMachineAttribute("NHibernate.Type.GenericMapType`2/<ReplaceElementsAsync>d__0")]
public virtual Task`1<object> ReplaceElementsAsync(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister, object key);
    public virtual Type get_ReturnedClass();
    public virtual IEnumerable GetElementsIterator(object collection);
    public virtual IPersistentCollection Wrap(ISessionImplementor session, object collection);
    protected virtual void Add(object collection, object element);
    protected virtual void Clear(object collection);
    public virtual object ReplaceElements(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session);
    public virtual object Instantiate(int anticipatedSize);
    public virtual object IndexOf(object collection, object element);
    protected virtual bool AreCollectionElementsEqual(IEnumerable original, IEnumerable target);
}
public class NHibernate.Type.GenericOrderedSetType`1 : GenericSetType`1<T> {
    public GenericOrderedSetType`1(string role, string propertyRef);
    public virtual object Instantiate(int anticipatedSize);
}
public class NHibernate.Type.GenericSetType`1 : CollectionType {
    public Type ReturnedClass { get; }
    public GenericSetType`1(string role, string propertyRef);
    public virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister, object key);
    public virtual Type get_ReturnedClass();
    public virtual IPersistentCollection Wrap(ISessionImplementor session, object collection);
    protected virtual void Add(object collection, object element);
    protected virtual void Clear(object collection);
    public virtual object Instantiate(int anticipatedSize);
    protected virtual bool AreCollectionElementsEqual(IEnumerable original, IEnumerable target);
}
public class NHibernate.Type.GenericSortedDictionaryType`2 : GenericMapType`2<TKey, TValue> {
    private IComparer`1<TKey> comparer;
    public IComparer`1<TKey> Comparer { get; }
    public GenericSortedDictionaryType`2(string role, string propertyRef, IComparer`1<TKey> comparer);
    public IComparer`1<TKey> get_Comparer();
    public virtual object Instantiate(int anticipatedSize);
}
public class NHibernate.Type.GenericSortedListType`2 : GenericMapType`2<TKey, TValue> {
    private IComparer`1<TKey> comparer;
    public IComparer`1<TKey> Comparer { get; }
    public GenericSortedListType`2(string role, string propertyRef, IComparer`1<TKey> comparer);
    public IComparer`1<TKey> get_Comparer();
    public virtual object Instantiate(int anticipatedSize);
}
public class NHibernate.Type.GenericSortedSetType`1 : GenericSetType`1<T> {
    private IComparer`1<T> comparer;
    public IComparer`1<T> Comparer { get; }
    public GenericSortedSetType`1(string role, string propertyRef, IComparer`1<T> comparer);
    public IComparer`1<T> get_Comparer();
    public virtual object Instantiate(int anticipatedSize);
}
public class NHibernate.Type.GuidType : PrimitiveType {
    public Type ReturnedClass { get; }
    public string Name { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual string get_Name();
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public sealed virtual object StringToObject(string xml);
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public interface NHibernate.Type.IAbstractComponentType {
    public IType[] Subtypes { get; }
    public String[] PropertyNames { get; }
    public Boolean[] PropertyNullability { get; }
    public bool IsEmbedded { get; }
    public abstract virtual Task`1<Object[]> GetPropertyValuesAsync(object component, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> GetPropertyValueAsync(object component, int i, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual IType[] get_Subtypes();
    public abstract virtual String[] get_PropertyNames();
    public abstract virtual Boolean[] get_PropertyNullability();
    public abstract virtual Object[] GetPropertyValues(object component, ISessionImplementor session);
    public abstract virtual Object[] GetPropertyValues(object component);
    public abstract virtual void SetPropertyValues(object component, Object[] values);
    public abstract virtual object GetPropertyValue(object component, int i, ISessionImplementor session);
    public abstract virtual CascadeStyle GetCascadeStyle(int i);
    public abstract virtual FetchMode GetFetchMode(int i);
    public abstract virtual bool get_IsEmbedded();
    public abstract virtual bool IsMethodOf(MethodBase method);
}
public interface NHibernate.Type.IAssociationType {
    public ForeignKeyDirection ForeignKeyDirection { get; }
    public bool UseLHSPrimaryKey { get; }
    public string LHSPropertyName { get; }
    public string RHSUniqueKeyPropertyName { get; }
    public bool IsAlwaysDirtyChecked { get; }
    public abstract virtual ForeignKeyDirection get_ForeignKeyDirection();
    public abstract virtual bool get_UseLHSPrimaryKey();
    public abstract virtual string get_LHSPropertyName();
    public abstract virtual string get_RHSUniqueKeyPropertyName();
    public abstract virtual IJoinable GetAssociatedJoinable(ISessionFactoryImplementor factory);
    public abstract virtual string GetAssociatedEntityName(ISessionFactoryImplementor factory);
    public abstract virtual bool get_IsAlwaysDirtyChecked();
    public abstract virtual string GetOnCondition(string alias, ISessionFactoryImplementor factory, IDictionary`2<string, IFilter> enabledFilters);
}
public interface NHibernate.Type.ICacheAssembler {
    public abstract virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task BeforeAssembleAsync(object cached, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public abstract virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public abstract virtual void BeforeAssemble(object cached, ISessionImplementor session);
}
public interface NHibernate.Type.IDiscriminatorType {
}
public interface NHibernate.Type.IIdentifierType {
    public abstract virtual object StringToObject(string xml);
}
public interface NHibernate.Type.ILiteralType {
    public abstract virtual string ObjectToSQLString(object value, Dialect dialect);
}
public abstract class NHibernate.Type.ImmutableType : NullableType {
    public bool IsMutable { get; }
    protected ImmutableType(SqlType sqlType);
    public virtual Task`1<object> ReplaceAsync(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public sealed virtual bool get_IsMutable();
    public virtual object Replace(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
}
public class NHibernate.Type.Int16Type : PrimitiveType {
    private static short ZERO;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand rs, object value, int index, ISessionImplementor session);
    public sealed virtual object StringToObject(string xml);
    public virtual object FromStringValue(string xml);
    public virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    public sealed virtual IComparer get_Comparator();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.Int32Type : PrimitiveType {
    private static int ZERO;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand rs, object value, int index, ISessionImplementor session);
    public sealed virtual object StringToObject(string xml);
    public virtual object FromStringValue(string xml);
    public virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    public sealed virtual IComparer get_Comparator();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.Int64Type : PrimitiveType {
    private static long ZERO;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand rs, object value, int index, ISessionImplementor session);
    public sealed virtual object StringToObject(string xml);
    public virtual object FromStringValue(string xml);
    public virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    public sealed virtual IComparer get_Comparator();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public interface NHibernate.Type.IType {
    public string Name { get; }
    public Type ReturnedClass { get; }
    public bool IsMutable { get; }
    public bool IsAssociationType { get; }
    public bool IsCollectionType { get; }
    public bool IsComponentType { get; }
    public bool IsEntityType { get; }
    public bool IsAnyType { get; }
    public abstract virtual Task`1<bool> IsDirtyAsync(object old, object current, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsModifiedAsync(object oldHydratedState, object currentState, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task NullSafeSetAsync(DbCommand st, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ResolveIdentifierAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> SemiResolveAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection, CancellationToken cancellationToken);
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReturnedClass();
    public abstract virtual bool get_IsMutable();
    public abstract virtual bool get_IsAssociationType();
    public abstract virtual bool get_IsCollectionType();
    public abstract virtual bool get_IsComponentType();
    public abstract virtual bool get_IsEntityType();
    public abstract virtual bool get_IsAnyType();
    public abstract virtual SqlType[] SqlTypes(IMapping mapping);
    public abstract virtual int GetColumnSpan(IMapping mapping);
    public abstract virtual bool IsDirty(object old, object current, ISessionImplementor session);
    public abstract virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public abstract virtual bool IsModified(object oldHydratedState, object currentState, Boolean[] checkable, ISessionImplementor session);
    public abstract virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public abstract virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public abstract virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public abstract virtual void NullSafeSet(DbCommand st, object value, int index, ISessionImplementor session);
    public abstract virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public abstract virtual object DeepCopy(object val, ISessionFactoryImplementor factory);
    public abstract virtual object Hydrate(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public abstract virtual object ResolveIdentifier(object value, ISessionImplementor session, object owner);
    public abstract virtual object SemiResolve(object value, ISessionImplementor session, object owner);
    public abstract virtual object Replace(object original, object target, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public abstract virtual object Replace(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection);
    public abstract virtual bool IsSame(object x, object y);
    public abstract virtual bool IsEqual(object x, object y);
    public abstract virtual bool IsEqual(object x, object y, ISessionFactoryImplementor factory);
    public abstract virtual int GetHashCode(object x);
    public abstract virtual int GetHashCode(object x, ISessionFactoryImplementor factory);
    public abstract virtual int Compare(object x, object y);
    public abstract virtual IType GetSemiResolvedType(ISessionFactoryImplementor factory);
    public abstract virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
}
public interface NHibernate.Type.IVersionType {
    public IComparer Comparator { get; }
    public abstract virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public abstract virtual object Next(object current, ISessionImplementor session);
    public abstract virtual object Seed(ISessionImplementor session);
    public abstract virtual IComparer get_Comparator();
    public abstract virtual object FromStringValue(string xml);
}
public class NHibernate.Type.LocalDateTimeNoMsType : DateTimeNoMsType {
    protected DateTimeKind Kind { get; }
    public string Name { get; }
    protected virtual DateTimeKind get_Kind();
    public virtual string get_Name();
}
public class NHibernate.Type.LocalDateTimeType : DateTimeType {
    protected DateTimeKind Kind { get; }
    public string Name { get; }
    public LocalDateTimeType(DateTimeSqlType sqlType);
    protected virtual DateTimeKind get_Kind();
    public virtual string get_Name();
}
public class NHibernate.Type.LocalDateType : DateType {
    protected DateTimeKind Kind { get; }
    protected virtual DateTimeKind get_Kind();
}
public class NHibernate.Type.ManyToOneType : EntityType {
    private bool ignoreNotFound;
    private bool isLogicalOneToOne;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public bool IsOneToOne { get; }
    public string PropertyName { get; }
    public ForeignKeyDirection ForeignKeyDirection { get; }
    public bool UseLHSPrimaryKey { get; }
    public bool IsAlwaysDirtyChecked { get; }
    public bool IsNullable { get; }
    public ManyToOneType(string className);
    public ManyToOneType(string className, bool lazy);
    [ObsoleteAttribute("Use Constructor with property name")]
public ManyToOneType(string entityName, string uniqueKeyPropertyName, bool lazy, bool unwrapProxy, bool ignoreNotFound, bool isLogicalOneToOne);
    public ManyToOneType(string entityName, string uniqueKeyPropertyName, bool lazy, bool unwrapProxy, bool ignoreNotFound, bool isLogicalOneToOne, string propertyName);
    [AsyncStateMachineAttribute("NHibernate.Type.ManyToOneType/<NullSafeSetAsync>d__0")]
public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ManyToOneType/<NullSafeSetAsync>d__1")]
public virtual Task NullSafeSetAsync(DbCommand cmd, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ManyToOneType/<HydrateAsync>d__2")]
public virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ManyToOneType/<IsModifiedAsync>d__3")]
public virtual Task`1<bool> IsModifiedAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ManyToOneType/<DisassembleAsync>d__4")]
public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ManyToOneType/<AssembleAsync>d__5")]
public virtual Task`1<object> AssembleAsync(object oid, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ManyToOneType/<BeforeAssembleAsync>d__6")]
public virtual Task BeforeAssembleAsync(object oid, ISessionImplementor session, CancellationToken cancellationToken);
    private Task`1<object> AssembleIdAsync(object oid, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDirtyAsync(object old, object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.ManyToOneType/<IsDirtyManyToOneAsync>d__10")]
private Task`1<bool> IsDirtyManyToOneAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual int GetColumnSpan(IMapping mapping);
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual bool get_IsOneToOne();
    public virtual bool IsLogicalOneToOne();
    [CompilerGeneratedAttribute]
public virtual string get_PropertyName();
    public virtual ForeignKeyDirection get_ForeignKeyDirection();
    public virtual object Hydrate(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    private void ScheduleBatchLoadIfNeeded(object id, ISessionImplementor session, bool addToQueryCacheBatch);
    public virtual bool get_UseLHSPrimaryKey();
    public virtual bool IsModified(object old, object current, Boolean[] checkable, ISessionImplementor session);
    private bool IsIdentifier(object value, ISessionImplementor session);
    public virtual bool IsNull(object owner, ISessionImplementor session);
    private static EntityKey GetEntityKey(object owner, ISessionImplementor session);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual object Assemble(object oid, ISessionImplementor session, object owner);
    public virtual void BeforeAssemble(object oid, ISessionImplementor session);
    private object AssembleId(object oid, ISessionImplementor session);
    public virtual bool get_IsAlwaysDirtyChecked();
    public virtual bool IsDirty(object old, object current, ISessionImplementor session);
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public virtual bool get_IsNullable();
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
    private bool IsDirtyManyToOne(object old, object current, Boolean[] checkable, ISessionImplementor session);
}
public class NHibernate.Type.MetaType : AbstractType {
    private IDictionary`2<object, string> _values;
    private IDictionary`2<string, object> _keys;
    private IType _baseType;
    private ILiteralType _baseLiteralType;
    public Type ReturnedClass { get; }
    public string Name { get; }
    public bool IsMutable { get; }
    public MetaType(IDictionary`2<object, string> values, IType baseType);
    [AsyncStateMachineAttribute("NHibernate.Type.MetaType/<NullSafeGetAsync>d__0")]
public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.MetaType/<NullSafeGetAsync>d__1")]
public virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.MetaType/<IsDirtyAsync>d__4")]
public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> ReplaceAsync(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual int GetColumnSpan(IMapping mapping);
    public virtual Type get_ReturnedClass();
    public virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    private object GetValueForKey(object key);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    public virtual string get_Name();
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
    public virtual bool get_IsMutable();
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public virtual object Replace(object original, object current, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
    internal string GetMetaValue(string className, Dialect dialect);
}
public abstract class NHibernate.Type.MutableType : NullableType {
    public bool IsMutable { get; }
    protected MutableType(SqlType sqlType);
    public virtual Task`1<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    public sealed virtual bool get_IsMutable();
    public virtual object Replace(object original, object target, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public abstract virtual object DeepCopyNotNull(object value);
    public virtual object DeepCopy(object value, ISessionFactoryImplementor factory);
}
public abstract class NHibernate.Type.NullableType : AbstractType {
    private static bool IsDebugEnabled;
    private SqlType _sqlType;
    private INHibernateLogger Log { get; }
    public SqlType SqlType { get; }
    private static NullableType();
    protected NullableType(SqlType sqlType);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task NullSafeSetAsync(DbCommand st, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.NullableType/<IsDirtyAsync>d__4")]
public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    private INHibernateLogger get_Log();
    public abstract virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public abstract virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public abstract virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public sealed virtual void NullSafeSet(DbCommand st, object value, int index, ISessionImplementor session);
    public sealed virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session);
    public virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session);
    public sealed virtual object NullSafeGet(DbDataReader rs, string name, ISessionImplementor session, object owner);
    public virtual SqlType get_SqlType();
    public sealed virtual SqlType[] SqlTypes(IMapping mapping);
    private static SqlType OverrideSqlType(IMapping mapping, SqlType type);
    public sealed virtual int GetColumnSpan(IMapping session);
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NHibernate.Type.OneToOneType : EntityType {
    private ForeignKeyDirection foreignKeyDirection;
    private string propertyName;
    private string entityName;
    public bool IsOneToOne { get; }
    public ForeignKeyDirection ForeignKeyDirection { get; }
    public bool IsNullable { get; }
    public bool UseLHSPrimaryKey { get; }
    public bool IsAlwaysDirtyChecked { get; }
    public string PropertyName { get; }
    public OneToOneType(string referencedEntityName, ForeignKeyDirection foreignKeyType, string uniqueKeyPropertyName, bool lazy, bool unwrapProxy, string entityName, string propertyName);
    public virtual Task NullSafeSetAsync(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.OneToOneType/<NullSafeSetAsync>d__1")]
public virtual Task NullSafeSetAsync(DbCommand cmd, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.OneToOneType/<IsDirtyAsync>d__2")]
public virtual Task`1<bool> IsDirtyAsync(object old, object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<bool> IsDirtyAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.OneToOneType/<IsModifiedAsync>d__4")]
public virtual Task`1<bool> IsModifiedAsync(object old, object current, Boolean[] checkable, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.OneToOneType/<HydrateAsync>d__5")]
public virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.OneToOneType/<DisassembleAsync>d__6")]
public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.OneToOneType/<AssembleAsync>d__7")]
public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual int GetColumnSpan(IMapping mapping);
    public virtual int GetOwnerColumnSpan(IMapping mapping);
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual void NullSafeSet(DbCommand st, object value, int index, Boolean[] settable, ISessionImplementor session);
    public virtual void NullSafeSet(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual bool get_IsOneToOne();
    public virtual bool IsDirty(object old, object current, ISessionImplementor session);
    public virtual bool IsDirty(object old, object current, Boolean[] checkable, ISessionImplementor session);
    public virtual bool IsModified(object old, object current, Boolean[] checkable, ISessionImplementor session);
    private bool IsIdentifier(object value, ISessionImplementor session);
    public virtual bool IsNull(object owner, ISessionImplementor session);
    public virtual ForeignKeyDirection get_ForeignKeyDirection();
    public virtual object Hydrate(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public virtual bool get_IsNullable();
    public virtual bool get_UseLHSPrimaryKey();
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual bool get_IsAlwaysDirtyChecked();
    public virtual string get_PropertyName();
    public virtual Boolean[] ToColumnNullness(object value, IMapping mapping);
}
public class NHibernate.Type.PersistentEnumType : AbstractEnumType {
    private static Dictionary`2<Type, IEnumConverter> converters;
    private IEnumConverter converter;
    public string Name { get; }
    private static PersistentEnumType();
    public PersistentEnumType(Type enumClass);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public static IEnumConverter GetEnumCoverter(Type enumClass);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object GetInstance(object code);
    public virtual object GetValue(object code);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual string get_Name();
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object value);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class NHibernate.Type.PrimitiveType : ImmutableType {
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    protected PrimitiveType(SqlType sqlType);
    public abstract virtual Type get_PrimitiveClass();
    public abstract virtual object get_DefaultValue();
    public abstract virtual string ObjectToSQLString(object value, Dialect dialect);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
}
public class NHibernate.Type.SByteType : PrimitiveType {
    private static sbyte ZERO;
    public string Name { get; }
    public Type ReturnedClass { get; }
    [ObsoleteAttribute("This member has no more usage and will be removed in a future version.")]
public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand rs, object value, int index, ISessionImplementor session);
    public sealed virtual object StringToObject(string xml);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    [ObsoleteAttribute("This member has no more usage and will be removed in a future version.")]
public virtual object Next(object current, ISessionImplementor session);
    [ObsoleteAttribute("This member has no more usage and will be removed in a future version.")]
public virtual object Seed(ISessionImplementor session);
    public IComparer get_Comparator();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.SerializableType : MutableType {
    private Type serializableClass;
    private BinaryType binaryType;
    public Type ReturnedClass { get; }
    public string Name { get; }
    internal SerializableType(Type serializableClass);
    internal SerializableType(Type serializableClass, BinarySqlType sqlType);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual bool IsEqual(object x, object y);
    public virtual int GetHashCode(object x);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object value);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual string get_Name();
    public virtual object DeepCopyNotNull(object value);
    private static Byte[] ToBytes(object obj);
    public object FromBytes(Byte[] bytes);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
}
public class NHibernate.Type.SerializationException : HibernateException {
    public SerializationException(string message);
    public SerializationException(string message, Exception e);
    protected SerializationException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.Type.SingleType : PrimitiveType {
    private static float ZERO;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public SingleType(SqlType sqlType);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand rs, object value, int index, ISessionImplementor session);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public object StringToObject(string xml);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.SpecialOneToOneType : OneToOneType {
    public bool UseLHSPrimaryKey { get; }
    public SpecialOneToOneType(string referencedEntityName, ForeignKeyDirection foreignKeyType, string uniqueKeyPropertyName, bool lazy, bool unwrapProxy, string entityName, string propertyName);
    public virtual Task`1<object> HydrateAsync(DbDataReader rs, String[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual int GetColumnSpan(IMapping mapping);
    public virtual int GetOwnerColumnSpan(IMapping mapping);
    public virtual SqlType[] SqlTypes(IMapping mapping);
    public virtual bool get_UseLHSPrimaryKey();
    public virtual object Hydrate(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
}
public class NHibernate.Type.StringClobType : StringType {
    public string Name { get; }
    internal StringClobType(StringSqlType sqlType);
    public virtual string get_Name();
}
public class NHibernate.Type.StringType : AbstractStringType {
    public string Name { get; }
    internal StringType(StringSqlType sqlType);
    public virtual string get_Name();
}
internal class NHibernate.Type.SubqueryComponentType : ComponentType {
    internal SubqueryComponentType(IType[] propertyTypes);
}
public class NHibernate.Type.TicksType : AbstractDateTimeType {
    public string Name { get; }
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    protected virtual DateTime GetDateTime(DbDataReader rs, int index, ISessionImplementor session);
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual string get_Name();
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public virtual object FromStringValue(string xml);
    public virtual object Seed(ISessionImplementor session);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public object StringToObject(string xml);
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.TimeAsTimeSpanType : PrimitiveType {
    private static DateTime BaseDateValue;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public TimeAsTimeSpanType(TimeSqlType sqlType);
    private static TimeAsTimeSpanType();
    public sealed virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public sealed virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public object StringToObject(string xml);
    public sealed virtual IComparer get_Comparator();
    public virtual object FromStringValue(string xml);
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.TimeSpanType : PrimitiveType {
    public string Name { get; }
    public Type ReturnedClass { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public sealed virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public sealed virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public object StringToObject(string xml);
    public sealed virtual IComparer get_Comparator();
    public virtual object FromStringValue(string xml);
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
[ObsoleteAttribute("Please use DateTimeType instead.")]
public class NHibernate.Type.TimestampType : AbstractDateTimeType {
    public string Name { get; }
    public virtual string get_Name();
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
}
public class NHibernate.Type.TimeType : PrimitiveType {
    private static DateTime BaseDateValue;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public TimeType(TimeSqlType sqlType);
    private static TimeType();
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand st, object value, int index, ISessionImplementor session);
    public virtual bool IsEqual(object x, object y);
    public virtual int GetHashCode(object x);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    public sealed virtual object StringToObject(string xml);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.TrueFalseType : CharBooleanType {
    protected string TrueString { get; }
    protected string FalseString { get; }
    public string Name { get; }
    protected sealed virtual string get_TrueString();
    protected sealed virtual string get_FalseString();
    public virtual string get_Name();
}
[ExtensionAttribute]
internal static class NHibernate.Type.TypeExtensions : object {
    [ExtensionAttribute]
public static int GetOwnerColumnSpan(IType type, IMapping sessionFactory);
}
public static class NHibernate.Type.TypeFactory : object {
    public static String[] EmptyAliases;
    private static INHibernateLogger _log;
    private static Char[] PrecisionScaleSplit;
    private static Char[] LengthSplit;
    private static MethodInfo BagDefinition;
    private static MethodInfo IdBagDefinition;
    private static MethodInfo ListDefinition;
    private static MethodInfo MapDefinition;
    private static MethodInfo SortedListDefinition;
    private static MethodInfo SortedDictionaryDefinition;
    private static MethodInfo SetDefinition;
    private static MethodInfo SortedSetDefinition;
    private static MethodInfo OrderedSetDefinition;
    private static ConcurrentDictionary`2<string, IType> typeByTypeOfName;
    private static ConcurrentDictionary`2<string, string> _obsoleteMessageByAlias;
    private static ConcurrentDictionary`2<string, GetNullableTypeWithLengthOrScale> _getTypeDelegatesWithLengthOrScale;
    private static ConcurrentDictionary`2<string, GetNullableTypeWithPrecision> getTypeDelegatesWithPrecision;
    private static ICollectionTypeFactory CollectionTypeFactory { get; }
    private static TypeFactory();
    public static void RegisterType(Type systemType, IType nhibernateType, IEnumerable`1<string> aliases);
    public static void RegisterType(Type systemType, IType nhibernateType, IEnumerable`1<string> aliases, GetNullableTypeWithLengthOrScale ctorLengthOrScale);
    private static void RegisterType(Type systemType, IType nhibernateType, IEnumerable`1<string> aliases, GetNullableTypeWithLengthOrScale ctorLengthOrScale, bool override);
    public static void RegisterType(Type systemType, IType nhibernateType, IEnumerable`1<string> aliases, GetNullableTypeWithPrecision ctorPrecision);
    private static void RegisterType(Type systemType, IType nhibernateType, IEnumerable`1<string> aliases, GetNullableTypeWithPrecision ctorPrecision, bool override);
    private static List`1<string> GetClrTypeAliases(Type systemType, IEnumerable`1<string> aliases);
    private static void RegisterType(IType nhibernateType, IEnumerable`1<string> aliases);
    private static void RegisterType(IType nhibernateType, IEnumerable`1<string> aliases, GetNullableTypeWithLengthOrScale ctorLengthOrScale, bool override);
    private static void RegisterType(IType nhibernateType, IEnumerable`1<string> aliases, GetNullableTypeWithPrecision ctorPrecision, bool override);
    private static IEnumerable`1<string> GetTypeAliases(IType nhibernateType, IEnumerable`1<string> aliases);
    private static void RegisterTypeAlias(IType nhibernateType, string alias);
    private static void RegisterTypes();
    public static void ClearCustomRegistrations();
    private static void RegisterDefaultNetTypes();
    private static void RegisterBuiltInTypes();
    private static ICollectionTypeFactory get_CollectionTypeFactory();
    private static TypeClassification GetTypeClassification(string typeName);
    public static IType Basic(string name);
    public static IType Basic(string name, IDictionary`2<string, string> parameters);
    private static IType GetBasicTypeByName(string name, IDictionary`2<string, string> parameters);
    internal static IType BuiltInType(string typeName, int lengthOrScale);
    internal static IType BuiltInType(string typeName, byte precision, byte scale);
    private static string GetKeyForLengthOrScaleBased(string name, int lengthOrScale);
    private static string GetKeyForPrecisionScaleBased(string name, byte precision, byte scale);
    public static IType HeuristicType(string typeName);
    public static IType HeuristicType(Type type);
    public static IType HeuristicType(string typeName, IDictionary`2<string, string> parameters);
    public static IType HeuristicType(string typeName, IDictionary`2<string, string> parameters, Nullable`1<int> length);
    private static IType GetBySystemType(Type typeClass, IDictionary`2<string, string> parameters, Nullable`1<int> length);
    public static IType GetDefaultTypeFor(Type type);
    public static NullableType GetAnsiStringType(int length);
    public static NullableType GetBinaryType(int length);
    private static NullableType GetType(NullableType defaultUnqualifiedType, int lengthOrScale, GetNullableTypeWithLengthOrScale ctorDelegate);
    private static NullableType GetType(NullableType defaultUnqualifiedType, byte precision, byte scale, NullableTypeCreatorDelegate ctor);
    public static NullableType GetSerializableType(Type serializableType);
    public static NullableType GetSerializableType(Type serializableType, int length);
    public static NullableType GetSerializableType(int length);
    public static NullableType GetStringType(int length);
    public static NullableType GetTypeType(int length);
    public static NullableType GetDateTimeType(byte fractionalSecondsPrecision);
    [ObsoleteAttribute("Use GetDateTimeType instead, it uses DateTime2 with dialects supporting it.")]
public static NullableType GetDateTime2Type(byte fractionalSecondsPrecision);
    public static NullableType GetLocalDateTimeType(byte fractionalSecondsPrecision);
    public static NullableType GetUtcDateTimeType(byte fractionalSecondsPrecision);
    public static NullableType GetDateTimeOffsetType(byte fractionalSecondsPrecision);
    public static NullableType GetTimeAsTimeSpanType(byte fractionalSecondsPrecision);
    public static NullableType GetTimeType(byte fractionalSecondsPrecision);
    public static EntityType OneToOne(string persistentClass, ForeignKeyDirection foreignKeyType, string uniqueKeyPropertyName, bool lazy, bool unwrapProxy, string entityName, string propertyName);
    public static EntityType ManyToOne(string persistentClass);
    public static EntityType ManyToOne(string persistentClass, bool lazy);
    public static EntityType ManyToOne(string persistentClass, string uniqueKeyPropertyName, bool lazy, bool unwrapProxy, bool ignoreNotFound, bool isLogicalOneToOne, string propertyName);
    [ObsoleteAttribute("Use ManyToOne with propertyName")]
public static EntityType ManyToOne(string persistentClass, string uniqueKeyPropertyName, bool lazy, bool unwrapProxy, bool ignoreNotFound, bool isLogicalOneToOne);
    public static CollectionType Array(string role, string propertyRef, Type elementClass);
    public static CollectionType GenericBag(string role, string propertyRef, Type elementClass);
    public static CollectionType GenericIdBag(string role, string propertyRef, Type elementClass);
    public static CollectionType GenericList(string role, string propertyRef, Type elementClass);
    public static CollectionType GenericMap(string role, string propertyRef, Type indexClass, Type elementClass);
    public static CollectionType GenericSortedList(string role, string propertyRef, object comparer, Type indexClass, Type elementClass);
    public static CollectionType GenericSortedDictionary(string role, string propertyRef, object comparer, Type indexClass, Type elementClass);
    public static CollectionType GenericSet(string role, string propertyRef, Type elementClass);
    public static CollectionType GenericSortedSet(string role, string propertyRef, object comparer, Type elementClass);
    public static CollectionType GenericOrderedSet(string role, string propertyRef, Type elementClass);
    public static CollectionType CustomCollection(string typeName, IDictionary`2<string, string> typeParameters, string role, string propertyRef);
    public static void InjectParameters(object type, IDictionary`2<string, string> parameters);
}
public static class NHibernate.Type.TypeHelper : object {
    public static IType[] EmptyTypeArray;
    private static TypeHelper();
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<BeforeAssembleAsync>d__0")]
public static Task BeforeAssembleAsync(Object[] row, ICacheAssembler[] types, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<AssembleAsync>d__1")]
public static Task`1<Object[]> AssembleAsync(Object[] row, ICacheAssembler[] types, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<AssembleAsync>d__2")]
internal static Task`1<Object[]> AssembleAsync(Object[] row, ICacheAssembler[] types, IList`1<int> typeIndexes, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<InitializeCollectionsAsync>d__3")]
internal static Task InitializeCollectionsAsync(Object[] cacheRow, Object[] assembleRow, IDictionary`2<int, ICollectionPersister> collectionIndexes, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<DisassembleAsync>d__4")]
public static Task`1<Object[]> DisassembleAsync(Object[] row, ICacheAssembler[] types, Boolean[] nonCacheable, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<ReplaceAsync>d__5")]
public static Task`1<Object[]> ReplaceAsync(Object[] original, Object[] target, IType[] types, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<ReplaceAsync>d__6")]
public static Task`1<Object[]> ReplaceAsync(Object[] original, Object[] target, IType[] types, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<ReplaceAssociationsAsync>d__7")]
public static Task`1<Object[]> ReplaceAssociationsAsync(Object[] original, Object[] target, IType[] types, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use overload without anyUninitializedProperties parameter instead")]
public static Task`1<Int32[]> FindDirtyAsync(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, bool anyUninitializedProperties, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<FindDirtyAsync>d__9")]
public static Task`1<Int32[]> FindDirtyAsync(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<DirtyAsync>d__10")]
private static Task`1<bool> DirtyAsync(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, ISessionImplementor session, int i, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use the overload without anyUninitializedProperties parameter.")]
public static Task`1<Int32[]> FindModifiedAsync(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, bool anyUninitializedProperties, ISessionImplementor session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NHibernate.Type.TypeHelper/<FindModifiedAsync>d__12")]
public static Task`1<Int32[]> FindModifiedAsync(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, ISessionImplementor session, CancellationToken cancellationToken);
    public static void DeepCopy(Object[] values, IType[] types, Boolean[] copy, Object[] target, ISessionImplementor session);
    public static void BeforeAssemble(Object[] row, ICacheAssembler[] types, ISessionImplementor session);
    public static Object[] Assemble(Object[] row, ICacheAssembler[] types, ISessionImplementor session, object owner);
    internal static Object[] Assemble(Object[] row, ICacheAssembler[] types, IList`1<int> typeIndexes, ISessionImplementor session);
    internal static void InitializeCollections(Object[] cacheRow, Object[] assembleRow, IDictionary`2<int, ICollectionPersister> collectionIndexes, ISessionImplementor session);
    public static Object[] Disassemble(Object[] row, ICacheAssembler[] types, Boolean[] nonCacheable, ISessionImplementor session, object owner);
    public static Object[] Replace(Object[] original, Object[] target, IType[] types, ISessionImplementor session, object owner, IDictionary copiedAlready);
    public static Object[] Replace(Object[] original, Object[] target, IType[] types, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection);
    public static Object[] ReplaceAssociations(Object[] original, Object[] target, IType[] types, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection);
    [ObsoleteAttribute("Use overload without anyUninitializedProperties parameter instead")]
public static Int32[] FindDirty(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, bool anyUninitializedProperties, ISessionImplementor session);
    public static Int32[] FindDirty(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, ISessionImplementor session);
    private static bool Dirty(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, ISessionImplementor session, int i);
    [ObsoleteAttribute("Use the overload without anyUninitializedProperties parameter.")]
public static Int32[] FindModified(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, bool anyUninitializedProperties, ISessionImplementor session);
    public static Int32[] FindModified(StandardProperty[] properties, Object[] currentState, Object[] previousState, Boolean[][] includeColumns, ISessionImplementor session);
}
public class NHibernate.Type.TypeType : ImmutableType {
    public SqlType SqlType { get; }
    public Type ReturnedClass { get; }
    public string Name { get; }
    internal TypeType(StringSqlType sqlType);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual SqlType get_SqlType();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object value);
    public virtual Type get_ReturnedClass();
    public virtual string get_Name();
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    private static string GetStringRepresentation(object value);
    private static object ParseStringRepresentation(object value);
}
public class NHibernate.Type.UInt16Type : PrimitiveType {
    private static ushort ZERO;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand rs, object value, int index, ISessionImplementor session);
    public sealed virtual object StringToObject(string xml);
    public virtual object FromStringValue(string xml);
    public virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    public sealed virtual IComparer get_Comparator();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.UInt32Type : PrimitiveType {
    private static UInt32 ZERO;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand rs, object value, int index, ISessionImplementor session);
    public sealed virtual object StringToObject(string xml);
    public virtual object FromStringValue(string xml);
    public virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    public sealed virtual IComparer get_Comparator();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.UInt64Type : PrimitiveType {
    private static UInt32 ZERO;
    public string Name { get; }
    public Type ReturnedClass { get; }
    public IComparer Comparator { get; }
    public Type PrimitiveClass { get; }
    public object DefaultValue { get; }
    public virtual Task`1<object> NextAsync(object current, ISessionImplementor session, CancellationToken cancellationToken);
    public virtual Task`1<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand rs, object value, int index, ISessionImplementor session);
    public sealed virtual object StringToObject(string xml);
    public virtual object FromStringValue(string xml);
    public virtual object Next(object current, ISessionImplementor session);
    public virtual object Seed(ISessionImplementor session);
    public sealed virtual IComparer get_Comparator();
    public virtual Type get_PrimitiveClass();
    public virtual object get_DefaultValue();
    public virtual string ObjectToSQLString(object value, Dialect dialect);
}
public class NHibernate.Type.UriType : ImmutableType {
    public string Name { get; }
    public Type ReturnedClass { get; }
    public UriType(SqlType sqlType);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual Type get_ReturnedClass();
    public sealed virtual object StringToObject(string xml);
    private static string GetStringRepresentation(object value);
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public sealed virtual string ObjectToSQLString(object value, Dialect dialect);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
}
public class NHibernate.Type.UtcDateTimeNoMsType : DateTimeNoMsType {
    protected DateTimeKind Kind { get; }
    public string Name { get; }
    protected virtual DateTimeKind get_Kind();
    public virtual string get_Name();
}
public class NHibernate.Type.UtcDateTimeType : DateTimeType {
    protected DateTimeKind Kind { get; }
    public string Name { get; }
    public UtcDateTimeType(DateTimeSqlType sqlType);
    protected virtual DateTimeKind get_Kind();
    public virtual string get_Name();
}
public class NHibernate.Type.UtcDbTimestampType : DbTimestampType {
    public string Name { get; }
    protected DateTimeKind Kind { get; }
    public virtual string get_Name();
    protected virtual DateTimeKind get_Kind();
    protected virtual bool SupportsCurrentTimestampSelection(Dialect dialect);
    protected virtual string GetCurrentTimestampSelectString(Dialect dialect);
}
public class NHibernate.Type.UtcTicksType : TicksType {
    protected DateTimeKind Kind { get; }
    public string Name { get; }
    protected virtual DateTimeKind get_Kind();
    public virtual string get_Name();
}
public class NHibernate.Type.XDocType : MutableType {
    public string Name { get; }
    public Type ReturnedClass { get; }
    public XDocType(SqlType sqlType);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual object DeepCopyNotNull(object value);
    public virtual bool IsEqual(object x, object y);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    private static string GetStringRepresentation(object value);
    private static object ParseStringRepresentation(string value);
}
public class NHibernate.Type.XmlDocType : MutableType {
    public string Name { get; }
    public Type ReturnedClass { get; }
    public XmlDocType(SqlType sqlType);
    public virtual Task`1<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual Task`1<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);
    public virtual string get_Name();
    public virtual Type get_ReturnedClass();
    public virtual void Set(DbCommand cmd, object value, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, int index, ISessionImplementor session);
    public virtual object Get(DbDataReader rs, string name, ISessionImplementor session);
    public virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version. Override ToLoggableString instead.")]
public virtual string ToString(object val);
    [ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public virtual object FromStringValue(string xml);
    public virtual object DeepCopyNotNull(object value);
    public virtual bool IsEqual(object x, object y);
    public virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public virtual object Disassemble(object value, ISessionImplementor session, object owner);
    private static string GetStringRepresentation(object value);
    private static object ParseStringRepresentation(string value);
}
public class NHibernate.Type.YesNoType : CharBooleanType {
    protected string TrueString { get; }
    protected string FalseString { get; }
    public string Name { get; }
    protected sealed virtual string get_TrueString();
    protected sealed virtual string get_FalseString();
    public virtual string get_Name();
}
public class NHibernate.TypeMismatchException : HibernateException {
    public TypeMismatchException(string message);
    public TypeMismatchException(string message, Exception inner);
    protected TypeMismatchException(SerializationInfo info, StreamingContext context);
}
public class NHibernate.UnresolvableObjectException : HibernateException {
    private object identifier;
    private Type clazz;
    private string entityName;
    public object Identifier { get; }
    public string Message { get; }
    public Type PersistentClass { get; }
    public string EntityName { get; }
    public UnresolvableObjectException(object identifier, Type clazz);
    public UnresolvableObjectException(object identifier, string entityName);
    public UnresolvableObjectException(string message, object identifier, Type clazz);
    public UnresolvableObjectException(string message, object identifier, string entityName);
    protected UnresolvableObjectException(SerializationInfo info, StreamingContext context);
    public object get_Identifier();
    public virtual string get_Message();
    public Type get_PersistentClass();
    public string get_EntityName();
    public static void ThrowIfNull(object o, object id, Type clazz);
    public static void ThrowIfNull(object o, object id, string entityName);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public interface NHibernate.UserTypes.ICompositeUserType {
    public String[] PropertyNames { get; }
    public IType[] PropertyTypes { get; }
    public Type ReturnedClass { get; }
    public bool IsMutable { get; }
    public abstract virtual String[] get_PropertyNames();
    public abstract virtual IType[] get_PropertyTypes();
    public abstract virtual object GetPropertyValue(object component, int property);
    public abstract virtual void SetPropertyValue(object component, int property, object value);
    public abstract virtual Type get_ReturnedClass();
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object x);
    public abstract virtual object NullSafeGet(DbDataReader dr, String[] names, ISessionImplementor session, object owner);
    public abstract virtual void NullSafeSet(DbCommand cmd, object value, int index, Boolean[] settable, ISessionImplementor session);
    public abstract virtual object DeepCopy(object value);
    public abstract virtual bool get_IsMutable();
    public abstract virtual object Disassemble(object value, ISessionImplementor session);
    public abstract virtual object Assemble(object cached, ISessionImplementor session, object owner);
    public abstract virtual object Replace(object original, object target, ISessionImplementor session, object owner);
}
public interface NHibernate.UserTypes.IEnhancedUserType {
    [ObsoleteAttribute("This method was not used for parsing xml strings, but instead used for parsing already de-encoded strings originating from xml (so indeed, plain text strings). It will be renamed "FromString" in a future version. Implement a "object FromString(string value)" without any xml de-coding, called by your"object FromXMLString(string xml)", in order to get ready for the rename.")]
public abstract virtual object FromXMLString(string xml);
    public abstract virtual string ObjectToSQLString(object value);
    [ObsoleteAttribute("This method was not used in a xml context, but instead just used for logs. It will be renamed "ToString" in a future version. Implement a "string ToString(object value)", called by your "string ToXMLString(object value)", in order to get ready for the rename.")]
public abstract virtual string ToXMLString(object value);
}
[ObsoleteAttribute("This interface has no usage and will be removed in a future version")]
public interface NHibernate.UserTypes.ILoggableUserType {
    public abstract virtual string ToLoggableString(object value, ISessionFactoryImplementor factory);
}
public interface NHibernate.UserTypes.IParameterizedType {
    public abstract virtual void SetParameterValues(IDictionary`2<string, string> parameters);
}
public interface NHibernate.UserTypes.IUserCollectionType {
    public abstract virtual IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister);
    public abstract virtual IPersistentCollection Wrap(ISessionImplementor session, object collection);
    public abstract virtual IEnumerable GetElements(object collection);
    public abstract virtual bool Contains(object collection, object entity);
    public abstract virtual object IndexOf(object collection, object entity);
    public abstract virtual object ReplaceElements(object original, object target, ICollectionPersister persister, object owner, IDictionary copyCache, ISessionImplementor session);
    public abstract virtual object Instantiate(int anticipatedSize);
}
public interface NHibernate.UserTypes.IUserType {
    public SqlType[] SqlTypes { get; }
    public Type ReturnedType { get; }
    public bool IsMutable { get; }
    public abstract virtual SqlType[] get_SqlTypes();
    public abstract virtual Type get_ReturnedType();
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object x);
    public abstract virtual object NullSafeGet(DbDataReader rs, String[] names, ISessionImplementor session, object owner);
    public abstract virtual void NullSafeSet(DbCommand cmd, object value, int index, ISessionImplementor session);
    public abstract virtual object DeepCopy(object value);
    public abstract virtual bool get_IsMutable();
    public abstract virtual object Replace(object original, object target, object owner);
    public abstract virtual object Assemble(object cached, object owner);
    public abstract virtual object Disassemble(object value);
}
public interface NHibernate.UserTypes.IUserVersionType {
    public abstract virtual object Seed(ISessionImplementor session);
    public abstract virtual object Next(object current, ISessionImplementor session);
}
public class NHibernate.Util.ADOExceptionReporter : object {
    private static INHibernateLogger log;
    public static string DefaultExceptionMsg;
    private static ADOExceptionReporter();
    public static void LogExceptions(Exception ex);
    public static void LogExceptions(Exception ex, string message);
}
[ExtensionAttribute]
public static class NHibernate.Util.ArrayHelper : object {
    public static Boolean[] True;
    public static Boolean[] False;
    [ObsoleteAttribute("Please use System.Array.Empty<object>() instead")]
public static Object[] EmptyObjectArray { get; }
    [ObsoleteAttribute("Please use System.Array.Empty<int>() instead")]
public static Int32[] EmptyIntArray { get; }
    [ObsoleteAttribute("Please use System.Array.Empty<bool>() instead")]
public static Boolean[] EmptyBoolArray { get; }
    private static ArrayHelper();
    public static Object[] get_EmptyObjectArray();
    public static Int32[] get_EmptyIntArray();
    public static Boolean[] get_EmptyBoolArray();
    internal static bool IsNullOrEmpty(Array array);
    public static bool IsAllNegative(Int32[] array);
    public static T[] Fill(T value, int length);
    public static void Fill(T[] array, T value);
    public static T[] Slice(T[] strings, int begin, int length);
    public static T[] Join(T[] x, T[] y, Boolean[] use);
    public static T[] Join(T[] x, T[] y);
    public static bool IsAllFalse(Boolean[] array);
    public static string ToString(Object[] array);
    public static void AddAll(IList to, IList from);
    public static void AddAll(IList`1<T> to, IList`1<T> from);
    public static void AddAll(IDictionary`2<TKey, TValue> to, IDictionary`2<TKey, TValue> from);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> AddOrOverride(IDictionary`2<TKey, TValue> destination, IDictionary`2<TKey, TValue> sourceOverride);
    public static Int32[] GetBatchSizes(int maxBatchSize);
    private static int GetNextBatchSize(int batchSize);
    public static int CountTrue(Boolean[] array);
    [IteratorStateMachineAttribute("NHibernate.Util.ArrayHelper/<IndexesOf>d__24`1")]
internal static IEnumerable`1<int> IndexesOf(T[] array, T value);
    public static bool ArrayEquals(T[] a, T[] b);
    public static bool ArrayEquals(Byte[] a, Byte[] b);
    public static int ArrayGetHashCode(T[] array);
    internal static T[] Append(T[] array, T value);
}
public class NHibernate.Util.AssemblyQualifiedTypeName : object {
    private string type;
    private string assembly;
    private int hashCode;
    public string Type { get; }
    public string Assembly { get; }
    public AssemblyQualifiedTypeName(string type, string assembly);
    public string get_Type();
    public string get_Assembly();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public bool Equals(AssemblyQualifiedTypeName obj);
    public virtual int GetHashCode();
}
public class NHibernate.Util.AsyncLock : object {
    private SemaphoreSlim _semaphore;
    private IDisposable _releaser;
    private Task`1<IDisposable> _releaserTask;
    public Task`1<IDisposable> LockAsync();
    public IDisposable Lock();
}
internal class NHibernate.Util.AsyncReaderWriterLock : object {
    private SemaphoreSlim _writeLockSemaphore;
    private SemaphoreSlim _readLockSemaphore;
    private Releaser _writerReleaser;
    private Releaser _readerReleaser;
    private Task`1<Releaser> _readerReleaserTask;
    private SemaphoreSlim _waitingReadLockSemaphore;
    private SemaphoreSlim _waitingDisposalSemaphore;
    private int _readersWaiting;
    private int _currentReaders;
    private int _writersWaiting;
    private bool _disposed;
    internal int CurrentReaders { get; }
    internal int WritersWaiting { get; }
    internal int ReadersWaiting { get; }
    internal bool Writing { get; }
    internal bool AcquiredWriteLock { get; }
    internal int get_CurrentReaders();
    internal int get_WritersWaiting();
    internal int get_ReadersWaiting();
    internal bool get_Writing();
    internal bool get_AcquiredWriteLock();
    private sealed virtual override IDisposable NHibernate.Cache.ICacheLock.WriteLock();
    public Releaser WriteLock();
    [AsyncStateMachineAttribute("NHibernate.Util.AsyncReaderWriterLock/<NHibernate-Cache-ICacheLock-WriteLockAsync>d__24")]
private sealed virtual override Task`1<IDisposable> NHibernate.Cache.ICacheLock.WriteLockAsync();
    [AsyncStateMachineAttribute("NHibernate.Util.AsyncReaderWriterLock/<WriteLockAsync>d__25")]
public Task`1<Releaser> WriteLockAsync();
    private sealed virtual override IDisposable NHibernate.Cache.ICacheLock.ReadLock();
    public Releaser ReadLock();
    [AsyncStateMachineAttribute("NHibernate.Util.AsyncReaderWriterLock/<NHibernate-Cache-ICacheLock-ReadLockAsync>d__28")]
private sealed virtual override Task`1<IDisposable> NHibernate.Cache.ICacheLock.ReadLockAsync();
    public Task`1<Releaser> ReadLockAsync();
    public sealed virtual void Dispose();
    private bool CanEnterWriteLock(Boolean& waitForReadLocks);
    private void ExitWriteLock();
    private bool CanEnterReadLock(SemaphoreSlim& waitingReadLockSemaphore);
    private void ExitReadLock();
    private void DisposeWaitingSemaphore();
    private void AssertNotDisposed();
}
[ExtensionAttribute]
public static class NHibernate.Util.CollectionHelper : object {
    public static IEnumerable EmptyEnumerable;
    public static IDictionary EmptyMap;
    public static ICollection EmptyCollection;
    [ObsoleteAttribute("It has no more usages in NHibernate and will be removed in a future version.")]
public static IList EmptyList;
    private static CollectionHelper();
    public static IDictionary`2<TKey, TValue> EmptyDictionary();
    internal static ISet`1<T> EmptySet();
    [ObsoleteAttribute("It has no more usages in NHibernate and will be removed in a future version.")]
public static bool CollectionEquals(ICollection c1, ICollection c2);
    [ObsoleteAttribute("It has no more usages in NHibernate and will be removed in a future version.")]
public static bool DictionaryEquals(IDictionary a, IDictionary b);
    [ObsoleteAttribute("It has no more usages in NHibernate and will be removed in a future version.")]
public static int GetHashCode(IEnumerable coll);
    public static IDictionary`2<string, T> CreateCaseInsensitiveHashtable();
    public static IDictionary`2<string, T> CreateCaseInsensitiveHashtable(IDictionary`2<string, T> dictionary);
    public static int GetHashCode(IEnumerable`1<T> coll);
    public static int GetHashCode(IEnumerable`1<T> coll, IEqualityComparer`1<T> comparer);
    public static bool SetEquals(ISet`1<T> s1, ISet`1<T> s2);
    [ObsoleteAttribute("Please use SequenceEquals instead.")]
public static bool CollectionEquals(ICollection`1<T> c1, ICollection`1<T> c2);
    public static bool SequenceEquals(IEnumerable`1<T> c1, IEnumerable`1<T> c2);
    public static bool SequenceEquals(IEnumerable`1<T> c1, IEnumerable`1<T> c2, IEqualityComparer`1<T> comparer);
    public static bool BagEquals(IEnumerable`1<T> c1, IEnumerable`1<T> c2);
    public static bool BagEquals(IEnumerable`1<T> c1, IEnumerable`1<T> c2, IEqualityComparer`1<T> comparer);
    public static bool DictionaryEquals(IDictionary`2<K, V> m1, IDictionary`2<K, V> m2);
    public static bool DictionaryEquals(IDictionary`2<K, V> m1, IDictionary`2<K, V> m2, IEqualityComparer`1<V> comparer);
    [ExtensionAttribute]
internal static bool Remove(Dictionary`2<TKey, TValue> dic, TKey key, TValue& value);
    private static Nullable`1<bool> FastCheckEquality(IEnumerable`1<T> c1, IEnumerable`1<T> c2);
}
public static class NHibernate.Util.CollectionPrinter : object {
    private static void AppendNullOrValue(StringBuilder builder, object value);
    public static string ToString(IDictionary dictionary);
    public static string ToString(IDictionary`2<string, string> dictionary);
    public static string ToString(IEnumerable elements);
}
[ExtensionAttribute]
internal static class NHibernate.Util.DbTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsStringType(DbType dbType);
}
internal static class NHibernate.Util.DelegateHelper : object {
    public static Func`2<object, T> BuildPropertyGetter(Type type, string propertyName);
    public static Action`2<object, T> BuildPropertySetter(Type type, string propertyName);
    public static Action`1<object> BuildAction(Type type, string methodName);
    public static Action`2<object, T> BuildAction(Type type, string methodName);
    public static Action`3<object, T1, T2> BuildAction(Type type, string methodName);
    public static Func`2<object, TReturn> BuildFunc(Type type, string methodName);
    private static MethodInfo GetMethod(Type type, string methodName, Type[] types);
}
public class NHibernate.Util.DynamicComponent : DynamicObject {
    private Dictionary`2<string, object> _data;
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private DynamicComponent(SerializationInfo info, StreamingContext context);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[ExtensionAttribute]
public static class NHibernate.Util.EnumerableExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Enumerable.Any<T>(IEnumerable<T>) instead.")]
public static bool Any(IEnumerable source);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Enumerable.First<T>(IEnumerable<T>) instead.")]
public static object First(IEnumerable source);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Enumerable.FirstOrDefault<T>(IEnumerable<T>) instead.")]
public static object FirstOrNull(IEnumerable source);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use a loop instead.")]
public static void ForEach(IEnumerable`1<T> query, Action`1<T> method);
    [ExtensionAttribute]
internal static TOutput[] ToArray(ICollection`1<TInput> input, Func`2<TInput, TOutput> converter);
    [ExtensionAttribute]
internal static TOutput[] ToArray(List`1<TInput> input, Func`2<TInput, TOutput> converter);
    [ExtensionAttribute]
internal static TOutput[] ToArray(TInput[] input, Converter`2<TInput, TOutput> converter);
    [ExtensionAttribute]
internal static List`1<TOutput> ToList(ICollection`1<TInput> input, Func`2<TInput, TOutput> converter);
    [ExtensionAttribute]
internal static List`1<TOutput> ToList(TInput[] input, Func`2<TInput, TOutput> converter);
    [ExtensionAttribute]
internal static List`1<TOutput> ToList(List`1<TInput> input, Converter`2<TInput, TOutput> converter);
    [ExtensionAttribute]
internal static IList ToIList(IEnumerable`1<T> list);
    [ExtensionAttribute]
internal static IReadOnlyList`1<T> EmptyIfNull(IReadOnlyList`1<T> list);
    [IteratorStateMachineAttribute("NHibernate.Util.EnumerableExtensions/<CastOrDefault>d__12`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> CastOrDefault(IEnumerable list);
}
public class NHibernate.Util.EnumeratorAdapter`1 : object {
    private IEnumerator _wrapped;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public EnumeratorAdapter`1(IEnumerator wrapped);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public static class NHibernate.Util.EqualsHelper : object {
    [ObsoleteAttribute("Please use object.Equals(object, object) instead.")]
public static bool Equals(object x, object y);
}
public static class NHibernate.Util.ExpressionsHelper : object {
    public static MemberInfo DecodeMemberAccessExpression(Expression`1<Func`2<TEntity, TResult>> expression);
    internal static bool TryGetDynamicMemberBinder(InvocationExpression expression, GetMemberBinder& memberBinder);
    internal static bool IsVariable(Expression expression, String& path, Object& closureContext);
    internal static IType GetType(VisitorParameters parameters, Expression expression);
    internal static bool TryGetMappedNullability(ISessionFactoryImplementor sessionFactory, Expression expression, Boolean& nullable);
    internal static bool TryGetMappedType(ISessionFactoryImplementor sessionFactory, Expression expression, IType& mappedType, IEntityPersister& entityPersister, IAbstractComponentType& component, String& memberPath);
    private static bool ProcessMembersMetadataResult(MemberMetadataResult metadataResult, ISessionFactoryImplementor sessionFactory, IType& mappedType, IEntityPersister& entityPersister, IAbstractComponentType& component, String& memberPath);
    private static bool TraverseMembers(ISessionFactoryImplementor sessionFactory, Stack`1<MemberMetadata> memberPaths, IEntityPersister currentEntityPersister, IType& mappedType, IEntityPersister& entityPersister, IAbstractComponentType& component, String& memberPath);
    private static IType GetPropertyType(IEntityPersister currentEntityPersister, string path);
    private static IType TryGetComponentPropertyType(IAbstractComponentType componentType, string memberPath);
    private static void ProcessAssociationType(IAssociationType associationType, ISessionFactoryImplementor sessionFactory, MemberMetadata member, Type convertType, IType& memberType, IEntityPersister& memberPersister, IAbstractComponentType& memberComponent);
    private static bool TryGetEntityPersister(string currentEntityName, Type convertedType, ISessionFactoryImplementor sessionFactory, IEntityPersister& persister);
    private static bool TryGetEntityPersister(IEntityPersister currentEntityPersister, Type convertedType, ISessionFactoryImplementor sessionFactory, IEntityPersister& persister);
    private static bool TryGetEntityPersister(Type convertedType, ISessionFactoryImplementor sessionFactory, IEntityPersister& persister);
    private static IType GetType(IEntityPersister currentEntityPersister, IType currentType, MemberMetadata member, ISessionFactoryImplementor sessionFactory);
}
public class NHibernate.Util.FilterHelper : object {
    private String[] filterNames;
    private String[] filterConditions;
    public FilterHelper(IDictionary`2<string, string> filters, Dialect dialect, SQLFunctionRegistry sqlFunctionRegistry);
    public bool IsAffectedBy(IDictionary`2<string, IFilter> enabledFilters);
    public string Render(string alias, IDictionary`2<string, IFilter> enabledFilters);
    public void Render(StringBuilder buffer, string alias, IDictionary`2<string, IFilter> enabledFilters);
    public void Render(StringBuilder buffer, string defaultAlias, IDictionary`2<string, string> propMap, IDictionary`2<string, IFilter> enabledFilters);
    private static void AddFilterString(StringBuilder buffer, string defaultAlias, IDictionary`2<string, string> propMap, string condition);
    public static IDictionary`2<string, IFilter> GetEnabledForManyToOne(IDictionary`2<string, IFilter> enabledFilters);
    internal static SqlString ExpandDynamicFilterParameters(SqlString sqlString, ICollection`1<IParameterSpecification> parameterSpecs, ISessionImplementor session);
}
internal static class NHibernate.Util.Hasher : object {
    private static UInt32 _m;
    private static int _r;
    internal static string HashToString(string input);
    internal static UInt32 Hash(string input);
    internal static UInt32 Hash(Byte[] data);
    internal static UInt32 Hash(Byte[] data, UInt32 seed);
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Util.IdentityMap : object {
    private IDictionary map;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public object Item { get; public set; }
    public ICollection Values { get; }
    public IList EntryList { get; }
    private IdentityMap(IDictionary underlyingMap);
    public static IDictionary Instantiate(int size);
    public static IDictionary InstantiateSequenced(int size);
    public static ICollection ConcurrentEntries(IDictionary map);
    public static ICollection Entries(IDictionary map);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void Add(object key, object val);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual void Remove(object key);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Values();
    public sealed virtual void CopyTo(Array array, int i);
    public IList get_EntryList();
    private object VerifyValidKey(object obj);
    public static IDictionary Invert(IDictionary map);
    public sealed virtual void OnDeserialization(object sender);
}
[ObsoleteAttribute("This class has no more usages and will be removed in a future version")]
public class NHibernate.Util.IdentitySet : object {
    private IDictionary map;
    private static object DumpValue;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IdentitySet(IEnumerable`1<object> members);
    private static IdentitySet();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.Add(object item);
    public sealed virtual bool Add(object o);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object o);
    public sealed virtual bool Remove(object o);
    public sealed virtual void CopyTo(Object[] array, int index);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void UnionWith(IEnumerable`1<object> other);
    public sealed virtual void IntersectWith(IEnumerable`1<object> other);
    public sealed virtual void ExceptWith(IEnumerable`1<object> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<object> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<object> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<object> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<object> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<object> other);
    public sealed virtual bool Overlaps(IEnumerable`1<object> other);
    public sealed virtual bool SetEquals(IEnumerable`1<object> other);
}
public class NHibernate.Util.JoinedEnumerable : object {
    private static INHibernateLogger log;
    private IEnumerable[] _enumerables;
    public JoinedEnumerable(IEnumerable[] enumerables);
    public JoinedEnumerable(IEnumerable`1<IEnumerable> enumerables);
    public JoinedEnumerable(IEnumerable first, IEnumerable second);
    private static JoinedEnumerable();
    public sealed virtual IEnumerator GetEnumerator();
}
[ObsoleteAttribute("This class has no more usages and will be removed in a future version")]
public class NHibernate.Util.JoinedEnumerable`1 : object {
    private IEnumerable`1[] enumerables;
    public JoinedEnumerable`1(IEnumerable`1[] enumerables);
    public JoinedEnumerable`1(List`1<IEnumerable`1<T>> enumerables);
    public JoinedEnumerable`1(IEnumerable`1<T> first, IEnumerable`1<T> second);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public sealed virtual IEnumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.CollectionProxy`1")]
public class NHibernate.Util.LinkedHashMap`2 : object {
    private Entry<TKey, TValue> header;
    private Dictionary`2<TKey, Entry<TKey, TValue>> entries;
    private long version;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public TKey FirstKey { get; }
    public TValue FirstValue { get; }
    public TKey LastKey { get; }
    public TValue LastValue { get; }
    private Entry<TKey, TValue> First { get; }
    private Entry<TKey, TValue> Last { get; }
    public LinkedHashMap`2(int capacity);
    public LinkedHashMap`2(IEqualityComparer`1<TKey> equalityComparer);
    public LinkedHashMap`2(int capacity, IEqualityComparer`1<TKey> equalityComparer);
    public virtual bool ContainsKey(TKey key);
    public virtual void Add(TKey key, TValue value);
    public virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private void OverrideEntry(Entry<TKey, TValue> e, TValue value);
    public virtual ICollection`1<TKey> get_Keys();
    public virtual ICollection`1<TValue> get_Values();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private bool get_IsEmpty();
    public virtual bool get_IsFixedSize();
    public virtual TKey get_FirstKey();
    public virtual TValue get_FirstValue();
    public virtual TKey get_LastKey();
    public virtual TValue get_LastValue();
    public virtual bool Contains(TKey key);
    public virtual bool ContainsValue(TValue value);
    private static Entry<TKey, TValue> CreateSentinel();
    private static void RemoveEntry(Entry<TKey, TValue> entry);
    private void InsertEntry(Entry<TKey, TValue> entry);
    private Entry<TKey, TValue> get_First();
    private Entry<TKey, TValue> get_Last();
    private bool RemoveImpl(TKey key);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Util.LRUMap : SequencedHashMap {
    private int maximumSize;
    public object Item { get; public set; }
    public int MaximumSize { get; public set; }
    public LRUMap(int capacity);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual void Add(object key, object value);
    private void RemoveLRU();
    protected void ProcessRemovedLRU(object key, object value);
    public int get_MaximumSize();
    public void set_MaximumSize(int value);
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Util.NullableDictionary`2 : object {
    private TValue _nullValue;
    private bool _gotNullValue;
    private Dictionary`2<TKey, TValue> _dict;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public NullableDictionary`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    [IteratorStateMachineAttribute("NHibernate.Util.NullableDictionary`2/<GetEnumerator>d__16")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public static class NHibernate.Util.ObjectHelpers : object {
    public static string IdentityToString(object obj);
}
internal static class NHibernate.Util.ParameterHelper : object {
    public static IType TryGuessType(object param, ISessionFactoryImplementor sessionFactory, bool isCollection);
    public static IType GuessType(object param, ISessionFactoryImplementor sessionFactory);
    public static IType TryGuessType(Type clazz, ISessionFactoryImplementor sessionFactory, bool isCollection);
    public static IType GuessType(Type clazz, ISessionFactoryImplementor sessionFactory);
    public static IType TryGuessType(Type clazz, ISessionFactoryImplementor sessionFactory);
}
public class NHibernate.Util.ParserException : Exception {
    public ParserException(string message);
    protected ParserException(SerializationInfo info, StreamingContext context);
}
public static class NHibernate.Util.PropertiesHelper : object {
    public static bool GetBoolean(string property, IDictionary`2<string, string> properties, bool defaultValue);
    public static bool GetBoolean(string property, IDictionary`2<string, string> properties);
    public static Nullable`1<byte> GetByte(string property, IDictionary`2<string, string> properties, Nullable`1<byte> defaultValue);
    public static int GetInt32(string property, IDictionary`2<string, string> properties, int defaultValue);
    public static long GetInt64(string property, IDictionary`2<string, string> properties, long defaultValue);
    public static string GetString(string property, IDictionary`2<string, string> properties, string defaultValue);
    public static TEnum GetEnum(string property, IDictionary`2<string, string> properties, TEnum defaultValue);
    public static IDictionary`2<string, string> ToDictionary(string property, string delim, IDictionary`2<string, string> properties);
}
internal class NHibernate.Util.ReferenceComparer`1 : object {
    public static ReferenceComparer`1<T> Instance;
    private static ReferenceComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
}
[ExtensionAttribute]
public static class NHibernate.Util.ReflectHelper : object {
    private static INHibernateLogger log;
    public static BindingFlags AnyVisibilityInstance;
    private static Type[] NoClasses;
    private static MethodInfo Exception_InternalPreserveStackTrace;
    private static ReflectHelper();
    internal static T CastOrThrow(object obj, string supportMessage);
    public static MethodInfo GetMethodDefinition(Expression`1<Action`1<TSource>> method);
    public static MethodInfo GetMethod(Expression`1<Action`1<TSource>> method);
    public static MethodInfo GetMethod(Expression`1<Func`2<TSource, TResult>> method);
    public static MethodInfo GetMethodDefinition(Expression`1<Action> method);
    public static MethodInfo GetMethod(Expression`1<Action> method);
    internal static MethodInfo FastGetMethod(Func`1<TResult> func);
    internal static MethodInfo FastGetMethod(Func`2<T, TResult> func, T a);
    internal static MethodInfo FastGetMethod(Func`3<T1, T2, TResult> func, T1 a1, T2 a2);
    internal static MethodInfo FastGetMethod(Func`4<T1, T2, T3, TResult> func, T1 a1, T2 a2, T3 a3);
    internal static MethodInfo FastGetMethodDefinition(Func`2<T, TResult> func, T a);
    internal static MethodInfo FastGetMethodDefinition(Func`3<T1, T2, TResult> func, T1 a1, T2 a2);
    internal static MethodInfo FastGetMethodDefinition(Func`4<T1, T2, T3, TResult> func, T1 a1, T2 a2, T3 a3);
    internal static MethodInfo FastGetMethodDefinition(Func`5<T1, T2, T3, T4, TResult> func, T1 a1, T2 a2, T3 a3, T4 a4);
    internal static MethodInfo FastGetMethodDefinition(Func`6<T1, T2, T3, T4, T5, TResult> func, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5);
    public static MethodInfo GetMethodOverload(MethodInfo method, Type[] parameterTypes);
    public static MemberInfo GetProperty(Expression`1<Func`2<TSource, TResult>> property);
    public static MemberInfo GetProperty(Expression`1<Func`1<TResult>> property);
    internal static bool ParameterTypesMatch(ParameterInfo[] parameters, Type[] types);
    [ExtensionAttribute]
internal static Type GetPropertyOrFieldType(MemberInfo memberInfo);
    public static bool OverridesEquals(Type clazz);
    private static bool OverrideMethod(Type clazz, string methodName, Type[] parametersTypes);
    private static MethodInfo GetMethodFromInterface(Type type, string methodName, Type[] parametersTypes);
    public static bool OverridesGetHashCode(Type clazz);
    public static IGetter GetGetter(Type theClass, string propertyName, string propertyAccessorName);
    public static IType ReflectedPropertyType(Type theClass, string name, string access);
    public static Type ReflectedPropertyClass(Type theClass, string name, string access);
    public static Type ReflectedPropertyClass(string className, string name, string accessorName);
    public static Type ClassForName(string name);
    public static Type ClassForFullName(string classFullName);
    public static Type ClassForFullNameOrNull(string classFullName);
    public static Type TypeFromAssembly(string type, string assembly, bool throwIfError);
    public static Type TypeFromAssembly(AssemblyQualifiedTypeName name, bool throwOnError);
    public static bool TryLoadAssembly(string assemblyName);
    public static object GetConstantValue(Type type, string fieldName);
    public static ConstructorInfo GetDefaultConstructor(Type type);
    public static ConstructorInfo GetConstructor(Type type, IType[] types);
    private static string FormatConstructorNotFoundMessage(IEnumerable`1<IType> types);
    public static bool IsAbstractClass(Type type);
    public static bool IsFinalClass(Type type);
    public static Exception UnwrapTargetInvocationException(TargetInvocationException ex);
    internal static void PreserveStackTrace(Exception ex);
    public static MethodInfo TryGetMethod(Type type, MethodInfo method);
    private static Type[] GetMethodSignature(MethodInfo method);
    private static MethodInfo SafeGetMethod(Type type, MethodInfo method, Type[] tps);
    internal static object GetConstantValue(string qualifiedName, ISessionFactoryImplementor sfi);
    [ObsoleteAttribute("Please use GetMethodDefinition then MethodInfo.MakeGenericMethod instead")]
public static MethodInfo GetGenericMethodFrom(string methodName, Type[] genericArgs, Type[] signature);
    [ExtensionAttribute]
public static IDictionary`2<string, string> ToTypeParameters(object source);
    public static bool IsPropertyGet(MethodInfo method);
    public static bool IsPropertySet(MethodInfo method);
    public static string GetPropertyName(MethodInfo method);
    [ExtensionAttribute]
public static Type GetCollectionElementType(IEnumerable collectionInstance);
    public static Type GetCollectionElementType(Type collectionType);
    [ExtensionAttribute]
public static bool HasProperty(Type source, string propertyName);
    [ExtensionAttribute]
public static bool IsMethodOf(MethodInfo source, Type realDeclaringType);
}
internal static class NHibernate.Util.ReflectionCache : object {
}
[ObsoleteAttribute("This class has no more usages and will be removed in a future version")]
public class NHibernate.Util.SafetyEnumerable`1 : object {
    private IEnumerable _collection;
    public SafetyEnumerable`1(IEnumerable collection);
    [IteratorStateMachineAttribute("NHibernate.Util.SafetyEnumerable`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.CollectionProxy`1")]
public class NHibernate.Util.SequencedHashMap : object {
    private Entry _sentinel;
    private Hashtable _entries;
    private long _modCount;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private bool IsEmpty { get; }
    private Entry First { get; }
    public object FirstKey { get; }
    public object FirstValue { get; }
    private Entry Last { get; }
    public object LastKey { get; }
    public object LastValue { get; }
    public SequencedHashMap(int capacity);
    public SequencedHashMap(int capacity, float loadFactor);
    public SequencedHashMap(int capacity, IEqualityComparer equalityComparer);
    public SequencedHashMap(IEqualityComparer equalityComparer);
    public SequencedHashMap(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    private static Entry CreateSentinel();
    private void RemoveEntry(Entry entry);
    private void InsertEntry(Entry entry);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual object get_Item(object o);
    public virtual void set_Item(object o, object value);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual bool Contains(object key);
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual void Remove(object key);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private bool get_IsEmpty();
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    private Entry get_First();
    public virtual object get_FirstKey();
    public virtual object get_FirstValue();
    private Entry get_Last();
    public virtual object get_LastKey();
    public virtual object get_LastValue();
    public sealed virtual void OnDeserialization(object sender);
    private void RemoveImpl(object key);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class NHibernate.Util.SerializationHelper : object {
    public static Byte[] Serialize(object obj);
    public static object Deserialize(Byte[] data);
    [ExtensionAttribute]
internal static void AddValueArray(SerializationInfo info, string name, T[] values);
    [ExtensionAttribute]
internal static T[] GetValueArray(SerializationInfo info, string name);
    [ExtensionAttribute]
internal static T GetValue(SerializationInfo info, string name);
    private static BinaryFormatter CreateFormatter();
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Util.SimpleMRUCache : object {
    private static int DefaultStrongRefCount;
    private object _syncRoot;
    private int strongReferenceCount;
    private LRUMap cache;
    public object Item { get; }
    public int Count { get; }
    public SimpleMRUCache(int strongReferenceCount);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public object get_Item(object key);
    public void Put(object key, object value);
    public int get_Count();
    public void Clear();
}
[ObsoleteAttribute("This class has no more usages and will be removed in a future version")]
public class NHibernate.Util.SingletonEnumerable`1 : object {
    private T value;
    public SingletonEnumerable`1(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Util.SoftLimitMRUCache : object {
    private static int DefaultStrongRefCount;
    private object _syncRoot;
    private int strongReferenceCount;
    private IDictionary softReferenceCache;
    private LRUMap strongReferenceCache;
    public object Item { get; }
    public int Count { get; }
    public int SoftCount { get; }
    public SoftLimitMRUCache(int strongReferenceCount);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public object get_Item(object key);
    public void Put(object key, object value);
    public int get_Count();
    public int get_SoftCount();
    public void Clear();
}
[ExtensionAttribute]
public static class NHibernate.Util.StringHelper : object {
    internal static String[] LineSeparators;
    public static string WhiteSpace;
    public static char Dot;
    public static char Underscore;
    public static string CommaSpace;
    public static string Comma;
    public static string OpenParen;
    public static string ClosedParen;
    public static char SingleQuote;
    public static string SqlParameter;
    public static int AliasTruncateLength;
    private static StringHelper();
    [ObsoleteAttribute("Please use string.Join instead")]
public static string Join(string separator, IEnumerable objects);
    public static string Repeat(string str, int times);
    [ObsoleteAttribute("Please use string.Replace or Regex.Replace instead.")]
public static string Replace(string template, string placeholder, string replacement);
    [ObsoleteAttribute("Please use string.Replace or Regex.Replace instead.")]
public static string Replace(string template, string placeholder, string replacement, bool wholeWords);
    private static string ReplaceByPredicate(string template, string placeholder, string replacement, bool useWholeWord, Predicate`1<string> isWholeWord);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use string.Replace or Regex.Replace instead.")]
public static string ReplaceWholeWord(string template, string placeholder, string replacement);
    public static string ReplaceOnce(string template, string placeholder, string replacement);
    public static String[] Split(string separators, string list);
    public static String[] Split(string separators, string list, bool include);
    public static string Unqualify(string qualifiedName);
    public static string Unqualify(string qualifiedName, string seperator);
    internal static string Unqualify(string qualifiedName, char seperator);
    public static string GetFullClassname(string typeName);
    public static string GetClassname(string typeName);
    public static string Qualifier(string qualifiedName);
    public static String[] Suffix(String[] columns, string suffix);
    public static string Suffix(string name, string suffix);
    public static String[] Prefix(String[] columns, string prefix);
    public static string Root(string qualifiedName);
    internal static bool IsNotRoot(string qualifiedName, String& root);
    internal static bool IsNotRoot(string qualifiedName, String& root, String& unrootPath);
    internal static bool ParsePathAndPropertyName(string fullPath, String& pathToProperty, String& propertyName);
    public static bool BooleanValue(string value);
    private static string NullSafeToString(object obj);
    public static string ToString(Object[] array);
    [ExtensionAttribute]
public static string LinesToString(String[] text);
    public static String[] Multiply(string str, IEnumerable`1<object> placeholders, IEnumerable`1<object> replacements);
    public static String[] Multiply(String[] strings, string placeholder, String[] replacements);
    public static int CountUnquoted(string str, char character);
    public static bool IsEmpty(string str);
    public static bool IsNotEmpty(string str);
    public static string Qualify(string prefix, string name);
    public static String[] Qualify(string prefix, String[] names);
    public static int FirstIndexOfChar(string sqlString, string str, int startIndex);
    internal static int FirstIndexOfChar(string sqlString, Char[] chars, int startIndex);
    public static string Truncate(string str, int length);
    public static int LastIndexOfLetter(string str);
    public static string UnqualifyEntityName(string entityName);
    public static string GenerateAlias(string description);
    public static string GenerateAlias(string description, int unique);
    private static string GenerateAliasRoot(string description);
    public static string MoveAndToBeginning(string filter);
    public static string Unroot(string qualifiedName);
    [ObsoleteAttribute("This method has no more usage and will be removed in a future version")]
public static bool EqualsCaseInsensitive(string a, string b);
    [ObsoleteAttribute("This method has no more usage and will be removed in a future version")]
public static int IndexOfCaseInsensitive(string source, string value);
    [ObsoleteAttribute("This method has no more usage and will be removed in a future version")]
public static int IndexOfCaseInsensitive(string source, string value, int startIndex);
    [ObsoleteAttribute("This method has no more usage and will be removed in a future version")]
public static int IndexOfCaseInsensitive(string source, string value, int startIndex, int count);
    [ObsoleteAttribute("This method has no more usage and will be removed in a future version")]
public static int LastIndexOfCaseInsensitive(string source, string value);
    [ObsoleteAttribute("This method has no more usage and will be removed in a future version")]
public static bool StartsWithCaseInsensitive(string source, string prefix);
    internal static bool ContainsCaseInsensitive(string source, string value);
    [ExtensionAttribute]
internal static bool StartsWith(string source, char value);
    [ExtensionAttribute]
internal static bool EndsWith(string source, char value);
    public static string InternedIfPossible(string str);
    public static string CollectionToString(IEnumerable keys);
    public static string ToUpperCase(string str);
    public static string ToLowerCase(string str);
    public static bool IsBackticksEnclosed(string identifier);
    public static string PurgeBackticksEnclosing(string identifier);
    public static String[] ParseFilterParameterName(string filterParameterName);
    [ExtensionAttribute]
public static int IndexOfAnyNewLine(string str, int startIndex, Int32& newLineLength);
    [ExtensionAttribute]
public static bool IsAnyNewLine(string str, int index, Int32& newLineLength);
}
public class NHibernate.Util.StringTokenizer : object {
    private static string _defaultDelim;
    private string _origin;
    private string _delim;
    private bool _returnDelim;
    public StringTokenizer(string str);
    public StringTokenizer(string str, string delim);
    public StringTokenizer(string str, string delim, bool returnDelims);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class NHibernate.Util.TypeExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This method has no more usages and will be removed in a future version.")]
public static bool IsEnumerableOfT(Type type);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool IsNullableOrReference(Type type);
    [ExtensionAttribute]
public static Type NullableOf(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsNonPrimitive(Type type);
    [ExtensionAttribute]
internal static bool IsCollectionType(Type type);
    [ExtensionAttribute]
internal static Type UnwrapIfNullable(Type type);
    [ExtensionAttribute]
internal static bool IsIntegralNumberType(Type type);
    [ExtensionAttribute]
internal static bool IsRealNumberType(Type type);
}
public class NHibernate.Util.TypeNameParser : object {
    private string defaultNamespace;
    private string defaultAssembly;
    private static Regex WhiteSpaces;
    private static Regex MultipleSpaces;
    public TypeNameParser(string defaultNamespace, string defaultAssembly);
    private static TypeNameParser();
    public static AssemblyQualifiedTypeName Parse(string type);
    public static AssemblyQualifiedTypeName Parse(string type, string defaultNamespace, string defaultAssembly);
    public AssemblyQualifiedTypeName ParseTypeName(string typeName);
    public AssemblyQualifiedTypeName MakeGenericType(AssemblyQualifiedTypeName qualifiedName, bool isArrayType, AssemblyQualifiedTypeName[] typeArguments);
    [IteratorStateMachineAttribute("NHibernate.Util.TypeNameParser/<GenericTypesArguments>d__9")]
private static IEnumerable`1<string> GenericTypesArguments(string s, int cardinality);
    private AssemblyQualifiedTypeName ParseNonGenericType(string typeName);
    private static int FindAssemblyQualifiedNameStartIndex(string typeName);
    private static bool NeedDefaultNamespaceOrDefaultAssembly(string typeFullName);
    private static bool NeedDefaultNamespace(string typeFullName);
    private static bool NeedDefaultAssembly(string typeFullName);
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("Please use System.Collections.ObjectModel.ReadOnlyDictionary<K,V> instead.")]
public class NHibernate.Util.UnmodifiableDictionary`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public UnmodifiableDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public sealed virtual IEnumerator GetEnumerator();
}
public class NHibernate.Util.WeakEnumerator : object {
    private IDictionaryEnumerator innerEnumerator;
    private object currentKey;
    private object currentValue;
    public object Key { get; }
    public object Value { get; }
    public DictionaryEntry Entry { get; }
    public object Current { get; }
    public WeakEnumerator(IDictionaryEnumerator innerEnumerator);
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
[DefaultMemberAttribute("Item")]
public class NHibernate.Util.WeakHashtable : object {
    private Hashtable innerHashtable;
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public void Scavenge();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerTypeProxyAttribute("NHibernate.DebugHelpers.DictionaryProxy")]
public class NHibernate.Util.WeakRefWrapper : object {
    private WeakReference reference;
    private Nullable`1<int> _hashCode;
    public object Target { get; }
    public bool IsAlive { get; }
    public WeakRefWrapper(object target);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void OnDeserialization(object sender);
    private int GenerateHashCode();
    public object get_Target();
    public bool get_IsAlive();
    public static WeakRefWrapper Wrap(object value);
    public static object Unwrap(object value);
}
public class NHibernate.WrongClassException : HibernateException {
    private object identifier;
    private string entityName;
    public object Identifier { get; }
    public string EntityName { get; }
    public string Message { get; }
    public WrongClassException(string message, object identifier, string entityName);
    protected WrongClassException(SerializationInfo info, StreamingContext context);
    public object get_Identifier();
    public string get_EntityName();
    public virtual string get_Message();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    public string AssemblyName { get; }
    public IgnoresAccessChecksToAttribute(string assemblyName);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
