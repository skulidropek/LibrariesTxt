public class Ninject.Activation.Blocks.ActivationBlock : DisposableObject {
    [CompilerGeneratedAttribute]
private IResolutionRoot <Parent>k__BackingField;
    public IResolutionRoot Parent { get; private set; }
    public ActivationBlock(IResolutionRoot parent);
    [CompilerGeneratedAttribute]
public IResolutionRoot get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(IResolutionRoot value);
    public sealed virtual void Inject(object instance, IParameter[] parameters);
    public sealed virtual bool CanResolve(IRequest request);
    public sealed virtual bool CanResolve(IRequest request, bool ignoreImplicitBindings);
    public sealed virtual IEnumerable`1<object> Resolve(IRequest request);
    public virtual IRequest CreateRequest(Type service, Func`2<IBindingMetadata, bool> constraint, IEnumerable`1<IParameter> parameters, bool isOptional, bool isUnique);
    public sealed virtual bool Release(object instance);
    private sealed virtual override Type Ninject.Syntax.IFluentSyntax.GetType();
    [CompilerGeneratedAttribute]
private object <CreateRequest>b__9_0();
}
public interface Ninject.Activation.Blocks.IActivationBlock {
}
public class Ninject.Activation.Caching.ActivationCache : NinjectComponent {
    private HashSet`1<object> activatedObjects;
    private HashSet`1<object> deactivatedObjects;
    public int ActivatedObjectCount { get; }
    public int DeactivatedObjectCount { get; }
    public ActivationCache(ICachePruner cachePruner);
    public int get_ActivatedObjectCount();
    public int get_DeactivatedObjectCount();
    public sealed virtual void Clear();
    public sealed virtual void AddActivatedInstance(object instance);
    public sealed virtual void AddDeactivatedInstance(object instance);
    public sealed virtual bool IsActivated(object instance);
    public sealed virtual bool IsDeactivated(object instance);
    public sealed virtual void Prune();
    private static void RemoveDeadObjects(HashSet`1<object> objects);
}
public class Ninject.Activation.Caching.Cache : NinjectComponent {
    private IDictionary`2<object, Multimap`2<IBindingConfiguration, CacheEntry>> entries;
    [CompilerGeneratedAttribute]
private IPipeline <Pipeline>k__BackingField;
    public IPipeline Pipeline { get; private set; }
    public int Count { get; }
    public Cache(IPipeline pipeline, ICachePruner cachePruner);
    [CompilerGeneratedAttribute]
public IPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
private void set_Pipeline(IPipeline value);
    public sealed virtual int get_Count();
    public virtual void Dispose(bool disposing);
    public sealed virtual void Remember(IContext context, InstanceReference reference);
    public sealed virtual object TryGet(IContext context);
    public sealed virtual bool Release(object instance);
    public sealed virtual void Prune();
    public sealed virtual void Clear(object scope);
    public sealed virtual void Clear();
    private static IEnumerable`1<CacheEntry> GetAllBindingEntries(Multimap`2<IBindingConfiguration, CacheEntry> bindings);
    private IEnumerable`1<CacheEntry> GetAllCacheEntries();
    private void Forget(IEnumerable`1<CacheEntry> cacheEntries);
    private void Forget(CacheEntry entry);
}
public class Ninject.Activation.Caching.GarbageCollectionCachePruner : NinjectComponent {
    private WeakReference indicator;
    private List`1<IPruneable> caches;
    private Timer timer;
    private bool stop;
    public virtual void Dispose(bool disposing);
    public sealed virtual void Start(IPruneable pruneable);
    public sealed virtual void Stop();
    private void PruneCacheIfGarbageCollectorHasRun(object state);
    private int GetTimeoutInMilliseconds();
}
public interface Ninject.Activation.Caching.IActivationCache {
    public abstract virtual void Clear();
    public abstract virtual void AddActivatedInstance(object instance);
    public abstract virtual void AddDeactivatedInstance(object instance);
    public abstract virtual bool IsActivated(object instance);
    public abstract virtual bool IsDeactivated(object instance);
}
public interface Ninject.Activation.Caching.ICache {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual void Remember(IContext context, InstanceReference reference);
    public abstract virtual object TryGet(IContext context);
    public abstract virtual bool Release(object instance);
    public abstract virtual void Clear(object scope);
    public abstract virtual void Clear();
}
public interface Ninject.Activation.Caching.ICachePruner {
    public abstract virtual void Start(IPruneable cache);
    public abstract virtual void Stop();
}
public interface Ninject.Activation.Caching.IPruneable {
    public abstract virtual void Prune();
}
public class Ninject.Activation.Caching.WeakReferenceEqualityComparer : object {
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
public class Ninject.Activation.Context : object {
    private object cachedScope;
    [CompilerGeneratedAttribute]
private IKernel <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private IBinding <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlan <Plan>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <GenericArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInferredGenericArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ICache <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlanner <Planner>k__BackingField;
    [CompilerGeneratedAttribute]
private IPipeline <Pipeline>k__BackingField;
    public IKernel Kernel { get; public set; }
    public IRequest Request { get; public set; }
    public IBinding Binding { get; public set; }
    public IPlan Plan { get; public set; }
    public ICollection`1<IParameter> Parameters { get; public set; }
    public Type[] GenericArguments { get; private set; }
    public bool HasInferredGenericArguments { get; private set; }
    public ICache Cache { get; private set; }
    public IPlanner Planner { get; private set; }
    public IPipeline Pipeline { get; private set; }
    public Context(IKernel kernel, IRequest request, IBinding binding, ICache cache, IPlanner planner, IPipeline pipeline);
    [CompilerGeneratedAttribute]
public sealed virtual IKernel get_Kernel();
    [CompilerGeneratedAttribute]
public void set_Kernel(IKernel value);
    [CompilerGeneratedAttribute]
public sealed virtual IRequest get_Request();
    [CompilerGeneratedAttribute]
public void set_Request(IRequest value);
    [CompilerGeneratedAttribute]
public sealed virtual IBinding get_Binding();
    [CompilerGeneratedAttribute]
public void set_Binding(IBinding value);
    [CompilerGeneratedAttribute]
public sealed virtual IPlan get_Plan();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Plan(IPlan value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(ICollection`1<IParameter> value);
    [CompilerGeneratedAttribute]
public sealed virtual Type[] get_GenericArguments();
    [CompilerGeneratedAttribute]
private void set_GenericArguments(Type[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasInferredGenericArguments();
    [CompilerGeneratedAttribute]
private void set_HasInferredGenericArguments(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ICache get_Cache();
    [CompilerGeneratedAttribute]
private void set_Cache(ICache value);
    [CompilerGeneratedAttribute]
public IPlanner get_Planner();
    [CompilerGeneratedAttribute]
private void set_Planner(IPlanner value);
    [CompilerGeneratedAttribute]
public IPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
private void set_Pipeline(IPipeline value);
    public sealed virtual object GetScope();
    public sealed virtual IProvider GetProvider();
    public sealed virtual object Resolve();
    private object ResolveInternal(object scope);
    private bool IsCyclical(IContext targetContext);
}
public interface Ninject.Activation.IContext {
    public IKernel Kernel { get; }
    public IRequest Request { get; }
    public IBinding Binding { get; }
    public IPlan Plan { get; public set; }
    public ICache Cache { get; }
    public ICollection`1<IParameter> Parameters { get; }
    public Type[] GenericArguments { get; }
    public bool HasInferredGenericArguments { get; }
    public abstract virtual IKernel get_Kernel();
    public abstract virtual IRequest get_Request();
    public abstract virtual IBinding get_Binding();
    public abstract virtual IPlan get_Plan();
    public abstract virtual void set_Plan(IPlan value);
    public abstract virtual ICache get_Cache();
    public abstract virtual ICollection`1<IParameter> get_Parameters();
    public abstract virtual Type[] get_GenericArguments();
    public abstract virtual bool get_HasInferredGenericArguments();
    public abstract virtual IProvider GetProvider();
    public abstract virtual object GetScope();
    public abstract virtual object Resolve();
}
public class Ninject.Activation.InstanceReference : object {
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    public object Instance { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [SecuritySafeCriticalAttribute]
public bool Is();
    public T As();
    public void IfInstanceIs(Action`1<T> action);
}
public interface Ninject.Activation.IPipeline {
    public IList`1<IActivationStrategy> Strategies { get; }
    public abstract virtual IList`1<IActivationStrategy> get_Strategies();
    public abstract virtual void Activate(IContext context, InstanceReference reference);
    public abstract virtual void Deactivate(IContext context, InstanceReference reference);
}
public interface Ninject.Activation.IProvider {
    public Type Type { get; }
    public abstract virtual Type get_Type();
    public abstract virtual object Create(IContext context);
}
public interface Ninject.Activation.IProvider`1 {
}
public interface Ninject.Activation.IRequest {
    public Type Service { get; }
    public IRequest ParentRequest { get; }
    public IContext ParentContext { get; }
    public ITarget Target { get; }
    public Func`2<IBindingMetadata, bool> Constraint { get; }
    public ICollection`1<IParameter> Parameters { get; }
    public Stack`1<IBinding> ActiveBindings { get; }
    public int Depth { get; }
    public bool IsOptional { get; public set; }
    public bool IsUnique { get; public set; }
    public bool ForceUnique { get; public set; }
    public abstract virtual Type get_Service();
    public abstract virtual IRequest get_ParentRequest();
    public abstract virtual IContext get_ParentContext();
    public abstract virtual ITarget get_Target();
    public abstract virtual Func`2<IBindingMetadata, bool> get_Constraint();
    public abstract virtual ICollection`1<IParameter> get_Parameters();
    public abstract virtual Stack`1<IBinding> get_ActiveBindings();
    public abstract virtual int get_Depth();
    public abstract virtual bool get_IsOptional();
    public abstract virtual void set_IsOptional(bool value);
    public abstract virtual bool get_IsUnique();
    public abstract virtual void set_IsUnique(bool value);
    public abstract virtual bool get_ForceUnique();
    public abstract virtual void set_ForceUnique(bool value);
    public abstract virtual bool Matches(IBinding binding);
    public abstract virtual object GetScope();
    public abstract virtual IRequest CreateChild(Type service, IContext parentContext, ITarget target);
}
public class Ninject.Activation.Pipeline : NinjectComponent {
    private IActivationCache activationCache;
    [CompilerGeneratedAttribute]
private IList`1<IActivationStrategy> <Strategies>k__BackingField;
    public IList`1<IActivationStrategy> Strategies { get; private set; }
    public Pipeline(IEnumerable`1<IActivationStrategy> strategies, IActivationCache activationCache);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IActivationStrategy> get_Strategies();
    [CompilerGeneratedAttribute]
private void set_Strategies(IList`1<IActivationStrategy> value);
    public sealed virtual void Activate(IContext context, InstanceReference reference);
    public sealed virtual void Deactivate(IContext context, InstanceReference reference);
}
public abstract class Ninject.Activation.Provider`1 : object {
    public Type Type { get; }
    public virtual Type get_Type();
    public sealed virtual object Create(IContext context);
    protected abstract virtual T CreateInstance(IContext context);
}
public class Ninject.Activation.Providers.CallbackProvider`1 : Provider`1<T> {
    [CompilerGeneratedAttribute]
private Func`2<IContext, T> <Method>k__BackingField;
    public Func`2<IContext, T> Method { get; private set; }
    public CallbackProvider`1(Func`2<IContext, T> method);
    [CompilerGeneratedAttribute]
public Func`2<IContext, T> get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(Func`2<IContext, T> value);
    protected virtual T CreateInstance(IContext context);
}
public class Ninject.Activation.Providers.ConstantProvider`1 : Provider`1<T> {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; private set; }
    public ConstantProvider`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    protected virtual T CreateInstance(IContext context);
}
public class Ninject.Activation.Providers.StandardProvider : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlanner <Planner>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstructorScorer <ConstructorScorer>k__BackingField;
    public Type Type { get; private set; }
    public IPlanner Planner { get; private set; }
    public IConstructorScorer ConstructorScorer { get; private set; }
    public StandardProvider(Type type, IPlanner planner, IConstructorScorer constructorScorer);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public IPlanner get_Planner();
    [CompilerGeneratedAttribute]
private void set_Planner(IPlanner value);
    [CompilerGeneratedAttribute]
public IConstructorScorer get_ConstructorScorer();
    [CompilerGeneratedAttribute]
private void set_ConstructorScorer(IConstructorScorer value);
    public static Func`2<IContext, IProvider> GetCreationCallback(Type prototype);
    public static Func`2<IContext, IProvider> GetCreationCallback(Type prototype, ConstructorInfo constructor);
    public virtual object Create(IContext context);
    public object GetValue(IContext context, ITarget target);
    public Type GetImplementationType(Type service);
    private ConstructorInjectionDirective DetermineConstructorInjectionDirective(IContext context);
}
public class Ninject.Activation.Request : object {
    [CompilerGeneratedAttribute]
private Type <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequest <ParentRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private IContext <ParentContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ITarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IBindingMetadata, bool> <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<IBinding> <ActiveBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnique>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceUnique>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <ScopeCallback>k__BackingField;
    public Type Service { get; private set; }
    public IRequest ParentRequest { get; private set; }
    public IContext ParentContext { get; private set; }
    public ITarget Target { get; private set; }
    public Func`2<IBindingMetadata, bool> Constraint { get; private set; }
    public ICollection`1<IParameter> Parameters { get; private set; }
    public Stack`1<IBinding> ActiveBindings { get; private set; }
    public int Depth { get; private set; }
    public bool IsOptional { get; public set; }
    public bool IsUnique { get; public set; }
    public bool ForceUnique { get; public set; }
    public Func`1<object> ScopeCallback { get; private set; }
    public Request(Type service, Func`2<IBindingMetadata, bool> constraint, IEnumerable`1<IParameter> parameters, Func`1<object> scopeCallback, bool isOptional, bool isUnique);
    public Request(IContext parentContext, Type service, ITarget target, Func`1<object> scopeCallback);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Service();
    [CompilerGeneratedAttribute]
private void set_Service(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual IRequest get_ParentRequest();
    [CompilerGeneratedAttribute]
private void set_ParentRequest(IRequest value);
    [CompilerGeneratedAttribute]
public sealed virtual IContext get_ParentContext();
    [CompilerGeneratedAttribute]
private void set_ParentContext(IContext value);
    [CompilerGeneratedAttribute]
public sealed virtual ITarget get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(ITarget value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<IBindingMetadata, bool> get_Constraint();
    [CompilerGeneratedAttribute]
private void set_Constraint(Func`2<IBindingMetadata, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(ICollection`1<IParameter> value);
    [CompilerGeneratedAttribute]
public sealed virtual Stack`1<IBinding> get_ActiveBindings();
    [CompilerGeneratedAttribute]
private void set_ActiveBindings(Stack`1<IBinding> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Depth();
    [CompilerGeneratedAttribute]
private void set_Depth(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOptional();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsOptional(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUnique();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsUnique(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ForceUnique();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ForceUnique(bool value);
    [CompilerGeneratedAttribute]
public Func`1<object> get_ScopeCallback();
    [CompilerGeneratedAttribute]
private void set_ScopeCallback(Func`1<object> value);
    public sealed virtual bool Matches(IBinding binding);
    public sealed virtual object GetScope();
    public sealed virtual IRequest CreateChild(Type service, IContext parentContext, ITarget target);
    public virtual string ToString();
}
public class Ninject.Activation.Strategies.ActivationCacheStrategy : NinjectComponent {
    private IActivationCache activationCache;
    public ActivationCacheStrategy(IActivationCache activationCache);
    public sealed virtual void Activate(IContext context, InstanceReference reference);
    public sealed virtual void Deactivate(IContext context, InstanceReference reference);
}
public abstract class Ninject.Activation.Strategies.ActivationStrategy : NinjectComponent {
    public virtual void Activate(IContext context, InstanceReference reference);
    public virtual void Deactivate(IContext context, InstanceReference reference);
}
public class Ninject.Activation.Strategies.BindingActionStrategy : ActivationStrategy {
    public virtual void Activate(IContext context, InstanceReference reference);
    public virtual void Deactivate(IContext context, InstanceReference reference);
}
public class Ninject.Activation.Strategies.DisposableStrategy : ActivationStrategy {
    public virtual void Deactivate(IContext context, InstanceReference reference);
}
public interface Ninject.Activation.Strategies.IActivationStrategy {
    public abstract virtual void Activate(IContext context, InstanceReference reference);
    public abstract virtual void Deactivate(IContext context, InstanceReference reference);
}
public class Ninject.Activation.Strategies.InitializableStrategy : ActivationStrategy {
    public virtual void Activate(IContext context, InstanceReference reference);
}
public class Ninject.Activation.Strategies.MethodInjectionStrategy : ActivationStrategy {
    public virtual void Activate(IContext context, InstanceReference reference);
}
public class Ninject.Activation.Strategies.PropertyInjectionStrategy : ActivationStrategy {
    private static BindingFlags DefaultFlags;
    [CompilerGeneratedAttribute]
private IInjectorFactory <InjectorFactory>k__BackingField;
    public IInjectorFactory InjectorFactory { get; public set; }
    private BindingFlags Flags { get; }
    public PropertyInjectionStrategy(IInjectorFactory injectorFactory);
    [CompilerGeneratedAttribute]
public IInjectorFactory get_InjectorFactory();
    [CompilerGeneratedAttribute]
public void set_InjectorFactory(IInjectorFactory value);
    private BindingFlags get_Flags();
    public virtual void Activate(IContext context, InstanceReference reference);
    private void AssignPropertyOverrides(IContext context, InstanceReference reference, IList`1<IPropertyValue> propertyValues);
    private object GetValue(IContext context, ITarget target, IEnumerable`1<IPropertyValue> allPropertyValues);
}
public class Ninject.Activation.Strategies.StartableStrategy : ActivationStrategy {
    public virtual void Activate(IContext context, InstanceReference reference);
    public virtual void Deactivate(IContext context, InstanceReference reference);
}
public class Ninject.ActivationException : Exception {
    public ActivationException(string message);
    public ActivationException(string message, Exception innerException);
    protected ActivationException(SerializationInfo info, StreamingContext context);
}
public class Ninject.Components.ComponentContainer : DisposableObject {
    private Multimap`2<Type, Type> mappings;
    private Dictionary`2<Type, INinjectComponent> instances;
    private HashSet`1<KeyValuePair`2<Type, Type>> transients;
    [CompilerGeneratedAttribute]
private IKernel <Kernel>k__BackingField;
    public IKernel Kernel { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IKernel get_Kernel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Kernel(IKernel value);
    public virtual void Dispose(bool disposing);
    public sealed virtual void Add();
    public sealed virtual void AddTransient();
    public sealed virtual void RemoveAll();
    public sealed virtual void Remove();
    public sealed virtual void RemoveAll(Type component);
    public sealed virtual T Get();
    public sealed virtual IEnumerable`1<T> GetAll();
    public sealed virtual object Get(Type component);
    public sealed virtual IEnumerable`1<object> GetAll(Type component);
    private static ConstructorInfo SelectConstructor(Type component, Type implementation);
    private object ResolveInstance(Type component, Type implementation);
    private object CreateNewInstance(Type component, Type implementation);
    [CompilerGeneratedAttribute]
private object <CreateNewInstance>b__19_0(ParameterInfo parameter);
}
public interface Ninject.Components.IComponentContainer {
    public IKernel Kernel { get; public set; }
    public abstract virtual IKernel get_Kernel();
    public abstract virtual void set_Kernel(IKernel value);
    public abstract virtual void Add();
    public abstract virtual void RemoveAll();
    public abstract virtual void RemoveAll(Type component);
    public abstract virtual void Remove();
    public abstract virtual T Get();
    public abstract virtual IEnumerable`1<T> GetAll();
    public abstract virtual object Get(Type component);
    public abstract virtual IEnumerable`1<object> GetAll(Type component);
    public abstract virtual void AddTransient();
}
public interface Ninject.Components.INinjectComponent {
    public INinjectSettings Settings { get; public set; }
    public abstract virtual INinjectSettings get_Settings();
    public abstract virtual void set_Settings(INinjectSettings value);
}
public abstract class Ninject.Components.NinjectComponent : DisposableObject {
    [CompilerGeneratedAttribute]
private INinjectSettings <Settings>k__BackingField;
    public INinjectSettings Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual INinjectSettings get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(INinjectSettings value);
}
[AttributeUsageAttribute("2432")]
public abstract class Ninject.ConstraintAttribute : Attribute {
    public abstract virtual bool Matches(IBindingMetadata metadata);
}
public abstract class Ninject.GlobalKernelRegistration : object {
    private static ReaderWriterLockSlim KernelRegistrationsLock;
    private static IDictionary`2<Type, Registration> KernelRegistrations;
    private static GlobalKernelRegistration();
    internal static void RegisterKernelForType(IKernel kernel, Type type);
    internal static void UnregisterKernelForType(IKernel kernel, Type type);
    protected void MapKernels(Action`1<IKernel> action);
    private static void RemoveKernels(Registration registration, IEnumerable`1<WeakReference> references);
    private static Registration GetRegistrationForType(Type type);
    private static Registration CreateNewRegistration(Type type);
}
public abstract class Ninject.GlobalKernelRegistrationModule`1 : NinjectModule {
    public virtual void Load();
    public virtual void Unload();
}
public interface Ninject.IHaveNinjectComponents {
    public IComponentContainer Components { get; }
    public abstract virtual IComponentContainer get_Components();
}
public interface Ninject.IHaveNinjectSettings {
    public INinjectSettings Settings { get; }
    public abstract virtual INinjectSettings get_Settings();
}
public interface Ninject.IInitializable {
    public abstract virtual void Initialize();
}
public interface Ninject.IKernel {
    public INinjectSettings Settings { get; }
    public IComponentContainer Components { get; }
    public abstract virtual INinjectSettings get_Settings();
    public abstract virtual IComponentContainer get_Components();
    public abstract virtual IEnumerable`1<INinjectModule> GetModules();
    public abstract virtual bool HasModule(string name);
    public abstract virtual void Load(IEnumerable`1<INinjectModule> m);
    public abstract virtual void Load(IEnumerable`1<string> filePatterns);
    public abstract virtual void Load(IEnumerable`1<Assembly> assemblies);
    public abstract virtual void Unload(string name);
    public abstract virtual IEnumerable`1<IBinding> GetBindings(Type service);
    public abstract virtual IActivationBlock BeginBlock();
}
public abstract class Ninject.Infrastructure.Disposal.DisposableObject : object {
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    public virtual void Dispose(bool disposing);
}
public interface Ninject.Infrastructure.Disposal.IDisposableObject {
    public bool IsDisposed { get; }
    public abstract virtual bool get_IsDisposed();
}
public interface Ninject.Infrastructure.Disposal.INotifyWhenDisposed {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Disposed(EventHandler value);
}
internal static class Ninject.Infrastructure.Ensure : object {
    internal static void ArgumentNotNull(object argument, string name);
    internal static void ArgumentNotNullOrEmpty(string argument, string name);
}
public interface Ninject.Infrastructure.IHaveBindingConfiguration {
    public IBindingConfiguration BindingConfiguration { get; }
    public abstract virtual IBindingConfiguration get_BindingConfiguration();
}
public interface Ninject.Infrastructure.IHaveKernel {
    public IKernel Kernel { get; }
    public abstract virtual IKernel get_Kernel();
}
public static class Ninject.Infrastructure.Introspection.ExceptionFormatter : object {
    public static string ModulesWithNullOrEmptyNamesAreNotSupported();
    public static string TargetDoesNotHaveADefaultValue(ITarget target);
    public static string ModuleWithSameNameIsAlreadyLoaded(INinjectModule newModule, INinjectModule existingModule);
    public static string NoModuleLoadedWithTheSpecifiedName(string name);
    public static string CouldNotUniquelyResolveBinding(IRequest request, String[] formattedMatchingBindings);
    public static string CouldNotResolveBinding(IRequest request);
    public static string CyclicalDependenciesDetected(IContext context);
    public static string InvalidAttributeTypeUsedInBindingCondition(string serviceNames, string methodName, Type type);
    public static string NoConstructorsAvailable(IContext context);
    public static string NoConstructorsAvailableForComponent(Type component, Type implementation);
    public static string NoSuchComponentRegistered(Type component);
    public static string CouldNotResolvePropertyForValueInjection(IRequest request, string propertyName);
    public static string ProviderCallbackIsNull(IContext context);
    public static string ProviderReturnedNull(IContext context);
    public static string ConstructorsAmbiguous(IContext context, IGrouping`2<int, ConstructorInjectionDirective> bestDirectives);
    private static void FormatConstructor(ConstructorInfo constructor, StringWriter sw);
    private static void FormatAttribute(StringWriter sw, Attribute attribute);
}
[ExtensionAttribute]
public static class Ninject.Infrastructure.Introspection.FormatExtensions : object {
    [ExtensionAttribute]
public static string FormatActivationPath(IRequest request);
    [ExtensionAttribute]
public static string Format(IBinding binding, IContext context);
    [ExtensionAttribute]
public static string Format(IRequest request);
    [ExtensionAttribute]
public static string Format(ITarget target);
    [ExtensionAttribute]
public static string Format(Type type);
    private static string GetFriendlyName(Type type);
    private static string FormatGenericType(string friendlyName, Type[] genericArguments);
    private static void AppendGenericArguments(StringBuilder sb, Type[] genericArguments, int start, int count);
}
[ExtensionAttribute]
internal static class Ninject.Infrastructure.Language.ExtensionsForAssembly : object {
    [ExtensionAttribute]
public static bool HasNinjectModules(Assembly assembly);
    [ExtensionAttribute]
public static IEnumerable`1<INinjectModule> GetNinjectModules(Assembly assembly);
    private static bool IsLoadableModule(Type type);
}
[ExtensionAttribute]
internal static class Ninject.Infrastructure.Language.ExtensionsForICustomAttributeProvider : object {
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider member, Type type);
    [ExtensionAttribute]
public static Object[] GetCustomAttributesExtended(ICustomAttributeProvider member, Type attributeType, bool inherit);
}
[ExtensionAttribute]
internal static class Ninject.Infrastructure.Language.ExtensionsForIEnumerable : object {
    private static MethodInfo Cast;
    private static MethodInfo ToArray;
    private static MethodInfo ToList;
    private static ExtensionsForIEnumerable();
    [ExtensionAttribute]
public static IEnumerable CastSlow(IEnumerable series, Type elementType);
    [ExtensionAttribute]
public static Array ToArraySlow(IEnumerable series, Type elementType);
    [ExtensionAttribute]
public static IList ToListSlow(IEnumerable series, Type elementType);
}
[ExtensionAttribute]
public static class Ninject.Infrastructure.Language.ExtensionsForIEnumerableOfT : object {
    [ExtensionAttribute]
public static void Map(IEnumerable`1<T> series, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToEnumerable(IEnumerable`1<T> series);
    [ExtensionAttribute]
public static T SingleOrThrowException(IEnumerable`1<T> series, Func`1<ActivationException> exceptionCreator);
}
[ExtensionAttribute]
public static class Ninject.Infrastructure.Language.ExtensionsForMemberInfo : object {
    private static BindingFlags DefaultFlags;
    private static BindingFlags Flags;
    private static MethodInfo parentDefinitionMethodInfo;
    private static MethodInfo ParentDefinitionMethodInfo { get; }
    private static MethodInfo get_ParentDefinitionMethodInfo();
    [ExtensionAttribute]
public static bool HasAttribute(MemberInfo member);
    [ExtensionAttribute]
public static bool HasAttribute(MemberInfo member, Type type);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyFromDeclaredType(MemberInfo memberInfo, PropertyInfo propertyDefinition, BindingFlags flags);
    [ExtensionAttribute]
public static bool IsPrivate(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static Object[] GetCustomAttributesExtended(MemberInfo member, Type attributeType, bool inherited);
    private static PropertyInfo GetParentDefinition(PropertyInfo property);
    [ExtensionAttribute]
private static MethodInfo GetParentDefinition(MethodInfo method, BindingFlags flags);
    private static bool IsDefined(PropertyInfo element, Type attributeType, bool inherit);
    private static Object[] GetCustomAttributes(PropertyInfo propertyInfo, Type attributeType, bool inherit);
    private static void AddAttributes(List`1<object> attributes, Object[] customAttributes, Dictionary`2<Type, bool> attributeUsages);
    private static AttributeUsageAttribute InternalGetAttributeUsage(Type type);
}
[ExtensionAttribute]
internal static class Ninject.Infrastructure.Language.ExtensionsForTargetInvocationException : object {
    [ExtensionAttribute]
public static void RethrowInnerException(TargetInvocationException exception);
}
[ExtensionAttribute]
public static class Ninject.Infrastructure.Language.ExtensionsForType : object {
    [IteratorStateMachineAttribute("Ninject.Infrastructure.Language.ExtensionsForType/<GetAllBaseTypes>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetAllBaseTypes(Type type);
}
[DefaultMemberAttribute("Item")]
public class Ninject.Infrastructure.Multimap`2 : object {
    private Dictionary`2<TKey, ICollection`1<TValue>> items;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<ICollection`1<TValue>> Values { get; }
    public ICollection`1<TValue> Item { get; }
    public ICollection`1<TKey> get_Keys();
    public ICollection`1<ICollection`1<TValue>> get_Values();
    public ICollection`1<TValue> get_Item(TKey key);
    public void Add(TKey key, TValue value);
    public bool Remove(TKey key, TValue value);
    public bool RemoveAll(TKey key);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TKey key, TValue value);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, ICollection`1<TValue>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,System.Collections.Generic.ICollection<TValue>>>.GetEnumerator();
}
public class Ninject.Infrastructure.ReferenceEqualWeakReference : WeakReference {
    private int cachedHashCode;
    public ReferenceEqualWeakReference(object target);
    public ReferenceEqualWeakReference(object target, bool trackResurrection);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Ninject.Infrastructure.StandardScopeCallbacks : object {
    public static Func`2<IContext, object> Transient;
    public static Func`2<IContext, object> Singleton;
    public static Func`2<IContext, object> Thread;
    private static StandardScopeCallbacks();
}
public interface Ninject.INinjectSettings {
    public Type InjectAttribute { get; }
    public TimeSpan CachePruningInterval { get; }
    public Func`2<IContext, object> DefaultScopeCallback { get; }
    public bool LoadExtensions { get; }
    public String[] ExtensionSearchPatterns { get; }
    public bool UseReflectionBasedInjection { get; }
    public bool InjectNonPublic { get; public set; }
    public bool InjectParentPrivateProperties { get; public set; }
    public bool ActivationCacheDisabled { get; public set; }
    public bool AllowNullInjection { get; public set; }
    public bool ThrowOnGetServiceNotFound { get; public set; }
    public abstract virtual Type get_InjectAttribute();
    public abstract virtual TimeSpan get_CachePruningInterval();
    public abstract virtual Func`2<IContext, object> get_DefaultScopeCallback();
    public abstract virtual bool get_LoadExtensions();
    public abstract virtual String[] get_ExtensionSearchPatterns();
    public abstract virtual bool get_UseReflectionBasedInjection();
    public abstract virtual bool get_InjectNonPublic();
    public abstract virtual void set_InjectNonPublic(bool value);
    public abstract virtual bool get_InjectParentPrivateProperties();
    public abstract virtual void set_InjectParentPrivateProperties(bool value);
    public abstract virtual bool get_ActivationCacheDisabled();
    public abstract virtual void set_ActivationCacheDisabled(bool value);
    public abstract virtual bool get_AllowNullInjection();
    public abstract virtual void set_AllowNullInjection(bool value);
    public abstract virtual bool get_ThrowOnGetServiceNotFound();
    public abstract virtual void set_ThrowOnGetServiceNotFound(bool value);
    public abstract virtual T Get(string key, T defaultValue);
    public abstract virtual void Set(string key, object value);
}
[AttributeUsageAttribute("480")]
public class Ninject.InjectAttribute : Attribute {
}
public class Ninject.Injection.ConstructorInjector : MulticastDelegate {
    public ConstructorInjector(object object, IntPtr method);
    public virtual object Invoke(Object[] arguments);
    public virtual IAsyncResult BeginInvoke(Object[] arguments, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class Ninject.Injection.DynamicMethodInjectorFactory : NinjectComponent {
    private static MethodInfo UnboxPointer;
    private static DynamicMethodInjectorFactory();
    public sealed virtual ConstructorInjector Create(ConstructorInfo constructor);
    public sealed virtual PropertyInjector Create(PropertyInfo property);
    public sealed virtual MethodInjector Create(MethodInfo method);
    private static void EmitLoadMethodArguments(ILGenerator il, MethodBase targetMethod);
    private static void EmitMethodCall(ILGenerator il, MethodInfo method);
    private static void EmitUnboxOrCast(ILGenerator il, Type type);
    private static string GetAnonymousMethodName();
}
public interface Ninject.Injection.IInjectorFactory {
    public abstract virtual ConstructorInjector Create(ConstructorInfo constructor);
    public abstract virtual PropertyInjector Create(PropertyInfo property);
    public abstract virtual MethodInjector Create(MethodInfo method);
}
public class Ninject.Injection.MethodInjector : MulticastDelegate {
    public MethodInjector(object object, IntPtr method);
    public virtual void Invoke(object target, Object[] arguments);
    public virtual IAsyncResult BeginInvoke(object target, Object[] arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Ninject.Injection.PropertyInjector : MulticastDelegate {
    public PropertyInjector(object object, IntPtr method);
    public virtual void Invoke(object target, object value);
    public virtual IAsyncResult BeginInvoke(object target, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Ninject.Injection.ReflectionInjectorFactory : NinjectComponent {
    public sealed virtual ConstructorInjector Create(ConstructorInfo constructor);
    public sealed virtual PropertyInjector Create(PropertyInfo property);
    public sealed virtual MethodInjector Create(MethodInfo method);
}
public interface Ninject.IStartable {
    public abstract virtual void Start();
    public abstract virtual void Stop();
}
public abstract class Ninject.KernelBase : BindingRoot {
    private object handleMissingBindingLockObject;
    private Multimap`2<Type, IBinding> bindings;
    private Dictionary`2<Type, List`1<IBinding>> bindingCache;
    private Dictionary`2<string, INinjectModule> modules;
    private IBindingPrecedenceComparer bindingPrecedenceComparer;
    [CompilerGeneratedAttribute]
private INinjectSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentContainer <Components>k__BackingField;
    public INinjectSettings Settings { get; private set; }
    public IComponentContainer Components { get; private set; }
    protected KernelBase(INinjectModule[] modules);
    protected KernelBase(INinjectSettings settings, INinjectModule[] modules);
    protected KernelBase(IComponentContainer components, INinjectSettings settings, INinjectModule[] modules);
    [CompilerGeneratedAttribute]
public sealed virtual INinjectSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(INinjectSettings value);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentContainer get_Components();
    [CompilerGeneratedAttribute]
private void set_Components(IComponentContainer value);
    public virtual void Dispose(bool disposing);
    public virtual void Unbind(Type service);
    public virtual void AddBinding(IBinding binding);
    public virtual void RemoveBinding(IBinding binding);
    public sealed virtual bool HasModule(string name);
    public sealed virtual IEnumerable`1<INinjectModule> GetModules();
    public sealed virtual void Load(IEnumerable`1<INinjectModule> m);
    public sealed virtual void Load(IEnumerable`1<string> filePatterns);
    public sealed virtual void Load(IEnumerable`1<Assembly> assemblies);
    public sealed virtual void Unload(string name);
    public virtual void Inject(object instance, IParameter[] parameters);
    public virtual bool Release(object instance);
    public virtual bool CanResolve(IRequest request);
    public virtual bool CanResolve(IRequest request, bool ignoreImplicitBindings);
    public virtual IEnumerable`1<object> Resolve(IRequest request);
    public virtual IRequest CreateRequest(Type service, Func`2<IBindingMetadata, bool> constraint, IEnumerable`1<IParameter> parameters, bool isOptional, bool isUnique);
    public virtual IActivationBlock BeginBlock();
    public virtual IEnumerable`1<IBinding> GetBindings(Type service);
    private sealed virtual override object System.IServiceProvider.GetService(Type service);
    protected virtual Func`2<IBinding, bool> SatifiesRequest(IRequest request);
    protected abstract virtual void AddComponents();
    protected virtual bool HandleMissingBinding(IRequest request);
    protected virtual IContext CreateContext(IRequest request, IBinding binding);
    private IEnumerable`1<object> Resolve(IRequest request, bool handleMissingBindings, bool filterImplicitBindings);
    private void AddBindings(IEnumerable`1<IBinding> bindings);
    private sealed virtual override Type Ninject.Syntax.IFluentSyntax.GetType();
    [CompilerGeneratedAttribute]
private void <AddBindings>b__41_0(IBinding binding);
}
[ExtensionAttribute]
public static class Ninject.ModuleLoadExtensions : object {
    [ExtensionAttribute]
public static void Load(IKernel kernel);
    [ExtensionAttribute]
public static void Load(IKernel kernel, INinjectModule[] modules);
    [ExtensionAttribute]
public static void Load(IKernel kernel, String[] filePatterns);
    [ExtensionAttribute]
public static void Load(IKernel kernel, Assembly[] assemblies);
}
public class Ninject.Modules.AssemblyNameRetriever : NinjectComponent {
    public sealed virtual IEnumerable`1<AssemblyName> GetAssemblyNames(IEnumerable`1<string> filenames, Predicate`1<Assembly> filter);
    private static AppDomain CreateTemporaryAppDomain();
}
public class Ninject.Modules.CompiledModuleLoaderPlugin : NinjectComponent {
    private static String[] Extensions;
    private IAssemblyNameRetriever assemblyNameRetriever;
    [CompilerGeneratedAttribute]
private IKernel <Kernel>k__BackingField;
    public IKernel Kernel { get; private set; }
    public IEnumerable`1<string> SupportedExtensions { get; }
    public CompiledModuleLoaderPlugin(IKernel kernel, IAssemblyNameRetriever assemblyNameRetriever);
    private static CompiledModuleLoaderPlugin();
    [CompilerGeneratedAttribute]
public IKernel get_Kernel();
    [CompilerGeneratedAttribute]
private void set_Kernel(IKernel value);
    public sealed virtual IEnumerable`1<string> get_SupportedExtensions();
    public sealed virtual void LoadModules(IEnumerable`1<string> filenames);
}
public interface Ninject.Modules.IAssemblyNameRetriever {
    public abstract virtual IEnumerable`1<AssemblyName> GetAssemblyNames(IEnumerable`1<string> filenames, Predicate`1<Assembly> filter);
}
public interface Ninject.Modules.IModuleLoader {
    public abstract virtual void LoadModules(IEnumerable`1<string> patterns);
}
public interface Ninject.Modules.IModuleLoaderPlugin {
    public IEnumerable`1<string> SupportedExtensions { get; }
    public abstract virtual IEnumerable`1<string> get_SupportedExtensions();
    public abstract virtual void LoadModules(IEnumerable`1<string> filenames);
}
public interface Ninject.Modules.INinjectModule {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void OnLoad(IKernel kernel);
    public abstract virtual void OnUnload(IKernel kernel);
    public abstract virtual void OnVerifyRequiredModules();
}
public class Ninject.Modules.ModuleLoader : NinjectComponent {
    [CompilerGeneratedAttribute]
private IKernel <Kernel>k__BackingField;
    public IKernel Kernel { get; private set; }
    public ModuleLoader(IKernel kernel);
    [CompilerGeneratedAttribute]
public IKernel get_Kernel();
    [CompilerGeneratedAttribute]
private void set_Kernel(IKernel value);
    public sealed virtual void LoadModules(IEnumerable`1<string> patterns);
    private static IEnumerable`1<string> GetFilesMatchingPattern(string pattern);
    private static IEnumerable`1<string> NormalizePaths(string path);
    private static IEnumerable`1<string> GetBaseDirectories();
}
public abstract class Ninject.Modules.NinjectModule : BindingRoot {
    [CompilerGeneratedAttribute]
private IKernel <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IBinding> <Bindings>k__BackingField;
    public IKernel Kernel { get; private set; }
    public string Name { get; }
    public ICollection`1<IBinding> Bindings { get; private set; }
    protected IKernel KernelInstance { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IKernel get_Kernel();
    [CompilerGeneratedAttribute]
private void set_Kernel(IKernel value);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public ICollection`1<IBinding> get_Bindings();
    [CompilerGeneratedAttribute]
private void set_Bindings(ICollection`1<IBinding> value);
    protected virtual IKernel get_KernelInstance();
    public sealed virtual void OnLoad(IKernel kernel);
    public sealed virtual void OnUnload(IKernel kernel);
    public sealed virtual void OnVerifyRequiredModules();
    public abstract virtual void Load();
    public virtual void Unload();
    public virtual void VerifyRequiredModulesAreLoaded();
    public virtual void Unbind(Type service);
    public virtual void AddBinding(IBinding binding);
    public virtual void RemoveBinding(IBinding binding);
}
public class Ninject.NamedAttribute : ConstraintAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public NamedAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public virtual bool Matches(IBindingMetadata metadata);
}
public class Ninject.NinjectSettings : object {
    private Dictionary`2<string, object> values;
    public Type InjectAttribute { get; public set; }
    public TimeSpan CachePruningInterval { get; public set; }
    public Func`2<IContext, object> DefaultScopeCallback { get; public set; }
    public bool LoadExtensions { get; public set; }
    public String[] ExtensionSearchPatterns { get; public set; }
    public bool UseReflectionBasedInjection { get; public set; }
    public bool InjectNonPublic { get; public set; }
    public bool InjectParentPrivateProperties { get; public set; }
    public bool ActivationCacheDisabled { get; public set; }
    public bool AllowNullInjection { get; public set; }
    public bool ThrowOnGetServiceNotFound { get; public set; }
    public sealed virtual Type get_InjectAttribute();
    public void set_InjectAttribute(Type value);
    public sealed virtual TimeSpan get_CachePruningInterval();
    public void set_CachePruningInterval(TimeSpan value);
    public sealed virtual Func`2<IContext, object> get_DefaultScopeCallback();
    public void set_DefaultScopeCallback(Func`2<IContext, object> value);
    public sealed virtual bool get_LoadExtensions();
    public void set_LoadExtensions(bool value);
    public sealed virtual String[] get_ExtensionSearchPatterns();
    public void set_ExtensionSearchPatterns(String[] value);
    public sealed virtual bool get_UseReflectionBasedInjection();
    public void set_UseReflectionBasedInjection(bool value);
    public sealed virtual bool get_InjectNonPublic();
    public sealed virtual void set_InjectNonPublic(bool value);
    public sealed virtual bool get_InjectParentPrivateProperties();
    public sealed virtual void set_InjectParentPrivateProperties(bool value);
    public sealed virtual bool get_ActivationCacheDisabled();
    public sealed virtual void set_ActivationCacheDisabled(bool value);
    public sealed virtual bool get_AllowNullInjection();
    public sealed virtual void set_AllowNullInjection(bool value);
    public sealed virtual bool get_ThrowOnGetServiceNotFound();
    public sealed virtual void set_ThrowOnGetServiceNotFound(bool value);
    public sealed virtual T Get(string key, T defaultValue);
    public sealed virtual void Set(string key, object value);
}
[AttributeUsageAttribute("2272")]
public class Ninject.OptionalAttribute : Attribute {
}
public class Ninject.Parameters.ConstructorArgument : Parameter {
    public ConstructorArgument(string name, object value);
    public ConstructorArgument(string name, Func`2<IContext, object> valueCallback);
    public ConstructorArgument(string name, Func`3<IContext, ITarget, object> valueCallback);
    public ConstructorArgument(string name, object value, bool shouldInherit);
    public ConstructorArgument(string name, Func`2<IContext, object> valueCallback, bool shouldInherit);
    public ConstructorArgument(string name, Func`3<IContext, ITarget, object> valueCallback, bool shouldInherit);
    public sealed virtual bool AppliesToTarget(IContext context, ITarget target);
}
public interface Ninject.Parameters.IConstructorArgument {
    public abstract virtual bool AppliesToTarget(IContext context, ITarget target);
}
public interface Ninject.Parameters.IParameter {
    public string Name { get; }
    public bool ShouldInherit { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_ShouldInherit();
    public abstract virtual object GetValue(IContext context, ITarget target);
}
public interface Ninject.Parameters.IPropertyValue {
}
public class Ninject.Parameters.Parameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldInherit>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<IContext, ITarget, object> <ValueCallback>k__BackingField;
    public string Name { get; private set; }
    public bool ShouldInherit { get; private set; }
    public Func`3<IContext, ITarget, object> ValueCallback { get; internal set; }
    public Parameter(string name, object value, bool shouldInherit);
    public Parameter(string name, Func`2<IContext, object> valueCallback, bool shouldInherit);
    public Parameter(string name, Func`3<IContext, ITarget, object> valueCallback, bool shouldInherit);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldInherit();
    [CompilerGeneratedAttribute]
private void set_ShouldInherit(bool value);
    [CompilerGeneratedAttribute]
public Func`3<IContext, ITarget, object> get_ValueCallback();
    [CompilerGeneratedAttribute]
internal void set_ValueCallback(Func`3<IContext, ITarget, object> value);
    public sealed virtual object GetValue(IContext context, ITarget target);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(IParameter other);
}
public class Ninject.Parameters.PropertyValue : Parameter {
    public PropertyValue(string name, object value);
    public PropertyValue(string name, Func`2<IContext, object> valueCallback);
    public PropertyValue(string name, Func`3<IContext, ITarget, object> valueCallback);
}
public class Ninject.Parameters.TypeMatchingConstructorArgument : object {
    private Type type;
    [CompilerGeneratedAttribute]
private bool <ShouldInherit>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<IContext, ITarget, object> <ValueCallback>k__BackingField;
    public string Name { get; }
    public bool ShouldInherit { get; private set; }
    private Func`3<IContext, ITarget, object> ValueCallback { get; private set; }
    public TypeMatchingConstructorArgument(Type type, Func`3<IContext, ITarget, object> valueCallback);
    public TypeMatchingConstructorArgument(Type type, Func`3<IContext, ITarget, object> valueCallback, bool shouldInherit);
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldInherit();
    [CompilerGeneratedAttribute]
private void set_ShouldInherit(bool value);
    [CompilerGeneratedAttribute]
private Func`3<IContext, ITarget, object> get_ValueCallback();
    [CompilerGeneratedAttribute]
private void set_ValueCallback(Func`3<IContext, ITarget, object> value);
    public sealed virtual bool AppliesToTarget(IContext context, ITarget target);
    public sealed virtual object GetValue(IContext context, ITarget target);
    public sealed virtual bool Equals(IParameter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Ninject.Parameters.WeakConstructorArgument : Parameter {
    private WeakReference weakReference;
    public WeakConstructorArgument(string name, object value);
    public WeakConstructorArgument(string name, object value, bool shouldInherit);
    public sealed virtual bool AppliesToTarget(IContext context, ITarget target);
    [CompilerGeneratedAttribute]
private object <.ctor>b__2_0(IContext ctx, ITarget target);
}
public class Ninject.Parameters.WeakPropertyValue : Parameter {
    private WeakReference weakReference;
    public WeakPropertyValue(string name, object value);
    [CompilerGeneratedAttribute]
private object <.ctor>b__1_0(IContext ctx, ITarget target);
}
public class Ninject.Planning.Bindings.Binding : object {
    [CompilerGeneratedAttribute]
private IBindingConfiguration <BindingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Service>k__BackingField;
    public IBindingConfiguration BindingConfiguration { get; private set; }
    public Type Service { get; private set; }
    public IBindingMetadata Metadata { get; }
    public BindingTarget Target { get; public set; }
    public bool IsImplicit { get; public set; }
    public bool IsConditional { get; }
    public Func`2<IRequest, bool> Condition { get; public set; }
    public Func`2<IContext, IProvider> ProviderCallback { get; public set; }
    public Func`2<IContext, object> ScopeCallback { get; public set; }
    public ICollection`1<IParameter> Parameters { get; }
    public ICollection`1<Action`2<IContext, object>> ActivationActions { get; }
    public ICollection`1<Action`2<IContext, object>> DeactivationActions { get; }
    public Binding(Type service);
    public Binding(Type service, IBindingConfiguration configuration);
    [CompilerGeneratedAttribute]
public sealed virtual IBindingConfiguration get_BindingConfiguration();
    [CompilerGeneratedAttribute]
private void set_BindingConfiguration(IBindingConfiguration value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Service();
    [CompilerGeneratedAttribute]
private void set_Service(Type value);
    public sealed virtual IBindingMetadata get_Metadata();
    public sealed virtual BindingTarget get_Target();
    public sealed virtual void set_Target(BindingTarget value);
    public sealed virtual bool get_IsImplicit();
    public sealed virtual void set_IsImplicit(bool value);
    public sealed virtual bool get_IsConditional();
    public sealed virtual Func`2<IRequest, bool> get_Condition();
    public sealed virtual void set_Condition(Func`2<IRequest, bool> value);
    public sealed virtual Func`2<IContext, IProvider> get_ProviderCallback();
    public sealed virtual void set_ProviderCallback(Func`2<IContext, IProvider> value);
    public sealed virtual Func`2<IContext, object> get_ScopeCallback();
    public sealed virtual void set_ScopeCallback(Func`2<IContext, object> value);
    public sealed virtual ICollection`1<IParameter> get_Parameters();
    public sealed virtual ICollection`1<Action`2<IContext, object>> get_ActivationActions();
    public sealed virtual ICollection`1<Action`2<IContext, object>> get_DeactivationActions();
    public sealed virtual IProvider GetProvider(IContext context);
    public sealed virtual object GetScope(IContext context);
    public sealed virtual bool Matches(IRequest request);
}
public class Ninject.Planning.Bindings.BindingBuilder : object {
    [CompilerGeneratedAttribute]
private IBindingConfiguration <BindingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IKernel <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceNames>k__BackingField;
    public IBindingConfiguration BindingConfiguration { get; private set; }
    public IKernel Kernel { get; private set; }
    protected string ServiceNames { get; private set; }
    public BindingBuilder(IBindingConfiguration bindingConfiguration, IKernel kernel, string serviceNames);
    [CompilerGeneratedAttribute]
public sealed virtual IBindingConfiguration get_BindingConfiguration();
    [CompilerGeneratedAttribute]
private void set_BindingConfiguration(IBindingConfiguration value);
    [CompilerGeneratedAttribute]
public sealed virtual IKernel get_Kernel();
    [CompilerGeneratedAttribute]
private void set_Kernel(IKernel value);
    [CompilerGeneratedAttribute]
protected string get_ServiceNames();
    [CompilerGeneratedAttribute]
private void set_ServiceNames(string value);
    protected IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> InternalTo();
    protected IBindingWhenInNamedWithOrOnSyntax`1<T> InternalTo(Type implementation);
    protected IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> InternalToConfiguration(TImplementation value);
    protected IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> InternalToMethod(Func`2<IContext, TImplementation> method);
    protected IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> InternalToProvider(IProvider`1<TImplementation> provider);
    protected IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProviderInternal();
    protected IBindingWhenInNamedWithOrOnSyntax`1<T> ToProviderInternal(Type providerType);
    protected IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> InternalToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
    private void AddConstructorArguments(NewExpression ctorExpression, ParameterExpression constructorArgumentSyntaxParameterExpression);
    private void AddConstructorArgument(Expression argument, string argumentName, ParameterExpression constructorArgumentSyntaxParameterExpression);
}
public class Ninject.Planning.Bindings.BindingBuilder`1 : BindingBuilder {
    [CompilerGeneratedAttribute]
private IBinding <Binding>k__BackingField;
    public IBinding Binding { get; private set; }
    public BindingBuilder`1(IBinding binding, IKernel kernel, string serviceNames);
    [CompilerGeneratedAttribute]
public IBinding get_Binding();
    [CompilerGeneratedAttribute]
private void set_Binding(IBinding value);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> ToSelf();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> To();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> To(Type implementation);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> ToProvider();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> ToProvider(Type providerType);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider(IProvider`1<TImplementation> provider);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> ToMethod(Func`2<IContext, T1> method);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToMethod(Func`2<IContext, TImplementation> method);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstant(TImplementation value);
    private sealed virtual override Type Ninject.Syntax.IFluentSyntax.GetType();
}
public class Ninject.Planning.Bindings.BindingBuilder`2 : BindingBuilder {
    public BindingBuilder`2(IBindingConfiguration bindingConfigurationConfiguration, IKernel kernel, string serviceNames);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> To();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> To(Type implementation);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider(Type providerType);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider(IProvider`1<TImplementation> provider);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToMethod(Func`2<IContext, TImplementation> method);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstant(TImplementation value);
    private sealed virtual override Type Ninject.Syntax.IFluentSyntax.GetType();
}
public class Ninject.Planning.Bindings.BindingBuilder`3 : BindingBuilder {
    public BindingBuilder`3(IBindingConfiguration bindingConfigurationConfiguration, IKernel kernel, string serviceNames);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> To();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> To(Type implementation);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider(Type providerType);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider(IProvider`1<TImplementation> provider);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToMethod(Func`2<IContext, TImplementation> method);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstant(TImplementation value);
    private sealed virtual override Type Ninject.Syntax.IFluentSyntax.GetType();
}
public class Ninject.Planning.Bindings.BindingBuilder`4 : BindingBuilder {
    public BindingBuilder`4(IBindingConfiguration bindingConfigurationConfiguration, IKernel kernel, string serviceNames);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> To();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> To(Type implementation);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider();
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider(Type providerType);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider(IProvider`1<TImplementation> provider);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToMethod(Func`2<IContext, TImplementation> method);
    public sealed virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstant(TImplementation value);
    private sealed virtual override Type Ninject.Syntax.IFluentSyntax.GetType();
}
public class Ninject.Planning.Bindings.BindingConfiguration : object {
    [CompilerGeneratedAttribute]
private IBindingMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IRequest, bool> <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IContext, IProvider> <ProviderCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IContext, object> <ScopeCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Action`2<IContext, object>> <ActivationActions>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Action`2<IContext, object>> <DeactivationActions>k__BackingField;
    public IBindingMetadata Metadata { get; private set; }
    public bool IsImplicit { get; public set; }
    public bool IsConditional { get; }
    public BindingTarget Target { get; public set; }
    public Func`2<IRequest, bool> Condition { get; public set; }
    public Func`2<IContext, IProvider> ProviderCallback { get; public set; }
    public Func`2<IContext, object> ScopeCallback { get; public set; }
    public ICollection`1<IParameter> Parameters { get; private set; }
    public ICollection`1<Action`2<IContext, object>> ActivationActions { get; private set; }
    public ICollection`1<Action`2<IContext, object>> DeactivationActions { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual IBindingMetadata get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(IBindingMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsImplicit(bool value);
    public sealed virtual bool get_IsConditional();
    [CompilerGeneratedAttribute]
public sealed virtual BindingTarget get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Target(BindingTarget value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<IRequest, bool> get_Condition();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Condition(Func`2<IRequest, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<IContext, IProvider> get_ProviderCallback();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProviderCallback(Func`2<IContext, IProvider> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<IContext, object> get_ScopeCallback();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ScopeCallback(Func`2<IContext, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(ICollection`1<IParameter> value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Action`2<IContext, object>> get_ActivationActions();
    [CompilerGeneratedAttribute]
private void set_ActivationActions(ICollection`1<Action`2<IContext, object>> value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Action`2<IContext, object>> get_DeactivationActions();
    [CompilerGeneratedAttribute]
private void set_DeactivationActions(ICollection`1<Action`2<IContext, object>> value);
    public sealed virtual IProvider GetProvider(IContext context);
    public sealed virtual object GetScope(IContext context);
    public sealed virtual bool Matches(IRequest request);
}
public class Ninject.Planning.Bindings.BindingConfigurationBuilder`1 : object {
    private string serviceNames;
    [CompilerGeneratedAttribute]
private IBindingConfiguration <BindingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IKernel <Kernel>k__BackingField;
    public IBindingConfiguration BindingConfiguration { get; private set; }
    public IKernel Kernel { get; private set; }
    public BindingConfigurationBuilder`1(IBindingConfiguration bindingConfiguration, string serviceNames, IKernel kernel);
    [CompilerGeneratedAttribute]
public sealed virtual IBindingConfiguration get_BindingConfiguration();
    [CompilerGeneratedAttribute]
private void set_BindingConfiguration(IBindingConfiguration value);
    [CompilerGeneratedAttribute]
public sealed virtual IKernel get_Kernel();
    [CompilerGeneratedAttribute]
private void set_Kernel(IKernel value);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> When(Func`2<IRequest, bool> condition);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedInto();
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedInto(Type parent);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedInto(Type[] parents);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedExactlyInto();
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedExactlyInto(Type parent);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedExactlyInto(Type[] parents);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenClassHas();
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenMemberHas();
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenTargetHas();
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenClassHas(Type attributeType);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenMemberHas(Type attributeType);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenTargetHas(Type attributeType);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenParentNamed(string name);
    [ObsoleteAttribute("Use WhenAnyAncestorNamed(string name)")]
public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenAnyAnchestorNamed(string name);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenAnyAncestorNamed(string name);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenNoAncestorNamed(string name);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenAnyAncestorMatches(Predicate`1<IContext> predicate);
    public sealed virtual IBindingInNamedWithOrOnSyntax`1<T> WhenNoAncestorMatches(Predicate`1<IContext> predicate);
    public sealed virtual IBindingWithOrOnSyntax`1<T> Named(string name);
    public sealed virtual IBindingNamedWithOrOnSyntax`1<T> InSingletonScope();
    public sealed virtual IBindingNamedWithOrOnSyntax`1<T> InTransientScope();
    public sealed virtual IBindingNamedWithOrOnSyntax`1<T> InThreadScope();
    public sealed virtual IBindingNamedWithOrOnSyntax`1<T> InScope(Func`2<IContext, object> scope);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(string name, object value);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(string name, Func`2<IContext, object> callback);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(string name, Func`3<IContext, ITarget, object> callback);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(TValue value);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Type type, object value);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Type type, Func`2<IContext, object> callback);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Func`2<IContext, TValue> callback);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Type type, Func`3<IContext, ITarget, object> callback);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Func`3<IContext, ITarget, TValue> callback);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithPropertyValue(string name, object value);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithPropertyValue(string name, Func`2<IContext, object> callback);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithPropertyValue(string name, Func`3<IContext, ITarget, object> callback);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithParameter(IParameter parameter);
    public sealed virtual IBindingWithOrOnSyntax`1<T> WithMetadata(string key, object value);
    public sealed virtual IBindingOnSyntax`1<T> OnActivation(Action`1<T> action);
    public sealed virtual IBindingOnSyntax`1<T> OnActivation(Action`1<TImplementation> action);
    public sealed virtual IBindingOnSyntax`1<T> OnActivation(Action`2<IContext, T> action);
    public sealed virtual IBindingOnSyntax`1<T> OnActivation(Action`2<IContext, TImplementation> action);
    public sealed virtual IBindingOnSyntax`1<T> OnDeactivation(Action`1<T> action);
    public sealed virtual IBindingOnSyntax`1<T> OnDeactivation(Action`1<TImplementation> action);
    public sealed virtual IBindingOnSyntax`1<T> OnDeactivation(Action`2<IContext, T> action);
    public sealed virtual IBindingOnSyntax`1<T> OnDeactivation(Action`2<IContext, TImplementation> action);
    private static bool DoesAnyAncestorMatch(IRequest request, Predicate`1<IContext> predicate);
    private sealed virtual override Type Ninject.Syntax.IFluentSyntax.GetType();
}
public class Ninject.Planning.Bindings.BindingMetadata : object {
    private Dictionary`2<string, object> values;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual bool Has(string key);
    public sealed virtual T Get(string key);
    public sealed virtual T Get(string key, T defaultValue);
    public sealed virtual void Set(string key, object value);
}
public class Ninject.Planning.Bindings.BindingPrecedenceComparer : NinjectComponent {
    public sealed virtual int Compare(IBinding x, IBinding y);
}
public enum Ninject.Planning.Bindings.BindingTarget : Enum {
    public int value__;
    public static BindingTarget Self;
    public static BindingTarget Type;
    public static BindingTarget Provider;
    public static BindingTarget Method;
    public static BindingTarget Constant;
}
public interface Ninject.Planning.Bindings.IBinding {
    public IBindingConfiguration BindingConfiguration { get; }
    public Type Service { get; }
    public abstract virtual IBindingConfiguration get_BindingConfiguration();
    public abstract virtual Type get_Service();
}
public interface Ninject.Planning.Bindings.IBindingConfiguration {
    public IBindingMetadata Metadata { get; }
    public BindingTarget Target { get; public set; }
    public bool IsImplicit { get; public set; }
    public bool IsConditional { get; }
    public Func`2<IRequest, bool> Condition { get; public set; }
    public Func`2<IContext, IProvider> ProviderCallback { get; public set; }
    public Func`2<IContext, object> ScopeCallback { get; public set; }
    public ICollection`1<IParameter> Parameters { get; }
    public ICollection`1<Action`2<IContext, object>> ActivationActions { get; }
    public ICollection`1<Action`2<IContext, object>> DeactivationActions { get; }
    public abstract virtual IBindingMetadata get_Metadata();
    public abstract virtual BindingTarget get_Target();
    public abstract virtual void set_Target(BindingTarget value);
    public abstract virtual bool get_IsImplicit();
    public abstract virtual void set_IsImplicit(bool value);
    public abstract virtual bool get_IsConditional();
    public abstract virtual Func`2<IRequest, bool> get_Condition();
    public abstract virtual void set_Condition(Func`2<IRequest, bool> value);
    public abstract virtual Func`2<IContext, IProvider> get_ProviderCallback();
    public abstract virtual void set_ProviderCallback(Func`2<IContext, IProvider> value);
    public abstract virtual Func`2<IContext, object> get_ScopeCallback();
    public abstract virtual void set_ScopeCallback(Func`2<IContext, object> value);
    public abstract virtual ICollection`1<IParameter> get_Parameters();
    public abstract virtual ICollection`1<Action`2<IContext, object>> get_ActivationActions();
    public abstract virtual ICollection`1<Action`2<IContext, object>> get_DeactivationActions();
    public abstract virtual IProvider GetProvider(IContext context);
    public abstract virtual object GetScope(IContext context);
    public abstract virtual bool Matches(IRequest request);
}
public interface Ninject.Planning.Bindings.IBindingConfigurationSyntax`1 {
}
public interface Ninject.Planning.Bindings.IBindingMetadata {
    public string Name { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual bool Has(string key);
    public abstract virtual T Get(string key);
    public abstract virtual T Get(string key, T defaultValue);
    public abstract virtual void Set(string key, object value);
}
public interface Ninject.Planning.Bindings.IBindingPrecedenceComparer {
}
public class Ninject.Planning.Bindings.Resolvers.DefaultValueBindingResolver : NinjectComponent {
    public sealed virtual IEnumerable`1<IBinding> Resolve(Multimap`2<Type, IBinding> bindings, IRequest request);
    private static bool HasDefaultValue(ITarget target);
}
public interface Ninject.Planning.Bindings.Resolvers.IBindingResolver {
    public abstract virtual IEnumerable`1<IBinding> Resolve(Multimap`2<Type, IBinding> bindings, Type service);
}
public interface Ninject.Planning.Bindings.Resolvers.IMissingBindingResolver {
    public abstract virtual IEnumerable`1<IBinding> Resolve(Multimap`2<Type, IBinding> bindings, IRequest request);
}
public class Ninject.Planning.Bindings.Resolvers.OpenGenericBindingResolver : NinjectComponent {
    public sealed virtual IEnumerable`1<IBinding> Resolve(Multimap`2<Type, IBinding> bindings, Type service);
}
public class Ninject.Planning.Bindings.Resolvers.SelfBindingResolver : NinjectComponent {
    public sealed virtual IEnumerable`1<IBinding> Resolve(Multimap`2<Type, IBinding> bindings, IRequest request);
    protected virtual bool TypeIsSelfBindable(Type service);
}
public class Ninject.Planning.Bindings.Resolvers.StandardBindingResolver : NinjectComponent {
    public sealed virtual IEnumerable`1<IBinding> Resolve(Multimap`2<Type, IBinding> bindings, Type service);
}
public class Ninject.Planning.Directives.ConstructorInjectionDirective : MethodInjectionDirectiveBase`2<ConstructorInfo, ConstructorInjector> {
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInjectAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasObsoleteAttribute>k__BackingField;
    public ConstructorInfo Constructor { get; public set; }
    public bool HasInjectAttribute { get; public set; }
    public bool HasObsoleteAttribute { get; public set; }
    public ConstructorInjectionDirective(ConstructorInfo constructor, ConstructorInjector injector);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Constructor();
    [CompilerGeneratedAttribute]
public void set_Constructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public bool get_HasInjectAttribute();
    [CompilerGeneratedAttribute]
public void set_HasInjectAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasObsoleteAttribute();
    [CompilerGeneratedAttribute]
public void set_HasObsoleteAttribute(bool value);
}
public interface Ninject.Planning.Directives.IDirective {
}
public class Ninject.Planning.Directives.MethodInjectionDirective : MethodInjectionDirectiveBase`2<MethodInfo, MethodInjector> {
    public MethodInjectionDirective(MethodInfo method, MethodInjector injector);
}
public abstract class Ninject.Planning.Directives.MethodInjectionDirectiveBase`2 : object {
    [CompilerGeneratedAttribute]
private TInjector <Injector>k__BackingField;
    [CompilerGeneratedAttribute]
private ITarget[] <Targets>k__BackingField;
    public TInjector Injector { get; private set; }
    public ITarget[] Targets { get; private set; }
    protected MethodInjectionDirectiveBase`2(TMethod method, TInjector injector);
    [CompilerGeneratedAttribute]
public TInjector get_Injector();
    [CompilerGeneratedAttribute]
private void set_Injector(TInjector value);
    [CompilerGeneratedAttribute]
public ITarget[] get_Targets();
    [CompilerGeneratedAttribute]
private void set_Targets(ITarget[] value);
    protected virtual ITarget[] CreateTargetsFromParameters(TMethod method);
}
public class Ninject.Planning.Directives.PropertyInjectionDirective : object {
    [CompilerGeneratedAttribute]
private PropertyInjector <Injector>k__BackingField;
    [CompilerGeneratedAttribute]
private ITarget <Target>k__BackingField;
    public PropertyInjector Injector { get; private set; }
    public ITarget Target { get; private set; }
    public PropertyInjectionDirective(PropertyInfo member, PropertyInjector injector);
    [CompilerGeneratedAttribute]
public PropertyInjector get_Injector();
    [CompilerGeneratedAttribute]
private void set_Injector(PropertyInjector value);
    [CompilerGeneratedAttribute]
public ITarget get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(ITarget value);
    protected virtual ITarget CreateTarget(PropertyInfo propertyInfo);
}
public interface Ninject.Planning.IPlan {
    public Type Type { get; }
    public IList`1<ConstructorInjectionDirective> ConstructorInjectionDirectives { get; }
    public abstract virtual Type get_Type();
    public abstract virtual IList`1<ConstructorInjectionDirective> get_ConstructorInjectionDirectives();
    public abstract virtual void Add(IDirective directive);
    public abstract virtual bool Has();
    public abstract virtual TDirective GetOne();
    public abstract virtual IEnumerable`1<TDirective> GetAll();
}
public interface Ninject.Planning.IPlanner {
    public IList`1<IPlanningStrategy> Strategies { get; }
    public abstract virtual IList`1<IPlanningStrategy> get_Strategies();
    public abstract virtual IPlan GetPlan(Type type);
}
public class Ninject.Planning.Plan : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IDirective> <Directives>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConstructorInjectionDirective> <ConstructorInjectionDirectives>k__BackingField;
    public Type Type { get; private set; }
    public ICollection`1<IDirective> Directives { get; private set; }
    public IList`1<ConstructorInjectionDirective> ConstructorInjectionDirectives { get; private set; }
    public Plan(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public ICollection`1<IDirective> get_Directives();
    [CompilerGeneratedAttribute]
private void set_Directives(ICollection`1<IDirective> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConstructorInjectionDirective> get_ConstructorInjectionDirectives();
    [CompilerGeneratedAttribute]
private void set_ConstructorInjectionDirectives(IList`1<ConstructorInjectionDirective> value);
    public sealed virtual void Add(IDirective directive);
    public sealed virtual bool Has();
    public sealed virtual TDirective GetOne();
    public sealed virtual IEnumerable`1<TDirective> GetAll();
}
public class Ninject.Planning.Planner : NinjectComponent {
    private ReaderWriterLockSlim plannerLock;
    private Dictionary`2<Type, IPlan> plans;
    [CompilerGeneratedAttribute]
private IList`1<IPlanningStrategy> <Strategies>k__BackingField;
    public IList`1<IPlanningStrategy> Strategies { get; private set; }
    public Planner(IEnumerable`1<IPlanningStrategy> strategies);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IPlanningStrategy> get_Strategies();
    [CompilerGeneratedAttribute]
private void set_Strategies(IList`1<IPlanningStrategy> value);
    public sealed virtual IPlan GetPlan(Type type);
    protected virtual IPlan CreateEmptyPlan(Type type);
    private IPlan CreateNewPlan(Type type);
}
public class Ninject.Planning.Strategies.ConstructorReflectionStrategy : NinjectComponent {
    [CompilerGeneratedAttribute]
private ISelector <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private IInjectorFactory <InjectorFactory>k__BackingField;
    public ISelector Selector { get; private set; }
    public IInjectorFactory InjectorFactory { get; public set; }
    public ConstructorReflectionStrategy(ISelector selector, IInjectorFactory injectorFactory);
    [CompilerGeneratedAttribute]
public ISelector get_Selector();
    [CompilerGeneratedAttribute]
private void set_Selector(ISelector value);
    [CompilerGeneratedAttribute]
public IInjectorFactory get_InjectorFactory();
    [CompilerGeneratedAttribute]
public void set_InjectorFactory(IInjectorFactory value);
    public sealed virtual void Execute(IPlan plan);
}
public interface Ninject.Planning.Strategies.IPlanningStrategy {
    public abstract virtual void Execute(IPlan plan);
}
public class Ninject.Planning.Strategies.MethodReflectionStrategy : NinjectComponent {
    [CompilerGeneratedAttribute]
private ISelector <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private IInjectorFactory <InjectorFactory>k__BackingField;
    public ISelector Selector { get; private set; }
    public IInjectorFactory InjectorFactory { get; public set; }
    public MethodReflectionStrategy(ISelector selector, IInjectorFactory injectorFactory);
    [CompilerGeneratedAttribute]
public ISelector get_Selector();
    [CompilerGeneratedAttribute]
private void set_Selector(ISelector value);
    [CompilerGeneratedAttribute]
public IInjectorFactory get_InjectorFactory();
    [CompilerGeneratedAttribute]
public void set_InjectorFactory(IInjectorFactory value);
    public sealed virtual void Execute(IPlan plan);
}
public class Ninject.Planning.Strategies.PropertyReflectionStrategy : NinjectComponent {
    [CompilerGeneratedAttribute]
private ISelector <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private IInjectorFactory <InjectorFactory>k__BackingField;
    public ISelector Selector { get; private set; }
    public IInjectorFactory InjectorFactory { get; public set; }
    public PropertyReflectionStrategy(ISelector selector, IInjectorFactory injectorFactory);
    [CompilerGeneratedAttribute]
public ISelector get_Selector();
    [CompilerGeneratedAttribute]
private void set_Selector(ISelector value);
    [CompilerGeneratedAttribute]
public IInjectorFactory get_InjectorFactory();
    [CompilerGeneratedAttribute]
public void set_InjectorFactory(IInjectorFactory value);
    public sealed virtual void Execute(IPlan plan);
}
public interface Ninject.Planning.Targets.ITarget {
    public Type Type { get; }
    public string Name { get; }
    public MemberInfo Member { get; }
    public Func`2<IBindingMetadata, bool> Constraint { get; }
    public bool IsOptional { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public abstract virtual Type get_Type();
    public abstract virtual string get_Name();
    public abstract virtual MemberInfo get_Member();
    public abstract virtual Func`2<IBindingMetadata, bool> get_Constraint();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual object get_DefaultValue();
    public abstract virtual object ResolveWithin(IContext parent);
}
public class Ninject.Planning.Targets.ParameterTarget : Target`1<ParameterInfo> {
    public string Name { get; }
    public Type Type { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public ParameterTarget(MethodBase method, ParameterInfo site);
    public virtual string get_Name();
    public virtual Type get_Type();
    public virtual bool get_HasDefaultValue();
    public virtual object get_DefaultValue();
}
public class Ninject.Planning.Targets.PropertyTarget : Target`1<PropertyInfo> {
    public string Name { get; }
    public Type Type { get; }
    public PropertyTarget(PropertyInfo site);
    public virtual string get_Name();
    public virtual Type get_Type();
}
public abstract class Ninject.Planning.Targets.Target`1 : object {
    private Lazy`1<Func`2<IBindingMetadata, bool>> constraint;
    private Lazy`1<bool> isOptional;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Site>k__BackingField;
    public MemberInfo Member { get; private set; }
    public T Site { get; private set; }
    public string Name { get; }
    public Type Type { get; }
    public Func`2<IBindingMetadata, bool> Constraint { get; }
    public bool IsOptional { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    protected Target`1(MemberInfo member, T site);
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(MemberInfo value);
    [CompilerGeneratedAttribute]
public T get_Site();
    [CompilerGeneratedAttribute]
private void set_Site(T value);
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public sealed virtual Func`2<IBindingMetadata, bool> get_Constraint();
    public sealed virtual bool get_IsOptional();
    public virtual bool get_HasDefaultValue();
    public virtual object get_DefaultValue();
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual object ResolveWithin(IContext parent);
    [ObsoleteAttribute]
protected virtual IEnumerable`1<object> GetValues(Type service, IContext parent);
    [ObsoleteAttribute]
protected virtual object GetValue(Type service, IContext parent);
    protected virtual bool ReadOptionalFromTarget();
    protected virtual Func`2<IBindingMetadata, bool> ReadConstraintFromTarget();
}
[ExtensionAttribute]
public static class Ninject.ResolutionExtensions : object {
    [ExtensionAttribute]
public static T Get(IResolutionRoot root, IParameter[] parameters);
    [ExtensionAttribute]
public static T Get(IResolutionRoot root, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static T Get(IResolutionRoot root, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    [ExtensionAttribute]
public static T TryGet(IResolutionRoot root, IParameter[] parameters);
    [ExtensionAttribute]
public static T TryGet(IResolutionRoot root, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static T TryGet(IResolutionRoot root, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    [ExtensionAttribute]
public static T TryGetAndThrowOnInvalidBinding(IResolutionRoot root, IParameter[] parameters);
    [ExtensionAttribute]
public static T TryGetAndThrowOnInvalidBinding(IResolutionRoot root, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static T TryGetAndThrowOnInvalidBinding(IResolutionRoot root, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAll(IResolutionRoot root, IParameter[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAll(IResolutionRoot root, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAll(IResolutionRoot root, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    [ExtensionAttribute]
public static object Get(IResolutionRoot root, Type service, IParameter[] parameters);
    [ExtensionAttribute]
public static object Get(IResolutionRoot root, Type service, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static object Get(IResolutionRoot root, Type service, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    [ExtensionAttribute]
public static object TryGet(IResolutionRoot root, Type service, IParameter[] parameters);
    [ExtensionAttribute]
public static object TryGet(IResolutionRoot root, Type service, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static object TryGet(IResolutionRoot root, Type service, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<object> GetAll(IResolutionRoot root, Type service, IParameter[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<object> GetAll(IResolutionRoot root, Type service, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<object> GetAll(IResolutionRoot root, Type service, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    [ExtensionAttribute]
public static bool CanResolve(IResolutionRoot root, IParameter[] parameters);
    [ExtensionAttribute]
public static bool CanResolve(IResolutionRoot root, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static bool CanResolve(IResolutionRoot root, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    [ExtensionAttribute]
public static bool CanResolve(IResolutionRoot root, Type service, IParameter[] parameters);
    [ExtensionAttribute]
public static bool CanResolve(IResolutionRoot root, Type service, string name, IParameter[] parameters);
    [ExtensionAttribute]
public static bool CanResolve(IResolutionRoot root, Type service, Func`2<IBindingMetadata, bool> constraint, IParameter[] parameters);
    private static bool CanResolve(IResolutionRoot root, Type service, Func`2<IBindingMetadata, bool> constraint, IEnumerable`1<IParameter> parameters, bool isOptional, bool isUnique);
    private static IEnumerable`1<object> GetResolutionIterator(IResolutionRoot root, Type service, Func`2<IBindingMetadata, bool> constraint, IEnumerable`1<IParameter> parameters, bool isOptional, bool isUnique);
    private static IEnumerable`1<object> GetResolutionIterator(IResolutionRoot root, Type service, Func`2<IBindingMetadata, bool> constraint, IEnumerable`1<IParameter> parameters, bool isOptional, bool isUnique, bool forceUnique);
    private static T TryGet(Func`1<IEnumerable`1<T>> iterator);
    private static T DoTryGetAndThrowOnInvalidBinding(IResolutionRoot root, Func`2<IBindingMetadata, bool> constraint, IEnumerable`1<IParameter> parameters);
}
public interface Ninject.Selection.Heuristics.IConstructorScorer {
    public abstract virtual int Score(IContext context, ConstructorInjectionDirective directive);
}
public interface Ninject.Selection.Heuristics.IInjectionHeuristic {
    public abstract virtual bool ShouldInject(MemberInfo member);
}
public class Ninject.Selection.Heuristics.SpecificConstructorSelector : NinjectComponent {
    private ConstructorInfo constructorInfo;
    public SpecificConstructorSelector(ConstructorInfo constructorInfo);
    public virtual int Score(IContext context, ConstructorInjectionDirective directive);
}
public class Ninject.Selection.Heuristics.StandardConstructorScorer : NinjectComponent {
    public virtual int Score(IContext context, ConstructorInjectionDirective directive);
    protected virtual bool BindingExists(IContext context, ITarget target);
    protected virtual bool BindingExists(IKernel kernel, IContext context, ITarget target);
    protected virtual bool ParameterExists(IContext context, ITarget target);
    private Type GetTargetType(ITarget target);
}
public class Ninject.Selection.Heuristics.StandardInjectionHeuristic : NinjectComponent {
    public virtual bool ShouldInject(MemberInfo member);
}
public interface Ninject.Selection.ISelector {
    public IConstructorScorer ConstructorScorer { get; }
    public ICollection`1<IInjectionHeuristic> InjectionHeuristics { get; }
    public abstract virtual IConstructorScorer get_ConstructorScorer();
    public abstract virtual ICollection`1<IInjectionHeuristic> get_InjectionHeuristics();
    public abstract virtual IEnumerable`1<ConstructorInfo> SelectConstructorsForInjection(Type type);
    public abstract virtual IEnumerable`1<PropertyInfo> SelectPropertiesForInjection(Type type);
    public abstract virtual IEnumerable`1<MethodInfo> SelectMethodsForInjection(Type type);
}
public class Ninject.Selection.Selector : NinjectComponent {
    private static BindingFlags DefaultFlags;
    [CompilerGeneratedAttribute]
private IConstructorScorer <ConstructorScorer>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IInjectionHeuristic> <InjectionHeuristics>k__BackingField;
    public IConstructorScorer ConstructorScorer { get; private set; }
    public ICollection`1<IInjectionHeuristic> InjectionHeuristics { get; private set; }
    protected BindingFlags Flags { get; }
    public Selector(IConstructorScorer constructorScorer, IEnumerable`1<IInjectionHeuristic> injectionHeuristics);
    [CompilerGeneratedAttribute]
public sealed virtual IConstructorScorer get_ConstructorScorer();
    [CompilerGeneratedAttribute]
private void set_ConstructorScorer(IConstructorScorer value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IInjectionHeuristic> get_InjectionHeuristics();
    [CompilerGeneratedAttribute]
private void set_InjectionHeuristics(ICollection`1<IInjectionHeuristic> value);
    protected virtual BindingFlags get_Flags();
    public virtual IEnumerable`1<ConstructorInfo> SelectConstructorsForInjection(Type type);
    public virtual IEnumerable`1<PropertyInfo> SelectPropertiesForInjection(Type type);
    public virtual IEnumerable`1<MethodInfo> SelectMethodsForInjection(Type type);
    private IEnumerable`1<PropertyInfo> GetPrivateProperties(Type type);
    [CompilerGeneratedAttribute]
private PropertyInfo <SelectPropertiesForInjection>b__13_0(PropertyInfo p);
    [CompilerGeneratedAttribute]
private bool <SelectPropertiesForInjection>b__13_1(PropertyInfo p);
    [CompilerGeneratedAttribute]
private bool <SelectMethodsForInjection>b__14_0(MethodInfo m);
}
public class Ninject.StandardKernel : KernelBase {
    protected IKernel KernelInstance { get; }
    public StandardKernel(INinjectModule[] modules);
    public StandardKernel(INinjectSettings settings, INinjectModule[] modules);
    protected virtual IKernel get_KernelInstance();
    protected virtual void AddComponents();
}
public abstract class Ninject.Syntax.BindingRoot : DisposableObject {
    protected IKernel KernelInstance { get; }
    protected abstract virtual IKernel get_KernelInstance();
    public sealed virtual IBindingToSyntax`1<T> Bind();
    public sealed virtual IBindingToSyntax`2<T1, T2> Bind();
    public sealed virtual IBindingToSyntax`3<T1, T2, T3> Bind();
    public sealed virtual IBindingToSyntax`4<T1, T2, T3, T4> Bind();
    public sealed virtual IBindingToSyntax`1<object> Bind(Type[] services);
    public sealed virtual void Unbind();
    public abstract virtual void Unbind(Type service);
    public sealed virtual IBindingToSyntax`1<T1> Rebind();
    public sealed virtual IBindingToSyntax`2<T1, T2> Rebind();
    public sealed virtual IBindingToSyntax`3<T1, T2, T3> Rebind();
    public sealed virtual IBindingToSyntax`4<T1, T2, T3, T4> Rebind();
    public sealed virtual IBindingToSyntax`1<object> Rebind(Type[] services);
    public abstract virtual void AddBinding(IBinding binding);
    public abstract virtual void RemoveBinding(IBinding binding);
    private sealed virtual override Type Ninject.Syntax.IFluentSyntax.GetType();
}
public interface Ninject.Syntax.IBindingInNamedWithOrOnSyntax`1 {
}
public interface Ninject.Syntax.IBindingInSyntax`1 {
    public abstract virtual IBindingNamedWithOrOnSyntax`1<T> InSingletonScope();
    public abstract virtual IBindingNamedWithOrOnSyntax`1<T> InTransientScope();
    public abstract virtual IBindingNamedWithOrOnSyntax`1<T> InThreadScope();
    public abstract virtual IBindingNamedWithOrOnSyntax`1<T> InScope(Func`2<IContext, object> scope);
}
public interface Ninject.Syntax.IBindingNamedSyntax`1 {
    public abstract virtual IBindingWithOrOnSyntax`1<T> Named(string name);
}
public interface Ninject.Syntax.IBindingNamedWithOrOnSyntax`1 {
}
public interface Ninject.Syntax.IBindingOnSyntax`1 {
    public abstract virtual IBindingOnSyntax`1<T> OnActivation(Action`1<T> action);
    public abstract virtual IBindingOnSyntax`1<T> OnActivation(Action`1<TImplementation> action);
    public abstract virtual IBindingOnSyntax`1<T> OnActivation(Action`2<IContext, T> action);
    public abstract virtual IBindingOnSyntax`1<T> OnActivation(Action`2<IContext, TImplementation> action);
    public abstract virtual IBindingOnSyntax`1<T> OnDeactivation(Action`1<T> action);
    public abstract virtual IBindingOnSyntax`1<T> OnDeactivation(Action`1<TImplementation> action);
    public abstract virtual IBindingOnSyntax`1<T> OnDeactivation(Action`2<IContext, T> action);
    public abstract virtual IBindingOnSyntax`1<T> OnDeactivation(Action`2<IContext, TImplementation> action);
}
public interface Ninject.Syntax.IBindingRoot {
    public abstract virtual IBindingToSyntax`1<T> Bind();
    public abstract virtual IBindingToSyntax`2<T1, T2> Bind();
    public abstract virtual IBindingToSyntax`3<T1, T2, T3> Bind();
    public abstract virtual IBindingToSyntax`4<T1, T2, T3, T4> Bind();
    public abstract virtual IBindingToSyntax`1<object> Bind(Type[] services);
    public abstract virtual void Unbind();
    public abstract virtual void Unbind(Type service);
    public abstract virtual IBindingToSyntax`1<T1> Rebind();
    public abstract virtual IBindingToSyntax`2<T1, T2> Rebind();
    public abstract virtual IBindingToSyntax`3<T1, T2, T3> Rebind();
    public abstract virtual IBindingToSyntax`4<T1, T2, T3, T4> Rebind();
    public abstract virtual IBindingToSyntax`1<object> Rebind(Type[] services);
    public abstract virtual void AddBinding(IBinding binding);
    public abstract virtual void RemoveBinding(IBinding binding);
}
public interface Ninject.Syntax.IBindingSyntax {
}
public interface Ninject.Syntax.IBindingToSyntax`1 {
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> ToSelf();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> To();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> To(Type implementation);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> ToProvider();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> ToProvider(Type providerType);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider(IProvider`1<TImplementation> provider);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<T1> ToMethod(Func`2<IContext, T1> method);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToMethod(Func`2<IContext, TImplementation> method);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstant(TImplementation value);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
}
public interface Ninject.Syntax.IBindingToSyntax`2 {
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> To();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> To(Type implementation);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider(Type providerType);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider(IProvider`1<TImplementation> provider);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToMethod(Func`2<IContext, TImplementation> method);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstant(TImplementation value);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
}
public interface Ninject.Syntax.IBindingToSyntax`3 {
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> To();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> To(Type implementation);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider(Type providerType);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider(IProvider`1<TImplementation> provider);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToMethod(Func`2<IContext, TImplementation> method);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstant(TImplementation value);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
}
public interface Ninject.Syntax.IBindingToSyntax`4 {
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> To();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> To(Type implementation);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider();
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<object> ToProvider(Type providerType);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToProvider(IProvider`1<TImplementation> provider);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToMethod(Func`2<IContext, TImplementation> method);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstant(TImplementation value);
    public abstract virtual IBindingWhenInNamedWithOrOnSyntax`1<TImplementation> ToConstructor(Expression`1<Func`2<IConstructorArgumentSyntax, TImplementation>> newExpression);
}
public interface Ninject.Syntax.IBindingWhenInNamedWithOrOnSyntax`1 {
}
public interface Ninject.Syntax.IBindingWhenSyntax`1 {
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> When(Func`2<IRequest, bool> condition);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedInto();
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedInto(Type parent);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedInto(Type[] parents);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedExactlyInto();
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedExactlyInto(Type parent);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenInjectedExactlyInto(Type[] parents);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenClassHas();
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenMemberHas();
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenTargetHas();
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenClassHas(Type attributeType);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenMemberHas(Type attributeType);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenTargetHas(Type attributeType);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenParentNamed(string name);
    [ObsoleteAttribute("Use WhenAnyAncestorNamed(string name)")]
public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenAnyAnchestorNamed(string name);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenAnyAncestorNamed(string name);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenNoAncestorNamed(string name);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenAnyAncestorMatches(Predicate`1<IContext> predicate);
    public abstract virtual IBindingInNamedWithOrOnSyntax`1<T> WhenNoAncestorMatches(Predicate`1<IContext> predicate);
}
public interface Ninject.Syntax.IBindingWithOrOnSyntax`1 {
}
public interface Ninject.Syntax.IBindingWithSyntax`1 {
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(string name, object value);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(string name, Func`2<IContext, object> callback);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(string name, Func`3<IContext, ITarget, object> callback);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(TValue value);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Type type, object value);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Func`2<IContext, TValue> callback);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Type type, Func`2<IContext, object> callback);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Func`3<IContext, ITarget, TValue> callback);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithConstructorArgument(Type type, Func`3<IContext, ITarget, object> callback);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithPropertyValue(string name, object value);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithPropertyValue(string name, Func`2<IContext, object> callback);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithPropertyValue(string name, Func`3<IContext, ITarget, object> callback);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithParameter(IParameter parameter);
    public abstract virtual IBindingWithOrOnSyntax`1<T> WithMetadata(string key, object value);
}
public interface Ninject.Syntax.IConstructorArgumentSyntax {
    public IContext Context { get; }
    public abstract virtual IContext get_Context();
    public abstract virtual T Inject();
}
[EditorBrowsableAttribute("1")]
public interface Ninject.Syntax.IFluentSyntax {
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object other);
}
public interface Ninject.Syntax.IResolutionRoot {
    public abstract virtual void Inject(object instance, IParameter[] parameters);
    public abstract virtual bool CanResolve(IRequest request);
    public abstract virtual bool CanResolve(IRequest request, bool ignoreImplicitBindings);
    public abstract virtual IEnumerable`1<object> Resolve(IRequest request);
    public abstract virtual IRequest CreateRequest(Type service, Func`2<IBindingMetadata, bool> constraint, IEnumerable`1<IParameter> parameters, bool isOptional, bool isUnique);
    public abstract virtual bool Release(object instance);
}
