[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AssertionConditionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private AssertionConditionType <ConditionType>k__BackingField;
    public AssertionConditionType ConditionType { get; }
    public AssertionConditionAttribute(AssertionConditionType conditionType);
    [CompilerGeneratedAttribute]
public AssertionConditionType get_ConditionType();
}
internal enum JetBrains.Annotations.AssertionConditionType : Enum {
    public int value__;
    public static AssertionConditionType IS_TRUE;
    public static AssertionConditionType IS_FALSE;
    public static AssertionConditionType IS_NULL;
    public static AssertionConditionType IS_NOT_NULL;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AssertionMethodAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
internal class JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
internal class JetBrains.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("8416")]
internal class JetBrains.Annotations.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
}
[FlagsAttribute]
internal enum JetBrains.Annotations.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    [NotNullAttribute]
public string Contract { get; }
    public bool ForceFullStates { get; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithInheritors;
    public static ImplicitUseTargetFlags WithMembers;
}
internal enum JetBrains.Annotations.InjectedLanguage : Enum {
    public int value__;
    public static InjectedLanguage CSS;
    public static InjectedLanguage HTML;
    public static InjectedLanguage JAVASCRIPT;
    public static InjectedLanguage JSON;
    public static InjectedLanguage XML;
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InstantHandleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <RequireAwait>k__BackingField;
    public bool RequireAwait { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RequireAwait();
    [CompilerGeneratedAttribute]
public void set_RequireAwait(bool value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.LanguageInjectionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private InjectedLanguage <InjectedLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    public InjectedLanguage InjectedLanguage { get; }
    [CanBeNullAttribute]
public string Prefix { get; public set; }
    [CanBeNullAttribute]
public string Suffix { get; public set; }
    public LanguageInjectionAttribute(InjectedLanguage injectedLanguage);
    [CompilerGeneratedAttribute]
public InjectedLanguage get_InjectedLanguage();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public void set_Suffix(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.MacroAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Editable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CanBeNullAttribute]
public string Expression { get; public set; }
    public int Editable { get; public set; }
    [CanBeNullAttribute]
public string Target { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
    [CompilerGeneratedAttribute]
public int get_Editable();
    [CompilerGeneratedAttribute]
public void set_Editable(int value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
}
[AttributeUsageAttribute("18436")]
internal class JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.MustUseReturnValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [CanBeNullAttribute]
public string Justification { get; }
    public MustUseReturnValueAttribute(string justification);
    [CompilerGeneratedAttribute]
public string get_Justification();
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.NonNegativeValueAttribute : Attribute {
}
[AttributeUsageAttribute("1052")]
internal class JetBrains.Annotations.NoReorderAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CanBeNullAttribute]
public string ParameterName { get; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CanBeNullAttribute]
public string BasePath { get; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
}
[AttributeUsageAttribute("19916")]
internal class JetBrains.Annotations.ProvidesContextAttribute : Attribute {
}
[MeansImplicitUseAttribute("3")]
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CanBeNullAttribute]
public string Comment { get; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.RegexPatternAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RequireStaticDelegateAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    public bool IsError { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public void set_IsError(bool value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.SourceTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("4320")]
internal class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    [NotNullAttribute]
public string FormatParameterName { get; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.StructuredMessageTemplateAttribute : Attribute {
}
[ObsoleteAttribute("Use [ContractAnnotation('=> halt')] instead")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.TerminatesProgramAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; }
    public ImplicitUseTargetFlags TargetFlags { get; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.ValueProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ValueRangeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <From>k__BackingField;
    [CompilerGeneratedAttribute]
private object <To>k__BackingField;
    public object From { get; }
    public object To { get; }
    public ValueRangeAttribute(long from, long to);
    public ValueRangeAttribute(ulong from, ulong to);
    public ValueRangeAttribute(long value);
    public ValueRangeAttribute(ulong value);
    [CompilerGeneratedAttribute]
public object get_From();
    [CompilerGeneratedAttribute]
public object get_To();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class NLog.Attributes.LogLevelTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    private static bool IsNumericType(Type sourceType);
}
public class NLog.Common.AsyncContinuation : MulticastDelegate {
    public AsyncContinuation(object object, IntPtr method);
    public virtual void Invoke(Exception exception);
    public virtual IAsyncResult BeginInvoke(Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class NLog.Common.AsyncHelpers : object {
    internal static int GetManagedThreadId();
    internal static void StartAsyncTask(AsyncHelpersTask asyncTask, object state);
    internal static void WaitForDelay(TimeSpan delay);
    [ObsoleteAttribute("Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static void ForEachItemSequentially(IEnumerable`1<T> items, AsyncContinuation asyncContinuation, AsynchronousAction`1<T> action);
    public static void Repeat(int repeatCount, AsyncContinuation asyncContinuation, AsynchronousAction action);
    [ObsoleteAttribute("Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static AsyncContinuation PrecededBy(AsyncContinuation asyncContinuation, AsynchronousAction action);
    public static AsyncContinuation WithTimeout(AsyncContinuation asyncContinuation, TimeSpan timeout);
    public static void ForEachItemInParallel(IEnumerable`1<T> values, AsyncContinuation asyncContinuation, AsynchronousAction`1<T> action);
    [ObsoleteAttribute("Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static void RunSynchronously(AsynchronousAction action);
    public static AsyncContinuation PreventMultipleCalls(AsyncContinuation asyncContinuation);
    public static Exception GetCombinedException(IList`1<Exception> exceptions);
    private static AsynchronousAction ExceptionGuard(AsynchronousAction action);
    private static AsynchronousAction`1<T> ExceptionGuard(AsynchronousAction`1<T> action);
    [ExtensionAttribute]
internal static bool WaitForDispose(Timer timer, TimeSpan timeout);
}
public class NLog.Common.AsynchronousAction : MulticastDelegate {
    public AsynchronousAction(object object, IntPtr method);
    public virtual void Invoke(AsyncContinuation asyncContinuation);
    public virtual IAsyncResult BeginInvoke(AsyncContinuation asyncContinuation, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NLog.Common.AsynchronousAction`1 : MulticastDelegate {
    public AsynchronousAction`1(object object, IntPtr method);
    public virtual void Invoke(T argument, AsyncContinuation asyncContinuation);
    public virtual IAsyncResult BeginInvoke(T argument, AsyncContinuation asyncContinuation, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NLog.Common.AsyncLogEventInfo : ValueType {
    [CompilerGeneratedAttribute]
private LogEventInfo <LogEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncContinuation <Continuation>k__BackingField;
    public LogEventInfo LogEvent { get; }
    public AsyncContinuation Continuation { get; }
    public AsyncLogEventInfo(LogEventInfo logEvent, AsyncContinuation continuation);
    [CompilerGeneratedAttribute]
public LogEventInfo get_LogEvent();
    [CompilerGeneratedAttribute]
public AsyncContinuation get_Continuation();
    public static bool op_Equality(AsyncLogEventInfo eventInfo1, AsyncLogEventInfo eventInfo2);
    public static bool op_Inequality(AsyncLogEventInfo eventInfo1, AsyncLogEventInfo eventInfo2);
    public sealed virtual bool Equals(AsyncLogEventInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NLog.Common.ConversionHelpers : object {
    public static bool TryParseEnum(string inputValue, TEnum& resultValue, TEnum defaultValue);
    internal static bool TryParseEnum(string inputValue, Type enumType, Object& resultValue);
    internal static bool TryParseEnum(string inputValue, bool ignoreCase, TEnum& resultValue);
    private static bool TryParseEnum_net3(string value, bool ignoreCase, TEnum& result);
}
internal interface NLog.Common.IInternalLoggerContext {
    public string Name { get; }
    [CanBeNullAttribute]
public LogFactory LogFactory { get; }
    public abstract virtual string get_Name();
    public abstract virtual LogFactory get_LogFactory();
}
public class NLog.Common.InternalEventOccurredHandler : MulticastDelegate {
    public InternalEventOccurredHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InternalLogEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InternalLogEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class NLog.Common.InternalLogEventArgs : ValueType {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SenderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SenderName>k__BackingField;
    public string Message { get; }
    public LogLevel Level { get; }
    [CanBeNullAttribute]
public Exception Exception { get; }
    [CanBeNullAttribute]
public Type SenderType { get; }
    [CanBeNullAttribute]
public string SenderName { get; }
    internal InternalLogEventArgs(string message, LogLevel level, Exception exception, Type senderType, string senderName);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public Type get_SenderType();
    [CompilerGeneratedAttribute]
public string get_SenderName();
}
public static class NLog.Common.InternalLogger : object {
    private static object LockObject;
    private static LogLevel _logLevel;
    private static bool _logToConsole;
    private static bool _logToConsoleError;
    private static bool _logToTrace;
    private static string _logFile;
    [CompilerGeneratedAttribute]
private static TextWriter <LogWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventHandler`1<InternalLoggerMessageEventArgs> _logMessageReceived;
    [CompilerGeneratedAttribute]
private static InternalEventOccurredHandler InternalEventOccurred;
    [CompilerGeneratedAttribute]
private static bool <IncludeTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <ExceptionThrowWhenWriting>k__BackingField;
    public static bool IsTraceEnabled { get; }
    public static bool IsDebugEnabled { get; }
    public static bool IsInfoEnabled { get; }
    public static bool IsWarnEnabled { get; }
    public static bool IsErrorEnabled { get; }
    public static bool IsFatalEnabled { get; }
    public static LogLevel LogLevel { get; public set; }
    public static bool LogToConsole { get; public set; }
    public static bool LogToConsoleError { get; public set; }
    [ObsoleteAttribute("Instead use InternalLogger.LogWriter. Marked obsolete with NLog v5.3")]
public static bool LogToTrace { get; public set; }
    public static string LogFile { get; public set; }
    public static TextWriter LogWriter { get; public set; }
    public static bool IncludeTimestamp { get; public set; }
    internal static bool ExceptionThrowWhenWriting { get; private set; }
    private static InternalLogger();
    public static bool get_IsTraceEnabled();
    public static bool get_IsDebugEnabled();
    public static bool get_IsInfoEnabled();
    public static bool get_IsWarnEnabled();
    public static bool get_IsErrorEnabled();
    public static bool get_IsFatalEnabled();
    [StringFormatMethodAttribute("message")]
public static void Trace(string message, Object[] args);
    public static void Trace(string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Trace(Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Trace(Exception ex, string message, Object[] args);
    [StringFormatMethodAttribute("message")]
public static void Trace(string message, TArgument1 arg0);
    [StringFormatMethodAttribute("message")]
public static void Trace(string message, TArgument1 arg0, TArgument2 arg1);
    [StringFormatMethodAttribute("message")]
public static void Trace(string message, TArgument1 arg0, TArgument2 arg1, TArgument3 arg2);
    public static void Trace(Exception ex, string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Trace(Exception ex, Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Debug(string message, Object[] args);
    public static void Debug(string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Debug(Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Debug(Exception ex, string message, Object[] args);
    [StringFormatMethodAttribute("message")]
public static void Debug(string message, TArgument1 arg0);
    [StringFormatMethodAttribute("message")]
public static void Debug(string message, TArgument1 arg0, TArgument2 arg1);
    [StringFormatMethodAttribute("message")]
public static void Debug(string message, TArgument1 arg0, TArgument2 arg1, TArgument3 arg2);
    public static void Debug(Exception ex, string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Debug(Exception ex, Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Info(string message, Object[] args);
    public static void Info(string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Info(Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Info(Exception ex, string message, Object[] args);
    [StringFormatMethodAttribute("message")]
public static void Info(string message, TArgument1 arg0);
    [StringFormatMethodAttribute("message")]
public static void Info(string message, TArgument1 arg0, TArgument2 arg1);
    [StringFormatMethodAttribute("message")]
public static void Info(string message, TArgument1 arg0, TArgument2 arg1, TArgument3 arg2);
    public static void Info(Exception ex, string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Info(Exception ex, Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Warn(string message, Object[] args);
    public static void Warn(string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Warn(Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Warn(Exception ex, string message, Object[] args);
    [StringFormatMethodAttribute("message")]
public static void Warn(string message, TArgument1 arg0);
    [StringFormatMethodAttribute("message")]
public static void Warn(string message, TArgument1 arg0, TArgument2 arg1);
    [StringFormatMethodAttribute("message")]
public static void Warn(string message, TArgument1 arg0, TArgument2 arg1, TArgument3 arg2);
    public static void Warn(Exception ex, string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Warn(Exception ex, Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Error(string message, Object[] args);
    public static void Error(string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Error(Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Error(Exception ex, string message, Object[] args);
    [StringFormatMethodAttribute("message")]
public static void Error(string message, TArgument1 arg0);
    [StringFormatMethodAttribute("message")]
public static void Error(string message, TArgument1 arg0, TArgument2 arg1);
    [StringFormatMethodAttribute("message")]
public static void Error(string message, TArgument1 arg0, TArgument2 arg1, TArgument3 arg2);
    public static void Error(Exception ex, string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Error(Exception ex, Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Fatal(string message, Object[] args);
    public static void Fatal(string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Fatal(Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Fatal(Exception ex, string message, Object[] args);
    [StringFormatMethodAttribute("message")]
public static void Fatal(string message, TArgument1 arg0);
    [StringFormatMethodAttribute("message")]
public static void Fatal(string message, TArgument1 arg0, TArgument2 arg1);
    [StringFormatMethodAttribute("message")]
public static void Fatal(string message, TArgument1 arg0, TArgument2 arg1, TArgument3 arg2);
    public static void Fatal(Exception ex, string message);
    [ObsoleteAttribute("Avoid delegate capture allocations. Marked obsolete with v5.3")]
[EditorBrowsableAttribute("1")]
public static void Fatal(Exception ex, Func`1<string> messageFunc);
    public static void Reset();
    public static LogLevel get_LogLevel();
    public static void set_LogLevel(LogLevel value);
    public static bool get_LogToConsole();
    public static void set_LogToConsole(bool value);
    public static bool get_LogToConsoleError();
    public static void set_LogToConsoleError(bool value);
    public static bool get_LogToTrace();
    public static void set_LogToTrace(bool value);
    public static string get_LogFile();
    public static void set_LogFile(string value);
    [CompilerGeneratedAttribute]
public static TextWriter get_LogWriter();
    [CompilerGeneratedAttribute]
public static void set_LogWriter(TextWriter value);
    public static void add_LogMessageReceived(EventHandler`1<InternalLoggerMessageEventArgs> value);
    public static void remove_LogMessageReceived(EventHandler`1<InternalLoggerMessageEventArgs> value);
    [CompilerGeneratedAttribute]
private static void add__logMessageReceived(EventHandler`1<InternalLoggerMessageEventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove__logMessageReceived(EventHandler`1<InternalLoggerMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_InternalEventOccurred(InternalEventOccurredHandler value);
    [CompilerGeneratedAttribute]
public static void remove_InternalEventOccurred(InternalEventOccurredHandler value);
    [CompilerGeneratedAttribute]
public static bool get_IncludeTimestamp();
    [CompilerGeneratedAttribute]
public static void set_IncludeTimestamp(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_ExceptionThrowWhenWriting();
    [CompilerGeneratedAttribute]
private static void set_ExceptionThrowWhenWriting(bool value);
    [StringFormatMethodAttribute("message")]
public static void Log(LogLevel level, string message, Object[] args);
    public static void Log(LogLevel level, string message);
    public static void Log(LogLevel level, Func`1<string> messageFunc);
    public static void Log(Exception ex, LogLevel level, Func`1<string> messageFunc);
    [StringFormatMethodAttribute("message")]
public static void Log(Exception ex, LogLevel level, string message, Object[] args);
    public static void Log(Exception ex, LogLevel level, string message);
    private static void Write(Exception ex, LogLevel level, string message, Object[] args);
    private static void WriteToLog(LogLevel level, Exception ex, string fullMessage, IInternalLoggerContext loggerContext);
    private static string CreateLogLine(Exception ex, LogLevel level, string fullMessage);
    private static bool IsSeriousException(Exception exception);
    private static bool IsLogLevelEnabled(LogLevel logLevel);
    internal static bool HasActiveLoggers();
    [ObsoleteAttribute("InternalLogger should be minimal. Marked obsolete with NLog v5.3")]
public static void LogAssemblyVersion(Assembly assembly);
    [ObsoleteAttribute("InternalLogger should be minimal. Marked obsolete with NLog v5.3")]
private static string GetAppSettings(string configName);
    [ObsoleteAttribute("InternalLogger should be minimal. Marked obsolete with NLog v5.3")]
private static string GetSettingString(string configName, string envName);
    [ObsoleteAttribute("InternalLogger should be minimal. Marked obsolete with NLog v5.3")]
private static LogLevel GetSetting(string configName, string envName, LogLevel defaultValue);
    [ObsoleteAttribute("InternalLogger should be minimal. Marked obsolete with NLog v5.3")]
private static T GetSetting(string configName, string envName, T defaultValue);
    private static void CreateDirectoriesIfNeeded(string filename);
    private static string ExpandFilePathVariables(string internalLogFile);
    private static bool ContainsSubStringIgnoreCase(string haystack, string needle, String& result);
    private static void LogToConsoleSubscription(object sender, InternalLogEventArgs eventArgs);
    private static void LogToConsoleErrorSubscription(object sender, InternalLogEventArgs eventArgs);
    [ObsoleteAttribute("Instead use InternalLogger.LogWriter. Marked obsolete with NLog v5.3")]
private static void LogToTraceSubscription(object sender, InternalLogEventArgs eventArgs);
    private static void LogToFileSubscription(object sender, InternalLogEventArgs eventArgs);
    [ObsoleteAttribute("Instead use InternalEventOccurred and InternalLogEventArgs. Marked obsolete with NLog v5.3")]
private static void LogToMessageReceived(object sender, InternalLogEventArgs eventArgs);
}
[ObsoleteAttribute("Instead use InternalEventOccurred and InternalLogEventArgs. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public class NLog.Common.InternalLoggerMessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SenderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SenderName>k__BackingField;
    public string Message { get; }
    public LogLevel Level { get; }
    [CanBeNullAttribute]
public Exception Exception { get; }
    [CanBeNullAttribute]
public Type SenderType { get; }
    [CanBeNullAttribute]
public string SenderName { get; }
    internal InternalLoggerMessageEventArgs(string message, LogLevel level, Exception exception, Type senderType, string senderName);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public Type get_SenderType();
    [CompilerGeneratedAttribute]
public string get_SenderName();
}
[ObsoleteAttribute("Use AsyncRequestQueue instead. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public class NLog.Common.LogEventInfoBuffer : object {
    private object _lockObject;
    private bool _growAsNeeded;
    private int _growLimit;
    private AsyncLogEventInfo[] _buffer;
    private int _getPointer;
    private int _putPointer;
    private int _count;
    public int Size { get; }
    internal int Count { get; }
    public LogEventInfoBuffer(int size, bool growAsNeeded, int growLimit);
    public int get_Size();
    internal int get_Count();
    public int Append(AsyncLogEventInfo eventInfo);
    public AsyncLogEventInfo[] GetEventsAndClear();
}
internal class NLog.Conditions.ConditionAndExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private ConditionExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <Right>k__BackingField;
    public ConditionExpression Left { get; }
    public ConditionExpression Right { get; }
    public ConditionAndExpression(ConditionExpression left, ConditionExpression right);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Left();
    [CompilerGeneratedAttribute]
public ConditionExpression get_Right();
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
public class NLog.Conditions.ConditionEvaluationException : Exception {
    public ConditionEvaluationException(string message);
    public ConditionEvaluationException(string message, Exception innerException);
    protected ConditionEvaluationException(SerializationInfo info, StreamingContext context);
}
internal class NLog.Conditions.ConditionExceptionExpression : ConditionExpression {
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
[NLogConfigurationItemAttribute]
public abstract class NLog.Conditions.ConditionExpression : object {
    internal static object BoxedTrue;
    internal static object BoxedFalse;
    private static ConditionExpression();
    public static ConditionExpression op_Implicit(string conditionExpressionText);
    public object Evaluate(LogEventInfo context);
    public abstract virtual string ToString();
    protected abstract virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionLayoutExpression : ConditionExpression {
    private SimpleLayout _simpleLayout;
    private StringBuilder _fastObjectPool;
    public Layout Layout { get; }
    public ConditionLayoutExpression(SimpleLayout layout);
    public Layout get_Layout();
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionLevelExpression : ConditionExpression {
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionLiteralExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private object <LiteralValue>k__BackingField;
    public object LiteralValue { get; }
    public ConditionLiteralExpression(object literalValue);
    [CompilerGeneratedAttribute]
public object get_LiteralValue();
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionLoggerNameExpression : ConditionExpression {
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionMessageExpression : ConditionExpression {
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
[AttributeUsageAttribute("64")]
public class NLog.Conditions.ConditionMethodAttribute : NameBaseAttribute {
    public ConditionMethodAttribute(string name);
}
internal class NLog.Conditions.ConditionMethodExpression : ConditionExpression {
    private IEvaluateMethod _method;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConditionExpression> <MethodParameters>k__BackingField;
    public string MethodName { get; }
    public IList`1<ConditionExpression> MethodParameters { get; }
    private ConditionMethodExpression(string methodName, IList`1<ConditionExpression> methodParameters, IEvaluateMethod method);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public IList`1<ConditionExpression> get_MethodParameters();
    protected virtual object EvaluateNode(LogEventInfo context);
    public virtual string ToString();
    public static ConditionMethodExpression CreateMethodNoParameters(string conditionMethodName, Func`2<LogEventInfo, object> method);
    public static ConditionMethodExpression CreateMethodOneParameter(string conditionMethodName, Func`3<LogEventInfo, object, object> method, IList`1<ConditionExpression> methodParameters);
    public static ConditionMethodExpression CreateMethodTwoParameters(string conditionMethodName, Func`4<LogEventInfo, object, object, object> method, IList`1<ConditionExpression> methodParameters);
    public static ConditionMethodExpression CreateMethodThreeParameters(string conditionMethodName, Func`5<LogEventInfo, object, object, object, object> method, IList`1<ConditionExpression> methodParameters);
    public static ConditionMethodExpression CreateMethodManyParameters(string conditionMethodName, Func`2<Object[], object> method, IList`1<ConditionExpression> methodParameters, bool includeLogEvent);
}
[ConditionMethodsAttribute]
public static class NLog.Conditions.ConditionMethods : object {
    [ConditionMethodAttribute("equals")]
public static bool Equals2(object firstValue, object secondValue);
    [ConditionMethodAttribute("strequals")]
public static bool Equals2(string firstValue, string secondValue, bool ignoreCase);
    [ConditionMethodAttribute("contains")]
public static bool Contains(string haystack, string needle, bool ignoreCase);
    [ConditionMethodAttribute("starts-with")]
public static bool StartsWith(string haystack, string needle, bool ignoreCase);
    [ConditionMethodAttribute("ends-with")]
public static bool EndsWith(string haystack, string needle, bool ignoreCase);
    [ConditionMethodAttribute("length")]
public static int Length(string text);
    [ConditionMethodAttribute("regex-matches")]
public static bool RegexMatches(string input, string pattern, string options);
    private static RegexOptions ParseRegexOptions(string options);
}
[AttributeUsageAttribute("4")]
public class NLog.Conditions.ConditionMethodsAttribute : Attribute {
}
internal class NLog.Conditions.ConditionNotExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private ConditionExpression <Expression>k__BackingField;
    public ConditionExpression Expression { get; }
    public ConditionNotExpression(ConditionExpression expression);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Expression();
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionOrExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private ConditionExpression <LeftExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <RightExpression>k__BackingField;
    public ConditionExpression LeftExpression { get; }
    public ConditionExpression RightExpression { get; }
    public ConditionOrExpression(ConditionExpression left, ConditionExpression right);
    [CompilerGeneratedAttribute]
public ConditionExpression get_LeftExpression();
    [CompilerGeneratedAttribute]
public ConditionExpression get_RightExpression();
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
public class NLog.Conditions.ConditionParseException : Exception {
    public ConditionParseException(string message);
    public ConditionParseException(string message, Exception innerException);
    protected ConditionParseException(SerializationInfo info, StreamingContext context);
}
public class NLog.Conditions.ConditionParser : object {
    private ConditionTokenizer _tokenizer;
    private ConfigurationItemFactory _configurationItemFactory;
    private ConditionParser(SimpleStringReader stringReader, ConfigurationItemFactory configurationItemFactory);
    public static ConditionExpression ParseExpression(string expressionText);
    public static ConditionExpression ParseExpression(string expressionText, ConfigurationItemFactory configurationItemFactories);
    internal static ConditionExpression ParseExpression(SimpleStringReader stringReader, ConfigurationItemFactory configurationItemFactories);
    private ConditionMethodExpression ParseMethodPredicate(string functionName);
    private ConditionMethodExpression CreateMethodExpression(string functionName, List`1<ConditionExpression> inputParameters);
    private ConditionExpression ParseLiteralExpression();
    private bool TryPlainKeywordToExpression(string keyword, ConditionExpression& expression);
    private ConditionExpression ParseNumber(bool negative);
    private ConditionExpression ParseBooleanRelation();
    private ConditionExpression ParseBooleanPredicate();
    private ConditionExpression ParseBooleanAnd();
    private ConditionExpression ParseBooleanOr();
    private ConditionExpression ParseBooleanExpression();
    private ConditionExpression ParseExpression();
}
internal class NLog.Conditions.ConditionRelationalExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private ConditionExpression <LeftExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <RightExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionRelationalOperator <RelationalOperator>k__BackingField;
    private static Dictionary`2<Type, int> TypePromoteOrder;
    public ConditionExpression LeftExpression { get; }
    public ConditionExpression RightExpression { get; }
    public ConditionRelationalOperator RelationalOperator { get; }
    public ConditionRelationalExpression(ConditionExpression leftExpression, ConditionExpression rightExpression, ConditionRelationalOperator relationalOperator);
    private static ConditionRelationalExpression();
    [CompilerGeneratedAttribute]
public ConditionExpression get_LeftExpression();
    [CompilerGeneratedAttribute]
public ConditionExpression get_RightExpression();
    [CompilerGeneratedAttribute]
public ConditionRelationalOperator get_RelationalOperator();
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
    private static bool Compare(object leftValue, object rightValue, ConditionRelationalOperator relationalOperator);
    private static void PromoteTypes(Object& leftValue, Object& rightValue);
    private static bool TryPromoteType(Object& val, Type type1);
    private static bool TryPromoteTypes(Object& val1, Type type1, Object& val2, Type type2);
    private static int GetOrder(Type type1);
    private static Dictionary`2<Type, int> BuildTypeOrderDictionary();
    private string GetOperatorString();
}
internal enum NLog.Conditions.ConditionRelationalOperator : Enum {
    public int value__;
    public static ConditionRelationalOperator Equal;
    public static ConditionRelationalOperator NotEqual;
    public static ConditionRelationalOperator Less;
    public static ConditionRelationalOperator Greater;
    public static ConditionRelationalOperator LessOrEqual;
    public static ConditionRelationalOperator GreaterOrEqual;
}
internal class NLog.Conditions.ConditionTokenizer : object {
    private static ConditionTokenType[] CharIndexToTokenType;
    private SimpleStringReader _stringReader;
    [CompilerGeneratedAttribute]
private ConditionTokenType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenValue>k__BackingField;
    public ConditionTokenType TokenType { get; private set; }
    public string TokenValue { get; private set; }
    public string StringTokenValue { get; }
    public ConditionTokenizer(SimpleStringReader stringReader);
    private static ConditionTokenizer();
    [CompilerGeneratedAttribute]
public ConditionTokenType get_TokenType();
    [CompilerGeneratedAttribute]
private void set_TokenType(ConditionTokenType value);
    [CompilerGeneratedAttribute]
public string get_TokenValue();
    [CompilerGeneratedAttribute]
private void set_TokenValue(string value);
    public string get_StringTokenValue();
    public void Expect(ConditionTokenType tokenType);
    public string EatKeyword();
    public bool IsKeyword(string keyword);
    public bool IsEOF();
    public bool IsNumber();
    public bool IsToken(ConditionTokenType tokenType);
    public void GetNextToken();
    private bool TryGetComparisonToken(char ch);
    private bool TryGetLogicalToken(char ch);
    private static ConditionTokenType[] BuildCharIndexToTokenType();
    private void ParseSingleQuotedString(char ch);
    private void ParseKeyword(char ch);
    private void ParseNumber(char ch);
    private void SkipWhitespace();
    private int PeekChar();
    private int ReadChar();
}
internal enum NLog.Conditions.ConditionTokenType : Enum {
    public int value__;
    public static ConditionTokenType EndOfInput;
    public static ConditionTokenType BeginningOfInput;
    public static ConditionTokenType Number;
    public static ConditionTokenType String;
    public static ConditionTokenType Keyword;
    public static ConditionTokenType Whitespace;
    public static ConditionTokenType FirstPunct;
    public static ConditionTokenType LessThan;
    public static ConditionTokenType GreaterThan;
    public static ConditionTokenType LessThanOrEqualTo;
    public static ConditionTokenType GreaterThanOrEqualTo;
    public static ConditionTokenType EqualTo;
    public static ConditionTokenType NotEqual;
    public static ConditionTokenType LeftParen;
    public static ConditionTokenType RightParen;
    public static ConditionTokenType Dot;
    public static ConditionTokenType Comma;
    public static ConditionTokenType Not;
    public static ConditionTokenType And;
    public static ConditionTokenType Or;
    public static ConditionTokenType Minus;
    public static ConditionTokenType LastPunct;
    public static ConditionTokenType Invalid;
    public static ConditionTokenType ClosingCurlyBrace;
    public static ConditionTokenType Colon;
    public static ConditionTokenType Exclamation;
    public static ConditionTokenType Ampersand;
    public static ConditionTokenType Pipe;
}
[ObsoleteAttribute("Attribute is no longer used. Obsolete with NLog 5.0")]
[AttributeUsageAttribute("128")]
public class NLog.Config.AdvancedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class NLog.Config.AppDomainFixedOutputAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
[MeansImplicitUseAttribute]
public class NLog.Config.ArrayParameterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    public Type ItemType { get; }
    public string ElementName { get; }
    public ArrayParameterAttribute(Type itemType, string elementName);
    [CompilerGeneratedAttribute]
public Type get_ItemType();
    [CompilerGeneratedAttribute]
public string get_ElementName();
}
[ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
internal class NLog.Config.AssemblyExtensionLoader : object {
    [UnconditionalSuppressMessageAttribute("Trimming - Allow extension loading from config", "IL2072")]
public sealed virtual void LoadTypeFromName(ConfigurationItemFactory factory, string typeName, string itemNamePrefix);
    public sealed virtual void LoadAssemblyFromName(ConfigurationItemFactory factory, string assemblyName, string itemNamePrefix);
    private static bool SkipAlreadyLoadedAssembly(ConfigurationItemFactory factory, string assemblyName, string itemNamePrefix);
    private static Dictionary`2<Assembly, Type> ResolveLoadedAssemblyTypes(ConfigurationItemFactory factory);
    private static bool IsNLogConfigurationItemType(Type itemType);
    private static bool IsNLogItemTypeAlreadyRegistered(ConfigurationItemFactory factory, Type itemType, string itemNamePrefix);
    private static bool IsNLogItemTypeAlreadyRegistered(TFactory factory, Type itemType, string itemNamePrefix);
    public sealed virtual void LoadAssemblyFromPath(ConfigurationItemFactory factory, string assemblyFileName, string baseDirectory, string itemNamePrefix);
    private static Assembly RegisterAssemblyFromPath(ConfigurationItemFactory factory, string assemblyFileName, string baseDirectory, string itemNamePrefix);
    public sealed virtual void ScanForAutoLoadExtensions(ConfigurationItemFactory factory);
    private static HashSet`1<string> LoadNLogExtensionAssemblies(ConfigurationItemFactory factory, Assembly nlogAssembly, String[] extensionDlls);
    private static void RegisterAppDomainAssemblies(ConfigurationItemFactory factory, Assembly nlogAssembly, HashSet`1<string> alreadyRegistered);
    private static bool IncludeAsHiddenAssembly(string assemblyFullName);
    [IteratorStateMachineAttribute("NLog.Config.AssemblyExtensionLoader/<GetAutoLoadingFileLocations>d__13")]
internal static IEnumerable`1<KeyValuePair`2<string, string>> GetAutoLoadingFileLocations();
    private static String[] GetNLogExtensionFiles(string assemblyLocation);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow extension loading from config", "IL2026")]
[ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
private static Assembly LoadAssemblyFromPath(string assemblyFileName, string baseDirectory);
    private static Assembly LoadAssemblyFromName(string assemblyName);
    private static bool IsAssemblyMatch(AssemblyName expected, AssemblyName actual);
}
internal static class NLog.Config.AssemblyExtensionTypes : object {
    public static void RegisterTypes(ConfigurationItemFactory factory);
}
[ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
public class NLog.Config.AssemblyLoadingEventArgs : CancelEventArgs {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    public Assembly Assembly { get; }
    public AssemblyLoadingEventArgs(Assembly assembly);
    [CompilerGeneratedAttribute]
public Assembly get_Assembly();
}
public class NLog.Config.ConfigSectionHandler : ConfigurationSection {
    private XmlLoggingConfiguration _config;
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual object GetRuntimeObject();
}
[ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
public class NLog.Config.ConfigurationItemCreator : MulticastDelegate {
    public ConfigurationItemCreator(object object, IntPtr method);
    public virtual object Invoke(Type itemType);
    public virtual IAsyncResult BeginInvoke(Type itemType, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class NLog.Config.ConfigurationItemFactory : object {
    private static ConfigurationItemFactory _defaultInstance;
    internal static object SyncRoot;
    private ServiceRepository _serviceRepository;
    [CompilerGeneratedAttribute]
private IAssemblyExtensionLoader <AssemblyLoader>k__BackingField;
    private IFactory[] _allFactories;
    private Factory`2<Target, TargetAttribute> _targets;
    private Factory`2<Filter, FilterAttribute> _filters;
    private LayoutRendererFactory _layoutRenderers;
    private Factory`2<Layout, LayoutAttribute> _layouts;
    private MethodFactory _conditionMethods;
    private Factory`2<LayoutRenderer, AmbientPropertyAttribute> _ambientProperties;
    private Factory`2<TimeSource, TimeSourceAttribute> _timeSources;
    private Dictionary`2<Type, ItemFactory> _itemFactories;
    [CompilerGeneratedAttribute]
private static EventHandler`1<AssemblyLoadingEventArgs> AssemblyLoading;
    [CompilerGeneratedAttribute]
private ConfigurationItemCreator <CreateInstance>k__BackingField;
    internal IAssemblyExtensionLoader AssemblyLoader { get; }
    public static ConfigurationItemFactory Default { get; public set; }
    public IFactory`1<Target> TargetFactory { get; }
    public IFactory`1<Layout> LayoutFactory { get; }
    public IFactory`1<LayoutRenderer> LayoutRendererFactory { get; }
    public IFactory`1<LayoutRenderer> AmbientRendererFactory { get; }
    public IFactory`1<Filter> FilterFactory { get; }
    public IFactory`1<TimeSource> TimeSourceFactory { get; }
    internal MethodFactory ConditionMethodFactory { get; }
    internal ICollection`1<Type> ItemTypes { get; }
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public ConfigurationItemCreator CreateInstance { get; public set; }
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(ext => ext.RegisterTarget<T>()). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public INamedItemFactory`2<Target, Type> Targets { get; }
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(ext => ext.RegisterLayout<T>()). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public INamedItemFactory`2<Layout, Type> Layouts { get; }
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(ext => ext.RegisterLayoutRenderer<T>()). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public INamedItemFactory`2<LayoutRenderer, Type> LayoutRenderers { get; }
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public INamedItemFactory`2<LayoutRenderer, Type> AmbientProperties { get; }
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public INamedItemFactory`2<Filter, Type> Filters { get; }
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public INamedItemFactory`2<TimeSource, Type> TimeSources { get; }
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public INamedItemFactory`2<MethodInfo, MethodInfo> ConditionMethods { get; }
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupSerialization(s => s.RegisterJsonConverter()) or ResolveService<IJsonConverter>(). Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public IJsonConverter JsonConverter { get; public set; }
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupSerialization(s => s.RegisterValueFormatter()) or ResolveService<IValueFormatter>(). Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public IValueFormatter ValueFormatter { get; public set; }
    [ObsoleteAttribute("Instead use LogFactory.ServiceRepository.RegisterService(). Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public IPropertyTypeConverter PropertyTypeConverter { get; public set; }
    public Nullable`1<bool> ParseMessageTemplates { get; public set; }
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public ConfigurationItemFactory(Assembly[] assemblies);
    internal ConfigurationItemFactory(ServiceRepository serviceRepository, ConfigurationItemFactory globalDefaultFactory);
    private static ConfigurationItemFactory();
    [CompilerGeneratedAttribute]
internal IAssemblyExtensionLoader get_AssemblyLoader();
    [CompilerGeneratedAttribute]
public static void add_AssemblyLoading(EventHandler`1<AssemblyLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_AssemblyLoading(EventHandler`1<AssemblyLoadingEventArgs> value);
    public static ConfigurationItemFactory get_Default();
    public static void set_Default(ConfigurationItemFactory value);
    public IFactory`1<Target> get_TargetFactory();
    public IFactory`1<Layout> get_LayoutFactory();
    public IFactory`1<LayoutRenderer> get_LayoutRendererFactory();
    public IFactory`1<LayoutRenderer> get_AmbientRendererFactory();
    public IFactory`1<Filter> get_FilterFactory();
    public IFactory`1<TimeSource> get_TimeSourceFactory();
    internal MethodFactory get_ConditionMethodFactory();
    internal Factory`2<Target, TargetAttribute> GetTargetFactory();
    internal Factory`2<Layout, LayoutAttribute> GetLayoutFactory();
    internal LayoutRendererFactory GetLayoutRendererFactory();
    internal ICollection`1<Type> get_ItemTypes();
    [CompilerGeneratedAttribute]
public ConfigurationItemCreator get_CreateInstance();
    [CompilerGeneratedAttribute]
public void set_CreateInstance(ConfigurationItemCreator value);
    public INamedItemFactory`2<Target, Type> get_Targets();
    public INamedItemFactory`2<Layout, Type> get_Layouts();
    public INamedItemFactory`2<LayoutRenderer, Type> get_LayoutRenderers();
    public INamedItemFactory`2<LayoutRenderer, Type> get_AmbientProperties();
    public INamedItemFactory`2<Filter, Type> get_Filters();
    public INamedItemFactory`2<TimeSource, Type> get_TimeSources();
    public INamedItemFactory`2<MethodInfo, MethodInfo> get_ConditionMethods();
    public IJsonConverter get_JsonConverter();
    public void set_JsonConverter(IJsonConverter value);
    public IValueFormatter get_ValueFormatter();
    public void set_ValueFormatter(IValueFormatter value);
    public IPropertyTypeConverter get_PropertyTypeConverter();
    public void set_PropertyTypeConverter(IPropertyTypeConverter value);
    public Nullable`1<bool> get_ParseMessageTemplates();
    public void set_ParseMessageTemplates(Nullable`1<bool> value);
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public void RegisterItemsFromAssembly(Assembly assembly);
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public void RegisterItemsFromAssembly(Assembly assembly, string itemNamePrefix);
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2072")]
[EditorBrowsableAttribute("1")]
public void PreloadAssembly(Type[] typesToScan);
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
private void CallPreload(Type type);
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
private static Object[] CreatePreloadParameters(MethodInfo preloadMethod, ConfigurationItemFactory configurationItemFactory);
    public void Clear();
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public void RegisterType(Type type, string itemNamePrefix);
    internal void RegisterType();
    internal void RegisterTypeProperties(Func`1<object> itemCreator);
    internal void RegisterTypeProperties(Type itemType, Func`1<object> itemCreator);
    internal Dictionary`2<string, PropertyInfo> TryGetTypeProperties(Type itemType);
    [UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2067")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2070")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2072")]
[ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
private Dictionary`2<string, PropertyInfo> ResolveTypePropertiesLegacy(Type itemType);
    internal bool TryCreateInstance(Type itemType, Object& instance);
    [UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2067")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2070")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2072")]
[ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
private object ResolveCreateInstanceLegacy(Type itemType);
    private static ConfigurationItemFactory BuildDefaultFactory();
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
private void RegisterExternalItems();
}
[AttributeUsageAttribute("128")]
[MeansImplicitUseAttribute]
public class NLog.Config.DefaultParameterAttribute : Attribute {
}
internal class NLog.Config.DynamicLogLevelFilter : object {
    private LoggingRule _loggingRule;
    private SimpleLayout _levelFilter;
    private SimpleLayout _finalMinLevelFilter;
    private KeyValuePair`2<string, Boolean[]> _activeFilter;
    public Boolean[] LogLevels { get; }
    public LogLevel FinalMinLevel { get; }
    public DynamicLogLevelFilter(LoggingRule loggingRule, SimpleLayout levelFilter, SimpleLayout finalMinLevelFilter);
    public sealed virtual Boolean[] get_LogLevels();
    public sealed virtual LogLevel get_FinalMinLevel();
    public sealed virtual LoggingRuleLevelFilter GetSimpleFilterForUpdate();
    private Boolean[] GenerateLogLevels();
    private LogLevel GenerateFinalMinLevel();
    private Boolean[] ParseSingleLevel(string levelFilter);
    private LogLevel ParseLogLevel(string logLevel, LogLevel levelIfEmpty);
    private Boolean[] ParseLevels(string levelFilter);
}
internal class NLog.Config.DynamicRangeLevelFilter : object {
    private LoggingRule _loggingRule;
    private SimpleLayout _minLevel;
    private SimpleLayout _maxLevel;
    private SimpleLayout _finalMinLevelFilter;
    private KeyValuePair`2<MinMaxLevels, Boolean[]> _activeFilter;
    public Boolean[] LogLevels { get; }
    public LogLevel FinalMinLevel { get; }
    public DynamicRangeLevelFilter(LoggingRule loggingRule, SimpleLayout minLevel, SimpleLayout maxLevel, SimpleLayout finalMinLevelFilter);
    public sealed virtual Boolean[] get_LogLevels();
    public sealed virtual LogLevel get_FinalMinLevel();
    public sealed virtual LoggingRuleLevelFilter GetSimpleFilterForUpdate();
    private Boolean[] GenerateLogLevels();
    private LogLevel GenerateFinalMinLevel();
    private Boolean[] ParseLevelRange(string minLevelFilter, string maxLevelFilter);
    private LogLevel ParseLogLevel(string logLevel, LogLevel levelIfEmpty);
}
public enum NLog.Config.ExceptionRenderingFormat : Enum {
    public int value__;
    public static ExceptionRenderingFormat Message;
    public static ExceptionRenderingFormat Type;
    public static ExceptionRenderingFormat ShortType;
    public static ExceptionRenderingFormat ToString;
    public static ExceptionRenderingFormat Method;
    public static ExceptionRenderingFormat StackTrace;
    public static ExceptionRenderingFormat Data;
    public static ExceptionRenderingFormat Serialize;
    public static ExceptionRenderingFormat Source;
    public static ExceptionRenderingFormat HResult;
    public static ExceptionRenderingFormat Properties;
}
internal class NLog.Config.Factory`2 : object {
    private Dictionary`2<string, ItemFactory<TBaseType, TAttributeType>> _items;
    private ConfigurationItemFactory _parentFactory;
    private Factory`2<TBaseType, TAttributeType> _globalDefaultFactory;
    internal Factory`2(ConfigurationItemFactory parentFactory, Factory`2<TBaseType, TAttributeType> globalDefaultFactory);
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2072")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2062")]
public sealed virtual void ScanTypes(Type[] types, string assemblyName, string itemNamePrefix);
    public sealed virtual void RegisterType(Type type, string itemNamePrefix);
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2072")]
public void RegisterNamedType(string itemName, string typeName);
    public virtual void Clear();
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2067")]
private sealed virtual override void NLog.Config.INamedItemFactory<TBaseType,System.Type>.RegisterDefinition(string itemName, Type itemDefinition);
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
public void RegisterDefinition(string typeAlias, Type itemType);
    private void RegisterDefinition(Type itemType, string typeAlias, string itemNamePrefix);
    public sealed virtual void RegisterType(string typeAlias);
    public void RegisterType(string typeAlias, Func`1<TType> itemCreator);
    [ObsoleteAttribute("Use TryCreateInstance instead. Marked obsolete with NLog v5.2")]
public sealed virtual bool TryGetDefinition(string itemName, Type& result);
    private bool TryGetItemFactory(string typeAlias, ItemFactory& itemFactory);
    private sealed virtual override bool NLog.Config.INamedItemFactory<TBaseType,System.Type>.TryCreateInstance(string itemName, TBaseType& result);
    public virtual bool TryCreateInstance(string typeAlias, TBaseType& result);
    [ObsoleteAttribute("Use TryCreateInstance instead. Marked obsolete with NLog v5.2")]
private bool TryCreateInstanceLegacy(string itemName, TBaseType& result);
    [ObsoleteAttribute("Use TryCreateInstance instead. Marked obsolete with NLog v5.2")]
private sealed virtual override TBaseType NLog.Config.INamedItemFactory<TBaseType,System.Type>.CreateInstance(string itemName);
}
[ExtensionAttribute]
internal static class NLog.Config.FactoryExtensions : object {
    [ExtensionAttribute]
public static TBaseType CreateInstance(IFactory`1<TBaseType> factory, string typeAlias);
    public static string NormalizeName(string itemName);
}
internal interface NLog.Config.IAssemblyExtensionLoader {
    public abstract virtual void ScanForAutoLoadExtensions(ConfigurationItemFactory factory);
    public abstract virtual void LoadAssemblyFromPath(ConfigurationItemFactory factory, string assemblyFileName, string baseDirectory, string itemNamePrefix);
    public abstract virtual void LoadAssemblyFromName(ConfigurationItemFactory factory, string assemblyName, string itemNamePrefix);
    public abstract virtual void LoadTypeFromName(ConfigurationItemFactory factory, string typeName, string itemNamePrefix);
}
internal interface NLog.Config.IFactory {
    public abstract virtual void Clear();
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
public abstract virtual void ScanTypes(Type[] types, string assemblyName, string itemNamePrefix);
    public abstract virtual void RegisterType(Type type, string itemNamePrefix);
}
public interface NLog.Config.IFactory`1 {
    public abstract virtual void RegisterType(string typeAlias);
    public abstract virtual bool TryCreateInstance(string typeAlias, TBaseType& result);
}
internal interface NLog.Config.IIncludeContext {
    public bool IncludeEventProperties { get; public set; }
    public bool IncludeScopeProperties { get; public set; }
    public bool IncludeScopeNested { get; public set; }
    public abstract virtual bool get_IncludeEventProperties();
    public abstract virtual void set_IncludeEventProperties(bool value);
    public abstract virtual bool get_IncludeScopeProperties();
    public abstract virtual void set_IncludeScopeProperties(bool value);
    public abstract virtual bool get_IncludeScopeNested();
    public abstract virtual void set_IncludeScopeNested(bool value);
}
internal interface NLog.Config.IInitializeSucceeded {
    public Nullable`1<bool> InitializeSucceeded { get; }
    public abstract virtual Nullable`1<bool> get_InitializeSucceeded();
}
public interface NLog.Config.IInstallable {
    public abstract virtual void Install(InstallationContext installationContext);
    public abstract virtual void Uninstall(InstallationContext installationContext);
    public abstract virtual Nullable`1<bool> IsInstalled(InstallationContext installationContext);
}
public interface NLog.Config.ILoggingConfigurationElement {
    public string Name { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> Values { get; }
    public IEnumerable`1<ILoggingConfigurationElement> Children { get; }
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_Values();
    public abstract virtual IEnumerable`1<ILoggingConfigurationElement> get_Children();
}
internal interface NLog.Config.ILoggingConfigurationLoader {
    public abstract virtual LoggingConfiguration Load(LogFactory logFactory, string filename);
    public abstract virtual void Activated(LogFactory logFactory, LoggingConfiguration config);
    public abstract virtual IEnumerable`1<string> GetDefaultCandidateConfigFilePaths(string filename);
}
internal interface NLog.Config.ILoggingRuleLevelFilter {
    public Boolean[] LogLevels { get; }
    public LogLevel FinalMinLevel { get; }
    public abstract virtual Boolean[] get_LogLevels();
    public abstract virtual LogLevel get_FinalMinLevel();
    public abstract virtual LoggingRuleLevelFilter GetSimpleFilterForUpdate();
}
[ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public interface NLog.Config.INamedItemFactory`2 {
    public abstract virtual void RegisterDefinition(string itemName, TDefinitionType itemDefinition);
    public abstract virtual bool TryGetDefinition(string itemName, TDefinitionType& result);
    public abstract virtual TInstanceType CreateInstance(string itemName);
    public abstract virtual bool TryCreateInstance(string itemName, TInstanceType& result);
}
public class NLog.Config.InstallationContext : object {
    private static Dictionary`2<LogLevel, ConsoleColor> LogLevel2ConsoleColor;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <LogOutput>k__BackingField;
    public LogLevel LogLevel { get; public set; }
    public bool IgnoreFailures { get; public set; }
    public bool ThrowExceptions { get; public set; }
    public IDictionary`2<string, string> Parameters { get; private set; }
    public TextWriter LogOutput { get; public set; }
    public InstallationContext(TextWriter logOutput);
    private static InstallationContext();
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreFailures();
    [CompilerGeneratedAttribute]
public void set_IgnoreFailures(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptions();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptions(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public TextWriter get_LogOutput();
    [CompilerGeneratedAttribute]
public void set_LogOutput(TextWriter value);
    public void Trace(string message, Object[] arguments);
    public void Debug(string message, Object[] arguments);
    public void Info(string message, Object[] arguments);
    public void Warning(string message, Object[] arguments);
    public void Error(string message, Object[] arguments);
    public sealed virtual void Dispose();
    public LogEventInfo CreateLogEvent();
    private void Log(LogLevel logLevel, string message, Object[] arguments);
}
public interface NLog.Config.IPropertyTypeConverter {
    public abstract virtual object Convert(object propertyValue, Type propertyType, string format, IFormatProvider formatProvider);
}
public interface NLog.Config.ISetupBuilder {
    public LogFactory LogFactory { get; }
    public abstract virtual LogFactory get_LogFactory();
}
public interface NLog.Config.ISetupConfigurationLoggingRuleBuilder {
    public LoggingRule LoggingRule { get; }
    public abstract virtual LoggingRule get_LoggingRule();
}
public interface NLog.Config.ISetupConfigurationTargetBuilder {
    public LoggingConfiguration Configuration { get; }
    public LogFactory LogFactory { get; }
    public IList`1<Target> Targets { get; }
    public abstract virtual LoggingConfiguration get_Configuration();
    public abstract virtual LogFactory get_LogFactory();
    public abstract virtual IList`1<Target> get_Targets();
}
public interface NLog.Config.ISetupExtensionsBuilder {
    public LogFactory LogFactory { get; }
    public abstract virtual LogFactory get_LogFactory();
}
public interface NLog.Config.ISetupInternalLoggerBuilder {
    public LogFactory LogFactory { get; }
    public abstract virtual LogFactory get_LogFactory();
}
public interface NLog.Config.ISetupLoadConfigurationBuilder {
    public LogFactory LogFactory { get; }
    public LoggingConfiguration Configuration { get; public set; }
    public abstract virtual LogFactory get_LogFactory();
    public abstract virtual LoggingConfiguration get_Configuration();
    public abstract virtual void set_Configuration(LoggingConfiguration value);
}
public interface NLog.Config.ISetupLogFactoryBuilder {
    public LogFactory LogFactory { get; }
    public abstract virtual LogFactory get_LogFactory();
}
public interface NLog.Config.ISetupSerializationBuilder {
    public LogFactory LogFactory { get; }
    public abstract virtual LogFactory get_LogFactory();
}
public interface NLog.Config.IUsesStackTrace {
    public StackTraceUsage StackTraceUsage { get; }
    public abstract virtual StackTraceUsage get_StackTraceUsage();
}
internal class NLog.Config.LayoutRendererFactory : Factory`2<LayoutRenderer, LayoutRendererAttribute> {
    private Dictionary`2<string, FuncLayoutRenderer> _funcRenderers;
    private LayoutRendererFactory _globalDefaultFactory;
    public LayoutRendererFactory(ConfigurationItemFactory parentFactory, LayoutRendererFactory globalDefaultFactory);
    public virtual void Clear();
    public void RegisterFuncLayout(string itemName, FuncLayoutRenderer renderer);
    public virtual bool TryCreateInstance(string typeAlias, LayoutRenderer& result);
}
internal abstract class NLog.Config.LoggerNameMatcher : object {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    protected string _matchingArgument;
    private string _toString;
    public string Pattern { get; }
    protected string MatchMode { get; }
    protected LoggerNameMatcher(string pattern, string matchingArgument);
    public static LoggerNameMatcher Create(string loggerNamePattern);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    public virtual string ToString();
    protected abstract virtual string get_MatchMode();
    public abstract virtual bool NameMatches(string loggerName);
}
public class NLog.Config.LoggingConfiguration : object {
    private IDictionary`2<string, Target> _targets;
    private List`1<object> _configItems;
    private bool _missingServiceTypes;
    private ConfigVariablesDictionary _variables;
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LoggingRule> <LoggingRules>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <DefaultCultureInfo>k__BackingField;
    public LogFactory LogFactory { get; }
    public IDictionary`2<string, Layout> Variables { get; }
    public ReadOnlyCollection`1<Target> ConfiguredNamedTargets { get; }
    public IEnumerable`1<string> FileNamesToWatch { get; }
    public IList`1<LoggingRule> LoggingRules { get; }
    [CanBeNullAttribute]
public CultureInfo DefaultCultureInfo { get; public set; }
    public ReadOnlyCollection`1<Target> AllTargets { get; }
    public LoggingConfiguration(LogFactory logFactory);
    [CompilerGeneratedAttribute]
public LogFactory get_LogFactory();
    public IDictionary`2<string, Layout> get_Variables();
    public ReadOnlyCollection`1<Target> get_ConfiguredNamedTargets();
    public virtual IEnumerable`1<string> get_FileNamesToWatch();
    [CompilerGeneratedAttribute]
public IList`1<LoggingRule> get_LoggingRules();
    internal List`1<LoggingRule> GetLoggingRulesThreadSafe();
    private void AddLoggingRulesThreadSafe(LoggingRule rule);
    private bool TryGetTargetThreadSafe(string name, Target& target);
    private List`1<Target> GetAllTargetsThreadSafe();
    private Target RemoveTargetThreadSafe(string name);
    private void AddTargetThreadSafe(Target target, string targetAlias);
    [CompilerGeneratedAttribute]
public CultureInfo get_DefaultCultureInfo();
    [CompilerGeneratedAttribute]
public void set_DefaultCultureInfo(CultureInfo value);
    public ReadOnlyCollection`1<Target> get_AllTargets();
    internal void InsertParsedConfigVariable(string key, Layout value);
    internal bool TryLookupDynamicVariable(string key, Layout& value);
    public void AddTarget(Target target);
    public void AddTarget(string name, Target target);
    public Target FindTargetByName(string name);
    public TTarget FindTargetByName(string name);
    public void AddRule(LogLevel minLevel, LogLevel maxLevel, string targetName, string loggerNamePattern);
    public void AddRule(LogLevel minLevel, LogLevel maxLevel, Target target, string loggerNamePattern);
    public void AddRule(LogLevel minLevel, LogLevel maxLevel, Target target, string loggerNamePattern, bool final);
    public void AddRule(LoggingRule rule);
    public void AddRuleForOneLevel(LogLevel level, string targetName, string loggerNamePattern);
    public void AddRuleForOneLevel(LogLevel level, Target target, string loggerNamePattern);
    public void AddRuleForOneLevel(LogLevel level, Target target, string loggerNamePattern, bool final);
    public void AddRuleForAllLevels(string targetName, string loggerNamePattern);
    public void AddRuleForAllLevels(Target target, string loggerNamePattern);
    public void AddRuleForAllLevels(Target target, string loggerNamePattern, bool final);
    public LoggingRule FindRuleByName(string ruleName);
    public bool RemoveRuleByName(string ruleName);
    public virtual LoggingConfiguration Reload();
    protected void PrepareForReload(LoggingConfiguration oldConfig);
    protected internal virtual void OnConfigurationAssigned(LogFactory logFactory);
    public void RemoveTarget(string name);
    private void CleanupRulesForRemovedTarget(string name, Target removedTarget, HashSet`1<Target> removedTargets);
    public void Install(InstallationContext installationContext);
    public void Uninstall(InstallationContext installationContext);
    internal void Close();
    internal void Dump();
    internal HashSet`1<Target> GetAllTargetsToFlush();
    internal void ValidateConfig();
    internal void InitializeAll();
    internal void CheckForMissingServiceTypes(Type serviceType);
    private static bool IsMissingServiceType(NLogDependencyResolveException resolveException, Type serviceType);
    private List`1<IInstallable> GetInstallableItems();
    private List`1<ISupportsInitialize> GetSupportsInitializes(bool reverse);
    [NotNullAttribute]
internal string ExpandSimpleVariables(string input);
    [NotNullAttribute]
internal string ExpandSimpleVariables(string input, String& matchingVariableName);
    internal void CheckUnusedTargets();
    internal bool FlushAllTargets(TimeSpan timeout, AsyncContinuation asyncContinuation, bool throwExceptions);
    private static AsyncContinuation FlushAllTargetsAsync(LoggingConfiguration loggingConfiguration, AsyncContinuation asyncContinuation, Nullable`1<TimeSpan> asyncTimeout);
    private static bool FlushAllTargetsSync(LoggingConfiguration oldConfig, TimeSpan timeout, bool throwExceptions);
    internal TargetWithFilterChain[] BuildLoggerConfiguration(string loggerName, LogLevel globalLogLevel, List`1<LoggingRule> loggingRules);
    private static bool DumpTargetConfigurationForLogger(string loggerName, TargetWithFilterChain[] targetsByLevel);
    public virtual string ToString();
}
public class NLog.Config.LoggingConfigurationChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private LoggingConfiguration <DeactivatedConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <ActivatedConfiguration>k__BackingField;
    public LoggingConfiguration DeactivatedConfiguration { get; }
    public LoggingConfiguration ActivatedConfiguration { get; }
    public LoggingConfigurationChangedEventArgs(LoggingConfiguration activatedConfiguration, LoggingConfiguration deactivatedConfiguration);
    [CompilerGeneratedAttribute]
public LoggingConfiguration get_DeactivatedConfiguration();
    [CompilerGeneratedAttribute]
public LoggingConfiguration get_ActivatedConfiguration();
}
[ExtensionAttribute]
internal static class NLog.Config.LoggingConfigurationElementExtensions : object {
    [ExtensionAttribute]
public static bool MatchesName(ILoggingConfigurationElement section, string expectedName);
    [ExtensionAttribute]
public static void AssertName(ILoggingConfigurationElement section, String[] allowedNames);
    [ExtensionAttribute]
public static string GetRequiredValue(ILoggingConfigurationElement element, string attributeName, string section);
    [ExtensionAttribute]
public static string GetOptionalValue(ILoggingConfigurationElement element, string attributeName, string defaultValue);
    [ExtensionAttribute]
public static bool GetOptionalBooleanValue(ILoggingConfigurationElement element, string attributeName, bool defaultValue);
    [ExtensionAttribute]
public static string GetConfigItemTypeAttribute(ILoggingConfigurationElement element, string sectionNameForRequiredValue);
    private static string StripOptionalNamespacePrefix(string attributeValue);
}
internal class NLog.Config.LoggingConfigurationFileLoader : object {
    private IAppEnvironment _appEnvironment;
    public LoggingConfigurationFileLoader(IAppEnvironment appEnvironment);
    public virtual LoggingConfiguration Load(LogFactory logFactory, string filename);
    public virtual void Activated(LogFactory logFactory, LoggingConfiguration config);
    private LoggingConfiguration TryLoadFromFilePaths(LogFactory logFactory, string filename);
    private bool TryLoadLoggingConfiguration(LogFactory logFactory, string configFile, LoggingConfiguration& config);
    private LoggingConfiguration LoadXmlLoggingConfigurationFile(LogFactory logFactory, string configFile);
    private LoggingConfiguration LoadXmlLoggingConfiguration(XmlReader xmlReader, string configFile, LogFactory logFactory);
    private static LoggingConfiguration CreateEmptyDefaultConfig(string configFile, LogFactory logFactory, bool autoReload);
    private bool ThrowXmlConfigExceptions(string configFile, XmlReader xmlReader, LogFactory logFactory, Boolean& autoReload);
    private static bool ScanForBooleanParameter(string fileContent, string parameterName, bool parameterValue);
    [IteratorStateMachineAttribute("NLog.Config.LoggingConfigurationFileLoader/<GetDefaultCandidateConfigFilePaths>d__11")]
public sealed virtual IEnumerable`1<string> GetDefaultCandidateConfigFilePaths(string filename);
    private static string LookupNLogAssemblyLocation();
    [IteratorStateMachineAttribute("NLog.Config.LoggingConfigurationFileLoader/<GetAppSpecificNLogLocations>d__13")]
public IEnumerable`1<string> GetAppSpecificNLogLocations(string baseDirectory, string entryAssemblyLocation);
    [IteratorStateMachineAttribute("NLog.Config.LoggingConfigurationFileLoader/<GetPrivateBinPathNLogLocations>d__14")]
private IEnumerable`1<string> GetPrivateBinPathNLogLocations(string baseDirectory, string nlogConfigFile, string nLogConfigFileLowerCase);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public abstract class NLog.Config.LoggingConfigurationParser : LoggingConfiguration {
    private ServiceRepository _serviceRepository;
    protected LoggingConfigurationParser(LogFactory logFactory);
    protected void LoadConfig(ILoggingConfigurationElement nlogConfig, string basePath);
    private void SetNLogElementSettings(ILoggingConfigurationElement nlogConfig);
    private ICollection`1<KeyValuePair`2<string, string>> CreateUniqueSortedListFromConfig(ILoggingConfigurationElement nlogConfig);
    private LogLevel ParseLogLevelSafe(string propertyName, string propertyValue, LogLevel fallbackValue);
    protected virtual bool ParseNLogSection(ILoggingConfigurationElement configSection);
    private void ParseExtensionsElement(ValidatedConfigurationElement extensionsElement, string baseDirectory);
    private void RegisterExtension(string typeName, string itemNamePrefix);
    private void ParseExtensionWithAssemblyFile(string baseDirectory, string assemblyFile, string prefix);
    private bool RegisterExtensionFromAssemblyName(string assemblyName, string originalTypeName);
    private bool ParseExtensionWithAssemblyName(string assemblyName, string prefix);
    private void ParseVariableElement(ValidatedConfigurationElement variableElement);
    private Layout ParseVariableLayoutValue(ValidatedConfigurationElement variableElement);
    private void ParseVariablesElement(ValidatedConfigurationElement variableElement);
    private void ParseTimeElement(ValidatedConfigurationElement timeElement);
    [ContractAnnotationAttribute("value:notnull => true")]
private bool AssertNotNullValue(object value, string propertyName, string elementName, string sectionName);
    [ContractAnnotationAttribute("value:null => false")]
private bool AssertNonEmptyValue(string value, string propertyName, string elementName, string sectionName);
    private void ParseRulesElement(ValidatedConfigurationElement rulesElement, IList`1<LoggingRule> rulesCollection);
    private LogLevel LogLevelFromString(string text);
    private LoggingRule ParseRuleElement(ValidatedConfigurationElement loggerElement);
    private void EnableLevelsForRule(LoggingRule rule, string enableLevels, string minLevel, string maxLevel, string finalMinLevel);
    private static bool IsLevelLayout(string level);
    private SimpleLayout ParseLevelLayout(string levelLayout);
    private void ParseLoggingRuleTargets(string writeTargets, LoggingRule rule);
    [ObsoleteAttribute("Very exotic feature without any unit-tests, not sure if it works. Marked obsolete with NLog v5.3")]
private void ParseLoggingRuleChildren(ValidatedConfigurationElement loggerElement, LoggingRule rule, string filterDefaultAction);
    private void ParseLoggingRuleFilters(LoggingRule rule, ValidatedConfigurationElement filtersElement, string filterDefaultAction);
    private void ValidateLoggingRuleFilters(LoggingRule rule);
    private void ParseTargetsElement(ValidatedConfigurationElement targetsElement);
    private static Dictionary`2<string, ValidatedConfigurationElement> RegisterNewTargetDefaultParameters(Dictionary`2<string, ValidatedConfigurationElement> typeNameToDefaultTargetParameters, ValidatedConfigurationElement targetElement, string targetTypeName);
    private void AddNewTargetFromConfig(string targetTypeName, ValidatedConfigurationElement targetElement, bool asyncWrap, Dictionary`2<string, ValidatedConfigurationElement> typeNameToDefaultTargetParameters, ValidatedConfigurationElement defaultWrapperElement);
    private Target CreateTargetType(string targetTypeName);
    private void ParseTargetElement(Target target, ValidatedConfigurationElement targetElement, Dictionary`2<string, ValidatedConfigurationElement> typeNameToDefaultTargetParameters);
    private bool ParseTargetWrapper(WrapperTargetBase wrapper, ValidatedConfigurationElement childElement, Dictionary`2<string, ValidatedConfigurationElement> typeNameToDefaultTargetParameters);
    private bool ParseCompoundTarget(CompoundTargetBase compound, ValidatedConfigurationElement childElement, Dictionary`2<string, ValidatedConfigurationElement> typeNameToDefaultTargetParameters, string targetName);
    private void ConfigureObjectFromAttributes(T targetObject, ValidatedConfigurationElement element, bool ignoreType);
    private void SetPropertyValueFromString(T targetObject, string propertyName, string propertyValue, ValidatedConfigurationElement element);
    private void SetPropertyValuesFromElement(T targetObject, ValidatedConfigurationElement childElement, ILoggingConfigurationElement parentElement);
    private bool AddArrayItemFromElement(object o, PropertyInfo propInfo, ValidatedConfigurationElement element);
    private object ParseArrayItemFromElement(Type elementType, ValidatedConfigurationElement element);
    private bool SetLayoutFromElement(object o, PropertyInfo propInfo, ValidatedConfigurationElement element);
    private bool SetFilterFromElement(object o, PropertyInfo propInfo, ValidatedConfigurationElement element);
    private SimpleLayout CreateSimpleLayout(string layoutText);
    private Layout TryCreateLayoutInstance(ValidatedConfigurationElement element, Type type);
    private Filter TryCreateFilterInstance(ValidatedConfigurationElement element, Type type);
    private T TryCreateInstance(ValidatedConfigurationElement element, Type type, IFactory`1<T> factory);
    private T FactoryCreateInstance(string typeName, IFactory`1<T> factory);
    private void ConfigureFromAttributesAndElements(T targetObject, ValidatedConfigurationElement element);
    private static Target WrapWithAsyncTargetWrapper(Target target);
    private Target WrapWithDefaultWrapper(Target target, ValidatedConfigurationElement defaultWrapperElement);
    private bool ParseBooleanValue(string propertyName, string value, bool defaultValue);
    private Nullable`1<bool> ParseNullableBooleanValue(string propertyName, string value, bool defaultValue);
    private bool MustThrowConfigException(NLogConfigurationException configException);
    private static bool MatchesName(string key, string expectedKey);
    private static bool IsTargetElement(string name);
    private static bool IsTargetRefElement(string name);
    private static string GetName(Target target);
}
[ObsoleteAttribute("Replaced by ConfigurationChanged, but check args.ActivatedConfiguration != null. Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public class NLog.Config.LoggingConfigurationReloadedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public bool Succeeded { get; }
    public Exception Exception { get; }
    public LoggingConfigurationReloadedEventArgs(bool succeeded);
    public LoggingConfigurationReloadedEventArgs(bool succeeded, Exception exception);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
internal class NLog.Config.LoggingConfigurationWatchableFileLoader : LoggingConfigurationFileLoader {
    private static int ReconfigAfterFileChangedTimeout;
    private object _lockObject;
    private Timer _reloadTimer;
    private MultiFileWatcher _watcher;
    private bool _isDisposing;
    private LogFactory _logFactory;
    public LoggingConfigurationWatchableFileLoader(IAppEnvironment appEnvironment);
    public virtual LoggingConfiguration Load(LogFactory logFactory, string filename);
    public virtual void Activated(LogFactory logFactory, LoggingConfiguration config);
    protected virtual void Dispose(bool disposing);
    private LoggingConfiguration TryLoadFromAppConfig();
    internal void ReloadConfigOnTimer(object state);
    private void ConfigFileChanged(object sender, EventArgs args);
    private void TryWachtingConfigFile(LoggingConfiguration config);
    private void TryUnwatchConfigFile();
}
[NLogConfigurationItemAttribute]
public class NLog.Config.LoggingRule : object {
    private ILoggingRuleLevelFilter _logLevelFilter;
    private LoggerNameMatcher _loggerNameMatcher;
    private List`1<Target> _targets;
    [CompilerGeneratedAttribute]
private string <RuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LoggingRule> <ChildRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Filter> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Final>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterResult <FilterDefaultAction>k__BackingField;
    public string RuleName { get; public set; }
    public IList`1<Target> Targets { get; }
    [ObsoleteAttribute("Very exotic feature without any unit-tests, not sure if it works. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public IList`1<LoggingRule> ChildRules { get; }
    public IList`1<Filter> Filters { get; }
    public bool Final { get; public set; }
    public LogLevel FinalMinLevel { get; public set; }
    public string LoggerNamePattern { get; public set; }
    internal Boolean[] LogLevels { get; }
    [NLogConfigurationIgnorePropertyAttribute]
public ReadOnlyCollection`1<LogLevel> Levels { get; }
    [ObsoleteAttribute("Replaced by FilterDefaultAction. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public FilterResult DefaultFilterResult { get; public set; }
    public FilterResult FilterDefaultAction { get; public set; }
    public LoggingRule(string ruleName);
    public LoggingRule(string loggerNamePattern, LogLevel minLevel, LogLevel maxLevel, Target target);
    public LoggingRule(string loggerNamePattern, LogLevel minLevel, Target target);
    public LoggingRule(string loggerNamePattern, Target target);
    [CompilerGeneratedAttribute]
public string get_RuleName();
    [CompilerGeneratedAttribute]
public void set_RuleName(string value);
    public IList`1<Target> get_Targets();
    [CompilerGeneratedAttribute]
public IList`1<LoggingRule> get_ChildRules();
    [ObsoleteAttribute("Very exotic feature without any unit-tests, not sure if it works. Marked obsolete with NLog v5.3")]
internal List`1<LoggingRule> GetChildRulesThreadSafe();
    internal Target[] GetTargetsThreadSafe();
    internal bool RemoveTargetThreadSafe(Target target);
    [CompilerGeneratedAttribute]
public IList`1<Filter> get_Filters();
    [CompilerGeneratedAttribute]
public bool get_Final();
    [CompilerGeneratedAttribute]
public void set_Final(bool value);
    public LogLevel get_FinalMinLevel();
    public void set_FinalMinLevel(LogLevel value);
    public string get_LoggerNamePattern();
    public void set_LoggerNamePattern(string value);
    internal Boolean[] get_LogLevels();
    public ReadOnlyCollection`1<LogLevel> get_Levels();
    public FilterResult get_DefaultFilterResult();
    public void set_DefaultFilterResult(FilterResult value);
    [CompilerGeneratedAttribute]
public FilterResult get_FilterDefaultAction();
    [CompilerGeneratedAttribute]
public void set_FilterDefaultAction(FilterResult value);
    public void EnableLoggingForLevel(LogLevel level);
    public void EnableLoggingForLevels(LogLevel minLevel, LogLevel maxLevel);
    internal void EnableLoggingForLevelLayout(SimpleLayout simpleLayout, SimpleLayout finalMinLevel);
    internal void EnableLoggingForLevelsLayout(SimpleLayout minLevel, SimpleLayout maxLevel, SimpleLayout finalMinLevel);
    public void DisableLoggingForLevel(LogLevel level);
    public void DisableLoggingForLevels(LogLevel minLevel, LogLevel maxLevel);
    public void SetLoggingLevels(LogLevel minLevel, LogLevel maxLevel);
    public virtual string ToString();
    public bool IsLoggingEnabledForLevel(LogLevel level);
    public bool NameMatches(string loggerName);
}
internal class NLog.Config.LoggingRuleLevelFilter : object {
    public static ILoggingRuleLevelFilter Off;
    [CompilerGeneratedAttribute]
private Boolean[] <LogLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <FinalMinLevel>k__BackingField;
    public Boolean[] LogLevels { get; }
    public LogLevel FinalMinLevel { get; private set; }
    public LoggingRuleLevelFilter(Boolean[] logLevels, LogLevel finalMinLevel);
    private static LoggingRuleLevelFilter();
    [CompilerGeneratedAttribute]
public sealed virtual Boolean[] get_LogLevels();
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_FinalMinLevel();
    [CompilerGeneratedAttribute]
private void set_FinalMinLevel(LogLevel value);
    public sealed virtual LoggingRuleLevelFilter GetSimpleFilterForUpdate();
    public LoggingRuleLevelFilter SetLoggingLevels(LogLevel minLevel, LogLevel maxLevel, bool enable);
    public LoggingRuleLevelFilter SetFinalMinLevel(LogLevel finalMinLevel);
}
internal class NLog.Config.MethodFactory : object {
    private MethodFactory _globalDefaultFactory;
    private Dictionary`2<string, MethodDetails> _nameToMethodDetails;
    public MethodFactory(MethodFactory globalDefaultFactory);
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2072")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2062")]
public sealed virtual void ScanTypes(Type[] types, string assemblyName, string itemNamePrefix);
    private sealed virtual override void NLog.Config.IFactory.RegisterType(Type type, string itemNamePrefix);
    private void RegisterType(Type type, string itemNamePrefix);
    private static IList`1<KeyValuePair`2<string, MethodInfo>> ExtractClassMethods(Type type);
    public sealed virtual void Clear();
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
private sealed virtual override void NLog.Config.INamedItemFactory<System.Reflection.MethodInfo,System.Reflection.MethodInfo>.RegisterDefinition(string itemName, MethodInfo itemDefinition);
    internal void RegisterDefinition(string methodName, MethodInfo methodInfo);
    private static object InvokeMethodInfo(MethodInfo methodInfo, Object[] methodArgs);
    private static Object[] ResolveDefaultMethodParameters(MethodInfo methodInfo, Int32& manyParameterMinCount, Int32& manyParameterMaxCount, Boolean& includeLogEvent);
    private static Object[] ResolveMethodParameters(Object[] defaultMethodParameters, Object[] inputParameters);
    private static Object[] ResolveMethodParameters(Object[] defaultMethodParameters, object inputParameterArg1);
    private static Object[] ResolveMethodParameters(Object[] defaultMethodParameters, object inputParameterArg1, object inputParameterArg2);
    private static Object[] ResolveMethodParameters(Object[] defaultMethodParameters, object inputParameterArg1, object inputParameterArg2, object inputParameterArg3);
    private static Object[] ResolveMethodParameters(Object[] defaultMethodParameters, object inputParameterArg1, object inputParameterArg2, object inputParameterArg3, object inputParameterArg4);
    [ObsoleteAttribute("Use TryCreateInstance instead. Marked obsolete with NLog v5.2")]
private sealed virtual override bool NLog.Config.INamedItemFactory<System.Reflection.MethodInfo,System.Reflection.MethodInfo>.TryCreateInstance(string itemName, MethodInfo& result);
    [ObsoleteAttribute("Use TryCreateInstance instead. Marked obsolete with NLog v5.2")]
private sealed virtual override MethodInfo NLog.Config.INamedItemFactory<System.Reflection.MethodInfo,System.Reflection.MethodInfo>.CreateInstance(string itemName);
    [ObsoleteAttribute("Use TryCreateInstance instead. Marked obsolete with NLog v5.2")]
public sealed virtual bool TryGetDefinition(string itemName, MethodInfo& result);
    public void RegisterNoParameters(string methodName, Func`2<LogEventInfo, object> noParameters, MethodInfo legacyMethodInfo);
    public void RegisterOneParameter(string methodName, Func`3<LogEventInfo, object, object> oneParameter, MethodInfo legacyMethodInfo);
    public void RegisterTwoParameters(string methodName, Func`4<LogEventInfo, object, object, object> twoParameters, MethodInfo legacyMethodInfo);
    public void RegisterThreeParameters(string methodName, Func`5<LogEventInfo, object, object, object, object> threeParameters, MethodInfo legacyMethodInfo);
    public void RegisterManyParameters(string methodName, Func`2<Object[], object> manyParameters, int manyParameterMinCount, int manyParameterMaxCount, bool manyParameterWithLogEvent, MethodInfo legacyMethodInfo);
    public Func`2<LogEventInfo, object> TryCreateInstanceWithNoParameters(string methodName);
    public Func`3<LogEventInfo, object, object> TryCreateInstanceWithOneParameter(string methodName);
    public Func`4<LogEventInfo, object, object, object> TryCreateInstanceWithTwoParameters(string methodName);
    public Func`5<LogEventInfo, object, object, object, object> TryCreateInstanceWithThreeParameters(string methodName);
    public Func`2<Object[], object> TryCreateInstanceWithManyParameters(string methodName, Int32& manyParameterMinCount, Int32& manyParameterMaxCount, Boolean& manyParameterWithLogEvent);
}
[ObsoleteAttribute("Marked obsolete on NLog 5.3, instead use ThreadAgnosticImmutableAttribute")]
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
public class NLog.Config.MutableUnsafeAttribute : Attribute {
}
[MeansImplicitUseAttribute]
public abstract class NLog.Config.NameBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    protected NameBaseAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("128")]
public class NLog.Config.NLogConfigurationIgnorePropertyAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
public class NLog.Config.NLogConfigurationItemAttribute : Attribute {
}
public class NLog.Config.NLogDependencyResolveException : Exception {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [NotNullAttribute]
public Type ServiceType { get; }
    public NLogDependencyResolveException(string message, Type serviceType);
    public NLogDependencyResolveException(string message, Exception innerException, Type serviceType);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    private static string CreateFullMessage(Type typeToResolve, string message);
}
internal class NLog.Config.PropertyTypeConverter : object {
    [CompilerGeneratedAttribute]
private static PropertyTypeConverter <Instance>k__BackingField;
    private static Dictionary`2<Type, Func`4<string, string, IFormatProvider, object>> _stringConverters;
    public static PropertyTypeConverter Instance { get; }
    private static Dictionary`2<Type, Func`4<string, string, IFormatProvider, object>> StringConverterLookup { get; }
    private static PropertyTypeConverter();
    [CompilerGeneratedAttribute]
public static PropertyTypeConverter get_Instance();
    private static Dictionary`2<Type, Func`4<string, string, IFormatProvider, object>> get_StringConverterLookup();
    private static Dictionary`2<Type, Func`4<string, string, IFormatProvider, object>> BuildStringConverterLookup();
    [UnconditionalSuppressMessageAttribute("Trimming - Allow converting option-values from config", "IL2057")]
internal static Type ConvertToType(string stringvalue, bool throwOnError);
    internal static bool IsComplexType(Type type);
    public sealed virtual object Convert(object propertyValue, Type propertyType, string format, IFormatProvider formatProvider);
    private static bool TryConvertFromString(string propertyString, Type propertyType, string format, IFormatProvider formatProvider, Object& propertyValue);
    private static object ChangeObjectType(object propertyValue, Type propertyType, string format, IFormatProvider formatProvider);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow converting option-values from config", "IL2026")]
[UnconditionalSuppressMessageAttribute("Trimming - Allow converting option-values from config", "IL2067")]
[UnconditionalSuppressMessageAttribute("Trimming - Allow converting option-values from config", "IL2072")]
private static bool TryConvertToType(object propertyValue, Type propertyType, Object& convertedValue);
    private static object ConvertGuid(string format, string propertyString);
    private static object ConvertToEncoding(string stringValue);
    private static object ConvertToTimeSpan(string format, IFormatProvider formatProvider, string propertyString);
    private static object ConvertToDateTimeOffset(string format, IFormatProvider formatProvider, string propertyString);
    private static object ConvertToDateTime(string format, IFormatProvider formatProvider, string propertyString);
}
[AttributeUsageAttribute("128")]
[MeansImplicitUseAttribute]
public class NLog.Config.RequiredParameterAttribute : Attribute {
}
public abstract class NLog.Config.ServiceRepository : object {
    public abstract virtual void RegisterService(Type type, object instance);
    public abstract virtual object GetService(Type serviceType);
    internal abstract virtual bool TryGetService(T& serviceInstance);
}
[ExtensionAttribute]
internal static class NLog.Config.ServiceRepositoryExtensions : object {
    [ExtensionAttribute]
internal static ServiceRepository GetServiceProvider(LoggingConfiguration loggingConfiguration);
    [ExtensionAttribute]
internal static T ResolveService(ServiceRepository serviceProvider, bool ignoreExternalProvider);
    [ExtensionAttribute]
internal static T GetService(IServiceProvider serviceProvider);
    [ExtensionAttribute]
internal static ServiceRepository RegisterSingleton(ServiceRepository serviceRepository, T singleton);
    [ExtensionAttribute]
internal static ServiceRepository RegisterValueFormatter(ServiceRepository serviceRepository, IValueFormatter valueFormatter);
    [ExtensionAttribute]
internal static ServiceRepository RegisterJsonConverter(ServiceRepository serviceRepository, IJsonConverter jsonConverter);
    [ExtensionAttribute]
internal static ServiceRepository RegisterPropertyTypeConverter(ServiceRepository serviceRepository, IPropertyTypeConverter converter);
    [ExtensionAttribute]
internal static ServiceRepository RegisterObjectTypeTransformer(ServiceRepository serviceRepository, IObjectTypeTransformer transformer);
    [ExtensionAttribute]
internal static ServiceRepository ParseMessageTemplates(ServiceRepository serviceRepository, Nullable`1<bool> enable);
    [ExtensionAttribute]
internal static Nullable`1<bool> ResolveParseMessageTemplates(ServiceRepository serviceRepository);
    [ExtensionAttribute]
internal static ServiceRepository RegisterDefaults(ServiceRepository serviceRepository);
}
internal class NLog.Config.ServiceRepositoryInternal : ServiceRepository {
    private Dictionary`2<Type, Func`1<object>> _creatorMap;
    private Dictionary`2<Type, CompiledConstructor> _lateBoundMap;
    private object _lockObject;
    [CompilerGeneratedAttribute]
private EventHandler`1<ServiceRepositoryUpdateEventArgs> TypeRegistered;
    internal ServiceRepositoryInternal(bool resetGlobalCache);
    [CompilerGeneratedAttribute]
public void add_TypeRegistered(EventHandler`1<ServiceRepositoryUpdateEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TypeRegistered(EventHandler`1<ServiceRepositoryUpdateEventArgs> value);
    public virtual void RegisterService(Type type, object instance);
    public virtual object GetService(Type serviceType);
    internal virtual bool TryGetService(T& serviceInstance);
    private object DefaultResolveInstance(Type itemType, HashSet`1<Type> seenTypes);
    [ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2070")]
private CompiledConstructor CreateCompiledConstructor(Type itemType);
    private Object[] CreateCtorParameterValues(ParameterInfo[] parameterInfos, HashSet`1<Type> seenTypes);
}
public class NLog.Config.ServiceRepositoryUpdateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public Type ServiceType { get; }
    public ServiceRepositoryUpdateEventArgs(Type serviceType);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
}
[ObsoleteAttribute("Use LogManager.Setup().LoadConfiguration() instead. Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static class NLog.Config.SimpleConfigurator : object {
    [ObsoleteAttribute("Use LogManager.Setup().LoadConfiguration(c => c.ForLogger().WriteToConsole()) instead. Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static void ConfigureForConsoleLogging();
    [ObsoleteAttribute("Use LogManager.Setup().LoadConfiguration(c => c.ForLogger(minLevel).WriteToConsole()) instead. Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static void ConfigureForConsoleLogging(LogLevel minLevel);
    [ObsoleteAttribute("Use LogManager.Setup().LoadConfiguration(c => c.ForLogger().WriteTo(target)) instead. Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static void ConfigureForTargetLogging(Target target);
    [ObsoleteAttribute("Use LogManager.Setup().LoadConfiguration(c => c.ForLogger(minLevel).WriteTo(target)) instead. Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static void ConfigureForTargetLogging(Target target, LogLevel minLevel);
    [ObsoleteAttribute("Use LogManager.Setup().LoadConfiguration(c => c.ForLogger().WriteToFile(fileName)) instead. Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static void ConfigureForFileLogging(string fileName);
    [ObsoleteAttribute("Use LogManager.Setup().LoadConfiguration(c => c.ForLogger(minLevel).WriteToFile(fileName)) instead. Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static void ConfigureForFileLogging(string fileName, LogLevel minLevel);
}
[FlagsAttribute]
public enum NLog.Config.StackTraceUsage : Enum {
    public int value__;
    public static StackTraceUsage None;
    public static StackTraceUsage WithStackTrace;
    public static StackTraceUsage WithFileNameAndLineNumber;
    public static StackTraceUsage WithCallSite;
    public static StackTraceUsage WithCallSiteClassName;
    [ObsoleteAttribute("Replace with `WithStackTrace`. Marked obsolete on NLog 5.0")]
public static StackTraceUsage WithoutSource;
    public static StackTraceUsage WithSource;
    public static StackTraceUsage Max;
}
[AttributeUsageAttribute("4")]
public class NLog.Config.ThreadAgnosticAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class NLog.Config.ThreadAgnosticImmutableAttribute : Attribute {
}
[ObsoleteAttribute("All LayoutRenderer's and Layout's should be ThreadSafe by default. Marked obsolete with NLog 5.0")]
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
public class NLog.Config.ThreadSafeAttribute : Attribute {
}
public class NLog.Config.XmlLoggingConfiguration : LoggingConfigurationParser {
    private Dictionary`2<string, bool> _fileMustAutoReloadLookup;
    private string _originalFileName;
    private Stack`1<string> _currentFilePath;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <InitializeSucceeded>k__BackingField;
    public static LoggingConfiguration AppConfig { get; }
    public Nullable`1<bool> InitializeSucceeded { get; private set; }
    public bool AutoReload { get; public set; }
    public IEnumerable`1<string> FileNamesToWatch { get; }
    internal XmlLoggingConfiguration(LogFactory logFactory);
    public XmlLoggingConfiguration(string fileName);
    public XmlLoggingConfiguration(string fileName, LogFactory logFactory);
    [ObsoleteAttribute("Constructor with parameter ignoreErrors has limited effect. Instead use LogManager.ThrowConfigExceptions. Marked obsolete in NLog 4.7")]
[EditorBrowsableAttribute("1")]
public XmlLoggingConfiguration(string fileName, bool ignoreErrors);
    [ObsoleteAttribute("Constructor with parameter ignoreErrors has limited effect. Instead use LogManager.ThrowConfigExceptions. Marked obsolete in NLog 4.7")]
[EditorBrowsableAttribute("1")]
public XmlLoggingConfiguration(string fileName, bool ignoreErrors, LogFactory logFactory);
    public XmlLoggingConfiguration(XmlReader reader);
    public XmlLoggingConfiguration(XmlReader reader, string fileName);
    public XmlLoggingConfiguration(XmlReader reader, string fileName, LogFactory logFactory);
    [ObsoleteAttribute("Constructor with parameter ignoreErrors has limited effect. Instead use LogManager.ThrowConfigExceptions. Marked obsolete in NLog 4.7")]
[EditorBrowsableAttribute("1")]
public XmlLoggingConfiguration(XmlReader reader, string fileName, bool ignoreErrors);
    [ObsoleteAttribute("Constructor with parameter ignoreErrors has limited effect. Instead use LogManager.ThrowConfigExceptions. Marked obsolete in NLog 4.7")]
[EditorBrowsableAttribute("1")]
public XmlLoggingConfiguration(XmlReader reader, string fileName, bool ignoreErrors, LogFactory logFactory);
    internal XmlLoggingConfiguration(string xmlContents, string fileName, LogFactory logFactory);
    public static XmlLoggingConfiguration CreateFromXmlString(string xml);
    public static XmlLoggingConfiguration CreateFromXmlString(string xml, LogFactory logFactory);
    public static LoggingConfiguration get_AppConfig();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_InitializeSucceeded();
    [CompilerGeneratedAttribute]
private void set_InitializeSucceeded(Nullable`1<bool> value);
    public bool get_AutoReload();
    public void set_AutoReload(bool value);
    public virtual IEnumerable`1<string> get_FileNamesToWatch();
    public virtual LoggingConfiguration Reload();
    [ObsoleteAttribute("Replaced by chaining LogManager.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static IEnumerable`1<string> GetCandidateConfigFilePaths();
    [ObsoleteAttribute("Replaced by chaining LogManager.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static void SetCandidateConfigFilePaths(IEnumerable`1<string> filePaths);
    [ObsoleteAttribute("Replaced by chaining LogManager.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static void ResetCandidateConfigFilePath();
    private void LoadFromXmlFile(string fileName);
    internal void LoadFromXmlContent(string xmlContent, string fileName);
    private XmlReader CreateFileReader(string fileName);
    private void Initialize(XmlReader reader, string fileName, bool ignoreErrors);
    private void ConfigureFromFile(string fileName, bool autoReloadDefault);
    private void ParseTopLevel(XmlLoggingConfigurationElement content, string filePath, bool autoReloadDefault);
    private void ParseConfigurationElement(XmlLoggingConfigurationElement configurationElement, string filePath, bool autoReloadDefault);
    private void ParseNLogElement(ILoggingConfigurationElement nlogElement, string filePath, bool autoReloadDefault);
    protected virtual bool ParseNLogSection(ILoggingConfigurationElement configSection);
    private void ParseIncludeElement(ILoggingConfigurationElement includeElement, string baseDirectory, bool autoReloadDefault);
    private void ConfigureFromFilesByMask(string baseDirectory, string fileMask, bool autoReloadDefault);
    private static string GetFileLookupKey(string fileName);
    public virtual string ToString();
}
internal class NLog.Config.XmlLoggingConfigurationElement : object {
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<KeyValuePair`2<string, string>> <AttributeValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<XmlLoggingConfigurationElement> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string LocalName { get; private set; }
    public IList`1<KeyValuePair`2<string, string>> AttributeValues { get; }
    public IList`1<XmlLoggingConfigurationElement> Children { get; }
    public string Value { get; private set; }
    public string Name { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> Values { get; }
    private IEnumerable`1<ILoggingConfigurationElement> NLog.Config.ILoggingConfigurationElement.Children { get; }
    public XmlLoggingConfigurationElement(XmlReader reader);
    public XmlLoggingConfigurationElement(XmlReader reader, bool nestedElement);
    [CompilerGeneratedAttribute]
public string get_LocalName();
    [CompilerGeneratedAttribute]
private void set_LocalName(string value);
    [CompilerGeneratedAttribute]
public IList`1<KeyValuePair`2<string, string>> get_AttributeValues();
    [CompilerGeneratedAttribute]
public IList`1<XmlLoggingConfigurationElement> get_Children();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_Values();
    private static bool SingleValueElement(XmlLoggingConfigurationElement child);
    private sealed virtual override IEnumerable`1<ILoggingConfigurationElement> NLog.Config.ILoggingConfigurationElement.get_Children();
    [IteratorStateMachineAttribute("NLog.Config.XmlLoggingConfigurationElement/<FilterChildren>d__23")]
public IEnumerable`1<XmlLoggingConfigurationElement> FilterChildren(string elementName);
    public void AssertName(String[] allowedNames);
    private void Parse(XmlReader reader, bool nestedElement, IList`1& attributes, IList`1& children);
    private static void ParseAttributes(XmlReader reader, bool nestedElement, IList`1& attributes);
    private static bool IsSpecialXmlAttribute(XmlReader reader);
    public virtual string ToString();
}
[FilterAttribute("when")]
public class NLog.Filters.ConditionBasedFilter : Filter {
    [CompilerGeneratedAttribute]
private ConditionExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterResult <FilterDefaultAction>k__BackingField;
    [RequiredParameterAttribute]
public ConditionExpression Condition { get; public set; }
    internal FilterResult FilterDefaultAction { get; internal set; }
    [CompilerGeneratedAttribute]
public ConditionExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(ConditionExpression value);
    [CompilerGeneratedAttribute]
internal FilterResult get_FilterDefaultAction();
    [CompilerGeneratedAttribute]
internal void set_FilterDefaultAction(FilterResult value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[NLogConfigurationItemAttribute]
public abstract class NLog.Filters.Filter : object {
    [CompilerGeneratedAttribute]
private FilterResult <Action>k__BackingField;
    public FilterResult Action { get; public set; }
    [CompilerGeneratedAttribute]
public FilterResult get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(FilterResult value);
    internal FilterResult GetFilterResult(LogEventInfo logEvent);
    protected abstract virtual FilterResult Check(LogEventInfo logEvent);
}
[AttributeUsageAttribute("4")]
public class NLog.Filters.FilterAttribute : NameBaseAttribute {
    public FilterAttribute(string name);
}
public enum NLog.Filters.FilterResult : Enum {
    public int value__;
    public static FilterResult Neutral;
    public static FilterResult Log;
    public static FilterResult Ignore;
    public static FilterResult LogFinal;
    public static FilterResult IgnoreFinal;
}
public abstract class NLog.Filters.LayoutBasedFilter : Filter {
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
}
[FilterAttribute("whenContains")]
public class NLog.Filters.WhenContainsFilter : LayoutBasedFilter {
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Substring>k__BackingField;
    public bool IgnoreCase { get; public set; }
    [RequiredParameterAttribute]
public string Substring { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public string get_Substring();
    [CompilerGeneratedAttribute]
public void set_Substring(string value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[FilterAttribute("whenEqual")]
public class NLog.Filters.WhenEqualFilter : LayoutBasedFilter {
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompareTo>k__BackingField;
    public bool IgnoreCase { get; public set; }
    [RequiredParameterAttribute]
public string CompareTo { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public string get_CompareTo();
    [CompilerGeneratedAttribute]
public void set_CompareTo(string value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
public class NLog.Filters.WhenMethodFilter : Filter {
    private Func`2<LogEventInfo, FilterResult> _filterMethod;
    public WhenMethodFilter(Func`2<LogEventInfo, FilterResult> filterMethod);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[FilterAttribute("whenNotContains")]
public class NLog.Filters.WhenNotContainsFilter : LayoutBasedFilter {
    [CompilerGeneratedAttribute]
private string <Substring>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [RequiredParameterAttribute]
public string Substring { get; public set; }
    public bool IgnoreCase { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Substring();
    [CompilerGeneratedAttribute]
public void set_Substring(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[FilterAttribute("whenNotEqual")]
public class NLog.Filters.WhenNotEqualFilter : LayoutBasedFilter {
    [CompilerGeneratedAttribute]
private string <CompareTo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [RequiredParameterAttribute]
public string CompareTo { get; public set; }
    public bool IgnoreCase { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CompareTo();
    [CompilerGeneratedAttribute]
public void set_CompareTo(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[FilterAttribute("whenRepeated")]
public class NLog.Filters.WhenRepeatedFilter : LayoutBasedFilter {
    private static int MaxInitialRenderBufferLength;
    [CompilerGeneratedAttribute]
private int <TimeoutSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFilterCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultFilterCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterCountPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterCountMessageAppendFormat>k__BackingField;
    private Nullable`1<bool> _optimizeBufferReuse;
    [CompilerGeneratedAttribute]
private int <OptimizeBufferDefaultLength>k__BackingField;
    private ReusableBuilderCreator ReusableLayoutBuilder;
    private Dictionary`2<FilterInfoKey, FilterInfo> _repeatFilter;
    private Stack`1<KeyValuePair`2<FilterInfoKey, FilterInfo>> _objectPool;
    public int TimeoutSeconds { get; public set; }
    public int MaxLength { get; public set; }
    public bool IncludeFirst { get; public set; }
    public int MaxFilterCacheSize { get; public set; }
    public int DefaultFilterCacheSize { get; public set; }
    public string FilterCountPropertyName { get; public set; }
    public string FilterCountMessageAppendFormat { get; public set; }
    [ObsoleteAttribute("No longer used, and always returns true. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool OptimizeBufferReuse { get; public set; }
    public int OptimizeBufferDefaultLength { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TimeoutSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutSeconds(int value);
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    [CompilerGeneratedAttribute]
public void set_MaxLength(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeFirst();
    [CompilerGeneratedAttribute]
public void set_IncludeFirst(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxFilterCacheSize();
    [CompilerGeneratedAttribute]
public void set_MaxFilterCacheSize(int value);
    [CompilerGeneratedAttribute]
public int get_DefaultFilterCacheSize();
    [CompilerGeneratedAttribute]
public void set_DefaultFilterCacheSize(int value);
    [CompilerGeneratedAttribute]
public string get_FilterCountPropertyName();
    [CompilerGeneratedAttribute]
public void set_FilterCountPropertyName(string value);
    [CompilerGeneratedAttribute]
public string get_FilterCountMessageAppendFormat();
    [CompilerGeneratedAttribute]
public void set_FilterCountMessageAppendFormat(string value);
    public bool get_OptimizeBufferReuse();
    public void set_OptimizeBufferReuse(bool value);
    [CompilerGeneratedAttribute]
public int get_OptimizeBufferDefaultLength();
    [CompilerGeneratedAttribute]
public void set_OptimizeBufferDefaultLength(int value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
    private FilterInfo CreateFilterInfo(LogEventInfo logEvent);
    private void PruneFilterCache(LogEventInfo logEvent, int aggressiveTimeoutSeconds);
    private FilterInfoKey RenderFilterInfoKey(LogEventInfo logEvent, StringBuilder targetBuilder);
    private FilterResult RefreshFilterInfo(LogEventInfo logEvent, FilterInfo filterInfo);
}
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.3")]
[EditorBrowsableAttribute("1")]
public static class NLog.Fluent.Log : object {
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
private static ILogger _logger;
    private static Log();
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Level(LogLevel logLevel, string callerFilePath);
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Trace(string callerFilePath);
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Debug(string callerFilePath);
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Info(string callerFilePath);
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Warn(string callerFilePath);
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Error(string callerFilePath);
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Fatal(string callerFilePath);
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
private static LogBuilder Create(LogLevel logLevel, string callerFilePath);
    [ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
private static ILogger GetLogger(string callerFilePath);
}
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public class NLog.Fluent.LogBuilder : object {
    private LogEventInfo _logEvent;
    private ILogger _logger;
    public LogEventInfo LogEventInfo { get; }
    [CLSCompliantAttribute("False")]
public LogBuilder(ILogger logger);
    [CLSCompliantAttribute("False")]
public LogBuilder(ILogger logger, LogLevel logLevel);
    public LogEventInfo get_LogEventInfo();
    public LogBuilder Exception(Exception exception);
    public LogBuilder Level(LogLevel logLevel);
    public LogBuilder LoggerName(string loggerName);
    public LogBuilder Message(string message);
    [MessageTemplateFormatMethodAttribute("format")]
public LogBuilder Message(string format, object arg0);
    [MessageTemplateFormatMethodAttribute("format")]
public LogBuilder Message(string format, object arg0, object arg1);
    [MessageTemplateFormatMethodAttribute("format")]
public LogBuilder Message(string format, object arg0, object arg1, object arg2);
    [MessageTemplateFormatMethodAttribute("format")]
public LogBuilder Message(string format, object arg0, object arg1, object arg2, object arg3);
    [MessageTemplateFormatMethodAttribute("format")]
public LogBuilder Message(string format, Object[] args);
    [MessageTemplateFormatMethodAttribute("format")]
public LogBuilder Message(IFormatProvider provider, string format, Object[] args);
    public LogBuilder Property(object name, object value);
    public LogBuilder Properties(IDictionary properties);
    public LogBuilder TimeStamp(DateTime timeStamp);
    public LogBuilder StackTrace(StackTrace stackTrace, int userStackFrame);
    public void Write(string callerMemberName, string callerFilePath, int callerLineNumber);
    public void WriteIf(Func`1<bool> condition, string callerMemberName, string callerFilePath, int callerLineNumber);
    public void WriteIf(bool condition, string callerMemberName, string callerFilePath, int callerLineNumber);
    private void SetCallerInfo(string callerMethodName, string callerFilePath, int callerLineNumber);
}
[ExtensionAttribute]
public static class NLog.Fluent.LoggerExtensions : object {
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForLogEvent and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Log(ILogger logger, LogLevel logLevel);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForTraceEvent() and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Trace(ILogger logger);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForDebugEvent() and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Debug(ILogger logger);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForInfoEvent() and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Info(ILogger logger);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForWarnEvent() and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Warn(ILogger logger);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForErrorEvent() and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Error(ILogger logger);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Obsoleted since it allocates unnecessary. Instead use ILogger.ForFatalEvent() and LogEventBuilder. Obsoleted in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static LogBuilder Fatal(ILogger logger);
}
public static class NLog.GlobalDiagnosticsContext : object {
    private static object _lockObject;
    private static Dictionary`2<string, object> _dict;
    private static Dictionary`2<string, object> _dictReadOnly;
    private static GlobalDiagnosticsContext();
    public static void Set(string item, string value);
    public static void Set(string item, object value);
    public static string Get(string item);
    public static string Get(string item, IFormatProvider formatProvider);
    public static object GetObject(string item);
    public static ICollection`1<string> GetNames();
    public static bool Contains(string item);
    public static void Remove(string item);
    public static void Clear();
    internal static Dictionary`2<string, object> GetReadOnlyDict();
    private static Dictionary`2<string, object> GetWritableDict(bool clearDictionary);
    private static Dictionary`2<string, object> CopyDictionaryOnWrite(bool clearDictionary);
}
public interface NLog.IJsonConverter {
    public abstract virtual bool SerializeObject(object value, StringBuilder builder);
}
[CLSCompliantAttribute("False")]
public interface NLog.ILogger {
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    [EditorBrowsableAttribute("1")]
public abstract virtual void Trace(object value);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Trace(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Debug(object value);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Debug(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Info(object value);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Info(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Warn(object value);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Warn(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Error(object value);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Error(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Error(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Error(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Error(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Fatal(object value);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Fatal(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Fatal(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, ulong argument);
    public abstract virtual bool get_IsTraceEnabled();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
    public abstract virtual void Trace(T value);
    public abstract virtual void Trace(IFormatProvider formatProvider, T value);
    public abstract virtual void Trace(LogMessageGenerator messageFunc);
    [ObsoleteAttribute("Use Trace(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public abstract virtual void TraceException(string message, Exception exception);
    public abstract virtual void Trace(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, Object[] args);
    public abstract virtual void Trace(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, Object[] args);
    [ObsoleteAttribute("Use Trace(Exception exception, string message) method instead. Marked obsolete with v4.3.11")]
[EditorBrowsableAttribute("1")]
public abstract virtual void Trace(string message, Exception exception);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Trace(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public abstract virtual void Debug(T value);
    public abstract virtual void Debug(IFormatProvider formatProvider, T value);
    public abstract virtual void Debug(LogMessageGenerator messageFunc);
    public abstract virtual void Debug(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, Object[] args);
    public abstract virtual void Debug(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Debug(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ObsoleteAttribute("Use Debug(Exception exception, string message) method instead. Marked obsolete with v4.3.11")]
[EditorBrowsableAttribute("1")]
public abstract virtual void Debug(string message, Exception exception);
    [ObsoleteAttribute("Use Debug(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public abstract virtual void DebugException(string message, Exception exception);
    public abstract virtual void Info(T value);
    public abstract virtual void Info(IFormatProvider formatProvider, T value);
    public abstract virtual void Info(LogMessageGenerator messageFunc);
    public abstract virtual void Info(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, Object[] args);
    public abstract virtual void Info(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Info(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ObsoleteAttribute("Use Info(Exception exception, string message) method instead. Marked obsolete with v4.3.11")]
[EditorBrowsableAttribute("1")]
public abstract virtual void Info(string message, Exception exception);
    [ObsoleteAttribute("Use Info(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public abstract virtual void InfoException(string message, Exception exception);
    public abstract virtual void Warn(T value);
    public abstract virtual void Warn(IFormatProvider formatProvider, T value);
    public abstract virtual void Warn(LogMessageGenerator messageFunc);
    public abstract virtual void Warn(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, Object[] args);
    public abstract virtual void Warn(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Warn(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ObsoleteAttribute("Use Warn(Exception exception, string message) method instead. Marked obsolete with v4.3.11")]
[EditorBrowsableAttribute("1")]
public abstract virtual void Warn(string message, Exception exception);
    [ObsoleteAttribute("Use Warn(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public abstract virtual void WarnException(string message, Exception exception);
    public abstract virtual void Error(T value);
    public abstract virtual void Error(IFormatProvider formatProvider, T value);
    public abstract virtual void Error(LogMessageGenerator messageFunc);
    public abstract virtual void Error(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, Object[] args);
    public abstract virtual void Error(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Error(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ObsoleteAttribute("Use Error(Exception exception, string message) method instead. Marked obsolete with v4.3.11")]
[EditorBrowsableAttribute("1")]
public abstract virtual void Error(string message, Exception exception);
    [ObsoleteAttribute("Use Error(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public abstract virtual void ErrorException(string message, Exception exception);
    public abstract virtual void Fatal(T value);
    public abstract virtual void Fatal(IFormatProvider formatProvider, T value);
    public abstract virtual void Fatal(LogMessageGenerator messageFunc);
    public abstract virtual void Fatal(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, Object[] args);
    public abstract virtual void Fatal(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Fatal(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ObsoleteAttribute("Use Fatal(Exception exception, string message) method instead. Marked obsolete with v4.3.11")]
[EditorBrowsableAttribute("1")]
public abstract virtual void Fatal(string message, Exception exception);
    [ObsoleteAttribute("Use Fatal(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public abstract virtual void FatalException(string message, Exception exception);
}
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("ILoggerBase should be replaced with ILogger. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public interface NLog.ILoggerBase {
    public string Name { get; }
    [ObsoleteAttribute("Factory-property is hard to mock for ILogger-interface. Instead use Logger.Factory. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public LogFactory Factory { get; }
    [EditorBrowsableAttribute("1")]
public abstract virtual void Log(LogLevel level, object value);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, ulong argument);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LoggerReconfigured(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LoggerReconfigured(EventHandler`1<EventArgs> value);
    public abstract virtual string get_Name();
    public abstract virtual LogFactory get_Factory();
    public abstract virtual bool IsEnabled(LogLevel level);
    public abstract virtual void Log(LogEventInfo logEvent);
    public abstract virtual void Log(Type wrapperType, LogEventInfo logEvent);
    public abstract virtual void Log(LogLevel level, T value);
    public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, T value);
    public abstract virtual void Log(LogLevel level, LogMessageGenerator messageFunc);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, Object[] args);
    public abstract virtual void Log(LogLevel level, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public abstract virtual void Log(LogLevel level, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ObsoleteAttribute("Use Log(LogLevel level, Exception exception, [Localizable(false)] string message, params object[] args) instead. Marked obsolete with v4.3.11")]
[EditorBrowsableAttribute("1")]
public abstract virtual void Log(LogLevel level, string message, Exception exception);
    [ObsoleteAttribute("Use Log(LogLevel level, Exception exception, [Localizable(false)] string message, params object[] args) instead. Marked obsolete with v4.3.11")]
[EditorBrowsableAttribute("1")]
public abstract virtual void LogException(LogLevel level, string message, Exception exception);
}
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static class NLog.ILoggerExtensions : object {
    [ExtensionAttribute]
public static LogEventBuilder ForLogEvent(ILogger logger, LogLevel logLevel);
    [ExtensionAttribute]
public static LogEventBuilder ForTraceEvent(ILogger logger);
    [ExtensionAttribute]
public static LogEventBuilder ForDebugEvent(ILogger logger);
    [ExtensionAttribute]
public static LogEventBuilder ForInfoEvent(ILogger logger);
    [ExtensionAttribute]
public static LogEventBuilder ForWarnEvent(ILogger logger);
    [ExtensionAttribute]
public static LogEventBuilder ForErrorEvent(ILogger logger);
    [ExtensionAttribute]
public static LogEventBuilder ForFatalEvent(ILogger logger);
    [ExtensionAttribute]
public static LogEventBuilder ForExceptionEvent(ILogger logger, Exception exception, LogLevel logLevel);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ConditionalDebug(ILogger logger, T value);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ConditionalDebug(ILogger logger, IFormatProvider formatProvider, T value);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ConditionalDebug(ILogger logger, LogMessageGenerator messageFunc);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalDebug(ILogger logger, Exception exception, string message, Object[] args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalDebug(ILogger logger, Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ConditionalDebug(ILogger logger, string message);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalDebug(ILogger logger, string message, Object[] args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalDebug(ILogger logger, IFormatProvider formatProvider, string message, Object[] args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalDebug(ILogger logger, string message, TArgument argument);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalDebug(ILogger logger, string message, TArgument1 argument1, TArgument2 argument2);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalDebug(ILogger logger, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ConditionalTrace(ILogger logger, T value);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ConditionalTrace(ILogger logger, IFormatProvider formatProvider, T value);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ConditionalTrace(ILogger logger, LogMessageGenerator messageFunc);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalTrace(ILogger logger, Exception exception, string message, Object[] args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalTrace(ILogger logger, Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ConditionalTrace(ILogger logger, string message);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalTrace(ILogger logger, string message, Object[] args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalTrace(ILogger logger, IFormatProvider formatProvider, string message, Object[] args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalTrace(ILogger logger, string message, TArgument argument);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalTrace(ILogger logger, string message, TArgument1 argument1, TArgument2 argument2);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public static void ConditionalTrace(ILogger logger, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ExtensionAttribute]
public static void Log(ILogger logger, LogLevel level, Exception exception, LogMessageGenerator messageFunc);
    [ExtensionAttribute]
public static void Trace(ILogger logger, Exception exception, LogMessageGenerator messageFunc);
    [ExtensionAttribute]
public static void Debug(ILogger logger, Exception exception, LogMessageGenerator messageFunc);
    [ExtensionAttribute]
public static void Info(ILogger logger, Exception exception, LogMessageGenerator messageFunc);
    [ExtensionAttribute]
public static void Warn(ILogger logger, Exception exception, LogMessageGenerator messageFunc);
    [ExtensionAttribute]
public static void Error(ILogger logger, Exception exception, LogMessageGenerator messageFunc);
    [ExtensionAttribute]
public static void Fatal(ILogger logger, Exception exception, LogMessageGenerator messageFunc);
}
internal class NLog.Internal.AppendBuilderCreator : ValueType {
    private static StringBuilderPool _builderPool;
    private StringBuilder _appendTarget;
    private ItemHolder _builder;
    public StringBuilder Builder { get; }
    public AppendBuilderCreator(bool mustBeEmpty);
    public AppendBuilderCreator(StringBuilder appendTarget, bool mustBeEmpty);
    private static AppendBuilderCreator();
    public StringBuilder get_Builder();
    public sealed virtual void Dispose();
}
internal static class NLog.Internal.ArrayHelper : object {
    internal static T[] Empty();
}
internal static class NLog.Internal.AssemblyHelpers : object {
    [UnconditionalSuppressMessageAttribute("Trimming - Allow extension loading from config", "IL2026")]
[ObsoleteAttribute("Instead use NLog.LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
public static Type[] SafeGetTypes(Assembly assembly);
    [ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
public static string GetAssemblyFileLocation(Assembly assembly);
}
internal class NLog.Internal.AsyncHelpersTask : ValueType {
    public WaitCallback AsyncDelegate;
    public AsyncHelpersTask(WaitCallback asyncDelegate);
}
internal class NLog.Internal.AsyncOperationCounter : object {
    private int _pendingOperationCounter;
    private LinkedList`1<AsyncContinuation> _pendingCompletionList;
    public void BeginOperation();
    public void CompleteOperation(Exception exception);
    private int NotifyCompletion(Exception exception);
    public AsyncContinuation RegisterCompletionNotification(AsyncContinuation asyncContinuation);
    public void Clear();
}
internal class NLog.Internal.CallSiteInformation : object {
    private static object lockObject;
    private static ICollection`1<Assembly> _hiddenAssemblies;
    private static ICollection`1<Type> _hiddenTypes;
    [CompilerGeneratedAttribute]
private int <UserStackFrameNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <UserStackFrameNumberLegacy>k__BackingField;
    [CompilerGeneratedAttribute]
private StackTrace <StackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallerClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallerMethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallerFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CallerLineNumber>k__BackingField;
    [ObsoleteAttribute("Instead use ${callsite} or CallerMemberName. Marked obsolete on NLog 5.3")]
public StackFrame UserStackFrame { get; }
    public int UserStackFrameNumber { get; private set; }
    public Nullable`1<int> UserStackFrameNumberLegacy { get; private set; }
    public StackTrace StackTrace { get; private set; }
    public string CallerClassName { get; internal set; }
    public string CallerMethodName { get; private set; }
    public string CallerFilePath { get; private set; }
    public Nullable`1<int> CallerLineNumber { get; private set; }
    private static CallSiteInformation();
    internal static bool IsHiddenAssembly(Assembly assembly);
    internal static bool IsHiddenClassType(Type type);
    public static void AddCallSiteHiddenAssembly(Assembly assembly);
    public static void AddCallSiteHiddenClassType(Type classType);
    public void SetStackTrace(StackTrace stackTrace, Nullable`1<int> userStackFrame, Type loggerType);
    public void SetCallerInfo(string callerClassName, string callerMethodName, string callerFilePath, int callerLineNumber);
    public StackFrame get_UserStackFrame();
    [CompilerGeneratedAttribute]
public int get_UserStackFrameNumber();
    [CompilerGeneratedAttribute]
private void set_UserStackFrameNumber(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_UserStackFrameNumberLegacy();
    [CompilerGeneratedAttribute]
private void set_UserStackFrameNumberLegacy(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public StackTrace get_StackTrace();
    [CompilerGeneratedAttribute]
private void set_StackTrace(StackTrace value);
    public MethodBase GetCallerStackFrameMethod(int skipFrames);
    public string GetCallerClassName(MethodBase method, bool includeNameSpace, bool cleanAsyncMoveNext, bool cleanAnonymousDelegates);
    public string GetCallerMethodName(MethodBase method, bool includeMethodInfo, bool cleanAsyncMoveNext, bool cleanAnonymousDelegates);
    public string GetCallerFilePath(int skipFrames);
    public int GetCallerLineNumber(int skipFrames);
    [CompilerGeneratedAttribute]
public string get_CallerClassName();
    [CompilerGeneratedAttribute]
internal void set_CallerClassName(string value);
    [CompilerGeneratedAttribute]
public string get_CallerMethodName();
    [CompilerGeneratedAttribute]
private void set_CallerMethodName(string value);
    [CompilerGeneratedAttribute]
public string get_CallerFilePath();
    [CompilerGeneratedAttribute]
private void set_CallerFilePath(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CallerLineNumber();
    [CompilerGeneratedAttribute]
private void set_CallerLineNumber(Nullable`1<int> value);
    private static Nullable`1<int> FindCallingMethodOnStackTrace(StackFrame[] stackFrames, Type loggerType);
    private static int SkipToUserStackFrameLegacy(StackFrame[] stackFrames, int firstUserStackFrame);
    private static bool SkipStackFrameWhenHidden(MethodBase stackMethod);
    private static bool SkipStackFrameWhenLoggerType(MethodBase stackMethod, Type loggerType);
}
[ExtensionAttribute]
internal static class NLog.Internal.CollectionExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<TItem> Filter(IList`1<TItem> items, TState state, Func`3<TItem, TState, bool> filter);
}
internal class NLog.Internal.ConfigurationManager : object {
    public NameValueCollection AppSettings { get; }
    public sealed virtual NameValueCollection get_AppSettings();
    public sealed virtual ConnectionStringSettings LookupConnectionString(string name);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class NLog.Internal.ConfigVariablesDictionary : object {
    private ThreadSafeDictionary`2<string, Layout> _variables;
    private LoggingConfiguration _configuration;
    private ThreadSafeDictionary`2<string, Layout> _dynamicVariables;
    private ThreadSafeDictionary`2<string, bool> _apiVariables;
    public int Count { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<Layout> Values { get; }
    public Layout Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,NLog.Layouts.Layout>>.IsReadOnly { get; }
    public ConfigVariablesDictionary(LoggingConfiguration configuration);
    public void InsertParsedConfigVariable(string key, Layout value, bool keepVariablesOnReload);
    public bool TryLookupDynamicVariable(string key, Layout& dynamicLayout);
    public void PrepareForReload(ConfigVariablesDictionary oldVariables);
    public sealed virtual int get_Count();
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<Layout> get_Values();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool TryGetValue(string key, Layout& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, Layout>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,NLog.Layouts.Layout>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<string, Layout> GetEnumerator();
    public sealed virtual Layout get_Item(string key);
    public sealed virtual void set_Item(string key, Layout value);
    public sealed virtual void Add(string key, Layout value);
    public sealed virtual bool Remove(string key);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,NLog.Layouts.Layout>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,NLog.Layouts.Layout>>.Contains(KeyValuePair`2<string, Layout> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,NLog.Layouts.Layout>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,NLog.Layouts.Layout>>.Add(KeyValuePair`2<string, Layout> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,NLog.Layouts.Layout>>.Remove(KeyValuePair`2<string, Layout> item);
    private void RegisterApiVariable(string key);
}
internal class NLog.Internal.DictionaryEntryEnumerable : ValueType {
    private IDictionary _dictionary;
    public DictionaryEntryEnumerable(IDictionary dictionary);
    public DictionaryEntryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<DictionaryEntry> System.Collections.Generic.IEnumerable<System.Collections.DictionaryEntry>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class NLog.Internal.EncodingHelpers : object {
    internal static Byte[] Utf8BOM;
    private static EncodingHelpers();
}
internal static class NLog.Internal.EnvironmentHelper : object {
    internal static string NewLine { get; }
    internal static string get_NewLine();
    internal static string GetMachineName();
    internal static string GetSafeEnvironmentVariable(string name);
}
[ExtensionAttribute]
internal static class NLog.Internal.ExceptionHelper : object {
    private static string LoggedKey;
    [ExtensionAttribute]
public static void MarkAsLoggedToInternalLogger(Exception exception);
    [ExtensionAttribute]
public static bool IsLoggedToInternalLogger(Exception exception);
    [ExtensionAttribute]
public static bool MustBeRethrown(Exception exception, IInternalLoggerContext loggerContext, string callerMemberName);
    [ExtensionAttribute]
public static bool MustBeRethrownImmediately(Exception exception);
}
internal class NLog.Internal.ExceptionMessageFormatProvider : object {
    internal static ExceptionMessageFormatProvider Instance;
    private static ExceptionMessageFormatProvider();
    private sealed virtual override string System.ICustomFormatter.Format(string format, object arg, IFormatProvider formatProvider);
    private static Exception GetPrimaryException(Exception exception);
    private sealed virtual override object System.IFormatProvider.GetFormat(Type formatType);
}
[ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
internal static class NLog.Internal.FactoryHelper : object {
    internal static ConfigurationItemCreator CreateInstance;
    private static FactoryHelper();
    [UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2067")]
private static object DefaultCreateInstance(Type type);
}
[ObsoleteAttribute("For unit testing only. Marked obsolete on NLog 5.0")]
internal class NLog.Internal.Fakeables.AppDomainWrapper : object {
    private AppDomain _currentAppDomain;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PrivateBinPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> processExitEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> domainUnloadEvent;
    public static AppDomainWrapper CurrentDomain { get; }
    public string BaseDirectory { get; private set; }
    public string ConfigurationFile { get; private set; }
    public IEnumerable`1<string> PrivateBinPath { get; private set; }
    public string FriendlyName { get; private set; }
    public int Id { get; private set; }
    public AppDomainWrapper(AppDomain appDomain);
    private static string LookupBaseDirectory(AppDomain appDomain);
    private static string LookupConfigurationFile(AppDomain appDomain);
    private static String[] LookupPrivateBinPath(AppDomain appDomain);
    private static string GetFriendlyNameFromEntryAssembly();
    private static string GetFriendlyNameFromProcessName();
    public static AppDomainWrapper get_CurrentDomain();
    [CompilerGeneratedAttribute]
public sealed virtual string get_BaseDirectory();
    [CompilerGeneratedAttribute]
private void set_BaseDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConfigurationFile();
    [CompilerGeneratedAttribute]
private void set_ConfigurationFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_PrivateBinPath();
    [CompilerGeneratedAttribute]
private void set_PrivateBinPath(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(int value);
    public sealed virtual IEnumerable`1<Assembly> GetAssemblies();
    public sealed virtual void add_ProcessExit(EventHandler`1<EventArgs> value);
    public sealed virtual void remove_ProcessExit(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
private void add_processExitEvent(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_processExitEvent(EventHandler`1<EventArgs> value);
    public sealed virtual void add_DomainUnload(EventHandler`1<EventArgs> value);
    public sealed virtual void remove_DomainUnload(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
private void add_domainUnloadEvent(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_domainUnloadEvent(EventHandler`1<EventArgs> value);
    private void OnDomainUnload(object sender, EventArgs e);
    private void OnProcessExit(object sender, EventArgs eventArgs);
}
internal class NLog.Internal.Fakeables.AppEnvironmentWrapper : object {
    private static string UnknownProcessName;
    private string _entryAssemblyLocation;
    private string _entryAssemblyFileName;
    private string _currentProcessFilePath;
    private string _currentProcessBaseName;
    private Nullable`1<int> _currentProcessId;
    [CompilerGeneratedAttribute]
private IAppDomain <AppDomain>k__BackingField;
    public string EntryAssemblyLocation { get; }
    public string EntryAssemblyFileName { get; }
    public string CurrentProcessFilePath { get; }
    public string CurrentProcessBaseName { get; }
    public int CurrentProcessId { get; }
    public string AppDomainBaseDirectory { get; }
    public string AppDomainConfigurationFile { get; }
    public string AppDomainFriendlyName { get; }
    public int AppDomainId { get; }
    public IEnumerable`1<string> AppDomainPrivateBinPath { get; }
    public string UserTempFilePath { get; }
    [ObsoleteAttribute("For unit testing only. Marked obsolete on NLog 5.0")]
public IAppDomain AppDomain { get; internal set; }
    public AppEnvironmentWrapper(IAppDomain appDomain);
    public sealed virtual string get_EntryAssemblyLocation();
    public sealed virtual string get_EntryAssemblyFileName();
    public sealed virtual string get_CurrentProcessFilePath();
    public sealed virtual string get_CurrentProcessBaseName();
    public sealed virtual int get_CurrentProcessId();
    public sealed virtual string get_AppDomainBaseDirectory();
    public sealed virtual string get_AppDomainConfigurationFile();
    public sealed virtual string get_AppDomainFriendlyName();
    public sealed virtual int get_AppDomainId();
    public sealed virtual IEnumerable`1<string> get_AppDomainPrivateBinPath();
    public sealed virtual IEnumerable`1<Assembly> GetAppDomainRuntimeAssemblies();
    public sealed virtual void add_ProcessExit(EventHandler`1<EventArgs> value);
    public sealed virtual void remove_ProcessExit(EventHandler`1<EventArgs> value);
    public sealed virtual string get_UserTempFilePath();
    [CompilerGeneratedAttribute]
public sealed virtual IAppDomain get_AppDomain();
    [CompilerGeneratedAttribute]
internal void set_AppDomain(IAppDomain value);
    public sealed virtual bool FileExists(string path);
    public sealed virtual XmlReader LoadXmlFile(string path);
    private static string LookupEntryAssemblyLocation();
    private static string LookupEntryAssemblyFileName();
    private static string LookupCurrentProcessFilePathWithFallback();
    private static string LookupCurrentProcessFilePath();
    private static int LookupCurrentProcessIdWithFallback();
    private static Nullable`1<int> LookupCurrentProcessId();
    private static string LookupCurrentProcessNameWithFallback();
    private static string LookupCurrentProcessName();
    private static string LookupCurrentProcessNameNative();
    private static string LookupCurrentProcessFilePathNative();
    [SecuritySafeCriticalAttribute]
private static string LookupCurrentProcessFilePathWin32();
    private static int LookupCurrentProcessIdNative();
    [SecuritySafeCriticalAttribute]
private static int LookupCurrentProcessIdWin32();
}
[ObsoleteAttribute("For unit testing only. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public interface NLog.Internal.Fakeables.IAppDomain {
    public string BaseDirectory { get; }
    public string ConfigurationFile { get; }
    public IEnumerable`1<string> PrivateBinPath { get; }
    public string FriendlyName { get; }
    public int Id { get; }
    public abstract virtual string get_BaseDirectory();
    public abstract virtual string get_ConfigurationFile();
    public abstract virtual IEnumerable`1<string> get_PrivateBinPath();
    public abstract virtual string get_FriendlyName();
    public abstract virtual int get_Id();
    public abstract virtual IEnumerable`1<Assembly> GetAssemblies();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProcessExit(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProcessExit(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DomainUnload(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DomainUnload(EventHandler`1<EventArgs> value);
}
internal interface NLog.Internal.Fakeables.IAppEnvironment {
    public string AppDomainBaseDirectory { get; }
    public string AppDomainConfigurationFile { get; }
    public string AppDomainFriendlyName { get; }
    public int AppDomainId { get; }
    public IEnumerable`1<string> AppDomainPrivateBinPath { get; }
    [ObsoleteAttribute("Marked obsolete on NLog 5.0")]
public IAppDomain AppDomain { get; }
    public string CurrentProcessFilePath { get; }
    public string CurrentProcessBaseName { get; }
    public int CurrentProcessId { get; }
    public string EntryAssemblyLocation { get; }
    public string EntryAssemblyFileName { get; }
    public string UserTempFilePath { get; }
    public abstract virtual string get_AppDomainBaseDirectory();
    public abstract virtual string get_AppDomainConfigurationFile();
    public abstract virtual string get_AppDomainFriendlyName();
    public abstract virtual int get_AppDomainId();
    public abstract virtual IEnumerable`1<string> get_AppDomainPrivateBinPath();
    public abstract virtual IEnumerable`1<Assembly> GetAppDomainRuntimeAssemblies();
    public abstract virtual IAppDomain get_AppDomain();
    public abstract virtual string get_CurrentProcessFilePath();
    public abstract virtual string get_CurrentProcessBaseName();
    public abstract virtual int get_CurrentProcessId();
    public abstract virtual string get_EntryAssemblyLocation();
    public abstract virtual string get_EntryAssemblyFileName();
    public abstract virtual string get_UserTempFilePath();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProcessExit(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProcessExit(EventHandler`1<EventArgs> value);
}
internal interface NLog.Internal.Fakeables.IFileSystem {
    public abstract virtual bool FileExists(string path);
    public abstract virtual XmlReader LoadXmlFile(string path);
}
[SecuritySafeCriticalAttribute]
internal abstract class NLog.Internal.FileAppenders.BaseFileAppender : object {
    private Random _random;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    private DateTime _creationTimeUtc;
    [CompilerGeneratedAttribute]
private DateTime <CreationTimeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <OpenTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private ICreateFileParameters <CreateFileParameters>k__BackingField;
    public string FileName { get; }
    public DateTime CreationTimeUtc { get; internal set; }
    public DateTime CreationTimeSource { get; private set; }
    public DateTime OpenTimeUtc { get; private set; }
    public ICreateFileParameters CreateFileParameters { get; private set; }
    protected BaseFileAppender(string fileName, ICreateFileParameters createParameters);
    [CompilerGeneratedAttribute]
public string get_FileName();
    public DateTime get_CreationTimeUtc();
    internal void set_CreationTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_CreationTimeSource();
    [CompilerGeneratedAttribute]
private void set_CreationTimeSource(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_OpenTimeUtc();
    [CompilerGeneratedAttribute]
private void set_OpenTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public ICreateFileParameters get_CreateFileParameters();
    [CompilerGeneratedAttribute]
private void set_CreateFileParameters(ICreateFileParameters value);
    public void Write(Byte[] bytes);
    public abstract virtual void Write(Byte[] bytes, int offset, int count);
    public abstract virtual void Flush();
    public abstract virtual void Close();
    public abstract virtual Nullable`1<DateTime> GetFileCreationTimeUtc();
    public abstract virtual Nullable`1<long> GetFileLength();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected FileStream CreateFileStream(bool allowFileSharedWriting, int overrideBufferSize);
    private FileStream TryCreateDirectoryFileStream(bool allowFileSharedWriting, int overrideBufferSize);
    private FileStream WindowsCreateFile(bool allowFileSharedWriting, int bufferSize);
    private FileStream TryCreateFileStream(bool allowFileSharedWriting, int overrideBufferSize);
    private void RefreshFileCreationTime();
    protected static void CloseFileSafe(FileStream& fileStream, string fileName);
    protected static bool MonitorForEnableFileDeleteEvent(string fileName, Int32& lastSimpleMonitorCheckTickCount);
}
[SecuritySafeCriticalAttribute]
internal abstract class NLog.Internal.FileAppenders.BaseMutexFileAppender : BaseFileAppender {
    [CompilerGeneratedAttribute]
private Mutex <ArchiveMutex>k__BackingField;
    [CanBeNullAttribute]
public Mutex ArchiveMutex { get; private set; }
    protected BaseMutexFileAppender(string fileName, ICreateFileParameters createParameters);
    [CompilerGeneratedAttribute]
public Mutex get_ArchiveMutex();
    [CompilerGeneratedAttribute]
private void set_ArchiveMutex(Mutex value);
    private Mutex CreateArchiveMutex();
    protected virtual void Dispose(bool disposing);
    protected Mutex CreateSharableMutex(string mutexNamePrefix);
    internal static Mutex ForceCreateSharableMutex(string name);
    private string GetMutexName(string mutexNamePrefix);
}
[SecuritySafeCriticalAttribute]
internal class NLog.Internal.FileAppenders.CountingSingleProcessFileAppender : BaseFileAppender {
    public static IFileAppenderFactory TheFactory;
    private FileStream _file;
    private long _currentFileLength;
    private bool _enableFileDeleteSimpleMonitor;
    private int _lastSimpleMonitorCheckTickCount;
    public CountingSingleProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static CountingSingleProcessFileAppender();
    public virtual void Close();
    public virtual void Flush();
    public virtual Nullable`1<DateTime> GetFileCreationTimeUtc();
    public virtual Nullable`1<long> GetFileLength();
    public virtual void Write(Byte[] bytes, int offset, int count);
}
internal class NLog.Internal.FileAppenders.FileAppenderCache : object {
    private BaseFileAppender[] _appenders;
    private Timer _autoClosingTimer;
    private string _archiveFilePatternToWatch;
    private MultiFileWatcher _externalFileArchivingWatcher;
    private bool _logFileWasArchived;
    public static FileAppenderCache Empty;
    [CompilerGeneratedAttribute]
private ICreateFileParameters <CreateFileParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileAppenderFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler CheckCloseAppenders;
    public string ArchiveFilePatternToWatch { get; public set; }
    public ICreateFileParameters CreateFileParameters { get; private set; }
    public IFileAppenderFactory Factory { get; private set; }
    public int Size { get; private set; }
    public FileAppenderCache(int size, IFileAppenderFactory appenderFactory, ICreateFileParameters createFileParams);
    private static FileAppenderCache();
    private void ExternalFileArchivingWatcher_OnFileChanged(object sender, FileSystemEventArgs e);
    private bool FileArchiveFolderChanged(string fullPath);
    public sealed virtual string get_ArchiveFilePatternToWatch();
    public sealed virtual void set_ArchiveFilePatternToWatch(string value);
    public sealed virtual void InvalidateAppendersForArchivedFiles();
    private void AutoClosingTimerCallback(object state);
    [CompilerGeneratedAttribute]
public sealed virtual ICreateFileParameters get_CreateFileParameters();
    [CompilerGeneratedAttribute]
private void set_CreateFileParameters(ICreateFileParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual IFileAppenderFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(IFileAppenderFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(int value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CheckCloseAppenders(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CheckCloseAppenders(EventHandler value);
    public sealed virtual BaseFileAppender AllocateAppender(string fileName);
    private BaseFileAppender CreateAppender(string fileName, int freeSpot);
    public sealed virtual void CloseAppenders(string reason);
    private void CloseAllAppenders(int startIndex, string reason);
    public sealed virtual void CloseExpiredAppenders(DateTime expireTimeUtc);
    public sealed virtual void FlushAppenders();
    private BaseFileAppender GetAppender(string fileName);
    public sealed virtual Nullable`1<DateTime> GetFileCreationTimeSource(string filePath, Nullable`1<DateTime> fallbackTimeSource);
    public sealed virtual Nullable`1<DateTime> GetFileLastWriteTimeUtc(string filePath);
    public sealed virtual Nullable`1<long> GetFileLength(string filePath);
    public sealed virtual BaseFileAppender InvalidateAppender(string filePath);
    private void CloseAppender(BaseFileAppender appender, string reason, bool lastAppender);
    public sealed virtual void Dispose();
}
internal interface NLog.Internal.FileAppenders.ICreateFileParameters {
    public int FileOpenRetryCount { get; }
    public int FileOpenRetryDelay { get; }
    public bool ConcurrentWrites { get; }
    public bool CreateDirs { get; }
    public bool EnableFileDelete { get; }
    public int BufferSize { get; }
    public bool ForceManaged { get; }
    public Win32FileAttributes FileAttributes { get; }
    public bool IsArchivingEnabled { get; }
    public bool EnableFileDeleteSimpleMonitor { get; }
    public abstract virtual int get_FileOpenRetryCount();
    public abstract virtual int get_FileOpenRetryDelay();
    public abstract virtual bool get_ConcurrentWrites();
    public abstract virtual bool get_CreateDirs();
    public abstract virtual bool get_EnableFileDelete();
    public abstract virtual int get_BufferSize();
    public abstract virtual bool get_ForceManaged();
    public abstract virtual Win32FileAttributes get_FileAttributes();
    public abstract virtual bool get_IsArchivingEnabled();
    public abstract virtual bool get_EnableFileDeleteSimpleMonitor();
}
internal interface NLog.Internal.FileAppenders.IFileAppenderCache {
    public ICreateFileParameters CreateFileParameters { get; }
    public IFileAppenderFactory Factory { get; }
    public int Size { get; }
    public string ArchiveFilePatternToWatch { get; public set; }
    public abstract virtual ICreateFileParameters get_CreateFileParameters();
    public abstract virtual IFileAppenderFactory get_Factory();
    public abstract virtual int get_Size();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CheckCloseAppenders(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CheckCloseAppenders(EventHandler value);
    public abstract virtual BaseFileAppender AllocateAppender(string fileName);
    public abstract virtual void CloseAppenders(string reason);
    public abstract virtual void CloseExpiredAppenders(DateTime expireTimeUtc);
    public abstract virtual void FlushAppenders();
    public abstract virtual Nullable`1<DateTime> GetFileCreationTimeSource(string filePath, Nullable`1<DateTime> fallbackTimeSource);
    public abstract virtual Nullable`1<DateTime> GetFileLastWriteTimeUtc(string filePath);
    public abstract virtual Nullable`1<long> GetFileLength(string filePath);
    public abstract virtual BaseFileAppender InvalidateAppender(string filePath);
    public abstract virtual string get_ArchiveFilePatternToWatch();
    public abstract virtual void set_ArchiveFilePatternToWatch(string value);
    public abstract virtual void InvalidateAppendersForArchivedFiles();
}
internal interface NLog.Internal.FileAppenders.IFileAppenderFactory {
    public abstract virtual BaseFileAppender Open(string fileName, ICreateFileParameters parameters);
}
[SecuritySafeCriticalAttribute]
internal class NLog.Internal.FileAppenders.MutexMultiProcessFileAppender : BaseMutexFileAppender {
    public static IFileAppenderFactory TheFactory;
    private FileStream _fileStream;
    private Mutex _mutex;
    public MutexMultiProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static MutexMultiProcessFileAppender();
    public virtual void Write(Byte[] bytes, int offset, int count);
    public virtual void Close();
    public virtual void Flush();
    public virtual Nullable`1<DateTime> GetFileCreationTimeUtc();
    public virtual Nullable`1<long> GetFileLength();
}
[SecuritySafeCriticalAttribute]
internal class NLog.Internal.FileAppenders.NullAppender : BaseFileAppender {
    public static IFileAppenderFactory TheFactory;
    public NullAppender(string fileName, ICreateFileParameters createParameters);
    private static NullAppender();
    public virtual void Close();
    public virtual void Flush();
    public virtual Nullable`1<DateTime> GetFileCreationTimeUtc();
    public virtual Nullable`1<long> GetFileLength();
    public virtual void Write(Byte[] bytes, int offset, int count);
}
[SecuritySafeCriticalAttribute]
internal class NLog.Internal.FileAppenders.RetryingMultiProcessFileAppender : BaseMutexFileAppender {
    public static IFileAppenderFactory TheFactory;
    public RetryingMultiProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static RetryingMultiProcessFileAppender();
    public virtual void Write(Byte[] bytes, int offset, int count);
    public virtual void Flush();
    public virtual void Close();
    public virtual Nullable`1<DateTime> GetFileCreationTimeUtc();
    public virtual Nullable`1<long> GetFileLength();
}
[SecuritySafeCriticalAttribute]
internal class NLog.Internal.FileAppenders.SingleProcessFileAppender : BaseFileAppender {
    public static IFileAppenderFactory TheFactory;
    private FileStream _file;
    private bool _enableFileDeleteSimpleMonitor;
    private int _lastSimpleMonitorCheckTickCount;
    public SingleProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static SingleProcessFileAppender();
    public virtual void Write(Byte[] bytes, int offset, int count);
    public virtual void Flush();
    public virtual void Close();
    public virtual Nullable`1<DateTime> GetFileCreationTimeUtc();
    public virtual Nullable`1<long> GetFileLength();
}
[SecuritySafeCriticalAttribute]
internal class NLog.Internal.FileAppenders.WindowsMultiProcessFileAppender : BaseMutexFileAppender {
    public static IFileAppenderFactory TheFactory;
    private FileStream _fileStream;
    public WindowsMultiProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static WindowsMultiProcessFileAppender();
    private void CreateAppendOnlyFile(string fileName);
    public virtual void Write(Byte[] bytes, int offset, int count);
    public virtual void Close();
    public virtual void Flush();
    public virtual Nullable`1<DateTime> GetFileCreationTimeUtc();
    public virtual Nullable`1<long> GetFileLength();
}
[ExtensionAttribute]
internal static class NLog.Internal.FileInfoExt : object {
    [ExtensionAttribute]
public static DateTime GetLastWriteTimeUtc(FileInfo fileInfo);
    [ExtensionAttribute]
public static DateTime GetCreationTimeUtc(FileInfo fileInfo);
    [ExtensionAttribute]
public static DateTime LookupValidFileCreationTimeUtc(FileInfo fileInfo);
    [ExtensionAttribute]
public static DateTime LookupValidFileCreationTimeUtc(FileInfo fileInfo, Nullable`1<DateTime> fallbackTime);
}
internal static class NLog.Internal.FileInfoHelper : object {
    internal static Nullable`1<DateTime> LookupValidFileCreationTimeUtc(T fileInfo, Func`2<T, Nullable`1<DateTime>> primary, Func`2<T, Nullable`1<DateTime>> fallback, Func`2<T, Nullable`1<DateTime>> finalFallback);
}
internal class NLog.Internal.FilePathLayout : object {
    private static Char[] DirectorySeparatorChars;
    private static HashSet`1<char> InvalidFileNameChars;
    private Layout _layout;
    private FilePathKind _filePathKind;
    private string _baseDir;
    private string _cleanedFixedResult;
    private bool _cleanupInvalidChars;
    private string _cachedPrevRawFileName;
    private string _cachedPrevCleanFileName;
    public bool IsFixedFilePath { get; }
    public FilePathLayout(Layout layout, bool cleanupInvalidChars, FilePathKind filePathKind);
    private static FilePathLayout();
    public bool get_IsFixedFilePath();
    public Layout GetLayout();
    private string GetRenderedFileName(LogEventInfo logEvent, StringBuilder reusableBuilder);
    private string GetCleanFileName(string rawFileName);
    public sealed virtual string Render(LogEventInfo logEvent);
    internal string RenderWithBuilder(LogEventInfo logEvent, StringBuilder reusableBuilder);
    internal static FilePathKind DetectFilePathKind(SimpleLayout pathLayout);
    internal static FilePathKind DetectFilePathKind(string path, bool isFixedText);
    private static bool IsLayoutRenderer(string path, bool isFixedText);
    private static bool IsAbsoluteStartChar(char firstChar);
    private static string CleanupInvalidFilePath(string filePath);
}
internal static class NLog.Internal.FormatHelper : object {
    internal static string ConvertToString(object o, IFormatProvider formatProvider);
    private static bool SkipFormattableToString(object value);
    internal static string TryFormatToString(object value, string format, IFormatProvider formatProvider);
}
internal static class NLog.Internal.Guard : object {
    internal static T ThrowIfNull(T arg, string param);
    internal static string ThrowIfNullOrEmpty(string arg, string param);
}
internal interface NLog.Internal.IConfigurationManager {
    public NameValueCollection AppSettings { get; }
    public abstract virtual NameValueCollection get_AppSettings();
    public abstract virtual ConnectionStringSettings LookupConnectionString(string name);
}
internal interface NLog.Internal.ILogMessageFormatter {
    public Nullable`1<bool> EnableMessageTemplateParser { get; }
    public abstract virtual Nullable`1<bool> get_EnableMessageTemplateParser();
    public abstract virtual string FormatMessage(LogEventInfo logEvent);
    public abstract virtual bool HasProperties(LogEventInfo logEvent);
    public abstract virtual void AppendFormattedMessage(LogEventInfo logEvent, StringBuilder builder);
}
internal interface NLog.Internal.INetworkInterfaceRetriever {
    public NetworkInterface[] AllNetworkInterfaces { get; }
    public abstract virtual NetworkInterface[] get_AllNetworkInterfaces();
}
internal interface NLog.Internal.IRawValue {
    public abstract virtual bool TryGetRawValue(LogEventInfo logEvent, Object& value);
}
internal interface NLog.Internal.IRenderable {
    public abstract virtual string Render(LogEventInfo logEvent);
}
internal interface NLog.Internal.ISmtpClient {
    public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public int Timeout { get; public set; }
    public ICredentialsByHost Credentials { get; public set; }
    public bool EnableSsl { get; public set; }
    public string PickupDirectoryLocation { get; public set; }
    public abstract virtual SmtpDeliveryMethod get_DeliveryMethod();
    public abstract virtual void set_DeliveryMethod(SmtpDeliveryMethod value);
    public abstract virtual string get_Host();
    public abstract virtual void set_Host(string value);
    public abstract virtual int get_Port();
    public abstract virtual void set_Port(int value);
    public abstract virtual int get_Timeout();
    public abstract virtual void set_Timeout(int value);
    public abstract virtual ICredentialsByHost get_Credentials();
    public abstract virtual void set_Credentials(ICredentialsByHost value);
    public abstract virtual bool get_EnableSsl();
    public abstract virtual void set_EnableSsl(bool value);
    public abstract virtual void Send(MailMessage msg);
    public abstract virtual string get_PickupDirectoryLocation();
    public abstract virtual void set_PickupDirectoryLocation(string value);
}
internal interface NLog.Internal.IStringValueRenderer {
    public abstract virtual string GetFormattedString(LogEventInfo logEvent);
}
internal interface NLog.Internal.ISupportsInitialize {
    public abstract virtual void Initialize(LoggingConfiguration configuration);
    public abstract virtual void Close();
}
internal interface NLog.Internal.ITargetWithFilterChain {
    public abstract virtual void WriteToLoggerTargets(Type loggerType, LogEventInfo logEvent, LogFactory logFactory);
}
internal class NLog.Internal.LogMessageStringFormatter : object {
    public static LogMessageStringFormatter Default;
    [CompilerGeneratedAttribute]
private LogMessageFormatter <MessageFormatter>k__BackingField;
    public LogMessageFormatter MessageFormatter { get; }
    public Nullable`1<bool> EnableMessageTemplateParser { get; }
    private static LogMessageStringFormatter();
    [CompilerGeneratedAttribute]
public LogMessageFormatter get_MessageFormatter();
    public sealed virtual Nullable`1<bool> get_EnableMessageTemplateParser();
    public sealed virtual void AppendFormattedMessage(LogEventInfo logEvent, StringBuilder builder);
    public sealed virtual string FormatMessage(LogEventInfo logEvent);
    internal static bool HasParameters(LogEventInfo logEvent);
    public sealed virtual bool HasProperties(LogEventInfo logEvent);
}
internal class NLog.Internal.LogMessageTemplateFormatter : object {
    private static StringBuilderPool _builderPool;
    private IServiceProvider _serviceProvider;
    private IValueFormatter _valueFormatter;
    private bool _forceTemplateRenderer;
    private bool _singleTargetOnly;
    [CompilerGeneratedAttribute]
private LogMessageFormatter <MessageFormatter>k__BackingField;
    private IValueFormatter ValueFormatter { get; }
    public LogMessageFormatter MessageFormatter { get; }
    public Nullable`1<bool> EnableMessageTemplateParser { get; }
    public LogMessageTemplateFormatter(IServiceProvider serviceProvider, bool forceTemplateRenderer, bool singleTargetOnly);
    private static LogMessageTemplateFormatter();
    private IValueFormatter get_ValueFormatter();
    [CompilerGeneratedAttribute]
public LogMessageFormatter get_MessageFormatter();
    public sealed virtual Nullable`1<bool> get_EnableMessageTemplateParser();
    public sealed virtual bool HasProperties(LogEventInfo logEvent);
    public sealed virtual void AppendFormattedMessage(LogEventInfo logEvent, StringBuilder builder);
    public sealed virtual string FormatMessage(LogEventInfo logEvent);
    private void AppendToBuilder(LogEventInfo logEvent, StringBuilder builder);
    private void Render(string template, IFormatProvider formatProvider, Object[] parameters, StringBuilder sb, IList`1& messageTemplateParameters);
    private void RenderHole(StringBuilder sb, Hole hole, IFormatProvider formatProvider, object value, bool legacy);
    private void RenderHole(StringBuilder sb, CaptureType captureType, string holeFormat, IFormatProvider formatProvider, object value, bool legacy);
    private static void RenderPadding(StringBuilder sb, int holeAlignment, int holeStartPosition);
}
internal class NLog.Internal.MruCache`2 : object {
    private Dictionary`2<TKey, MruCacheItem<TKey, TValue>> _dictionary;
    private int _maxCapacity;
    private long _currentVersion;
    public MruCache`2(int maxCapacity);
    public bool TryAddValue(TKey key, TValue value);
    private void PruneCache();
    public bool TryGetValue(TKey key, TValue& value);
}
internal class NLog.Internal.MultiFileWatcher : object {
    private Dictionary`2<string, FileSystemWatcher> _watcherMap;
    [CompilerGeneratedAttribute]
private NotifyFilters <NotifyFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemEventHandler FileChanged;
    public NotifyFilters NotifyFilters { get; public set; }
    public MultiFileWatcher(NotifyFilters notifyFilters);
    [CompilerGeneratedAttribute]
public NotifyFilters get_NotifyFilters();
    [CompilerGeneratedAttribute]
public void set_NotifyFilters(NotifyFilters value);
    [CompilerGeneratedAttribute]
public void add_FileChanged(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FileChanged(FileSystemEventHandler value);
    public sealed virtual void Dispose();
    public void StopWatching();
    public void StopWatching(string fileName);
    public void Watch(IEnumerable`1<string> fileNames);
    public void Watch(string fileName);
    private bool TryAddWatch(string fileName, string directory, string fileFilter);
    private void StopWatching(FileSystemWatcher watcher);
    private static void OnWatcherError(object source, ErrorEventArgs e);
    private void OnFileChanged(object source, FileSystemEventArgs e);
}
internal static class NLog.Internal.MutexDetector : object {
    private static Nullable`1<bool> _supportsSharableMutex;
    public static bool SupportsSharableMutex { get; }
    public static bool get_SupportsSharableMutex();
    private static bool ResolveSupportsSharableMutex();
}
internal class NLog.Internal.MySmtpClient : SmtpClient {
    private sealed virtual override SmtpDeliveryMethod NLog.Internal.ISmtpClient.get_DeliveryMethod();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_DeliveryMethod(SmtpDeliveryMethod value);
    private sealed virtual override string NLog.Internal.ISmtpClient.get_Host();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_Host(string value);
    private sealed virtual override int NLog.Internal.ISmtpClient.get_Port();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_Port(int value);
    private sealed virtual override int NLog.Internal.ISmtpClient.get_Timeout();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_Timeout(int value);
    private sealed virtual override ICredentialsByHost NLog.Internal.ISmtpClient.get_Credentials();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_Credentials(ICredentialsByHost value);
    private sealed virtual override bool NLog.Internal.ISmtpClient.get_EnableSsl();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_EnableSsl(bool value);
    private sealed virtual override void NLog.Internal.ISmtpClient.Send(MailMessage msg);
    private sealed virtual override string NLog.Internal.ISmtpClient.get_PickupDirectoryLocation();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_PickupDirectoryLocation(string value);
}
internal static class NLog.Internal.NativeMethods : object {
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static int GetCurrentProcessId();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetModuleFileName(IntPtr hModule, StringBuilder lpFilename, int nSize);
}
internal class NLog.Internal.NetworkInterfaceRetriever : object {
    public NetworkInterface[] AllNetworkInterfaces { get; }
    public sealed virtual NetworkInterface[] get_AllNetworkInterfaces();
}
internal class NLog.Internal.NetworkSenders.HttpNetworkSender : QueuedNetworkSender {
    private Uri _addressUri;
    [CompilerGeneratedAttribute]
private IWebRequestFactory <HttpRequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SendTimeout>k__BackingField;
    internal IWebRequestFactory HttpRequestFactory { get; internal set; }
    internal TimeSpan SendTimeout { get; internal set; }
    public HttpNetworkSender(string url);
    [CompilerGeneratedAttribute]
internal IWebRequestFactory get_HttpRequestFactory();
    [CompilerGeneratedAttribute]
internal void set_HttpRequestFactory(IWebRequestFactory value);
    [CompilerGeneratedAttribute]
internal TimeSpan get_SendTimeout();
    [CompilerGeneratedAttribute]
internal void set_SendTimeout(TimeSpan value);
    protected virtual void BeginRequest(NetworkRequestArgs eventArgs);
    private void CompleteRequest(AsyncContinuation asyncContinuation);
}
internal interface NLog.Internal.NetworkSenders.INetworkSenderFactory {
    public abstract virtual QueuedNetworkSender Create(string url, int maxQueueSize, NetworkTargetQueueOverflowAction onQueueOverflow, int maxMessageSize, SslProtocols sslProtocols, TimeSpan keepAliveTime, TimeSpan sendTimeout);
}
internal interface NLog.Internal.NetworkSenders.ISocket {
    public abstract virtual bool ConnectAsync(SocketAsyncEventArgs args);
    public abstract virtual void Close();
    public abstract virtual bool SendAsync(SocketAsyncEventArgs args);
    public abstract virtual bool SendToAsync(SocketAsyncEventArgs args);
}
internal interface NLog.Internal.NetworkSenders.IWebRequestFactory {
    public abstract virtual WebRequest CreateWebRequest(Uri address);
}
internal abstract class NLog.Internal.NetworkSenders.NetworkSender : object {
    private static int currentSendTime;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastSendTime>k__BackingField;
    public string Address { get; private set; }
    public int LastSendTime { get; private set; }
    protected NetworkSender(string url);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(string value);
    [CompilerGeneratedAttribute]
public int get_LastSendTime();
    [CompilerGeneratedAttribute]
private void set_LastSendTime(int value);
    public void Initialize();
    public void Close(AsyncContinuation continuation);
    public void FlushAsync(AsyncContinuation continuation);
    public void Send(Byte[] bytes, int offset, int length, AsyncContinuation asyncContinuation);
    public sealed virtual void Dispose();
    protected virtual void DoInitialize();
    protected virtual void DoClose(AsyncContinuation continuation);
    protected virtual void DoFlush(AsyncContinuation continuation);
    protected abstract virtual void DoSend(Byte[] bytes, int offset, int length, AsyncContinuation asyncContinuation);
    protected virtual IPAddress ResolveIpAddress(Uri uri, AddressFamily addressFamily);
    public virtual ISocket CheckSocket();
    private void Dispose(bool disposing);
}
internal class NLog.Internal.NetworkSenders.NetworkSenderFactory : object {
    public static INetworkSenderFactory Default;
    private static NetworkSenderFactory();
    public sealed virtual QueuedNetworkSender Create(string url, int maxQueueSize, NetworkTargetQueueOverflowAction onQueueOverflow, int maxMessageSize, SslProtocols sslProtocols, TimeSpan keepAliveTime, TimeSpan sendTimeout);
}
internal abstract class NLog.Internal.NetworkSenders.QueuedNetworkSender : NetworkSender {
    private Queue`1<NetworkRequestArgs> _pendingRequests;
    private Queue`1<NetworkRequestArgs> _activeRequests;
    private Exception _pendingError;
    private bool _asyncOperationInProgress;
    private AsyncContinuation _closeContinuation;
    private AsyncContinuation _flushContinuation;
    [CompilerGeneratedAttribute]
private int <MaxQueueSize>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkTargetQueueOverflowAction <OnQueueOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<NetworkLogEventDroppedEventArgs> LogEventDropped;
    public int MaxQueueSize { get; public set; }
    public NetworkTargetQueueOverflowAction OnQueueOverflow { get; public set; }
    protected QueuedNetworkSender(string url);
    [CompilerGeneratedAttribute]
public int get_MaxQueueSize();
    [CompilerGeneratedAttribute]
public void set_MaxQueueSize(int value);
    [CompilerGeneratedAttribute]
public NetworkTargetQueueOverflowAction get_OnQueueOverflow();
    [CompilerGeneratedAttribute]
public void set_OnQueueOverflow(NetworkTargetQueueOverflowAction value);
    [CompilerGeneratedAttribute]
public void add_LogEventDropped(EventHandler`1<NetworkLogEventDroppedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LogEventDropped(EventHandler`1<NetworkLogEventDroppedEventArgs> value);
    protected virtual void DoSend(Byte[] bytes, int offset, int length, AsyncContinuation asyncContinuation);
    protected virtual void DoFlush(AsyncContinuation continuation);
    protected virtual void DoClose(AsyncContinuation continuation);
    protected void BeginInitialize();
    protected Nullable`1<NetworkRequestArgs> EndRequest(AsyncContinuation asyncContinuation, Exception pendingException);
    protected abstract virtual void BeginRequest(NetworkRequestArgs eventArgs);
    private Nullable`1<NetworkRequestArgs> DequeueNextItem();
    private void SignalSocketFailedForPendingRequests(Exception pendingException);
    private void OnLogEventDropped(object sender, NetworkLogEventDroppedEventArgs logEventDroppedEventArgs);
}
internal class NLog.Internal.NetworkSenders.SocketProxy : object {
    private Socket _socket;
    public Socket UnderlyingSocket { get; }
    internal SocketProxy(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public Socket get_UnderlyingSocket();
    public sealed virtual void Close();
    public sealed virtual bool ConnectAsync(SocketAsyncEventArgs args);
    public sealed virtual bool SendAsync(SocketAsyncEventArgs args);
    public sealed virtual bool SendToAsync(SocketAsyncEventArgs args);
    public sealed virtual void Dispose();
}
internal class NLog.Internal.NetworkSenders.SslSocketProxy : object {
    private AsyncCallback _sendCompleted;
    private SocketProxy _socketProxy;
    private string _host;
    private SslProtocols _sslProtocol;
    private SslStream _sslStream;
    public SslSocketProxy(string host, SslProtocols sslProtocol, SocketProxy socketProxy);
    public sealed virtual void Close();
    public sealed virtual bool ConnectAsync(SocketAsyncEventArgs args);
    private void SocketProxySendCompleted(IAsyncResult asyncResult);
    private void SocketProxyConnectCompleted(object sender, SocketAsyncEventArgs e);
    private static SocketError GetSocketError(Exception ex);
    private static void AuthenticateAsClient(SslStream sslStream, string targetHost, SslProtocols enabledSslProtocols);
    private static bool UserCertificateValidationCallback(object sender, object certificate, object chain, SslPolicyErrors sslPolicyErrors);
    public sealed virtual bool SendAsync(SocketAsyncEventArgs args);
    public sealed virtual bool SendToAsync(SocketAsyncEventArgs args);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(IAsyncResult ar);
}
internal class NLog.Internal.NetworkSenders.TcpNetworkSender : QueuedNetworkSender {
    private static Nullable`1<bool> EnableKeepAliveSuccessful;
    private ISocket _socket;
    private EventHandler`1<SocketAsyncEventArgs> _socketOperationCompletedAsync;
    private Nullable`1<AsyncHelpersTask> _asyncBeginRequest;
    [CompilerGeneratedAttribute]
private AddressFamily <AddressFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <KeepAliveTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SendTimeout>k__BackingField;
    internal AddressFamily AddressFamily { get; internal set; }
    internal SslProtocols SslProtocols { get; internal set; }
    internal TimeSpan KeepAliveTime { get; internal set; }
    internal TimeSpan SendTimeout { get; internal set; }
    public TcpNetworkSender(string url, AddressFamily addressFamily);
    [CompilerGeneratedAttribute]
internal AddressFamily get_AddressFamily();
    [CompilerGeneratedAttribute]
internal void set_AddressFamily(AddressFamily value);
    [CompilerGeneratedAttribute]
internal SslProtocols get_SslProtocols();
    [CompilerGeneratedAttribute]
internal void set_SslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
internal TimeSpan get_KeepAliveTime();
    [CompilerGeneratedAttribute]
internal void set_KeepAliveTime(TimeSpan value);
    [CompilerGeneratedAttribute]
internal TimeSpan get_SendTimeout();
    [CompilerGeneratedAttribute]
internal void set_SendTimeout(TimeSpan value);
    protected internal virtual ISocket CreateSocket(string host, AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, TimeSpan sendTimeout);
    private static bool TryEnableKeepAlive(Socket underlyingSocket, int keepAliveTimeSeconds);
    private static bool TrySetSocketOption(Socket underlyingSocket, SocketOptionName socketOption, bool value);
    private static bool TrySetTcpOption(Socket underlyingSocket, SocketOptionName socketOption, int value);
    protected virtual void DoInitialize();
    protected virtual void DoClose(AsyncContinuation continuation);
    private void CloseSocket(AsyncContinuation continuation, Exception pendingException);
    protected virtual void BeginRequest(NetworkRequestArgs eventArgs);
    private void BeginRequestAsync(object state);
    private void BeginSocketRequest(SocketAsyncEventArgs args);
    private void SetSocketNetworkRequest(SocketAsyncEventArgs socketEventArgs, NetworkRequestArgs networkRequest);
    private void SocketOperationCompletedAsync(object sender, SocketAsyncEventArgs args);
    private SocketAsyncEventArgs SocketOperationCompleted(SocketAsyncEventArgs args);
    public virtual ISocket CheckSocket();
}
internal class NLog.Internal.NetworkSenders.UdpNetworkSender : QueuedNetworkSender {
    private ISocket _socket;
    private EndPoint _endpoint;
    private EventHandler`1<SocketAsyncEventArgs> _socketOperationCompletedAsync;
    private Nullable`1<AsyncHelpersTask> _asyncBeginRequest;
    [CompilerGeneratedAttribute]
private AddressFamily <AddressFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxMessageSize>k__BackingField;
    internal AddressFamily AddressFamily { get; internal set; }
    internal int MaxMessageSize { get; internal set; }
    public UdpNetworkSender(string url, AddressFamily addressFamily);
    [CompilerGeneratedAttribute]
internal AddressFamily get_AddressFamily();
    [CompilerGeneratedAttribute]
internal void set_AddressFamily(AddressFamily value);
    [CompilerGeneratedAttribute]
internal int get_MaxMessageSize();
    [CompilerGeneratedAttribute]
internal void set_MaxMessageSize(int value);
    protected internal virtual ISocket CreateSocket(IPAddress ipAddress);
    protected virtual void DoInitialize();
    protected virtual void DoClose(AsyncContinuation continuation);
    private void CloseSocket(AsyncContinuation continuation, Exception pendingException);
    protected virtual void BeginRequest(NetworkRequestArgs eventArgs);
    private void BeginRequestAsync(object state);
    private void BeginSocketRequest(SocketAsyncEventArgs args);
    private void SetSocketNetworkRequest(SocketAsyncEventArgs socketEventArgs, NetworkRequestArgs networkRequest);
    private void SocketOperationCompletedAsync(object sender, SocketAsyncEventArgs args);
    private SocketAsyncEventArgs SocketOperationCompleted(SocketAsyncEventArgs args);
    public virtual ISocket CheckSocket();
}
internal class NLog.Internal.NetworkSenders.WebRequestFactory : object {
    [CompilerGeneratedAttribute]
private static IWebRequestFactory <Instance>k__BackingField;
    public static IWebRequestFactory Instance { get; }
    private static WebRequestFactory();
    [CompilerGeneratedAttribute]
public static IWebRequestFactory get_Instance();
    public sealed virtual WebRequest CreateWebRequest(Uri address);
}
internal static class NLog.Internal.ObjectGraphScanner : object {
    public static List`1<T> FindReachableObjects(ConfigurationItemFactory configFactory, bool aggressiveSearch, Object[] rootObjects);
    private static void ScanProperties(ConfigurationItemFactory configFactory, bool aggressiveSearch, object targetObject, List`1<T> result, int level, HashSet`1<object> visitedObjects);
    private static void ScanPropertyForObject(ConfigurationItemFactory configFactory, bool aggressiveSearch, object propValue, PropertyInfo prop, List`1<T> result, int level, HashSet`1<object> visitedObjects);
    private static void ScanPropertiesList(ConfigurationItemFactory configFactory, bool aggressiveSearch, IList list, List`1<T> result, int level, HashSet`1<object> visitedObjects);
    private static IList ConvertEnumerableToList(IEnumerable enumerable, HashSet`1<object> visitedObjects);
}
internal class NLog.Internal.ObjectHandleSerializer : object {
    private object _wrapped;
    public ObjectHandleSerializer(object wrapped);
    protected ObjectHandleSerializer(SerializationInfo info, StreamingContext context);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public object Unwrap();
}
internal class NLog.Internal.ObjectPropertyPath : ValueType {
    [CompilerGeneratedAttribute]
private String[] <PathNames>k__BackingField;
    public String[] PathNames { get; private set; }
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_PathNames();
    [CompilerGeneratedAttribute]
private void set_PathNames(String[] value);
    public string get_Value();
    public void set_Value(string value);
}
internal class NLog.Internal.ObjectReflectionCache : object {
    private MruCache`2<Type, ObjectPropertyInfos> _objectTypeCache;
    private IServiceProvider _serviceProvider;
    private IObjectTypeTransformer _objectTypeTransformation;
    private static BindingFlags PublicProperties;
    private MruCache`2<Type, ObjectPropertyInfos> ObjectTypeCache { get; }
    private IObjectTypeTransformer ObjectTypeTransformation { get; }
    public ObjectReflectionCache(IServiceProvider serviceProvider);
    private MruCache`2<Type, ObjectPropertyInfos> get_ObjectTypeCache();
    private IObjectTypeTransformer get_ObjectTypeTransformation();
    private sealed virtual override object NLog.IObjectTypeTransformer.TryTransformObject(object obj);
    public ObjectPropertyList LookupObjectProperties(object value);
    public bool TryGetObjectProperty(object value, String[] objectPath, Object& foundValue);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow reflection of message args", "IL2072")]
[UnconditionalSuppressMessageAttribute("Trimming - Allow reflection of message args", "IL2075")]
public bool TryLookupExpandoObject(object value, ObjectPropertyList& objectPropertyList);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow reflection of message args", "IL2072")]
private static ObjectPropertyInfos BuildObjectPropertyInfos(object value);
    private static bool ConvertSimpleToString(Type objectType);
    private static PropertyInfo[] GetPublicProperties(Type type);
    private static FastPropertyLookup[] BuildFastLookup(PropertyInfo[] properties, bool includeType);
    private static Dictionary`2<string, object> DynamicObjectToDict(DynamicObject d);
    private static bool IsGenericDictionaryEnumeratorType(Type interfaceType);
}
internal static class NLog.Internal.PathHelpers : object {
    private static Char[] DirectorySeparatorChars;
    private static PathHelpers();
    internal static string CombinePaths(string path, string dir, string file);
    public static string TrimDirectorySeparators(string path);
    public static bool IsTempDir(string directory, string tempDir);
}
internal static class NLog.Internal.PlatformDetector : object {
    private static Nullable`1<RuntimeOS> _currentOS;
    private static Nullable`1<bool> _isMono;
    public static RuntimeOS CurrentOS { get; }
    public static bool IsWin32 { get; }
    public static bool IsUnix { get; }
    public static bool IsMono { get; }
    public static RuntimeOS get_CurrentOS();
    public static bool get_IsWin32();
    public static bool get_IsUnix();
    public static bool get_IsMono();
    private static RuntimeOS GetCurrentRuntimeOS();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class NLog.Internal.PropertiesDictionary : object {
    private Dictionary`2<object, PropertyValue> _eventProperties;
    private IList`1<MessageTemplateParameter> _messageProperties;
    private static DictionaryCollection EmptyKeyCollection;
    private static DictionaryCollection EmptyValueCollection;
    private bool IsEmpty { get; }
    private Dictionary`2<object, PropertyValue> EventProperties { get; }
    public IList`1<MessageTemplateParameter> MessageProperties { get; internal set; }
    public object Item { get; public set; }
    public ICollection`1<object> Keys { get; }
    public ICollection`1<object> Values { get; }
    private DictionaryCollection KeyCollection { get; }
    private DictionaryCollection ValueCollection { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public PropertiesDictionary(IList`1<MessageTemplateParameter> messageParameters);
    public PropertiesDictionary(IReadOnlyList`1<KeyValuePair`2<object, object>> eventProperties);
    private static PropertiesDictionary();
    private bool get_IsEmpty();
    private Dictionary`2<object, PropertyValue> get_EventProperties();
    public IList`1<MessageTemplateParameter> get_MessageProperties();
    internal void set_MessageProperties(IList`1<MessageTemplateParameter> value);
    private IList`1<MessageTemplateParameter> SetMessageProperties(IList`1<MessageTemplateParameter> newMessageProperties, IList`1<MessageTemplateParameter> oldMessageProperties);
    private static void RemoveOldMessageProperties(IList`1<MessageTemplateParameter> oldMessageProperties, Dictionary`2<object, PropertyValue> eventProperties);
    private static Dictionary`2<object, PropertyValue> BuildEventProperties(IList`1<MessageTemplateParameter> messageProperties);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection`1<object> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    private DictionaryCollection get_KeyCollection();
    private DictionaryCollection get_ValueCollection();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Add(KeyValuePair`2<object, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<object, object> item);
    public sealed virtual bool ContainsKey(object key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    internal PropertyDictionaryEnumerator GetPropertyEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<object, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Remove(object key);
    public sealed virtual bool Remove(KeyValuePair`2<object, object> item);
    public sealed virtual bool TryGetValue(object key, Object& value);
    private bool TryLookupMessagePropertyValue(object key, Object& propertyValue);
    private static bool VerifyUniqueMessageTemplateParametersFast(IList`1<MessageTemplateParameter> parameterList);
    private static void InsertMessagePropertiesIntoEmptyDictionary(IList`1<MessageTemplateParameter> messageProperties, Dictionary`2<object, PropertyValue> eventProperties);
    internal static string GenerateUniquePropertyName(string originalName, IDictionary`2<TKey, TValue> properties, Func`3<string, IDictionary`2<TKey, TValue>, bool> containsKey);
}
internal static class NLog.Internal.PropertyHelper : object {
    private static Dictionary`2<Type, Dictionary`2<string, PropertyInfo>> _parameterInfoCache;
    private static Dictionary`2<Type, Func`3<string, ConfigurationItemFactory, object>> _propertyConversionMapper;
    private static RequiredParameterAttribute _requiredParameterAttribute;
    private static ArrayParameterAttribute _arrayParameterAttribute;
    private static DefaultParameterAttribute _defaultParameterAttribute;
    private static NLogConfigurationIgnorePropertyAttribute _ignorePropertyAttribute;
    private static NLogConfigurationItemAttribute _configPropertyAttribute;
    private static FlagsAttribute _flagsAttribute;
    private static PropertyHelper();
    private static Dictionary`2<Type, Func`3<string, ConfigurationItemFactory, object>> BuildPropertyConversionMapper();
    internal static void SetPropertyFromString(object targetObject, PropertyInfo propInfo, string stringValue, ConfigurationItemFactory configurationItemFactory);
    internal static void SetPropertyValueForObject(object targetObject, object value, PropertyInfo propInfo);
    internal static bool TryGetPropertyInfo(ConfigurationItemFactory configFactory, object obj, string propertyName, PropertyInfo& result);
    [UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2075")]
[ObsoleteAttribute("Instead use RegisterType<T>, as dynamic Assembly loading will be moved out. Marked obsolete with NLog v5.2")]
private static bool TryGetPropertyInfo(object obj, string propertyName, PropertyInfo& result);
    internal static Type GetArrayItemType(PropertyInfo propInfo);
    internal static bool IsConfigurationItemType(ConfigurationItemFactory configFactory, Type type);
    internal static Dictionary`2<string, PropertyInfo> GetAllConfigItemProperties(ConfigurationItemFactory configFactory, Type type);
    private static Dictionary`2<string, PropertyInfo> TryLookupConfigItemProperties(ConfigurationItemFactory configFactory, Type type);
    internal static void CheckRequiredParameters(ConfigurationItemFactory configFactory, object o);
    internal static bool IsSimplePropertyType(Type type);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow converting option-values from config", "IL2070")]
private static bool TryImplicitConversion(Type resultType, string value, Object& result);
    private static bool TryNLogSpecificConversion(Type propertyType, string value, ConfigurationItemFactory configurationItemFactory, Object& newValue);
    private static bool TryGetEnumValue(Type resultType, string value, Object& result);
    private static object TryParseCultureInfo(string stringValue);
    private static object TryParseEncodingValue(string stringValue, ConfigurationItemFactory configurationItemFactory);
    private static object TryParseLayoutValue(string stringValue, ConfigurationItemFactory configurationItemFactory);
    private static object TryParseConditionValue(string stringValue, ConfigurationItemFactory configurationItemFactory);
    private static bool TryFlatListConversion(object obj, PropertyInfo propInfo, string valueRaw, ConfigurationItemFactory configurationItemFactory, Object& newValue);
    private static bool TryCreateCollectionObject(object obj, PropertyInfo propInfo, string valueRaw, Object& collectionObject, MethodInfo& collectionAddMethod, Type& collectionItemType);
    private static object CreateCollectionHashSetInstance(Type collectionItemType, object hashSetComparer, MethodInfo& collectionAddMethod);
    private static object CreateCollectionListInstance(Type collectionItemType, MethodInfo& collectionAddMethod);
    private static object ExtractHashSetComparer(object obj, PropertyInfo propInfo);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow converting option-values from config", "IL2026")]
[UnconditionalSuppressMessageAttribute("Trimming - Allow converting option-values from config", "IL2067")]
[UnconditionalSuppressMessageAttribute("Trimming - Allow converting option-values from config", "IL2072")]
internal static bool TryTypeConverterConversion(Type type, string value, Object& newValue);
    private static bool TryCreatePropertyInfoDictionary(ConfigurationItemFactory configFactory, Type objectType, Dictionary`2& result);
    private static bool HasCustomConfigurationProperties(Type objectType, Dictionary`2<string, PropertyInfo> objectProperties);
    private static bool IncludeConfigurationPropertyInfo(Type objectType, PropertyInfo propInfo, bool checkDefaultValue, String& overridePropertyName);
}
[ExtensionAttribute]
internal static class NLog.Internal.ReflectionHelpers : object {
    [ExtensionAttribute]
public static bool IsStaticClass(Type type);
    public static LateBoundMethod CreateLateBoundMethod(MethodInfo methodInfo);
    public static LateBoundConstructor CreateLateBoundConstructor(ConstructorInfo constructor);
    private static IEnumerable`1<Expression> BuildParameterList(MethodBase methodInfo, ParameterExpression parametersParameter);
    private static MethodCallExpression BuildMethodCall(MethodInfo methodInfo, ParameterExpression instanceParameter, IEnumerable`1<Expression> parameterExpressions);
    private static UnaryExpression CreateParameterExpression(ParameterInfo parameterInfo, Expression expression);
    [ExtensionAttribute]
public static bool IsPublic(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TAttr GetFirstCustomAttribute(Type type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TAttr GetFirstCustomAttribute(PropertyInfo info);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TAttr GetFirstCustomAttribute(Assembly assembly);
    [ExtensionAttribute]
public static IEnumerable`1<TAttr> GetCustomAttributes(Type type, bool inherit);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static bool IsValidPublicProperty(PropertyInfo p);
    [ExtensionAttribute]
public static object GetPropertyValue(PropertyInfo p, object instance);
    [ExtensionAttribute]
public static MethodInfo GetDelegateInfo(Delegate method);
}
internal class NLog.Internal.RegexHelper : object {
    private Regex _regex;
    private string _searchText;
    private string _regexPattern;
    private bool _wholeWords;
    private bool _ignoreCase;
    private bool _simpleSearchText;
    [CompilerGeneratedAttribute]
private bool <CompileRegex>k__BackingField;
    public string SearchText { get; public set; }
    public string RegexPattern { get; public set; }
    public bool CompileRegex { get; public set; }
    public bool WholeWords { get; public set; }
    public bool IgnoreCase { get; public set; }
    public Regex Regex { get; }
    public string get_SearchText();
    public void set_SearchText(string value);
    public string get_RegexPattern();
    public void set_RegexPattern(string value);
    [CompilerGeneratedAttribute]
public bool get_CompileRegex();
    [CompilerGeneratedAttribute]
public void set_CompileRegex(bool value);
    public bool get_WholeWords();
    public void set_WholeWords(bool value);
    public bool get_IgnoreCase();
    public void set_IgnoreCase(bool value);
    public Regex get_Regex();
    private void ResetRegex();
    private RegexOptions GetRegexOptions();
    public string Replace(string input, string replacement);
    public MatchCollection Matches(string input);
}
internal class NLog.Internal.ReusableAsyncLogEventList : ReusableObjectCreator`1<IList`1<AsyncLogEventInfo>> {
    public ReusableAsyncLogEventList(int initialCapacity);
}
internal class NLog.Internal.ReusableBufferCreator : ReusableObjectCreator`1<Char[]> {
    public ReusableBufferCreator(int initialCapacity);
}
internal class NLog.Internal.ReusableBuilderCreator : ReusableObjectCreator`1<StringBuilder> {
    private static int MaxBuilderCapacity;
    private static void ResetCapacity(StringBuilder stringBuilder);
}
internal class NLog.Internal.ReusableObjectCreator`1 : object {
    protected T _reusableObject;
    private Action`1<T> _clearObject;
    private Func`1<T> _createObject;
    protected ReusableObjectCreator`1(Func`1<T> createObject, Action`1<T> clearObject);
    public LockOject<T> Allocate();
    private void Deallocate(T reusableObject);
}
internal class NLog.Internal.ReusableStreamCreator : ReusableObjectCreator`1<MemoryStream> {
    public ReusableStreamCreator(bool batchStream);
    private static void ResetCapacity(MemoryStream memoryStream);
    private static void ResetBatchCapacity(MemoryStream memoryStream);
    private sealed virtual override void System.IDisposable.Dispose();
}
internal enum NLog.Internal.RuntimeOS : Enum {
    public int value__;
    public static RuntimeOS Unknown;
    public static RuntimeOS Linux;
    public static RuntimeOS Windows9x;
    public static RuntimeOS WindowsNT;
    public static RuntimeOS MacOSX;
}
internal class NLog.Internal.ScopeContextPropertyEnumerator`1 : ValueType {
    private IEnumerator`1<KeyValuePair`2<string, object>> _scopeEnumerator;
    private IReadOnlyList`1<KeyValuePair`2<string, object>> _scopeList;
    private int _scopeIndex;
    private Enumerator<string, object> _dictionaryEnumerator;
    public KeyValuePair`2<string, object> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ScopeContextPropertyEnumerator`1(IEnumerable`1<KeyValuePair`2<string, TValue>> scopeProperties);
    public static void CopyScopePropertiesToDictionary(IReadOnlyCollection`1<KeyValuePair`2<string, TValue>> parentContext, Dictionary`2<string, object> scopeDictionary);
    public static bool HasUniqueCollectionKeys(IEnumerable`1<KeyValuePair`2<string, TValue>> scopeProperties, IEqualityComparer`1<string> keyComparer);
    [IteratorStateMachineAttribute("NLog.Internal.ScopeContextPropertyEnumerator`1/<CreateScopeEnumerable>d__7")]
private static IEnumerable`1<KeyValuePair`2<string, object>> CreateScopeEnumerable(IEnumerable`1<KeyValuePair`2<string, TValue>> scopeProperties);
    public sealed virtual KeyValuePair`2<string, object> get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class NLog.Internal.SetupBuilder : object {
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    public LogFactory LogFactory { get; }
    internal SetupBuilder(LogFactory logFactory);
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_LogFactory();
}
internal class NLog.Internal.SetupConfigurationLoggingRuleBuilder : object {
    [CompilerGeneratedAttribute]
private LoggingRule <LoggingRule>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    public LoggingRule LoggingRule { get; }
    public LoggingConfiguration Configuration { get; }
    public LogFactory LogFactory { get; }
    public IList`1<Target> Targets { get; }
    private Target System.Collections.Generic.IList<NLog.Targets.Target>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<NLog.Targets.Target>.Count { get; }
    private bool System.Collections.Generic.ICollection<NLog.Targets.Target>.IsReadOnly { get; }
    public SetupConfigurationLoggingRuleBuilder(LogFactory logFactory, LoggingConfiguration configuration, string loggerNamePattern, string ruleName);
    [CompilerGeneratedAttribute]
public sealed virtual LoggingRule get_LoggingRule();
    [CompilerGeneratedAttribute]
public sealed virtual LoggingConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_LogFactory();
    public sealed virtual IList`1<Target> get_Targets();
    private sealed virtual override Target System.Collections.Generic.IList<NLog.Targets.Target>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<NLog.Targets.Target>.set_Item(int index, Target value);
    private sealed virtual override int System.Collections.Generic.ICollection<NLog.Targets.Target>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<NLog.Targets.Target>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<NLog.Targets.Target>.Add(Target item);
    private sealed virtual override void System.Collections.Generic.ICollection<NLog.Targets.Target>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<NLog.Targets.Target>.Contains(Target item);
    private sealed virtual override void System.Collections.Generic.ICollection<NLog.Targets.Target>.CopyTo(Target[] array, int arrayIndex);
    private sealed virtual override IEnumerator`1<Target> System.Collections.Generic.IEnumerable<NLog.Targets.Target>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<NLog.Targets.Target>.IndexOf(Target item);
    private sealed virtual override void System.Collections.Generic.IList<NLog.Targets.Target>.Insert(int index, Target item);
    private sealed virtual override bool System.Collections.Generic.ICollection<NLog.Targets.Target>.Remove(Target item);
    private sealed virtual override void System.Collections.Generic.IList<NLog.Targets.Target>.RemoveAt(int index);
}
internal class NLog.Internal.SetupConfigurationTargetBuilder : object {
    private IList`1<Target> _targets;
    private string _targetName;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    public LoggingConfiguration Configuration { get; }
    public LogFactory LogFactory { get; }
    public IList`1<Target> Targets { get; }
    private Target System.Collections.Generic.IList<NLog.Targets.Target>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<NLog.Targets.Target>.Count { get; }
    private bool System.Collections.Generic.ICollection<NLog.Targets.Target>.IsReadOnly { get; }
    public SetupConfigurationTargetBuilder(LogFactory logFactory, LoggingConfiguration configuration, string targetName);
    [CompilerGeneratedAttribute]
public sealed virtual LoggingConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_LogFactory();
    public sealed virtual IList`1<Target> get_Targets();
    private void UpdateTargetName(Target item);
    private sealed virtual override Target System.Collections.Generic.IList<NLog.Targets.Target>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<NLog.Targets.Target>.set_Item(int index, Target value);
    private sealed virtual override int System.Collections.Generic.ICollection<NLog.Targets.Target>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<NLog.Targets.Target>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<NLog.Targets.Target>.Add(Target item);
    private sealed virtual override void System.Collections.Generic.ICollection<NLog.Targets.Target>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<NLog.Targets.Target>.Contains(Target item);
    private sealed virtual override void System.Collections.Generic.ICollection<NLog.Targets.Target>.CopyTo(Target[] array, int arrayIndex);
    private sealed virtual override IEnumerator`1<Target> System.Collections.Generic.IEnumerable<NLog.Targets.Target>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<NLog.Targets.Target>.IndexOf(Target item);
    private sealed virtual override void System.Collections.Generic.IList<NLog.Targets.Target>.Insert(int index, Target item);
    private sealed virtual override bool System.Collections.Generic.ICollection<NLog.Targets.Target>.Remove(Target item);
    private sealed virtual override void System.Collections.Generic.IList<NLog.Targets.Target>.RemoveAt(int index);
}
internal class NLog.Internal.SetupExtensionsBuilder : object {
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    public LogFactory LogFactory { get; }
    internal SetupExtensionsBuilder(LogFactory logFactory);
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_LogFactory();
}
internal class NLog.Internal.SetupInternalLoggerBuilder : object {
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    public LogFactory LogFactory { get; }
    internal SetupInternalLoggerBuilder(LogFactory logFactory);
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_LogFactory();
}
internal class NLog.Internal.SetupLoadConfigurationBuilder : object {
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    internal LoggingConfiguration _configuration;
    public LogFactory LogFactory { get; }
    public LoggingConfiguration Configuration { get; public set; }
    internal SetupLoadConfigurationBuilder(LogFactory logFactory, LoggingConfiguration configuration);
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_LogFactory();
    public sealed virtual LoggingConfiguration get_Configuration();
    public sealed virtual void set_Configuration(LoggingConfiguration value);
}
internal class NLog.Internal.SetupLogFactoryBuilder : object {
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    public LogFactory LogFactory { get; }
    internal SetupLogFactoryBuilder(LogFactory logFactory);
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_LogFactory();
}
internal class NLog.Internal.SetupSerializationBuilder : object {
    [CompilerGeneratedAttribute]
private LogFactory <LogFactory>k__BackingField;
    public LogFactory LogFactory { get; }
    internal SetupSerializationBuilder(LogFactory logFactory);
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_LogFactory();
}
internal class NLog.Internal.SimpleStringReader : object {
    private string _text;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal int Position { get; internal set; }
    internal string Text { get; }
    public SimpleStringReader(string text);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(int value);
    internal string get_Text();
    internal int Peek();
    internal int Read();
    internal string Substring(int startIndex, int endIndex);
    internal string ReadUntilMatch(Func`2<int, bool> charFinder);
}
internal class NLog.Internal.SingleCallContinuation : object {
    internal static AsyncContinuation Completed;
    private AsyncContinuation _asyncContinuation;
    public SingleCallContinuation(AsyncContinuation asyncContinuation);
    private static SingleCallContinuation();
    public void Function(Exception exception);
    private void CompletedFunction(Exception exception);
}
internal class NLog.Internal.SingleItemOptimizedHashSet`1 : ValueType {
    private T _singleItem;
    private HashSet`1<T> _hashset;
    private IEqualityComparer`1<T> _comparer;
    private IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SingleItemOptimizedHashSet`1(T singleItem, SingleItemOptimizedHashSet`1<T> existing, IEqualityComparer`1<T> comparer);
    private IEqualityComparer`1<T> get_Comparer();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("NLog.Internal.SingleItemOptimizedHashSet`1/<SingleItemEnumerator>d__17")]
private IEnumerator`1<T> SingleItemEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class NLog.Internal.SortHelpers : object {
    [ExtensionAttribute]
public static Dictionary`2<TKey, List`1<TValue>> BucketSort(IEnumerable`1<TValue> inputs, KeySelector`2<TValue, TKey> keySelector);
    [ExtensionAttribute]
public static ReadOnlySingleBucketDictionary`2<TKey, IList`1<TValue>> BucketSort(IList`1<TValue> inputs, KeySelector`2<TValue, TKey> keySelector);
    [ExtensionAttribute]
public static ReadOnlySingleBucketDictionary`2<TKey, IList`1<TValue>> BucketSort(IList`1<TValue> inputs, KeySelector`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
    private static Dictionary`2<TKey, IList`1<TValue>> CreateBucketDictionaryWithValue(IList`1<TValue> inputs, IEqualityComparer`1<TKey> keyComparer, int currentIndex, TKey firstBucketKey, TKey nextBucketKey);
}
[ExtensionAttribute]
internal static class NLog.Internal.StackTraceUsageUtils : object {
    private static Assembly nlogAssembly;
    private static Assembly mscorlibAssembly;
    private static Assembly systemAssembly;
    private static StackTraceUsageUtils();
    public static StackTraceUsage GetStackTraceUsage(bool includeFileName, int skipFrames, bool captureStackTrace);
    [ExtensionAttribute]
public static int GetFrameCount(StackTrace strackTrace);
    public static string GetStackFrameMethodName(MethodBase method, bool includeMethodInfo, bool cleanAsyncMoveNext, bool cleanAnonymousDelegates);
    public static string GetStackFrameMethodClassName(MethodBase method, bool includeNameSpace, bool cleanAsyncMoveNext, bool cleanAnonymousDelegates);
    private static string GetNamespaceFromTypeAssembly(Type callerClassType);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow callsite logic", "IL2026")]
public static MethodBase GetStackMethod(StackFrame stackFrame);
    public static string GetClassFullName();
    public static string GetClassFullName(StackFrame stackFrame);
    private static string GetClassFullName(StackTrace stackTrace);
    public static Assembly LookupAssemblyFromMethod(MethodBase method);
    public static string LookupClassNameFromStackFrame(StackFrame stackFrame);
}
[ExtensionAttribute]
internal static class NLog.Internal.StreamHelpers : object {
    [ExtensionAttribute]
public static void CopyAndSkipBom(Stream input, Stream output, Encoding encoding);
    [ExtensionAttribute]
public static void Copy(Stream input, Stream output);
    [ExtensionAttribute]
public static void CopyWithOffset(Stream input, Stream output, int offset);
}
[ExtensionAttribute]
internal static class NLog.Internal.StringBuilderExt : object {
    private static Char[] charToInt;
    internal static int Iso8601_MaxDigitCount;
    private static StringBuilderExt();
    [ExtensionAttribute]
public static void AppendFormattedValue(StringBuilder builder, object value, string format, IFormatProvider formatProvider, IValueFormatter valueFormatter);
    [ExtensionAttribute]
public static void AppendInvariant(StringBuilder builder, int value);
    [ExtensionAttribute]
public static void AppendInvariant(StringBuilder builder, UInt32 value);
    private static int CalculateDigitCount(UInt32 value);
    private static void ApppendValueWithDigitCount(StringBuilder builder, UInt32 value, int digitCount);
    [ExtensionAttribute]
public static void AppendXmlDateTimeUtcRoundTripFixed(StringBuilder builder, DateTime dateTime);
    [ExtensionAttribute]
public static void AppendXmlDateTimeUtcRoundTrip(StringBuilder builder, DateTime dateTime);
    [ExtensionAttribute]
private static void AppendXmlDateTimeUtcRoundTrip(StringBuilder builder, DateTime dateTime, int fraction, int max_digit_count);
    [ExtensionAttribute]
public static void ClearBuilder(StringBuilder builder);
    [ExtensionAttribute]
public static void CopyToStream(StringBuilder builder, MemoryStream ms, Encoding encoding, Char[] transformBuffer);
    [ExtensionAttribute]
public static void CopyToBuffer(StringBuilder builder, Char[] destination, int destinationIndex);
    [ExtensionAttribute]
public static void CopyTo(StringBuilder builder, StringBuilder destination);
    [ExtensionAttribute]
public static int IndexOf(StringBuilder builder, char needle, int startPos);
    [ExtensionAttribute]
public static int IndexOfAny(StringBuilder builder, Char[] needles, int startPos);
    private static bool CharArrayContains(char searchChar, Char[] needles);
    [ExtensionAttribute]
public static bool EqualTo(StringBuilder builder, StringBuilder other);
    [ExtensionAttribute]
public static bool EqualTo(StringBuilder builder, string other);
    [ExtensionAttribute]
internal static void Append2DigitsZeroPadded(StringBuilder builder, int number);
    [ExtensionAttribute]
internal static void Append4DigitsZeroPadded(StringBuilder builder, int number);
    [ExtensionAttribute]
internal static void AppendNumericInvariant(StringBuilder sb, IConvertible value, TypeCode objTypeCode);
    private static void AppendDecimalInvariant(StringBuilder sb, decimal decimalValue);
    private static void AppendDoubleInvariant(StringBuilder sb, double doubleValue);
    private static void AppendFloatInvariant(StringBuilder sb, float floatValue);
    [ExtensionAttribute]
public static void TrimRight(StringBuilder sb, int startPos);
}
internal class NLog.Internal.StringBuilderPool : object {
    private StringBuilder _fastPool;
    private StringBuilder[] _slowPool;
    private int _maxBuilderCapacity;
    public StringBuilderPool(int poolCapacity, int initialBuilderCapacity, int maxBuilderCapacity);
    public ItemHolder Acquire();
    private void Release(StringBuilder stringBuilder, int poolIndex);
}
[ExtensionAttribute]
internal static class NLog.Internal.StringHelpers : object {
    [ContractAnnotationAttribute("value:null => true")]
internal static bool IsNullOrWhiteSpace(string value);
    [ExtensionAttribute]
internal static String[] SplitAndTrimTokens(string value, char delimiter);
    public static string Replace(string str, string oldValue, string newValue, StringComparison comparison);
    internal static string Join(string separator, IEnumerable`1<string> values);
    internal static bool IsNullOrEmptyString(object objectValue);
}
[ExtensionAttribute]
internal static class NLog.Internal.StringSplitter : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> SplitQuoted(string text, char splitChar, char quoteChar, char escapeChar);
    [IteratorStateMachineAttribute("NLog.Internal.StringSplitter/<SplitQuoted2>d__1")]
private static IEnumerable`1<string> SplitQuoted2(string text, char splitChar, char quoteChar, char escapeChar);
}
internal class NLog.Internal.TargetWithFilterChain : object {
    internal static TargetWithFilterChain[] NoTargetsByLevel;
    private MruCache`2<CallSiteKey, string> _callSiteClassNameCache;
    [CompilerGeneratedAttribute]
private Target <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Filter> <FilterChain>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetWithFilterChain <NextInChain>k__BackingField;
    [CompilerGeneratedAttribute]
private StackTraceUsage <StackTraceUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterResult <FilterDefaultAction>k__BackingField;
    public Target Target { get; }
    public IList`1<Filter> FilterChain { get; }
    public TargetWithFilterChain NextInChain { get; public set; }
    public StackTraceUsage StackTraceUsage { get; private set; }
    public FilterResult FilterDefaultAction { get; }
    public TargetWithFilterChain(Target target, IList`1<Filter> filterChain, FilterResult filterDefaultAction);
    private static TargetWithFilterChain();
    private static TargetWithFilterChain[] CreateLoggerConfiguration();
    [CompilerGeneratedAttribute]
public Target get_Target();
    [CompilerGeneratedAttribute]
public IList`1<Filter> get_FilterChain();
    [CompilerGeneratedAttribute]
public TargetWithFilterChain get_NextInChain();
    [CompilerGeneratedAttribute]
public void set_NextInChain(TargetWithFilterChain value);
    [CompilerGeneratedAttribute]
public StackTraceUsage get_StackTraceUsage();
    [CompilerGeneratedAttribute]
private void set_StackTraceUsage(StackTraceUsage value);
    [CompilerGeneratedAttribute]
public FilterResult get_FilterDefaultAction();
    internal StackTraceUsage PrecalculateStackTraceUsage();
    internal static TargetWithFilterChain[] BuildLoggerConfiguration(string loggerName, List`1<LoggingRule> loggingRules, LogLevel globalLogLevel);
    private static bool GetTargetsByLevelForLogger(string name, List`1<LoggingRule> loggingRules, LogLevel globalLogLevel, TargetWithFilterChain[] targetsByLevel, TargetWithFilterChain[] lastTargetsByLevel, Boolean[] suppressedLevels);
    private static bool LoggingRuleHasFinalMinLevelFilters(LoggingRule rule);
    private static void CollectFinalMinLevelFiltersFromRule(LoggingRule rule, IList`1& finalMinLevelWithFilters);
    private static TargetWithFilterChain AppendFinalMinLevelFilters(TargetWithFilterChain targetsByLevel, IList`1<Filter> finalMinLevelFilters, FilterResult finalMinLevelDefaultResult);
    private static bool AddTargetsFromLoggingRule(LoggingRule rule, string loggerName, LogLevel globalLogLevel, TargetWithFilterChain[] targetsByLevel, TargetWithFilterChain[] lastTargetsByLevel, Boolean[] suppressedLevels);
    private static bool SuppressLogLevel(LoggingRule rule, Boolean[] ruleLogLevels, LogLevel finalMinLevel, LogLevel globalLogLevel, int logLevelOrdinal, Boolean& suppressedLevels);
    private static TargetWithFilterChain CreateTargetChainFromLoggingRule(LoggingRule rule, Target target, TargetWithFilterChain existingTargets);
    internal bool TryCallSiteClassNameOptimization(StackTraceUsage stackTraceUsage, LogEventInfo logEvent);
    internal bool MustCaptureStackTrace(StackTraceUsage stackTraceUsage, LogEventInfo logEvent);
    internal bool TryRememberCallSiteClassName(LogEventInfo logEvent);
    internal bool TryLookupCallSiteClassName(LogEventInfo logEvent, String& callSiteClassName);
    public sealed virtual void WriteToLoggerTargets(Type loggerType, LogEventInfo logEvent, LogFactory logFactory);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class NLog.Internal.ThreadSafeDictionary`2 : object {
    private object _lockObject;
    private Dictionary`2<TKey, TValue> _dict;
    private Dictionary`2<TKey, TValue> _dictReadOnly;
    public TValue Item { get; public set; }
    public IEqualityComparer`1<TKey> Comparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ThreadSafeDictionary`2(IEqualityComparer`1<TKey> comparer);
    public ThreadSafeDictionary`2(ThreadSafeDictionary`2<TKey, TValue> source);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public void CopyFrom(IDictionary`2<TKey, TValue> source);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<TKey, TValue> GetEnumerator();
    private Dictionary`2<TKey, TValue> GetReadOnlyDict();
    private IDictionary`2<TKey, TValue> GetWritableDict(bool clearDictionary);
}
internal class NLog.Internal.TimeoutContinuation : object {
    private AsyncContinuation _asyncContinuation;
    private Timer _timeoutTimer;
    public TimeoutContinuation(AsyncContinuation asyncContinuation, TimeSpan timeout);
    public void Function(Exception exception);
    public sealed virtual void Dispose();
    private void StopTimer();
    private void TimerElapsed(object state);
}
internal static class NLog.Internal.UrlHelper : object {
    private static string RFC2396ReservedMarks;
    private static string RFC3986ReservedMarks;
    private static string RFC2396UnreservedMarks;
    private static string RFC3986UnreservedMarks;
    private static Char[] hexUpperChars;
    private static Char[] hexLowerChars;
    private static UrlHelper();
    public static void EscapeDataEncode(string source, StringBuilder target, EscapeEncodingOptions options);
    private static bool Contains(EscapeEncodingOptions options, EscapeEncodingOptions option);
    private static void WriteWideChars(StringBuilder target, Char[] charArray, Byte[] byteArray, Char[] hexChars);
    [ObsoleteAttribute("Instead use default Rfc2396 or Rfc3986. Marked obsolete with NLog v5.3")]
private static void HandleLegacyEncoding(StringBuilder target, char ch, Char[] hexChars);
    private static bool IsAllowedChar(EscapeEncodingOptions options, char ch);
    private static bool IsSimpleCharOrNumber(char ch);
    public static EscapeEncodingOptions GetUriStringEncodingFlags(bool escapeDataNLogLegacy, bool spaceAsPlus, bool escapeDataRfc3986);
}
internal static class NLog.Internal.Win32FileNativeMethods : object {
    public static int FILE_SHARE_READ;
    public static int FILE_SHARE_WRITE;
    public static int FILE_SHARE_DELETE;
    [DefaultDllImportSearchPathsAttribute("2048")]
public static SafeFileHandle CreateFile(string lpFileName, FileAccess dwDesiredAccess, int dwShareMode, IntPtr lpSecurityAttributes, CreationDisposition dwCreationDisposition, Win32FileAttributes dwFlagsAndAttributes, IntPtr hTemplateFile);
}
[AttributeUsageAttribute("32767")]
public class NLog.Internal.Xamarin.PreserveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AllMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Conditional>k__BackingField;
    public bool AllMembers { get; public set; }
    public bool Conditional { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllMembers();
    [CompilerGeneratedAttribute]
public void set_AllMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_Conditional();
    [CompilerGeneratedAttribute]
public void set_Conditional(bool value);
}
[ExtensionAttribute]
internal static class NLog.Internal.XmlHelper : object {
    private static Char[] XmlEscapeChars;
    private static Char[] XmlEscapeNewlineChars;
    private static Char[] DecimalScientificExponent;
    private static XmlHelper();
    private static string RemoveInvalidXmlChars(string text);
    private static string CreateValidXmlString(string text);
    internal static void PerformXmlEscapeWhenNeeded(StringBuilder builder, int startPos, bool xmlEncodeNewlines);
    private static bool RequiresXmlEscape(StringBuilder target, int startPos, bool xmlEncodeNewlines);
    internal static string EscapeXmlString(string text, bool xmlEncodeNewlines, StringBuilder result);
    private static bool SmallAndNoEscapeNeeded(string text, bool xmlEncodeNewlines);
    internal static string XmlConvertToStringSafe(object value);
    internal static string XmlConvertToString(object value);
    internal static string XmlConvertToString(float value);
    internal static string XmlConvertToString(double value);
    internal static string XmlConvertToString(decimal value);
    internal static string XmlConvertToElementName(string xmlElementName);
    private static string XmlConvertToString(object value, bool safeConversion);
    private static string XmlConvertToStringInvariant(object value, bool safeConversion);
    internal static string XmlConvertToString(IConvertible value, TypeCode objTypeCode, bool safeConversion);
    [ExtensionAttribute]
public static void WriteAttributeSafeString(XmlWriter writer, string localName, string value);
    [ExtensionAttribute]
public static void WriteElementSafeString(XmlWriter writer, string prefix, string localName, string ns, string value);
    [ExtensionAttribute]
public static void WriteSafeCData(XmlWriter writer, string value);
    private static string EnsureDecimalPlace(string text);
    [CompilerGeneratedAttribute]
internal static StringBuilder <XmlConvertToElementName>g__CreateStringBuilder|13_0(string orgValue, int i);
}
internal interface NLog.IObjectTypeTransformer {
    public abstract virtual object TryTransformObject(object obj);
}
[ObsoleteAttribute("ISuppress should be replaced with ILogger. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public interface NLog.ISuppress {
    public abstract virtual void Swallow(Action action);
    public abstract virtual T Swallow(Func`1<T> func);
    public abstract virtual T Swallow(Func`1<T> func, T fallback);
    public abstract virtual void Swallow(Task task);
    public abstract virtual Task SwallowAsync(Task task);
    public abstract virtual Task SwallowAsync(Func`1<Task> asyncAction);
    public abstract virtual Task`1<TResult> SwallowAsync(Func`1<Task`1<TResult>> asyncFunc);
    public abstract virtual Task`1<TResult> SwallowAsync(Func`1<Task`1<TResult>> asyncFunc, TResult fallback);
}
public interface NLog.IValueFormatter {
    public abstract virtual bool FormatValue(object value, string format, CaptureType captureType, IFormatProvider formatProvider, StringBuilder builder);
}
[LayoutRendererAttribute("all-event-properties")]
[ThreadAgnosticAttribute]
[ThreadAgnosticImmutableAttribute]
public class NLog.LayoutRenderers.AllEventPropertiesLayoutRenderer : LayoutRenderer {
    private string _format;
    private string _beforeKey;
    private string _afterKey;
    private string _afterValue;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEmptyValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeScopeProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Exclude>k__BackingField;
    private static LayoutRenderer _fixScopeContext;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public string Separator { get; public set; }
    public bool IncludeEmptyValues { get; public set; }
    public bool IncludeScopeProperties { get; public set; }
    public ISet`1<string> Exclude { get; public set; }
    public LayoutRenderer FixScopeContext { get; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static AllEventPropertiesLayoutRenderer();
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEmptyValues();
    [CompilerGeneratedAttribute]
public void set_IncludeEmptyValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeScopeProperties();
    [CompilerGeneratedAttribute]
public void set_IncludeScopeProperties(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(ISet`1<string> value);
    public LayoutRenderer get_FixScopeContext();
    public string get_Format();
    public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private bool AppendProperty(StringBuilder builder, object propertyKey, object propertyValue, string propertyFormat, IFormatProvider formatProvider, bool includeSeparator, bool checkForExclude, bool nonStandardFormat);
    private static bool IsEmptyPropertyValue(object value);
}
[AttributeUsageAttribute("4")]
public class NLog.LayoutRenderers.AmbientPropertyAttribute : NameBaseAttribute {
    public AmbientPropertyAttribute(string name);
}
[LayoutRendererAttribute("appdomain")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.AppDomainLayoutRenderer : LayoutRenderer {
    private static string ShortFormat;
    private static string LongFormat;
    private static string FriendlyFormat;
    private static string LongFormatCode;
    private static string ShortFormatCode;
    private static string FriendlyFormatCode;
    private IAppEnvironment _currentAppEnvironment;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    private string _assemblyName;
    [DefaultParameterAttribute]
public string Format { get; public set; }
    internal AppDomainLayoutRenderer(IAppEnvironment appEnvironment);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static string GetFormattingString(string format);
}
[LayoutRendererAttribute("appsetting")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.AppSettingLayoutRenderer : LayoutRenderer {
    private string _connectionStringName;
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationManager <ConfigurationManager>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Item { get; public set; }
    [ObsoleteAttribute("Allows easier conversion from NLog.Extended. Instead use Item-property. Marked obsolete in NLog 4.6")]
[EditorBrowsableAttribute("1")]
public string Name { get; public set; }
    public string Default { get; public set; }
    internal IConfigurationManager ConfigurationManager { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(string value);
    [CompilerGeneratedAttribute]
internal IConfigurationManager get_ConfigurationManager();
    [CompilerGeneratedAttribute]
internal void set_ConfigurationManager(IConfigurationManager value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue();
}
[LayoutRendererAttribute("assembly-version")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.AssemblyVersionLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyVersionType <Type>k__BackingField;
    private string _default;
    private string _format;
    private static string DefaultFormat;
    private string _assemblyVersion;
    [DefaultParameterAttribute]
public string Name { get; public set; }
    public AssemblyVersionType Type { get; public set; }
    public string Default { get; public set; }
    public string Format { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public AssemblyVersionType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(AssemblyVersionType value);
    public string get_Default();
    public void set_Default(string value);
    public string get_Format();
    public void set_Format(string value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private string ApplyFormatToVersion(string version);
    private string GenerateDefaultValue();
    private string GetVersion();
    protected virtual Assembly GetAssembly();
}
public enum NLog.LayoutRenderers.AssemblyVersionType : Enum {
    public int value__;
    public static AssemblyVersionType Assembly;
    public static AssemblyVersionType File;
    public static AssemblyVersionType Informational;
}
[LayoutRendererAttribute("basedir")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.BaseDirLayoutRenderer : LayoutRenderer {
    private string _baseDir;
    private string _processDir;
    private IAppEnvironment _appEnvironment;
    [CompilerGeneratedAttribute]
private bool <ProcessDir>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixTempDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    public bool ProcessDir { get; public set; }
    public bool FixTempDir { get; public set; }
    public string File { get; public set; }
    public string Dir { get; public set; }
    internal BaseDirLayoutRenderer(IAppEnvironment appEnvironment);
    [CompilerGeneratedAttribute]
public bool get_ProcessDir();
    [CompilerGeneratedAttribute]
public void set_ProcessDir(bool value);
    [CompilerGeneratedAttribute]
public bool get_FixTempDir();
    [CompilerGeneratedAttribute]
public void set_FixTempDir(bool value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private string GetFixedTempBaseDir(string baseDir);
    private string GetProcessDir();
}
[LayoutRendererAttribute("callsite-filename")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.CallSiteFileNameLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <IncludeSourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkipFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaptureStackTrace>k__BackingField;
    public bool IncludeSourcePath { get; public set; }
    public int SkipFrames { get; public set; }
    public bool CaptureStackTrace { get; public set; }
    private StackTraceUsage NLog.Config.IUsesStackTrace.StackTraceUsage { get; }
    [CompilerGeneratedAttribute]
public bool get_IncludeSourcePath();
    [CompilerGeneratedAttribute]
public void set_IncludeSourcePath(bool value);
    [CompilerGeneratedAttribute]
public int get_SkipFrames();
    [CompilerGeneratedAttribute]
public void set_SkipFrames(int value);
    [CompilerGeneratedAttribute]
public bool get_CaptureStackTrace();
    [CompilerGeneratedAttribute]
public void set_CaptureStackTrace(bool value);
    private sealed virtual override StackTraceUsage NLog.Config.IUsesStackTrace.get_StackTraceUsage();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("callsite")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.CallSiteLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CleanNamesOfAnonymousDelegates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CleanNamesOfAsyncContinuations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkipFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaptureStackTrace>k__BackingField;
    public bool ClassName { get; public set; }
    public bool IncludeNamespace { get; public set; }
    public bool MethodName { get; public set; }
    public bool CleanNamesOfAnonymousDelegates { get; public set; }
    public bool CleanNamesOfAsyncContinuations { get; public set; }
    public int SkipFrames { get; public set; }
    public bool FileName { get; public set; }
    public bool IncludeSourcePath { get; public set; }
    public bool CaptureStackTrace { get; public set; }
    private StackTraceUsage NLog.Config.IUsesStackTrace.StackTraceUsage { get; }
    [CompilerGeneratedAttribute]
public bool get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeNamespace();
    [CompilerGeneratedAttribute]
public void set_IncludeNamespace(bool value);
    [CompilerGeneratedAttribute]
public bool get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(bool value);
    [CompilerGeneratedAttribute]
public bool get_CleanNamesOfAnonymousDelegates();
    [CompilerGeneratedAttribute]
public void set_CleanNamesOfAnonymousDelegates(bool value);
    [CompilerGeneratedAttribute]
public bool get_CleanNamesOfAsyncContinuations();
    [CompilerGeneratedAttribute]
public void set_CleanNamesOfAsyncContinuations(bool value);
    [CompilerGeneratedAttribute]
public int get_SkipFrames();
    [CompilerGeneratedAttribute]
public void set_SkipFrames(int value);
    [CompilerGeneratedAttribute]
public bool get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSourcePath();
    [CompilerGeneratedAttribute]
public void set_IncludeSourcePath(bool value);
    [CompilerGeneratedAttribute]
public bool get_CaptureStackTrace();
    [CompilerGeneratedAttribute]
public void set_CaptureStackTrace(bool value);
    private sealed virtual override StackTraceUsage NLog.Config.IUsesStackTrace.get_StackTraceUsage();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private void AppendFileName(StringBuilder builder, string fileName, int lineNumber);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow callsite logic", "IL2026")]
private void AppendExceptionCallSite(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("callsite-linenumber")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.CallSiteLineNumberLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private int <SkipFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaptureStackTrace>k__BackingField;
    public int SkipFrames { get; public set; }
    public bool CaptureStackTrace { get; public set; }
    private StackTraceUsage NLog.Config.IUsesStackTrace.StackTraceUsage { get; }
    [CompilerGeneratedAttribute]
public int get_SkipFrames();
    [CompilerGeneratedAttribute]
public void set_SkipFrames(int value);
    [CompilerGeneratedAttribute]
public bool get_CaptureStackTrace();
    [CompilerGeneratedAttribute]
public void set_CaptureStackTrace(bool value);
    private sealed virtual override StackTraceUsage NLog.Config.IUsesStackTrace.get_StackTraceUsage();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private Nullable`1<int> GetLineNumber(LogEventInfo logEvent);
}
[LayoutRendererAttribute("counter")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.CounterLayoutRenderer : LayoutRenderer {
    private static Dictionary`2<string, long> sequences;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Sequence>k__BackingField;
    public long Value { get; public set; }
    public int Increment { get; public set; }
    public Layout Sequence { get; public set; }
    private static CounterLayoutRenderer();
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(long value);
    [CompilerGeneratedAttribute]
public int get_Increment();
    [CompilerGeneratedAttribute]
public void set_Increment(int value);
    [CompilerGeneratedAttribute]
public Layout get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(Layout value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private long GetNextValue(LogEventInfo logEvent);
    private static long GetNextSequenceValue(string sequenceName, long defaultValue, int increment);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
}
[LayoutRendererAttribute("currentdir")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.CurrentDirLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    public string File { get; public set; }
    public string Dir { get; public set; }
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue();
}
[LayoutRendererAttribute("date")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.DateLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    private string _format;
    private static string _lowTimeResolutionChars;
    private CachedDateFormatted _cachedDateFormatted;
    private bool _utcRoundRoundTrip;
    private Nullable`1<bool> _universalTime;
    public CultureInfo Culture { get; public set; }
    [DefaultParameterAttribute]
public string Format { get; public set; }
    public bool UniversalTime { get; public set; }
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    public string get_Format();
    public void set_Format(string value);
    public bool get_UniversalTime();
    public void set_UniversalTime(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue(DateTime timestamp, IFormatProvider formatProvider);
    private DateTime GetValue(LogEventInfo logEvent);
    private static bool IsLowTimeResolutionLayout(string dateTimeFormat);
    private static bool IsUtcRoundRountTripLayout(string dateTimeFormat, Nullable`1<bool> universalTime);
}
[LayoutRendererAttribute("db-null")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.DbNullLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
}
[LayoutRendererAttribute("dir-separator")]
[ThreadAgnosticAttribute]
[AppDomainFixedOutputAttribute]
public class NLog.LayoutRenderers.DirectorySeparatorLayoutRenderer : LayoutRenderer {
    private char _separatorChar;
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
}
[LayoutRendererAttribute("environment")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.EnvironmentLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Default>k__BackingField;
    private KeyValuePair`2<string, SimpleLayout> _cachedValue;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Variable { get; public set; }
    public string Default { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Variable();
    [CompilerGeneratedAttribute]
public void set_Variable(string value);
    [CompilerGeneratedAttribute]
public string get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private SimpleLayout GetSimpleLayout();
}
[LayoutRendererAttribute("environment-user")]
public class NLog.LayoutRenderers.EnvironmentUserLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultUser>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultDomain>k__BackingField;
    public bool UserName { get; public set; }
    public bool Domain { get; public set; }
    public string DefaultUser { get; public set; }
    public string DefaultDomain { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(bool value);
    [CompilerGeneratedAttribute]
public bool get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(bool value);
    [CompilerGeneratedAttribute]
public string get_DefaultUser();
    [CompilerGeneratedAttribute]
public void set_DefaultUser(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultDomain();
    [CompilerGeneratedAttribute]
public void set_DefaultDomain(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue();
    private string GetUserName();
    private string GetDomainName();
    private string GetValueSafe(Func`1<string> getValue, string defaultValue);
}
[LayoutRendererAttribute("event-properties")]
[LayoutRendererAttribute("event-property")]
[LayoutRendererAttribute("event-context")]
[ThreadAgnosticAttribute]
[ThreadAgnosticImmutableAttribute]
public class NLog.LayoutRenderers.EventPropertiesLayoutRenderer : LayoutRenderer {
    private ObjectReflectionCache _objectReflectionCache;
    private ObjectPropertyPath _objectPropertyPath;
    private object _item;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    private bool _ignoreCase;
    private ObjectReflectionCache ObjectReflectionCache { get; }
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Item { get; public set; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    public string ObjectPath { get; public set; }
    public bool IgnoreCase { get; public set; }
    private ObjectReflectionCache get_ObjectReflectionCache();
    public string get_Item();
    public void set_Item(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    public string get_ObjectPath();
    public void set_ObjectPath(string value);
    public bool get_IgnoreCase();
    public void set_IgnoreCase(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private bool TryGetValue(LogEventInfo logEvent, Object& value);
    private string GetStringValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("exceptiondata")]
[LayoutRendererAttribute("exception-data")]
[ThreadAgnosticAttribute]
[ThreadAgnosticImmutableAttribute]
public class NLog.LayoutRenderers.ExceptionDataLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BaseException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [DefaultParameterAttribute]
[RequiredParameterAttribute]
public string Item { get; public set; }
    public bool BaseException { get; public set; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    [CompilerGeneratedAttribute]
public bool get_BaseException();
    [CompilerGeneratedAttribute]
public void set_BaseException(bool value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    private Exception GetTopException(LogEventInfo logEvent);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("exception")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.ExceptionLayoutRenderer : LayoutRenderer {
    private string _format;
    private string _innerFormat;
    private static Dictionary`2<string, ExceptionRenderingFormat> _formatsMapping;
    private static Dictionary`2<ExceptionRenderingFormat, Action`4<ExceptionLayoutRenderer, StringBuilder, Exception, Exception>> _renderingfunctions;
    private static HashSet`1<string> ExcludeDefaultProperties;
    private ObjectReflectionCache _objectReflectionCache;
    private string _seperator;
    private string _exceptionDataSeparator;
    [CompilerGeneratedAttribute]
private int <MaxInnerExceptionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InnerExceptionSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BaseException>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlattenException>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ExceptionRenderingFormat> <Formats>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ExceptionRenderingFormat> <InnerFormats>k__BackingField;
    private ObjectReflectionCache ObjectReflectionCache { get; }
    [DefaultParameterAttribute]
public string Format { get; public set; }
    public string InnerFormat { get; public set; }
    public string Separator { get; public set; }
    public string ExceptionDataSeparator { get; public set; }
    public int MaxInnerExceptionLevel { get; public set; }
    public string InnerExceptionSeparator { get; public set; }
    public bool BaseException { get; public set; }
    public bool FlattenException { get; public set; }
    public List`1<ExceptionRenderingFormat> Formats { get; private set; }
    public List`1<ExceptionRenderingFormat> InnerFormats { get; private set; }
    private static ExceptionLayoutRenderer();
    private ObjectReflectionCache get_ObjectReflectionCache();
    public string get_Format();
    public void set_Format(string value);
    public string get_InnerFormat();
    public void set_InnerFormat(string value);
    public string get_Separator();
    public void set_Separator(string value);
    public string get_ExceptionDataSeparator();
    public void set_ExceptionDataSeparator(string value);
    [CompilerGeneratedAttribute]
public int get_MaxInnerExceptionLevel();
    [CompilerGeneratedAttribute]
public void set_MaxInnerExceptionLevel(int value);
    [CompilerGeneratedAttribute]
public string get_InnerExceptionSeparator();
    [CompilerGeneratedAttribute]
public void set_InnerExceptionSeparator(string value);
    [CompilerGeneratedAttribute]
public bool get_BaseException();
    [CompilerGeneratedAttribute]
public void set_BaseException(bool value);
    [CompilerGeneratedAttribute]
public bool get_FlattenException();
    [CompilerGeneratedAttribute]
public void set_FlattenException(bool value);
    [CompilerGeneratedAttribute]
public List`1<ExceptionRenderingFormat> get_Formats();
    [CompilerGeneratedAttribute]
private void set_Formats(List`1<ExceptionRenderingFormat> value);
    [CompilerGeneratedAttribute]
public List`1<ExceptionRenderingFormat> get_InnerFormats();
    [CompilerGeneratedAttribute]
private void set_InnerFormats(List`1<ExceptionRenderingFormat> value);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private Exception GetTopException(LogEventInfo logEvent);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static Exception GetPrimaryException(AggregateException aggregateException);
    private void AppendAggregateException(AggregateException primaryException, int currentLevel, StringBuilder builder);
    private int AppendInnerExceptionTree(Exception currentException, int currentLevel, StringBuilder sb);
    private void AppendInnerException(Exception currentException, StringBuilder builder);
    private void AppendException(Exception currentException, List`1<ExceptionRenderingFormat> renderFormats, StringBuilder builder, Exception aggregateException);
    protected virtual void AppendMessage(StringBuilder sb, Exception ex);
    [UnconditionalSuppressMessageAttribute("Trimming - Allow callsite logic", "IL2026")]
protected virtual void AppendMethod(StringBuilder sb, Exception ex);
    protected virtual void AppendStackTrace(StringBuilder sb, Exception ex);
    protected virtual void AppendToString(StringBuilder sb, Exception ex);
    protected virtual void AppendType(StringBuilder sb, Exception ex);
    protected virtual void AppendShortType(StringBuilder sb, Exception ex);
    protected virtual void AppendSource(StringBuilder sb, Exception ex);
    protected virtual void AppendHResult(StringBuilder sb, Exception ex);
    private void AppendData(StringBuilder builder, Exception ex, Exception aggregateException);
    protected virtual void AppendData(StringBuilder sb, Exception ex);
    protected virtual void AppendSerializeObject(StringBuilder sb, Exception ex);
    protected virtual void AppendProperties(StringBuilder sb, Exception ex);
    private static List`1<ExceptionRenderingFormat> CompileFormat(string formatSpecifier, string propertyName);
}
[LayoutRendererAttribute("file-contents")]
public class NLog.LayoutRenderers.FileContentsLayoutRenderer : LayoutRenderer {
    private object _lockObject;
    private string _lastFileName;
    private string _currentFileContents;
    [CompilerGeneratedAttribute]
private Layout <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [DefaultParameterAttribute]
public Layout FileName { get; public set; }
    public Encoding Encoding { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(Layout value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private string ReadFileContents(string fileName);
}
public class NLog.LayoutRenderers.FuncLayoutRenderer : LayoutRenderer {
    private Func`3<LogEventInfo, LoggingConfiguration, object> _renderMethod;
    [CompilerGeneratedAttribute]
private string <LayoutRendererName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public string LayoutRendererName { get; public set; }
    public Func`3<LogEventInfo, LoggingConfiguration, object> RenderMethod { get; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    protected FuncLayoutRenderer(string layoutRendererName);
    public FuncLayoutRenderer(string layoutRendererName, Func`3<LogEventInfo, LoggingConfiguration, object> renderMethod);
    [CompilerGeneratedAttribute]
public string get_LayoutRendererName();
    [CompilerGeneratedAttribute]
public void set_LayoutRendererName(string value);
    public Func`3<LogEventInfo, LoggingConfiguration, object> get_RenderMethod();
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue(LogEventInfo logEvent);
    protected virtual object RenderValue(LogEventInfo logEvent);
}
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.FuncThreadAgnosticLayoutRenderer : FuncLayoutRenderer {
    public FuncThreadAgnosticLayoutRenderer(string layoutRendererName, Func`3<LogEventInfo, LoggingConfiguration, object> renderMethod);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
}
[LayoutRendererAttribute("gc")]
public class NLog.LayoutRenderers.GarbageCollectorInfoLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private GarbageCollectorProperty <Property>k__BackingField;
    public GarbageCollectorProperty Property { get; public set; }
    [CompilerGeneratedAttribute]
public GarbageCollectorProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(GarbageCollectorProperty value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private long GetValue();
}
public enum NLog.LayoutRenderers.GarbageCollectorProperty : Enum {
    public int value__;
    public static GarbageCollectorProperty TotalMemory;
    public static GarbageCollectorProperty TotalMemoryForceCollection;
    public static GarbageCollectorProperty CollectionCount0;
    public static GarbageCollectorProperty CollectionCount1;
    public static GarbageCollectorProperty CollectionCount2;
    public static GarbageCollectorProperty MaxGeneration;
}
[LayoutRendererAttribute("gdc")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.GdcLayoutRenderer : LayoutRenderer {
    private CachedLookup _cachedLookup;
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Item { get; public set; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue(LogEventInfo logEvent);
    private object GetValue();
}
[LayoutRendererAttribute("guid")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.GuidLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GeneratedFromLogEvent>k__BackingField;
    public string Format { get; public set; }
    public bool GeneratedFromLogEvent { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public bool get_GeneratedFromLogEvent();
    [CompilerGeneratedAttribute]
public void set_GeneratedFromLogEvent(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue(LogEventInfo logEvent);
    private Guid GetValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("hostname")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.HostNameLayoutRenderer : LayoutRenderer {
    private string _hostName;
    protected virtual void InitializeLayoutRenderer();
    private static string GetHostName();
    private static string TryLookupValue(Func`1<string> lookupFunc, string lookupType);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("identity")]
public class NLog.LayoutRenderers.IdentityLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AuthType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAuthenticated>k__BackingField;
    public string Separator { get; public set; }
    public bool Name { get; public set; }
    public bool AuthType { get; public set; }
    public bool IsAuthenticated { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public bool get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(bool value);
    [CompilerGeneratedAttribute]
public bool get_AuthType();
    [CompilerGeneratedAttribute]
public void set_AuthType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAuthenticated();
    [CompilerGeneratedAttribute]
public void set_IsAuthenticated(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static IIdentity GetValue();
}
[LayoutRendererAttribute("install-context")]
public class NLog.LayoutRenderers.InstallContextLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Parameter>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Parameter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private object GetValue(LogEventInfo logEvent);
}
[NLogConfigurationItemAttribute]
public abstract class NLog.LayoutRenderers.LayoutRenderer : object {
    private bool _isInitialized;
    private IValueFormatter _valueFormatter;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <LoggingConfiguration>k__BackingField;
    protected LoggingConfiguration LoggingConfiguration { get; private set; }
    protected IValueFormatter ValueFormatter { get; }
    [CompilerGeneratedAttribute]
protected LoggingConfiguration get_LoggingConfiguration();
    [CompilerGeneratedAttribute]
private void set_LoggingConfiguration(LoggingConfiguration value);
    protected IValueFormatter get_ValueFormatter();
    public virtual string ToString();
    public sealed virtual string Render(LogEventInfo logEvent);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Initialize(LoggingConfiguration configuration);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Close();
    internal void Initialize(LoggingConfiguration configuration);
    private void Initialize();
    internal void Close();
    internal void RenderAppendBuilder(LogEventInfo logEvent, StringBuilder builder);
    protected abstract virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected IFormatProvider GetFormatProvider(LogEventInfo logEvent, IFormatProvider layoutCulture);
    protected CultureInfo GetCulture(LogEventInfo logEvent, CultureInfo layoutCulture);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(string name);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(string name, Type layoutRendererType);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(string name, Func`2<LogEventInfo, object> func);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(string name, Func`3<LogEventInfo, LoggingConfiguration, object> func);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(FuncLayoutRenderer layoutRenderer);
    protected T ResolveService();
}
[AttributeUsageAttribute("4")]
public class NLog.LayoutRenderers.LayoutRendererAttribute : NameBaseAttribute {
    public LayoutRendererAttribute(string name);
}
public enum NLog.LayoutRenderers.LevelFormat : Enum {
    public int value__;
    public static LevelFormat Name;
    public static LevelFormat FirstCharacter;
    public static LevelFormat OneLetter;
    public static LevelFormat Ordinal;
    public static LevelFormat FullName;
    public static LevelFormat TriLetter;
}
[LayoutRendererAttribute("level")]
[LayoutRendererAttribute("loglevel")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.LevelLayoutRenderer : LayoutRenderer {
    private static String[] _upperCaseMapper;
    [CompilerGeneratedAttribute]
private LevelFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Uppercase>k__BackingField;
    public LevelFormat Format { get; public set; }
    public bool Uppercase { get; public set; }
    private static LevelLayoutRenderer();
    [CompilerGeneratedAttribute]
public LevelFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(LevelFormat value);
    [CompilerGeneratedAttribute]
public bool get_Uppercase();
    [CompilerGeneratedAttribute]
public void set_Uppercase(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static string GetUpperCaseString(LogLevel level);
    private string GetFullNameString(LogLevel level);
    private string GetTriLetterString(LogLevel level);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private static LogLevel GetValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("literal")]
[ThreadAgnosticAttribute]
[AppDomainFixedOutputAttribute]
public class NLog.LayoutRenderers.LiteralLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [DefaultParameterAttribute]
public string Text { get; public set; }
    public LiteralLayoutRenderer(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.LiteralWithRawValueLayoutRenderer : LiteralLayoutRenderer {
    private bool _rawValueSuccess;
    private object _rawValue;
    public LiteralWithRawValueLayoutRenderer(string text, bool rawValueSuccess, object rawValue);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
}
[LayoutRendererAttribute("local-ip")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.LocalIpAddressLayoutRenderer : LayoutRenderer {
    private Nullable`1<AddressFamily> _addressFamily;
    private INetworkInterfaceRetriever _networkInterfaceRetriever;
    public AddressFamily AddressFamily { get; public set; }
    internal LocalIpAddressLayoutRenderer(INetworkInterfaceRetriever networkInterfaceRetriever);
    public AddressFamily get_AddressFamily();
    public void set_AddressFamily(AddressFamily value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private string LookupIpAddress();
    private static bool CheckOptimalNetworkScore(UnicastIPAddressInformation networkAddress, int networkScore, Int32& currentNetworkScore, String& currentIpAddress);
    private static int CalculateNetworkInterfaceScore(NetworkInterface networkInterface);
    private int CalculateNetworkAddressScore(UnicastIPAddressInformation networkAddress, IPInterfaceProperties ipProperties);
    private int CalculateIpAddressScore(IPAddress ipAddress);
    private static bool IsLoopbackAddressValue(IPAddress ipAddress);
}
[LayoutRendererAttribute("log4jxmlevent")]
public class NLog.LayoutRenderers.Log4JXmlEventLayoutRenderer : LayoutRenderer {
    private static DateTime log4jDateBase;
    private static string dummyNamespace;
    private static string dummyNamespaceRemover;
    private static string dummyNLogNamespace;
    private static string dummyNLogNamespaceRemover;
    private ScopeContextNestedStatesLayoutRenderer _scopeNestedLayoutRenderer;
    [CompilerGeneratedAttribute]
private bool <IncludeNLogData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentXml>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <FormattedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <AppInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeCallSite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSourceInfo>k__BackingField;
    private Nullable`1<bool> _includeMdc;
    private Nullable`1<bool> _includeMdlc;
    private Nullable`1<bool> _includeNdlc;
    private Nullable`1<bool> _includeNdc;
    private Nullable`1<bool> _includeScopeProperties;
    private Nullable`1<bool> _includeScopeNested;
    [CompilerGeneratedAttribute]
private bool <IncludeEventProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteThrowableCData>k__BackingField;
    private string _machineName;
    private XmlWriterSettings _xmlWriterSettings;
    [CompilerGeneratedAttribute]
private IList`1<NLogViewerParameterInfo> <Parameters>k__BackingField;
    public bool IncludeNLogData { get; public set; }
    public bool IndentXml { get; public set; }
    public Layout LoggerName { get; public set; }
    public Layout FormattedMessage { get; public set; }
    public Layout AppInfo { get; public set; }
    public bool IncludeCallSite { get; public set; }
    public bool IncludeSourceInfo { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdlc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeNdc. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeNdlc { get; public set; }
    public bool IncludeNdc { get; public set; }
    public bool IncludeScopeProperties { get; public set; }
    public bool IncludeScopeNested { get; public set; }
    public string ScopeNestedSeparator { get; public set; }
    [ObsoleteAttribute("Replaced by NdcItemSeparator. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public string NdlcItemSeparator { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeEventProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeAllProperties { get; public set; }
    public bool IncludeEventProperties { get; public set; }
    public string NdcItemSeparator { get; public set; }
    public bool WriteThrowableCData { get; public set; }
    private StackTraceUsage NLog.Config.IUsesStackTrace.StackTraceUsage { get; }
    internal IList`1<NLogViewerParameterInfo> Parameters { get; internal set; }
    internal Log4JXmlEventLayoutRenderer(IAppEnvironment appEnvironment);
    private static Log4JXmlEventLayoutRenderer();
    protected virtual void InitializeLayoutRenderer();
    [CompilerGeneratedAttribute]
public bool get_IncludeNLogData();
    [CompilerGeneratedAttribute]
public void set_IncludeNLogData(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentXml();
    [CompilerGeneratedAttribute]
public void set_IndentXml(bool value);
    [CompilerGeneratedAttribute]
public Layout get_LoggerName();
    [CompilerGeneratedAttribute]
public void set_LoggerName(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_FormattedMessage();
    [CompilerGeneratedAttribute]
public void set_FormattedMessage(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_AppInfo();
    [CompilerGeneratedAttribute]
public void set_AppInfo(Layout value);
    [CompilerGeneratedAttribute]
public bool get_IncludeCallSite();
    [CompilerGeneratedAttribute]
public void set_IncludeCallSite(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSourceInfo();
    [CompilerGeneratedAttribute]
public void set_IncludeSourceInfo(bool value);
    public bool get_IncludeMdc();
    public void set_IncludeMdc(bool value);
    public bool get_IncludeMdlc();
    public void set_IncludeMdlc(bool value);
    public bool get_IncludeNdlc();
    public void set_IncludeNdlc(bool value);
    public bool get_IncludeNdc();
    public void set_IncludeNdc(bool value);
    public sealed virtual bool get_IncludeScopeProperties();
    public sealed virtual void set_IncludeScopeProperties(bool value);
    public sealed virtual bool get_IncludeScopeNested();
    public sealed virtual void set_IncludeScopeNested(bool value);
    public string get_ScopeNestedSeparator();
    public void set_ScopeNestedSeparator(string value);
    public string get_NdlcItemSeparator();
    public void set_NdlcItemSeparator(string value);
    public bool get_IncludeAllProperties();
    public void set_IncludeAllProperties(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeEventProperties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeEventProperties(bool value);
    public string get_NdcItemSeparator();
    public void set_NdcItemSeparator(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteThrowableCData();
    [CompilerGeneratedAttribute]
public void set_WriteThrowableCData(bool value);
    private sealed virtual override StackTraceUsage NLog.Config.IUsesStackTrace.get_StackTraceUsage();
    [CompilerGeneratedAttribute]
internal IList`1<NLogViewerParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
internal void set_Parameters(IList`1<NLogViewerParameterInfo> value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private void AppendScopeContextProperties(XmlWriter xtw);
    private void AppendScopeContextNestedStates(XmlWriter xtw, LogEventInfo logEvent);
    private void AppendParameters(LogEventInfo logEvent, XmlWriter xtw);
    private void AppendCallSite(LogEventInfo logEvent, XmlWriter xtw);
    private static void AppendDataProperties(string prefix, string propertiesNamespace, XmlWriter xtw, LogEventInfo logEvent);
    private static void AppendDataProperty(XmlWriter xtw, string propertyKey, string propertyValue, string propertiesNamespace, string prefix);
}
[LayoutRendererAttribute("loggername")]
[LayoutRendererAttribute("logger")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.LoggerNameLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrefixName>k__BackingField;
    public bool ShortName { get; public set; }
    public bool PrefixName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ShortName();
    [CompilerGeneratedAttribute]
public void set_ShortName(bool value);
    [CompilerGeneratedAttribute]
public bool get_PrefixName();
    [CompilerGeneratedAttribute]
public void set_PrefixName(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private int TryGetLastDotForShortName(LogEventInfo logEvent);
}
[LayoutRendererAttribute("longdate")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.LongDateLayoutRenderer : LayoutRenderer {
    private Nullable`1<bool> _universalTime;
    public bool UniversalTime { get; public set; }
    public bool get_UniversalTime();
    public void set_UniversalTime(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private DateTime GetValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("machinename")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.MachineNameLayoutRenderer : LayoutRenderer {
    private string _machineName;
    protected virtual void InitializeLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("mdc")]
[ObsoleteAttribute("Replaced by ScopeContextPropertyLayoutRenderer ${scopeproperty}. Marked obsolete on NLog 5.0")]
public class NLog.LayoutRenderers.MdcLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Item { get; public set; }
    public string Format { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue(LogEventInfo logEvent);
    private object GetValue();
}
[LayoutRendererAttribute("mdlc")]
[ObsoleteAttribute("Replaced by ScopeContextPropertyLayoutRenderer ${scopeproperty}. Marked obsolete on NLog 5.0")]
public class NLog.LayoutRenderers.MdlcLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Item { get; public set; }
    public string Format { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue(LogEventInfo logEvent);
    private object GetValue();
}
[LayoutRendererAttribute("message")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.MessageLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <WithException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Raw>k__BackingField;
    public bool WithException { get; public set; }
    public string ExceptionSeparator { get; public set; }
    public bool Raw { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WithException();
    [CompilerGeneratedAttribute]
public void set_WithException(bool value);
    [CompilerGeneratedAttribute]
public string get_ExceptionSeparator();
    [CompilerGeneratedAttribute]
public void set_ExceptionSeparator(string value);
    [CompilerGeneratedAttribute]
public bool get_Raw();
    [CompilerGeneratedAttribute]
public void set_Raw(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static Exception GetPrimaryException(Exception exception);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
}
[LayoutRendererAttribute("ndc")]
[ObsoleteAttribute("Replaced by ScopeContextNestedStatesLayoutRenderer ${scopenested}. Marked obsolete on NLog 5.0")]
public class NLog.LayoutRenderers.NdcLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private int <TopFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BottomFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    public int TopFrames { get; public set; }
    public int BottomFrames { get; public set; }
    public string Separator { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TopFrames();
    [CompilerGeneratedAttribute]
public void set_TopFrames(int value);
    [CompilerGeneratedAttribute]
public int get_BottomFrames();
    [CompilerGeneratedAttribute]
public void set_BottomFrames(int value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static void AppendAsString(object message, IFormatProvider formatProvider, StringBuilder builder);
}
[LayoutRendererAttribute("ndlc")]
[ObsoleteAttribute("Replaced by ScopeContextNestedStatesLayoutRenderer ${scopenested}. Marked obsolete on NLog 5.0")]
public class NLog.LayoutRenderers.NdlcLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private int <TopFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BottomFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    public int TopFrames { get; public set; }
    public int BottomFrames { get; public set; }
    public string Separator { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TopFrames();
    [CompilerGeneratedAttribute]
public void set_TopFrames(int value);
    [CompilerGeneratedAttribute]
public int get_BottomFrames();
    [CompilerGeneratedAttribute]
public void set_BottomFrames(int value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static void AppendAsString(object message, IFormatProvider formatProvider, StringBuilder builder);
}
[LayoutRendererAttribute("ndlctiming")]
[ObsoleteAttribute("Replaced by ScopeContextTimingLayoutRenderer ${scopetiming}. Marked obsolete on NLog 5.0")]
public class NLog.LayoutRenderers.NdlcTimingLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <CurrentScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ScopeBeginTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public bool CurrentScope { get; public set; }
    public bool ScopeBeginTime { get; public set; }
    public string Format { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CurrentScope();
    [CompilerGeneratedAttribute]
public void set_CurrentScope(bool value);
    [CompilerGeneratedAttribute]
public bool get_ScopeBeginTime();
    [CompilerGeneratedAttribute]
public void set_ScopeBeginTime(bool value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("newline")]
[ThreadAgnosticAttribute]
[AppDomainFixedOutputAttribute]
public class NLog.LayoutRenderers.NewLineLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("nlogdir")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.NLogDirLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    private static string _nlogDir;
    private string _nlogCombinedPath;
    public string File { get; public set; }
    public string Dir { get; public set; }
    private static string NLogDir { get; }
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    private static string get_NLogDir();
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static string ResolveNLogDir();
}
[LayoutRendererAttribute("processdir")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.ProcessDirLayoutRenderer : LayoutRenderer {
    private string _processDir;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    public string File { get; public set; }
    public string Dir { get; public set; }
    internal ProcessDirLayoutRenderer(IAppEnvironment appEnvironment);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("processid")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.ProcessIdLayoutRenderer : LayoutRenderer {
    private int _processId;
    internal ProcessIdLayoutRenderer(IAppEnvironment appEnvironment);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
}
[LayoutRendererAttribute("processinfo")]
public class NLog.LayoutRenderers.ProcessInfoLayoutRenderer : LayoutRenderer {
    private Process _process;
    private LateBoundMethod _lateBoundPropertyGet;
    [CompilerGeneratedAttribute]
private ProcessInfoProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [DefaultParameterAttribute]
public ProcessInfoProperty Property { get; public set; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public ProcessInfoProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(ProcessInfoProperty value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private object GetValue();
}
public enum NLog.LayoutRenderers.ProcessInfoProperty : Enum {
    public int value__;
    public static ProcessInfoProperty BasePriority;
    public static ProcessInfoProperty ExitCode;
    public static ProcessInfoProperty ExitTime;
    public static ProcessInfoProperty Handle;
    public static ProcessInfoProperty HandleCount;
    public static ProcessInfoProperty HasExited;
    public static ProcessInfoProperty Id;
    public static ProcessInfoProperty MachineName;
    public static ProcessInfoProperty MainWindowHandle;
    public static ProcessInfoProperty MainWindowTitle;
    public static ProcessInfoProperty MaxWorkingSet;
    public static ProcessInfoProperty MinWorkingSet;
    public static ProcessInfoProperty NonPagedSystemMemorySize;
    public static ProcessInfoProperty NonPagedSystemMemorySize64;
    public static ProcessInfoProperty PagedMemorySize;
    public static ProcessInfoProperty PagedMemorySize64;
    public static ProcessInfoProperty PagedSystemMemorySize;
    public static ProcessInfoProperty PagedSystemMemorySize64;
    public static ProcessInfoProperty PeakPagedMemorySize;
    public static ProcessInfoProperty PeakPagedMemorySize64;
    public static ProcessInfoProperty PeakVirtualMemorySize;
    public static ProcessInfoProperty PeakVirtualMemorySize64;
    public static ProcessInfoProperty PeakWorkingSet;
    public static ProcessInfoProperty PeakWorkingSet64;
    public static ProcessInfoProperty PriorityBoostEnabled;
    public static ProcessInfoProperty PriorityClass;
    public static ProcessInfoProperty PrivateMemorySize;
    public static ProcessInfoProperty PrivateMemorySize64;
    public static ProcessInfoProperty PrivilegedProcessorTime;
    public static ProcessInfoProperty ProcessName;
    public static ProcessInfoProperty Responding;
    public static ProcessInfoProperty SessionId;
    public static ProcessInfoProperty StartTime;
    public static ProcessInfoProperty TotalProcessorTime;
    public static ProcessInfoProperty UserProcessorTime;
    public static ProcessInfoProperty VirtualMemorySize;
    public static ProcessInfoProperty VirtualMemorySize64;
    public static ProcessInfoProperty WorkingSet;
    public static ProcessInfoProperty WorkingSet64;
}
[LayoutRendererAttribute("processname")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.ProcessNameLayoutRenderer : LayoutRenderer {
    private string _processFilePath;
    private string _processBaseName;
    [CompilerGeneratedAttribute]
private bool <FullName>k__BackingField;
    public bool FullName { get; public set; }
    internal ProcessNameLayoutRenderer(IAppEnvironment appEnvironment);
    [CompilerGeneratedAttribute]
public bool get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("processtime")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.ProcessTimeLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public bool Invariant { get; public set; }
    [RequiredParameterAttribute]
public CultureInfo Culture { get; public set; }
    public bool get_Invariant();
    public void set_Invariant(bool value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    internal static void WriteTimestamp(StringBuilder builder, TimeSpan ts, CultureInfo culture);
    private static TimeSpan GetValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("scopeindent")]
public class NLog.LayoutRenderers.ScopeContextIndentLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private Layout <Indent>k__BackingField;
    [DefaultParameterAttribute]
public Layout Indent { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Indent();
    [CompilerGeneratedAttribute]
public void set_Indent(Layout value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("scopenested")]
public class NLog.LayoutRenderers.ScopeContextNestedStatesLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private int <TopFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BottomFrames>k__BackingField;
    private SimpleLayout _separator;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public int TopFrames { get; public set; }
    public int BottomFrames { get; public set; }
    public string Separator { get; public set; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TopFrames();
    [CompilerGeneratedAttribute]
public void set_TopFrames(int value);
    [CompilerGeneratedAttribute]
public int get_BottomFrames();
    [CompilerGeneratedAttribute]
public void set_BottomFrames(int value);
    public string get_Separator();
    public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private void AppendNestedStates(StringBuilder builder, IList`1<object> messages, int startPos, int endPos, LogEventInfo logEvent);
    private void AppendJsonFormattedValue(object nestedState, IFormatProvider formatProvider, StringBuilder builder, string separator, string itemSeparator);
    private bool AppendJsonProperty(string propertyName, object propertyValue, StringBuilder builder, string itemSeparator);
    private bool HasUniqueCollectionKeys(IEnumerable`1<KeyValuePair`2<string, object>> propertyList);
}
[LayoutRendererAttribute("scopeproperty")]
public class NLog.LayoutRenderers.ScopeContextPropertyLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Item { get; public set; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private string GetStringValue(LogEventInfo logEvent);
    private object GetValue();
}
[LayoutRendererAttribute("scopetiming")]
public class NLog.LayoutRenderers.ScopeContextTimingLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <CurrentScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public bool CurrentScope { get; public set; }
    public bool StartTime { get; public set; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CurrentScope();
    [CompilerGeneratedAttribute]
public void set_CurrentScope(bool value);
    [CompilerGeneratedAttribute]
public bool get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(bool value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static void RenderAppendDurationMs(StringBuilder builder, double scopeDurationMs);
}
[LayoutRendererAttribute("sequenceid")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.SequenceIdLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private static int GetValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("shortdate")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.ShortDateLayoutRenderer : LayoutRenderer {
    private Nullable`1<bool> _universalTime;
    private CachedDateFormatted _cachedDateFormatted;
    public bool UniversalTime { get; public set; }
    public bool get_UniversalTime();
    public void set_UniversalTime(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private string GetStringValue(LogEventInfo logEvent);
    private DateTime GetValue(LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
}
[LayoutRendererAttribute("userApplicationDataDir")]
public class NLog.LayoutRenderers.SpecialFolderApplicationDataLayoutRenderer : SpecialFolderLayoutRenderer {
}
[LayoutRendererAttribute("commonApplicationDataDir")]
public class NLog.LayoutRenderers.SpecialFolderCommonApplicationDataLayoutRenderer : SpecialFolderLayoutRenderer {
}
[LayoutRendererAttribute("specialfolder")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.SpecialFolderLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private SpecialFolder <Folder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    [DefaultParameterAttribute]
public SpecialFolder Folder { get; public set; }
    public string File { get; public set; }
    public string Dir { get; public set; }
    [CompilerGeneratedAttribute]
public SpecialFolder get_Folder();
    [CompilerGeneratedAttribute]
public void set_Folder(SpecialFolder value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    internal static string GetFolderPath(SpecialFolder folder);
    private static string GetFolderPathFromEnvironment(SpecialFolder folder);
    private static string GetFolderWindowsEnvironmentVariable(SpecialFolder folder);
}
[LayoutRendererAttribute("userLocalApplicationDataDir")]
public class NLog.LayoutRenderers.SpecialFolderLocalApplicationDataLayoutRenderer : SpecialFolderLayoutRenderer {
}
public enum NLog.LayoutRenderers.StackTraceFormat : Enum {
    public int value__;
    public static StackTraceFormat Raw;
    public static StackTraceFormat Flat;
    public static StackTraceFormat DetailedFlat;
}
[LayoutRendererAttribute("stacktrace")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.StackTraceLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private StackTraceFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TopFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkipFrames>k__BackingField;
    private SimpleLayout _separator;
    [CompilerGeneratedAttribute]
private bool <CaptureStackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Reverse>k__BackingField;
    public StackTraceFormat Format { get; public set; }
    public int TopFrames { get; public set; }
    public int SkipFrames { get; public set; }
    public string Separator { get; public set; }
    public bool CaptureStackTrace { get; public set; }
    public bool Reverse { get; public set; }
    private StackTraceUsage NLog.Config.IUsesStackTrace.StackTraceUsage { get; }
    [CompilerGeneratedAttribute]
public StackTraceFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(StackTraceFormat value);
    [CompilerGeneratedAttribute]
public int get_TopFrames();
    [CompilerGeneratedAttribute]
public void set_TopFrames(int value);
    [CompilerGeneratedAttribute]
public int get_SkipFrames();
    [CompilerGeneratedAttribute]
public void set_SkipFrames(int value);
    public string get_Separator();
    public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public bool get_CaptureStackTrace();
    [CompilerGeneratedAttribute]
public void set_CaptureStackTrace(bool value);
    [CompilerGeneratedAttribute]
public bool get_Reverse();
    [CompilerGeneratedAttribute]
public void set_Reverse(bool value);
    private sealed virtual override StackTraceUsage NLog.Config.IUsesStackTrace.get_StackTraceUsage();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private void AppendRaw(StringBuilder builder, StackFrameList stackFrameList, LogEventInfo logEvent);
    private void AppendFlat(StringBuilder builder, StackFrameList stackFrameList, LogEventInfo logEvent);
    private void AppendDetailedFlat(StringBuilder builder, StackFrameList stackFrameList, LogEventInfo logEvent);
}
[LayoutRendererAttribute("tempdir")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.TempDirLayoutRenderer : LayoutRenderer {
    private static string tempDir;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    public string File { get; public set; }
    public string Dir { get; public set; }
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("threadid")]
public class NLog.LayoutRenderers.ThreadIdLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static int GetValue();
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
}
[LayoutRendererAttribute("threadname")]
public class NLog.LayoutRenderers.ThreadNameLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static string GetStringValue();
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
}
[LayoutRendererAttribute("ticks")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.TicksLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private static long GetValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("time")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.TimeLayoutRenderer : LayoutRenderer {
    private Nullable`1<bool> _universalTime;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public bool UniversalTime { get; public set; }
    public bool Invariant { get; public set; }
    [RequiredParameterAttribute]
public CultureInfo Culture { get; public set; }
    public bool get_UniversalTime();
    public void set_UniversalTime(bool value);
    public bool get_Invariant();
    public void set_Invariant(bool value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private DateTime GetValue(LogEventInfo logEvent);
}
[LayoutRendererAttribute("activityid")]
public class NLog.LayoutRenderers.TraceActivityIdLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private static string GetStringValue();
    private static Guid GetValue();
}
[LayoutRendererAttribute("var")]
public class NLog.LayoutRenderers.VariableLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Default>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Name { get; public set; }
    public string Default { get; public set; }
    public Layout ActiveLayout { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(string value);
    public Layout get_ActiveLayout();
    protected virtual void InitializeLayoutRenderer();
    private bool TryGetLayout(Layout& layout);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("cached")]
[AmbientPropertyAttribute("Cached")]
[AmbientPropertyAttribute("ClearCache")]
[AmbientPropertyAttribute("CachedSeconds")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.CachedLayoutRendererWrapper : WrapperLayoutRendererBase {
    private object _lockObject;
    private string _cachedValue;
    private string _renderedCacheKey;
    private DateTime _cachedValueExpires;
    private Nullable`1<TimeSpan> _cachedValueTimeout;
    [CompilerGeneratedAttribute]
private bool <Cached>k__BackingField;
    [CompilerGeneratedAttribute]
private ClearCacheOption <ClearCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <CacheKey>k__BackingField;
    public bool Cached { get; public set; }
    public ClearCacheOption ClearCache { get; public set; }
    public Layout CacheKey { get; public set; }
    public int CachedSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Cached();
    [CompilerGeneratedAttribute]
public void set_Cached(bool value);
    [CompilerGeneratedAttribute]
public ClearCacheOption get_ClearCache();
    [CompilerGeneratedAttribute]
public void set_ClearCache(ClearCacheOption value);
    [CompilerGeneratedAttribute]
public Layout get_CacheKey();
    [CompilerGeneratedAttribute]
public void set_CacheKey(Layout value);
    public int get_CachedSeconds();
    public void set_CachedSeconds(int value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual string Transform(string text);
    protected virtual string RenderInner(LogEventInfo logEvent);
    private string LookupValidCachedValue(LogEventInfo logEvent, string newCacheKey);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
}
[LayoutRendererAttribute("filesystem-normalize")]
[AmbientPropertyAttribute("FSNormalize")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.FileSystemNormalizeLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <FSNormalize>k__BackingField;
    public bool FSNormalize { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_FSNormalize();
    [CompilerGeneratedAttribute]
public void set_FSNormalize(bool value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
    private static void TransformFileSystemNormalize(StringBuilder builder, int startPos);
    private static bool IsSafeCharacter(char c);
}
[LayoutRendererAttribute("json-encode")]
[AmbientPropertyAttribute("JsonEncode")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.JsonEncodeLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <JsonEncode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeUnicode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeForwardSlash>k__BackingField;
    public bool JsonEncode { get; public set; }
    public bool EscapeUnicode { get; public set; }
    public bool EscapeForwardSlash { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_JsonEncode();
    [CompilerGeneratedAttribute]
public void set_JsonEncode(bool value);
    [CompilerGeneratedAttribute]
public bool get_EscapeUnicode();
    [CompilerGeneratedAttribute]
public void set_EscapeUnicode(bool value);
    [CompilerGeneratedAttribute]
public bool get_EscapeForwardSlash();
    [CompilerGeneratedAttribute]
public void set_EscapeForwardSlash(bool value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("left")]
[AmbientPropertyAttribute("Truncate")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.LeftLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; public set; }
    public int Truncate { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    public int get_Truncate();
    public void set_Truncate(int value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("lowercase")]
[AmbientPropertyAttribute("Lowercase")]
[AmbientPropertyAttribute("ToLower")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.LowercaseLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <Lowercase>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public bool Lowercase { get; public set; }
    public bool ToLower { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Lowercase();
    [CompilerGeneratedAttribute]
public void set_Lowercase(bool value);
    public bool get_ToLower();
    public void set_ToLower(bool value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
    private void TransformToLowerCase(StringBuilder target, int startPos);
}
[LayoutRendererAttribute("norawvalue")]
[AmbientPropertyAttribute("NoRawValue")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.NoRawValueLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <NoRawValue>k__BackingField;
    public bool NoRawValue { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_NoRawValue();
    [CompilerGeneratedAttribute]
public void set_NoRawValue(bool value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("Object-Path")]
[AmbientPropertyAttribute("ObjectPath")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.ObjectPathRendererWrapper : WrapperLayoutRendererBase {
    private ObjectReflectionCache _objectReflectionCache;
    private ObjectPropertyPath _objectPropertyPath;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    private ObjectReflectionCache ObjectReflectionCache { get; }
    public string Path { get; public set; }
    public string ObjectPath { get; public set; }
    public string Format { get; public set; }
    public CultureInfo Culture { get; public set; }
    private ObjectReflectionCache get_ObjectReflectionCache();
    public string get_Path();
    public void set_Path(string value);
    public string get_ObjectPath();
    public void set_ObjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual string Transform(string text);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    private bool TryGetRawPropertyValue(LogEventInfo logEvent, Object& propertyValue);
    public bool TryGetPropertyValue(object sourceObject, Object& propertyValue);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
}
[LayoutRendererAttribute("onexception")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.OnExceptionLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private Layout <Else>k__BackingField;
    public Layout Else { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Else();
    [CompilerGeneratedAttribute]
public void set_Else(Layout value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("onhasproperties")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.OnHasPropertiesLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private Layout <Else>k__BackingField;
    public Layout Else { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Else();
    [CompilerGeneratedAttribute]
public void set_Else(Layout value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
}
public enum NLog.LayoutRenderers.Wrappers.PaddingHorizontalAlignment : Enum {
    public int value__;
    public static PaddingHorizontalAlignment Left;
    public static PaddingHorizontalAlignment Right;
}
[LayoutRendererAttribute("pad")]
[AmbientPropertyAttribute("Padding")]
[AmbientPropertyAttribute("PadCharacter")]
[AmbientPropertyAttribute("FixedLength")]
[AmbientPropertyAttribute("AlignmentOnTruncation")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.PaddingLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private int <Padding>k__BackingField;
    [CompilerGeneratedAttribute]
private char <PadCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixedLength>k__BackingField;
    [CompilerGeneratedAttribute]
private PaddingHorizontalAlignment <AlignmentOnTruncation>k__BackingField;
    public int Padding { get; public set; }
    public char PadCharacter { get; public set; }
    public bool FixedLength { get; public set; }
    public PaddingHorizontalAlignment AlignmentOnTruncation { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Padding();
    [CompilerGeneratedAttribute]
public void set_Padding(int value);
    [CompilerGeneratedAttribute]
public char get_PadCharacter();
    [CompilerGeneratedAttribute]
public void set_PadCharacter(char value);
    [CompilerGeneratedAttribute]
public bool get_FixedLength();
    [CompilerGeneratedAttribute]
public void set_FixedLength(bool value);
    [CompilerGeneratedAttribute]
public PaddingHorizontalAlignment get_AlignmentOnTruncation();
    [CompilerGeneratedAttribute]
public void set_AlignmentOnTruncation(PaddingHorizontalAlignment value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    private int AppendPadding(StringBuilder builder, int orgLength, int absolutePadding);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("replace")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.ReplaceLayoutRendererWrapper : WrapperLayoutRendererBase {
    private RegexHelper _regexHelper;
    private MatchEvaluator _groupMatchEvaluator;
    [CompilerGeneratedAttribute]
private string <SearchFor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceWith>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceGroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WholeWords>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompileRegex>k__BackingField;
    [RequiredParameterAttribute]
public string SearchFor { get; public set; }
    public bool Regex { get; public set; }
    public string ReplaceWith { get; public set; }
    public string ReplaceGroupName { get; public set; }
    public bool IgnoreCase { get; public set; }
    public bool WholeWords { get; public set; }
    public bool CompileRegex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SearchFor();
    [CompilerGeneratedAttribute]
public void set_SearchFor(string value);
    [CompilerGeneratedAttribute]
public bool get_Regex();
    [CompilerGeneratedAttribute]
public void set_Regex(bool value);
    [CompilerGeneratedAttribute]
public string get_ReplaceWith();
    [CompilerGeneratedAttribute]
public void set_ReplaceWith(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceGroupName();
    [CompilerGeneratedAttribute]
public void set_ReplaceGroupName(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public bool get_WholeWords();
    [CompilerGeneratedAttribute]
public void set_WholeWords(bool value);
    [CompilerGeneratedAttribute]
public bool get_CompileRegex();
    [CompilerGeneratedAttribute]
public void set_CompileRegex(bool value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual string Transform(string text);
    [ObsoleteAttribute("This method should not be used. Marked obsolete on NLog 4.7")]
public static string ReplaceNamedGroup(string input, string groupName, string replacement, Match match);
    internal static string ReplaceNamedGroup(string groupName, string replacement, Match match);
    [CompilerGeneratedAttribute]
private string <Transform>b__31_0(Match m);
}
[LayoutRendererAttribute("replace-newlines")]
[AmbientPropertyAttribute("ReplaceNewLines")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.ReplaceNewLinesLayoutRendererWrapper : WrapperLayoutRendererBase {
    private static string WindowsNewLine;
    private static string UnixNewLine;
    private string _replacement;
    private bool _replaceWithNewLines;
    public string Replacement { get; public set; }
    public string get_Replacement();
    public void set_Replacement(string value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("right")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.RightLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("rot13")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.Rot13LayoutRendererWrapper : WrapperLayoutRendererBase {
    public Layout Text { get; public set; }
    public Layout get_Text();
    public void set_Text(Layout value);
    public static string DecodeRot13(string encodedValue);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
    internal static void DecodeRot13(StringBuilder encodedValue, int startPos);
    private static char DecodeRot13Char(char c);
}
[LayoutRendererAttribute("substring")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.SubstringLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Length>k__BackingField;
    public int Start { get; public set; }
    public Nullable`1<int> Length { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(Nullable`1<int> value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
    private int CalcStart(int textLength);
    private int CalcLength(int textLength, int start);
}
[LayoutRendererAttribute("trim-whitespace")]
[AmbientPropertyAttribute("TrimWhiteSpace")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.TrimWhiteSpaceLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <TrimWhiteSpace>k__BackingField;
    public bool TrimWhiteSpace { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TrimWhiteSpace();
    [CompilerGeneratedAttribute]
public void set_TrimWhiteSpace(bool value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
    private static void TransformTrimWhiteSpaces(StringBuilder builder, int startPos);
}
[LayoutRendererAttribute("uppercase")]
[AmbientPropertyAttribute("Uppercase")]
[AmbientPropertyAttribute("ToUpper")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.UppercaseLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <Uppercase>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public bool Uppercase { get; public set; }
    public bool ToUpper { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Uppercase();
    [CompilerGeneratedAttribute]
public void set_Uppercase(bool value);
    public bool get_ToUpper();
    public void set_ToUpper(bool value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
    private void TransformToUpperCase(StringBuilder target, int startPos);
}
[LayoutRendererAttribute("url-encode")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.UrlEncodeLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <SpaceAsPlus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeDataRfc3986>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeDataNLogLegacy>k__BackingField;
    public bool SpaceAsPlus { get; public set; }
    public bool EscapeDataRfc3986 { get; public set; }
    [ObsoleteAttribute("Instead use default Rfc2396 or EscapeDataRfc3986. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public bool EscapeDataNLogLegacy { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SpaceAsPlus();
    [CompilerGeneratedAttribute]
public void set_SpaceAsPlus(bool value);
    [CompilerGeneratedAttribute]
public bool get_EscapeDataRfc3986();
    [CompilerGeneratedAttribute]
public void set_EscapeDataRfc3986(bool value);
    [CompilerGeneratedAttribute]
public bool get_EscapeDataNLogLegacy();
    [CompilerGeneratedAttribute]
public void set_EscapeDataNLogLegacy(bool value);
    protected virtual string Transform(string text);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
}
[LayoutRendererAttribute("whenEmpty")]
[AmbientPropertyAttribute("WhenEmpty")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.WhenEmptyLayoutRendererWrapper : WrapperLayoutRendererBase {
    private bool _skipStringValueRenderer;
    [CompilerGeneratedAttribute]
private Layout <WhenEmpty>k__BackingField;
    [RequiredParameterAttribute]
public Layout WhenEmpty { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_WhenEmpty();
    [CompilerGeneratedAttribute]
public void set_WhenEmpty(Layout value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
    private sealed virtual override string NLog.Internal.IStringValueRenderer.GetFormattedString(LogEventInfo logEvent);
    private bool TryGetStringValue(SimpleLayout& innerLayout, SimpleLayout& whenEmptyLayout);
    private static bool IsStringLayout(SimpleLayout innerLayout);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
}
[LayoutRendererAttribute("when")]
[AmbientPropertyAttribute("When")]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.WhenLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private ConditionExpression <When>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Else>k__BackingField;
    [RequiredParameterAttribute]
public ConditionExpression When { get; public set; }
    public Layout Else { get; public set; }
    [CompilerGeneratedAttribute]
public ConditionExpression get_When();
    [CompilerGeneratedAttribute]
public void set_When(ConditionExpression value);
    [CompilerGeneratedAttribute]
public Layout get_Else();
    [CompilerGeneratedAttribute]
public void set_Else(Layout value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    protected virtual string Transform(string text);
    private bool ShouldRenderInner(LogEventInfo logEvent);
    private sealed virtual override bool NLog.Internal.IRawValue.TryGetRawValue(LogEventInfo logEvent, Object& value);
    private static bool TryGetRawValueFromLayout(LogEventInfo logEvent, Layout layout, Object& value);
}
[LayoutRendererAttribute("wrapline")]
[AmbientPropertyAttribute("WrapLine")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.WrapLineLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private int <WrapLine>k__BackingField;
    public int WrapLine { get; public set; }
    [CompilerGeneratedAttribute]
public int get_WrapLine();
    [CompilerGeneratedAttribute]
public void set_WrapLine(int value);
    protected virtual string Transform(string text);
}
public abstract class NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBase : LayoutRenderer {
    [CompilerGeneratedAttribute]
private Layout <Inner>k__BackingField;
    [DefaultParameterAttribute]
public Layout Inner { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Inner();
    [CompilerGeneratedAttribute]
public void set_Inner(Layout value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(LogEventInfo logEvent, string text);
    protected abstract virtual string Transform(string text);
    protected virtual string RenderInner(LogEventInfo logEvent);
}
[ObsoleteAttribute("Inherit from WrapperLayoutRendererBase and override RenderInnerAndTransform() instead. Marked obsolete in NLog 5.0")]
public abstract class NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBuilderBase : WrapperLayoutRendererBase {
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    [ObsoleteAttribute("Inherit from WrapperLayoutRendererBase and override RenderInnerAndTransform() instead. Marked obsolete in NLog 4.6")]
protected virtual void TransformFormattedMesssage(LogEventInfo logEvent, StringBuilder target);
    [ObsoleteAttribute("Inherit from WrapperLayoutRendererBase and override RenderInnerAndTransform() instead. Marked obsolete in NLog 4.6")]
protected abstract virtual void TransformFormattedMesssage(StringBuilder target);
    [ObsoleteAttribute("Inherit from WrapperLayoutRendererBase and override RenderInnerAndTransform() instead. Marked obsolete in NLog 4.6")]
protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
    protected sealed virtual string Transform(string text);
    protected sealed virtual string RenderInner(LogEventInfo logEvent);
}
[LayoutRendererAttribute("xml-encode")]
[AmbientPropertyAttribute("XmlEncode")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
public class NLog.LayoutRenderers.Wrappers.XmlEncodeLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <XmlEncode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XmlEncodeNewlines>k__BackingField;
    public bool XmlEncode { get; public set; }
    public bool XmlEncodeNewlines { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_XmlEncode();
    [CompilerGeneratedAttribute]
public void set_XmlEncode(bool value);
    [CompilerGeneratedAttribute]
public bool get_XmlEncodeNewlines();
    [CompilerGeneratedAttribute]
public void set_XmlEncodeNewlines(bool value);
    protected virtual void RenderInnerAndTransform(LogEventInfo logEvent, StringBuilder builder, int orgLength);
    protected virtual string Transform(string text);
}
[LayoutAttribute("CompoundLayout")]
[ThreadAgnosticAttribute]
[AppDomainFixedOutputAttribute]
public class NLog.Layouts.CompoundLayout : Layout {
    private Layout[] _precalculateLayouts;
    [CompilerGeneratedAttribute]
private IList`1<Layout> <Layouts>k__BackingField;
    [ArrayParameterAttribute("NLog.Layouts.Layout", "layout")]
public IList`1<Layout> Layouts { get; private set; }
    [CompilerGeneratedAttribute]
public IList`1<Layout> get_Layouts();
    [CompilerGeneratedAttribute]
private void set_Layouts(IList`1<Layout> value);
    protected virtual void InitializeLayout();
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
    protected virtual void CloseLayout();
    public virtual string ToString();
}
[NLogConfigurationItemAttribute]
public class NLog.Layouts.CsvColumn : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    internal Nullable`1<CsvQuotingMode> _quoting;
    public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public CsvQuotingMode Quoting { get; public set; }
    public CsvColumn(string name, Layout layout);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
    public CsvQuotingMode get_Quoting();
    public void set_Quoting(CsvQuotingMode value);
}
public enum NLog.Layouts.CsvColumnDelimiterMode : Enum {
    public int value__;
    public static CsvColumnDelimiterMode Auto;
    public static CsvColumnDelimiterMode Comma;
    public static CsvColumnDelimiterMode Semicolon;
    public static CsvColumnDelimiterMode Tab;
    public static CsvColumnDelimiterMode Pipe;
    public static CsvColumnDelimiterMode Space;
    public static CsvColumnDelimiterMode Custom;
}
[LayoutAttribute("CsvLayout")]
[ThreadAgnosticAttribute]
[AppDomainFixedOutputAttribute]
public class NLog.Layouts.CsvLayout : LayoutWithHeaderAndFooter {
    private string _actualColumnDelimiter;
    private string _doubleQuoteChar;
    private Char[] _quotableCharacters;
    private Layout[] _precalculateLayouts;
    [CompilerGeneratedAttribute]
private IList`1<CsvColumn> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WithHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private CsvColumnDelimiterMode <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private CsvQuotingMode <Quoting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QuoteChar>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomColumnDelimiter>k__BackingField;
    [ArrayParameterAttribute("NLog.Layouts.CsvColumn", "column")]
public IList`1<CsvColumn> Columns { get; }
    public bool WithHeader { get; public set; }
    public CsvColumnDelimiterMode Delimiter { get; public set; }
    public CsvQuotingMode Quoting { get; public set; }
    public string QuoteChar { get; public set; }
    public string CustomColumnDelimiter { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<CsvColumn> get_Columns();
    [CompilerGeneratedAttribute]
public bool get_WithHeader();
    [CompilerGeneratedAttribute]
public void set_WithHeader(bool value);
    [CompilerGeneratedAttribute]
public CsvColumnDelimiterMode get_Delimiter();
    [CompilerGeneratedAttribute]
public void set_Delimiter(CsvColumnDelimiterMode value);
    [CompilerGeneratedAttribute]
public CsvQuotingMode get_Quoting();
    [CompilerGeneratedAttribute]
public void set_Quoting(CsvQuotingMode value);
    [CompilerGeneratedAttribute]
public string get_QuoteChar();
    [CompilerGeneratedAttribute]
public void set_QuoteChar(string value);
    [CompilerGeneratedAttribute]
public string get_CustomColumnDelimiter();
    [CompilerGeneratedAttribute]
public void set_CustomColumnDelimiter(string value);
    protected virtual void InitializeLayout();
    protected virtual void CloseLayout();
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
    private void RenderColumnLayout(LogEventInfo logEvent, Layout columnLayout, CsvQuotingMode quoting, StringBuilder target, int i);
    private void RenderHeader(StringBuilder sb);
    private bool ColumnValueRequiresQuotes(CsvQuotingMode quoting, StringBuilder sb, int startPosition);
    public virtual string ToString();
}
public enum NLog.Layouts.CsvQuotingMode : Enum {
    public int value__;
    public static CsvQuotingMode All;
    public static CsvQuotingMode Nothing;
    public static CsvQuotingMode Auto;
}
internal interface NLog.Layouts.ILayoutTypeValue {
    public Type InnerType { get; }
    public ILayoutTypeValue InnerLayout { get; }
    public abstract virtual Type get_InnerType();
    public abstract virtual ILayoutTypeValue get_InnerLayout();
    public abstract virtual object RenderObjectValue(LogEventInfo logEvent, StringBuilder stringBuilder);
}
internal interface NLog.Layouts.ILayoutTypeValue`1 {
    public LoggingConfiguration LoggingConfiguration { get; }
    public bool ThreadAgnostic { get; }
    public bool ThreadAgnosticImmutable { get; }
    public StackTraceUsage StackTraceUsage { get; }
    public abstract virtual LoggingConfiguration get_LoggingConfiguration();
    public abstract virtual bool get_ThreadAgnostic();
    public abstract virtual bool get_ThreadAgnosticImmutable();
    public abstract virtual StackTraceUsage get_StackTraceUsage();
    public abstract virtual void InitializeLayout();
    public abstract virtual void CloseLayout();
    public abstract virtual bool TryRenderValue(LogEventInfo logEvent, StringBuilder stringBuilder, T& value);
}
[LayoutAttribute("JsonArrayLayout")]
[ThreadAgnosticAttribute]
public class NLog.Layouts.JsonArrayLayout : Layout {
    private Layout[] _precalculateLayouts;
    private IJsonConverter _jsonConverter;
    [CompilerGeneratedAttribute]
private IList`1<Layout> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressSpaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenderEmptyObject>k__BackingField;
    private IJsonConverter JsonConverter { get; private set; }
    [ArrayParameterAttribute("NLog.Layouts.Layout", "item")]
public IList`1<Layout> Items { get; }
    public bool SuppressSpaces { get; public set; }
    public bool RenderEmptyObject { get; public set; }
    private IJsonConverter get_JsonConverter();
    private void set_JsonConverter(IJsonConverter value);
    [CompilerGeneratedAttribute]
public IList`1<Layout> get_Items();
    [CompilerGeneratedAttribute]
public bool get_SuppressSpaces();
    [CompilerGeneratedAttribute]
public void set_SuppressSpaces(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenderEmptyObject();
    [CompilerGeneratedAttribute]
public void set_RenderEmptyObject(bool value);
    protected virtual void InitializeLayout();
    protected virtual void CloseLayout();
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    private void RenderJsonFormattedMessage(LogEventInfo logEvent, StringBuilder sb);
    private bool RenderLayoutJsonValue(LogEventInfo logEvent, Layout layout, StringBuilder sb);
    public virtual string ToString();
}
[NLogConfigurationItemAttribute]
public class NLog.Layouts.JsonAttribute : object {
    private ValueTypeLayoutInfo _layoutInfo;
    private string _name;
    [CompilerGeneratedAttribute]
private bool <Encode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeUnicode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EscapeForwardSlashInternal>k__BackingField;
    private bool _includeEmptyValue;
    [RequiredParameterAttribute]
public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public Type ValueType { get; public set; }
    public Layout DefaultValue { get; public set; }
    public bool Encode { get; public set; }
    public bool EscapeUnicode { get; public set; }
    public bool EscapeForwardSlash { get; public set; }
    internal Nullable`1<bool> EscapeForwardSlashInternal { get; private set; }
    public bool IncludeEmptyValue { get; public set; }
    public JsonAttribute(string name, Layout layout);
    public JsonAttribute(string name, Layout layout, bool encode);
    public string get_Name();
    public void set_Name(string value);
    public Layout get_Layout();
    public void set_Layout(Layout value);
    public Type get_ValueType();
    public void set_ValueType(Type value);
    public Layout get_DefaultValue();
    public void set_DefaultValue(Layout value);
    [CompilerGeneratedAttribute]
public bool get_Encode();
    [CompilerGeneratedAttribute]
public void set_Encode(bool value);
    [CompilerGeneratedAttribute]
public bool get_EscapeUnicode();
    [CompilerGeneratedAttribute]
public void set_EscapeUnicode(bool value);
    public bool get_EscapeForwardSlash();
    public void set_EscapeForwardSlash(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_EscapeForwardSlashInternal();
    [CompilerGeneratedAttribute]
private void set_EscapeForwardSlashInternal(Nullable`1<bool> value);
    public bool get_IncludeEmptyValue();
    public void set_IncludeEmptyValue(bool value);
    internal bool RenderAppendJsonValue(LogEventInfo logEvent, IJsonConverter jsonConverter, StringBuilder builder);
}
[LayoutAttribute("JsonLayout")]
[ThreadAgnosticAttribute]
public class NLog.Layouts.JsonLayout : Layout {
    private static int SpacesPerIndent;
    private Layout[] _precalculateLayouts;
    private LimitRecursionJsonConvert _jsonConverter;
    private IValueFormatter _valueFormatter;
    [CompilerGeneratedAttribute]
private IList`1<JsonAttribute> <Attributes>k__BackingField;
    private bool _suppressSpaces;
    private Nullable`1<bool> _renderEmptyObject;
    private bool _indentJson;
    [CompilerGeneratedAttribute]
private bool <IncludeEventProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeGdc>k__BackingField;
    private Nullable`1<bool> _includeScopeProperties;
    private Nullable`1<bool> _includeMdc;
    private Nullable`1<bool> _includeMdlc;
    [CompilerGeneratedAttribute]
private bool <ExcludeEmptyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <ExcludeProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRecursionLimit>k__BackingField;
    private Nullable`1<bool> _escapeForwardSlashInternal;
    private string _beginJsonMessage;
    private string _completeJsonMessage;
    private string _beginJsonPropertyName;
    private string _completeJsonPropertyName;
    private LimitRecursionJsonConvert JsonConverter { get; private set; }
    private IValueFormatter ValueFormatter { get; private set; }
    [ArrayParameterAttribute("NLog.Layouts.JsonAttribute", "attribute")]
public IList`1<JsonAttribute> Attributes { get; }
    public bool SuppressSpaces { get; public set; }
    public bool RenderEmptyObject { get; public set; }
    public bool IndentJson { get; public set; }
    public bool IncludeEventProperties { get; public set; }
    public bool IncludeGdc { get; public set; }
    public bool IncludeScopeProperties { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeEventProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeAllProperties { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdlc { get; public set; }
    public bool ExcludeEmptyProperties { get; public set; }
    public ISet`1<string> ExcludeProperties { get; public set; }
    public int MaxRecursionLimit { get; public set; }
    public bool EscapeForwardSlash { get; public set; }
    private LimitRecursionJsonConvert get_JsonConverter();
    private void set_JsonConverter(LimitRecursionJsonConvert value);
    private IValueFormatter get_ValueFormatter();
    private void set_ValueFormatter(IValueFormatter value);
    [CompilerGeneratedAttribute]
public IList`1<JsonAttribute> get_Attributes();
    public bool get_SuppressSpaces();
    public void set_SuppressSpaces(bool value);
    public bool get_RenderEmptyObject();
    public void set_RenderEmptyObject(bool value);
    public bool get_IndentJson();
    public void set_IndentJson(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEventProperties();
    [CompilerGeneratedAttribute]
public void set_IncludeEventProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeGdc();
    [CompilerGeneratedAttribute]
public void set_IncludeGdc(bool value);
    public bool get_IncludeScopeProperties();
    public void set_IncludeScopeProperties(bool value);
    public bool get_IncludeAllProperties();
    public void set_IncludeAllProperties(bool value);
    public bool get_IncludeMdc();
    public void set_IncludeMdc(bool value);
    public bool get_IncludeMdlc();
    public void set_IncludeMdlc(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeEmptyProperties();
    [CompilerGeneratedAttribute]
public void set_ExcludeEmptyProperties(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_ExcludeProperties();
    [CompilerGeneratedAttribute]
public void set_ExcludeProperties(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public int get_MaxRecursionLimit();
    [CompilerGeneratedAttribute]
public void set_MaxRecursionLimit(int value);
    public bool get_EscapeForwardSlash();
    public void set_EscapeForwardSlash(bool value);
    protected virtual void InitializeLayout();
    protected virtual void CloseLayout();
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    private void RenderJsonFormattedMessage(LogEventInfo logEvent, StringBuilder sb);
    private void BeginJsonProperty(StringBuilder sb, string propName, bool beginJsonMessage, bool ensureStringEscape);
    private void RefreshJsonDelimiters();
    private void AppendJsonPropertyValue(string propName, object propertyValue, StringBuilder sb, bool beginJsonMessage);
    private void AppendJsonPropertyValue(string propName, object propertyValue, string format, IFormatProvider formatProvider, CaptureType captureType, StringBuilder sb, bool beginJsonMessage);
    private static void PerformJsonEscapeIfNeeded(StringBuilder sb, int valueStart, bool escapeForwardSlash);
    private bool RenderAppendJsonPropertyValue(JsonAttribute attrib, LogEventInfo logEvent, StringBuilder sb, bool beginJsonMessage);
    public virtual string ToString();
}
[NLogConfigurationItemAttribute]
public abstract class NLog.Layouts.Layout : object {
    internal bool IsInitialized;
    private bool _scannedForObjects;
    [CompilerGeneratedAttribute]
private bool <ThreadAgnostic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThreadAgnosticImmutable>k__BackingField;
    [CompilerGeneratedAttribute]
private StackTraceUsage <StackTraceUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <LoggingConfiguration>k__BackingField;
    internal bool ThreadAgnostic { get; internal set; }
    internal bool ThreadAgnosticImmutable { get; internal set; }
    internal StackTraceUsage StackTraceUsage { get; internal set; }
    [CanBeNullAttribute]
protected internal LoggingConfiguration LoggingConfiguration { get; private set; }
    [CompilerGeneratedAttribute]
internal bool get_ThreadAgnostic();
    [CompilerGeneratedAttribute]
internal void set_ThreadAgnostic(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ThreadAgnosticImmutable();
    [CompilerGeneratedAttribute]
internal void set_ThreadAgnosticImmutable(bool value);
    [CompilerGeneratedAttribute]
internal StackTraceUsage get_StackTraceUsage();
    [CompilerGeneratedAttribute]
internal void set_StackTraceUsage(StackTraceUsage value);
    [CompilerGeneratedAttribute]
protected internal LoggingConfiguration get_LoggingConfiguration();
    [CompilerGeneratedAttribute]
private void set_LoggingConfiguration(LoggingConfiguration value);
    public static Layout op_Implicit(string text);
    public static Layout FromString(string layoutText);
    public static Layout FromString(string layoutText, ConfigurationItemFactory configurationItemFactory);
    public static Layout FromString(string layoutText, bool throwConfigExceptions);
    public static Layout FromMethod(Func`2<LogEventInfo, object> layoutMethod, LayoutRenderOptions options);
    internal static FuncLayoutRenderer CreateFuncLayoutRenderer(Func`3<LogEventInfo, LoggingConfiguration, object> layoutMethod, LayoutRenderOptions options, string name);
    public virtual void Precalculate(LogEventInfo logEvent);
    public sealed virtual string Render(LogEventInfo logEvent);
    internal string Render(LogEventInfo logEvent, bool cacheLayoutResult);
    public void Render(LogEventInfo logEvent, StringBuilder target);
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    private void RenderAppendBuilder(LogEventInfo logEvent, StringBuilder target, bool cacheLayoutResult);
    internal string RenderAllocateBuilder(LogEventInfo logEvent);
    internal string RenderAllocateBuilder(LogEventInfo logEvent, StringBuilder target);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Initialize(LoggingConfiguration configuration);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Close();
    internal void Initialize(LoggingConfiguration configuration);
    internal void PerformObjectScanning();
    internal Layout[] ResolveLayoutPrecalculation(IEnumerable`1<Layout> allLayouts);
    internal void Close();
    protected virtual void InitializeLayout();
    protected virtual void CloseLayout();
    protected abstract virtual string GetFormattedMessage(LogEventInfo logEvent);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(string name);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(string name, Type layoutType);
    internal void PrecalculateBuilderInternal(LogEventInfo logEvent, StringBuilder target, Layout[] precalculateLayout);
    internal string ToStringWithNestedItems(IList`1<T> nestedItems, Func`2<T, string> nextItemToString);
    internal virtual bool TryGetRawValue(LogEventInfo logEvent, Object& rawValue);
    protected T ResolveService();
}
[ThreadAgnosticAttribute]
public class NLog.Layouts.Layout`1 : Layout {
    private T _fixedValue;
    private object _fixedObjectValue;
    private ILayoutTypeValue`1<T> _layoutValue;
    private IPropertyTypeConverter _valueTypeConverter;
    private ILayoutTypeValue NLog.Layouts.ILayoutTypeValue.InnerLayout { get; }
    private Type NLog.Layouts.ILayoutTypeValue.InnerType { get; }
    private bool NLog.Layouts.ILayoutTypeValue<T>.ThreadAgnostic { get; }
    private bool NLog.Layouts.ILayoutTypeValue<T>.ThreadAgnosticImmutable { get; }
    private StackTraceUsage NLog.Layouts.ILayoutTypeValue<T>.StackTraceUsage { get; }
    private LoggingConfiguration NLog.Layouts.ILayoutTypeValue<T>.LoggingConfiguration { get; }
    public bool IsFixed { get; }
    public T FixedValue { get; }
    private object FixedObjectValue { get; }
    private IPropertyTypeConverter ValueTypeConverter { get; }
    public Layout`1(Layout layout);
    public Layout`1(Layout layout, string parseValueFormat, CultureInfo parseValueCulture);
    public Layout`1(T value);
    private Layout`1(Func`2<LogEventInfo, T> layoutMethod, LayoutRenderOptions options);
    private sealed virtual override ILayoutTypeValue NLog.Layouts.ILayoutTypeValue.get_InnerLayout();
    private sealed virtual override Type NLog.Layouts.ILayoutTypeValue.get_InnerType();
    private sealed virtual override bool NLog.Layouts.ILayoutTypeValue<T>.get_ThreadAgnostic();
    private sealed virtual override bool NLog.Layouts.ILayoutTypeValue<T>.get_ThreadAgnosticImmutable();
    private sealed virtual override StackTraceUsage NLog.Layouts.ILayoutTypeValue<T>.get_StackTraceUsage();
    private sealed virtual override LoggingConfiguration NLog.Layouts.ILayoutTypeValue<T>.get_LoggingConfiguration();
    private sealed virtual override void NLog.Layouts.ILayoutTypeValue<T>.InitializeLayout();
    private sealed virtual override void NLog.Layouts.ILayoutTypeValue<T>.CloseLayout();
    private sealed virtual override bool NLog.Layouts.ILayoutTypeValue<T>.TryRenderValue(LogEventInfo logEvent, StringBuilder stringBuilder, T& value);
    private sealed virtual override object NLog.Layouts.ILayoutTypeValue.RenderObjectValue(LogEventInfo logEvent, StringBuilder stringBuilder);
    public bool get_IsFixed();
    public T get_FixedValue();
    private object get_FixedObjectValue();
    private IPropertyTypeConverter get_ValueTypeConverter();
    internal T RenderTypedValue(LogEventInfo logEvent, T defaultValue);
    internal T RenderTypedValue(LogEventInfo logEvent, StringBuilder stringBuilder, T defaultValue);
    private object RenderObjectValue(LogEventInfo logEvent, StringBuilder stringBuilder);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    protected virtual void InitializeLayout();
    protected virtual void CloseLayout();
    public virtual void Precalculate(LogEventInfo logEvent);
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    public static Layout`1<T> FromMethod(Func`2<LogEventInfo, T> layoutMethod, LayoutRenderOptions options);
    private void PrecalculateInnerLayout(LogEventInfo logEvent, StringBuilder target);
    private bool TryParseFixedValue(Layout layout, string parseValueFormat, CultureInfo parseValueCulture, T& fixedValue);
    private object ParseValueFromObject(object rawValue, string parseValueFormat, CultureInfo parseValueCulture);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(T other);
    public virtual int GetHashCode();
    public static Layout`1<T> op_Implicit(T value);
    public static Layout`1<T> op_Implicit(string layout);
    public static bool op_Equality(Layout`1<T> left, T right);
    public static bool op_Inequality(Layout`1<T> left, T right);
}
[AttributeUsageAttribute("4")]
public class NLog.Layouts.LayoutAttribute : NameBaseAttribute {
    public LayoutAttribute(string name);
}
internal static class NLog.Layouts.LayoutParser : object {
    private static Char[] SpecialTokens;
    private static LayoutParser();
    internal static LayoutRenderer[] CompileLayout(string value, ConfigurationItemFactory configurationItemFactory, Nullable`1<bool> throwConfigExceptions, String& text);
    internal static LayoutRenderer[] CompileLayout(ConfigurationItemFactory configurationItemFactory, SimpleStringReader sr, Nullable`1<bool> throwConfigExceptions, bool isNested, String& text);
    private static void AddLiteral(StringBuilder literalBuf, List`1<LayoutRenderer> result);
    private static bool EndOfLayout(int ch);
    private static string ParseLayoutRendererTypeName(SimpleStringReader sr);
    private static string ParseParameterNameOrValue(SimpleStringReader sr);
    private static string ParseParameterStringValue(SimpleStringReader sr);
    private static bool ParseLayoutParameterValue(SimpleStringReader sr, StringBuilder parameterValue, Func`2<int, bool> endOfLayout);
    private static string ParseParameterValue(SimpleStringReader sr);
    private static string EscapeUnicodeStringValue(string value, StringBuilder nameBuf);
    private static char GetUnicode(string value, int maxDigits, Int32& currentIndex);
    private static LayoutRenderer ParseLayoutRenderer(ConfigurationItemFactory configurationItemFactory, SimpleStringReader stringReader, Nullable`1<bool> throwConfigExceptions);
    private static LayoutRenderer BuildCompleteLayoutRenderer(ConfigurationItemFactory configurationItemFactory, LayoutRenderer layoutRenderer, List`1<LayoutRenderer> orderedWrappers);
    private static object ParseLayoutRendererPropertyValue(ConfigurationItemFactory configurationItemFactory, SimpleStringReader stringReader, Nullable`1<bool> throwConfigExceptions, string targetTypeName, PropertyInfo propertyInfo);
    private static string ValidatePreviousParameterName(string previousParameterName, string parameterName, LayoutRenderer layoutRenderer, Nullable`1<bool> throwConfigExceptions);
    private static LayoutRenderer LookupAmbientProperty(string propertyName, ConfigurationItemFactory configurationItemFactory, Dictionary`2& wrappers, List`1& orderedWrappers);
    private static LayoutRenderer GetLayoutRenderer(string typeName, ConfigurationItemFactory configurationItemFactory, Nullable`1<bool> throwConfigExceptions);
    private static string SetDefaultPropertyValue(string value, LayoutRenderer layoutRenderer, ConfigurationItemFactory configurationItemFactory, Nullable`1<bool> throwConfigExceptions);
    private static LayoutRenderer ApplyWrappers(ConfigurationItemFactory configurationItemFactory, LayoutRenderer lr, List`1<LayoutRenderer> orderedWrappers);
    private static bool CanBeConvertedToLiteral(ConfigurationItemFactory configurationItemFactory, LayoutRenderer lr);
    private static void MergeLiterals(List`1<LayoutRenderer> list);
    private static LayoutRenderer ConvertToLiteral(LayoutRenderer renderer);
}
[FlagsAttribute]
public enum NLog.Layouts.LayoutRenderOptions : Enum {
    public int value__;
    public static LayoutRenderOptions None;
    [ObsoleteAttribute("All LayoutRenderers and Layout should be ThreadSafe by default. Marked obsolete with NLog 5.0")]
public static LayoutRenderOptions ThreadSafe;
    public static LayoutRenderOptions ThreadAgnostic;
}
internal class NLog.Layouts.LayoutTypeValue : object {
    private Layout _innerLayout;
    private Type _valueType;
    private CultureInfo _parseValueCulture;
    private string _parseValueFormat;
    private string _previousStringValue;
    private object _previousValue;
    [CompilerGeneratedAttribute]
private IPropertyTypeConverter <ValueTypeConverter>k__BackingField;
    public LoggingConfiguration LoggingConfiguration { get; }
    public bool ThreadAgnostic { get; }
    public bool ThreadAgnosticImmutable { get; }
    public StackTraceUsage StackTraceUsage { get; }
    public IPropertyTypeConverter ValueTypeConverter { get; }
    private ILayoutTypeValue NLog.Layouts.ILayoutTypeValue.InnerLayout { get; }
    private Type NLog.Layouts.ILayoutTypeValue.InnerType { get; }
    public LayoutTypeValue(Layout layout, Type valueType, string parseValueFormat, CultureInfo parseValueCulture, IPropertyTypeConverter valueTypeConverter);
    public sealed virtual LoggingConfiguration get_LoggingConfiguration();
    public sealed virtual bool get_ThreadAgnostic();
    public sealed virtual bool get_ThreadAgnosticImmutable();
    public sealed virtual StackTraceUsage get_StackTraceUsage();
    [CompilerGeneratedAttribute]
public virtual IPropertyTypeConverter get_ValueTypeConverter();
    private sealed virtual override ILayoutTypeValue NLog.Layouts.ILayoutTypeValue.get_InnerLayout();
    private sealed virtual override Type NLog.Layouts.ILayoutTypeValue.get_InnerType();
    public object TryParseFixedValue();
    protected void InitializeLayout(Layout ownerLayout);
    protected void Close();
    public sealed virtual object RenderObjectValue(LogEventInfo logEvent, StringBuilder stringBuilder);
    private string RenderStringValue(LogEventInfo logEvent, StringBuilder stringBuilder, string previousStringValue);
    private bool TryParseValueFromObject(object rawValue, string parseValueFormat, CultureInfo parseValueCulture, Object& parsedValue);
    private object ParseValueFromObject(object rawValue, string parseValueFormat, CultureInfo parseValueCulture);
    private bool TryParseValueFromString(string stringValue, string parseValueFormat, CultureInfo parseValueCulture, Object& parsedValue);
    public virtual string ToString();
}
[LayoutAttribute("LayoutWithHeaderAndFooter")]
[ThreadAgnosticAttribute]
[AppDomainFixedOutputAttribute]
public class NLog.Layouts.LayoutWithHeaderAndFooter : Layout {
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Footer>k__BackingField;
    public Layout Layout { get; public set; }
    public Layout Header { get; public set; }
    public Layout Footer { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_Footer();
    [CompilerGeneratedAttribute]
public void set_Footer(Layout value);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
}
[LayoutAttribute("Log4JXmlEventLayout")]
[ThreadAgnosticAttribute]
public class NLog.Layouts.Log4JXmlEventLayout : Layout {
    [CompilerGeneratedAttribute]
private Log4JXmlEventLayoutRenderer <Renderer>k__BackingField;
    public Log4JXmlEventLayoutRenderer Renderer { get; }
    [ArrayParameterAttribute("NLog.Targets.NLogViewerParameterInfo", "parameter")]
public IList`1<NLogViewerParameterInfo> Parameters { get; public set; }
    public bool IncludeEventProperties { get; public set; }
    public bool IncludeScopeProperties { get; public set; }
    public bool IncludeScopeNested { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeEventProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeAllProperties { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdc { get; public set; }
    public bool IncludeNdc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdlc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeNested. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeNdlc { get; public set; }
    public Layout LoggerName { get; public set; }
    public Layout FormattedMessage { get; public set; }
    public Layout AppInfo { get; public set; }
    public bool WriteThrowableCData { get; public set; }
    public bool IncludeCallSite { get; public set; }
    public bool IncludeSourceInfo { get; public set; }
    [CompilerGeneratedAttribute]
public Log4JXmlEventLayoutRenderer get_Renderer();
    public IList`1<NLogViewerParameterInfo> get_Parameters();
    public void set_Parameters(IList`1<NLogViewerParameterInfo> value);
    public sealed virtual bool get_IncludeEventProperties();
    public sealed virtual void set_IncludeEventProperties(bool value);
    public sealed virtual bool get_IncludeScopeProperties();
    public sealed virtual void set_IncludeScopeProperties(bool value);
    public sealed virtual bool get_IncludeScopeNested();
    public sealed virtual void set_IncludeScopeNested(bool value);
    public bool get_IncludeAllProperties();
    public void set_IncludeAllProperties(bool value);
    public bool get_IncludeMdc();
    public void set_IncludeMdc(bool value);
    public bool get_IncludeNdc();
    public void set_IncludeNdc(bool value);
    public bool get_IncludeMdlc();
    public void set_IncludeMdlc(bool value);
    public bool get_IncludeNdlc();
    public void set_IncludeNdlc(bool value);
    public Layout get_LoggerName();
    public void set_LoggerName(Layout value);
    public Layout get_FormattedMessage();
    public void set_FormattedMessage(Layout value);
    public Layout get_AppInfo();
    public void set_AppInfo(Layout value);
    public bool get_WriteThrowableCData();
    public void set_WriteThrowableCData(bool value);
    public bool get_IncludeCallSite();
    public void set_IncludeCallSite(bool value);
    public bool get_IncludeSourceInfo();
    public void set_IncludeSourceInfo(bool value);
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
}
[LayoutAttribute("SimpleLayout")]
[ThreadAgnosticAttribute]
[AppDomainFixedOutputAttribute]
public class NLog.Layouts.SimpleLayout : Layout {
    private string _fixedText;
    private string _layoutText;
    private IRawValue _rawValueRenderer;
    private IStringValueRenderer _stringValueRenderer;
    private ConfigurationItemFactory _configurationItemFactory;
    [CompilerGeneratedAttribute]
private string <OriginalText>k__BackingField;
    private ReadOnlyCollection`1<LayoutRenderer> _renderers;
    private LayoutRenderer[] _layoutRenderers;
    public string OriginalText { get; private set; }
    public string Text { get; public set; }
    public bool IsFixedText { get; }
    public string FixedText { get; }
    internal bool IsSimpleStringText { get; }
    [NLogConfigurationIgnorePropertyAttribute]
public ReadOnlyCollection`1<LayoutRenderer> Renderers { get; }
    public IEnumerable`1<LayoutRenderer> LayoutRenderers { get; }
    public StackTraceUsage StackTraceUsage { get; }
    public SimpleLayout(string txt);
    public SimpleLayout(string txt, ConfigurationItemFactory configurationItemFactory);
    internal SimpleLayout(string txt, ConfigurationItemFactory configurationItemFactory, Nullable`1<bool> throwConfigExceptions);
    internal SimpleLayout(LayoutRenderer[] renderers, string text, ConfigurationItemFactory configurationItemFactory);
    [CompilerGeneratedAttribute]
public string get_OriginalText();
    [CompilerGeneratedAttribute]
private void set_OriginalText(string value);
    public string get_Text();
    public void set_Text(string value);
    private void SetLayoutText(string value, Nullable`1<bool> throwConfigExceptions);
    public bool get_IsFixedText();
    public string get_FixedText();
    internal bool get_IsSimpleStringText();
    public ReadOnlyCollection`1<LayoutRenderer> get_Renderers();
    public IEnumerable`1<LayoutRenderer> get_LayoutRenderers();
    public sealed virtual StackTraceUsage get_StackTraceUsage();
    public static SimpleLayout op_Implicit(string text);
    public static string Escape(string text);
    public static string Evaluate(string text, LogEventInfo logEvent);
    public static string Evaluate(string text);
    public virtual string ToString();
    internal void SetLayoutRenderers(LayoutRenderer[] layoutRenderers, string text);
    protected virtual void InitializeLayout();
    public virtual void Precalculate(LogEventInfo logEvent);
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    private bool MustPrecalculateLayoutValue(LogEventInfo logEvent);
    private bool IsRawValueImmutable(LogEventInfo logEvent);
    private static bool IsRawValueImmutable(object value);
    internal virtual bool TryGetRawValue(LogEventInfo logEvent, Object& rawValue);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    private void RenderAllRenderers(LogEventInfo logEvent, StringBuilder target);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
}
[NLogConfigurationItemAttribute]
public class NLog.Layouts.ValueTypeLayoutInfo : object {
    private static Layout`1<string> _fixedNullValue;
    private Layout _layout;
    private Type _valueType;
    private Func`1<object> _createDefaultValue;
    private Layout _defaultValue;
    private bool _useDefaultWhenEmptyString;
    private string _valueParseFormat;
    private CultureInfo _valueParseCulture;
    private ILayoutTypeValue _layoutValue;
    private ILayoutTypeValue _defaultLayoutValue;
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public Type ValueType { get; public set; }
    public Layout DefaultValue { get; public set; }
    public bool ForceDefaultValueNull { get; public set; }
    public string ValueParseFormat { get; public set; }
    public CultureInfo ValueParseCulture { get; public set; }
    private ILayoutTypeValue LayoutValue { get; }
    private ILayoutTypeValue DefaultLayoutValue { get; }
    private static ValueTypeLayoutInfo();
    public Layout get_Layout();
    public void set_Layout(Layout value);
    public Type get_ValueType();
    [UnconditionalSuppressMessageAttribute("Trimming - Allow ValueType assign from config", "IL2067")]
public void set_ValueType(Type value);
    public Layout get_DefaultValue();
    public void set_DefaultValue(Layout value);
    private static bool UseDefaultWhenEmptyString(Type valueType, Layout defaultValue);
    public bool get_ForceDefaultValueNull();
    public void set_ForceDefaultValueNull(bool value);
    public string get_ValueParseFormat();
    public void set_ValueParseFormat(string value);
    public CultureInfo get_ValueParseCulture();
    public void set_ValueParseCulture(CultureInfo value);
    public object RenderValue(LogEventInfo logEvent);
    private ILayoutTypeValue get_LayoutValue();
    private ILayoutTypeValue get_DefaultLayoutValue();
    private ILayoutTypeValue BuildLayoutTypeValue(Layout layout);
}
[NLogConfigurationItemAttribute]
public class NLog.Layouts.XmlAttribute : object {
    private ValueTypeLayoutInfo _layoutInfo;
    private string _name;
    [CompilerGeneratedAttribute]
private bool <Encode>k__BackingField;
    private bool _includeEmptyValue;
    [RequiredParameterAttribute]
public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public Type ValueType { get; public set; }
    public Layout DefaultValue { get; public set; }
    public bool Encode { get; public set; }
    public bool IncludeEmptyValue { get; public set; }
    public XmlAttribute(string name, Layout layout);
    public XmlAttribute(string name, Layout layout, bool encode);
    public string get_Name();
    public void set_Name(string value);
    public Layout get_Layout();
    public void set_Layout(Layout value);
    public Type get_ValueType();
    public void set_ValueType(Type value);
    public Layout get_DefaultValue();
    public void set_DefaultValue(Layout value);
    [CompilerGeneratedAttribute]
public bool get_Encode();
    [CompilerGeneratedAttribute]
public void set_Encode(bool value);
    public bool get_IncludeEmptyValue();
    public void set_IncludeEmptyValue(bool value);
    internal bool RenderAppendXmlValue(LogEventInfo logEvent, StringBuilder builder);
}
[ThreadAgnosticAttribute]
public class NLog.Layouts.XmlElement : XmlElementBase {
    private static string DefaultElementName;
    [RequiredParameterAttribute]
public string Name { get; public set; }
    public Layout Value { get; public set; }
    public Layout Layout { get; public set; }
    public bool Encode { get; public set; }
    public XmlElement(string elementName, Layout elementValue);
    public string get_Name();
    public void set_Name(string value);
    public Layout get_Value();
    public void set_Value(Layout value);
    public Layout get_Layout();
    public void set_Layout(Layout value);
    public bool get_Encode();
    public void set_Encode(bool value);
}
public abstract class NLog.Layouts.XmlElementBase : Layout {
    private Layout[] _precalculateLayouts;
    private static string DefaultPropertyName;
    private static string DefaultPropertyKeyAttribute;
    private static string DefaultCollectionItemName;
    private string _elementNameInternal;
    internal XmlEncodeLayoutRendererWrapper LayoutWrapper;
    [CompilerGeneratedAttribute]
private bool <IndentXml>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<XmlElement> <Elements>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<XmlAttribute> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEmptyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEventProperties>k__BackingField;
    private Nullable`1<bool> _includeScopeProperties;
    private Nullable`1<bool> _includeMdc;
    private Nullable`1<bool> _includeMdlc;
    [CompilerGeneratedAttribute]
private ISet`1<string> <ExcludeProperties>k__BackingField;
    private string _propertiesElementName;
    private bool _propertiesElementNameHasFormat;
    [CompilerGeneratedAttribute]
private string <PropertiesElementKeyAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertiesElementValueAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertiesCollectionItemName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRecursionLimit>k__BackingField;
    private ObjectReflectionCache _objectReflectionCache;
    private static IEqualityComparer`1<object> _referenceEqualsComparer;
    private static int MaxXmlLength;
    internal string ElementNameInternal { get; internal set; }
    public bool IndentXml { get; public set; }
    [ArrayParameterAttribute("NLog.Layouts.XmlElement", "element")]
public IList`1<XmlElement> Elements { get; }
    [ArrayParameterAttribute("NLog.Layouts.XmlAttribute", "attribute")]
public IList`1<XmlAttribute> Attributes { get; }
    public bool IncludeEmptyValue { get; public set; }
    public bool IncludeEventProperties { get; public set; }
    public bool IncludeScopeProperties { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdlc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeEventProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeAllProperties { get; public set; }
    public ISet`1<string> ExcludeProperties { get; public set; }
    public string PropertiesElementName { get; public set; }
    public string PropertiesElementKeyAttribute { get; public set; }
    public string PropertiesElementValueAttribute { get; public set; }
    public string PropertiesCollectionItemName { get; public set; }
    public int MaxRecursionLimit { get; public set; }
    private ObjectReflectionCache ObjectReflectionCache { get; }
    protected XmlElementBase(string elementName, Layout elementValue);
    private static XmlElementBase();
    internal string get_ElementNameInternal();
    internal void set_ElementNameInternal(string value);
    [CompilerGeneratedAttribute]
public bool get_IndentXml();
    [CompilerGeneratedAttribute]
public void set_IndentXml(bool value);
    [CompilerGeneratedAttribute]
public IList`1<XmlElement> get_Elements();
    [CompilerGeneratedAttribute]
public IList`1<XmlAttribute> get_Attributes();
    [CompilerGeneratedAttribute]
public bool get_IncludeEmptyValue();
    [CompilerGeneratedAttribute]
public void set_IncludeEmptyValue(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEventProperties();
    [CompilerGeneratedAttribute]
public void set_IncludeEventProperties(bool value);
    public bool get_IncludeScopeProperties();
    public void set_IncludeScopeProperties(bool value);
    public bool get_IncludeMdc();
    public void set_IncludeMdc(bool value);
    public bool get_IncludeMdlc();
    public void set_IncludeMdlc(bool value);
    public bool get_IncludeAllProperties();
    public void set_IncludeAllProperties(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_ExcludeProperties();
    [CompilerGeneratedAttribute]
public void set_ExcludeProperties(ISet`1<string> value);
    public string get_PropertiesElementName();
    public void set_PropertiesElementName(string value);
    [CompilerGeneratedAttribute]
public string get_PropertiesElementKeyAttribute();
    [CompilerGeneratedAttribute]
public void set_PropertiesElementKeyAttribute(string value);
    [CompilerGeneratedAttribute]
public string get_PropertiesElementValueAttribute();
    [CompilerGeneratedAttribute]
public void set_PropertiesElementValueAttribute(string value);
    [CompilerGeneratedAttribute]
public string get_PropertiesCollectionItemName();
    [CompilerGeneratedAttribute]
public void set_PropertiesCollectionItemName(string value);
    [CompilerGeneratedAttribute]
public int get_MaxRecursionLimit();
    [CompilerGeneratedAttribute]
public void set_MaxRecursionLimit(int value);
    private ObjectReflectionCache get_ObjectReflectionCache();
    protected virtual void InitializeLayout();
    protected virtual void CloseLayout();
    internal virtual void PrecalculateBuilder(LogEventInfo logEvent, StringBuilder target);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    private void RenderXmlFormattedMessage(LogEventInfo logEvent, StringBuilder sb);
    private bool HasNestedXmlElements(LogEventInfo logEvent);
    private void AppendLogEventXmlProperties(LogEventInfo logEventInfo, StringBuilder sb, int orgLength);
    private void AppendLogEventProperties(LogEventInfo logEventInfo, StringBuilder sb, int orgLength);
    private bool AppendXmlPropertyObjectValue(string propName, object propertyValue, StringBuilder sb, int orgLength, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth, bool ignorePropertiesElementName);
    private static SingleItemScopedInsert<object> StartCollectionScope(SingleItemOptimizedHashSet`1& objectsInPath, object value);
    private void AppendXmlCollectionObject(string propName, IEnumerable collection, StringBuilder sb, int orgLength, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth, bool ignorePropertiesElementName);
    private void AppendXmlDictionaryObject(string propName, IDictionary dictionary, StringBuilder sb, int orgLength, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth, bool ignorePropertiesElementName);
    private void AppendXmlObjectPropertyValues(string propName, ObjectPropertyList& propertyValues, StringBuilder sb, int orgLength, SingleItemOptimizedHashSet`1& objectsInPath, int depth, bool ignorePropertiesElementName);
    private string AppendXmlPropertyValue(string propName, object propertyValue, StringBuilder sb, int orgLength, bool ignoreValue, bool ignorePropertiesElementName);
    private string AppendXmlPropertyStringValue(string propName, string xmlValueString, StringBuilder sb, int orgLength, bool ignoreValue, bool ignorePropertiesElementName);
    private void AppendClosingPropertyTag(string propNameElement, StringBuilder sb, bool ignorePropertiesElementName);
    private static bool RenderAttribute(StringBuilder sb, string attributeName, string value);
    private bool RenderAppendXmlElementValue(XmlElementBase xmlElement, LogEventInfo logEvent, StringBuilder sb, bool beginXmlDocument);
    private bool RenderAppendXmlAttributeValue(XmlAttribute xmlAttribute, LogEventInfo logEvent, StringBuilder sb, bool beginXmlDocument);
    private void BeginXmlDocument(StringBuilder sb, string elementName);
    private void EndXmlDocument(StringBuilder sb, string elementName);
    public virtual string ToString();
    private static void RenderSelfClosingElement(StringBuilder target, string elementName);
    private static void RenderStartElement(StringBuilder sb, string elementName);
    private static void RenderEndElement(StringBuilder sb, string elementName);
}
[LayoutAttribute("XmlLayout")]
[ThreadAgnosticAttribute]
public class NLog.Layouts.XmlLayout : XmlElementBase {
    private static string DefaultRootElementName;
    public string ElementName { get; public set; }
    public Layout ElementValue { get; public set; }
    public bool ElementEncode { get; public set; }
    public XmlLayout(string elementName, Layout elementValue);
    public string get_ElementName();
    public void set_ElementName(string value);
    public Layout get_ElementValue();
    public void set_ElementValue(Layout value);
    public bool get_ElementEncode();
    public void set_ElementEncode(bool value);
}
[ExtensionAttribute]
public static class NLog.LayoutTypedExtensions : object {
    [ExtensionAttribute]
public static T RenderValue(Layout`1<T> layout, LogEventInfo logEvent, T defaultValue);
}
[CLSCompliantAttribute("False")]
public class NLog.LogEventBuilder : ValueType {
    private ILogger _logger;
    private LogEventInfo _logEvent;
    [NotNullAttribute]
public ILogger Logger { get; }
    [CanBeNullAttribute]
public LogEventInfo LogEvent { get; }
    public LogEventBuilder(ILogger logger);
    public LogEventBuilder(ILogger logger, LogLevel logLevel);
    public ILogger get_Logger();
    public LogEventInfo get_LogEvent();
    public LogEventBuilder Property(string propertyName, T propertyValue);
    public LogEventBuilder Properties(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public LogEventBuilder Exception(Exception exception);
    public LogEventBuilder TimeStamp(DateTime timeStamp);
    public LogEventBuilder Message(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public LogEventBuilder Message(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public LogEventBuilder Message(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public LogEventBuilder Message(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public LogEventBuilder Message(string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public LogEventBuilder Message(IFormatProvider formatProvider, string message, Object[] args);
    public LogEventBuilder Callsite(string callerClassName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public void Log(LogLevel logLevel, string callerMemberName, string callerFilePath, int callerLineNumber);
    public void Log(Type wrapperType);
    private LogEventInfo ResolveLogEvent(LogEventInfo logEvent, LogLevel logLevel);
}
public class NLog.LogEventInfo : object {
    public static DateTime ZeroDate;
    private static int globalSequenceId;
    private string _formattedMessage;
    private string _message;
    private Object[] _parameters;
    private IFormatProvider _formatProvider;
    private LogMessageFormatter _messageFormatter;
    private IDictionary`2<Layout, object> _layoutCache;
    private PropertiesDictionary _properties;
    private int _sequenceId;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private CallSiteInformation <CallSiteInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    public int SequenceID { get; }
    public DateTime TimeStamp { get; public set; }
    public LogLevel Level { get; public set; }
    [CanBeNullAttribute]
internal CallSiteInformation CallSiteInformation { get; private set; }
    public bool HasStackTrace { get; }
    [ObsoleteAttribute("Instead use ${callsite} or CallerMemberName. Marked obsolete on NLog 5.3")]
public StackFrame UserStackFrame { get; }
    public int UserStackFrameNumber { get; }
    public StackTrace StackTrace { get; }
    public string CallerClassName { get; }
    public string CallerMemberName { get; }
    public string CallerFilePath { get; }
    public int CallerLineNumber { get; }
    [CanBeNullAttribute]
public Exception Exception { get; public set; }
    [CanBeNullAttribute]
public string LoggerName { get; public set; }
    public string Message { get; public set; }
    public Object[] Parameters { get; public set; }
    public IFormatProvider FormatProvider { get; public set; }
    public LogMessageFormatter MessageFormatter { get; public set; }
    public string FormattedMessage { get; }
    public bool HasProperties { get; }
    public IDictionary`2<object, object> Properties { get; }
    private bool HasMessageTemplateParameters { get; }
    public MessageTemplateParameters MessageTemplateParameters { get; }
    public LogEventInfo(LogLevel level, string loggerName, string message);
    public LogEventInfo(LogLevel level, string loggerName, string message, IList`1<MessageTemplateParameter> messageTemplateParameters);
    public LogEventInfo(LogLevel level, string loggerName, string formattedMessage, string messageTemplate, IList`1<MessageTemplateParameter> messageTemplateParameters);
    public LogEventInfo(LogLevel level, string loggerName, string message, IReadOnlyList`1<KeyValuePair`2<object, object>> eventProperties);
    public LogEventInfo(LogLevel level, string loggerName, IFormatProvider formatProvider, string message, Object[] parameters);
    public LogEventInfo(LogLevel level, string loggerName, IFormatProvider formatProvider, string message, Object[] parameters, Exception exception);
    private static LogEventInfo();
    public int get_SequenceID();
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
internal CallSiteInformation get_CallSiteInformation();
    [CompilerGeneratedAttribute]
private void set_CallSiteInformation(CallSiteInformation value);
    [NotNullAttribute]
internal CallSiteInformation GetCallSiteInformationInternal();
    public bool get_HasStackTrace();
    public StackFrame get_UserStackFrame();
    public int get_UserStackFrameNumber();
    public StackTrace get_StackTrace();
    public string get_CallerClassName();
    public string get_CallerMemberName();
    public string get_CallerFilePath();
    public int get_CallerLineNumber();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_LoggerName();
    [CompilerGeneratedAttribute]
public void set_LoggerName(string value);
    public string get_Message();
    public void set_Message(string value);
    public Object[] get_Parameters();
    public void set_Parameters(Object[] value);
    public IFormatProvider get_FormatProvider();
    public void set_FormatProvider(IFormatProvider value);
    public LogMessageFormatter get_MessageFormatter();
    public void set_MessageFormatter(LogMessageFormatter value);
    public string get_FormattedMessage();
    public bool get_HasProperties();
    public IDictionary`2<object, object> get_Properties();
    internal PropertiesDictionary CreateOrUpdatePropertiesInternal(bool forceCreate, IList`1<MessageTemplateParameter> templateParameters);
    private bool get_HasMessageTemplateParameters();
    public MessageTemplateParameters get_MessageTemplateParameters();
    public static LogEventInfo CreateNullEvent();
    public static LogEventInfo Create(LogLevel logLevel, string loggerName, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public static LogEventInfo Create(LogLevel logLevel, string loggerName, IFormatProvider formatProvider, string message, Object[] parameters);
    public static LogEventInfo Create(LogLevel logLevel, string loggerName, IFormatProvider formatProvider, object message);
    public static LogEventInfo Create(LogLevel logLevel, string loggerName, Exception exception, IFormatProvider formatProvider, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public static LogEventInfo Create(LogLevel logLevel, string loggerName, Exception exception, IFormatProvider formatProvider, string message, Object[] parameters);
    public AsyncLogEventInfo WithContinuation(AsyncContinuation asyncContinuation);
    public virtual string ToString();
    public void SetStackTrace(StackTrace stackTrace, int userStackFrame);
    public void SetCallerInfo(string callerClassName, string callerMemberName, string callerFilePath, int callerLineNumber);
    internal void AddCachedLayoutValue(Layout layout, object value);
    internal bool TryGetCachedLayoutValue(Layout layout, Object& value);
    private static bool NeedToPreformatMessage(Object[] parameters);
    private static bool IsSafeToDeferFormatting(object value);
    internal bool IsLogEventThreadAgnosticImmutable();
    private static bool HasImmutableProperties(PropertiesDictionary properties);
    internal void SetMessageFormatter(LogMessageFormatter messageFormatter, LogMessageFormatter singleTargetMessageFormatter);
    private void CalcFormattedMessage();
    internal void AppendFormattedMessage(ILogMessageFormatter messageFormatter, StringBuilder builder);
    private void ResetFormattedMessage(bool rebuildMessageTemplateParameters);
    private bool ResetMessageTemplateParameters();
}
public class NLog.LogFactory : object {
    private static TimeSpan DefaultFlushTimeout;
    [ObsoleteAttribute("For unit testing only. Marked obsolete on NLog 5.0")]
private static IAppDomain currentAppDomain;
    private static AppEnvironmentWrapper defaultAppEnvironment;
    internal object _syncRoot;
    private LoggerCache _loggerCache;
    [NotNullAttribute]
private ServiceRepositoryInternal _serviceRepository;
    private IAppEnvironment _currentAppEnvironment;
    internal LoggingConfiguration _config;
    internal LogMessageFormatter ActiveMessageFormatter;
    internal LogMessageFormatter SingleTargetMessageFormatter;
    private LogLevel _globalThreshold;
    private bool _configLoaded;
    private int _supendLoggingCounter;
    [ObsoleteAttribute("Replaced by LogFactory.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
private List`1<string> _candidateConfigFilePaths;
    private ILoggingConfigurationLoader _configLoader;
    [CompilerGeneratedAttribute]
private EventHandler`1<LoggingConfigurationChangedEventArgs> ConfigurationChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<LoggingConfigurationReloadedEventArgs> ConfigurationReloaded;
    [CompilerGeneratedAttribute]
private static EventHandler`1<EventArgs> LoggerShutdown;
    [CompilerGeneratedAttribute]
private bool <ThrowExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ThrowConfigExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepVariablesOnReload>k__BackingField;
    private bool _autoShutdown;
    internal CultureInfo _defaultCultureInfo;
    private bool _isDisposing;
    [ObsoleteAttribute("For unit testing only. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static IAppDomain CurrentAppDomain { get; public set; }
    internal static IAppEnvironment DefaultAppEnvironment { get; }
    internal IAppEnvironment CurrentAppEnvironment { get; internal set; }
    public bool ThrowExceptions { get; public set; }
    public Nullable`1<bool> ThrowConfigExceptions { get; public set; }
    public bool KeepVariablesOnReload { get; public set; }
    public bool AutoShutdown { get; public set; }
    public LoggingConfiguration Configuration { get; public set; }
    [NotNullAttribute]
public ServiceRepository ServiceRepository { get; internal set; }
    public LogLevel GlobalThreshold { get; public set; }
    [CanBeNullAttribute]
public CultureInfo DefaultCultureInfo { get; public set; }
    private static LogFactory();
    [ObsoleteAttribute("Constructor with LoggingConfiguration as parameter should not be used. Instead provide LogFactory as parameter when constructing LoggingConfiguration. Marked obsolete in NLog 5.0")]
[EditorBrowsableAttribute("1")]
public LogFactory(LoggingConfiguration config);
    internal LogFactory(ILoggingConfigurationLoader configLoader, IAppEnvironment appEnvironment);
    [CompilerGeneratedAttribute]
public void add_ConfigurationChanged(EventHandler`1<LoggingConfigurationChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ConfigurationChanged(EventHandler`1<LoggingConfigurationChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ConfigurationReloaded(EventHandler`1<LoggingConfigurationReloadedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ConfigurationReloaded(EventHandler`1<LoggingConfigurationReloadedEventArgs> value);
    [CompilerGeneratedAttribute]
private static void add_LoggerShutdown(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove_LoggerShutdown(EventHandler`1<EventArgs> value);
    public static IAppDomain get_CurrentAppDomain();
    public static void set_CurrentAppDomain(IAppDomain value);
    internal static IAppEnvironment get_DefaultAppEnvironment();
    internal IAppEnvironment get_CurrentAppEnvironment();
    internal void set_CurrentAppEnvironment(IAppEnvironment value);
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptions();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptions(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ThrowConfigExceptions();
    [CompilerGeneratedAttribute]
public void set_ThrowConfigExceptions(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_KeepVariablesOnReload();
    [CompilerGeneratedAttribute]
public void set_KeepVariablesOnReload(bool value);
    public bool get_AutoShutdown();
    public void set_AutoShutdown(bool value);
    public LoggingConfiguration get_Configuration();
    public void set_Configuration(LoggingConfiguration value);
    private void ActivateLoggingConfiguration(LoggingConfiguration config);
    public ServiceRepository get_ServiceRepository();
    internal void set_ServiceRepository(ServiceRepository value);
    private void ServiceRepository_TypeRegistered(object sender, ServiceRepositoryUpdateEventArgs e);
    private void RefreshMessageFormatter();
    public LogLevel get_GlobalThreshold();
    public void set_GlobalThreshold(LogLevel value);
    public CultureInfo get_DefaultCultureInfo();
    public void set_DefaultCultureInfo(CultureInfo value);
    [ObsoleteAttribute("LogFactory should be minimal. Marked obsolete with NLog v5.3")]
internal static void LogNLogAssemblyVersion();
    public sealed virtual void Dispose();
    public ISetupBuilder Setup();
    public LogFactory Setup(Action`1<ISetupBuilder> setupBuilder);
    public Logger CreateNullLogger();
    public Logger GetCurrentClassLogger();
    public T GetCurrentClassLogger();
    [ObsoleteAttribute("Replaced by GetCurrentClassLogger<T>(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public Logger GetCurrentClassLogger(Type loggerType);
    public Logger GetLogger(string name);
    public T GetLogger(string name);
    [ObsoleteAttribute("Replaced by GetLogger<T>(). Marked obsolete on NLog 5.2")]
[UnconditionalSuppressMessageAttribute("Trimming - Ignore since obsolete", "IL2067")]
[EditorBrowsableAttribute("1")]
public Logger GetLogger(string name, Type loggerType);
    private bool RefreshExistingLoggers();
    public void ReconfigExistingLoggers();
    public void ReconfigExistingLoggers(bool purgeObsoleteLoggers);
    public void Flush();
    public void Flush(TimeSpan timeout);
    public void Flush(int timeoutMilliseconds);
    public void Flush(AsyncContinuation asyncContinuation);
    public void Flush(AsyncContinuation asyncContinuation, int timeoutMilliseconds);
    public void Flush(AsyncContinuation asyncContinuation, TimeSpan timeout);
    private void FlushInternal(TimeSpan flushTimeout, AsyncContinuation asyncContinuation);
    public IDisposable SuspendLogging();
    public void ResumeLogging();
    public bool IsLoggingEnabled();
    protected virtual void OnConfigurationChanged(LoggingConfigurationChangedEventArgs e);
    [ObsoleteAttribute("Replaced by ConfigurationChanged, but check args.ActivatedConfiguration != null. Marked obsolete on NLog 5.2")]
protected virtual void OnConfigurationReloaded(LoggingConfigurationReloadedEventArgs e);
    [ObsoleteAttribute("Replaced by ConfigurationChanged, but check args.ActivatedConfiguration != null. Marked obsolete on NLog 5.2")]
internal void NotifyConfigurationReloaded(LoggingConfigurationReloadedEventArgs eventArgs);
    internal TargetWithFilterChain[] BuildLoggerConfiguration(string loggerName, List`1<LoggingRule> loggingRules);
    private void Close(TimeSpan flushTimeout);
    private void CloseOldConfig(TimeSpan flushTimeout, LoggingConfiguration oldConfig);
    protected virtual void Dispose(bool disposing);
    public void Shutdown();
    [ObsoleteAttribute("Replaced by LogFactory.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public IEnumerable`1<string> GetCandidateConfigFilePaths();
    [ObsoleteAttribute("Replaced by chaining LogFactory.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
internal IEnumerable`1<string> GetCandidateConfigFilePaths(string filename);
    [ObsoleteAttribute("Replaced by chaining LogFactory.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public void SetCandidateConfigFilePaths(IEnumerable`1<string> filePaths);
    [ObsoleteAttribute("Replaced by chaining LogFactory.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public void ResetCandidateConfigFilePath();
    private Logger GetLoggerThreadSafe(string name, Type loggerType, Func`2<Type, Logger> loggerCreator);
    internal Logger CreateNewLogger(Type loggerType, Func`2<Type, Logger> loggerCreator);
    [ObsoleteAttribute("Replaced by LogFactory.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public LogFactory LoadConfiguration(string configFile);
    internal LogFactory LoadConfiguration(string configFile, bool optional);
    private string CreateFileNotFoundMessage(string configFile);
    internal int ResetLoggerCache();
    private static void RegisterEvents(IAppEnvironment appEnvironment);
    private static void UnregisterEvents(IAppEnvironment appEnvironment);
    private static void OnLoggerShutdown(object sender, EventArgs args);
    private void OnStopLogging(object sender, EventArgs args);
}
public class NLog.LogFactory`1 : LogFactory {
    public T GetLogger(string name);
    public T GetCurrentClassLogger();
}
[CLSCompliantAttribute("True")]
public class NLog.Logger : object {
    internal static Type DefaultLoggerType;
    private ITargetWithFilterChain[] _targetsByLevel;
    private Logger _contextLogger;
    private ThreadSafeDictionary`2<string, object> _contextProperties;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isTraceEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDebugEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isInfoEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isWarnEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isErrorEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isFatalEnabled;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> LoggerReconfigured;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LogFactory <Factory>k__BackingField;
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public string Name { get; private set; }
    public LogFactory Factory { get; private set; }
    public IDictionary`2<string, object> Properties { get; }
    private static Logger();
    [ConditionalAttribute("DEBUG")]
public void ConditionalDebug(T value);
    [ConditionalAttribute("DEBUG")]
public void ConditionalDebug(IFormatProvider formatProvider, T value);
    [ConditionalAttribute("DEBUG")]
public void ConditionalDebug(LogMessageGenerator messageFunc);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(Exception exception, string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
public void ConditionalDebug(string message);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, TArgument argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, TArgument argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, TArgument1 argument1, TArgument2 argument2);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ConditionalAttribute("DEBUG")]
public void ConditionalDebug(object value);
    [ConditionalAttribute("DEBUG")]
public void ConditionalDebug(IFormatProvider formatProvider, object value);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, object arg1, object arg2);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, object arg1, object arg2, object arg3);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, bool argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, bool argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, char argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, char argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, byte argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, byte argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, string argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, string argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, int argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, int argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, long argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, long argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, float argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, float argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, double argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, double argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, decimal argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, decimal argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(IFormatProvider formatProvider, string message, object argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalDebug(string message, object argument);
    [ConditionalAttribute("DEBUG")]
public void ConditionalTrace(T value);
    [ConditionalAttribute("DEBUG")]
public void ConditionalTrace(IFormatProvider formatProvider, T value);
    [ConditionalAttribute("DEBUG")]
public void ConditionalTrace(LogMessageGenerator messageFunc);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(Exception exception, string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
public void ConditionalTrace(string message);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, TArgument argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, TArgument argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, TArgument1 argument1, TArgument2 argument2);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [ConditionalAttribute("DEBUG")]
public void ConditionalTrace(object value);
    [ConditionalAttribute("DEBUG")]
public void ConditionalTrace(IFormatProvider formatProvider, object value);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, object arg1, object arg2);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, object arg1, object arg2, object arg3);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, bool argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, bool argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, char argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, char argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, byte argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, byte argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, string argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, string argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, int argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, int argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, long argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, long argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, float argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, float argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, double argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, double argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, decimal argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, decimal argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(IFormatProvider formatProvider, string message, object argument);
    [ConditionalAttribute("DEBUG")]
[MessageTemplateFormatMethodAttribute("message")]
public void ConditionalTrace(string message, object argument);
    public sealed virtual bool get_IsTraceEnabled();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual void Trace(T value);
    public sealed virtual void Trace(IFormatProvider formatProvider, T value);
    public sealed virtual void Trace(LogMessageGenerator messageFunc);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, Object[] args);
    public sealed virtual void Trace(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, Object[] args);
    public sealed virtual void Trace(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public sealed virtual void Debug(T value);
    public sealed virtual void Debug(IFormatProvider formatProvider, T value);
    public sealed virtual void Debug(LogMessageGenerator messageFunc);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, Object[] args);
    public sealed virtual void Debug(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, Object[] args);
    public sealed virtual void Debug(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public sealed virtual void Info(T value);
    public sealed virtual void Info(IFormatProvider formatProvider, T value);
    public sealed virtual void Info(LogMessageGenerator messageFunc);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, Object[] args);
    public sealed virtual void Info(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, Object[] args);
    public sealed virtual void Info(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public sealed virtual void Warn(T value);
    public sealed virtual void Warn(IFormatProvider formatProvider, T value);
    public sealed virtual void Warn(LogMessageGenerator messageFunc);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, Object[] args);
    public sealed virtual void Warn(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, Object[] args);
    public sealed virtual void Warn(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public sealed virtual void Error(T value);
    public sealed virtual void Error(IFormatProvider formatProvider, T value);
    public sealed virtual void Error(LogMessageGenerator messageFunc);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, Object[] args);
    public sealed virtual void Error(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, Object[] args);
    public sealed virtual void Error(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public sealed virtual void Fatal(T value);
    public sealed virtual void Fatal(IFormatProvider formatProvider, T value);
    public sealed virtual void Fatal(LogMessageGenerator messageFunc);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, Object[] args);
    public sealed virtual void Fatal(string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, Object[] args);
    public sealed virtual void Fatal(Exception exception, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Log(LogLevel level, object value);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Trace(object value);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Trace(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Trace(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Debug(object value);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Debug(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Debug(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Info(object value);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Info(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Info(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Warn(object value);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Warn(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Warn(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Error(object value);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Error(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Error(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Fatal(object value);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Fatal(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, bool argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, char argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, byte argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, string argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, int argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, long argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, float argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, double argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Fatal(string message, ulong argument);
    private sealed virtual override void NLog.ILoggerBase.LogException(LogLevel level, string message, Exception exception);
    private sealed virtual override void NLog.ILoggerBase.Log(LogLevel level, string message, Exception exception);
    [ObsoleteAttribute("Use Trace(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public sealed virtual void TraceException(string message, Exception exception);
    private sealed virtual override void NLog.ILogger.Trace(string message, Exception exception);
    [ObsoleteAttribute("Use Debug(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public sealed virtual void DebugException(string message, Exception exception);
    private sealed virtual override void NLog.ILogger.Debug(string message, Exception exception);
    [ObsoleteAttribute("Use Info(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public sealed virtual void InfoException(string message, Exception exception);
    private sealed virtual override void NLog.ILogger.Info(string message, Exception exception);
    [ObsoleteAttribute("Use Warn(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public sealed virtual void WarnException(string message, Exception exception);
    private sealed virtual override void NLog.ILogger.Warn(string message, Exception exception);
    [ObsoleteAttribute("Use Error(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public sealed virtual void ErrorException(string message, Exception exception);
    private sealed virtual override void NLog.ILogger.Error(string message, Exception exception);
    [ObsoleteAttribute("Use Fatal(Exception exception, string message) method instead. Marked obsolete with v4.3.11 (Only here because of LibLog)")]
[EditorBrowsableAttribute("1")]
public sealed virtual void FatalException(string message, Exception exception);
    private sealed virtual override void NLog.ILogger.Fatal(string message, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LoggerReconfigured(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LoggerReconfigured(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual LogFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(LogFactory value);
    public IDictionary`2<string, object> get_Properties();
    public sealed virtual bool IsEnabled(LogLevel level);
    public Logger WithProperty(string propertyKey, object propertyValue);
    public Logger WithProperties(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    [ObsoleteAttribute("Instead use WithProperty which is safe. If really necessary then one can use Properties-property. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public void SetProperty(string propertyKey, object propertyValue);
    private static ThreadSafeDictionary`2<string, object> CreateContextPropertiesDictionary(ThreadSafeDictionary`2<string, object> contextProperties);
    public IDisposable PushScopeProperty(string propertyName, object propertyValue);
    public IDisposable PushScopeProperty(string propertyName, TValue propertyValue);
    public IDisposable PushScopeProperties(IReadOnlyCollection`1<KeyValuePair`2<string, object>> scopeProperties);
    public IDisposable PushScopeProperties(IReadOnlyCollection`1<KeyValuePair`2<string, TValue>> scopeProperties);
    public IDisposable PushScopeNested(T nestedState);
    public IDisposable PushScopeNested(object nestedState);
    public sealed virtual void Log(LogEventInfo logEvent);
    public sealed virtual void Log(Type wrapperType, LogEventInfo logEvent);
    public sealed virtual void Log(LogLevel level, T value);
    public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, T value);
    public sealed virtual void Log(LogLevel level, LogMessageGenerator messageFunc);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, Object[] args);
    public sealed virtual void Log(LogLevel level, string message);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, Exception exception, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, Exception exception, IFormatProvider formatProvider, string message, Object[] args);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, TArgument argument);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, TArgument1 argument1, TArgument2 argument2);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    [MessageTemplateFormatMethodAttribute("message")]
public sealed virtual void Log(LogLevel level, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    private LogEventInfo PrepareLogEventInfo(LogEventInfo logEvent);
    public sealed virtual void Swallow(Action action);
    public sealed virtual T Swallow(Func`1<T> func);
    public sealed virtual T Swallow(Func`1<T> func, T fallback);
    [AsyncStateMachineAttribute("NLog.Logger/<Swallow>d__457")]
public sealed virtual void Swallow(Task task);
    [AsyncStateMachineAttribute("NLog.Logger/<SwallowAsync>d__458")]
public sealed virtual Task SwallowAsync(Task task);
    [AsyncStateMachineAttribute("NLog.Logger/<SwallowAsync>d__459")]
public sealed virtual Task SwallowAsync(Func`1<Task> asyncAction);
    [AsyncStateMachineAttribute("NLog.Logger/<SwallowAsync>d__460`1")]
public sealed virtual Task`1<TResult> SwallowAsync(Func`1<Task`1<TResult>> asyncFunc);
    [AsyncStateMachineAttribute("NLog.Logger/<SwallowAsync>d__461`1")]
public sealed virtual Task`1<TResult> SwallowAsync(Func`1<Task`1<TResult>> asyncFunc, TResult fallback);
    internal void Initialize(string name, ITargetWithFilterChain[] targetsByLevel, LogFactory factory);
    private void WriteToTargets(LogLevel level, string message, Object[] args);
    private void WriteToTargets(LogLevel level, IFormatProvider formatProvider, string message, Object[] args);
    private void WriteToTargets(LogLevel level, string message);
    private void WriteToTargets(LogLevel level, IFormatProvider formatProvider, T value);
    private void WriteToTargets(LogLevel level, Exception ex, string message, Object[] args);
    private void WriteToTargets(LogLevel level, Exception ex, IFormatProvider formatProvider, string message, Object[] args);
    private void WriteToTargets(LogEventInfo logEvent, ITargetWithFilterChain targetsForLevel);
    private void WriteToTargets(Type wrapperType, LogEventInfo logEvent, ITargetWithFilterChain targetsForLevel);
    internal void SetConfiguration(ITargetWithFilterChain[] targetsByLevel);
    private ITargetWithFilterChain GetTargetsForLevelSafe(LogLevel level);
    private ITargetWithFilterChain GetTargetsForLevel(LogLevel level);
    protected virtual void OnLoggerReconfigured(EventArgs e);
    private Logger CreateChildLogger();
}
internal static class NLog.LoggerImpl : object {
    private static int StackTraceSkipMethods;
    internal static void Write(Type loggerType, TargetWithFilterChain targetsForLevel, LogEventInfo logEvent, LogFactory logFactory);
    private static void CaptureCallSiteInfo(LogFactory logFactory, Type loggerType, LogEventInfo logEvent, StackTraceUsage stackTraceUsage);
    private static bool WriteToTargetWithFilterChain(Target target, FilterResult result, LogEventInfo logEvent, AsyncContinuation onException);
    private static FilterResult GetFilterResult(IList`1<Filter> filterChain, LogEventInfo logEvent, FilterResult filterDefaultAction);
}
[TypeConverterAttribute("NLog.Attributes.LogLevelTypeConverter")]
public class NLog.LogLevel : object {
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
    public static LogLevel Fatal;
    public static LogLevel Off;
    private static IList`1<LogLevel> allLevels;
    private static IList`1<LogLevel> allLoggingLevels;
    private int _ordinal;
    private string _name;
    public static IEnumerable`1<LogLevel> AllLevels { get; }
    public static IEnumerable`1<LogLevel> AllLoggingLevels { get; }
    internal static LogLevel MaxLevel { get; }
    internal static LogLevel MinLevel { get; }
    public string Name { get; }
    public int Ordinal { get; }
    private LogLevel(string name, int ordinal);
    private static LogLevel();
    public static IEnumerable`1<LogLevel> get_AllLevels();
    public static IEnumerable`1<LogLevel> get_AllLoggingLevels();
    internal static LogLevel get_MaxLevel();
    internal static LogLevel get_MinLevel();
    public string get_Name();
    public int get_Ordinal();
    public static bool op_Equality(LogLevel level1, LogLevel level2);
    public static bool op_Inequality(LogLevel level1, LogLevel level2);
    public static bool op_GreaterThan(LogLevel level1, LogLevel level2);
    public static bool op_GreaterThanOrEqual(LogLevel level1, LogLevel level2);
    public static bool op_LessThan(LogLevel level1, LogLevel level2);
    public static bool op_LessThanOrEqual(LogLevel level1, LogLevel level2);
    public static LogLevel FromOrdinal(int ordinal);
    public static LogLevel FromString(string levelName);
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LogLevel other);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(LogLevel other);
}
public static class NLog.LogManager : object {
    private static LogFactory factory;
    public static LogFactory LogFactory { get; }
    public static bool ThrowExceptions { get; public set; }
    public static Nullable`1<bool> ThrowConfigExceptions { get; public set; }
    public static bool KeepVariablesOnReload { get; public set; }
    public static bool AutoShutdown { get; public set; }
    public static LoggingConfiguration Configuration { get; public set; }
    public static LogLevel GlobalThreshold { get; public set; }
    private static LogManager();
    public static LogFactory get_LogFactory();
    public static void add_ConfigurationChanged(EventHandler`1<LoggingConfigurationChangedEventArgs> value);
    public static void remove_ConfigurationChanged(EventHandler`1<LoggingConfigurationChangedEventArgs> value);
    public static void add_ConfigurationReloaded(EventHandler`1<LoggingConfigurationReloadedEventArgs> value);
    public static void remove_ConfigurationReloaded(EventHandler`1<LoggingConfigurationReloadedEventArgs> value);
    public static bool get_ThrowExceptions();
    public static void set_ThrowExceptions(bool value);
    public static Nullable`1<bool> get_ThrowConfigExceptions();
    public static void set_ThrowConfigExceptions(Nullable`1<bool> value);
    public static bool get_KeepVariablesOnReload();
    public static void set_KeepVariablesOnReload(bool value);
    public static bool get_AutoShutdown();
    public static void set_AutoShutdown(bool value);
    public static LoggingConfiguration get_Configuration();
    public static void set_Configuration(LoggingConfiguration value);
    public static LogLevel get_GlobalThreshold();
    public static void set_GlobalThreshold(LogLevel value);
    public static ISetupBuilder Setup();
    public static LogFactory Setup(Action`1<ISetupBuilder> setupBuilder);
    [ObsoleteAttribute("Replaced by LogManager.Setup().LoadConfigurationFromFile(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static LogFactory LoadConfiguration(string configFile);
    [ObsoleteAttribute("Replaced by LogManager.Setup().SetupLogFactory(setup => setup.AddCallSiteHiddenAssembly(assembly)). Marked obsolete on NLog 5.3")]
public static void AddHiddenAssembly(Assembly assembly);
    [CLSCompliantAttribute("False")]
public static Logger GetCurrentClassLogger();
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Replaced by LogFactory.GetCurrentClassLogger<T>(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static Logger GetCurrentClassLogger(Type loggerType);
    public static Logger CreateNullLogger();
    public static Logger GetLogger(string name);
    [ObsoleteAttribute("Replaced by LogFactory.GetLogger<T>(). Marked obsolete on NLog 5.2")]
[EditorBrowsableAttribute("1")]
public static Logger GetLogger(string name, Type loggerType);
    public static void ReconfigExistingLoggers();
    public static void ReconfigExistingLoggers(bool purgeObsoleteLoggers);
    public static void Flush();
    public static void Flush(TimeSpan timeout);
    public static void Flush(int timeoutMilliseconds);
    public static void Flush(AsyncContinuation asyncContinuation);
    public static void Flush(AsyncContinuation asyncContinuation, TimeSpan timeout);
    public static void Flush(AsyncContinuation asyncContinuation, int timeoutMilliseconds);
    [ObsoleteAttribute("Use SuspendLogging() instead. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static IDisposable DisableLogging();
    [ObsoleteAttribute("Use ResumeLogging() instead. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static void EnableLogging();
    public static IDisposable SuspendLogging();
    public static void ResumeLogging();
    public static bool IsLoggingEnabled();
    public static void Shutdown();
}
public class NLog.LogMessageFormatter : MulticastDelegate {
    public LogMessageFormatter(object object, IntPtr method);
    public virtual string Invoke(LogEventInfo logEvent);
    public virtual IAsyncResult BeginInvoke(LogEventInfo logEvent, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class NLog.LogMessageGenerator : MulticastDelegate {
    public LogMessageGenerator(object object, IntPtr method);
    public virtual string Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static class NLog.MappedDiagnosticsContext : object {
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static IDisposable SetScoped(string item, string value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static IDisposable SetScoped(string item, object value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static void Set(string item, string value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static void Set(string item, object value);
    [ObsoleteAttribute("Replaced by ScopeContext.TryGetProperty. Marked obsolete on NLog 5.0")]
public static string Get(string item);
    [ObsoleteAttribute("Replaced by ScopeContext.TryGetProperty. Marked obsolete on NLog 5.0")]
public static string Get(string item, IFormatProvider formatProvider);
    [ObsoleteAttribute("Replaced by ScopeContext.TryGetProperty. Marked obsolete on NLog 5.0")]
public static object GetObject(string item);
    [ObsoleteAttribute("Replaced by ScopeContext.GetAllProperties. Marked obsolete on NLog 5.0")]
public static ICollection`1<string> GetNames();
    [ObsoleteAttribute("Replaced by ScopeContext.TryGetProperty. Marked obsolete on NLog 5.0")]
public static bool Contains(string item);
    [ObsoleteAttribute("Replaced by dispose of return value from ScopeContext.PushProperty. Marked obsolete on NLog 5.0")]
public static void Remove(string item);
    [ObsoleteAttribute("Replaced by ScopeContext.Clear(). Marked obsolete on NLog 5.0")]
public static void Clear();
}
[ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static class NLog.MappedDiagnosticsLogicalContext : object {
    [ObsoleteAttribute("Replaced by ScopeContext.TryGetProperty. Marked obsolete on NLog 5.0")]
public static string Get(string item);
    [ObsoleteAttribute("Replaced by ScopeContext.TryGetProperty. Marked obsolete on NLog 5.0")]
public static string Get(string item, IFormatProvider formatProvider);
    [ObsoleteAttribute("Replaced by ScopeContext.TryGetProperty. Marked obsolete on NLog 5.0")]
public static object GetObject(string item);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static IDisposable SetScoped(string item, string value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static IDisposable SetScoped(string item, object value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static IDisposable SetScoped(string item, T value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperties or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static IDisposable SetScoped(IReadOnlyList`1<KeyValuePair`2<string, object>> items);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static void Set(string item, string value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static void Set(string item, object value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty or Logger.PushScopeProperty using ${scopeproperty}. Marked obsolete on NLog 5.0")]
public static void Set(string item, T value);
    [ObsoleteAttribute("Replaced by ScopeContext.GetAllProperties. Marked obsolete on NLog 5.0")]
public static ICollection`1<string> GetNames();
    [ObsoleteAttribute("Replaced by ScopeContext.TryGetProperty. Marked obsolete on NLog 5.0")]
public static bool Contains(string item);
    [ObsoleteAttribute("Replaced by dispose of return value from ScopeContext.PushProperty. Marked obsolete on NLog 5.0")]
public static void Remove(string item);
    [ObsoleteAttribute("Replaced by ScopeContext.Clear(). Marked obsolete on NLog 5.0")]
public static void Clear();
    [ObsoleteAttribute("Replaced by ScopeContext.Clear(). Marked obsolete on NLog 5.0")]
public static void Clear(bool free);
}
[AttributeUsageAttribute("96")]
public class NLog.MessageTemplateFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public MessageTemplateFormatMethodAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
public enum NLog.MessageTemplates.CaptureType : Enum {
    public byte value__;
    public static CaptureType Unknown;
    public static CaptureType Normal;
    public static CaptureType Serialize;
    public static CaptureType Stringify;
}
internal class NLog.MessageTemplates.Hole : ValueType {
    public string Name;
    public string Format;
    public CaptureType CaptureType;
    public short Index;
    public short Alignment;
    public Hole(string name, string format, CaptureType captureType, short parameterIndex, short alignment);
}
internal class NLog.MessageTemplates.Literal : ValueType {
    public int Print;
    public int Skip;
    public Literal(int print, int skip);
}
internal class NLog.MessageTemplates.LiteralHole : ValueType {
    public Literal Literal;
    public Hole Hole;
    public bool MaybePositionalTemplate { get; }
    public LiteralHole(Literal literal, Hole hole);
    public bool get_MaybePositionalTemplate();
}
public class NLog.MessageTemplates.MessageTemplateParameter : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CaptureType <CaptureType>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public object Value { get; }
    [CanBeNullAttribute]
public string Format { get; }
    public CaptureType CaptureType { get; }
    public Nullable`1<int> PositionalIndex { get; }
    internal MessageTemplateParameter(string name, object value, string format);
    public MessageTemplateParameter(string name, object value, string format, CaptureType captureType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public CaptureType get_CaptureType();
    public Nullable`1<int> get_PositionalIndex();
}
[DefaultMemberAttribute("Item")]
public class NLog.MessageTemplates.MessageTemplateParameters : object {
    internal static MessageTemplateParameters Empty;
    private IList`1<MessageTemplateParameter> _parameters;
    [CompilerGeneratedAttribute]
private bool <IsPositional>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValidTemplate>k__BackingField;
    public MessageTemplateParameter Item { get; }
    public int Count { get; }
    public bool IsPositional { get; }
    internal bool IsValidTemplate { get; }
    internal MessageTemplateParameters(string message, Object[] parameters);
    internal MessageTemplateParameters(IList`1<MessageTemplateParameter> templateParameters, string message, Object[] parameters);
    private static MessageTemplateParameters();
    public sealed virtual IEnumerator`1<MessageTemplateParameter> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public MessageTemplateParameter get_Item(int index);
    public int get_Count();
    [CompilerGeneratedAttribute]
public bool get_IsPositional();
    [CompilerGeneratedAttribute]
internal bool get_IsValidTemplate();
    private static IList`1<MessageTemplateParameter> ParseMessageTemplate(string template, Object[] parameters, Boolean& isPositional, Boolean& isValidTemplate);
    private static short GetMaxHoleIndex(short maxHoleIndex, short holeIndex);
    private static object GetHoleValueSafe(Object[] parameters, short holeIndex, Boolean& isValidTemplate);
}
internal class NLog.MessageTemplates.TemplateEnumerator : ValueType {
    private static Char[] HoleDelimiters;
    private static Char[] TextDelimiters;
    private string _template;
    private int _length;
    private int _position;
    private int _literalLength;
    private LiteralHole _current;
    private static short Zero;
    public LiteralHole Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public TemplateEnumerator(string template);
    private static TemplateEnumerator();
    public sealed virtual LiteralHole get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    private void AddLiteral();
    private void ParseTextPart();
    private void ParseOpenBracketPart();
    private void ParseCloseBracketPart();
    private void ParseHole(CaptureType type);
    private string ParseName(Int32& parameterIndex);
    private static string ParameterIndexToString(int parameterIndex);
    private string ParseFormat();
    private int ParseAlignment();
    private char Peek();
    private char Read();
    private void Skip(char c);
    private void SkipSpaces();
    private int SkipUntil(Char[] search, bool required);
    private int ReadInt();
    private string ReadUntil(Char[] search, bool required);
}
public class NLog.MessageTemplates.TemplateParserException : Exception {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Template>k__BackingField;
    public int Index { get; }
    public string Template { get; }
    public TemplateParserException(string message, int index, string template);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public string get_Template();
}
internal class NLog.MessageTemplates.ValueFormatter : object {
    private static IEqualityComparer`1<object> _referenceEqualsComparer;
    private MruCache`2<Enum, string> _enumCache;
    private IServiceProvider _serviceProvider;
    private IJsonConverter _jsonConverter;
    private static int MaxRecursionDepth;
    private static int MaxValueLength;
    private static string LiteralFormatSymbol;
    public static string FormatAsJson;
    public static string FormatAsString;
    private IJsonConverter JsonConverter { get; }
    public ValueFormatter(IServiceProvider serviceProvider);
    private static ValueFormatter();
    private IJsonConverter get_JsonConverter();
    public sealed virtual bool FormatValue(object value, string format, CaptureType captureType, IFormatProvider formatProvider, StringBuilder builder);
    public bool FormatObject(object value, string format, IFormatProvider formatProvider, StringBuilder builder);
    private bool SerializeSimpleObject(object value, string format, IFormatProvider formatProvider, StringBuilder builder, bool convertToString);
    private void SerializeConvertibleObject(IConvertible value, string format, IFormatProvider formatProvider, StringBuilder builder);
    private static void SerializeConvertToString(object value, IFormatProvider formatProvider, StringBuilder builder);
    private static void SerializeStringObject(string stringValue, string format, StringBuilder builder);
    private void AppendEnumAsString(StringBuilder sb, Enum value);
    private bool SerializeWithoutCyclicLoop(IEnumerable collection, string format, IFormatProvider formatProvider, StringBuilder builder, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth);
    private bool SerializeDictionaryObject(IDictionary dictionary, string format, IFormatProvider formatProvider, StringBuilder builder, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth);
    private bool SerializeCollectionObject(IEnumerable collection, string format, IFormatProvider formatProvider, StringBuilder builder, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth);
    private void SerializeCollectionItem(object item, string format, IFormatProvider formatProvider, StringBuilder builder, SingleItemOptimizedHashSet`1& objectsInPath, int depth);
    public static void FormatToString(object value, string format, IFormatProvider formatProvider, StringBuilder builder);
}
[ObsoleteAttribute("Replaced by ScopeContext.PushNestedState or Logger.PushScopeNested using ${scopenested}. Marked obsolete on NLog 5.0")]
public static class NLog.NestedDiagnosticsContext : object {
    [ObsoleteAttribute("Replaced by ScopeContext.PeekNestedState. Marked obsolete on NLog 5.0")]
public static string TopMessage { get; }
    [ObsoleteAttribute("Replaced by ScopeContext.PeekNestedState. Marked obsolete on NLog 5.0")]
public static object TopObject { get; }
    public static string get_TopMessage();
    public static object get_TopObject();
    [ObsoleteAttribute("Replaced by ScopeContext.PushNestedState or Logger.PushScopeNested using ${scopenested}. Marked obsolete on NLog 5.0")]
public static IDisposable Push(string text);
    [ObsoleteAttribute("Replaced by ScopeContext.PushNestedState or Logger.PushScopeNested using ${scopenested}. Marked obsolete on NLog 5.0")]
public static IDisposable Push(object value);
    [ObsoleteAttribute("Replaced by dispose of return value from ScopeContext.PushNestedState or Logger.PushScopeNested. Marked obsolete on NLog 5.0")]
public static string Pop();
    [ObsoleteAttribute("Replaced by dispose of return value from ScopeContext.PushNestedState or Logger.PushScopeNested. Marked obsolete on NLog 5.0")]
public static string Pop(IFormatProvider formatProvider);
    [ObsoleteAttribute("Replaced by dispose of return value from ScopeContext.PushNestedState or Logger.PushScopeNested. Marked obsolete on NLog 5.0")]
public static object PopObject();
    [ObsoleteAttribute("Replaced by ScopeContext.PeekNestedState. Marked obsolete on NLog 5.0")]
public static object PeekObject();
    [ObsoleteAttribute("Replaced by ScopeContext.Clear. Marked obsolete on NLog 5.0")]
public static void Clear();
    [ObsoleteAttribute("Replaced by ScopeContext.GetAllNestedStates. Marked obsolete on NLog 5.0")]
public static String[] GetAllMessages();
    [ObsoleteAttribute("Replaced by ScopeContext.GetAllNestedStates. Marked obsolete on NLog 5.0")]
public static String[] GetAllMessages(IFormatProvider formatProvider);
    [ObsoleteAttribute("Replaced by ScopeContext.GetAllNestedStates. Marked obsolete on NLog 5.0")]
public static Object[] GetAllObjects();
}
[ObsoleteAttribute("Replaced by ScopeContext.PushNestedState or Logger.PushScopeNested using ${scopenested}. Marked obsolete on NLog 5.0")]
public static class NLog.NestedDiagnosticsLogicalContext : object {
    [ObsoleteAttribute("Replaced by ScopeContext.PushNestedState or Logger.PushScopeNested using ${scopenested}. Marked obsolete on NLog 5.0")]
public static IDisposable Push(T value);
    [ObsoleteAttribute("Replaced by ScopeContext.PushNestedState or Logger.PushScopeNested using ${scopenested}. Marked obsolete on NLog 5.0")]
public static IDisposable PushObject(object value);
    [ObsoleteAttribute("Replaced by dispose of return value from ScopeContext.PushNestedState or Logger.PushScopeNested. Marked obsolete on NLog 5.0")]
public static object Pop();
    [ObsoleteAttribute("Replaced by dispose of return value from ScopeContext.PushNestedState or Logger.PushScopeNested. Marked obsolete on NLog 5.0")]
public static string Pop(IFormatProvider formatProvider);
    [ObsoleteAttribute("Replaced by dispose of return value from ScopeContext.PushNestedState or Logger.PushScopeNested. Marked obsolete on NLog 5.0")]
public static object PopObject();
    [ObsoleteAttribute("Replaced by ScopeContext.PeekNestedState. Marked obsolete on NLog 5.0")]
public static object PeekObject();
    [ObsoleteAttribute("Replaced by ScopeContext.Clear. Marked obsolete on NLog 5.0")]
public static void Clear();
    [ObsoleteAttribute("Replaced by ScopeContext.GetAllNestedStates. Marked obsolete on NLog 5.0")]
public static String[] GetAllMessages();
    [ObsoleteAttribute("Replaced by ScopeContext.GetAllNestedStates. Marked obsolete on NLog 5.0")]
public static String[] GetAllMessages(IFormatProvider formatProvider);
    [ObsoleteAttribute("Replaced by ScopeContext.GetAllNestedStates. Marked obsolete on NLog 5.0")]
public static Object[] GetAllObjects();
}
public class NLog.NLogConfigurationException : Exception {
    public NLogConfigurationException(string message);
    [ObsoleteAttribute("Instead use string interpolation. Marked obsolete with NLog 5.0")]
[StringFormatMethodAttribute("message")]
[EditorBrowsableAttribute("1")]
public NLogConfigurationException(string message, Object[] messageParameters);
    [ObsoleteAttribute("Instead use string interpolation. Marked obsolete with NLog 5.0")]
[StringFormatMethodAttribute("message")]
[EditorBrowsableAttribute("1")]
public NLogConfigurationException(Exception innerException, string message, Object[] messageParameters);
    public NLogConfigurationException(string message, Exception innerException);
    protected NLogConfigurationException(SerializationInfo info, StreamingContext context);
}
public class NLog.NLogRuntimeException : Exception {
    public NLogRuntimeException(string message);
    [ObsoleteAttribute("Instead use string interpolation. Marked obsolete with NLog 5.0")]
[StringFormatMethodAttribute("message")]
[EditorBrowsableAttribute("1")]
public NLogRuntimeException(string message, Object[] messageParameters);
    public NLogRuntimeException(string message, Exception innerException);
    protected NLogRuntimeException(SerializationInfo info, StreamingContext context);
}
public class NLog.NLogTraceListener : TraceListener {
    private LogFactory _logFactory;
    private LogLevel _defaultLogLevel;
    private bool _attributesLoaded;
    private bool _autoLoggerName;
    private LogLevel _forceLogLevel;
    private bool _disableFlush;
    private static Dictionary`2<TraceEventType, object> TraceEventTypeBoxing;
    private static Object[] EventIdBoxing;
    public LogFactory LogFactory { get; public set; }
    public LogLevel DefaultLogLevel { get; public set; }
    public LogLevel ForceLogLevel { get; public set; }
    public bool DisableFlush { get; public set; }
    public bool IsThreadSafe { get; }
    public bool AutoLoggerName { get; public set; }
    private static NLogTraceListener();
    public LogFactory get_LogFactory();
    public void set_LogFactory(LogFactory value);
    public LogLevel get_DefaultLogLevel();
    public void set_DefaultLogLevel(LogLevel value);
    public LogLevel get_ForceLogLevel();
    public void set_ForceLogLevel(LogLevel value);
    public bool get_DisableFlush();
    public void set_DisableFlush(bool value);
    public virtual bool get_IsThreadSafe();
    public bool get_AutoLoggerName();
    public void set_AutoLoggerName(bool value);
    public virtual void Write(string message);
    public virtual void Write(object o);
    public virtual void WriteLine(string message);
    public virtual void WriteLine(object o);
    private void WriteInternal(string message);
    private void WriteInternal(object o);
    public virtual void Close();
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    public virtual void Flush();
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    protected virtual String[] GetSupportedAttributes();
    private static LogLevel TranslateLogLevel(TraceEventType eventType);
    protected virtual void ProcessLogEventInfo(LogLevel logLevel, string loggerName, string message, Object[] arguments, Nullable`1<int> eventId, Nullable`1<TraceEventType> eventType, Nullable`1<Guid> relatedActivityId);
    private static object ResolveBoxedTraceEventType(TraceEventType traceEventType);
    private static object ResolvedBoxedEventId(int eventId);
    private Logger GetLogger(string loggerName, StackTrace stackTrace, Int32& userFrameIndex);
    private void InitAttributes();
}
public class NLog.NullLogger : Logger {
    public NullLogger(LogFactory factory);
}
public static class NLog.ScopeContext : object {
    internal static IEqualityComparer`1<string> DefaultComparer;
    private static string MappedContextDataSlotName;
    private static string NestedContextDataSlotName;
    private static ScopeContext();
    public static IDisposable PushNestedStateProperties(object nestedState, IReadOnlyCollection`1<KeyValuePair`2<string, object>> properties);
    public static IDisposable PushProperties(IReadOnlyCollection`1<KeyValuePair`2<string, object>> properties);
    public static IDisposable PushProperties(IReadOnlyCollection`1<KeyValuePair`2<string, TValue>> properties);
    public static IDisposable PushProperty(string key, TValue value);
    public static IDisposable PushProperty(string key, object value);
    public static IDisposable PushNestedState(T nestedState);
    public static IDisposable PushNestedState(object nestedState);
    public static void Clear();
    public static IEnumerable`1<KeyValuePair`2<string, object>> GetAllProperties();
    internal static ScopeContextPropertyEnumerator`1<object> GetAllPropertiesEnumerator();
    public static bool TryGetProperty(string key, Object& value);
    public static Object[] GetAllNestedStates();
    internal static IList`1<object> GetAllNestedStateList();
    public static object PeekNestedState();
    internal static Nullable`1<TimeSpan> PeekInnerNestedDuration();
    internal static Nullable`1<TimeSpan> PeekOuterNestedDuration();
    [ObsoleteAttribute("Replaced by ScopeContext.PushProperty. Marked obsolete on NLog 5.0")]
internal static void SetMappedContextLegacy(string key, TValue value);
    internal static ICollection`1<string> GetKeysMappedContextLegacy();
    [ObsoleteAttribute("Replaced by disposing return value from ScopeContext.PushProperty. Marked obsolete on NLog 5.0")]
internal static void RemoveMappedContextLegacy(string key);
    [ObsoleteAttribute("Replaced by disposing return value from ScopeContext.PushNestedState. Marked obsolete on NLog 5.0")]
internal static object PopNestedContextLegacy();
    [ObsoleteAttribute("Replaced by ScopeContext.Clear. Marked obsolete on NLog 5.0")]
internal static void ClearMappedContextLegacy();
    [ObsoleteAttribute("Replaced by ScopeContext.Clear. Marked obsolete on NLog 5.0")]
internal static void ClearNestedContextLegacy();
    private static Dictionary`2<string, object> PushPropertiesCallContext(IReadOnlyCollection`1<KeyValuePair`2<string, TValue>> properties);
    private static Dictionary`2<string, object> PushPropertyCallContext(string propertyName, TValue propertyValue);
    private static void ClearMappedContextCallContext();
    [IteratorStateMachineAttribute("NLog.ScopeContext/<GetAllPropertiesUnwrapped>d__27")]
private static IEnumerable`1<KeyValuePair`2<string, object>> GetAllPropertiesUnwrapped(Dictionary`2<string, object> properties);
    private static Dictionary`2<string, object> CloneMappedContext(Dictionary`2<string, object> oldContext, int initialCapacity);
    private static void SetPropertyCallContext(string item, TValue value, IDictionary`2<string, object> mappedContext);
    private static void SetMappedContextCallContext(Dictionary`2<string, object> newValue);
    internal static Dictionary`2<string, object> GetMappedContextCallContext();
    private static LinkedList`1<object> PushNestedStateCallContext(object objectValue);
    private static void ClearNestedContextCallContext();
    [SecuritySafeCriticalAttribute]
private static void SetNestedContextCallContext(LinkedList`1<object> nestedContext);
    [SecuritySafeCriticalAttribute]
private static LinkedList`1<object> GetNestedContextCallContext();
}
[ExtensionAttribute]
public static class NLog.SetupBuilderExtensions : object {
    [ExtensionAttribute]
public static Logger GetCurrentClassLogger(ISetupBuilder setupBuilder);
    [ExtensionAttribute]
public static Logger GetLogger(ISetupBuilder setupBuilder, string name);
    [ExtensionAttribute]
public static ISetupBuilder SetupLogFactory(ISetupBuilder setupBuilder, Action`1<ISetupLogFactoryBuilder> logfactoryBuilder);
    [ExtensionAttribute]
public static ISetupBuilder SetupExtensions(ISetupBuilder setupBuilder, Action`1<ISetupExtensionsBuilder> extensionsBuilder);
    [ExtensionAttribute]
public static ISetupBuilder SetupInternalLogger(ISetupBuilder setupBuilder, Action`1<ISetupInternalLoggerBuilder> internalLoggerBuilder);
    [ExtensionAttribute]
public static ISetupBuilder SetupSerialization(ISetupBuilder setupBuilder, Action`1<ISetupSerializationBuilder> serializationBuilder);
    [ExtensionAttribute]
public static ISetupBuilder LoadConfiguration(ISetupBuilder setupBuilder, Action`1<ISetupLoadConfigurationBuilder> configBuilder);
    [ExtensionAttribute]
public static ISetupBuilder LoadConfiguration(ISetupBuilder setupBuilder, LoggingConfiguration loggingConfiguration);
    [ExtensionAttribute]
public static ISetupBuilder LoadConfigurationFromFile(ISetupBuilder setupBuilder, string configFile, bool optional);
    [ExtensionAttribute]
public static ISetupBuilder LoadConfigurationFromFile(ISetupBuilder setupBuilder, IEnumerable`1<string> candidateFilePaths, bool optional);
    [ExtensionAttribute]
public static ISetupBuilder LoadConfigurationFromXml(ISetupBuilder setupBuilder, string configXml);
    [ExtensionAttribute]
public static ISetupBuilder LoadConfigurationFromAssemblyResource(ISetupBuilder setupBuilder, Assembly applicationAssembly, string resourceName);
    [ExtensionAttribute]
public static ISetupBuilder ReloadConfiguration(ISetupBuilder setupBuilder);
}
[ExtensionAttribute]
public static class NLog.SetupExtensionsBuilderExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("AutoLoadAssemblies(true) has been replaced by AutoLoadExtensions(), that matches the name of nlog-attribute in NLog.config. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static ISetupExtensionsBuilder AutoLoadAssemblies(ISetupExtensionsBuilder setupBuilder, bool enable);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder AutoLoadExtensions(ISetupExtensionsBuilder setupBuilder);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterAssembly(ISetupExtensionsBuilder setupBuilder, Assembly assembly);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterAssembly(ISetupExtensionsBuilder setupBuilder, string assemblyName);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterType(ISetupExtensionsBuilder setupBuilder);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterTarget(ISetupExtensionsBuilder setupBuilder, string name);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterTarget(ISetupExtensionsBuilder setupBuilder, Func`1<T> factory, string typeAlias);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterTarget(ISetupExtensionsBuilder setupBuilder, string name, Type targetType);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayout(ISetupExtensionsBuilder setupBuilder, string typeAlias);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayout(ISetupExtensionsBuilder setupBuilder, Func`1<T> factory, string typeAlias);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayout(ISetupExtensionsBuilder setupBuilder, string typeAlias, Type layoutType);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayoutRenderer(ISetupExtensionsBuilder setupBuilder, string name);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayoutRenderer(ISetupExtensionsBuilder setupBuilder, Func`1<T> factory, string typeAlias);
    private static string ResolveTypeAlias(String[] trimEndings);
    private static string ResolveTypeAlias(String[] trimEndings);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayoutRenderer(ISetupExtensionsBuilder setupBuilder, string name, Type layoutRendererType);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayoutRenderer(ISetupExtensionsBuilder setupBuilder, string name, Func`2<LogEventInfo, object> layoutMethod);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayoutRenderer(ISetupExtensionsBuilder setupBuilder, string name, Func`3<LogEventInfo, LoggingConfiguration, object> layoutMethod);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayoutRenderer(ISetupExtensionsBuilder setupBuilder, string name, Func`2<LogEventInfo, object> layoutMethod, LayoutRenderOptions options);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayoutRenderer(ISetupExtensionsBuilder setupBuilder, string name, Func`3<LogEventInfo, LoggingConfiguration, object> layoutMethod, LayoutRenderOptions options);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterLayoutRenderer(ISetupExtensionsBuilder setupBuilder, FuncLayoutRenderer layoutRenderer);
    [ExtensionAttribute]
[ObsoleteAttribute("Instead use RegisterConditionMethod with delegate, as type reflection will be moved out. Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static ISetupExtensionsBuilder RegisterConditionMethod(ISetupExtensionsBuilder setupBuilder, string name, MethodInfo conditionMethod);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterConditionMethod(ISetupExtensionsBuilder setupBuilder, string name, Func`2<LogEventInfo, object> conditionMethod);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterConditionMethod(ISetupExtensionsBuilder setupBuilder, string name, Func`1<object> conditionMethod);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterSingletonService(ISetupExtensionsBuilder setupBuilder, T singletonService);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterSingletonService(ISetupExtensionsBuilder setupBuilder, Type interfaceType, object singletonService);
    [ExtensionAttribute]
public static ISetupExtensionsBuilder RegisterServiceProvider(ISetupExtensionsBuilder setupBuilder, IServiceProvider serviceProvider);
}
[ExtensionAttribute]
public static class NLog.SetupInternalLoggerBuilderExtensions : object {
    [ExtensionAttribute]
public static ISetupInternalLoggerBuilder SetMinimumLogLevel(ISetupInternalLoggerBuilder setupBuilder, LogLevel logLevel);
    [ExtensionAttribute]
public static ISetupInternalLoggerBuilder LogToFile(ISetupInternalLoggerBuilder setupBuilder, string fileName);
    [ExtensionAttribute]
public static ISetupInternalLoggerBuilder LogToConsole(ISetupInternalLoggerBuilder setupBuilder, bool enabled);
    [ExtensionAttribute]
public static ISetupInternalLoggerBuilder LogToTrace(ISetupInternalLoggerBuilder setupBuilder, bool enabled);
    [ExtensionAttribute]
public static ISetupInternalLoggerBuilder LogToWriter(ISetupInternalLoggerBuilder setupBuilder, TextWriter writer);
    [ExtensionAttribute]
[ObsoleteAttribute("Instead use AddEventSubscription. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public static ISetupInternalLoggerBuilder AddLogSubscription(ISetupInternalLoggerBuilder setupBuilder, EventHandler`1<InternalLoggerMessageEventArgs> eventSubscriber);
    [ExtensionAttribute]
[ObsoleteAttribute("Instead use RemoveEventSubscription. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public static ISetupInternalLoggerBuilder RemoveLogSubscription(ISetupInternalLoggerBuilder setupBuilder, EventHandler`1<InternalLoggerMessageEventArgs> eventSubscriber);
    [ExtensionAttribute]
public static ISetupInternalLoggerBuilder AddEventSubscription(ISetupInternalLoggerBuilder setupBuilder, InternalEventOccurredHandler eventSubscriber);
    [ExtensionAttribute]
public static ISetupInternalLoggerBuilder RemoveEventSubscription(ISetupInternalLoggerBuilder setupBuilder, InternalEventOccurredHandler eventSubscriber);
    [ExtensionAttribute]
public static ISetupInternalLoggerBuilder SetupFromEnvironmentVariables(ISetupInternalLoggerBuilder setupBuilder);
}
[ExtensionAttribute]
public static class NLog.SetupLoadConfigurationExtensions : object {
    [ExtensionAttribute]
public static ISetupLoadConfigurationBuilder SetTimeSource(ISetupLoadConfigurationBuilder configBuilder, TimeSource timeSource);
    [ExtensionAttribute]
public static ISetupLoadConfigurationBuilder SetGlobalContextProperty(ISetupLoadConfigurationBuilder configBuilder, string name, string value);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder ForLogger(ISetupLoadConfigurationBuilder configBuilder, string loggerNamePattern, string ruleName);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder ForLogger(ISetupLoadConfigurationBuilder configBuilder, LogLevel finalMinLevel, string loggerNamePattern, string ruleName);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder ForTarget(ISetupLoadConfigurationBuilder configBuilder, string targetName);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder FilterMinLevel(ISetupConfigurationLoggingRuleBuilder configBuilder, LogLevel minLevel);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder FilterMaxLevel(ISetupConfigurationLoggingRuleBuilder configBuilder, LogLevel maxLevel);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder FilterLevel(ISetupConfigurationLoggingRuleBuilder configBuilder, LogLevel logLevel);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder FilterLevels(ISetupConfigurationLoggingRuleBuilder configBuilder, LogLevel minLevel, LogLevel maxLevel);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder FilterDynamic(ISetupConfigurationLoggingRuleBuilder configBuilder, Filter filter, Nullable`1<FilterResult> filterDefaultAction);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder FilterDynamic(ISetupConfigurationLoggingRuleBuilder configBuilder, Func`2<LogEventInfo, FilterResult> filterMethod, Nullable`1<FilterResult> filterDefaultAction);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder FilterDynamicIgnore(ISetupConfigurationLoggingRuleBuilder configBuilder, Func`2<LogEventInfo, bool> filterMethod, bool final);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder FilterDynamicLog(ISetupConfigurationLoggingRuleBuilder configBuilder, Func`2<LogEventInfo, bool> filterMethod, bool final);
    [ExtensionAttribute]
public static ISetupConfigurationLoggingRuleBuilder TopRule(ISetupConfigurationLoggingRuleBuilder configBuilder, bool insertFirst);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteTo(ISetupConfigurationTargetBuilder configBuilder, Target target);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteTo(ISetupConfigurationTargetBuilder configBuilder, Target[] targets);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteTo(ISetupConfigurationTargetBuilder configBuilder, ISetupConfigurationTargetBuilder targetBuilder);
    [ExtensionAttribute]
public static void WriteToNil(ISetupConfigurationLoggingRuleBuilder configBuilder, LogLevel finalMinLevel);
    [ExtensionAttribute]
public static Target FirstTarget(ISetupConfigurationTargetBuilder configBuilder);
    [ExtensionAttribute]
public static T FirstTarget(ISetupConfigurationTargetBuilder configBuilder);
    [IteratorStateMachineAttribute("NLog.SetupLoadConfigurationExtensions/<YieldAllTargets>d__20")]
internal static IEnumerable`1<Target> YieldAllTargets(Target target);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteToMethodCall(ISetupConfigurationTargetBuilder configBuilder, Action`2<LogEventInfo, Object[]> logEventAction, Layout[] layouts);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteToConsole(ISetupConfigurationTargetBuilder configBuilder, Layout layout, Encoding encoding, bool stderr, bool detectConsoleAvailable, bool writeBuffered);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteToColoredConsole(ISetupConfigurationTargetBuilder configBuilder, Layout layout, bool highlightWordLevel, Encoding encoding, bool stderr, bool detectConsoleAvailable, bool enableAnsiOutput);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteToTrace(ISetupConfigurationTargetBuilder configBuilder, Layout layout, bool rawWrite);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteToDebug(ISetupConfigurationTargetBuilder configBuilder, Layout layout);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void WriteToDebugConditional(ISetupConfigurationTargetBuilder configBuilder, Layout layout);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WriteToFile(ISetupConfigurationTargetBuilder configBuilder, Layout fileName, Layout layout, Encoding encoding, LineEndingMode lineEnding, bool keepFileOpen, bool concurrentWrites, long archiveAboveSize, int maxArchiveFiles, int maxArchiveDays);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WithWrapper(ISetupConfigurationTargetBuilder configBuilder, Func`2<Target, Target> wrapperFactory);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WithAsync(ISetupConfigurationTargetBuilder configBuilder, AsyncTargetWrapperOverflowAction overflowAction, int queueLimit, int batchSize);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WithBuffering(ISetupConfigurationTargetBuilder configBuilder, Nullable`1<int> bufferSize, Nullable`1<TimeSpan> flushTimeout, Nullable`1<bool> slidingTimeout, Nullable`1<BufferingTargetWrapperOverflowAction> overflowAction);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WithAutoFlush(ISetupConfigurationTargetBuilder configBuilder, Func`2<LogEventInfo, bool> conditionMethod, Nullable`1<bool> flushOnConditionOnly);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WithRetry(ISetupConfigurationTargetBuilder configBuilder, Nullable`1<int> retryCount, Nullable`1<TimeSpan> retryDelay);
    [ExtensionAttribute]
public static ISetupConfigurationTargetBuilder WithFallback(ISetupConfigurationTargetBuilder configBuilder, Target fallbackTarget, bool returnToFirstOnSuccess);
    private static string EnsureUniqueTargetName(LoggingConfiguration configuration, Target target, string suffix);
    private static bool IsTargetNameUnique(IList`1<Target> allTargets, Target target, string targetName);
    private static string GenerateTargetName(Type targetType);
}
[ExtensionAttribute]
public static class NLog.SetupLogFactoryBuilderExtensions : object {
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder SetTimeSource(ISetupLogFactoryBuilder configBuilder, TimeSource timeSource);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder SetTimeSourcAccurateUtc(ISetupLogFactoryBuilder configBuilder);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder SetTimeSourcAccurateLocal(ISetupLogFactoryBuilder configBuilder);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder SetGlobalContextProperty(ISetupLogFactoryBuilder configBuilder, string name, object value);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder SetAutoShutdown(ISetupLogFactoryBuilder configBuilder, bool enabled);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder SetDefaultCultureInfo(ISetupLogFactoryBuilder configBuilder, CultureInfo cultureInfo);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder SetGlobalThreshold(ISetupLogFactoryBuilder configBuilder, LogLevel logLevel);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder SetThrowConfigExceptions(ISetupLogFactoryBuilder configBuilder, bool enabled);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder AddCallSiteHiddenAssembly(ISetupLogFactoryBuilder configBuilder, Assembly assembly);
    [ExtensionAttribute]
public static ISetupLogFactoryBuilder AddCallSiteHiddenClassType(ISetupLogFactoryBuilder configBuilder, Type type);
}
[ExtensionAttribute]
public static class NLog.SetupSerializationBuilderExtensions : object {
    [ExtensionAttribute]
public static ISetupSerializationBuilder ParseMessageTemplates(ISetupSerializationBuilder setupBuilder, Nullable`1<bool> enable);
    [ExtensionAttribute]
public static ISetupSerializationBuilder RegisterJsonConverter(ISetupSerializationBuilder setupBuilder, IJsonConverter jsonConverter);
    [ExtensionAttribute]
public static ISetupSerializationBuilder RegisterValueFormatter(ISetupSerializationBuilder setupBuilder, IValueFormatter valueFormatter);
    [ExtensionAttribute]
public static ISetupSerializationBuilder RegisterObjectTransformation(ISetupSerializationBuilder setupBuilder, Func`2<T, object> transformer);
    [ExtensionAttribute]
public static ISetupSerializationBuilder RegisterObjectTransformation(ISetupSerializationBuilder setupBuilder, Type objectType, Func`2<object, object> transformer);
}
public enum NLog.Targets.ArchiveNumberingMode : Enum {
    public int value__;
    public static ArchiveNumberingMode Sequence;
    public static ArchiveNumberingMode Rolling;
    public static ArchiveNumberingMode Date;
    public static ArchiveNumberingMode DateAndSequence;
}
public abstract class NLog.Targets.AsyncTaskTarget : TargetWithContext {
    private Timer _taskTimeoutTimer;
    private CancellationTokenSource _cancelTokenSource;
    private AsyncRequestQueueBase _requestQueue;
    private Action _taskCancelledTokenReInit;
    private Action`2<Task, object> _taskCompletion;
    private Task _previousTask;
    private Timer _lazyWriterTimer;
    private ReusableAsyncLogEventList _reusableAsyncLogEventList;
    private Tuple`2<List`1<LogEventInfo>, List`1<AsyncContinuation>> _reusableLogEvents;
    private Nullable`1<AsyncHelpersTask> _flushEventsInQueueDelegate;
    private bool _missingServiceTypes;
    [CompilerGeneratedAttribute]
private int <TaskDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TaskTimeoutSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryDelayMilliseconds>k__BackingField;
    private Nullable`1<bool> _forceLockingQueue;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    public int TaskDelayMilliseconds { get; public set; }
    public int TaskTimeoutSeconds { get; public set; }
    public int RetryCount { get; public set; }
    public int RetryDelayMilliseconds { get; public set; }
    public bool ForceLockingQueue { get; public set; }
    public AsyncTargetWrapperOverflowAction OverflowAction { get; public set; }
    public int QueueLimit { get; public set; }
    public int BatchSize { get; public set; }
    protected TaskScheduler TaskScheduler { get; }
    [CompilerGeneratedAttribute]
public int get_TaskDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_TaskDelayMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_TaskTimeoutSeconds();
    [CompilerGeneratedAttribute]
public void set_TaskTimeoutSeconds(int value);
    [CompilerGeneratedAttribute]
public int get_RetryCount();
    [CompilerGeneratedAttribute]
public void set_RetryCount(int value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(int value);
    public bool get_ForceLockingQueue();
    public void set_ForceLockingQueue(bool value);
    public AsyncTargetWrapperOverflowAction get_OverflowAction();
    public void set_OverflowAction(AsyncTargetWrapperOverflowAction value);
    public int get_QueueLimit();
    public void set_QueueLimit(int value);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    protected virtual TaskScheduler get_TaskScheduler();
    protected virtual void InitializeTarget();
    protected abstract virtual Task WriteAsyncTask(LogEventInfo logEvent, CancellationToken cancellationToken);
    protected virtual Task WriteAsyncTask(IList`1<LogEventInfo> logEvents, CancellationToken cancellationToken);
    protected virtual bool RetryFailedAsyncTask(Exception exception, CancellationToken cancellationToken, int retryCountRemaining, TimeSpan& retryDelay);
    protected sealed virtual void Write(LogEventInfo logEvent);
    protected sealed virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    protected sealed virtual void Write(AsyncLogEventInfo logEvent);
    protected sealed virtual void WriteAsyncThreadSafe(AsyncLogEventInfo logEvent);
    protected sealed virtual void WriteAsyncThreadSafe(IList`1<AsyncLogEventInfo> logEvents);
    protected virtual void WriteFailedNotInitialized(AsyncLogEventInfo logEvent, Exception initializeException);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void CloseTarget();
    protected virtual void Dispose(bool disposing);
    private void TaskStartNext(object previousTask, bool fullBatchCompleted);
    private bool CheckOtherTask(object previousTask);
    internal Task WriteAsyncTaskWithRetry(Task firstTask, IList`1<LogEventInfo> logEvents, CancellationToken cancellationToken, int retryCount);
    private bool TaskCreation(IList`1<AsyncLogEventInfo> logEvents);
    private Task StartWriteAsyncTask(IList`1<LogEventInfo> logEvents, CancellationToken cancellationToken);
    private static void NotifyTaskCompletion(IList`1<AsyncContinuation> reusableContinuations, Exception ex);
    private void TaskCompletion(Task completedTask, object continuation);
    private void TaskTimeout(object state);
    private static bool WaitTaskIsCompleted(Task task, TimeSpan timeout);
    private static Exception ExtractActualException(AggregateException taskException);
    private void TaskCancelledTokenReInit();
    [CompilerGeneratedAttribute]
private void <.ctor>b__43_0(object s);
    [CompilerGeneratedAttribute]
private void <FlushAsync>b__54_0(object cont);
}
[TargetAttribute("Chainsaw")]
public class NLog.Targets.ChainsawTarget : NLogViewerTarget {
    public ChainsawTarget(string name);
}
internal class NLog.Targets.ColoredConsoleAnsiPrinter : object {
    [CompilerGeneratedAttribute]
private IList`1<ConsoleRowHighlightingRule> <DefaultConsoleRowHighlightingRules>k__BackingField;
    private static string TerminalDefaultForegroundColorEscapeCode { get; }
    private static string TerminalDefaultBackgroundColorEscapeCode { get; }
    private static string TerminalDefaultColorEscapeCode { get; }
    public IList`1<ConsoleRowHighlightingRule> DefaultConsoleRowHighlightingRules { get; }
    public sealed virtual TextWriter AcquireTextWriter(TextWriter consoleStream, StringBuilder reusableBuilder);
    public sealed virtual void ReleaseTextWriter(TextWriter consoleWriter, TextWriter consoleStream, Nullable`1<ConsoleColor> oldForegroundColor, Nullable`1<ConsoleColor> oldBackgroundColor, bool flush);
    public sealed virtual Nullable`1<ConsoleColor> ChangeForegroundColor(TextWriter consoleWriter, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> oldForegroundColor);
    public sealed virtual Nullable`1<ConsoleColor> ChangeBackgroundColor(TextWriter consoleWriter, Nullable`1<ConsoleColor> backgroundColor, Nullable`1<ConsoleColor> oldBackgroundColor);
    public sealed virtual void ResetDefaultColors(TextWriter consoleWriter, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> backgroundColor);
    public sealed virtual void WriteSubString(TextWriter consoleWriter, string text, int index, int endIndex);
    public sealed virtual void WriteChar(TextWriter consoleWriter, char text);
    public sealed virtual void WriteLine(TextWriter consoleWriter, string text);
    private static string GetForegroundColorEscapeCode(ConsoleColor color);
    private static string get_TerminalDefaultForegroundColorEscapeCode();
    private static string GetBackgroundColorEscapeCode(ConsoleColor color);
    private static string get_TerminalDefaultBackgroundColorEscapeCode();
    private static string get_TerminalDefaultColorEscapeCode();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConsoleRowHighlightingRule> get_DefaultConsoleRowHighlightingRules();
}
internal class NLog.Targets.ColoredConsoleSystemPrinter : object {
    [CompilerGeneratedAttribute]
private IList`1<ConsoleRowHighlightingRule> <DefaultConsoleRowHighlightingRules>k__BackingField;
    public IList`1<ConsoleRowHighlightingRule> DefaultConsoleRowHighlightingRules { get; }
    public sealed virtual TextWriter AcquireTextWriter(TextWriter consoleStream, StringBuilder reusableBuilder);
    public sealed virtual void ReleaseTextWriter(TextWriter consoleWriter, TextWriter consoleStream, Nullable`1<ConsoleColor> oldForegroundColor, Nullable`1<ConsoleColor> oldBackgroundColor, bool flush);
    public sealed virtual Nullable`1<ConsoleColor> ChangeForegroundColor(TextWriter consoleWriter, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> oldForegroundColor);
    public sealed virtual Nullable`1<ConsoleColor> ChangeBackgroundColor(TextWriter consoleWriter, Nullable`1<ConsoleColor> backgroundColor, Nullable`1<ConsoleColor> oldBackgroundColor);
    public sealed virtual void ResetDefaultColors(TextWriter consoleWriter, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> backgroundColor);
    public sealed virtual void WriteSubString(TextWriter consoleWriter, string text, int index, int endIndex);
    public sealed virtual void WriteChar(TextWriter consoleWriter, char text);
    public sealed virtual void WriteLine(TextWriter consoleWriter, string text);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConsoleRowHighlightingRule> get_DefaultConsoleRowHighlightingRules();
}
[TargetAttribute("ColoredConsole")]
public class NLog.Targets.ColoredConsoleTarget : TargetWithLayoutHeaderAndFooter {
    private bool _pauseLogging;
    private bool _disableColors;
    private IColoredConsolePrinter _consolePrinter;
    [CompilerGeneratedAttribute]
private bool <StdErr>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDefaultRowHighlightingRules>k__BackingField;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private bool <DetectConsoleAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetectOutputRedirected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoFlush>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableAnsiOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConsoleRowHighlightingRule> <RowHighlightingRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConsoleWordHighlightingRule> <WordHighlightingRules>k__BackingField;
    [ObsoleteAttribute("Replaced by StdErr to align with ConsoleTarget. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool ErrorStream { get; public set; }
    public bool StdErr { get; public set; }
    public bool UseDefaultRowHighlightingRules { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool DetectConsoleAvailable { get; public set; }
    public bool DetectOutputRedirected { get; public set; }
    public bool AutoFlush { get; public set; }
    public bool EnableAnsiOutput { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.ConsoleRowHighlightingRule", "highlight-row")]
public IList`1<ConsoleRowHighlightingRule> RowHighlightingRules { get; }
    [ArrayParameterAttribute("NLog.Targets.ConsoleWordHighlightingRule", "highlight-word")]
public IList`1<ConsoleWordHighlightingRule> WordHighlightingRules { get; }
    public ColoredConsoleTarget(string name);
    public bool get_ErrorStream();
    public void set_ErrorStream(bool value);
    [CompilerGeneratedAttribute]
public bool get_StdErr();
    [CompilerGeneratedAttribute]
public void set_StdErr(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseDefaultRowHighlightingRules();
    [CompilerGeneratedAttribute]
public void set_UseDefaultRowHighlightingRules(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public bool get_DetectConsoleAvailable();
    [CompilerGeneratedAttribute]
public void set_DetectConsoleAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_DetectOutputRedirected();
    [CompilerGeneratedAttribute]
public void set_DetectOutputRedirected(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoFlush();
    [CompilerGeneratedAttribute]
public void set_AutoFlush(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableAnsiOutput();
    [CompilerGeneratedAttribute]
public void set_EnableAnsiOutput(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ConsoleRowHighlightingRule> get_RowHighlightingRules();
    [CompilerGeneratedAttribute]
public IList`1<ConsoleWordHighlightingRule> get_WordHighlightingRules();
    protected virtual void InitializeTarget();
    private static IColoredConsolePrinter CreateConsolePrinter(bool enableAnsiOutput);
    protected virtual void CloseTarget();
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    private void ExplicitConsoleFlush();
    protected virtual void Write(LogEventInfo logEvent);
    private void WriteToOutput(LogEventInfo logEvent, string message);
    private void WriteToOutputWithColor(LogEventInfo logEvent, string message);
    private void WriteToOutputWithPrinter(TextWriter consoleStream, string colorMessage, Nullable`1<ConsoleColor> newForegroundColor, Nullable`1<ConsoleColor> newBackgroundColor, bool wordHighlighting);
    private ConsoleRowHighlightingRule GetMatchingRowHighlightingRule(LogEventInfo logEvent);
    private static ConsoleRowHighlightingRule GetMatchingRowHighlightingRule(IList`1<ConsoleRowHighlightingRule> rules, LogEventInfo logEvent);
    private string GenerateColorEscapeSequences(LogEventInfo logEvent, string message);
    private static string EscapeColorCodes(string message);
    private static void ColorizeEscapeSequences(IColoredConsolePrinter consolePrinter, TextWriter consoleWriter, string message, Nullable`1<ConsoleColor> defaultForegroundColor, Nullable`1<ConsoleColor> defaultBackgroundColor, Nullable`1<ConsoleColor> rowForegroundColor, Nullable`1<ConsoleColor> rowBackgroundColor);
    private TextWriter GetOutput();
}
public enum NLog.Targets.ConsoleOutputColor : Enum {
    public int value__;
    public static ConsoleOutputColor Black;
    public static ConsoleOutputColor DarkBlue;
    public static ConsoleOutputColor DarkGreen;
    public static ConsoleOutputColor DarkCyan;
    public static ConsoleOutputColor DarkRed;
    public static ConsoleOutputColor DarkMagenta;
    public static ConsoleOutputColor DarkYellow;
    public static ConsoleOutputColor Gray;
    public static ConsoleOutputColor DarkGray;
    public static ConsoleOutputColor Blue;
    public static ConsoleOutputColor Green;
    public static ConsoleOutputColor Cyan;
    public static ConsoleOutputColor Red;
    public static ConsoleOutputColor Magenta;
    public static ConsoleOutputColor Yellow;
    public static ConsoleOutputColor White;
    public static ConsoleOutputColor NoChange;
}
[NLogConfigurationItemAttribute]
public class NLog.Targets.ConsoleRowHighlightingRule : object {
    [CompilerGeneratedAttribute]
private static ConsoleRowHighlightingRule <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleOutputColor <ForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleOutputColor <BackgroundColor>k__BackingField;
    public static ConsoleRowHighlightingRule Default { get; }
    [RequiredParameterAttribute]
public ConditionExpression Condition { get; public set; }
    public ConsoleOutputColor ForegroundColor { get; public set; }
    public ConsoleOutputColor BackgroundColor { get; public set; }
    public ConsoleRowHighlightingRule(ConditionExpression condition, ConsoleOutputColor foregroundColor, ConsoleOutputColor backgroundColor);
    private static ConsoleRowHighlightingRule();
    [CompilerGeneratedAttribute]
public static ConsoleRowHighlightingRule get_Default();
    [CompilerGeneratedAttribute]
public ConditionExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(ConditionExpression value);
    [CompilerGeneratedAttribute]
public ConsoleOutputColor get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(ConsoleOutputColor value);
    [CompilerGeneratedAttribute]
public ConsoleOutputColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(ConsoleOutputColor value);
    public bool CheckCondition(LogEventInfo logEvent);
}
[TargetAttribute("Console")]
public class NLog.Targets.ConsoleTarget : TargetWithLayoutHeaderAndFooter {
    private bool _pauseLogging;
    private ReusableBufferCreator _reusableEncodingBuffer;
    [CompilerGeneratedAttribute]
private bool <StdErr>k__BackingField;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private bool <DetectConsoleAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoFlush>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteBuffer>k__BackingField;
    [ObsoleteAttribute("Replaced by StdErr to align with ColoredConsoleTarget. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool Error { get; public set; }
    public bool StdErr { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool DetectConsoleAvailable { get; public set; }
    public bool AutoFlush { get; public set; }
    public bool WriteBuffer { get; public set; }
    public ConsoleTarget(string name);
    public bool get_Error();
    public void set_Error(bool value);
    [CompilerGeneratedAttribute]
public bool get_StdErr();
    [CompilerGeneratedAttribute]
public void set_StdErr(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public bool get_DetectConsoleAvailable();
    [CompilerGeneratedAttribute]
public void set_DetectConsoleAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoFlush();
    [CompilerGeneratedAttribute]
public void set_AutoFlush(bool value);
    [CompilerGeneratedAttribute]
public bool get_WriteBuffer();
    [CompilerGeneratedAttribute]
public void set_WriteBuffer(bool value);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    private void ExplicitConsoleFlush();
    protected virtual void Write(LogEventInfo logEvent);
    protected virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    private void RenderToOutput(Layout layout, LogEventInfo logEvent);
    private void WriteBufferToOutput(TextWriter output, Layout layout, LogEventInfo logEvent);
    private void WriteBufferToOutput(IList`1<AsyncLogEventInfo> logEvents);
    private void RenderLogEventToWriteBuffer(TextWriter output, Layout layout, LogEventInfo logEvent, StringBuilder targetBuilder, Char[] targetBuffer, Int32& targetBufferPosition);
    private void WriteLineToOutput(TextWriter output, string message);
    private void WriteBufferToOutput(TextWriter output, Char[] buffer, int length);
    private TextWriter GetOutput();
}
internal static class NLog.Targets.ConsoleTargetHelper : object {
    private static object _lockObject;
    private static ConsoleTargetHelper();
    public static bool IsConsoleAvailable(String& reason);
    public static Encoding GetConsoleOutputEncoding(Encoding currentEncoding, bool isInitialized, bool pauseLogging);
    public static bool SetConsoleOutputEncoding(Encoding newEncoding, bool isInitialized, bool pauseLogging);
    public static void WriteLineThreadSafe(TextWriter console, string message, bool flush);
    public static void WriteBufferThreadSafe(TextWriter console, Char[] buffer, int length, bool flush);
}
[NLogConfigurationItemAttribute]
public class NLog.Targets.ConsoleWordHighlightingRule : object {
    private RegexHelper _regexHelper;
    [CompilerGeneratedAttribute]
private ConditionExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleOutputColor <ForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleOutputColor <BackgroundColor>k__BackingField;
    public string Regex { get; public set; }
    public ConditionExpression Condition { get; public set; }
    public bool CompileRegex { get; public set; }
    public string Text { get; public set; }
    public bool WholeWords { get; public set; }
    public bool IgnoreCase { get; public set; }
    public ConsoleOutputColor ForegroundColor { get; public set; }
    public ConsoleOutputColor BackgroundColor { get; public set; }
    public Regex CompiledRegex { get; }
    public ConsoleWordHighlightingRule(string text, ConsoleOutputColor foregroundColor, ConsoleOutputColor backgroundColor);
    public string get_Regex();
    public void set_Regex(string value);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(ConditionExpression value);
    public bool get_CompileRegex();
    public void set_CompileRegex(bool value);
    public string get_Text();
    public void set_Text(string value);
    public bool get_WholeWords();
    public void set_WholeWords(bool value);
    public bool get_IgnoreCase();
    public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public ConsoleOutputColor get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(ConsoleOutputColor value);
    [CompilerGeneratedAttribute]
public ConsoleOutputColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(ConsoleOutputColor value);
    public Regex get_CompiledRegex();
    internal MatchCollection Matches(LogEventInfo logEvent, string message);
}
internal class NLog.Targets.DateAndSequenceArchive : object {
    private string _dateFormat;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sequence>k__BackingField;
    public string FileName { get; }
    public DateTime Date { get; }
    public int Sequence { get; }
    public bool HasValidSequence { get; }
    public DateAndSequenceArchive(string fileName, DateTime date, string dateFormat, int sequence);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public DateTime get_Date();
    [CompilerGeneratedAttribute]
public int get_Sequence();
    public bool get_HasValidSequence();
    public bool HasSameFormattedDate(DateTime date);
}
[TargetAttribute("Debugger")]
public class NLog.Targets.DebuggerTarget : TargetWithLayoutHeaderAndFooter {
    public DebuggerTarget(string name);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
}
[TargetAttribute("DebugSystem")]
public class NLog.Targets.DebugSystemTarget : TargetWithLayoutHeaderAndFooter {
    public DebugSystemTarget(string name);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
    private static void DebugWriteLine(string message);
}
[TargetAttribute("Debug")]
public class NLog.Targets.DebugTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private int <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastMessage>k__BackingField;
    public int Counter { get; private set; }
    public string LastMessage { get; private set; }
    public DebugTarget(string name);
    [CompilerGeneratedAttribute]
public int get_Counter();
    [CompilerGeneratedAttribute]
private void set_Counter(int value);
    [CompilerGeneratedAttribute]
public string get_LastMessage();
    [CompilerGeneratedAttribute]
private void set_LastMessage(string value);
    protected virtual void Write(LogEventInfo logEvent);
}
public class NLog.Targets.DefaultJsonSerializer : object {
    private ObjectReflectionCache _objectReflectionCache;
    private MruCache`2<Enum, string> _enumCache;
    private static int MaxJsonLength;
    private static IEqualityComparer`1<object> _referenceEqualsComparer;
    private static JsonSerializeOptions DefaultSerializerOptions;
    private static JsonSerializeOptions DefaultExceptionSerializerOptions;
    [CompilerGeneratedAttribute]
private static DefaultJsonSerializer <Instance>k__BackingField;
    [ObsoleteAttribute("Instead use ResolveService<IJsonConverter>() in Layout / Target. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static DefaultJsonSerializer Instance { get; }
    internal DefaultJsonSerializer(IServiceProvider serviceProvider);
    private static DefaultJsonSerializer();
    [CompilerGeneratedAttribute]
public static DefaultJsonSerializer get_Instance();
    public string SerializeObject(object value);
    public string SerializeObject(object value, JsonSerializeOptions options);
    public sealed virtual bool SerializeObject(object value, StringBuilder destination);
    public bool SerializeObject(object value, StringBuilder destination, JsonSerializeOptions options);
    private bool SerializeObject(object value, StringBuilder destination, JsonSerializeOptions options, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth);
    private bool SerializeObjectWithReflection(object value, StringBuilder destination, JsonSerializeOptions options, SingleItemOptimizedHashSet`1& objectsInPath, int depth);
    private bool SerializeSimpleObjectValue(object value, StringBuilder destination, JsonSerializeOptions options, bool forceToString);
    private static SingleItemScopedInsert<object> StartCollectionScope(SingleItemOptimizedHashSet`1& objectsInPath, object value);
    private void SerializeDictionaryObject(IDictionary dictionary, StringBuilder destination, JsonSerializeOptions options, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth);
    private static bool SanitizeDictionaryKey(StringBuilder destination, int keyStartIndex, int keyLength);
    private void SerializeCollectionObject(IEnumerable value, StringBuilder destination, JsonSerializeOptions options, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth);
    private bool SerializeObjectPropertyList(object value, ObjectPropertyList& objectPropertyList, StringBuilder destination, JsonSerializeOptions options, SingleItemOptimizedHashSet`1& objectsInPath, int depth);
    private void SerializeSimpleTypeCodeValue(IConvertible value, TypeCode objTypeCode, StringBuilder destination, JsonSerializeOptions options, bool forceToString);
    private void SerializeSimpleTypeCodeValueNoEscape(IConvertible value, TypeCode objTypeCode, StringBuilder destination, JsonSerializeOptions options, bool forceToString);
    private static void SerializeNumericValue(IConvertible value, TypeCode objTypeCode, StringBuilder destination, bool forceToString);
    private static string QuoteValue(string value);
    private static void QuoteValue(StringBuilder destination, string value);
    private string EnumAsString(Enum value);
    private static bool SkipQuotes(IConvertible value, TypeCode objTypeCode);
    private static bool IsNumericTypeCode(TypeCode objTypeCode, bool includeDecimals);
    private static void AppendStringEscape(StringBuilder destination, string text, JsonSerializeOptions options);
    internal static void AppendStringEscape(StringBuilder destination, string text, bool escapeUnicode, bool escapeForwardSlash);
    internal static void PerformJsonEscapeWhenNeeded(StringBuilder builder, int startPos, bool escapeUnicode, bool escapeForwardSlash);
    internal static bool RequiresJsonEscape(char ch, bool escapeUnicode, bool escapeForwardSlash);
    private bool SerializeObjectProperties(ObjectPropertyList objectPropertyList, StringBuilder destination, JsonSerializeOptions options, SingleItemOptimizedHashSet`1<object> objectsInPath, int depth);
    private bool SerializeObjectAsString(object value, StringBuilder destination, JsonSerializeOptions options);
}
[TargetAttribute("EventLog")]
public class NLog.Targets.EventLogTarget : TargetWithLayout {
    internal static int EventLogMaxMessageLength;
    private IEventLogWrapper _eventLogWrapper;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<int> <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<short> <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<EventLogEntryType> <EntryType>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Log>k__BackingField;
    private int _maxMessageLength;
    private Nullable`1<long> _maxKilobytes;
    [CompilerGeneratedAttribute]
private EventLogTargetOverflowAction <OnOverflow>k__BackingField;
    public string MachineName { get; public set; }
    public Layout`1<int> EventId { get; public set; }
    public Layout`1<short> Category { get; public set; }
    public Layout`1<EventLogEntryType> EntryType { get; public set; }
    [RequiredParameterAttribute]
public Layout Source { get; public set; }
    public string Log { get; public set; }
    public int MaxMessageLength { get; public set; }
    public Nullable`1<long> MaxKilobytes { get; public set; }
    public EventLogTargetOverflowAction OnOverflow { get; public set; }
    public EventLogTarget(string name);
    internal EventLogTarget(IEventLogWrapper eventLogWrapper, string sourceName);
    [CompilerGeneratedAttribute]
public string get_MachineName();
    [CompilerGeneratedAttribute]
public void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public Layout`1<int> get_EventId();
    [CompilerGeneratedAttribute]
public void set_EventId(Layout`1<int> value);
    [CompilerGeneratedAttribute]
public Layout`1<short> get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(Layout`1<short> value);
    [CompilerGeneratedAttribute]
public Layout`1<EventLogEntryType> get_EntryType();
    [CompilerGeneratedAttribute]
public void set_EntryType(Layout`1<EventLogEntryType> value);
    [CompilerGeneratedAttribute]
public Layout get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(Layout value);
    [CompilerGeneratedAttribute]
public string get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(string value);
    public int get_MaxMessageLength();
    public void set_MaxMessageLength(int value);
    public Nullable`1<long> get_MaxKilobytes();
    public void set_MaxKilobytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public EventLogTargetOverflowAction get_OnOverflow();
    [CompilerGeneratedAttribute]
public void set_OnOverflow(EventLogTargetOverflowAction value);
    public sealed virtual void Install(InstallationContext installationContext);
    public sealed virtual void Uninstall(InstallationContext installationContext);
    public sealed virtual Nullable`1<bool> IsInstalled(InstallationContext installationContext);
    protected virtual void InitializeTarget();
    protected virtual void Write(LogEventInfo logEvent);
    private void WriteEntry(string eventLogSource, string message, EventLogEntryType entryType, int eventId, short category);
    private EventLogEntryType GetEntryType(LogEventInfo logEvent);
    internal string GetFixedSource();
    private void CreateEventSourceIfNeeded(string fixedSource, bool alwaysThrowError);
}
public enum NLog.Targets.EventLogTargetOverflowAction : Enum {
    public int value__;
    public static EventLogTargetOverflowAction Truncate;
    public static EventLogTargetOverflowAction Split;
    public static EventLogTargetOverflowAction Discard;
}
internal abstract class NLog.Targets.FileArchiveModes.FileArchiveModeBase : object {
    private static DateTime MaxAgeArchiveFileDate;
    private int _lastArchiveFileCount;
    private DateTime _oldestArchiveFileDate;
    [CompilerGeneratedAttribute]
private bool <IsArchiveCleanupEnabled>k__BackingField;
    public bool IsArchiveCleanupEnabled { get; }
    protected FileArchiveModeBase(bool isArchiveCleanupEnabled);
    private static FileArchiveModeBase();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsArchiveCleanupEnabled();
    public virtual bool AttemptCleanupOnInitializeFile(string archiveFilePath, int maxArchiveFiles, int maxArchiveDays);
    public sealed virtual string GenerateFileNameMask(string archiveFilePath);
    public virtual List`1<DateAndSequenceArchive> GetExistingArchiveFiles(string archiveFilePath);
    protected void UpdateMaxArchiveState(List`1<DateAndSequenceArchive> existingArchiveFiles);
    private static int FileSortOrderComparison(DateAndSequenceArchive x, DateAndSequenceArchive y);
    protected virtual FileNameTemplate GenerateFileNameTemplate(string archiveFilePath);
    protected virtual string GenerateFileNameMask(string archiveFilePath, FileNameTemplate fileTemplate);
    protected abstract virtual DateAndSequenceArchive GenerateArchiveFileInfo(FileInfo archiveFile, FileNameTemplate fileTemplate);
    public abstract virtual DateAndSequenceArchive GenerateArchiveFileName(string archiveFilePath, DateTime archiveDate, List`1<DateAndSequenceArchive> existingArchiveFiles);
    [IteratorStateMachineAttribute("NLog.Targets.FileArchiveModes.FileArchiveModeBase/<CheckArchiveCleanup>d__16")]
public virtual IEnumerable`1<DateAndSequenceArchive> CheckArchiveCleanup(string archiveFilePath, List`1<DateAndSequenceArchive> existingArchiveFiles, int maxArchiveFiles, int maxArchiveDays);
    private static bool ShouldDeleteFile(DateAndSequenceArchive existingArchiveFile, int remainingFileCount, int maxArchiveFiles, int maxArchiveDays);
}
internal class NLog.Targets.FileArchiveModes.FileArchiveModeDate : FileArchiveModeBase {
    private string _archiveDateFormat;
    public FileArchiveModeDate(string archiveDateFormat, bool isArchiveCleanupEnabled);
    public virtual List`1<DateAndSequenceArchive> GetExistingArchiveFiles(string archiveFilePath);
    protected virtual DateAndSequenceArchive GenerateArchiveFileInfo(FileInfo archiveFile, FileNameTemplate fileTemplate);
    public virtual DateAndSequenceArchive GenerateArchiveFileName(string archiveFilePath, DateTime archiveDate, List`1<DateAndSequenceArchive> existingArchiveFiles);
}
internal class NLog.Targets.FileArchiveModes.FileArchiveModeDateAndSequence : FileArchiveModeBase {
    private string _archiveDateFormat;
    public FileArchiveModeDateAndSequence(string archiveDateFormat, bool archiveCleanupEnabled);
    public virtual bool AttemptCleanupOnInitializeFile(string archiveFilePath, int maxArchiveFiles, int maxArchiveDays);
    protected virtual DateAndSequenceArchive GenerateArchiveFileInfo(FileInfo archiveFile, FileNameTemplate fileTemplate);
    public virtual DateAndSequenceArchive GenerateArchiveFileName(string archiveFilePath, DateTime archiveDate, List`1<DateAndSequenceArchive> existingArchiveFiles);
    private static bool TryParseDateAndSequence(string archiveFileNameWithoutPath, string dateFormat, FileNameTemplate fileTemplate, DateTime& date, Int32& sequence);
}
internal class NLog.Targets.FileArchiveModes.FileArchiveModeDynamicSequence : FileArchiveModeBase {
    private ArchiveNumberingMode _archiveNumbering;
    private string _archiveDateFormat;
    private bool _customArchiveFileName;
    public FileArchiveModeDynamicSequence(ArchiveNumberingMode archiveNumbering, string archiveDateFormat, bool customArchiveFileName, bool archiveCleanupEnabled);
    private static bool RemoveNonLetters(string fileName, int startPosition, StringBuilder sb, Int32& digitsRemoved);
    protected virtual FileNameTemplate GenerateFileNameTemplate(string archiveFilePath);
    protected virtual DateAndSequenceArchive GenerateArchiveFileInfo(FileInfo archiveFile, FileNameTemplate fileTemplate);
    private static bool FileNameMatchesTemplate(string filename, FileNameTemplate fileTemplate);
    private static int ExtractArchiveNumberFromFileName(string archiveFileName);
    public virtual DateAndSequenceArchive GenerateArchiveFileName(string archiveFilePath, DateTime archiveDate, List`1<DateAndSequenceArchive> existingArchiveFiles);
    private int GetStartSequenceNo();
}
internal class NLog.Targets.FileArchiveModes.FileArchiveModeDynamicTemplate : object {
    private IFileArchiveMode _archiveHelper;
    public bool IsArchiveCleanupEnabled { get; }
    public FileArchiveModeDynamicTemplate(IFileArchiveMode archiveHelper);
    public sealed virtual bool get_IsArchiveCleanupEnabled();
    private static string CreateDynamicTemplate(string archiveFilePath);
    public sealed virtual bool AttemptCleanupOnInitializeFile(string archiveFilePath, int maxArchiveFiles, int maxArchiveDays);
    public sealed virtual IEnumerable`1<DateAndSequenceArchive> CheckArchiveCleanup(string archiveFilePath, List`1<DateAndSequenceArchive> existingArchiveFiles, int maxArchiveFiles, int maxArchiveDays);
    public sealed virtual DateAndSequenceArchive GenerateArchiveFileName(string archiveFilePath, DateTime archiveDate, List`1<DateAndSequenceArchive> existingArchiveFiles);
    public sealed virtual string GenerateFileNameMask(string archiveFilePath);
    public sealed virtual List`1<DateAndSequenceArchive> GetExistingArchiveFiles(string archiveFilePath);
}
internal static class NLog.Targets.FileArchiveModes.FileArchiveModeFactory : object {
    public static IFileArchiveMode CreateArchiveStyle(string archiveFilePath, ArchiveNumberingMode archiveNumbering, string dateFormat, bool customArchiveFileName, bool archiveCleanupEnabled);
    private static IFileArchiveMode CreateStrictFileArchiveMode(ArchiveNumberingMode archiveNumbering, string dateFormat, bool archiveCleanupEnabled);
    public static bool ContainsFileNamePattern(string fileName);
}
internal class NLog.Targets.FileArchiveModes.FileArchiveModeRolling : object {
    public bool IsArchiveCleanupEnabled { get; }
    public sealed virtual bool get_IsArchiveCleanupEnabled();
    public sealed virtual bool AttemptCleanupOnInitializeFile(string archiveFilePath, int maxArchiveFiles, int maxArchiveDays);
    public sealed virtual string GenerateFileNameMask(string archiveFilePath);
    public sealed virtual List`1<DateAndSequenceArchive> GetExistingArchiveFiles(string archiveFilePath);
    private static string ReplaceNumberPattern(string pattern, int value);
    public sealed virtual DateAndSequenceArchive GenerateArchiveFileName(string archiveFilePath, DateTime archiveDate, List`1<DateAndSequenceArchive> existingArchiveFiles);
    [IteratorStateMachineAttribute("NLog.Targets.FileArchiveModes.FileArchiveModeRolling/<CheckArchiveCleanup>d__7")]
public sealed virtual IEnumerable`1<DateAndSequenceArchive> CheckArchiveCleanup(string archiveFilePath, List`1<DateAndSequenceArchive> existingArchiveFiles, int maxArchiveFiles, int maxArchiveDays);
}
internal class NLog.Targets.FileArchiveModes.FileArchiveModeSequence : FileArchiveModeBase {
    private string _archiveDateFormat;
    public FileArchiveModeSequence(string archiveDateFormat, bool isArchiveCleanupEnabled);
    public virtual bool AttemptCleanupOnInitializeFile(string archiveFilePath, int maxArchiveFiles, int maxArchiveDays);
    protected virtual DateAndSequenceArchive GenerateArchiveFileInfo(FileInfo archiveFile, FileNameTemplate fileTemplate);
    public virtual DateAndSequenceArchive GenerateArchiveFileName(string archiveFilePath, DateTime archiveDate, List`1<DateAndSequenceArchive> existingArchiveFiles);
}
public enum NLog.Targets.FileArchivePeriod : Enum {
    public int value__;
    public static FileArchivePeriod None;
    public static FileArchivePeriod Year;
    public static FileArchivePeriod Month;
    public static FileArchivePeriod Day;
    public static FileArchivePeriod Hour;
    public static FileArchivePeriod Minute;
    public static FileArchivePeriod Sunday;
    public static FileArchivePeriod Monday;
    public static FileArchivePeriod Tuesday;
    public static FileArchivePeriod Wednesday;
    public static FileArchivePeriod Thursday;
    public static FileArchivePeriod Friday;
    public static FileArchivePeriod Saturday;
}
public enum NLog.Targets.FilePathKind : Enum {
    public byte value__;
    public static FilePathKind Unknown;
    public static FilePathKind Relative;
    public static FilePathKind Absolute;
}
[TargetAttribute("File")]
public class NLog.Targets.FileTarget : TargetWithLayoutHeaderAndFooter {
    private static int InitializedFilesCleanupPeriod;
    private static long ArchiveAboveSizeDisabled;
    private Dictionary`2<string, DateTime> _initializedFiles;
    private IFileAppenderCache _fileAppenderCache;
    private IFileArchiveMode _fileArchiveHelper;
    private Timer _autoClosingTimer;
    private int _initializedFilesCounter;
    private int _maxArchiveFiles;
    private int _maxArchiveDays;
    private FilePathLayout _fullFileName;
    private FilePathLayout _fullArchiveFileName;
    private FileArchivePeriod _archiveEvery;
    private long _archiveAboveSize;
    private bool _enableArchiveFileCompression;
    private Nullable`1<DateTime> _previousLogEventTimestamp;
    private string _previousLogFileName;
    private bool _concurrentWrites;
    private bool _cleanupFileName;
    private FilePathKind _fileNameKind;
    private FilePathKind _archiveFileKind;
    [CompilerGeneratedAttribute]
private bool <CreateDirs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteOldFileOnStartup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplaceFileContentsOnEachWrite>k__BackingField;
    private bool _keepFileOpen;
    [CompilerGeneratedAttribute]
private bool <EnableFileDelete>k__BackingField;
    private Win32FileAttributes _fileAttributes;
    [CompilerGeneratedAttribute]
private LineEndingMode <LineEnding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoFlush>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OpenFileCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OpenFileCacheTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OpenFileFlushTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private bool <DiscardAll>k__BackingField;
    private Nullable`1<bool> _writeBom;
    private Nullable`1<int> _concurrentWriteAttempts;
    [CompilerGeneratedAttribute]
private int <ConcurrentWriteAttemptDelay>k__BackingField;
    private Nullable`1<bool> _archiveOldFileOnStartup;
    [CompilerGeneratedAttribute]
private bool <WriteHeaderWhenInitialFileNotEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ArchiveOldFileOnStartupAboveSize>k__BackingField;
    private string _archiveDateFormat;
    private ArchiveNumberingMode _archiveNumbering;
    [CompilerGeneratedAttribute]
private static IFileCompressor <FileCompressor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceManaged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceMutexConcurrentWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteFooterOnArchivingOnly>k__BackingField;
    private ReusableStreamCreator _reusableFileWriteStream;
    private ReusableStreamCreator _reusableBatchFileWriteStream;
    private ReusableBufferCreator _reusableEncodingBuffer;
    private KeySelector`2<AsyncLogEventInfo, string> _getFullFileNameDelegate;
    [RequiredParameterAttribute]
public Layout FileName { get; public set; }
    public bool CleanupFileName { get; public set; }
    public FilePathKind FileNameKind { get; public set; }
    public bool CreateDirs { get; public set; }
    public bool DeleteOldFileOnStartup { get; public set; }
    public bool ReplaceFileContentsOnEachWrite { get; public set; }
    public bool KeepFileOpen { get; public set; }
    public bool EnableFileDelete { get; public set; }
    public Win32FileAttributes FileAttributes { get; public set; }
    private bool NLog.Internal.FileAppenders.ICreateFileParameters.IsArchivingEnabled { get; }
    private int NLog.Internal.FileAppenders.ICreateFileParameters.FileOpenRetryCount { get; }
    private int NLog.Internal.FileAppenders.ICreateFileParameters.FileOpenRetryDelay { get; }
    public LineEndingMode LineEnding { get; public set; }
    public bool AutoFlush { get; public set; }
    public int OpenFileCacheSize { get; public set; }
    public int OpenFileCacheTimeout { get; public set; }
    public int OpenFileFlushTimeout { get; public set; }
    public int BufferSize { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool DiscardAll { get; public set; }
    public bool ConcurrentWrites { get; public set; }
    [ObsoleteAttribute("Instead use KeepFileOpen = false. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public bool NetworkWrites { get; public set; }
    public bool WriteBom { get; public set; }
    public int ConcurrentWriteAttempts { get; public set; }
    public int ConcurrentWriteAttemptDelay { get; public set; }
    public bool ArchiveOldFileOnStartup { get; public set; }
    public bool WriteHeaderWhenInitialFileNotEmpty { get; public set; }
    public long ArchiveOldFileOnStartupAboveSize { get; public set; }
    public string ArchiveDateFormat { get; public set; }
    public long ArchiveAboveSize { get; public set; }
    public FileArchivePeriod ArchiveEvery { get; public set; }
    public FilePathKind ArchiveFileKind { get; public set; }
    public Layout ArchiveFileName { get; public set; }
    public int MaxArchiveFiles { get; public set; }
    public int MaxArchiveDays { get; public set; }
    public ArchiveNumberingMode ArchiveNumbering { get; public set; }
    public static IFileCompressor FileCompressor { get; public set; }
    public bool EnableArchiveFileCompression { get; public set; }
    public bool ForceManaged { get; public set; }
    public bool ForceMutexConcurrentWrites { get; public set; }
    public bool WriteFooterOnArchivingOnly { get; public set; }
    protected internal string NewLineChars { get; }
    private bool IsArchivingEnabled { get; }
    private bool IsSimpleKeepFileOpen { get; }
    private bool EnableFileDeleteSimpleMonitor { get; }
    private bool NLog.Internal.FileAppenders.ICreateFileParameters.EnableFileDeleteSimpleMonitor { get; }
    internal FileTarget(IFileAppenderCache fileAppenderCache);
    private static FileTarget();
    public FileTarget(string name);
    private IFileArchiveMode GetFileArchiveHelper(string archiveFilePattern);
    public Layout get_FileName();
    public void set_FileName(Layout value);
    private FilePathLayout CreateFileNameLayout(Layout value);
    public bool get_CleanupFileName();
    public void set_CleanupFileName(bool value);
    public FilePathKind get_FileNameKind();
    public void set_FileNameKind(FilePathKind value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CreateDirs();
    [CompilerGeneratedAttribute]
public void set_CreateDirs(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeleteOldFileOnStartup();
    [CompilerGeneratedAttribute]
public void set_DeleteOldFileOnStartup(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReplaceFileContentsOnEachWrite();
    [CompilerGeneratedAttribute]
public void set_ReplaceFileContentsOnEachWrite(bool value);
    public bool get_KeepFileOpen();
    public void set_KeepFileOpen(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableFileDelete();
    [CompilerGeneratedAttribute]
public void set_EnableFileDelete(bool value);
    public sealed virtual Win32FileAttributes get_FileAttributes();
    public void set_FileAttributes(Win32FileAttributes value);
    private sealed virtual override bool NLog.Internal.FileAppenders.ICreateFileParameters.get_IsArchivingEnabled();
    private sealed virtual override int NLog.Internal.FileAppenders.ICreateFileParameters.get_FileOpenRetryCount();
    private sealed virtual override int NLog.Internal.FileAppenders.ICreateFileParameters.get_FileOpenRetryDelay();
    [CompilerGeneratedAttribute]
public LineEndingMode get_LineEnding();
    [CompilerGeneratedAttribute]
public void set_LineEnding(LineEndingMode value);
    [CompilerGeneratedAttribute]
public bool get_AutoFlush();
    [CompilerGeneratedAttribute]
public void set_AutoFlush(bool value);
    [CompilerGeneratedAttribute]
public int get_OpenFileCacheSize();
    [CompilerGeneratedAttribute]
public void set_OpenFileCacheSize(int value);
    [CompilerGeneratedAttribute]
public int get_OpenFileCacheTimeout();
    [CompilerGeneratedAttribute]
public void set_OpenFileCacheTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_OpenFileFlushTimeout();
    [CompilerGeneratedAttribute]
public void set_OpenFileFlushTimeout(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public bool get_DiscardAll();
    [CompilerGeneratedAttribute]
public void set_DiscardAll(bool value);
    public sealed virtual bool get_ConcurrentWrites();
    public void set_ConcurrentWrites(bool value);
    public bool get_NetworkWrites();
    public void set_NetworkWrites(bool value);
    public bool get_WriteBom();
    public void set_WriteBom(bool value);
    public int get_ConcurrentWriteAttempts();
    public void set_ConcurrentWriteAttempts(int value);
    [CompilerGeneratedAttribute]
public int get_ConcurrentWriteAttemptDelay();
    [CompilerGeneratedAttribute]
public void set_ConcurrentWriteAttemptDelay(int value);
    public bool get_ArchiveOldFileOnStartup();
    public void set_ArchiveOldFileOnStartup(bool value);
    [CompilerGeneratedAttribute]
public bool get_WriteHeaderWhenInitialFileNotEmpty();
    [CompilerGeneratedAttribute]
public void set_WriteHeaderWhenInitialFileNotEmpty(bool value);
    [CompilerGeneratedAttribute]
public long get_ArchiveOldFileOnStartupAboveSize();
    [CompilerGeneratedAttribute]
public void set_ArchiveOldFileOnStartupAboveSize(long value);
    public string get_ArchiveDateFormat();
    public void set_ArchiveDateFormat(string value);
    public long get_ArchiveAboveSize();
    public void set_ArchiveAboveSize(long value);
    public FileArchivePeriod get_ArchiveEvery();
    public void set_ArchiveEvery(FileArchivePeriod value);
    public FilePathKind get_ArchiveFileKind();
    public void set_ArchiveFileKind(FilePathKind value);
    public Layout get_ArchiveFileName();
    public void set_ArchiveFileName(Layout value);
    public int get_MaxArchiveFiles();
    public void set_MaxArchiveFiles(int value);
    public int get_MaxArchiveDays();
    public void set_MaxArchiveDays(int value);
    public ArchiveNumberingMode get_ArchiveNumbering();
    public void set_ArchiveNumbering(ArchiveNumberingMode value);
    [CompilerGeneratedAttribute]
public static IFileCompressor get_FileCompressor();
    [CompilerGeneratedAttribute]
public static void set_FileCompressor(IFileCompressor value);
    public bool get_EnableArchiveFileCompression();
    public void set_EnableArchiveFileCompression(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ForceManaged();
    [CompilerGeneratedAttribute]
public void set_ForceManaged(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceMutexConcurrentWrites();
    [CompilerGeneratedAttribute]
public void set_ForceMutexConcurrentWrites(bool value);
    [CompilerGeneratedAttribute]
public bool get_WriteFooterOnArchivingOnly();
    [CompilerGeneratedAttribute]
public void set_WriteFooterOnArchivingOnly(bool value);
    protected internal string get_NewLineChars();
    private void RefreshArchiveFilePatternToWatch(string fileName, LogEventInfo logEvent);
    public void CleanupInitializedFiles();
    public void CleanupInitializedFiles(DateTime cleanupThreshold);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    private IFileAppenderFactory GetFileAppenderFactory();
    private bool get_IsArchivingEnabled();
    private bool get_IsSimpleKeepFileOpen();
    private bool get_EnableFileDeleteSimpleMonitor();
    private sealed virtual override bool NLog.Internal.FileAppenders.ICreateFileParameters.get_EnableFileDeleteSimpleMonitor();
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    private void ResetFileAppenders(string reason);
    protected virtual void Write(LogEventInfo logEvent);
    internal string GetFullFileName(LogEventInfo logEvent);
    protected virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    private int WriteToMemoryStream(IList`1<AsyncLogEventInfo> logEvents, int startIndex, MemoryStream ms);
    private void ProcessLogEvent(LogEventInfo logEvent, string fileName, ArraySegment`1<byte> bytesToWrite);
    [ObsoleteAttribute("No longer used and replaced by RenderFormattedMessage. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    [ObsoleteAttribute("No longer used and replaced by RenderFormattedMessage. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual Byte[] GetBytesToWrite(LogEventInfo logEvent);
    [ObsoleteAttribute("No longer used and replaced by TransformStream. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual Byte[] TransformBytes(Byte[] value);
    protected virtual void RenderFormattedMessageToStream(LogEventInfo logEvent, StringBuilder formatBuilder, Char[] transformBuffer, MemoryStream streamTarget);
    protected virtual void RenderFormattedMessage(LogEventInfo logEvent, StringBuilder target);
    private void TransformBuilderToStream(LogEventInfo logEvent, StringBuilder builder, Char[] transformBuffer, MemoryStream workStream);
    protected virtual void TransformStream(LogEventInfo logEvent, MemoryStream stream);
    private void AppendMemoryStreamToFile(string currentFileName, LogEventInfo firstLogEvent, MemoryStream ms, Exception& lastException);
    private void ArchiveFile(string fileName, string archiveFileName);
    private void ArchiveFileCompress(string fileName, string archiveFileName);
    private void ArchiveFileAppendExisting(string fileName, string archiveFileName);
    private void ArchiveFileMove(string fileName, string archiveFileName);
    private bool DeleteOldArchiveFile(string fileName);
    private void DeleteAndWaitForFileDelete(string fileName);
    private string GetArchiveDateFormatString(string defaultFormat);
    private Nullable`1<DateTime> GetArchiveDate(string fileName, LogEventInfo logEvent, DateTime previousLogEventTimestamp);
    private bool PreviousLogOverlappedPeriod(LogEventInfo logEvent, DateTime previousLogEventTimestamp, DateTime lastFileWrite);
    private Nullable`1<DateTime> CalculateNextArchiveEventTime(DateTime timestamp);
    public static DateTime CalculateNextWeekday(DateTime previousLogEventTimestamp, DayOfWeek dayOfWeek);
    private void DoAutoArchive(string fileName, LogEventInfo eventInfo, DateTime previousLogEventTimestamp, bool initializedNewFile);
    private string GenerateArchiveFileNameAfterCleanup(string fileName, FileInfo fileInfo, string archiveFilePattern, Nullable`1<DateTime> archiveDate, bool initializedNewFile);
    private void CleanupOldArchiveFiles(FileInfo currentFile, string archiveFilePattern, List`1<DateAndSequenceArchive> existingArchiveFiles, DateAndSequenceArchive newArchiveFile);
    private static void ExcludeActiveFileFromOldArchiveFiles(FileInfo currentFile, List`1<DateAndSequenceArchive> existingArchiveFiles);
    private string GetArchiveFileNamePattern(string fileName, LogEventInfo eventInfo);
    private bool TryArchiveFile(string fileName, LogEventInfo ev, int upcomingWriteSize, DateTime previousLogEventTimestamp, bool initializedNewFile);
    private BaseFileAppender TryCloseFileAppenderBeforeArchive(string fileName, string archiveFile);
    private void ArchiveFileAfterCloseFileAppender(BaseFileAppender archivedAppender, string archiveFile, LogEventInfo ev, int upcomingWriteSize, DateTime previousLogEventTimestamp);
    private string GetArchiveFileName(string fileName, LogEventInfo ev, int upcomingWriteSize, DateTime previousLogEventTimestamp, bool initializedNewFile);
    private string GetPotentialFileForArchiving(string fileName);
    private string GetArchiveFileNameBasedOnFileSize(string fileName, int upcomingWriteSize, bool initializedNewFile);
    private string TryFallbackToPreviousLogFileName(string archiveFileName, bool initializedNewFile);
    private string GetArchiveFileNameBasedOnTime(string fileName, LogEventInfo logEvent, DateTime previousLogEventTimestamp, bool initializedNewFile);
    private Nullable`1<DateTime> TryGetArchiveFileCreationTimeSource(string fileName, DateTime previousLogEventTimestamp);
    private static DateTime TruncateArchiveTime(DateTime input, FileArchivePeriod resolution);
    private void AutoCloseAppendersAfterArchive(object sender, EventArgs state);
    private void AutoClosingTimerCallback(object sender, EventArgs state);
    private void ConditionalFlushOpenFileAppenders();
    private void WriteToFile(string fileName, ArraySegment`1<byte> bytes, bool initializedNewFile);
    private DateTime InitializeFile(string fileName, LogEventInfo logEvent);
    private static DateTime EnsureValidLogEventTimeStamp(DateTime logEventTimeStamp, DateTime previousTimeStamp);
    private void CloseInvalidFileHandle(string fileName);
    private void FinalizeFile(string fileName, bool isArchiving);
    private void WriteFooter(string fileName);
    internal bool ShouldArchiveOldFileOnStartup(string fileName);
    private void PrepareForNewFile(string fileName, LogEventInfo logEvent);
    private void ReplaceFileContent(string fileName, ArraySegment`1<byte> bytes, bool firstAttempt);
    private static bool InitialValueBom(Encoding encoding);
    private void WriteHeaderAndBom(BaseFileAppender appender);
    private ArraySegment`1<byte> GetLayoutBytes(Layout layout);
    [CompilerGeneratedAttribute]
private void <InitializeTarget>b__187_0(object state);
    [CompilerGeneratedAttribute]
private string <Write>b__196_0(AsyncLogEventInfo c);
}
internal interface NLog.Targets.IArchiveFileCompressor {
    public abstract virtual void CompressFile(string fileName, string archiveFileName, string entryName);
}
internal interface NLog.Targets.IColoredConsolePrinter {
    public IList`1<ConsoleRowHighlightingRule> DefaultConsoleRowHighlightingRules { get; }
    public abstract virtual TextWriter AcquireTextWriter(TextWriter consoleStream, StringBuilder reusableBuilder);
    public abstract virtual void ReleaseTextWriter(TextWriter consoleWriter, TextWriter consoleStream, Nullable`1<ConsoleColor> oldForegroundColor, Nullable`1<ConsoleColor> oldBackgroundColor, bool flush);
    public abstract virtual Nullable`1<ConsoleColor> ChangeForegroundColor(TextWriter consoleWriter, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> oldForegroundColor);
    public abstract virtual Nullable`1<ConsoleColor> ChangeBackgroundColor(TextWriter consoleWriter, Nullable`1<ConsoleColor> backgroundColor, Nullable`1<ConsoleColor> oldBackgroundColor);
    public abstract virtual void ResetDefaultColors(TextWriter consoleWriter, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> backgroundColor);
    public abstract virtual void WriteSubString(TextWriter consoleWriter, string text, int index, int endIndex);
    public abstract virtual void WriteChar(TextWriter consoleWriter, char text);
    public abstract virtual void WriteLine(TextWriter consoleWriter, string text);
    public abstract virtual IList`1<ConsoleRowHighlightingRule> get_DefaultConsoleRowHighlightingRules();
}
internal interface NLog.Targets.IFileArchiveMode {
    public bool IsArchiveCleanupEnabled { get; }
    public abstract virtual bool get_IsArchiveCleanupEnabled();
    public abstract virtual bool AttemptCleanupOnInitializeFile(string archiveFilePath, int maxArchiveFiles, int maxArchiveDays);
    public abstract virtual string GenerateFileNameMask(string archiveFilePath);
    public abstract virtual List`1<DateAndSequenceArchive> GetExistingArchiveFiles(string archiveFilePath);
    public abstract virtual DateAndSequenceArchive GenerateArchiveFileName(string archiveFilePath, DateTime archiveDate, List`1<DateAndSequenceArchive> existingArchiveFiles);
    public abstract virtual IEnumerable`1<DateAndSequenceArchive> CheckArchiveCleanup(string archiveFilePath, List`1<DateAndSequenceArchive> existingArchiveFiles, int maxArchiveFiles, int maxArchiveDays);
}
public interface NLog.Targets.IFileCompressor {
    public abstract virtual void CompressFile(string fileName, string archiveFileName);
}
public class NLog.Targets.JsonSerializeOptions : object {
    [CompilerGeneratedAttribute]
private bool <QuoteKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatProvider <FormatProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeUnicode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeForwardSlash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnumAsInteger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SanitizeDictionaryKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRecursionLimit>k__BackingField;
    [ObsoleteAttribute("Marked obsolete on NLog 5.0.")]
[EditorBrowsableAttribute("1")]
public bool QuoteKeys { get; public set; }
    [ObsoleteAttribute("Marked obsolete on NLog 5.0. Should always be InvariantCulture.")]
[EditorBrowsableAttribute("1")]
public IFormatProvider FormatProvider { get; public set; }
    [ObsoleteAttribute("Marked obsolete on NLog 5.0. Should always be InvariantCulture.")]
[EditorBrowsableAttribute("1")]
public string Format { get; public set; }
    public bool EscapeUnicode { get; public set; }
    public bool EscapeForwardSlash { get; public set; }
    public bool EnumAsInteger { get; public set; }
    public bool SanitizeDictionaryKeys { get; public set; }
    public int MaxRecursionLimit { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_QuoteKeys();
    [CompilerGeneratedAttribute]
public void set_QuoteKeys(bool value);
    [CompilerGeneratedAttribute]
public IFormatProvider get_FormatProvider();
    [CompilerGeneratedAttribute]
public void set_FormatProvider(IFormatProvider value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public bool get_EscapeUnicode();
    [CompilerGeneratedAttribute]
public void set_EscapeUnicode(bool value);
    [CompilerGeneratedAttribute]
public bool get_EscapeForwardSlash();
    [CompilerGeneratedAttribute]
public void set_EscapeForwardSlash(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnumAsInteger();
    [CompilerGeneratedAttribute]
public void set_EnumAsInteger(bool value);
    [CompilerGeneratedAttribute]
public bool get_SanitizeDictionaryKeys();
    [CompilerGeneratedAttribute]
public void set_SanitizeDictionaryKeys(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxRecursionLimit();
    [CompilerGeneratedAttribute]
public void set_MaxRecursionLimit(int value);
}
[TypeConverterAttribute("NLog.Targets.LineEndingMode/LineEndingModeConverter")]
public class NLog.Targets.LineEndingMode : object {
    public static LineEndingMode Default;
    public static LineEndingMode CRLF;
    public static LineEndingMode CR;
    public static LineEndingMode LF;
    public static LineEndingMode Null;
    public static LineEndingMode None;
    private string _name;
    private string _newLineCharacters;
    public string Name { get; }
    public string NewLineCharacters { get; }
    private LineEndingMode(string name, string newLineCharacters);
    private static LineEndingMode();
    public string get_Name();
    public string get_NewLineCharacters();
    public static LineEndingMode FromString(string name);
    public static bool op_Equality(LineEndingMode mode1, LineEndingMode mode2);
    public static bool op_Inequality(LineEndingMode mode1, LineEndingMode mode2);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LineEndingMode other);
}
[TargetAttribute("Mail")]
[TargetAttribute("Email")]
[TargetAttribute("Smtp")]
[TargetAttribute("SmtpClient")]
public class NLog.Targets.MailTarget : TargetWithLayoutHeaderAndFooter {
    private static string RequiredPropertyIsEmptyFormat;
    private Layout _from;
    private SmtpSection _currentailSettings;
    [CompilerGeneratedAttribute]
private Layout <To>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <CC>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Bcc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddNewLines>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Html>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <SmtpServer>k__BackingField;
    [CompilerGeneratedAttribute]
private SmtpAuthenticationMode <SmtpAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <SmtpUserName>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <SmtpPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableSsl>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<int> <SmtpPort>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSystemNetMailSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private SmtpDeliveryMethod <DeliveryMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <PickupDirectoryLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<MailPriority> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplaceNewlineWithBrTagInHtml>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<int> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MethodCallParameter> <MailHeaders>k__BackingField;
    internal SmtpSection SmtpSection { get; internal set; }
    [RequiredParameterAttribute]
public Layout From { get; public set; }
    [RequiredParameterAttribute]
public Layout To { get; public set; }
    public Layout CC { get; public set; }
    public Layout Bcc { get; public set; }
    public bool AddNewLines { get; public set; }
    [RequiredParameterAttribute]
public Layout Subject { get; public set; }
    public Layout Body { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool Html { get; public set; }
    public Layout SmtpServer { get; public set; }
    public SmtpAuthenticationMode SmtpAuthentication { get; public set; }
    public Layout SmtpUserName { get; public set; }
    public Layout SmtpPassword { get; public set; }
    public bool EnableSsl { get; public set; }
    public Layout`1<int> SmtpPort { get; public set; }
    public bool UseSystemNetMailSettings { get; public set; }
    public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    public Layout PickupDirectoryLocation { get; public set; }
    public Layout`1<MailPriority> Priority { get; public set; }
    public bool ReplaceNewlineWithBrTagInHtml { get; public set; }
    public Layout`1<int> Timeout { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.MethodCallParameter", "mailheader")]
public IList`1<MethodCallParameter> MailHeaders { get; }
    public MailTarget(string name);
    internal SmtpSection get_SmtpSection();
    internal void set_SmtpSection(SmtpSection value);
    public Layout get_From();
    public void set_From(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_To();
    [CompilerGeneratedAttribute]
public void set_To(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_CC();
    [CompilerGeneratedAttribute]
public void set_CC(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_Bcc();
    [CompilerGeneratedAttribute]
public void set_Bcc(Layout value);
    [CompilerGeneratedAttribute]
public bool get_AddNewLines();
    [CompilerGeneratedAttribute]
public void set_AddNewLines(bool value);
    [CompilerGeneratedAttribute]
public Layout get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(Layout value);
    public Layout get_Body();
    public void set_Body(Layout value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public bool get_Html();
    [CompilerGeneratedAttribute]
public void set_Html(bool value);
    [CompilerGeneratedAttribute]
public Layout get_SmtpServer();
    [CompilerGeneratedAttribute]
public void set_SmtpServer(Layout value);
    [CompilerGeneratedAttribute]
public SmtpAuthenticationMode get_SmtpAuthentication();
    [CompilerGeneratedAttribute]
public void set_SmtpAuthentication(SmtpAuthenticationMode value);
    [CompilerGeneratedAttribute]
public Layout get_SmtpUserName();
    [CompilerGeneratedAttribute]
public void set_SmtpUserName(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_SmtpPassword();
    [CompilerGeneratedAttribute]
public void set_SmtpPassword(Layout value);
    [CompilerGeneratedAttribute]
public bool get_EnableSsl();
    [CompilerGeneratedAttribute]
public void set_EnableSsl(bool value);
    [CompilerGeneratedAttribute]
public Layout`1<int> get_SmtpPort();
    [CompilerGeneratedAttribute]
public void set_SmtpPort(Layout`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_UseSystemNetMailSettings();
    [CompilerGeneratedAttribute]
public void set_UseSystemNetMailSettings(bool value);
    [CompilerGeneratedAttribute]
public SmtpDeliveryMethod get_DeliveryMethod();
    [CompilerGeneratedAttribute]
public void set_DeliveryMethod(SmtpDeliveryMethod value);
    [CompilerGeneratedAttribute]
public Layout get_PickupDirectoryLocation();
    [CompilerGeneratedAttribute]
public void set_PickupDirectoryLocation(Layout value);
    [CompilerGeneratedAttribute]
public Layout`1<MailPriority> get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(Layout`1<MailPriority> value);
    [CompilerGeneratedAttribute]
public bool get_ReplaceNewlineWithBrTagInHtml();
    [CompilerGeneratedAttribute]
public void set_ReplaceNewlineWithBrTagInHtml(bool value);
    [CompilerGeneratedAttribute]
public Layout`1<int> get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(Layout`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<MethodCallParameter> get_MailHeaders();
    internal virtual ISmtpClient CreateSmtpClient();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    protected virtual void InitializeTarget();
    private void ProcessSingleMailMessage(IEnumerable`1<AsyncLogEventInfo> events);
    private StringBuilder CreateBodyBuffer(IEnumerable`1<AsyncLogEventInfo> events, LogEventInfo firstEvent, LogEventInfo lastEvent);
    internal void ConfigureMailClient(LogEventInfo lastEvent, ISmtpClient client);
    internal static string ConvertDirectoryLocation(string pickupDirectoryLocation);
    private void CheckRequiredParameters();
    private string GetSmtpSettingsKey(LogEventInfo logEvent);
    private MailMessage CreateMailMessage(LogEventInfo lastEvent, string body);
    private bool AddAddresses(MailAddressCollection mailAddressCollection, Layout layout, LogEventInfo logEvent);
    [CompilerGeneratedAttribute]
private string <Write>b__95_0(AsyncLogEventInfo l);
}
[TargetAttribute("Memory")]
public class NLog.Targets.MemoryTarget : TargetWithLayoutHeaderAndFooter {
    private ThreadSafeList`1<string> _logs;
    [CompilerGeneratedAttribute]
private int <MaxLogsCount>k__BackingField;
    public IList`1<string> Logs { get; }
    public int MaxLogsCount { get; public set; }
    public MemoryTarget(string name);
    public IList`1<string> get_Logs();
    [CompilerGeneratedAttribute]
public int get_MaxLogsCount();
    [CompilerGeneratedAttribute]
public void set_MaxLogsCount(int value);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
}
[NLogConfigurationItemAttribute]
public class NLog.Targets.MethodCallParameter : object {
    private ValueTypeLayoutInfo _layoutInfo;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    [ObsoleteAttribute("Use property ParameterType instead. Marked obsolete on NLog 4.6")]
[EditorBrowsableAttribute("1")]
public Type Type { get; public set; }
    public Type ParameterType { get; public set; }
    public Layout DefaultValue { get; public set; }
    public MethodCallParameter(Layout layout);
    public MethodCallParameter(string parameterName, Layout layout);
    public MethodCallParameter(string name, Layout layout, Type type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public Layout get_Layout();
    public void set_Layout(Layout value);
    public Type get_Type();
    public void set_Type(Type value);
    public Type get_ParameterType();
    public void set_ParameterType(Type value);
    public Layout get_DefaultValue();
    public void set_DefaultValue(Layout value);
    public object RenderValue(LogEventInfo logEvent);
}
[TargetAttribute("MethodCall")]
public class NLog.Targets.MethodCallTarget : MethodCallTargetBase {
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    private Action`2<LogEventInfo, Object[]> _logEventAction;
    public string ClassName { get; public set; }
    public string MethodName { get; public set; }
    public MethodCallTarget(string name);
    public MethodCallTarget(string name, Action`2<LogEventInfo, Object[]> logEventAction);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    protected virtual void InitializeTarget();
    [UnconditionalSuppressMessageAttribute("Trimming - Allow method lookup from config", "IL2075")]
private static Action`2<LogEventInfo, Object[]> BuildLogEventAction(string className, string methodName);
    private static Action`2<LogEventInfo, Object[]> BuildLogEventAction(MethodInfo methodInfo);
    private static LateBoundMethod CreateFastInvoke(MethodInfo methodInfo, Object[] parameters);
    private static LateBoundMethod CreateNormalInvoke(MethodInfo methodInfo, Object[] parameters);
    protected virtual void DoInvoke(Object[] parameters, AsyncLogEventInfo logEvent);
    protected virtual void DoInvoke(Object[] parameters);
    private void ExecuteLogMethod(Object[] parameters, LogEventInfo logEvent);
}
public abstract class NLog.Targets.MethodCallTargetBase : Target {
    [CompilerGeneratedAttribute]
private IList`1<MethodCallParameter> <Parameters>k__BackingField;
    [ArrayParameterAttribute("NLog.Targets.MethodCallParameter", "parameter")]
public IList`1<MethodCallParameter> Parameters { get; private set; }
    [CompilerGeneratedAttribute]
public IList`1<MethodCallParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<MethodCallParameter> value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void DoInvoke(Object[] parameters, AsyncLogEventInfo logEvent);
    protected virtual void DoInvoke(Object[] parameters, AsyncContinuation continuation);
    protected abstract virtual void DoInvoke(Object[] parameters);
}
public class NLog.Targets.NetworkLogEventDroppedEventArgs : EventArgs {
    internal static NetworkLogEventDroppedEventArgs MaxMessageSizeOverflow;
    internal static NetworkLogEventDroppedEventArgs MaxConnectionsOverflow;
    internal static NetworkLogEventDroppedEventArgs MaxQueueOverflow;
    internal static NetworkLogEventDroppedEventArgs NetworkErrorDetected;
    [CompilerGeneratedAttribute]
private NetworkLogEventDroppedReason <Reason>k__BackingField;
    public NetworkLogEventDroppedReason Reason { get; }
    public NetworkLogEventDroppedEventArgs(NetworkLogEventDroppedReason reason);
    private static NetworkLogEventDroppedEventArgs();
    [CompilerGeneratedAttribute]
public NetworkLogEventDroppedReason get_Reason();
}
public enum NLog.Targets.NetworkLogEventDroppedReason : Enum {
    public int value__;
    public static NetworkLogEventDroppedReason MaxMessageSizeOverflow;
    public static NetworkLogEventDroppedReason MaxQueueOverflow;
    public static NetworkLogEventDroppedReason MaxConnectionsOverflow;
    public static NetworkLogEventDroppedReason NetworkError;
}
[TargetAttribute("Network")]
public class NLog.Targets.NetworkTarget : TargetWithLayout {
    private Dictionary`2<string, LinkedListNode`1<NetworkSender>> _currentSenderCache;
    private LinkedList`1<NetworkSender> _openNetworkSenders;
    private ReusableBufferCreator _reusableEncodingBuffer;
    [CompilerGeneratedAttribute]
private Layout <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NewLine>k__BackingField;
    private LineEndingMode _lineEnding;
    [CompilerGeneratedAttribute]
private int <MaxMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConnections>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkTargetConnectionsOverflowAction <OnConnectionOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxQueueSize>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkTargetQueueOverflowAction <OnQueueOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<NetworkLogEventDroppedEventArgs> LogEventDropped;
    [CompilerGeneratedAttribute]
private int <ConnectionCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkTargetOverflowAction <OnOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeepAliveTimeSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendTimeoutSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkTargetCompressionType <Compress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompressMinBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private INetworkSenderFactory <SenderFactory>k__BackingField;
    public Layout Address { get; public set; }
    public bool KeepConnection { get; public set; }
    public bool NewLine { get; public set; }
    public LineEndingMode LineEnding { get; public set; }
    public int MaxMessageSize { get; public set; }
    public int MaxConnections { get; public set; }
    public NetworkTargetConnectionsOverflowAction OnConnectionOverflow { get; public set; }
    public int MaxQueueSize { get; public set; }
    public NetworkTargetQueueOverflowAction OnQueueOverflow { get; public set; }
    public int ConnectionCacheSize { get; public set; }
    public NetworkTargetOverflowAction OnOverflow { get; public set; }
    public Encoding Encoding { get; public set; }
    public SslProtocols SslProtocols { get; public set; }
    public int KeepAliveTimeSeconds { get; public set; }
    public int SendTimeoutSeconds { get; public set; }
    public NetworkTargetCompressionType Compress { get; public set; }
    public int CompressMinBytes { get; public set; }
    internal INetworkSenderFactory SenderFactory { get; internal set; }
    public NetworkTarget(string name);
    [CompilerGeneratedAttribute]
public Layout get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(Layout value);
    [CompilerGeneratedAttribute]
public bool get_KeepConnection();
    [CompilerGeneratedAttribute]
public void set_KeepConnection(bool value);
    [CompilerGeneratedAttribute]
public bool get_NewLine();
    [CompilerGeneratedAttribute]
public void set_NewLine(bool value);
    public LineEndingMode get_LineEnding();
    public void set_LineEnding(LineEndingMode value);
    [CompilerGeneratedAttribute]
public int get_MaxMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaxMessageSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxConnections();
    [CompilerGeneratedAttribute]
public void set_MaxConnections(int value);
    [CompilerGeneratedAttribute]
public NetworkTargetConnectionsOverflowAction get_OnConnectionOverflow();
    [CompilerGeneratedAttribute]
public void set_OnConnectionOverflow(NetworkTargetConnectionsOverflowAction value);
    [CompilerGeneratedAttribute]
public int get_MaxQueueSize();
    [CompilerGeneratedAttribute]
public void set_MaxQueueSize(int value);
    [CompilerGeneratedAttribute]
public NetworkTargetQueueOverflowAction get_OnQueueOverflow();
    [CompilerGeneratedAttribute]
public void set_OnQueueOverflow(NetworkTargetQueueOverflowAction value);
    [CompilerGeneratedAttribute]
public void add_LogEventDropped(EventHandler`1<NetworkLogEventDroppedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LogEventDropped(EventHandler`1<NetworkLogEventDroppedEventArgs> value);
    [CompilerGeneratedAttribute]
public int get_ConnectionCacheSize();
    [CompilerGeneratedAttribute]
public void set_ConnectionCacheSize(int value);
    [CompilerGeneratedAttribute]
public NetworkTargetOverflowAction get_OnOverflow();
    [CompilerGeneratedAttribute]
public void set_OnOverflow(NetworkTargetOverflowAction value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public SslProtocols get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
public int get_KeepAliveTimeSeconds();
    [CompilerGeneratedAttribute]
public void set_KeepAliveTimeSeconds(int value);
    [CompilerGeneratedAttribute]
public int get_SendTimeoutSeconds();
    [CompilerGeneratedAttribute]
public void set_SendTimeoutSeconds(int value);
    [CompilerGeneratedAttribute]
public NetworkTargetCompressionType get_Compress();
    [CompilerGeneratedAttribute]
public void set_Compress(NetworkTargetCompressionType value);
    [CompilerGeneratedAttribute]
public int get_CompressMinBytes();
    [CompilerGeneratedAttribute]
public void set_CompressMinBytes(int value);
    [CompilerGeneratedAttribute]
internal INetworkSenderFactory get_SenderFactory();
    [CompilerGeneratedAttribute]
internal void set_SenderFactory(INetworkSenderFactory value);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void CloseTarget();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    private void WriteBytesToCachedNetworkSender(string address, Byte[] payload, AsyncLogEventInfo logEvent);
    private void WriteBytesToNewNetworkSender(string address, Byte[] payload, AsyncLogEventInfo logEvent);
    private void OnLogEventDropped(object sender, NetworkLogEventDroppedEventArgs logEventDroppedEventArgs);
    private static bool TryRemove(LinkedList`1<T> list, LinkedListNode`1<T> node);
    protected virtual Byte[] GetBytesToWrite(LogEventInfo logEvent);
    private Byte[] RenderBytesToWrite(LogEventInfo logEvent);
    private Byte[] GetBytesFromStringBuilder(Char[] charBuffer, StringBuilder stringBuilder);
    private Byte[] GetBytesFromString(Char[] charBuffer, string layoutMessage);
    private Byte[] CompressBytesToWrite(Byte[] payload);
    private LinkedListNode`1<NetworkSender> GetCachedNetworkSender(string address);
    private NetworkSender CreateNetworkSender(string address);
    private void ReleaseCachedConnection(LinkedListNode`1<NetworkSender> senderNode);
    private static void WriteBytesToNetworkSender(NetworkSender sender, Byte[] payload, AsyncContinuation continuation);
}
public enum NLog.Targets.NetworkTargetCompressionType : Enum {
    public int value__;
    public static NetworkTargetCompressionType None;
    public static NetworkTargetCompressionType GZip;
    public static NetworkTargetCompressionType GZipFast;
}
public enum NLog.Targets.NetworkTargetConnectionsOverflowAction : Enum {
    public int value__;
    public static NetworkTargetConnectionsOverflowAction Grow;
    [ObsoleteAttribute("Replaced by Grow. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static NetworkTargetConnectionsOverflowAction AllowNewConnnection;
    public static NetworkTargetConnectionsOverflowAction Discard;
    [ObsoleteAttribute("Replaced by Discard. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public static NetworkTargetConnectionsOverflowAction DiscardMessage;
    public static NetworkTargetConnectionsOverflowAction Block;
}
public enum NLog.Targets.NetworkTargetOverflowAction : Enum {
    public int value__;
    public static NetworkTargetOverflowAction Error;
    public static NetworkTargetOverflowAction Split;
    public static NetworkTargetOverflowAction Discard;
}
public enum NLog.Targets.NetworkTargetQueueOverflowAction : Enum {
    public int value__;
    public static NetworkTargetQueueOverflowAction Grow;
    public static NetworkTargetQueueOverflowAction Discard;
    public static NetworkTargetQueueOverflowAction Block;
}
[NLogConfigurationItemAttribute]
public class NLog.Targets.NLogViewerParameterInfo : object {
    private string _name;
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEmptyValue>k__BackingField;
    [RequiredParameterAttribute]
public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public bool IncludeEmptyValue { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEmptyValue();
    [CompilerGeneratedAttribute]
public void set_IncludeEmptyValue(bool value);
}
[TargetAttribute("NLogViewer")]
public class NLog.Targets.NLogViewerTarget : NetworkTarget {
    private Log4JXmlEventLayout _log4JLayout;
    public bool IncludeNLogData { get; public set; }
    public Layout LoggerName { get; public set; }
    public Layout FormattedMessage { get; public set; }
    public Layout AppInfo { get; public set; }
    public bool IncludeCallSite { get; public set; }
    public bool IncludeSourceInfo { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdc { get; public set; }
    public bool IncludeNdc { get; public set; }
    public bool IncludeEventProperties { get; public set; }
    public bool IncludeScopeProperties { get; public set; }
    public bool IncludeScopeNested { get; public set; }
    public string ScopeNestedSeparator { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeEventProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeAllProperties { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdlc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeNdc. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeNdlc { get; public set; }
    [ObsoleteAttribute("Replaced by NdcItemSeparator. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public string NdlcItemSeparator { get; public set; }
    public string NdcItemSeparator { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.NLogViewerParameterInfo", "parameter")]
public IList`1<NLogViewerParameterInfo> Parameters { get; }
    public Log4JXmlEventLayoutRenderer Renderer { get; }
    public Layout Layout { get; public set; }
    public NLogViewerTarget(string name);
    public bool get_IncludeNLogData();
    public void set_IncludeNLogData(bool value);
    public Layout get_LoggerName();
    public void set_LoggerName(Layout value);
    public Layout get_FormattedMessage();
    public void set_FormattedMessage(Layout value);
    public Layout get_AppInfo();
    public void set_AppInfo(Layout value);
    public bool get_IncludeCallSite();
    public void set_IncludeCallSite(bool value);
    public bool get_IncludeSourceInfo();
    public void set_IncludeSourceInfo(bool value);
    public bool get_IncludeMdc();
    public void set_IncludeMdc(bool value);
    public bool get_IncludeNdc();
    public void set_IncludeNdc(bool value);
    public sealed virtual bool get_IncludeEventProperties();
    public sealed virtual void set_IncludeEventProperties(bool value);
    public sealed virtual bool get_IncludeScopeProperties();
    public sealed virtual void set_IncludeScopeProperties(bool value);
    public sealed virtual bool get_IncludeScopeNested();
    public sealed virtual void set_IncludeScopeNested(bool value);
    public string get_ScopeNestedSeparator();
    public void set_ScopeNestedSeparator(string value);
    public bool get_IncludeAllProperties();
    public void set_IncludeAllProperties(bool value);
    public bool get_IncludeMdlc();
    public void set_IncludeMdlc(bool value);
    public bool get_IncludeNdlc();
    public void set_IncludeNdlc(bool value);
    public string get_NdlcItemSeparator();
    public void set_NdlcItemSeparator(string value);
    public string get_NdcItemSeparator();
    public void set_NdcItemSeparator(string value);
    public IList`1<NLogViewerParameterInfo> get_Parameters();
    public Log4JXmlEventLayoutRenderer get_Renderer();
    public virtual Layout get_Layout();
    public virtual void set_Layout(Layout value);
}
[TargetAttribute("Null")]
public class NLog.Targets.NullTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private bool <FormatMessage>k__BackingField;
    public bool FormatMessage { get; public set; }
    public NullTarget(string name);
    [CompilerGeneratedAttribute]
public bool get_FormatMessage();
    [CompilerGeneratedAttribute]
public void set_FormatMessage(bool value);
    protected virtual void Write(LogEventInfo logEvent);
}
public enum NLog.Targets.SmtpAuthenticationMode : Enum {
    public int value__;
    public static SmtpAuthenticationMode None;
    public static SmtpAuthenticationMode Basic;
    public static SmtpAuthenticationMode Ntlm;
}
[NLogConfigurationItemAttribute]
public abstract class NLog.Targets.Target : object {
    internal string _tostring;
    private Layout[] _allLayouts;
    private bool _allLayoutsAreThreadAgnostic;
    private bool _anyLayoutsAreThreadAgnosticImmutable;
    private bool _scannedForLayouts;
    private Exception _initializeException;
    [CompilerGeneratedAttribute]
private StackTraceUsage <StackTraceUsage>k__BackingField;
    private string _name;
    private Nullable`1<bool> _optimizeBufferReuse;
    internal Nullable`1<bool> _layoutWithLock;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <LoggingConfiguration>k__BackingField;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isInitialized;
    internal ReusableBuilderCreator ReusableLayoutBuilder;
    private StringBuilderPool _precalculateStringBuilderPool;
    internal StackTraceUsage StackTraceUsage { get; private set; }
    internal Exception InitializeException { get; }
    public string Name { get; public set; }
    [ObsoleteAttribute("No longer used, and always returns true. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool OptimizeBufferReuse { get; public set; }
    [ObsoleteAttribute("Temporary workaround for broken Layout Renderers that are not threadsafe. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool LayoutWithLock { get; public set; }
    protected object SyncRoot { get; }
    protected LoggingConfiguration LoggingConfiguration { get; private set; }
    private LogFactory NLog.Common.IInternalLoggerContext.LogFactory { get; }
    protected bool IsInitialized { get; }
    [CompilerGeneratedAttribute]
internal StackTraceUsage get_StackTraceUsage();
    [CompilerGeneratedAttribute]
private void set_StackTraceUsage(StackTraceUsage value);
    internal Exception get_InitializeException();
    public sealed virtual string get_Name();
    public void set_Name(string value);
    public bool get_OptimizeBufferReuse();
    public void set_OptimizeBufferReuse(bool value);
    public bool get_LayoutWithLock();
    public void set_LayoutWithLock(bool value);
    [CompilerGeneratedAttribute]
protected object get_SyncRoot();
    [CompilerGeneratedAttribute]
protected LoggingConfiguration get_LoggingConfiguration();
    [CompilerGeneratedAttribute]
private void set_LoggingConfiguration(LoggingConfiguration value);
    private sealed virtual override LogFactory NLog.Common.IInternalLoggerContext.get_LogFactory();
    protected bool get_IsInitialized();
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Initialize(LoggingConfiguration configuration);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Close();
    public sealed virtual void Dispose();
    public void Flush(AsyncContinuation asyncContinuation);
    public void PrecalculateVolatileLayouts(LogEventInfo logEvent);
    private void PrecalculateVolatileLayoutsConcurrent(LogEventInfo logEvent);
    private void PrecalculateVolatileLayoutsWithLock(LogEventInfo logEvent);
    public virtual string ToString();
    internal string GenerateTargetToString(bool targetWrapper, string targetName);
    public void WriteAsyncLogEvent(AsyncLogEventInfo logEvent);
    public void WriteAsyncLogEvents(AsyncLogEventInfo[] logEvents);
    public void WriteAsyncLogEvents(IList`1<AsyncLogEventInfo> logEvents);
    protected virtual void WriteFailedNotInitialized(AsyncLogEventInfo logEvent, Exception initializeException);
    internal void Initialize(LoggingConfiguration configuration);
    internal void Close();
    protected virtual void Dispose(bool disposing);
    protected virtual void InitializeTarget();
    private void FindAllLayouts();
    protected virtual void CloseTarget();
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void Write(LogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void WriteAsyncThreadSafe(AsyncLogEventInfo logEvent);
    protected virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    protected virtual void WriteAsyncThreadSafe(IList`1<AsyncLogEventInfo> logEvents);
    [ObsoleteAttribute("Logger.Trace(logEvent) now automatically captures the logEvent Properties. Marked obsolete on NLog 4.6")]
[EditorBrowsableAttribute("1")]
protected void MergeEventProperties(LogEventInfo logEvent);
    protected string RenderLogEvent(Layout layout, LogEventInfo logEvent);
    protected T RenderLogEvent(Layout`1<T> layout, LogEventInfo logEvent, T defaultValue);
    protected T ResolveService();
    internal bool ExceptionMustBeRethrown(Exception exception, string callerMemberName);
    private static bool TryGetCachedValue(Layout layout, LogEventInfo logEvent, Object& value);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(string name);
    [ObsoleteAttribute("Instead use LogManager.Setup().SetupExtensions(). Marked obsolete with NLog v5.2")]
[EditorBrowsableAttribute("1")]
public static void Register(string name, Type targetType);
}
[AttributeUsageAttribute("4")]
public class NLog.Targets.TargetAttribute : NameBaseAttribute {
    [CompilerGeneratedAttribute]
private bool <IsWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompound>k__BackingField;
    public bool IsWrapper { get; public set; }
    public bool IsCompound { get; public set; }
    public TargetAttribute(string name);
    [CompilerGeneratedAttribute]
public bool get_IsWrapper();
    [CompilerGeneratedAttribute]
public void set_IsWrapper(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCompound();
    [CompilerGeneratedAttribute]
public void set_IsCompound(bool value);
}
[NLogConfigurationItemAttribute]
public class NLog.Targets.TargetPropertyWithContext : object {
    private ValueTypeLayoutInfo _layoutInfo;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private bool _includeEmptyValue;
    [RequiredParameterAttribute]
public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public Type PropertyType { get; public set; }
    public Layout DefaultValue { get; public set; }
    public bool IncludeEmptyValue { get; public set; }
    public TargetPropertyWithContext(string name, Layout layout);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public Layout get_Layout();
    public void set_Layout(Layout value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    public Layout get_DefaultValue();
    public void set_DefaultValue(Layout value);
    public bool get_IncludeEmptyValue();
    public void set_IncludeEmptyValue(bool value);
    public object RenderValue(LogEventInfo logEvent);
}
public abstract class NLog.Targets.TargetWithContext : TargetWithLayout {
    private TargetWithContextLayout _contextLayout;
    [CompilerGeneratedAttribute]
private bool <IncludeGdc>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TargetPropertyWithContext> <ContextProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <ExcludeProperties>k__BackingField;
    public Layout Layout { get; public set; }
    public bool IncludeEventProperties { get; public set; }
    public bool IncludeScopeProperties { get; public set; }
    public bool IncludeScopeNested { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeNested. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeNdc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeMdlc { get; public set; }
    [ObsoleteAttribute("Replaced by IncludeScopeNested. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
public bool IncludeNdlc { get; public set; }
    public bool IncludeGdc { get; public set; }
    public bool IncludeCallSite { get; public set; }
    public bool IncludeCallSiteStackTrace { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.TargetPropertyWithContext", "contextproperty")]
public IList`1<TargetPropertyWithContext> ContextProperties { get; }
    public ISet`1<string> ExcludeProperties { get; public set; }
    public sealed virtual Layout get_Layout();
    public sealed virtual void set_Layout(Layout value);
    public sealed virtual bool get_IncludeEventProperties();
    public sealed virtual void set_IncludeEventProperties(bool value);
    public sealed virtual bool get_IncludeScopeProperties();
    public sealed virtual void set_IncludeScopeProperties(bool value);
    public sealed virtual bool get_IncludeScopeNested();
    public sealed virtual void set_IncludeScopeNested(bool value);
    public bool get_IncludeMdc();
    public void set_IncludeMdc(bool value);
    public bool get_IncludeNdc();
    public void set_IncludeNdc(bool value);
    public bool get_IncludeMdlc();
    public void set_IncludeMdlc(bool value);
    public bool get_IncludeNdlc();
    public void set_IncludeNdlc(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeGdc();
    [CompilerGeneratedAttribute]
public void set_IncludeGdc(bool value);
    public bool get_IncludeCallSite();
    public void set_IncludeCallSite(bool value);
    public bool get_IncludeCallSiteStackTrace();
    public void set_IncludeCallSiteStackTrace(bool value);
    [CompilerGeneratedAttribute]
public virtual IList`1<TargetPropertyWithContext> get_ContextProperties();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_ExcludeProperties();
    [CompilerGeneratedAttribute]
public void set_ExcludeProperties(ISet`1<string> value);
    protected bool ShouldIncludeProperties(LogEventInfo logEvent);
    protected IDictionary`2<string, object> GetContextProperties(LogEventInfo logEvent);
    protected IDictionary`2<string, object> GetContextProperties(LogEventInfo logEvent, IDictionary`2<string, object> combinedProperties);
    protected IDictionary`2<string, object> GetAllProperties(LogEventInfo logEvent);
    protected IDictionary`2<string, object> GetAllProperties(LogEventInfo logEvent, IDictionary`2<string, object> combinedProperties);
    private static IDictionary`2<string, object> CreateNewDictionary(int initialCapacity);
    protected virtual string GenerateUniqueItemName(LogEventInfo logEvent, string itemName, object itemValue, IDictionary`2<string, object> combinedProperties);
    private bool CombineProperties(LogEventInfo logEvent, Layout contextLayout, IDictionary`2& combinedProperties);
    private void AddContextProperty(LogEventInfo logEvent, string propertyName, object propertyValue, bool checkForDuplicates, IDictionary`2<string, object> combinedProperties);
    [ObsoleteAttribute("Replaced by GetScopeContextProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected IDictionary`2<string, object> GetContextMdc(LogEventInfo logEvent);
    protected IDictionary`2<string, object> GetScopeContextProperties(LogEventInfo logEvent);
    [ObsoleteAttribute("Replaced by GetScopeContextProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected IDictionary`2<string, object> GetContextMdlc(LogEventInfo logEvent);
    [ObsoleteAttribute("Replaced by GetScopeContextNested. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected IList`1<object> GetContextNdc(LogEventInfo logEvent);
    protected IList`1<object> GetScopeContextNested(LogEventInfo logEvent);
    [ObsoleteAttribute("Replaced by GetScopeContextNested. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected IList`1<object> GetContextNdlc(LogEventInfo logEvent);
    private IDictionary`2<string, object> CaptureContextProperties(LogEventInfo logEvent, IDictionary`2<string, object> combinedProperties);
    private static bool TryGetContextPropertyValue(LogEventInfo logEvent, TargetPropertyWithContext contextProperty, Object& propertyValue);
    protected virtual IDictionary`2<string, object> CaptureContextGdc(LogEventInfo logEvent, IDictionary`2<string, object> contextProperties);
    [ObsoleteAttribute("Replaced by CaptureScopeContextProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual IDictionary`2<string, object> CaptureContextMdc(LogEventInfo logEvent, IDictionary`2<string, object> contextProperties);
    [ObsoleteAttribute("Replaced by SerializeScopeContextProperty. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual bool SerializeMdcItem(LogEventInfo logEvent, string name, object value, Object& serializedValue);
    [ObsoleteAttribute("Replaced by CaptureScopeContextProperties. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual IDictionary`2<string, object> CaptureContextMdlc(LogEventInfo logEvent, IDictionary`2<string, object> contextProperties);
    protected virtual IDictionary`2<string, object> CaptureScopeContextProperties(LogEventInfo logEvent, IDictionary`2<string, object> contextProperties);
    [ObsoleteAttribute("Replaced by SerializeScopeContextProperty. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected bool SerializeMdlcItem(LogEventInfo logEvent, string name, object value, Object& serializedValue);
    protected virtual bool SerializeScopeContextProperty(LogEventInfo logEvent, string name, object value, Object& serializedValue);
    [ObsoleteAttribute("Replaced by CaptureScopeContextNested. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual IList`1<object> CaptureContextNdc(LogEventInfo logEvent);
    [ObsoleteAttribute("Replaced by SerializeScopeContextNestedState. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual bool SerializeNdcItem(LogEventInfo logEvent, object value, Object& serializedValue);
    [ObsoleteAttribute("Replaced by CaptureScopeContextNested. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual IList`1<object> CaptureContextNdlc(LogEventInfo logEvent);
    protected virtual IList`1<object> CaptureScopeContextNested(LogEventInfo logEvent);
    [ObsoleteAttribute("Replaced by SerializeScopeContextNestedState. Marked obsolete on NLog 5.0")]
[EditorBrowsableAttribute("1")]
protected virtual bool SerializeNdlcItem(LogEventInfo logEvent, object value, Object& serializedValue);
    protected virtual bool SerializeScopeContextNestedState(LogEventInfo logEvent, object value, Object& serializedValue);
    protected virtual bool SerializeItemValue(LogEventInfo logEvent, string name, object value, Object& serializedValue);
}
public abstract class NLog.Targets.TargetWithLayout : Target {
    private static string DefaultLayoutText;
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    private static LayoutRenderer[] DefaultLayout { get; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    private static LayoutRenderer[] get_DefaultLayout();
    [CompilerGeneratedAttribute]
public virtual Layout get_Layout();
    [CompilerGeneratedAttribute]
public virtual void set_Layout(Layout value);
}
public abstract class NLog.Targets.TargetWithLayoutHeaderAndFooter : TargetWithLayout {
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public Layout Footer { get; public set; }
    public Layout Header { get; public set; }
    private LayoutWithHeaderAndFooter LHF { get; private set; }
    public virtual Layout get_Layout();
    public virtual void set_Layout(Layout value);
    public Layout get_Footer();
    public void set_Footer(Layout value);
    public Layout get_Header();
    public void set_Header(Layout value);
    private LayoutWithHeaderAndFooter get_LHF();
    private void set_LHF(LayoutWithHeaderAndFooter value);
}
[TargetAttribute("Trace")]
[TargetAttribute("TraceSystem")]
public class NLog.Targets.TraceTarget : TargetWithLayoutHeaderAndFooter {
    [CompilerGeneratedAttribute]
private bool <RawWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTraceFail>k__BackingField;
    public bool RawWrite { get; public set; }
    public bool EnableTraceFail { get; public set; }
    public TraceTarget(string name);
    [CompilerGeneratedAttribute]
public bool get_RawWrite();
    [CompilerGeneratedAttribute]
public void set_RawWrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableTraceFail();
    [CompilerGeneratedAttribute]
public void set_EnableTraceFail(bool value);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
}
public enum NLog.Targets.WebServiceProtocol : Enum {
    public int value__;
    public static WebServiceProtocol Soap11;
    public static WebServiceProtocol Soap12;
    public static WebServiceProtocol HttpPost;
    public static WebServiceProtocol HttpGet;
    public static WebServiceProtocol JsonPost;
    public static WebServiceProtocol XmlPost;
}
public enum NLog.Targets.WebServiceProxyType : Enum {
    public int value__;
    public static WebServiceProxyType DefaultWebProxy;
    public static WebServiceProxyType AutoProxy;
    public static WebServiceProxyType NoProxy;
    public static WebServiceProxyType ProxyAddress;
}
[TargetAttribute("WebService")]
public class NLog.Targets.WebServiceTarget : MethodCallTargetBase {
    private static string SoapEnvelopeNamespaceUri;
    private static string Soap12EnvelopeNamespaceUri;
    private static Dictionary`2<WebServiceProtocol, Func`2<WebServiceTarget, HttpPostFormatterBase>> _postFormatterFactories;
    [CompilerGeneratedAttribute]
private Layout`1<Uri> <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    private KeyValuePair`2<WebServiceProtocol, HttpPostFormatterBase> _activeProtocol;
    private KeyValuePair`2<WebServiceProxyType, IWebProxy> _activeProxy;
    [CompilerGeneratedAttribute]
private Layout <ProxyAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeBOM>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeDataRfc3986>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeDataNLogLegacy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XmlRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XmlRootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MethodCallParameter> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreAuthenticate>k__BackingField;
    private AsyncOperationCounter _pendingManualFlushList;
    [RequiredParameterAttribute]
public Layout`1<Uri> Url { get; public set; }
    public Layout UserAgent { get; public set; }
    public string MethodName { get; public set; }
    public string Namespace { get; public set; }
    public WebServiceProtocol Protocol { get; public set; }
    public WebServiceProxyType ProxyType { get; public set; }
    public Layout ProxyAddress { get; public set; }
    public Nullable`1<bool> IncludeBOM { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool EscapeDataRfc3986 { get; public set; }
    [ObsoleteAttribute("Instead use default Rfc2396 or EscapeDataRfc3986. Marked obsolete with NLog v5.3")]
[EditorBrowsableAttribute("1")]
public bool EscapeDataNLogLegacy { get; public set; }
    public string XmlRoot { get; public set; }
    public string XmlRootNamespace { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.MethodCallParameter", "header")]
public IList`1<MethodCallParameter> Headers { get; }
    public bool PreAuthenticate { get; public set; }
    public WebServiceTarget(string name);
    private static WebServiceTarget();
    [CompilerGeneratedAttribute]
public Layout`1<Uri> get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(Layout`1<Uri> value);
    [CompilerGeneratedAttribute]
public Layout get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(Layout value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    public WebServiceProtocol get_Protocol();
    public void set_Protocol(WebServiceProtocol value);
    public WebServiceProxyType get_ProxyType();
    public void set_ProxyType(WebServiceProxyType value);
    [CompilerGeneratedAttribute]
public Layout get_ProxyAddress();
    [CompilerGeneratedAttribute]
public void set_ProxyAddress(Layout value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeBOM();
    [CompilerGeneratedAttribute]
public void set_IncludeBOM(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public bool get_EscapeDataRfc3986();
    [CompilerGeneratedAttribute]
public void set_EscapeDataRfc3986(bool value);
    [CompilerGeneratedAttribute]
public bool get_EscapeDataNLogLegacy();
    [CompilerGeneratedAttribute]
public void set_EscapeDataNLogLegacy(bool value);
    [CompilerGeneratedAttribute]
public string get_XmlRoot();
    [CompilerGeneratedAttribute]
public void set_XmlRoot(string value);
    [CompilerGeneratedAttribute]
public string get_XmlRootNamespace();
    [CompilerGeneratedAttribute]
public void set_XmlRootNamespace(string value);
    [CompilerGeneratedAttribute]
public IList`1<MethodCallParameter> get_Headers();
    [CompilerGeneratedAttribute]
public bool get_PreAuthenticate();
    [CompilerGeneratedAttribute]
public void set_PreAuthenticate(bool value);
    protected virtual void DoInvoke(Object[] parameters);
    protected virtual void DoInvoke(Object[] parameters, AsyncContinuation continuation);
    protected virtual void DoInvoke(Object[] parameters, AsyncLogEventInfo logEvent);
    private HttpWebRequest CreateHttpWebRequest(Uri url);
    private void DoInvoke(Object[] parameters, HttpWebRequest webRequest, AsyncContinuation continuation);
    internal void DoInvoke(Object[] parameters, AsyncContinuation continuation, HttpWebRequest webRequest, Func`3<HttpWebRequest, AsyncCallback, IAsyncResult> beginGetRequest, Func`3<HttpWebRequest, IAsyncResult, Stream> getRequestStream);
    private void WaitForReponse(AsyncContinuation continuation, HttpWebRequest webRequest);
    private void PostPayload(AsyncContinuation continuation, HttpWebRequest webRequest, Func`3<HttpWebRequest, AsyncCallback, IAsyncResult> beginGetRequest, Func`3<HttpWebRequest, IAsyncResult, Stream> getRequestStream, MemoryStream postPayload);
    private void DoInvokeCompleted(AsyncContinuation continuation, Exception ex);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void CloseTarget();
    private Uri BuildWebServiceUrl(LogEventInfo logEvent, Object[] parameterValues);
    private void BuildWebServiceQueryParameters(Object[] parameterValues, StringBuilder sb, EscapeEncodingOptions encodingOptions);
    private static void WriteStreamAndFixPreamble(MemoryStream postPayload, Stream output, Nullable`1<bool> writeUtf8BOM, Encoding encoding);
}
[FlagsAttribute]
public enum NLog.Targets.Win32FileAttributes : Enum {
    public int value__;
    public static Win32FileAttributes ReadOnly;
    public static Win32FileAttributes Hidden;
    public static Win32FileAttributes System;
    public static Win32FileAttributes Archive;
    public static Win32FileAttributes Device;
    public static Win32FileAttributes Normal;
    public static Win32FileAttributes Temporary;
    public static Win32FileAttributes SparseFile;
    public static Win32FileAttributes ReparsePoint;
    public static Win32FileAttributes Compressed;
    public static Win32FileAttributes NotContentIndexed;
    public static Win32FileAttributes Encrypted;
    public static Win32FileAttributes WriteThrough;
    public static Win32FileAttributes NoBuffering;
    public static Win32FileAttributes DeleteOnClose;
    public static Win32FileAttributes PosixSemantics;
}
internal class NLog.Targets.Wrappers.AsyncRequestQueue : AsyncRequestQueueBase {
    private Queue`1<AsyncLogEventInfo> _logEventInfoQueue;
    public int RequestCount { get; }
    public bool IsEmpty { get; }
    public AsyncRequestQueue(int requestLimit, AsyncTargetWrapperOverflowAction overflowAction);
    public int get_RequestCount();
    public virtual bool get_IsEmpty();
    public virtual bool Enqueue(AsyncLogEventInfo logEventInfo);
    public virtual AsyncLogEventInfo[] DequeueBatch(int count);
    public virtual void DequeueBatch(int count, IList`1<AsyncLogEventInfo> result);
    public virtual void Clear();
}
internal abstract class NLog.Targets.Wrappers.AsyncRequestQueueBase : object {
    [CompilerGeneratedAttribute]
private int <RequestLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncTargetWrapperOverflowAction <OnOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<LogEventDroppedEventArgs> LogEventDropped;
    [CompilerGeneratedAttribute]
private EventHandler`1<LogEventQueueGrowEventArgs> LogEventQueueGrow;
    public bool IsEmpty { get; }
    public int RequestLimit { get; public set; }
    public AsyncTargetWrapperOverflowAction OnOverflow { get; public set; }
    public abstract virtual bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public int get_RequestLimit();
    [CompilerGeneratedAttribute]
public void set_RequestLimit(int value);
    [CompilerGeneratedAttribute]
public AsyncTargetWrapperOverflowAction get_OnOverflow();
    [CompilerGeneratedAttribute]
public void set_OnOverflow(AsyncTargetWrapperOverflowAction value);
    [CompilerGeneratedAttribute]
public void add_LogEventDropped(EventHandler`1<LogEventDroppedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LogEventDropped(EventHandler`1<LogEventDroppedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LogEventQueueGrow(EventHandler`1<LogEventQueueGrowEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LogEventQueueGrow(EventHandler`1<LogEventQueueGrowEventArgs> value);
    public abstract virtual bool Enqueue(AsyncLogEventInfo logEventInfo);
    public abstract virtual AsyncLogEventInfo[] DequeueBatch(int count);
    public abstract virtual void DequeueBatch(int count, IList`1<AsyncLogEventInfo> result);
    public abstract virtual void Clear();
    protected void OnLogEventDropped(LogEventInfo logEventInfo);
    protected void OnLogEventQueueGrows(long requestsCount);
}
[TargetAttribute("AsyncWrapper")]
public class NLog.Targets.Wrappers.AsyncTargetWrapper : WrapperTargetBase {
    private object _writeLockObject;
    private object _timerLockObject;
    private Timer _lazyWriterTimer;
    private ReusableAsyncLogEventList _reusableAsyncLogEventList;
    [CompilerGeneratedAttribute]
private EventHandler`1<LogEventDroppedEventArgs> _logEventDroppedEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<LogEventQueueGrowEventArgs> _eventQueueGrowEvent;
    private bool _missingServiceTypes;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeToSleepBetweenBatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FullBatchSizeWriteLimit>k__BackingField;
    private Nullable`1<bool> _forceLockingQueue;
    private AsyncRequestQueueBase _requestQueue;
    private Nullable`1<AsyncHelpersTask> _flushEventsInQueueDelegate;
    public int BatchSize { get; public set; }
    public int TimeToSleepBetweenBatches { get; public set; }
    public AsyncTargetWrapperOverflowAction OverflowAction { get; public set; }
    public int QueueLimit { get; public set; }
    public int FullBatchSizeWriteLimit { get; public set; }
    public bool ForceLockingQueue { get; public set; }
    public AsyncTargetWrapper(string name, Target wrappedTarget);
    public AsyncTargetWrapper(Target wrappedTarget);
    public AsyncTargetWrapper(Target wrappedTarget, int queueLimit, AsyncTargetWrapperOverflowAction overflowAction);
    [CompilerGeneratedAttribute]
private void add__logEventDroppedEvent(EventHandler`1<LogEventDroppedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__logEventDroppedEvent(EventHandler`1<LogEventDroppedEventArgs> value);
    [CompilerGeneratedAttribute]
private void add__eventQueueGrowEvent(EventHandler`1<LogEventQueueGrowEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__eventQueueGrowEvent(EventHandler`1<LogEventQueueGrowEventArgs> value);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public int get_TimeToSleepBetweenBatches();
    [CompilerGeneratedAttribute]
public void set_TimeToSleepBetweenBatches(int value);
    public void add_LogEventDropped(EventHandler`1<LogEventDroppedEventArgs> value);
    public void remove_LogEventDropped(EventHandler`1<LogEventDroppedEventArgs> value);
    public void add_EventQueueGrow(EventHandler`1<LogEventQueueGrowEventArgs> value);
    public void remove_EventQueueGrow(EventHandler`1<LogEventQueueGrowEventArgs> value);
    public AsyncTargetWrapperOverflowAction get_OverflowAction();
    public void set_OverflowAction(AsyncTargetWrapperOverflowAction value);
    public int get_QueueLimit();
    public void set_QueueLimit(int value);
    [CompilerGeneratedAttribute]
public int get_FullBatchSizeWriteLimit();
    [CompilerGeneratedAttribute]
public void set_FullBatchSizeWriteLimit(int value);
    public bool get_ForceLockingQueue();
    public void set_ForceLockingQueue(bool value);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void StartLazyWriterTimer();
    protected virtual bool StartInstantWriterTimer();
    private void StartTimerUnlessWriterActive(bool instant);
    private bool StartLazyWriterThread(bool instant);
    protected virtual void StopLazyWriterThread();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void WriteAsyncThreadSafe(AsyncLogEventInfo logEvent);
    private void ProcessPendingEvents(object state);
    private void FlushEventsInQueue(object state);
    private int WriteLogEventsInQueue(int batchSize, string reason);
    private int WriteLogEventsToTarget(IList`1<AsyncLogEventInfo> logEvents, string reason);
    private void OnRequestQueueDropItem(object sender, LogEventDroppedEventArgs logEventDroppedEventArgs);
    private void OnRequestQueueGrow(object sender, LogEventQueueGrowEventArgs logEventQueueGrowEventArgs);
}
public enum NLog.Targets.Wrappers.AsyncTargetWrapperOverflowAction : Enum {
    public int value__;
    public static AsyncTargetWrapperOverflowAction Grow;
    public static AsyncTargetWrapperOverflowAction Discard;
    public static AsyncTargetWrapperOverflowAction Block;
}
[TargetAttribute("AutoFlushWrapper")]
public class NLog.Targets.Wrappers.AutoFlushTargetWrapper : WrapperTargetBase {
    [CompilerGeneratedAttribute]
private ConditionExpression <Condition>k__BackingField;
    private Nullable`1<bool> _asyncFlush;
    [CompilerGeneratedAttribute]
private bool <FlushOnConditionOnly>k__BackingField;
    private AsyncOperationCounter _pendingManualFlushList;
    private AsyncContinuation _flushCompletedContinuation;
    public ConditionExpression Condition { get; public set; }
    public bool AsyncFlush { get; public set; }
    public bool FlushOnConditionOnly { get; public set; }
    public AutoFlushTargetWrapper(string name, Target wrappedTarget);
    public AutoFlushTargetWrapper(Target wrappedTarget);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(ConditionExpression value);
    public bool get_AsyncFlush();
    public void set_AsyncFlush(bool value);
    [CompilerGeneratedAttribute]
public bool get_FlushOnConditionOnly();
    [CompilerGeneratedAttribute]
public void set_FlushOnConditionOnly(bool value);
    protected virtual void InitializeTarget();
    private static bool TargetSupportsAsyncFlush(Target wrappedTarget);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    private void FlushWrappedTarget(AsyncContinuation asyncContinuation);
    protected virtual void CloseTarget();
    [CompilerGeneratedAttribute]
private void <.ctor>b__16_0(Exception ex);
}
[TargetAttribute("BufferingWrapper")]
public class NLog.Targets.Wrappers.BufferingTargetWrapper : WrapperTargetBase {
    private AsyncRequestQueue _buffer;
    private Timer _flushTimer;
    private object _lockObject;
    [CompilerGeneratedAttribute]
private Layout`1<int> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<int> <FlushTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SlidingTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferingTargetWrapperOverflowAction <OverflowAction>k__BackingField;
    public Layout`1<int> BufferSize { get; public set; }
    public Layout`1<int> FlushTimeout { get; public set; }
    public bool SlidingTimeout { get; public set; }
    public BufferingTargetWrapperOverflowAction OverflowAction { get; public set; }
    public BufferingTargetWrapper(string name, Target wrappedTarget);
    public BufferingTargetWrapper(Target wrappedTarget);
    public BufferingTargetWrapper(Target wrappedTarget, int bufferSize);
    public BufferingTargetWrapper(Target wrappedTarget, int bufferSize, int flushTimeout);
    public BufferingTargetWrapper(Target wrappedTarget, int bufferSize, int flushTimeout, BufferingTargetWrapperOverflowAction overflowAction);
    [CompilerGeneratedAttribute]
public Layout`1<int> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Layout`1<int> value);
    [CompilerGeneratedAttribute]
public Layout`1<int> get_FlushTimeout();
    [CompilerGeneratedAttribute]
public void set_FlushTimeout(Layout`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_SlidingTimeout();
    [CompilerGeneratedAttribute]
public void set_SlidingTimeout(bool value);
    [CompilerGeneratedAttribute]
public BufferingTargetWrapperOverflowAction get_OverflowAction();
    [CompilerGeneratedAttribute]
public void set_OverflowAction(BufferingTargetWrapperOverflowAction value);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    private void FlushCallback(object state);
    private void WriteEventsInBuffer(string reason);
}
public enum NLog.Targets.Wrappers.BufferingTargetWrapperOverflowAction : Enum {
    public int value__;
    public static BufferingTargetWrapperOverflowAction Flush;
    public static BufferingTargetWrapperOverflowAction Discard;
}
public abstract class NLog.Targets.Wrappers.CompoundTargetBase : Target {
    [CompilerGeneratedAttribute]
private IList`1<Target> <Targets>k__BackingField;
    public IList`1<Target> Targets { get; }
    protected CompoundTargetBase(Target[] targets);
    [CompilerGeneratedAttribute]
public IList`1<Target> get_Targets();
    public virtual string ToString();
    private string GenerateTargetToString();
    protected virtual void Write(LogEventInfo logEvent);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
}
internal class NLog.Targets.Wrappers.ConcurrentRequestQueue : AsyncRequestQueueBase {
    private ConcurrentQueue`1<AsyncLogEventInfo> _logEventInfoQueue;
    private long _count;
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentRequestQueue(int requestLimit, AsyncTargetWrapperOverflowAction overflowAction);
    public virtual bool get_IsEmpty();
    public int get_Count();
    public virtual bool Enqueue(AsyncLogEventInfo logEventInfo);
    private bool DequeueUntilBelowRequestLimit();
    private bool WaitForBelowRequestLimit();
    private long TrySpinWaitForLowerCount();
    public virtual AsyncLogEventInfo[] DequeueBatch(int count);
    public virtual void DequeueBatch(int count, IList`1<AsyncLogEventInfo> result);
    public virtual void Clear();
}
[TargetAttribute("FallbackGroup")]
public class NLog.Targets.Wrappers.FallbackGroupTarget : CompoundTargetBase {
    private long _currentTarget;
    [CompilerGeneratedAttribute]
private bool <ReturnToFirstOnSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableBatchWrite>k__BackingField;
    public bool ReturnToFirstOnSuccess { get; public set; }
    public bool EnableBatchWrite { get; public set; }
    public FallbackGroupTarget(string name, Target[] targets);
    public FallbackGroupTarget(Target[] targets);
    [CompilerGeneratedAttribute]
public bool get_ReturnToFirstOnSuccess();
    [CompilerGeneratedAttribute]
public void set_ReturnToFirstOnSuccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableBatchWrite();
    [CompilerGeneratedAttribute]
public void set_EnableBatchWrite(bool value);
    protected virtual void WriteAsyncThreadSafe(IList`1<AsyncLogEventInfo> logEvents);
    protected virtual void WriteAsyncThreadSafe(AsyncLogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    private AsyncLogEventInfo WrapWithFallback(AsyncLogEventInfo logEvent, int targetToInvoke);
}
[NLogConfigurationItemAttribute]
public class NLog.Targets.Wrappers.FilteringRule : object {
    [CompilerGeneratedAttribute]
private ConditionExpression <Exists>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <Filter>k__BackingField;
    [RequiredParameterAttribute]
public ConditionExpression Exists { get; public set; }
    [RequiredParameterAttribute]
public ConditionExpression Filter { get; public set; }
    public FilteringRule(ConditionExpression whenExistsExpression, ConditionExpression filterToApply);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Exists();
    [CompilerGeneratedAttribute]
public void set_Exists(ConditionExpression value);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(ConditionExpression value);
}
[TargetAttribute("FilteringWrapper")]
public class NLog.Targets.Wrappers.FilteringTargetWrapper : WrapperTargetBase {
    [CompilerGeneratedAttribute]
private Filter <Filter>k__BackingField;
    public ConditionExpression Condition { get; public set; }
    [RequiredParameterAttribute]
public Filter Filter { get; public set; }
    public FilteringTargetWrapper(string name, Target wrappedTarget, ConditionExpression condition);
    public FilteringTargetWrapper(Target wrappedTarget, ConditionExpression condition);
    public ConditionExpression get_Condition();
    public void set_Condition(ConditionExpression value);
    [CompilerGeneratedAttribute]
public Filter get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(Filter value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    private static bool ShouldLogEvent(AsyncLogEventInfo logEvent, Filter filter);
    private static ConditionBasedFilter CreateFilter(ConditionExpression value);
}
[TargetAttribute("GroupByWrapper")]
public class NLog.Targets.Wrappers.GroupByTargetWrapper : WrapperTargetBase {
    private KeySelector`2<AsyncLogEventInfo, string> _buildKeyStringDelegate;
    [CompilerGeneratedAttribute]
private Layout <Key>k__BackingField;
    [RequiredParameterAttribute]
public Layout Key { get; public set; }
    public GroupByTargetWrapper(Target wrappedTarget);
    public GroupByTargetWrapper(string name, Target wrappedTarget);
    public GroupByTargetWrapper(string name, Target wrappedTarget, Layout key);
    [CompilerGeneratedAttribute]
public Layout get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Layout value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    [CompilerGeneratedAttribute]
private string <Write>b__10_0(AsyncLogEventInfo logEvent);
}
[TargetAttribute("LimitingWrapper")]
public class NLog.Targets.Wrappers.LimitingTargetWrapper : WrapperTargetBase {
    private DateTime _firstWriteInInterval;
    [CompilerGeneratedAttribute]
private Layout`1<int> <MessageLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<TimeSpan> <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MessagesWrittenCount>k__BackingField;
    public Layout`1<int> MessageLimit { get; public set; }
    public Layout`1<TimeSpan> Interval { get; public set; }
    public int MessagesWrittenCount { get; private set; }
    public LimitingTargetWrapper(string name, Target wrappedTarget);
    public LimitingTargetWrapper(Target wrappedTarget);
    public LimitingTargetWrapper(Target wrappedTarget, int messageLimit, TimeSpan interval);
    [CompilerGeneratedAttribute]
public Layout`1<int> get_MessageLimit();
    [CompilerGeneratedAttribute]
public void set_MessageLimit(Layout`1<int> value);
    [CompilerGeneratedAttribute]
public Layout`1<TimeSpan> get_Interval();
    [CompilerGeneratedAttribute]
public void set_Interval(Layout`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public int get_MessagesWrittenCount();
    [CompilerGeneratedAttribute]
private void set_MessagesWrittenCount(int value);
    protected virtual void InitializeTarget();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    private void ResetInterval(DateTime timestamp);
}
public class NLog.Targets.Wrappers.LogEventDroppedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private LogEventInfo <DroppedLogEventInfo>k__BackingField;
    public LogEventInfo DroppedLogEventInfo { get; }
    public LogEventDroppedEventArgs(LogEventInfo logEventInfo);
    [CompilerGeneratedAttribute]
public LogEventInfo get_DroppedLogEventInfo();
}
public class NLog.Targets.Wrappers.LogEventQueueGrowEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private long <NewQueueSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RequestsCount>k__BackingField;
    public long NewQueueSize { get; }
    public long RequestsCount { get; }
    public LogEventQueueGrowEventArgs(long newQueueSize, long requestsCount);
    [CompilerGeneratedAttribute]
public long get_NewQueueSize();
    [CompilerGeneratedAttribute]
public long get_RequestsCount();
}
[TargetAttribute("PostFilteringWrapper")]
public class NLog.Targets.Wrappers.PostFilteringTargetWrapper : WrapperTargetBase {
    [CompilerGeneratedAttribute]
private ConditionExpression <DefaultFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FilteringRule> <Rules>k__BackingField;
    public ConditionExpression DefaultFilter { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.Wrappers.FilteringRule", "when")]
public IList`1<FilteringRule> Rules { get; }
    public PostFilteringTargetWrapper(Target wrappedTarget);
    public PostFilteringTargetWrapper(string name, Target wrappedTarget);
    [CompilerGeneratedAttribute]
public ConditionExpression get_DefaultFilter();
    [CompilerGeneratedAttribute]
public void set_DefaultFilter(ConditionExpression value);
    [CompilerGeneratedAttribute]
public IList`1<FilteringRule> get_Rules();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    private static bool ShouldLogEvent(AsyncLogEventInfo logEvent, ConditionExpression resultFilter);
    private ConditionExpression EvaluateAllRules(IList`1<AsyncLogEventInfo> logEvents);
}
[TargetAttribute("RandomizeGroup")]
public class NLog.Targets.Wrappers.RandomizeGroupTarget : CompoundTargetBase {
    private Random _random;
    public RandomizeGroupTarget(string name, Target[] targets);
    public RandomizeGroupTarget(Target[] targets);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[TargetAttribute("RepeatingWrapper")]
public class NLog.Targets.Wrappers.RepeatingTargetWrapper : WrapperTargetBase {
    [CompilerGeneratedAttribute]
private int <RepeatCount>k__BackingField;
    public int RepeatCount { get; public set; }
    public RepeatingTargetWrapper(string name, Target wrappedTarget, int repeatCount);
    public RepeatingTargetWrapper(Target wrappedTarget, int repeatCount);
    [CompilerGeneratedAttribute]
public int get_RepeatCount();
    [CompilerGeneratedAttribute]
public void set_RepeatCount(int value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[TargetAttribute("RetryingWrapper")]
public class NLog.Targets.Wrappers.RetryingTargetWrapper : WrapperTargetBase {
    [CompilerGeneratedAttribute]
private Layout`1<int> <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout`1<int> <RetryDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableBatchWrite>k__BackingField;
    private object _retrySyncObject;
    public Layout`1<int> RetryCount { get; public set; }
    public Layout`1<int> RetryDelayMilliseconds { get; public set; }
    public bool EnableBatchWrite { get; public set; }
    public RetryingTargetWrapper(string name, Target wrappedTarget, int retryCount, int retryDelayMilliseconds);
    public RetryingTargetWrapper(Target wrappedTarget, int retryCount, int retryDelayMilliseconds);
    [CompilerGeneratedAttribute]
public Layout`1<int> get_RetryCount();
    [CompilerGeneratedAttribute]
public void set_RetryCount(Layout`1<int> value);
    [CompilerGeneratedAttribute]
public Layout`1<int> get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(Layout`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_EnableBatchWrite();
    [CompilerGeneratedAttribute]
public void set_EnableBatchWrite(bool value);
    protected virtual void WriteAsyncThreadSafe(IList`1<AsyncLogEventInfo> logEvents);
    protected virtual void WriteAsyncThreadSafe(AsyncLogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    private AsyncLogEventInfo WrapWithRetry(AsyncLogEventInfo logEvent, Func`2<int, bool> sleepBeforeRetry);
}
[TargetAttribute("RoundRobinGroup")]
public class NLog.Targets.Wrappers.RoundRobinGroupTarget : CompoundTargetBase {
    private int _currentTarget;
    public RoundRobinGroupTarget(string name, Target[] targets);
    public RoundRobinGroupTarget(Target[] targets);
    protected virtual void WriteAsyncThreadSafe(AsyncLogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[TargetAttribute("SplitGroup")]
public class NLog.Targets.Wrappers.SplitGroupTarget : CompoundTargetBase {
    public SplitGroupTarget(string name, Target[] targets);
    public SplitGroupTarget(Target[] targets);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(IList`1<AsyncLogEventInfo> logEvents);
    private static AsyncContinuation CreateCountedContinuation(AsyncContinuation originalContinuation, int targetCounter);
}
public abstract class NLog.Targets.Wrappers.WrapperTargetBase : Target {
    private Target _wrappedTarget;
    [RequiredParameterAttribute]
public Target WrappedTarget { get; public set; }
    public Target get_WrappedTarget();
    public void set_WrappedTarget(Target value);
    public virtual string ToString();
    private string GenerateTargetToString();
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected sealed virtual void Write(LogEventInfo logEvent);
}
internal class NLog.Targets.ZipArchiveFileCompressor : object {
    public sealed virtual void CompressFile(string fileName, string archiveFileName);
    public sealed virtual void CompressFile(string fileName, string archiveFileName, string entryName);
}
[TimeSourceAttribute("AccurateLocal")]
public class NLog.Time.AccurateLocalTimeSource : TimeSource {
    public DateTime Time { get; }
    public virtual DateTime get_Time();
    public virtual DateTime FromSystemTime(DateTime systemTime);
}
[TimeSourceAttribute("AccurateUTC")]
public class NLog.Time.AccurateUtcTimeSource : TimeSource {
    public DateTime Time { get; }
    public virtual DateTime get_Time();
    public virtual DateTime FromSystemTime(DateTime systemTime);
}
public abstract class NLog.Time.CachedTimeSource : TimeSource {
    private int _lastTicks;
    private DateTime _lastTime;
    protected DateTime FreshTime { get; }
    public DateTime Time { get; }
    protected abstract virtual DateTime get_FreshTime();
    public virtual DateTime get_Time();
    private DateTime RetrieveFreshTime(int tickCount);
}
[TimeSourceAttribute("FastLocal")]
public class NLog.Time.FastLocalTimeSource : CachedTimeSource {
    protected DateTime FreshTime { get; }
    protected virtual DateTime get_FreshTime();
    public virtual DateTime FromSystemTime(DateTime systemTime);
}
[TimeSourceAttribute("FastUTC")]
public class NLog.Time.FastUtcTimeSource : CachedTimeSource {
    protected DateTime FreshTime { get; }
    protected virtual DateTime get_FreshTime();
    public virtual DateTime FromSystemTime(DateTime systemTime);
}
[NLogConfigurationItemAttribute]
public abstract class NLog.Time.TimeSource : object {
    [CompilerGeneratedAttribute]
private static TimeSource <Current>k__BackingField;
    public DateTime Time { get; }
    public static TimeSource Current { get; public set; }
    private static TimeSource();
    public abstract virtual DateTime get_Time();
    [CompilerGeneratedAttribute]
public static TimeSource get_Current();
    [CompilerGeneratedAttribute]
public static void set_Current(TimeSource value);
    public virtual string ToString();
    public abstract virtual DateTime FromSystemTime(DateTime systemTime);
}
[AttributeUsageAttribute("4")]
public class NLog.Time.TimeSourceAttribute : NameBaseAttribute {
    public TimeSourceAttribute(string name);
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Param>k__BackingField;
    public string Param { get; }
    public CallerArgumentExpressionAttribute(string param);
    [CompilerGeneratedAttribute]
public string get_Param();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
