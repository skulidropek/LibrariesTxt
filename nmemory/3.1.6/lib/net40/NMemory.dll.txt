[ExtensionAttribute]
internal static class NMemory.Common.CollectionExtensions : object {
    [ExtensionAttribute]
public static IList`1<T> AsReadOnly(IList`1<T> collection);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToEnumerable(IEnumerator`1<T> input);
}
internal static class NMemory.Common.DatabaseMembers : object {
    public static PropertyInfo Database_Tables { get; }
    public static MethodInfo TableCollection_FindTable { get; }
    public static MethodInfo TableCollectionExtensions_FindTable { get; }
    public static MethodInfo TableExtensions_SelectAll { get; }
    public static PropertyInfo ExecutionContext_Database { get; }
    public static MethodInfo ExecutionContext_GetParameter { get; }
    public static PropertyInfo get_Database_Tables();
    public static MethodInfo get_TableCollection_FindTable();
    public static MethodInfo get_TableCollectionExtensions_FindTable();
    public static MethodInfo get_TableExtensions_SelectAll();
    public static PropertyInfo get_ExecutionContext_Database();
    public static MethodInfo get_ExecutionContext_GetParameter();
}
internal static class NMemory.Common.DatabaseReflectionHelper : object {
    public static bool IsTable(Type table);
    public static Type GetTableEntityType(Type table);
}
public class NMemory.Common.DefaultEntityMemberInfo`2 : object {
    private MemberInfo memberInfo;
    private IEntityMemberInfoServices`2<TEntity, TMember> services;
    public Type EntityType { get; }
    public Type MemberType { get; }
    public MemberInfo Member { get; }
    public IEntityMemberInfoServices`2<TEntity, TMember> EntityMemberInfoServices { get; }
    public DefaultEntityMemberInfo`2(MemberInfo member);
    public DefaultEntityMemberInfo`2(Expression`1<Func`2<TEntity, TMember>> memberSelector);
    public sealed virtual Type get_EntityType();
    public sealed virtual Type get_MemberType();
    public sealed virtual MemberInfo get_Member();
    public sealed virtual IEntityMemberInfoServices`2<TEntity, TMember> get_EntityMemberInfoServices();
    public void InitializeEntityMemberInfoServices();
}
public class NMemory.Common.DefaultEntityMemberInfoServices`2 : object {
    private Func`2<TEntity, TMember> getter;
    private Action`2<TEntity, TMember> setter;
    public DefaultEntityMemberInfoServices`2(IEntityMemberInfo memberInfo);
    private static Expression`1<Action`2<TEntity, TMember>> CreateSetter(IEntityMemberInfo memberInfo);
    private static Expression`1<Func`2<TEntity, TMember>> CreateGetter(IEntityMemberInfo memberInfo);
    public sealed virtual TMember GetValue(TEntity entity);
    public sealed virtual void SetValue(TEntity entity, TMember value);
}
internal static class NMemory.Common.DynamicMethodBuilder : object {
    public static Action`2<TObject, TValue> CreateSinglePropertySetter(PropertyInfo member);
    public static DynamicPropertySetter`1<TObject> CreatePropertySetter(PropertyInfo[] members);
    public static MethodInfo CreatePropertySetterMethodInfo(PropertyInfo[] members);
    private static DynamicMethod CreatePropertySetterImpl(PropertyInfo[] members);
}
internal class NMemory.Common.DynamicPropertySetter`1 : MulticastDelegate {
    public DynamicPropertySetter`1(object object, IntPtr method);
    public virtual TObject Invoke(TObject obj, Object[] args);
    public virtual IAsyncResult BeginInvoke(TObject obj, Object[] args, AsyncCallback callback, object object);
    public virtual TObject EndInvoke(IAsyncResult result);
}
internal static class NMemory.Common.ExpressionHelper : object {
    public static MemberExpression FindMemberExpression(Expression expression);
    public static Expression`1<Func`2<TEntity, TEntity>> ValidateAndCompleteUpdaterExpression(Expression`1<Func`2<TEntity, TEntity>> updater);
    public static IParameter FindParameter(UnaryExpression node);
    public static Expression SkipQuoteNode(Expression expression);
    public static Expression SkipConversionNodes(Expression expression);
    private static void ConvertExpression(Expression& to, Expression& expr);
    public static void TryUnifyValueTypes(Expression& left, Expression& right);
    public static LambdaExpression CreateMemberSelectorLambdaExpression(Expression[] members, ParameterExpression[] parameters);
}
public interface NMemory.Common.Expressions.IExpressionBuilder {
    public abstract virtual Expression Build(Expression source);
}
internal class NMemory.Common.Expressions.UnaryExpressionCloner : object {
    private Expression root;
    private Expression unary;
    private UnaryExpressionCloner(Expression original, Expression root);
    public static bool TryCreate(Expression unary, Expression root, UnaryExpressionCloner& result);
    public sealed virtual Expression Build(Expression source);
    private static bool TryGetNextStep(Expression current, Expression& next);
    private static bool IsValidDefaultNode(Expression node);
}
public interface NMemory.Common.IEntityMemberInfo {
    public Type EntityType { get; }
    public Type MemberType { get; }
    public MemberInfo Member { get; }
    public abstract virtual Type get_EntityType();
    public abstract virtual Type get_MemberType();
    public abstract virtual MemberInfo get_Member();
}
public interface NMemory.Common.IEntityMemberInfo`1 {
}
public interface NMemory.Common.IEntityMemberInfo`2 {
}
public interface NMemory.Common.IEntityMemberInfoServices`2 {
    public abstract virtual TMember GetValue(TEntity entity);
    public abstract virtual void SetValue(TEntity entity, TMember value);
}
internal interface NMemory.Common.IEntityMemberInfoServicesProvider`2 {
    public IEntityMemberInfoServices`2<TEntity, TMember> EntityMemberInfoServices { get; }
    public abstract virtual IEntityMemberInfoServices`2<TEntity, TMember> get_EntityMemberInfoServices();
}
internal static class NMemory.Common.KeyExpressionHelper : object {
    public static Expression`1<Func`2<TKey, bool>> CreateKeyEmptinessDetector(IKeyInfoHelper helper);
    public static Expression`1<Func`2<TEntity, TKey>> CreateKeySelector(MemberInfo[] entityMembers, IKeyInfoHelper helper);
    public static Expression CreateKeySelector(Expression source, MemberInfo[] entityMembers, IKeyInfoHelper helper);
    public static Expression CreateKeyEmptinessDetector(Expression source, IKeyInfoHelper helper);
    public static bool TryGetMemberMapping(MemberInfo[] left, MemberInfo[] right, Int32[]& mapping);
    public static Expression CreateKeyConversionExpression(Expression source, MemberInfo[] toMembers, Int32[] mapping, IKeyInfoHelper from, IKeyInfoHelper to);
}
internal class NMemory.Common.LinqJoinKeyHelper : object {
    public static void CreateKeySelectors(Type outerType, Type innerType, IExpressionBuilder[] outerKeyCreator, IExpressionBuilder[] innerKeyCreator, LambdaExpression& outerKey, LambdaExpression& innerKey);
}
[DefaultMemberAttribute("Item")]
public class NMemory.Common.MemberChain : object {
    private MemberInfo[] members;
    public int Count { get; }
    public MemberInfo Item { get; }
    public MemberChain(IEnumerable`1<MemberInfo> members);
    public Expression CreateExpression(Expression source);
    public int get_Count();
    public MemberInfo get_Item(int index);
}
internal static class NMemory.Common.QueryExpressionHelper : object {
    public static bool GetSelectManyCollectionSelector(Expression node, LambdaExpression& collectionSelector);
    public static bool GetWherePredicate(Expression node, LambdaExpression& predicate);
    public static bool GetDefaultOrEmptySource(Expression node, Expression& source);
}
internal class NMemory.Common.QueryMethods : object {
    public static MethodInfo SelectMany { get; }
    public static MethodInfo First { get; }
    public static MethodInfo Select { get; }
    public static MethodInfo Where { get; }
    public static MethodInfo DefaultIfEmpty { get; }
    public static MethodInfo EnumerableDefaultIfEmpty { get; }
    public static MethodInfo SelectManyNoResultSelector { get; }
    public static MethodInfo Join { get; }
    public static MethodInfo JoinIndexed { get; }
    public static MethodInfo GroupJoin { get; }
    public static MethodInfo GroupJoinIndexed { get; }
    public static MethodInfo AsQueryable { get; }
    public static MethodInfo get_SelectMany();
    public static MethodInfo get_First();
    public static MethodInfo get_Select();
    public static MethodInfo get_Where();
    public static MethodInfo get_DefaultIfEmpty();
    public static MethodInfo get_EnumerableDefaultIfEmpty();
    public static MethodInfo get_SelectManyNoResultSelector();
    public static MethodInfo get_Join();
    public static MethodInfo get_JoinIndexed();
    public static MethodInfo get_GroupJoin();
    public static MethodInfo get_GroupJoinIndexed();
    public static MethodInfo get_AsQueryable();
    private static MethodInfo GetMethodInfo(Expression`1<Func`1<object>> expression);
}
internal class NMemory.Common.ReflectionHelper : object {
    public static Type GetMemberType(MemberInfo member);
    public static object GetMemberValue(MemberInfo member, object source);
    public static MethodInfo GetMethodInfo(Expression`1<Action`1<TClass>> expression);
    public static MethodInfo GetStaticMethodInfo(Expression`1<Func`1<TResult>> expression);
    public static PropertyInfo GetPropertyInfo(Expression`1<Func`2<TClass, TResult>> expression);
    public static string GetMemberName(Expression`1<Func`2<TClass, TResult>> expression);
    public static PropertyInfo GetPropertyInfo(Expression`1<Func`1<object>> expression);
    public static string GetMethodName(Expression`1<Func`2<T, object>> expression);
    public static Type GetUnderlyingIfNullable(Type type);
    public static bool IsAnonymousType(Type type);
    private static bool CheckIfAnonymousType(Type type);
    public static bool IsNullable(Type type);
    public static bool IsTuple(Type type);
    public static Type GetTupleType(int count);
    public static Type GetTupleType(Type[] elementTypes);
    public static bool IsGenericEnumerable(Type type);
    public static bool IsCastableTo(Type from, Type to);
    public static Type GetEnumerableInterface(Type type);
    public static Type GetElementType(Type type);
}
internal static class NMemory.Common.TableLocator : object {
    public static ITable[] FindAffectedTables(IDatabase database, IExecutionPlan plan);
}
internal class NMemory.Common.TupleTypeHelper : object {
    public static int LargeTupleSize;
    private static TupleTypeHelper();
    public static Type CreateTupleType(Type[] memberTypes);
    private static Type CreateTupleType(Type[] memberTypes, int offset);
    private static Type GetTupleType(Type[] memberTypes);
}
internal class NMemory.Common.Visitors.EntityTypeSearchVisitor : ExpressionVisitor {
    private HashSet`1<Type> entityTypes;
    public Type[] FoundEntityTypes { get; }
    public Type[] get_FoundEntityTypes();
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
}
public class NMemory.Common.Visitors.ExpressionSearchVisitor : ExpressionVisitor {
    private Expression expression;
    private bool found;
    public ExpressionSearchVisitor(Expression expression);
    public virtual Expression Visit(Expression node);
    public static bool Search(Expression source, Expression node);
}
internal class NMemory.Common.Visitors.ParameterChangeVisitor : ExpressionVisitor {
    private ParameterExpression from;
    private ParameterExpression to;
    public Expression Change(Expression expression, ParameterExpression from, ParameterExpression to);
    protected virtual Expression VisitParameter(ParameterExpression node);
}
internal class NMemory.Common.Visitors.ReplaceVisitor : ExpressionVisitor {
    private Func`2<Expression, bool> condition;
    private Func`2<Expression, Expression> converter;
    public ReplaceVisitor(Func`2<Expression, bool> condition, Func`2<Expression, Expression> modifier);
    public virtual Expression Visit(Expression expression);
    public static Expression Replace(Expression expression, Func`2<Expression, bool> condition, Func`2<Expression, Expression> modifier);
}
public class NMemory.Common.Visitors.StoredProcedureParameterSearchVisitor : ExpressionVisitor {
    private Dictionary`2<string, IParameter> parameters;
    public static IList`1<IParameter> FindParameters(Expression expression);
    public IList`1<IParameter> SearchParameters(Expression expression);
    protected virtual Expression VisitUnary(UnaryExpression node);
}
public class NMemory.Concurrency.ChaosConcurrencyManager : object {
    public sealed virtual void Initialize(IDatabase database);
    public sealed virtual void AcquireTableWriteLock(ITable table, Transaction transaction);
    public sealed virtual void ReleaseTableWriteLock(ITable table, Transaction transaction);
    public sealed virtual void AcquireTableReadLock(ITable table, Transaction transaction);
    public sealed virtual void ReleaseTableReadLock(ITable table, Transaction transaction);
    public sealed virtual void ReleaseAllLocks(Transaction transaction);
    public sealed virtual void AcquireRelatedTableLock(ITable table, Transaction transaction);
}
public enum NMemory.Concurrency.DeadlockManagementStrategy : Enum {
    public int value__;
    public static DeadlockManagementStrategy DeadlockDetection;
    public static DeadlockManagementStrategy DeadlockPrevention;
}
internal class NMemory.Concurrency.EntrantCounter : object {
    private Dictionary`2<long, int> counter;
    public int Increment(long id);
    public int Decrement(long id);
}
public class NMemory.Concurrency.Locks.DefaultLockFactory : object {
    public sealed virtual ILock CreateLock();
}
public interface NMemory.Concurrency.Locks.ILock {
    public abstract virtual void EnterRead();
    public abstract virtual void EnterWrite();
    public abstract virtual void ExitRead();
    public abstract virtual void ExitWrite();
    public abstract virtual void Upgrade();
    public abstract virtual void Downgrade();
}
public interface NMemory.Concurrency.Locks.ILockFactory {
    public abstract virtual ILock CreateLock();
}
internal class NMemory.Concurrency.Locks.LightweightSpinLock : object {
    private static int ProcessorCount;
    private int held;
    private static LightweightSpinLock();
    public void Enter();
    public void Exit();
    internal static void SpinWait(Int32& retry);
}
public class NMemory.Concurrency.Locks.UncheckedReaderWriterLock : object {
    private static long counter;
    private int readerCount;
    private int writerPending;
    private WaitingToken sentinelToken;
    private LightweightSpinLock innerLock;
    private long id;
    public sealed virtual void EnterRead();
    public sealed virtual void ExitRead();
    public sealed virtual void Upgrade();
    public sealed virtual void Downgrade();
    public sealed virtual void EnterWrite();
    public sealed virtual void ExitWrite();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private void WaitForWrite(WaitingToken wait);
    private WaitingToken AllocateWaitingToken();
    private void DropWaitingToken();
}
internal class NMemory.Concurrency.Locks.WaitingToken : object {
    public WaitingToken Next;
}
public class NMemory.Concurrency.TableLockConcurrencyManager : object {
    private IDatabase database;
    private ILockFactory lockFactory;
    private Dictionary`2<ITable, ILock> tableLocks;
    private Graph`1<object> lockGraph;
    private TransactionLockInventory lockInventory;
    public sealed virtual void Initialize(IDatabase database);
    public sealed virtual void RegisterTable(ITable table);
    public sealed virtual void AcquireTableWriteLock(ITable table, Transaction transaction);
    public sealed virtual void ReleaseTableWriteLock(ITable table, Transaction transaction);
    public sealed virtual void AcquireRelatedTableLock(ITable table, Transaction transaction);
    public sealed virtual void AcquireTableReadLock(ITable table, Transaction transaction);
    public sealed virtual void ReleaseTableReadLock(ITable table, Transaction transaction);
    public sealed virtual void ReleaseAllLocks(Transaction transaction);
    private void WaitsFor(ILock l, Transaction transaction);
    private void LockAquired(ILock l, Transaction transaction);
}
internal class NMemory.Concurrency.TransactionLockInventory : object {
    private ConcurrentDictionary`2<Transaction, HashSet`1<Item>> collection;
    public IList`1<Item> GetAllForRelease(Transaction transaction);
    public Item GetLockInformation(ILock l, Transaction transaction);
    private HashSet`1<Item> GetLocks(Transaction transaction);
}
public abstract class NMemory.Constraints.ConstraintBase`2 : object {
    private IEntityMemberInfo`2<TEntity, TMember> member;
    private IEntityMemberInfoServices`2<TEntity, TMember> memberServices;
    protected string MemberName { get; }
    protected ConstraintBase`2(Expression`1<Func`2<TEntity, TMember>> memberSelector);
    protected ConstraintBase`2(IEntityMemberInfo`2<TEntity, TMember> member);
    protected string get_MemberName();
    public sealed virtual void Apply(TEntity entity, IExecutionContext context);
    protected abstract virtual TMember Apply(TMember value, IExecutionContext context);
    private static IEntityMemberInfo`2<TEntity, TMember> ParseSelectorExpression(Expression`1<Func`2<TEntity, TMember>> selector);
}
public class NMemory.Constraints.GeneratedGuidConstraint`1 : ConstraintBase`2<TEntity, Guid> {
    public GeneratedGuidConstraint`1(IEntityMemberInfo`2<TEntity, Guid> member);
    public GeneratedGuidConstraint`1(Expression`1<Func`2<TEntity, Guid>> memberSelector);
    protected virtual Guid Apply(Guid value, IExecutionContext context);
}
public interface NMemory.Constraints.IConstraint {
}
public interface NMemory.Constraints.IConstraint`1 {
    public abstract virtual void Apply(TEntity entity, IExecutionContext context);
}
public interface NMemory.Constraints.IConstraintFactory`1 {
    public abstract virtual IConstraint`1<TEntity> Create();
}
public class NMemory.Constraints.NCharConstraint`1 : ConstraintBase`2<TEntity, string> {
    private int maxLength;
    public NCharConstraint`1(IEntityMemberInfo`2<TEntity, string> member, int maxLength);
    public NCharConstraint`1(Expression`1<Func`2<TEntity, string>> memberSelector, int maxLength);
    protected virtual string Apply(string value, IExecutionContext context);
}
public class NMemory.Constraints.NotNullableConstraint`2 : ConstraintBase`2<TEntity, TMember> {
    public NotNullableConstraint`2(IEntityMemberInfo`2<TEntity, TMember> member);
    public NotNullableConstraint`2(Expression`1<Func`2<TEntity, TMember>> memberSelector);
    protected virtual TMember Apply(TMember value, IExecutionContext context);
}
public class NMemory.Constraints.NumericConstraint`1 : ConstraintBase`2<TEntity, decimal> {
    private int allDigits;
    private int fractionalPartDigits;
    private long threshold;
    private int WholePartDigits { get; }
    public NumericConstraint`1(IEntityMemberInfo`2<TEntity, decimal> member, int precision, int scale);
    public NumericConstraint`1(Expression`1<Func`2<TEntity, decimal>> memberSelector, int precision, int scale);
    private static void Validate(int precision, int scale);
    private int get_WholePartDigits();
    protected virtual decimal Apply(decimal value, IExecutionContext context);
}
public class NMemory.Constraints.NVarCharConstraint`1 : ConstraintBase`2<TEntity, string> {
    private int maxLength;
    public NVarCharConstraint`1(IEntityMemberInfo`2<TEntity, string> member, int maxLength);
    public NVarCharConstraint`1(Expression`1<Func`2<TEntity, string>> memberSelector, int maxLength);
    protected virtual string Apply(string value, IExecutionContext context);
}
internal class NMemory.Constraints.TimestampConstraint`1 : ConstraintBase`2<TEntity, Timestamp> {
    public TimestampConstraint`1(Expression`1<Func`2<TEntity, Timestamp>> propertySelector);
    protected virtual Timestamp Apply(Timestamp value, IExecutionContext context);
}
[DefaultMemberAttribute("Item")]
public class NMemory.Data.Binary : object {
    private Byte[] binary;
    public int Length { get; }
    public long LongLength { get; }
    public byte Item { get; public set; }
    private Binary(Byte[] binary);
    public int get_Length();
    public long get_LongLength();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public static Binary op_Implicit(Byte[] binary);
    public static Byte[] op_Implicit(Binary binary);
    public static bool op_Equality(Binary left, Binary right);
    public static bool op_Inequality(Binary left, Binary right);
    public static bool op_GreaterThan(Binary left, Binary right);
    public static bool op_LessThan(Binary left, Binary right);
    public static bool op_GreaterThanOrEqual(Binary left, Binary right);
    public static bool op_LessThanOrEqual(Binary left, Binary right);
    public sealed virtual bool Equals(Binary other);
    public sealed virtual bool Equals(Byte[] other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(Binary other);
    public sealed virtual int CompareTo(Byte[] other);
    private static int Compare(Byte[] b1, Byte[] b2);
    private static bool AreEqual(Byte[] b1, Byte[] b2);
    private static int GetHashCode(Byte[] b);
}
public class NMemory.Data.Timestamp : object {
    private static long counter;
    private long value;
    public static Timestamp CreateNew();
    public static Timestamp GetLastTimestamp();
    public static Timestamp FromBytes(Byte[] bytes);
    public static Byte[] GetBytes(Timestamp timestamp);
    public static Timestamp op_Implicit(Byte[] bytes);
    public static Byte[] op_Implicit(Timestamp timestamp);
    public static Timestamp op_Implicit(Binary binary);
    public static Binary op_Implicit(Timestamp timestamp);
    public sealed virtual bool Equals(Timestamp other);
    public sealed virtual int CompareTo(Timestamp other);
    public sealed virtual int CompareTo(object obj);
}
public class NMemory.Database : object {
    private IDatabaseEngine databaseEngine;
    private StoredProcedureCollection storedProcedures;
    private TableCollection tables;
    public StoredProcedureCollection StoredProcedures { get; }
    public TableCollection Tables { get; }
    public IDatabaseEngine DatabaseEngine { get; }
    public Database(IDatabaseComponentFactory databaseComponentFactory);
    public sealed virtual StoredProcedureCollection get_StoredProcedures();
    public sealed virtual TableCollection get_Tables();
    public sealed virtual IDatabaseEngine get_DatabaseEngine();
}
public class NMemory.DataStructures.Hashtable`2 : object {
    private Dictionary`2<TKey, List`1<TEntity>> inner;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public long Count { get; private set; }
    private IEnumerable`1<TKey> NMemory.DataStructures.IDataStructure<TKey,TEntity>.AllKeys { get; }
    public bool SupportsIntervalSearch { get; }
    [CompilerGeneratedAttribute]
public sealed virtual long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
    private sealed virtual override IEnumerable`1<TKey> NMemory.DataStructures.IDataStructure<TKey,TEntity>.get_AllKeys();
    public sealed virtual bool get_SupportsIntervalSearch();
    private sealed virtual override IEnumerable`1<TEntity> NMemory.DataStructures.IDataStructure<TKey,TEntity>.Select(TKey key);
    public sealed virtual IEnumerable`1<TEntity> SelectAll();
    public sealed virtual void Insert(TKey key, TEntity entity);
    public bool TryInsert(TKey key, TEntity entity);
    public sealed virtual void Delete(TKey key, TEntity item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Clear();
    public sealed virtual IEnumerable`1<TEntity> Select(TKey from, TKey to, bool fromOpen, bool toOpen);
    public sealed virtual IEnumerable`1<TEntity> SelectGreater(TKey from, bool open);
    public sealed virtual IEnumerable`1<TEntity> SelectLess(TKey to, bool open);
}
public interface NMemory.DataStructures.IDataStructure`2 {
    public IEnumerable`1<TKey> AllKeys { get; }
    public long Count { get; }
    public bool SupportsIntervalSearch { get; }
    public abstract virtual IEnumerable`1<TKey> get_AllKeys();
    public abstract virtual long get_Count();
    public abstract virtual bool get_SupportsIntervalSearch();
    public abstract virtual IEnumerable`1<TEntity> Select(TKey value);
    public abstract virtual IEnumerable`1<TEntity> SelectAll();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void Clear();
    public abstract virtual void Insert(TKey key, TEntity entity);
    public abstract virtual void Delete(TKey key, TEntity entity);
}
public interface NMemory.DataStructures.IIntervalSearchable`2 {
    public abstract virtual IEnumerable`1<TEntity> Select(TKey from, TKey to, bool fromOpen, bool toOpen);
    public abstract virtual IEnumerable`1<TEntity> SelectGreater(TKey from, bool open);
    public abstract virtual IEnumerable`1<TEntity> SelectLess(TKey to, bool open);
}
internal class NMemory.DataStructures.Internal.Graphs.Graph`1 : object {
    private object syncLock;
    [CompilerGeneratedAttribute]
private Dictionary`2<T, List`1<T>> <Connections>k__BackingField;
    public Dictionary`2<T, List`1<T>> Connections { get; private set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<T, List`1<T>> get_Connections();
    [CompilerGeneratedAttribute]
private void set_Connections(Dictionary`2<T, List`1<T>> value);
    public void AddNode(T node);
    public void AddConnection(T from, T end);
    public void RemoveConnection(T from, T end);
    public bool HasCycle();
    private bool HasCycleReq(T current, List`1<T> visited);
}
[DefaultMemberAttribute("Item")]
internal class NMemory.DataStructures.Internal.Trees.RedBlackTree`2 : object {
    private IComparer`1<TKey> comparer;
    private RedBlackTreeNode`2<TKey, TValue> root;
    private int count;
    private RedBlackTreeNode`2<TKey, TValue> nodeBeingDeleted;
    private bool siblingToRight;
    private bool parentToRight;
    private bool nodeToDeleteRed;
    private object syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    internal RedBlackTreeNode`2<TKey, TValue> RootElement { get; }
    public TValue Item { get; public set; }
    public RedBlackTree`2(IComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsSynchronized();
    public object get_SyncRoot();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    internal RedBlackTreeNode`2<TKey, TValue> get_RootElement();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<TValue> IntervalSearch(TKey from, TKey to, bool fromOpen, bool toOpen);
    public IEnumerable`1<TValue> SearchGreater(TKey from, bool open);
    public IEnumerable`1<TValue> SearchLess(TKey to, bool open);
    private IEnumerable`1<RedBlackTreeNode`2<TKey, TValue>> InOrderTraversal(RedBlackTreeNode`2<TKey, TValue> node, TKey from, TKey to, bool fromOpen, bool toOpen);
    private IEnumerable`1<RedBlackTreeNode`2<TKey, TValue>> InOrderTraversalFrom(RedBlackTreeNode`2<TKey, TValue> node, TKey from, bool fromOpen);
    private IEnumerable`1<RedBlackTreeNode`2<TKey, TValue>> InOrderTraversalTo(RedBlackTreeNode`2<TKey, TValue> node, TKey to, bool toOpen);
    private RedBlackTreeNode`2<TKey, TValue> FindNode(TKey key, RedBlackTreeNode`2<TKey, TValue> node);
    private IEnumerable`1<RedBlackTreeNode`2<TKey, TValue>> InorderedTraversal();
    private RedBlackTreeNode`2<TKey, TValue> InsertNode(TKey key, TValue value);
    private bool DeleteNode(RedBlackTreeNode`2<TKey, TValue> node, TKey item, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2& result);
    private void RightRotate(RedBlackTreeNode`2& node);
    private void LeftRotate(RedBlackTreeNode`2& node);
    private void GetNodesAbove(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2& parent, RedBlackTreeNode`2& grandParent, RedBlackTreeNode`2& greatGrandParent);
    private void GetParentGrandParentSibling(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2& sibling, RedBlackTreeNode`2& grandParent);
    private void FixTreeAfterInsertion(RedBlackTreeNode`2<TKey, TValue> child, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> grandParent, RedBlackTreeNode`2<TKey, TValue> greatGrandParent);
    private RedBlackTreeNode`2<TKey, TValue> LeftMost(RedBlackTreeNode`2<TKey, TValue> node);
    private RedBlackTreeNode`2<TKey, TValue> DeleteLeftMost(RedBlackTreeNode`2<TKey, TValue> node, RedBlackTreeNode`2<TKey, TValue> parent);
    private void FixTreeAfterDeletion(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> sibling, RedBlackTreeNode`2<TKey, TValue> grandParent);
    private void Case1(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> sibling, RedBlackTreeNode`2<TKey, TValue> grandParent);
    private void Case2A(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> sibling, RedBlackTreeNode`2<TKey, TValue> grandParent);
    private void Case2B(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> sibling, RedBlackTreeNode`2<TKey, TValue> grandParent);
    private void Case3(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> sibling, RedBlackTreeNode`2<TKey, TValue> grandParent);
    private void Case3P(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> sibling, RedBlackTreeNode`2<TKey, TValue> grandParent);
    private void Case4(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> sibling, RedBlackTreeNode`2<TKey, TValue> grandParent);
    private void Case4P(RedBlackTreeNode`2<TKey, TValue> curNode, RedBlackTreeNode`2<TKey, TValue> parent, RedBlackTreeNode`2<TKey, TValue> sibling, RedBlackTreeNode`2<TKey, TValue> grandParent);
}
internal class NMemory.DataStructures.Internal.Trees.RedBlackTreeNode`2 : object {
    private WeakReference parent;
    [CompilerGeneratedAttribute]
private RedBlackTreeNode`2<TKey, TValue> <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private RedBlackTreeNode`2<TKey, TValue> <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Red>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public RedBlackTreeNode`2<TKey, TValue> Left { get; public set; }
    public RedBlackTreeNode`2<TKey, TValue> Right { get; public set; }
    public RedBlackTreeNode`2<TKey, TValue> Parent { get; public set; }
    public bool Red { get; public set; }
    public TKey Key { get; public set; }
    public TValue Value { get; public set; }
    public RedBlackTreeNode`2(TKey key, TValue value, RedBlackTreeNode`2<TKey, TValue> parent);
    [CompilerGeneratedAttribute]
public RedBlackTreeNode`2<TKey, TValue> get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(RedBlackTreeNode`2<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public RedBlackTreeNode`2<TKey, TValue> get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(RedBlackTreeNode`2<TKey, TValue> value);
    public RedBlackTreeNode`2<TKey, TValue> get_Parent();
    public void set_Parent(RedBlackTreeNode`2<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public bool get_Red();
    [CompilerGeneratedAttribute]
public void set_Red(bool value);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(TKey value);
    [CompilerGeneratedAttribute]
public TValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(TValue value);
    public virtual string ToString();
}
public interface NMemory.DataStructures.IUniqueDataStructure`2 {
    public abstract virtual TEntity Select(TKey key);
}
public class NMemory.DataStructures.RedBlackTree`2 : object {
    private RedBlackTree`2<TKey, List`1<TEntity>> inner;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    private IEnumerable`1<TKey> NMemory.DataStructures.IDataStructure<TKey,TEntity>.AllKeys { get; }
    public long Count { get; private set; }
    public bool SupportsIntervalSearch { get; }
    public RedBlackTree`2(IComparer`1<TKey> comparer);
    private sealed virtual override IEnumerable`1<TKey> NMemory.DataStructures.IDataStructure<TKey,TEntity>.get_AllKeys();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
    public sealed virtual bool get_SupportsIntervalSearch();
    public sealed virtual IEnumerable`1<TEntity> Select(TKey key);
    public sealed virtual IEnumerable`1<TEntity> SelectAll();
    public sealed virtual void Insert(TKey key, TEntity entity);
    public sealed virtual void Delete(TKey key, TEntity item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Clear();
    public sealed virtual IEnumerable`1<TEntity> Select(TKey from, TKey to, bool fromOpen, bool toOpen);
    public sealed virtual IEnumerable`1<TEntity> SelectGreater(TKey from, bool open);
    public sealed virtual IEnumerable`1<TEntity> SelectLess(TKey to, bool open);
}
public class NMemory.DataStructures.UniqueHashtable`2 : object {
    private Dictionary`2<TKey, TEntity> inner;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public long Count { get; private set; }
    private IEnumerable`1<TKey> NMemory.DataStructures.IDataStructure<TKey,TEntity>.AllKeys { get; }
    public bool SupportsIntervalSearch { get; }
    [CompilerGeneratedAttribute]
public sealed virtual long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
    private sealed virtual override IEnumerable`1<TKey> NMemory.DataStructures.IDataStructure<TKey,TEntity>.get_AllKeys();
    public sealed virtual bool get_SupportsIntervalSearch();
    private sealed virtual override IEnumerable`1<TEntity> NMemory.DataStructures.IDataStructure<TKey,TEntity>.Select(TKey key);
    public sealed virtual IEnumerable`1<TEntity> SelectAll();
    public sealed virtual void Insert(TKey key, TEntity entity);
    public sealed virtual void Delete(TKey key, TEntity item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Clear();
    private sealed virtual override TEntity NMemory.DataStructures.IUniqueDataStructure<TKey,TEntity>.Select(TKey key);
    public sealed virtual IEnumerable`1<TEntity> Select(TKey from, TKey to, bool fromOpen, bool toOpen);
    public sealed virtual IEnumerable`1<TEntity> SelectGreater(TKey from, bool open);
    public sealed virtual IEnumerable`1<TEntity> SelectLess(TKey to, bool open);
}
public class NMemory.DataStructures.UniqueRedBlackTree`2 : object {
    private RedBlackTree`2<TKey, TEntity> inner;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public long Count { get; private set; }
    public bool SupportsIntervalSearch { get; }
    private IEnumerable`1<TKey> NMemory.DataStructures.IDataStructure<TKey,TEntity>.AllKeys { get; }
    public UniqueRedBlackTree`2(IComparer`1<TKey> comparer);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
    public sealed virtual bool get_SupportsIntervalSearch();
    private sealed virtual override IEnumerable`1<TKey> NMemory.DataStructures.IDataStructure<TKey,TEntity>.get_AllKeys();
    private sealed virtual override TEntity NMemory.DataStructures.IUniqueDataStructure<TKey,TEntity>.Select(TKey key);
    private sealed virtual override IEnumerable`1<TEntity> NMemory.DataStructures.IDataStructure<TKey,TEntity>.Select(TKey key);
    public sealed virtual IEnumerable`1<TEntity> SelectAll();
    public sealed virtual void Insert(TKey key, TEntity entity);
    public sealed virtual void Delete(TKey key, TEntity item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Clear();
    public sealed virtual IEnumerable`1<TEntity> Select(TKey from, TKey to, bool fromOpen, bool toOpen);
    public sealed virtual IEnumerable`1<TEntity> SelectGreater(TKey from, bool open);
    public sealed virtual IEnumerable`1<TEntity> SelectLess(TKey to, bool open);
}
public class NMemory.Diagnostics.ConsoleLoggingPort : object {
    public sealed virtual void Send(Message msg);
}
public class NMemory.Diagnostics.MessageBuffer : object {
    [CompilerGeneratedAttribute]
private List`1<Message> <Messages>k__BackingField;
    public List`1<Message> Messages { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<Message> get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(List`1<Message> value);
    public void Clear();
    public sealed virtual void Send(Message msg);
}
public class NMemory.Diagnostics.Messages.IndexFoundMessage : TableMessage {
    [CompilerGeneratedAttribute]
private IIndex <Index>k__BackingField;
    public IIndex Index { get; public set; }
    [CompilerGeneratedAttribute]
public IIndex get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(IIndex value);
    public virtual string ToString();
}
public class NMemory.Diagnostics.Messages.JoinArgumentsOrderSwappedMessage : Message {
    public virtual string ToString();
}
public class NMemory.Diagnostics.Messages.JoinOperatorsSwappedMessage : Message {
    public virtual string ToString();
}
public class NMemory.Diagnostics.Messages.Message : object {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    public DateTime Timestamp { get; private set; }
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(DateTime value);
    public virtual string ToString();
}
public class NMemory.Diagnostics.Messages.PreferredIndexMessage : Message {
    [CompilerGeneratedAttribute]
private IIndex <OldIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndex <NewIndex>k__BackingField;
    public IIndex OldIndex { get; public set; }
    public IIndex NewIndex { get; public set; }
    [CompilerGeneratedAttribute]
public IIndex get_OldIndex();
    [CompilerGeneratedAttribute]
public void set_OldIndex(IIndex value);
    [CompilerGeneratedAttribute]
public IIndex get_NewIndex();
    [CompilerGeneratedAttribute]
public void set_NewIndex(IIndex value);
    public virtual string ToString();
}
public class NMemory.Diagnostics.Messages.StandardMessage : Message {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    public StandardMessage(string text);
    public StandardMessage(string text, Object[] args);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    public virtual string ToString();
}
public class NMemory.Diagnostics.Messages.TableMessage : Message {
    [CompilerGeneratedAttribute]
private ITable <Table>k__BackingField;
    public ITable Table { get; public set; }
    [CompilerGeneratedAttribute]
public ITable get_Table();
    [CompilerGeneratedAttribute]
public void set_Table(ITable value);
    public virtual string ToString();
}
public class NMemory.Exceptions.ConstraintException : NMemoryException {
    public ConstraintException(string message);
}
public class NMemory.Exceptions.DeadlockException : NMemoryException {
}
public enum NMemory.Exceptions.ErrorCode : Enum {
    public int value__;
    public static ErrorCode GenericError;
    public static ErrorCode ExistingKeyFound;
    public static ErrorCode TransactionHasAlreadyStarted;
    public static ErrorCode RelationError;
}
internal static class NMemory.Exceptions.ExceptionMessages : object {
    public static string Missing;
    public static string CannotCreateKeyInfo;
    public static string MemberAndSortOrderCountMismatch;
    public static string InvalidKeyInfoHelper;
    public static string GenericKeyInfoCannotBeNull;
    public static string ServiceNotFound;
    public static string ServiceCannotBeCombined;
    public static string TableNotCreated;
    public static string InvalidKeySelector;
    public static string ForeignKeyViolation;
    private static ExceptionMessages();
}
public class NMemory.Exceptions.ForeignKeyViolationException : NMemoryException {
    public ForeignKeyViolationException(IIndex primaryIndex, IIndex foreignIndex, object primaryKey);
    private static string GetMessage(IIndex primaryIndex, IIndex foreignIndex, object primaryKey);
}
public class NMemory.Exceptions.IndexKeyTypeNotSupportedException : NMemoryException {
}
public class NMemory.Exceptions.MultipleUniqueKeyFoundException : NMemoryException {
    public MultipleUniqueKeyFoundException(IKeyInfo keyInfo, Exception inner);
    private static string GetMessage(IKeyInfo info);
}
public class NMemory.Exceptions.NMemoryException : Exception {
    private string message;
    private ErrorCode errorCode;
    public ErrorCode ErrorCode { get; }
    public string Message { get; }
    public NMemoryException(ErrorCode errorCode, string message);
    public NMemoryException(ErrorCode errorCode, string message, Object[] args);
    public NMemoryException(string message, Object[] args);
    public NMemoryException(string message);
    public NMemoryException(ErrorCode errorCode, Exception innerException);
    public ErrorCode get_ErrorCode();
    public virtual string get_Message();
}
public class NMemory.Exceptions.ParameterException : NMemoryException {
}
public class NMemory.Execution.CommandExecutor : object {
    private IDatabase database;
    protected IDatabase Database { get; }
    protected IConcurrencyManager ConcurrencyManager { get; }
    public sealed virtual void Initialize(IDatabase database);
    public sealed virtual IEnumerator`1<T> ExecuteQuery(IExecutionPlan`1<IEnumerable`1<T>> plan, IExecutionContext context);
    private IEnumerator`1<T> ExecuteQuery(IExecutionPlan`1<IEnumerable`1<T>> plan, IExecutionContext context, ITable[] tablesToLock, bool cloneEntities);
    public sealed virtual T ExecuteQuery(IExecutionPlan`1<T> plan, IExecutionContext context);
    public sealed virtual void ExecuteInsert(T entity, IExecutionContext context);
    public sealed virtual IEnumerable`1<T> ExecuteDelete(IExecutionPlan`1<IEnumerable`1<T>> plan, IExecutionContext context);
    public sealed virtual IEnumerable`1<T> ExecuteUpdater(IExecutionPlan`1<IEnumerable`1<T>> plan, IUpdater`1<T> updater, IExecutionContext context);
    protected IDatabase get_Database();
    protected IConcurrencyManager get_ConcurrencyManager();
    protected void AcquireWriteLock(ITable table, IExecutionContext context);
    protected void AcquireWriteLock(ITable[] tables, IExecutionContext context);
    protected void ReleaseWriteLock(ITable table, IExecutionContext context);
    protected void AcquireReadLock(ITable table, IExecutionContext context);
    protected void ReleaseReadLock(ITable table, IExecutionContext context);
    protected void LockRelatedTables(ITable[] relatedTables, IExecutionContext context);
    private void LockRelatedTables(RelationGroup relations, IExecutionContext context, ITable[] except);
    private List`1<T> Query(IExecutionPlan`1<IEnumerable`1<T>> plan, ITable`1<T> table, IExecutionContext context);
    private AtomicLogScope StartAtomicLogOperation(IExecutionContext context);
}
public class NMemory.Execution.EntityUpdater`1 : object {
    private T source;
    public MemberInfo[] Changes { get; }
    public EntityUpdater`1(T source);
    public sealed virtual T Update(T entity);
    public sealed virtual MemberInfo[] get_Changes();
}
internal class NMemory.Execution.ExecutionContext : object {
    private Transaction transaction;
    private IDictionary`2<string, object> parameters;
    private IDatabase database;
    private OperationType operationType;
    public IDatabase Database { get; }
    public Transaction Transaction { get; }
    public OperationType OperationType { get; }
    public ExecutionContext(IDatabase database, Transaction transaction, OperationType operationType);
    public ExecutionContext(IDatabase database, Transaction transaction, OperationType operationType, IDictionary`2<string, object> parameters);
    public sealed virtual IDatabase get_Database();
    public sealed virtual Transaction get_Transaction();
    public sealed virtual OperationType get_OperationType();
    public sealed virtual T GetParameter(string name);
}
[ExtensionAttribute]
internal static class NMemory.Execution.ExecutionContextExtensions : object {
    [ExtensionAttribute]
public static T GetService(IExecutionContext context);
}
internal class NMemory.Execution.ExecutionHelper : object {
    private IDatabase database;
    public ExecutionHelper(IDatabase database);
    public IEnumerable`1<ITable> GetRelatedTables(RelationGroup relations, ITable[] except);
    public RelationGroup FindRelations(IEnumerable`1<IIndex> indexes, bool referring, bool referred);
    public Dictionary`2<IRelation, HashSet`1<object>> FindReferringEntities(IList`1<T> storedEntities, IList`1<IRelationInternal> relations);
    public void ValidateForeignKeys(IList`1<IRelationInternal> relations, Dictionary`2<IRelation, HashSet`1<object>> referringEntities);
    public void ValidateForeignKeys(IList`1<IRelationInternal> relations, IEnumerable`1<object> referringEntities);
    public ITable[] GetCascadedTables(ITable table);
    private void CollectAllCascadedTables(ITable currentTable, List`1<ITable> tables);
    public IList`1<IIndex`1<T>> FindAffectedIndexes(ITable`1<T> table, MemberInfo[] changes);
}
public class NMemory.Execution.ExecutionPlan`1 : object {
    private Func`2<IExecutionContext, T> executable;
    private IExecutionPlanInfo info;
    public IExecutionPlanInfo Info { get; }
    public ExecutionPlan`1(Func`2<IExecutionContext, T> executable, IExecutionPlanInfo info);
    public sealed virtual IExecutionPlanInfo get_Info();
    public sealed virtual T Execute(IExecutionContext context);
}
internal class NMemory.Execution.ExecutionPlanInfo : object {
    private IList`1<ITransformationStep> steps;
    public Expression Final { get; }
    public IList`1<ITransformationStep> TransformationSteps { get; }
    public ExecutionPlanInfo(IList`1<ITransformationStep> steps);
    public sealed virtual Expression get_Final();
    public sealed virtual IList`1<ITransformationStep> get_TransformationSteps();
}
public class NMemory.Execution.ExpressionUpdater`1 : object {
    private Func`2<T, T> updater;
    private Expression`1<Func`2<T, T>> updaterExpr;
    public MemberInfo[] Changes { get; }
    public ExpressionUpdater`1(Expression`1<Func`2<T, T>> updater);
    public sealed virtual T Update(T entity);
    public sealed virtual MemberInfo[] get_Changes();
}
public interface NMemory.Execution.IExecutionContext {
    public IDatabase Database { get; }
    public Transaction Transaction { get; }
    public OperationType OperationType { get; }
    public abstract virtual IDatabase get_Database();
    public abstract virtual Transaction get_Transaction();
    public abstract virtual T GetParameter(string name);
    public abstract virtual OperationType get_OperationType();
}
public interface NMemory.Execution.IExecutionPlan {
    public IExecutionPlanInfo Info { get; }
    public abstract virtual IExecutionPlanInfo get_Info();
}
public interface NMemory.Execution.IExecutionPlan`1 {
    public abstract virtual T Execute(IExecutionContext context);
}
public interface NMemory.Execution.IExecutionPlanInfo {
    public Expression Final { get; }
    public IList`1<ITransformationStep> TransformationSteps { get; }
    public abstract virtual Expression get_Final();
    public abstract virtual IList`1<ITransformationStep> get_TransformationSteps();
}
public interface NMemory.Execution.ITransformationContext {
    public bool IsFinished { get; public set; }
    public ParameterExpression Parameter { get; }
    public abstract virtual bool get_IsFinished();
    public abstract virtual void set_IsFinished(bool value);
    public abstract virtual ParameterExpression get_Parameter();
}
public interface NMemory.Execution.IUpdater`1 {
    public MemberInfo[] Changes { get; }
    public abstract virtual T Update(T entity);
    public abstract virtual MemberInfo[] get_Changes();
}
public enum NMemory.Execution.OperationType : Enum {
    public int value__;
    public static OperationType Query;
    public static OperationType Insert;
    public static OperationType Update;
    public static OperationType Delete;
}
public class NMemory.Execution.Optimization.EqualityMappingDetector : ExpressionVisitor {
    private IList`1<IExpressionBuilder> leftMembers;
    private IList`1<IExpressionBuilder> rightMembers;
    private Expression leftSource;
    private Expression rightSource;
    public IExpressionBuilder[] LeftMembers { get; }
    public IExpressionBuilder[] RightMembers { get; }
    public EqualityMappingDetector(Expression left, Expression right);
    public IExpressionBuilder[] get_LeftMembers();
    public IExpressionBuilder[] get_RightMembers();
    public bool Detect(Expression expression);
    private bool DetectEqualOperand(Expression expression);
    private bool DetectEqualOperand(Expression expression, Expression source, IList`1<IExpressionBuilder> collector);
}
public interface NMemory.Execution.Optimization.IExpressionRewriter {
    public abstract virtual Expression Rewrite(Expression expression);
}
public interface NMemory.Execution.Optimization.ITransformationStep {
    public Expression Expression { get; }
    public abstract virtual Expression get_Expression();
}
internal static class NMemory.Execution.Optimization.JoinGroup : object {
    public static JoinGroup`2<TOuter, TInner> Create(TOuter outer, IEnumerable`1<TInner> inner);
}
internal class NMemory.Execution.Optimization.JoinGroup`2 : object {
    private TOuter outer;
    private IEnumerable`1<TInner> inner;
    public TOuter Outer { get; }
    public IEnumerable`1<TInner> Inner { get; }
    public JoinGroup`2(TOuter outer, IEnumerable`1<TInner> inner);
    public TOuter get_Outer();
    public IEnumerable`1<TInner> get_Inner();
}
public class NMemory.Execution.Optimization.Rewriters.DatabaseParameterRewriter : ExpressionRewriterBase {
    private ITransformationContext context;
    public DatabaseParameterRewriter(ITransformationContext context);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
}
public abstract class NMemory.Execution.Optimization.Rewriters.ExpressionRewriterBase : ExpressionVisitor {
    private IDatabase database;
    protected ILoggingPort LoggingPort { get; }
    protected IDatabase Database { get; }
    public sealed virtual void Initialize(IDatabase database);
    public sealed virtual Expression Rewrite(Expression expression);
    protected ILoggingPort get_LoggingPort();
    protected IDatabase get_Database();
    protected virtual IList`1<Expression> VisitExpressions(IList`1<Expression> original);
}
public class NMemory.Execution.Optimization.Rewriters.GroupJoinPhysicalRewriter : JoinPhysicalRewriterBase {
    protected MethodInfo Original { get; }
    protected MethodInfo Indexed { get; }
    protected virtual MethodInfo get_Original();
    protected virtual MethodInfo get_Indexed();
}
public class NMemory.Execution.Optimization.Rewriters.IndexAccessRewriter : ExpressionRewriterBase {
    protected virtual Expression VisitMember(MemberExpression node);
}
public class NMemory.Execution.Optimization.Rewriters.InnerJoinLogicalRewriter : ExpressionRewriterBase {
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
}
public class NMemory.Execution.Optimization.Rewriters.JoinPhysicalRewriter : JoinPhysicalRewriterBase {
    protected MethodInfo Original { get; }
    protected MethodInfo Indexed { get; }
    protected virtual MethodInfo get_Original();
    protected virtual MethodInfo get_Indexed();
}
public abstract class NMemory.Execution.Optimization.Rewriters.JoinPhysicalRewriterBase : ExpressionRewriterBase {
    protected MethodInfo Original { get; }
    protected MethodInfo Indexed { get; }
    protected abstract virtual MethodInfo get_Original();
    protected abstract virtual MethodInfo get_Indexed();
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private static IKeyInfoHelper GetKeyInfoHelper(IKeyInfo keyInfo);
    private IKeyInfoHelper GetKeyInfoHelper(Type keyType);
}
public class NMemory.Execution.Optimization.Rewriters.OuterJoinLogicalRewriter : ExpressionRewriterBase {
    private static string JoinGroupInner;
    private static string JoinGroupOuter;
    private static MethodInfo JoinGroupCreate;
    private static OuterJoinLogicalRewriter();
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private static LambdaExpression CreateGroupJoinResultSelector(Type outerType, Type innerType);
    private static LambdaExpression CreatePostSelectManyCollectionSelector(Type innerType, Type groupJoinResultType);
    private static LambdaExpression CreatePostSelectManyResultSelector(Type innerType, Type groupJoinResultType, LambdaExpression originalResultSelector);
}
public class NMemory.Execution.Optimization.Rewriters.PropertyAccessRewriter : ExpressionRewriterBase {
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    private Expression CreateSafeMemberAccessExpression(MemberExpression memberNode, Type resultType);
}
public class NMemory.Execution.Optimization.Rewriters.QueryableRewriter : ExpressionRewriterBase {
    private static ILookup`2<string, MethodInfo> enumerableLookup;
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private static MethodInfo FindEnumerableMethod(string name, IList`1<Expression> arguments, Type[] genericArguments);
    private static Type StripExpression(Type type);
    private static Type FindGenericType(Type definition, Type type);
    private static bool ArgsMatch(MethodInfo methodInfo, IList`1<Expression> arguments, Type[] typeArgs);
    private Expression FixupQuotedExpression(Type type, Expression expression);
    private IList`1<Expression> FixupArguments(MethodInfo methodInfo, IList`1<Expression> arguments);
}
internal class NMemory.Execution.Optimization.Rewriters.StoredProcedureParameterRewriter : ExpressionRewriterBase {
    private ITransformationContext context;
    public StoredProcedureParameterRewriter(ITransformationContext context);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    private Expression CreateParameterReader(Type type, string name);
}
public class NMemory.Execution.Optimization.Rewriters.TableAccessRewriter : ExpressionRewriterBase {
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private IDatabase FindDatabase(Expression databaseAccess);
}
public class NMemory.Execution.Optimization.Rewriters.TableScanRewriter : ExpressionRewriterBase {
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private static Expression CreateSelectTableExpression(Expression source, Type entityType);
}
public class NMemory.Execution.Optimization.TransformationStep : object {
    private Expression expression;
    public Expression Expression { get; }
    public TransformationStep(Expression expression);
    public sealed virtual Expression get_Expression();
    public virtual string ToString();
    public virtual int GetHashCode();
}
internal class NMemory.Execution.Optimization.TransformationStepRecorder : object {
    private IList`1<ITransformationStep> steps;
    private IList`1<ITransformationStep> readonlySteps;
    public IList`1<ITransformationStep> Steps { get; }
    public void Record(ITransformationStep step);
    public IList`1<ITransformationStep> get_Steps();
}
internal class NMemory.Execution.Primitives.DeletePrimitive : object {
    private IDatabase database;
    private AtomicLogScope log;
    public DeletePrimitive(IDatabase database, AtomicLogScope log);
    public sealed virtual void Delete(IList`1<T> storedEntities);
}
internal interface NMemory.Execution.Primitives.IDeletePrimitive {
    public abstract virtual void Delete(IList`1<T> storedEntities);
}
public class NMemory.Execution.QueryCompiler : QueryCompilerBase {
    [CompilerGeneratedAttribute]
private bool <EnableCompilationCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableOptimization>k__BackingField;
    public bool EnableCompilationCaching { get; public set; }
    public bool EnableOptimization { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableCompilationCaching();
    [CompilerGeneratedAttribute]
public void set_EnableCompilationCaching(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableOptimization();
    [CompilerGeneratedAttribute]
public void set_EnableOptimization(bool value);
    protected virtual IEnumerable`1<IExpressionRewriter> GetRewriters(Expression expression, ITransformationContext context);
    private IEnumerable`1<IExpressionRewriter> GetCustomRewriters(Expression expression, ITransformationContext context);
}
public abstract class NMemory.Execution.QueryCompilerBase : object {
    private IDatabase database;
    public sealed virtual void Initialize(IDatabase database);
    public sealed virtual IExecutionPlan`1<T> Compile(Expression expression);
    protected virtual Expression PreprocessExpression(Expression expression, ITransformationContext context);
    protected virtual IEnumerable`1<IExpressionRewriter> GetRewriters(Expression expression, ITransformationContext context);
    protected virtual Expression PostprocessExpression(Expression expression, ITransformationContext context);
    protected IList`1<IExpressionRewriter> ReviewRewriters(IList`1<IExpressionRewriter> rewriters);
    private Expression TransformExpression(Expression expression, ITransformationContext context, TransformationStepRecorder recorder);
    private Delegate CompileCore(Expression expression, ParameterExpression parameter);
}
public class NMemory.Execution.TransformationContext : object {
    private ParameterExpression parameter;
    [CompilerGeneratedAttribute]
private bool <IsFinished>k__BackingField;
    public bool IsFinished { get; public set; }
    public ParameterExpression Parameter { get; }
    public TransformationContext(ParameterExpression parameter);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFinished();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsFinished(bool value);
    public sealed virtual ParameterExpression get_Parameter();
}
public static class NMemory.Functions : object {
    public static bool Like(string input, string pattern);
    internal static bool IsRegexMatch(string input, Regex regex);
    internal static string ConvertLikeToRegex(string pattern);
}
public static class NMemory.Indexes.AnonymousTypeKeyInfo : object {
    public static AnonymousTypeKeyInfo`2<TEntity, TKey> Create(Expression`1<Func`2<TEntity, TKey>> keySelector);
    public static AnonymousTypeKeyInfo`2<TEntity, TKey> Create(Expression`1<Func`2<TEntity, TKey>> keySelector, SortOrder[] sortOrders);
}
public class NMemory.Indexes.AnonymousTypeKeyInfo`2 : KeyInfoBase`2<TEntity, TKey> {
    internal static IKeyInfoHelper KeyInfoHelper;
    private IKeyInfoHelper NMemory.Indexes.IKeyInfoHelperProvider.KeyInfoHelper { get; }
    public AnonymousTypeKeyInfo`2(Expression`1<Func`2<TEntity, TKey>> keySelector, SortOrder[] sortOrders);
    public AnonymousTypeKeyInfo`2(Expression`1<Func`2<TEntity, TKey>> keySelector);
    internal AnonymousTypeKeyInfo`2(MemberInfo[] entityKeyMembers);
    private static AnonymousTypeKeyInfo`2();
    private sealed virtual override IKeyInfoHelper NMemory.Indexes.IKeyInfoHelperProvider.get_KeyInfoHelper();
}
public class NMemory.Indexes.AnonymousTypeKeyInfoHelper : object {
    private Type anonymousType;
    private PropertyInfo[] orderedProperties;
    public AnonymousTypeKeyInfoHelper(Type anonymousType);
    public sealed virtual int GetMemberCount();
    public sealed virtual Expression CreateKeyFactoryExpression(Expression[] arguments);
    public sealed virtual Expression CreateKeyMemberSelectorExpression(Expression source, int index);
    public sealed virtual bool TryParseKeySelectorExpression(Expression keySelector, bool strict, MemberInfo[]& result);
}
public class NMemory.Indexes.DefaultKeyInfoFactory : ModularKeyInfoFactory {
}
public class NMemory.Indexes.DictionaryIndexFactory : IndexFactoryBase {
    public virtual IIndex`2<TEntity, TKey> CreateIndex(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TKey> keyInfo);
    public virtual IUniqueIndex`2<TEntity, TUniqueKey> CreateUniqueIndex(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TUniqueKey> keyInfo);
}
public class NMemory.Indexes.GenericKeyComparer`1 : object {
    private Func`3<T, T, int> comparer;
    public GenericKeyComparer`1(SortOrder[] sortOrders, IKeyInfoHelper helper);
    public sealed virtual int Compare(T x, T y);
    private Expression CreateComparsion(Expression x, Expression y, SortOrder ordering);
}
public interface NMemory.Indexes.IIndex {
    public ITable Table { get; }
    public IKeyInfo KeyInfo { get; }
    public bool SupportsIntervalSearch { get; }
    public long Count { get; }
    public abstract virtual ITable get_Table();
    public abstract virtual IKeyInfo get_KeyInfo();
    public abstract virtual bool get_SupportsIntervalSearch();
    public abstract virtual long get_Count();
    public abstract virtual void Clear();
    public abstract virtual void Rebuild();
}
public interface NMemory.Indexes.IIndex`1 {
    public ITable`1<TEntity> Table { get; }
    public abstract virtual ITable`1<TEntity> get_Table();
    public abstract virtual IEnumerable`1<TEntity> SelectAll();
    public abstract virtual void Insert(TEntity item);
    public abstract virtual void Delete(TEntity item);
}
public interface NMemory.Indexes.IIndex`2 {
    public IKeyInfo`2<TEntity, TKey> KeyInfo { get; }
    public abstract virtual IKeyInfo`2<TEntity, TKey> get_KeyInfo();
    public abstract virtual bool Contains(TKey key);
    public abstract virtual IEnumerable`1<TEntity> Select(TKey value);
    public abstract virtual IEnumerable`1<TEntity> Select(TKey from, TKey to, bool fromOpen, bool toOpen);
    public abstract virtual IEnumerable`1<TEntity> SelectGreater(TKey from, bool open);
    public abstract virtual IEnumerable`1<TEntity> SelectLess(TKey to, bool open);
}
public interface NMemory.Indexes.IIndexFactory {
    public abstract virtual IIndex`2<TEntity, TKey> CreateIndex(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TKey> keyInfo);
    public abstract virtual IUniqueIndex`2<TEntity, TUniqueKey> CreateUniqueIndex(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TUniqueKey> keyInfo);
}
public interface NMemory.Indexes.IKeyInfo {
    public MemberInfo[] EntityKeyMembers { get; }
    public SortOrder[] SortOrders { get; }
    public Type KeyType { get; }
    public abstract virtual MemberInfo[] get_EntityKeyMembers();
    public abstract virtual SortOrder[] get_SortOrders();
    public abstract virtual Type get_KeyType();
}
public interface NMemory.Indexes.IKeyInfo`1 {
    public IComparer`1<TKey> KeyComparer { get; }
    public abstract virtual IComparer`1<TKey> get_KeyComparer();
    public abstract virtual bool IsEmptyKey(TKey key);
}
public interface NMemory.Indexes.IKeyInfo`2 {
    public abstract virtual TKey SelectKey(TEntity entity);
}
public interface NMemory.Indexes.IKeyInfoFactory {
    public abstract virtual IKeyInfo`2<TEntity, TKey> Create(Expression`1<Func`2<TEntity, TKey>> keySelector);
}
public interface NMemory.Indexes.IKeyInfoHelper {
    public abstract virtual int GetMemberCount();
    public abstract virtual Expression CreateKeyFactoryExpression(Expression[] arguments);
    public abstract virtual Expression CreateKeyMemberSelectorExpression(Expression source, int index);
    public abstract virtual bool TryParseKeySelectorExpression(Expression keySelector, bool strict, MemberInfo[]& result);
}
public interface NMemory.Indexes.IKeyInfoHelperProvider {
    public IKeyInfoHelper KeyInfoHelper { get; }
    public abstract virtual IKeyInfoHelper get_KeyInfoHelper();
}
public class NMemory.Indexes.Index`2 : IndexBase`2<TEntity, TKey> {
    private IDataStructure`2<TKey, TEntity> dataStructure;
    internal IDataStructure`2<TKey, TEntity> DataStructure { get; }
    public bool SupportsIntervalSearch { get; }
    internal Index`2(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TKey> keyInfo, IDataStructure`2<TKey, TEntity> dataStructure);
    internal virtual IDataStructure`2<TKey, TEntity> get_DataStructure();
    public virtual IEnumerable`1<TEntity> Select(TKey key);
    public virtual IEnumerable`1<TEntity> SelectAll();
    public virtual void Insert(TEntity entity);
    public virtual void Delete(TEntity entity);
    public virtual bool get_SupportsIntervalSearch();
}
public abstract class NMemory.Indexes.IndexBase`2 : object {
    private ITable`1<TEntity> table;
    private IKeyInfo`2<TEntity, TKey> keyInfo;
    public IKeyInfo`2<TEntity, TKey> KeyInfo { get; }
    private IKeyInfo NMemory.Indexes.IIndex.KeyInfo { get; }
    public ITable`1<TEntity> Table { get; }
    private ITable NMemory.Indexes.IIndex.Table { get; }
    public bool SupportsIntervalSearch { get; }
    public long Count { get; }
    internal IDataStructure`2<TKey, TEntity> DataStructure { get; }
    internal IndexBase`2(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TKey> keyInfo);
    public TKey Key(TEntity entity);
    public abstract virtual IEnumerable`1<TEntity> Select(TKey value);
    public sealed virtual IEnumerable`1<TEntity> Select(TKey from, TKey to, bool fromOpen, bool toOpen);
    public sealed virtual IEnumerable`1<TEntity> SelectGreater(TKey from, bool open);
    public sealed virtual IEnumerable`1<TEntity> SelectLess(TKey to, bool open);
    public abstract virtual IEnumerable`1<TEntity> SelectAll();
    public abstract virtual void Insert(TEntity item);
    public abstract virtual void Delete(TEntity item);
    public IQueryable`1<TEntity> SelectExpr(TKey epxr);
    public IQueryable`1<TEntity> SelectExpr(TKey from, TKey to, bool fromOpen, bool toOpen);
    public IQueryable`1<TEntity> SelectGreaterExpr(TKey from, bool open);
    public IQueryable`1<TEntity> SelectLessExpr(TKey from, bool open);
    public sealed virtual IKeyInfo`2<TEntity, TKey> get_KeyInfo();
    private sealed virtual override IKeyInfo NMemory.Indexes.IIndex.get_KeyInfo();
    public sealed virtual ITable`1<TEntity> get_Table();
    private sealed virtual override ITable NMemory.Indexes.IIndex.get_Table();
    public abstract virtual bool get_SupportsIntervalSearch();
    public sealed virtual long get_Count();
    internal abstract virtual IDataStructure`2<TKey, TEntity> get_DataStructure();
    public virtual string ToString();
    public sealed virtual bool Contains(TKey key);
    public sealed virtual void Rebuild();
    public sealed virtual void Clear();
}
public abstract class NMemory.Indexes.IndexFactoryBase : object {
    public abstract virtual IIndex`2<TEntity, TKey> CreateIndex(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TKey> keyInfo);
    public abstract virtual IUniqueIndex`2<TEntity, TUniqueKey> CreateUniqueIndex(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TUniqueKey> keyInfo);
}
public interface NMemory.Indexes.IUniqueIndex {
}
public interface NMemory.Indexes.IUniqueIndex`1 {
}
public interface NMemory.Indexes.IUniqueIndex`2 {
    public abstract virtual TEntity GetByUniqueIndex(TUniqueKey entity);
}
public abstract class NMemory.Indexes.KeyInfoBase`2 : object {
    private MemberInfo[] entityKeyMembers;
    private SortOrder[] sortOrders;
    private IComparer`1<TKey> keyComparer;
    private Func`2<TEntity, TKey> keySelector;
    private Func`2<TKey, bool> keyEmptinessDetector;
    public IComparer`1<TKey> KeyComparer { get; }
    public MemberInfo[] EntityKeyMembers { get; }
    public SortOrder[] SortOrders { get; }
    public Type KeyType { get; }
    public KeyInfoBase`2(MemberInfo[] entityKeyMembers, SortOrder[] sortOrders, IComparer`1<TKey> keyComparer, IKeyInfoHelper helper);
    public KeyInfoBase`2(Expression`1<Func`2<TEntity, TKey>> keySelector, SortOrder[] sortOrders, IComparer`1<TKey> keyComparer, IKeyInfoHelper helper);
    public sealed virtual TKey SelectKey(TEntity entity);
    public sealed virtual bool IsEmptyKey(TKey key);
    public sealed virtual IComparer`1<TKey> get_KeyComparer();
    public sealed virtual MemberInfo[] get_EntityKeyMembers();
    public sealed virtual SortOrder[] get_SortOrders();
    public sealed virtual Type get_KeyType();
    private static SortOrder[] GetDefaultSortOrders(int count);
    private static MemberInfo[] ParseSelector(Expression`1<Func`2<TEntity, TKey>> selector, IKeyInfoHelper helper);
}
public class NMemory.Indexes.ModularKeyInfoFactory : object {
    private IKeyInfoService service;
    protected ModularKeyInfoFactory(IKeyInfoService service);
    public ModularKeyInfoFactory(IDatabase database);
    public sealed virtual IKeyInfo`2<TEntity, TKey> Create(Expression`1<Func`2<TEntity, TKey>> keySelector);
}
public static class NMemory.Indexes.PrimitiveKeyComparer : object {
    public static int Compare(T x, T y, SortOrder sortOder);
    private static int EvaluateResult(int result, SortOrder sortOrder);
}
internal class NMemory.Indexes.PrimitiveKeyComparer`1 : object {
    private SortOrder sortOrder;
    public PrimitiveKeyComparer`1(SortOrder sortOrder);
    public sealed virtual int Compare(T x, T y);
}
public static class NMemory.Indexes.PrimitiveKeyInfo : object {
    public static PrimitiveKeyInfo`2<TEntity, TKey> Create(Expression`1<Func`2<TEntity, TKey>> keySelector);
    public static PrimitiveKeyInfo`2<TEntity, TKey> Create(Expression`1<Func`2<TEntity, TKey>> keySelector, SortOrder sortOrder);
}
public class NMemory.Indexes.PrimitiveKeyInfo`2 : KeyInfoBase`2<TEntity, TKey> {
    internal static IKeyInfoHelper KeyInfoHelper;
    private IKeyInfoHelper NMemory.Indexes.IKeyInfoHelperProvider.KeyInfoHelper { get; }
    public PrimitiveKeyInfo`2(Expression`1<Func`2<TEntity, TKey>> keySelector, SortOrder sortOrder);
    public PrimitiveKeyInfo`2(Expression`1<Func`2<TEntity, TKey>> keySelector);
    internal PrimitiveKeyInfo`2(MemberInfo member);
    private static PrimitiveKeyInfo`2();
    private sealed virtual override IKeyInfoHelper NMemory.Indexes.IKeyInfoHelperProvider.get_KeyInfoHelper();
}
public class NMemory.Indexes.PrimitiveKeyInfoHelper : object {
    private Type primitiveType;
    public PrimitiveKeyInfoHelper(Type primitiveType);
    public sealed virtual int GetMemberCount();
    public sealed virtual Expression CreateKeyFactoryExpression(Expression[] arguments);
    public sealed virtual Expression CreateKeyMemberSelectorExpression(Expression source, int index);
    public sealed virtual bool TryParseKeySelectorExpression(Expression keySelector, bool strict, MemberInfo[]& result);
}
public class NMemory.Indexes.RedBlackTreeIndexFactory : IndexFactoryBase {
    public virtual IIndex`2<TEntity, TKey> CreateIndex(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TKey> keyInfo);
    public virtual IUniqueIndex`2<TEntity, TUniqueKey> CreateUniqueIndex(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TUniqueKey> keyInfo);
}
public enum NMemory.Indexes.SortOrder : Enum {
    public int value__;
    public static SortOrder Ascending;
    public static SortOrder Descending;
}
public static class NMemory.Indexes.TupleKeyInfo : object {
    public static TupleKeyInfo`2<TEntity, TKey> Create(Expression`1<Func`2<TEntity, TKey>> keySelector, SortOrder[] sortOrders);
    public static TupleKeyInfo`2<TEntity, TKey> Create(Expression`1<Func`2<TEntity, TKey>> keySelector);
}
public class NMemory.Indexes.TupleKeyInfo`2 : KeyInfoBase`2<TEntity, TKey> {
    internal static IKeyInfoHelper KeyInfoHelper;
    private IKeyInfoHelper NMemory.Indexes.IKeyInfoHelperProvider.KeyInfoHelper { get; }
    public TupleKeyInfo`2(Expression`1<Func`2<TEntity, TKey>> keySelector, SortOrder[] sortOrders);
    public TupleKeyInfo`2(Expression`1<Func`2<TEntity, TKey>> keySelector);
    internal TupleKeyInfo`2(MemberInfo[] entityKeyMember);
    private static TupleKeyInfo`2();
    private sealed virtual override IKeyInfoHelper NMemory.Indexes.IKeyInfoHelperProvider.get_KeyInfoHelper();
}
public class NMemory.Indexes.TupleKeyInfoHelper : object {
    private static int largeTupleSize;
    private Type tupleType;
    public TupleKeyInfoHelper(Type tupleType);
    private static TupleKeyInfoHelper();
    public sealed virtual int GetMemberCount();
    public sealed virtual Expression CreateKeyFactoryExpression(Expression[] arguments);
    public sealed virtual Expression CreateKeyMemberSelectorExpression(Expression source, int index);
    public sealed virtual bool TryParseKeySelectorExpression(Expression keySelector, bool strict, MemberInfo[]& result);
    private static Expression CreateKeyFactoryExpression(Type tuple, Int32& memberIndex, Expression[] arguments);
    private static List`1<MemberInfo> TryParseSelectorCore(Expression expression, bool strict);
    private static List`1<MemberInfo> GetMemberInfoFromArguments(IList`1<Expression> arguments, bool ctorArgs, bool strict);
}
public class NMemory.Indexes.UniqueIndex`2 : IndexBase`2<TEntity, TUniqueKey> {
    private IUniqueDataStructure`2<TUniqueKey, TEntity> uniqueDataStructure;
    internal IDataStructure`2<TUniqueKey, TEntity> DataStructure { get; }
    public bool SupportsIntervalSearch { get; }
    internal UniqueIndex`2(ITable`1<TEntity> table, IKeyInfo`2<TEntity, TUniqueKey> keyInfo, IUniqueDataStructure`2<TUniqueKey, TEntity> dataStructure);
    public sealed virtual TEntity GetByUniqueIndex(TUniqueKey indexKeys);
    public virtual void Insert(TEntity item);
    public virtual void Delete(TEntity item);
    internal virtual IDataStructure`2<TUniqueKey, TEntity> get_DataStructure();
    public virtual IEnumerable`1<TEntity> Select(TUniqueKey value);
    public virtual IEnumerable`1<TEntity> SelectAll();
    public virtual bool get_SupportsIntervalSearch();
}
[ExtensionAttribute]
public static class NMemory.Linq.EnumerableEx : object {
    [ExtensionAttribute]
public static IEnumerable`1<TResult> JoinIndexed(IEnumerable`1<TOuter> outer, IIndex`2<TInner, TInnerKey> inner, Func`2<TOuter, TOuterKey> outerKeySelector, Func`2<TOuterKey, bool> isEmpty, Func`2<TOuterKey, TInnerKey> outerKeyToIndexKey, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupJoinIndexed(IEnumerable`1<TOuter> outer, IIndex`2<TInner, TInnerKey> inner, Func`2<TOuter, TOuterKey> outerKeySelector, Func`2<TOuterKey, bool> isEmpty, Func`2<TOuterKey, TInnerKey> outerKeyToIndexKey, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    private static IEnumerable`1<TResult> JoinIndexedCore(IEnumerable`1<TOuter> outer, IIndex`2<TInner, TInnerKey> inner, Func`2<TOuter, TOuterKey> outerKeySelector, Func`2<TOuterKey, bool> isEmpty, Func`2<TOuterKey, TInnerKey> outerKeyToIndexKey, Func`3<TOuter, TInner, TResult> resultSelector);
    private static IEnumerable`1<TResult> GroupJoinIndexedCore(IEnumerable`1<TOuter> outer, IIndex`2<TInner, TInnerKey> inner, Func`2<TOuter, TOuterKey> outerKeySelector, Func`2<TOuterKey, bool> isEmpty, Func`2<TOuterKey, TInnerKey> outerKeyToIndexKey, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
}
public class NMemory.Linq.Helpers.IndexedQueryable`1 : object {
    private IIndex index;
    private IQueryable`1<T> query;
    public Type ElementType { get; }
    public Expression Expression { get; }
    public IQueryProvider Provider { get; }
    public IIndex Index { get; }
    public IndexedQueryable`1(IQueryable`1<T> query, IIndex index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Type get_ElementType();
    public sealed virtual Expression get_Expression();
    public sealed virtual IQueryProvider get_Provider();
    public sealed virtual IIndex get_Index();
}
internal interface NMemory.Linq.IIndexedQueryable`1 {
    public IIndex Index { get; }
    public abstract virtual IIndex get_Index();
}
public interface NMemory.Linq.ITableQuery {
    public Type EntityType { get; }
    public IDatabase Database { get; }
    public abstract virtual Type get_EntityType();
    public abstract virtual IDatabase get_Database();
}
[ExtensionAttribute]
public static class NMemory.Linq.QueryableEx : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> Update(IQueryable`1<T> queryable, Expression`1<Func`2<T, T>> updater);
    [ExtensionAttribute]
public static IEnumerable`1<T> Update(IQueryable`1<T> queryable, Expression`1<Func`2<T, T>> updater, Transaction transaction);
    [ExtensionAttribute]
public static int Delete(IQueryable`1<T> queryable);
    [ExtensionAttribute]
public static int Delete(IQueryable`1<T> queryable, Transaction transaction);
    [ExtensionAttribute]
public static IEnumerable`1<T> Execute(IQueryable`1<T> queryable);
    [ExtensionAttribute]
public static IEnumerable`1<T> Execute(IQueryable`1<T> queryable, Transaction transaction);
    [ExtensionAttribute]
internal static IEnumerable`1<T> Execute(IQueryable`1<T> queryable, IDictionary`2<string, object> parameters);
    [ExtensionAttribute]
internal static IEnumerable`1<T> Execute(IQueryable`1<T> queryable, IDictionary`2<string, object> parameters, Transaction transaction);
    public static int Count(IQueryable`1<T> source);
    [ExtensionAttribute]
public static IQueryable`1<T> AsIndexedQueryable(IEnumerable`1<T> source, IIndex index);
}
public abstract class NMemory.Linq.TableQuery : object {
    private Expression expression;
    private IDatabase database;
    private IQueryProvider provider;
    public IDatabase Database { get; }
    public Type EntityType { get; }
    private Type System.Linq.IQueryable.ElementType { get; }
    private Expression System.Linq.IQueryable.Expression { get; }
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    internal TableQuery(IDatabase database, Expression expression, IQueryProvider provider);
    internal TableQuery(IDatabase database, Expression expression);
    internal TableQuery(IDatabase database);
    public sealed virtual IDatabase get_Database();
    public abstract virtual Type get_EntityType();
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NMemory.Linq.TableQuery`1 : TableQuery {
    private IExecutionPlan`1<IEnumerable`1<TEntity>> plan;
    private bool storeCompilation;
    public Type EntityType { get; }
    internal TableQuery`1(IDatabase database, Expression expression, IQueryProvider provider);
    public TableQuery`1(IDatabase database, Expression expression);
    public TableQuery`1(IDatabase database, Expression expression, bool storeCompilation);
    protected TableQuery`1(IDatabase database);
    protected TableQuery`1(IDatabase database, bool storeCompilation);
    public virtual Type get_EntityType();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TEntity> GetEnumerator();
    internal IEnumerator`1<TEntity> GetEnumerator(IDictionary`2<string, object> parameters, Transaction transaction);
    public void Compile();
    private IExecutionPlan`1<IEnumerable`1<TEntity>> CompilePlan();
}
public class NMemory.Linq.TableQueryProvider : object {
    private IDatabase database;
    public TableQueryProvider(IDatabase database);
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    public sealed virtual object Execute(Expression expression);
}
internal class NMemory.Linq.TableQueryWrapper`1 : object {
    private TableQuery`1<T> tableQuery;
    private Transaction transaction;
    private IDictionary`2<string, object> parameters;
    public TableQueryWrapper`1(TableQuery`1<T> tableQuery, IDictionary`2<string, object> parameters, Transaction transaction);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NMemory.Modularity.DefaultDatabaseComponentFactory : object {
    public virtual IConcurrencyManager CreateConcurrencyManager();
    public virtual IQueryCompiler CreateQueryCompiler();
    public virtual ICommandExecutor CreateQueryExecutor();
    public virtual ITransactionHandler CreateTransactionHandler();
    public virtual ILoggingPort CreateLoggingPort();
    public virtual IServiceProvider CreateServiceProvider();
}
public class NMemory.Modularity.DefaultDatabaseEngine : object {
    private IQueryCompiler compiler;
    private ICommandExecutor executor;
    private IConcurrencyManager concurrencyManager;
    private ITransactionHandler transactionHandler;
    private ILoggingPort loggingPort;
    private IServiceProvider serviceProvider;
    public IConcurrencyManager ConcurrencyManager { get; }
    public IQueryCompiler Compiler { get; }
    public ICommandExecutor Executor { get; }
    public ITransactionHandler TransactionHandler { get; }
    public ILoggingPort LoggingPort { get; }
    public IServiceProvider ServiceProvider { get; }
    public IEnumerable Components { get; }
    public DefaultDatabaseEngine(IDatabaseComponentFactory databaseEngineFactory, IDatabase database);
    public sealed virtual IConcurrencyManager get_ConcurrencyManager();
    public sealed virtual IQueryCompiler get_Compiler();
    public sealed virtual ICommandExecutor get_Executor();
    public sealed virtual ITransactionHandler get_TransactionHandler();
    public sealed virtual ILoggingPort get_LoggingPort();
    public sealed virtual IServiceProvider get_ServiceProvider();
    public sealed virtual IEnumerable get_Components();
}
public interface NMemory.Modularity.ICommandExecutor {
    public abstract virtual IEnumerator`1<T> ExecuteQuery(IExecutionPlan`1<IEnumerable`1<T>> plan, IExecutionContext context);
    public abstract virtual T ExecuteQuery(IExecutionPlan`1<T> plan, IExecutionContext context);
    public abstract virtual void ExecuteInsert(T entity, IExecutionContext context);
    public abstract virtual IEnumerable`1<T> ExecuteDelete(IExecutionPlan`1<IEnumerable`1<T>> plan, IExecutionContext context);
    public abstract virtual IEnumerable`1<T> ExecuteUpdater(IExecutionPlan`1<IEnumerable`1<T>> plan, IUpdater`1<T> updater, IExecutionContext context);
}
public interface NMemory.Modularity.IConcurrencyManager {
    public abstract virtual void AcquireTableWriteLock(ITable table, Transaction transaction);
    public abstract virtual void ReleaseTableWriteLock(ITable table, Transaction transaction);
    public abstract virtual void AcquireRelatedTableLock(ITable table, Transaction transaction);
    public abstract virtual void AcquireTableReadLock(ITable table, Transaction transaction);
    public abstract virtual void ReleaseTableReadLock(ITable table, Transaction transaction);
    public abstract virtual void ReleaseAllLocks(Transaction transaction);
}
public interface NMemory.Modularity.IDatabase {
    public TableCollection Tables { get; }
    public StoredProcedureCollection StoredProcedures { get; }
    public IDatabaseEngine DatabaseEngine { get; }
    public abstract virtual TableCollection get_Tables();
    public abstract virtual StoredProcedureCollection get_StoredProcedures();
    public abstract virtual IDatabaseEngine get_DatabaseEngine();
}
public interface NMemory.Modularity.IDatabaseComponent {
    public abstract virtual void Initialize(IDatabase database);
}
public interface NMemory.Modularity.IDatabaseComponentFactory {
    public abstract virtual IConcurrencyManager CreateConcurrencyManager();
    public abstract virtual IQueryCompiler CreateQueryCompiler();
    public abstract virtual ICommandExecutor CreateQueryExecutor();
    public abstract virtual ITransactionHandler CreateTransactionHandler();
    public abstract virtual ILoggingPort CreateLoggingPort();
    public abstract virtual IServiceProvider CreateServiceProvider();
}
public interface NMemory.Modularity.IDatabaseEngine {
    public IConcurrencyManager ConcurrencyManager { get; }
    public IQueryCompiler Compiler { get; }
    public ICommandExecutor Executor { get; }
    public ITransactionHandler TransactionHandler { get; }
    public ILoggingPort LoggingPort { get; }
    public IServiceProvider ServiceProvider { get; }
    public IEnumerable Components { get; }
    public abstract virtual IConcurrencyManager get_ConcurrencyManager();
    public abstract virtual IQueryCompiler get_Compiler();
    public abstract virtual ICommandExecutor get_Executor();
    public abstract virtual ITransactionHandler get_TransactionHandler();
    public abstract virtual ILoggingPort get_LoggingPort();
    public abstract virtual IServiceProvider get_ServiceProvider();
    public abstract virtual IEnumerable get_Components();
}
public interface NMemory.Modularity.IExtensible {
}
public interface NMemory.Modularity.ILoggingPort {
    public abstract virtual void Send(Message msg);
}
public interface NMemory.Modularity.IQueryCompiler {
    public abstract virtual IExecutionPlan`1<T> Compile(Expression expression);
}
public interface NMemory.Modularity.IServiceProvider {
    public abstract virtual T GetService();
}
public interface NMemory.Modularity.ITableCatalog {
    public abstract virtual void RegisterTable(ITable table);
}
public interface NMemory.Modularity.ITransactionHandler {
    public abstract virtual ITransactionLog GetTransactionLog(Transaction transaction);
    public abstract virtual void Commit(Transaction transaction);
    public abstract virtual void Rollback(Transaction transaction);
}
public static class NMemory.NMemoryManager : object {
    [CompilerGeneratedAttribute]
private static bool <UseDefaultForNotNullable>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <UseTimestampBytesReverse>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <DisableObjectCloning>k__BackingField;
    public static bool UseDefaultForNotNullable { get; public set; }
    public static bool UseTimestampBytesReverse { get; public set; }
    public static bool DisableObjectCloning { get; public set; }
    [CompilerGeneratedAttribute]
public static bool get_UseDefaultForNotNullable();
    [CompilerGeneratedAttribute]
public static void set_UseDefaultForNotNullable(bool value);
    [CompilerGeneratedAttribute]
public static bool get_UseTimestampBytesReverse();
    [CompilerGeneratedAttribute]
public static void set_UseTimestampBytesReverse(bool value);
    [CompilerGeneratedAttribute]
public static bool get_DisableObjectCloning();
    [CompilerGeneratedAttribute]
public static void set_DisableObjectCloning(bool value);
}
public class NMemory.Services.AnonymousTypeKeyInfoService : object {
    public sealed virtual bool TryCreateKeyInfo(Expression`1<Func`2<TEntity, TKey>> keySelector, IKeyInfo`2& result);
    public sealed virtual bool TryCreateKeyInfoHelper(Type keyType, IKeyInfoHelper& result);
}
internal class NMemory.Services.CombinedKeyInfoService : object {
    private IKeyInfoService[] factories;
    public static CombinedKeyInfoService Empty { get; }
    private CombinedKeyInfoService(CombinedKeyInfoService existing, IKeyInfoService addition);
    public static CombinedKeyInfoService get_Empty();
    public sealed virtual bool TryCreateKeyInfo(Expression`1<Func`2<TEntity, TKey>> keySelector, IKeyInfo`2& result);
    public sealed virtual bool TryCreateKeyInfoHelper(Type keyType, IKeyInfoHelper& result);
    public CombinedKeyInfoService Add(IKeyInfoService factory);
}
public interface NMemory.Services.Contracts.IEntityService {
    public abstract virtual void CloneProperties(T source, T destination);
}
public interface NMemory.Services.Contracts.IKeyInfoService {
    public abstract virtual bool TryCreateKeyInfo(Expression`1<Func`2<TEntity, TKey>> keySelector, IKeyInfo`2& result);
    public abstract virtual bool TryCreateKeyInfoHelper(Type keyType, IKeyInfoHelper& result);
}
public interface NMemory.Services.Contracts.ITableService {
    public abstract virtual Table`2<TEntity, TPrimaryKey> CreateTable(IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, IDatabase database);
    public abstract virtual Table`2<TEntity, TPrimaryKey> CreateTable(IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, IDatabase database, object tableInfo);
}
public class NMemory.Services.DefaultEntityService : object {
    public sealed virtual void CloneProperties(T source, T destination);
}
internal static class NMemory.Services.DefaultServiceConfigurations : object {
    public static IKeyInfoService CreateDefaultKeyInfoService();
}
public class NMemory.Services.DefaultServiceProvider : ServiceProviderBase {
}
internal class NMemory.Services.DefaultTableService : object {
    public sealed virtual Table`2<TEntity, TPrimaryKey> CreateTable(IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, IDatabase database, object tableInfo);
    public sealed virtual Table`2<TEntity, TPrimaryKey> CreateTable(IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, IDatabase database);
}
public class NMemory.Services.PrimitiveKeyInfoService : object {
    public sealed virtual bool TryCreateKeyInfo(Expression`1<Func`2<TEntity, TKey>> keySelector, IKeyInfo`2& result);
    public sealed virtual bool TryCreateKeyInfoHelper(Type keyType, IKeyInfoHelper& result);
    private static bool ValidateType(Type type);
}
public abstract class NMemory.Services.ServiceProviderBase : object {
    private Dictionary`2<Type, object> services;
    private IDatabase database;
    public sealed virtual T GetService();
    public sealed virtual void Initialize(IDatabase database);
    protected void Replace(T service);
    protected void Add(T service);
    protected bool Remove();
    protected void Combine(T service);
    protected void Combine(T[] services);
    private T Combine(T existing, T addition);
    private IKeyInfoService Combine(IKeyInfoService existing, IKeyInfoService addition);
}
public class NMemory.Services.TupleKeyInfoService : object {
    public sealed virtual bool TryCreateKeyInfo(Expression`1<Func`2<TEntity, TKey>> keySelector, IKeyInfo`2& result);
    public sealed virtual bool TryCreateKeyInfoHelper(Type keyType, IKeyInfoHelper& result);
}
public interface NMemory.StoredProcedures.IParameter {
    public string Name { get; }
    public Type Type { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
}
public interface NMemory.StoredProcedures.ISharedStoredProcedure {
    public IList`1<ParameterDescription> Parameters { get; }
    public abstract virtual IList`1<ParameterDescription> get_Parameters();
    public abstract virtual IEnumerable Execute(IDatabase database, IDictionary`2<string, object> parameters);
    public abstract virtual IEnumerable Execute(IDatabase database, IDictionary`2<string, object> parameters, Transaction transaction);
}
public interface NMemory.StoredProcedures.ISharedStoredProcedure`1 {
    public abstract virtual IEnumerable`1<TEntity> Execute(IDatabase database, IDictionary`2<string, object> parameters);
    public abstract virtual IEnumerable`1<TEntity> Execute(IDatabase database, IDictionary`2<string, object> parameters, Transaction transaction);
}
public interface NMemory.StoredProcedures.IStoredProcedure {
    public IList`1<ParameterDescription> Parameters { get; }
    public abstract virtual IList`1<ParameterDescription> get_Parameters();
    public abstract virtual IEnumerable Execute(IDictionary`2<string, object> parameters);
    public abstract virtual IEnumerable Execute(IDictionary`2<string, object> parameters, Transaction transaction);
}
public interface NMemory.StoredProcedures.IStoredProcedure`1 {
    public abstract virtual IEnumerable`1<T> Execute(IDictionary`2<string, object> parameters);
    public abstract virtual IEnumerable`1<T> Execute(IDictionary`2<string, object> parameters, Transaction transaction);
}
public class NMemory.StoredProcedures.Parameter`1 : object {
    private string name;
    public string Name { get; }
    public Type Type { get; }
    public Parameter`1(string name);
    public sealed virtual string get_Name();
    public sealed virtual Type get_Type();
    public static T op_Implicit(Parameter`1<T> parameter);
}
public class NMemory.StoredProcedures.ParameterDescription : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Name { get; private set; }
    public Type Type { get; private set; }
    public ParameterDescription(string name, Type type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
}
public class NMemory.StoredProcedures.SharedStoredProcedure`2 : StoredProcedureBase {
    private Expression expression;
    public SharedStoredProcedure`2(Expression`1<Func`2<TDatabase, IQueryable`1<TResult>>> expression);
    public sealed virtual IEnumerable`1<TResult> Execute(IDatabase database, IDictionary`2<string, object> parameters);
    public sealed virtual IEnumerable`1<TResult> Execute(IDatabase database, IDictionary`2<string, object> parameters, Transaction transaction);
    private sealed virtual override IEnumerable NMemory.StoredProcedures.ISharedStoredProcedure.Execute(IDatabase database, IDictionary`2<string, object> parameters);
    private sealed virtual override IEnumerable NMemory.StoredProcedures.ISharedStoredProcedure.Execute(IDatabase database, IDictionary`2<string, object> parameters, Transaction transaction);
}
public class NMemory.StoredProcedures.StoredProcedure`1 : StoredProcedureBase {
    private TableQuery`1<T> query;
    public StoredProcedure`1(IQueryable`1<T> query, bool precompile);
    public sealed virtual IEnumerable`1<T> Execute(IDictionary`2<string, object> parameters);
    public sealed virtual IEnumerable`1<T> Execute(IDictionary`2<string, object> parameters, Transaction transaction);
    private sealed virtual override IEnumerable NMemory.StoredProcedures.IStoredProcedure.Execute(IDictionary`2<string, object> parameters);
    private sealed virtual override IEnumerable NMemory.StoredProcedures.IStoredProcedure.Execute(IDictionary`2<string, object> parameters, Transaction transaction);
}
public class NMemory.StoredProcedures.StoredProcedureBase : object {
    private List`1<ParameterDescription> parameters;
    private IList`1<ParameterDescription> protectedParameters;
    public IList`1<ParameterDescription> Parameters { get; }
    public sealed virtual IList`1<ParameterDescription> get_Parameters();
    protected void SetParameters(IEnumerable`1<ParameterDescription> parameters);
    protected void VerifyParameters(IDictionary`2<string, object> parameters);
    private static void VerifyParameterValue(ParameterDescription parameter, object value);
}
public class NMemory.StoredProcedures.StoredProcedureCollection : object {
    private WeakReference database;
    private List`1<object> storedProcedures;
    private Database Database { get; }
    internal StoredProcedureCollection(Database database);
    private Database get_Database();
    public IStoredProcedure`1<T> Create(IQueryable`1<T> query);
    public IStoredProcedure`1<T> Create(IQueryable`1<T> query, bool precompiled);
    private void ValidateQuery(IQueryable`1<T> query);
}
public class NMemory.Tables.ConstraintCollection`1 : object {
    private List`1<IConstraint`1<T>> constraints;
    public void Apply(T entity, IExecutionContext context, ITable table);
    public void Add(IConstraint`1<T> constraint);
    public void Add(IConstraintFactory`1<T> constraintFactory);
}
public class NMemory.Tables.DefaultTable`2 : Table`2<TEntity, TPrimaryKey> {
    protected ICommandExecutor Executor { get; }
    protected IQueryCompiler Compiler { get; }
    public DefaultTable`2(IDatabase database, IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, object tableInfo);
    protected virtual void InsertCore(TEntity entity, Transaction transaction);
    protected virtual IEnumerable`1<TEntity> UpdateCore(Expression expression, IUpdater`1<TEntity> updater, Transaction transaction);
    protected virtual int DeleteCore(Expression expression, Transaction transaction);
    protected ICommandExecutor get_Executor();
    protected IQueryCompiler get_Compiler();
}
internal class NMemory.Tables.EntityPropertyChangeDetector`1 : object {
    public static EntityPropertyChangeDetector`1<TEntity> Instance;
    private Func`3<TEntity, TEntity, List`1<PropertyInfo>> entityPropertyChangeDetector;
    private static EntityPropertyChangeDetector`1();
    public List`1<PropertyInfo> GetChanges(TEntity originalEntity, TEntity newEntity);
}
internal class NMemory.Tables.EntityPropertyCloner`1 : object {
    public static EntityPropertyCloner`1<TEntity> Instance;
    private Action`2<TEntity, TEntity> entityPropertyCloner;
    private static EntityPropertyCloner`1();
    public void Clone(TEntity source, TEntity destination);
}
internal interface NMemory.Tables.IBulkTable`1 {
    public abstract virtual IEnumerable`1<TEntity> Update(TableQuery`1<TEntity> query, Expression`1<Func`2<TEntity, TEntity>> updater, Transaction transaction);
    public abstract virtual int Delete(TableQuery`1<TEntity> query, Transaction transaction);
}
internal class NMemory.Tables.IdentityField`1 : object {
    private Func`2<TEntity, long> identityGetter;
    private DynamicPropertySetter`1<TEntity> identitySetter;
    private IdentitySpecification`1<TEntity> identitySpecification;
    internal long nextIdentity;
    private Type identityType;
    internal IdentityField`1(IdentitySpecification`1<TEntity> identitySpecification);
    internal void InitializeBasedOnData(IEnumerable`1<TEntity> initialEntities, bool forceMinValue);
    internal void Generate(TEntity entity);
}
public class NMemory.Tables.IdentitySpecification`1 : object {
    [CompilerGeneratedAttribute]
private int <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TEntity, long>> <IdentityColumn>k__BackingField;
    public int Seed { get; private set; }
    public int Increment { get; internal set; }
    public Expression`1<Func`2<TEntity, long>> IdentityColumn { get; private set; }
    public IdentitySpecification`1(Expression`1<Func`2<TEntity, long>> identityColumn, int seed, int increment);
    [CompilerGeneratedAttribute]
public int get_Seed();
    [CompilerGeneratedAttribute]
private void set_Seed(int value);
    [CompilerGeneratedAttribute]
public int get_Increment();
    [CompilerGeneratedAttribute]
internal void set_Increment(int value);
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<TEntity, long>> get_IdentityColumn();
    [CompilerGeneratedAttribute]
private void set_IdentityColumn(Expression`1<Func`2<TEntity, long>> value);
}
public interface NMemory.Tables.IReflectionTable {
    public abstract virtual void Insert(object entity);
    public abstract virtual void Update(object entity);
    public abstract virtual void Delete(object entity);
}
public interface NMemory.Tables.IRelation {
    public ITable PrimaryTable { get; }
    public ITable ForeignTable { get; }
    public IIndex PrimaryIndex { get; }
    public IIndex ForeignIndex { get; }
    public bool IsEnabled { get; public set; }
    public RelationOptions Options { get; }
    public abstract virtual ITable get_PrimaryTable();
    public abstract virtual ITable get_ForeignTable();
    public abstract virtual IIndex get_PrimaryIndex();
    public abstract virtual IIndex get_ForeignIndex();
    public abstract virtual bool get_IsEnabled();
    public abstract virtual void set_IsEnabled(bool value);
    public abstract virtual RelationOptions get_Options();
}
public interface NMemory.Tables.IRelationContraint {
    public MemberInfo PrimaryField { get; }
    public MemberInfo ForeignField { get; }
    public abstract virtual MemberInfo get_PrimaryField();
    public abstract virtual MemberInfo get_ForeignField();
}
internal interface NMemory.Tables.IRelationInternal {
    public abstract virtual void ValidateEntity(object foreign);
    public abstract virtual void ValidateAll();
    public abstract virtual IEnumerable`1<object> GetReferringEntities(object primary);
    public abstract virtual IEnumerable`1<object> GetReferredEntities(object foreign);
    public abstract virtual void CascadedDelete(HashSet`1<object> entities, IDeletePrimitive delete);
}
public interface NMemory.Tables.ITable {
    public IDatabase Database { get; }
    public Type EntityType { get; }
    public IIndex PrimaryKeyIndex { get; }
    public IEnumerable`1<IIndex> Indexes { get; }
    public long Count { get; }
    public abstract virtual IDatabase get_Database();
    public abstract virtual Type get_EntityType();
    public abstract virtual IIndex get_PrimaryKeyIndex();
    public abstract virtual IEnumerable`1<IIndex> get_Indexes();
    [CompilerGeneratedAttribute]
public abstract virtual void add_IndexChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_IndexChanged(EventHandler value);
    public abstract virtual long get_Count();
}
public interface NMemory.Tables.ITable`1 {
    public IUniqueIndex`1<TEntity> PrimaryKeyIndex { get; }
    public ConstraintCollection`1<TEntity> Contraints { get; }
    public abstract virtual IUniqueIndex`1<TEntity> get_PrimaryKeyIndex();
    public abstract virtual void Insert(TEntity entity);
    public abstract virtual void Insert(TEntity entity, Transaction transaction);
    public abstract virtual void Update(TEntity entity);
    public abstract virtual void Update(TEntity entity, Transaction transaction);
    public abstract virtual void Delete(TEntity entity);
    public abstract virtual void Delete(TEntity entity, Transaction transaction);
    public abstract virtual ConstraintCollection`1<TEntity> get_Contraints();
}
public interface NMemory.Tables.ITable`2 {
    public IUniqueIndex`2<TEntity, TPrimaryKey> PrimaryKeyIndex { get; }
    public abstract virtual IUniqueIndex`2<TEntity, TPrimaryKey> get_PrimaryKeyIndex();
    public abstract virtual void Update(TPrimaryKey key, TEntity entity);
    public abstract virtual void Update(TPrimaryKey key, TEntity entity, Transaction transaction);
    public abstract virtual void Delete(TPrimaryKey key);
    public abstract virtual void Delete(TPrimaryKey key, Transaction transaction);
}
public class NMemory.Tables.Relation`4 : object {
    private bool isEnabled;
    private IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex;
    private IIndex`2<TForeign, TForeignKey> foreignIndex;
    private Func`2<TForeignKey, TPrimaryKey> convertForeignToPrimary;
    private Func`2<TPrimaryKey, TForeignKey> convertPrimaryToForeign;
    private RelationOptions options;
    public bool IsEnabled { get; public set; }
    public RelationOptions Options { get; }
    private ITable NMemory.Tables.IRelation.PrimaryTable { get; }
    private ITable NMemory.Tables.IRelation.ForeignTable { get; }
    private IIndex NMemory.Tables.IRelation.PrimaryIndex { get; }
    private IIndex NMemory.Tables.IRelation.ForeignIndex { get; }
    internal Relation`4(IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex, IIndex`2<TForeign, TForeignKey> foreignIndex, Func`2<TForeignKey, TPrimaryKey> foreignToPrimary, Func`2<TPrimaryKey, TForeignKey> primaryToForeign, RelationOptions options);
    public sealed virtual bool get_IsEnabled();
    public sealed virtual void set_IsEnabled(bool value);
    public sealed virtual RelationOptions get_Options();
    private sealed virtual override ITable NMemory.Tables.IRelation.get_PrimaryTable();
    private sealed virtual override ITable NMemory.Tables.IRelation.get_ForeignTable();
    private sealed virtual override IIndex NMemory.Tables.IRelation.get_PrimaryIndex();
    private sealed virtual override IIndex NMemory.Tables.IRelation.get_ForeignIndex();
    private sealed virtual override void NMemory.Tables.IRelationInternal.ValidateEntity(object foreign);
    private sealed virtual override void NMemory.Tables.IRelationInternal.ValidateAll();
    private sealed virtual override IEnumerable`1<object> NMemory.Tables.IRelationInternal.GetReferringEntities(object primary);
    private sealed virtual override IEnumerable`1<object> NMemory.Tables.IRelationInternal.GetReferredEntities(object foreign);
    private void ValidateAllCore();
    private void ValidateEntityCore(TForeign foreign);
    private sealed virtual override void NMemory.Tables.IRelationInternal.CascadedDelete(HashSet`1<object> entities, IDeletePrimitive delete);
}
public class NMemory.Tables.RelationConstraint : object {
    [CompilerGeneratedAttribute]
private MemberInfo <PrimaryField>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <ForeignField>k__BackingField;
    public MemberInfo PrimaryField { get; private set; }
    public MemberInfo ForeignField { get; private set; }
    public RelationConstraint(MemberInfo primaryField, MemberInfo foreignField);
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_PrimaryField();
    [CompilerGeneratedAttribute]
private void set_PrimaryField(MemberInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_ForeignField();
    [CompilerGeneratedAttribute]
private void set_ForeignField(MemberInfo value);
}
public class NMemory.Tables.RelationConstraint`3 : object {
    [CompilerGeneratedAttribute]
private MemberInfo <PrimaryField>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <ForeignField>k__BackingField;
    public MemberInfo PrimaryField { get; private set; }
    public MemberInfo ForeignField { get; private set; }
    public RelationConstraint`3(Expression`1<Func`2<TPrimary, TField>> primaryField, Expression`1<Func`2<TForeign, TField>> foreignField);
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_PrimaryField();
    [CompilerGeneratedAttribute]
private void set_PrimaryField(MemberInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_ForeignField();
    [CompilerGeneratedAttribute]
private void set_ForeignField(MemberInfo value);
}
internal class NMemory.Tables.RelationGroup : object {
    private List`1<IRelationInternal> referring;
    private List`1<IRelationInternal> referred;
    private ReadOnlyCollection`1<IRelationInternal> referringReadOnly;
    private ReadOnlyCollection`1<IRelationInternal> referredReadOnly;
    public IList`1<IRelationInternal> Referring { get; }
    public IList`1<IRelationInternal> Referred { get; }
    public ReadOnlyCollection`1<IRelationInternal> ReferringReadOnly { get; }
    public ReadOnlyCollection`1<IRelationInternal> ReferredReadOnly { get; }
    public IList`1<IRelationInternal> get_Referring();
    public IList`1<IRelationInternal> get_Referred();
    public ReadOnlyCollection`1<IRelationInternal> get_ReferringReadOnly();
    public ReadOnlyCollection`1<IRelationInternal> get_ReferredReadOnly();
}
public static class NMemory.Tables.RelationKeyConverterFactory : object {
    public static Func`2<TPrimaryKey, TForeignKey> CreatePrimaryToForeignConverter(IKeyInfo`1<TPrimaryKey> primaryKey, IKeyInfo`1<TForeignKey> foreignKey, IRelationContraint[] constraints);
    public static Func`2<TForeignKey, TPrimaryKey> CreateForeignToPrimaryConverter(IKeyInfo`1<TPrimaryKey> primaryKey, IKeyInfo`1<TForeignKey> foreignKey, IRelationContraint[] constraints);
    private static Func`2<TFrom, TTo> CreateConversion(IKeyInfo`1<TFrom> fromKeyInfo, IKeyInfo`1<TTo> toKeyInfo, Int32[] mapping);
    private static Int32[] CreateMapping(IKeyInfo`1<TFrom> primaryKeyInfo, IKeyInfo`1<TTo> foreignKeyInfo, IRelationContraint[] constraints, bool invert);
    private static IKeyInfoHelper GetKeyInfoHelper(IKeyInfo keyInfo);
}
public class NMemory.Tables.RelationOptions : object {
    private bool cascadedDeletion;
    public bool CascadedDeletion { get; }
    public RelationOptions(bool cascadedDeletion);
    public bool get_CascadedDeletion();
}
public abstract class NMemory.Tables.Table`2 : TableQuery`1<TEntity> {
    private IdentityField`1<TEntity> identityField;
    private IdentitySpecification`1<TEntity> originalIdentitySpecification;
    private IUniqueIndex`2<TEntity, TPrimaryKey> primaryKeyIndex;
    private IList`1<IIndex`1<TEntity>> indexes;
    private IEntityService entityService;
    private ConstraintCollection`1<TEntity> constraints;
    private static int counter;
    private int id;
    [CompilerGeneratedAttribute]
private object <TableInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler IndexChanged;
    public object TableInfo { get; public set; }
    [DebuggerBrowsableAttribute("0")]
public long Count { get; }
    public IEnumerable`1<IIndex> Indexes { get; }
    public ConstraintCollection`1<TEntity> Contraints { get; }
    public IUniqueIndex`2<TEntity, TPrimaryKey> PrimaryKeyIndex { get; }
    private IUniqueIndex`1<TEntity> NMemory.Tables.ITable<TEntity>.PrimaryKeyIndex { get; }
    private IIndex NMemory.Tables.ITable.PrimaryKeyIndex { get; }
    protected IKeyInfoHelper KeyInfoHelper { get; }
    protected IEntityService EntityService { get; }
    public Table`2(IDatabase database, IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, object tableInfo);
    [CompilerGeneratedAttribute]
public object get_TableInfo();
    [CompilerGeneratedAttribute]
public void set_TableInfo(object value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_IndexChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_IndexChanged(EventHandler value);
    public sealed virtual void Insert(TEntity entity);
    public sealed virtual void Insert(TEntity entity, Transaction transaction);
    protected abstract virtual void InsertCore(TEntity entity, Transaction transaction);
    public sealed virtual void Update(TEntity entity);
    public sealed virtual void Update(TEntity entity, Transaction transaction);
    public sealed virtual void Update(TPrimaryKey key, TEntity entity);
    internal IEnumerable`1<TEntity> Execute(IQueryable`1<TEntity> query, Transaction transaction);
    public sealed virtual void Update(TPrimaryKey key, TEntity entity, Transaction transaction);
    private sealed virtual override IEnumerable`1<TEntity> NMemory.Tables.IBulkTable<TEntity>.Update(TableQuery`1<TEntity> query, Expression`1<Func`2<TEntity, TEntity>> updater, Transaction transaction);
    private IEnumerable`1<TEntity> Update(IQueryable`1<TEntity> query, IUpdater`1<TEntity> updater, Transaction transaction);
    protected abstract virtual IEnumerable`1<TEntity> UpdateCore(Expression expression, IUpdater`1<TEntity> updater, Transaction transaction);
    public sealed virtual void Delete(TEntity entity);
    public sealed virtual void Delete(TEntity entity, Transaction transaction);
    public sealed virtual void Delete(TPrimaryKey key);
    public sealed virtual void Delete(TPrimaryKey key, Transaction transaction);
    private sealed virtual override int NMemory.Tables.IBulkTable<TEntity>.Delete(TableQuery`1<TEntity> query, Transaction transaction);
    private int Delete(IQueryable`1<TEntity> query, Transaction transaction);
    protected abstract virtual int DeleteCore(Expression expression, Transaction transaction);
    public void SetIdentity(Nullable`1<int> seed, Nullable`1<int> increment);
    public sealed virtual long get_Count();
    internal long GetCount();
    private void OnIndexChanged();
    public IIndex`2<TEntity, TKey> CreateIndex(IIndexFactory indexFactory, Expression`1<Func`2<TEntity, TKey>> keySelector);
    public IIndex`2<TEntity, TKey> CreateIndex(IIndexFactory indexFactory, IKeyInfo`2<TEntity, TKey> keyInfo);
    public IUniqueIndex`2<TEntity, TUniqueKey> CreateUniqueIndex(IIndexFactory indexFactory, Expression`1<Func`2<TEntity, TUniqueKey>> keySelector);
    public IUniqueIndex`2<TEntity, TUniqueKey> CreateUniqueIndex(IIndexFactory indexFactory, IKeyInfo`2<TEntity, TUniqueKey> keyInfo);
    public sealed virtual IEnumerable`1<IIndex> get_Indexes();
    public sealed virtual ConstraintCollection`1<TEntity> get_Contraints();
    public sealed virtual IUniqueIndex`2<TEntity, TPrimaryKey> get_PrimaryKeyIndex();
    private sealed virtual override IUniqueIndex`1<TEntity> NMemory.Tables.ITable<TEntity>.get_PrimaryKeyIndex();
    private sealed virtual override IIndex NMemory.Tables.ITable.get_PrimaryKeyIndex();
    private sealed virtual override void NMemory.Tables.IReflectionTable.Update(object entity);
    private sealed virtual override void NMemory.Tables.IReflectionTable.Insert(object entity);
    private sealed virtual override void NMemory.Tables.IReflectionTable.Delete(object entity);
    public virtual string ToString();
    protected virtual TEntity CreateStoredEntity();
    protected virtual void GenerateIdentityFieldValue(TEntity entity);
    protected void CalculateIdentityFeed(bool forceMinValue);
    protected IQueryable`1<TEntity> CreateQuery(TPrimaryKey key);
    protected IKeyInfoHelper get_KeyInfoHelper();
    protected IEntityService get_EntityService();
    protected virtual bool SupportsPropertyType(PropertyInfo prop);
    private void VerifyType();
    private void RegisterTimestampConstraints();
    public void RestoreIdentityField();
}
public class NMemory.Tables.TableCollection : object {
    private IDatabase database;
    private List`1<ITable> tables;
    private List`1<IRelation> relations;
    private Dictionary`2<ITable, RelationGroup> relationMapping;
    private HashSet`1<Type> entityTypes;
    internal TableCollection(IDatabase database);
    public IList`1<ITable> GetAllTables();
    public IList`1<IRelation> GetAllRelations();
    public Table`2<TEntity, TPrimaryKey> Create(Expression`1<Func`2<TEntity, TPrimaryKey>> primaryKey, IdentitySpecification`1<TEntity> identitySpecification);
    public Table`2<TEntity, TPrimaryKey> Create(Expression`1<Func`2<TEntity, TPrimaryKey>> primaryKey);
    public Table`2<TEntity, TPrimaryKey> Create(IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, object tableInfo);
    public Relation`4<TPrimary, TPrimaryKey, TForeign, TForeignKey> CreateRelation(IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex, IIndex`2<TForeign, TForeignKey> foreignIndex, Func`2<TForeignKey, TPrimaryKey> convertForeignToPrimary, Func`2<TPrimaryKey, TForeignKey> convertPrimaryToForeign);
    public Relation`4<TPrimary, TPrimaryKey, TForeign, TForeignKey> CreateRelation(IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex, IIndex`2<TForeign, TForeignKey> foreignIndex, Func`2<TForeignKey, TPrimaryKey> convertForeignToPrimary, Func`2<TPrimaryKey, TForeignKey> convertPrimaryToForeign, RelationOptions relationOptions);
    public ITable FindTable(Type entityType);
    internal IList`1<IRelationInternal> GetReferringRelations(ITable primaryTable);
    internal IList`1<IRelationInternal> GetReferredRelations(ITable foreignTable);
    internal IList`1<IRelationInternal> GetReferringRelations(IIndex primaryIndex);
    internal IList`1<IRelationInternal> GetReferredRelations(IIndex foreignIndex);
    internal bool IsEntityType();
    private void RegisterTable(ITable table);
}
internal static class NMemory.Transactions.AmbientTransactionStore : object {
    private static ConcurrentDictionary`2<string, Transaction> transactions;
    private static AmbientTransactionStore();
    public static Transaction GetAmbientEnlistedTransaction(Transaction ambient);
    public static void RemoveTransaction(Transaction ambient);
    private static Transaction CreateTransaction(Transaction ambient);
    private static void OnAmbientTransactionCompleted(object sender, TransactionEventArgs e);
}
public enum NMemory.Transactions.IsolationLevels : Enum {
    public int value__;
    public static IsolationLevels ReadCommited;
    public static IsolationLevels RepetableRead;
}
internal class NMemory.Transactions.Logs.AtomicLogScope : object {
    private Transaction transaction;
    private ITransactionLog log;
    private int logPosition;
    private bool completed;
    public ITransactionLog Log { get; }
    public AtomicLogScope(Transaction transaction, IDatabase database);
    public ITransactionLog get_Log();
    public void Complete();
    public sealed virtual void Dispose();
}
internal class NMemory.Transactions.Logs.IndexDeleteTransactionLogItem`1 : IndexTransactionLogItemBase`1<TEntity> {
    public IndexDeleteTransactionLogItem`1(IIndex`1<TEntity> index, TEntity entity);
    public virtual void Undo();
}
internal class NMemory.Transactions.Logs.IndexInsertTransactionLogItem`1 : IndexTransactionLogItemBase`1<TEntity> {
    public IndexInsertTransactionLogItem`1(IIndex`1<TEntity> index, TEntity entity);
    public virtual void Undo();
}
internal abstract class NMemory.Transactions.Logs.IndexTransactionLogItemBase`1 : object {
    private IIndex`1<TEntity> index;
    private TEntity entity;
    protected IIndex`1<TEntity> Index { get; }
    protected TEntity Entity { get; }
    public IndexTransactionLogItemBase`1(IIndex`1<TEntity> index, TEntity entity);
    protected IIndex`1<TEntity> get_Index();
    protected TEntity get_Entity();
    public abstract virtual void Undo();
}
public interface NMemory.Transactions.Logs.ITransactionLog {
    public int CurrentPosition { get; }
    public abstract virtual int get_CurrentPosition();
    public abstract virtual void Rollback();
    public abstract virtual void RollbackTo(int position);
    public abstract virtual void Write(ITransactionLogItem item);
}
public interface NMemory.Transactions.Logs.ITransactionLogItem {
    public abstract virtual void Undo();
}
public class NMemory.Transactions.Logs.TransactionLog : object {
    private List`1<ITransactionLogItem> logItems;
    public int CurrentPosition { get; }
    public sealed virtual int get_CurrentPosition();
    public sealed virtual void Rollback();
    public sealed virtual void RollbackTo(int position);
    public sealed virtual void Write(ITransactionLogItem item);
    public void Release();
}
[ExtensionAttribute]
internal static class NMemory.Transactions.Logs.TransactionLogExtensions : object {
    [ExtensionAttribute]
public static void WriteIndexInsert(ITransactionLog log, IIndex`1<TEntity> index, TEntity entity);
    [ExtensionAttribute]
public static void WriteIndexDelete(ITransactionLog log, IIndex`1<TEntity> index, TEntity entity);
    [ExtensionAttribute]
public static void WriteEntityUpdate(ITransactionLog log, Action`2<TEntity, TEntity> propertyCloner, TEntity storedEntity, TEntity oldEntity);
}
internal class NMemory.Transactions.Logs.UpdateEntityLogItem`1 : object {
    private TEntity storedEntity;
    private TEntity oldEntity;
    private Action`2<TEntity, TEntity> propertyCloner;
    public UpdateEntityLogItem`1(Action`2<TEntity, TEntity> propertyCloner, TEntity storedEntity, TEntity oldEntity);
    public sealed virtual void Undo();
}
public class NMemory.Transactions.Transaction : object {
    private static TimeSpan DefaultTransactionTimeout;
    private static int transactionCounter;
    private int transactionId;
    private bool isAmbient;
    private Transaction internalTransaction;
    private IsolationLevels isolationLevel;
    private LightweightSpinLock atomicSectionLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) aborted;
    private HashSet`1<ITransactionHandler> registeredHandlers;
    internal int Id { get; }
    public IsolationLevels IsolationLevel { get; }
    internal Transaction InternalTransaction { get; }
    internal bool Aborted { get; }
    internal Transaction(Transaction transaction, bool isAmbient);
    private static Transaction();
    public static Transaction Create(Transaction external);
    internal static TransactionContext EnsureTransaction(Transaction& transaction, IDatabase database);
    internal static Transaction TryGetAmbientEnlistedTransaction();
    private static CommittableTransaction CreateDefaultTransaction();
    internal int get_Id();
    public IsolationLevels get_IsolationLevel();
    internal Transaction get_InternalTransaction();
    internal bool get_Aborted();
    private IsolationLevels MapIsolationLevel(IsolationLevel isolationLevel);
    internal void Subscribe(ITransactionHandler handler);
    internal void EnterAtomicSection();
    internal void ExitAtomicSection();
    private void Commit();
    private void Rollback();
    private void Release();
    private sealed virtual override void System.Transactions.IEnlistmentNotification.Commit(Enlistment enlistment);
    private sealed virtual override void System.Transactions.IEnlistmentNotification.Rollback(Enlistment enlistment);
    private sealed virtual override void System.Transactions.IEnlistmentNotification.InDoubt(Enlistment enlistment);
    private sealed virtual override void System.Transactions.IEnlistmentNotification.Prepare(PreparingEnlistment preparingEnlistment);
}
public class NMemory.Transactions.TransactionContext : object {
    private CommittableTransaction transaction;
    private bool completed;
    public TransactionContext(CommittableTransaction transaction);
    public void Complete();
    public sealed virtual void Dispose();
}
public class NMemory.Transactions.TransactionHandler : object {
    private IDatabase database;
    private ConcurrentDictionary`2<Transaction, TransactionLog> transactionLogs;
    private static int counter;
    private int id;
    public sealed virtual void Initialize(IDatabase database);
    public sealed virtual ITransactionLog GetTransactionLog(Transaction transaction);
    public sealed virtual void Commit(Transaction transaction);
    public sealed virtual void Rollback(Transaction transaction);
    private void ReleaseResources(Transaction transaction);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[ExtensionAttribute]
public static class NMemory.Utilities.TableCollectionExtensions : object {
    [ExtensionAttribute]
public static Relation`4<TPrimary, TPrimaryKey, TForeign, TForeignKey> CreateRelation(TableCollection tableCollection, IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex, IIndex`2<TForeign, TForeignKey> foreignIndex, RelationOptions options, IRelationContraint[] constraints);
    [ExtensionAttribute]
public static Relation`4<TPrimary, TPrimaryKey, TForeign, TForeignKey> CreateRelation(TableCollection tableCollection, IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex, IIndex`2<TForeign, TForeignKey> foreignIndex, IRelationContraint[] constraints);
    [ExtensionAttribute]
public static Relation`4<TPrimary, TPrimaryKey, TForeign, TForeignKey> CreateRelation(TableCollection tableCollection, IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex, IIndex`2<TForeign, TForeignKey> foreignIndex, Expression`1<Func`2<TPrimary, TConstraint1>> constraint1P, Expression`1<Func`2<TForeign, TConstraint1>> constraint1F, RelationOptions options);
    [ExtensionAttribute]
public static Relation`4<TPrimary, TPrimaryKey, TForeign, TForeignKey> CreateRelation(TableCollection tableCollection, IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex, IIndex`2<TForeign, TForeignKey> foreignIndex, Expression`1<Func`2<TPrimary, TConstraint1>> constraint1P, Expression`1<Func`2<TForeign, TConstraint1>> constraint1F, Expression`1<Func`2<TPrimary, TConstraint2>> constraint2P, Expression`1<Func`2<TForeign, TConstraint2>> constraint2F, RelationOptions options);
    [ExtensionAttribute]
public static Relation`4<TPrimary, TPrimaryKey, TForeign, TForeignKey> CreateRelation(TableCollection tableCollection, IUniqueIndex`2<TPrimary, TPrimaryKey> primaryIndex, IIndex`2<TForeign, TForeignKey> foreignIndex, Expression`1<Func`2<TPrimary, TConstraint1>> constraint1P, Expression`1<Func`2<TForeign, TConstraint1>> constraint1F, Expression`1<Func`2<TPrimary, TConstraint2>> constraint2P, Expression`1<Func`2<TForeign, TConstraint2>> constraint2F, Expression`1<Func`2<TPrimary, TConstraint2>> constraint3P, Expression`1<Func`2<TForeign, TConstraint2>> constraint3F, RelationOptions options);
    [ExtensionAttribute]
public static ITable`1<T> FindTable(TableCollection tableCollection);
}
[ExtensionAttribute]
public static class NMemory.Utilities.TableExtensions : object {
    [ExtensionAttribute]
internal static IEnumerable`1<T> SelectAll(ITable`1<T> table);
}
