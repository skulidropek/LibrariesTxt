[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.PureAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("96")]
internal class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MutableAttribute]
public class NodaTime.AmbiguousTimeException : ArgumentOutOfRangeException {
    [CompilerGeneratedAttribute]
private ZonedDateTime <EarlierMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private ZonedDateTime <LaterMapping>k__BackingField;
    internal LocalDateTime LocalDateTime { get; }
    public DateTimeZone Zone { get; }
    public ZonedDateTime EarlierMapping { get; }
    public ZonedDateTime LaterMapping { get; }
    public AmbiguousTimeException(ZonedDateTime earlierMapping, ZonedDateTime laterMapping);
    internal LocalDateTime get_LocalDateTime();
    public DateTimeZone get_Zone();
    [CompilerGeneratedAttribute]
public ZonedDateTime get_EarlierMapping();
    [CompilerGeneratedAttribute]
public ZonedDateTime get_LaterMapping();
}
[AttributeUsageAttribute("12")]
internal class NodaTime.Annotations.ImmutableAttribute : Attribute {
}
[AttributeUsageAttribute("12")]
internal class NodaTime.Annotations.MutableAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class NodaTime.Annotations.SpecialNullHandlingAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class NodaTime.Annotations.TestExemptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private TestExemptionCategory <Category>k__BackingField;
    internal TestExemptionCategory Category { get; }
    internal TestExemptionAttribute(TestExemptionCategory category);
    [CompilerGeneratedAttribute]
internal TestExemptionCategory get_Category();
}
internal enum NodaTime.Annotations.TestExemptionCategory : Enum {
    public int value__;
    public static TestExemptionCategory ConversionName;
}
[AttributeUsageAttribute("2048")]
internal class NodaTime.Annotations.TrustedAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class NodaTime.Annotations.ValidatedNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("228")]
internal class NodaTime.Annotations.VisibleForTestingAttribute : Attribute {
}
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.AnnualDateTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.AnnualDate : ValueType {
    private YearMonthDay value;
    public int Month { get; }
    public int Day { get; }
    public AnnualDate(int month, int day);
    public int get_Month();
    public int get_Day();
    [PureAttribute]
public LocalDate InYear(int year);
    [PureAttribute]
public bool IsValidYear(int year);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public sealed virtual bool Equals(AnnualDate other);
    public sealed virtual int CompareTo(AnnualDate other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(AnnualDate lhs, AnnualDate rhs);
    public static bool op_Inequality(AnnualDate lhs, AnnualDate rhs);
    public static bool op_LessThan(AnnualDate lhs, AnnualDate rhs);
    public static bool op_LessThanOrEqual(AnnualDate lhs, AnnualDate rhs);
    public static bool op_GreaterThan(AnnualDate lhs, AnnualDate rhs);
    public static bool op_GreaterThanOrEqual(AnnualDate lhs, AnnualDate rhs);
    [NullableContextAttribute("1")]
public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    [NullableContextAttribute("1")]
private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    [NullableContextAttribute("1")]
private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    [NullableContextAttribute("1")]
private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
internal enum NodaTime.CalendarOrdinal : Enum {
    public int value__;
    public static CalendarOrdinal Iso;
    public static CalendarOrdinal Gregorian;
    public static CalendarOrdinal Julian;
    public static CalendarOrdinal Coptic;
    public static CalendarOrdinal HebrewCivil;
    public static CalendarOrdinal HebrewScriptural;
    public static CalendarOrdinal PersianSimple;
    public static CalendarOrdinal PersianArithmetic;
    public static CalendarOrdinal PersianAstronomical;
    public static CalendarOrdinal IslamicAstronomicalBase15;
    public static CalendarOrdinal IslamicAstronomicalBase16;
    public static CalendarOrdinal IslamicAstronomicalIndian;
    public static CalendarOrdinal IslamicAstronomicalHabashAlHasib;
    public static CalendarOrdinal IslamicCivilBase15;
    public static CalendarOrdinal IslamicCivilBase16;
    public static CalendarOrdinal IslamicCivilIndian;
    public static CalendarOrdinal IslamicCivilHabashAlHasib;
    public static CalendarOrdinal UmAlQura;
    public static CalendarOrdinal Badi;
    public static CalendarOrdinal Size;
}
internal class NodaTime.Calendars.BadiYearMonthDayCalculator : YearMonthDayCalculator {
    private static int AverageDaysPer10Years;
    private static int DaysInAyyamiHaInLeapYear;
    private static int DaysInAyyamiHaInNormalYear;
    internal static int DaysInMonth;
    private static int FirstYearOfStandardizedCalendar;
    private static int GregorianYearOfFirstBadiYear;
    internal static int Month18;
    private static int Month19;
    private static int MonthsInYear;
    private static int UnixEpochDayAtStartOfYear1;
    private static int BadiMaxYear;
    private static int BadiMinYear;
    [NullableAttribute("1")]
private static Byte[] YearInfoRaw;
    private static BadiYearMonthDayCalculator();
    internal static int GetDaysInAyyamiHa(int year);
    private static int GetNawRuzDayInMarch(int year);
    protected virtual int CalculateStartOfYearDays(int year);
    protected virtual int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
    internal virtual YearMonthDay AddMonths(YearMonthDay start, int months);
    internal virtual int GetDaysInMonth(int year, int month);
    internal virtual int GetDaysInYear(int year);
    internal virtual int GetDaysSinceEpoch(YearMonthDay target);
    internal virtual int GetMonthsInYear(int year);
    internal virtual YearMonthDay GetYearMonthDay(int year, int dayOfYear);
    internal static bool IsInAyyamiHa(YearMonthDay ymd);
    internal virtual bool IsLeapYear(int year);
    internal virtual int MonthsBetween(YearMonthDay start, YearMonthDay end);
    internal virtual YearMonthDay SetYear(YearMonthDay start, int newYear);
    internal virtual void ValidateYearMonthDay(int year, int month, int day);
}
internal class NodaTime.Calendars.CopticYearMonthDayCalculator : FixedMonthYearMonthDayCalculator {
    protected virtual int CalculateStartOfYearDays(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Calendars.Era : object {
    [CompilerGeneratedAttribute]
private static Era <Common>k__BackingField;
    [CompilerGeneratedAttribute]
private static Era <BeforeCommon>k__BackingField;
    [CompilerGeneratedAttribute]
private static Era <AnnoMartyrum>k__BackingField;
    [CompilerGeneratedAttribute]
private static Era <AnnoHegirae>k__BackingField;
    [CompilerGeneratedAttribute]
private static Era <AnnoMundi>k__BackingField;
    [CompilerGeneratedAttribute]
private static Era <AnnoPersico>k__BackingField;
    [CompilerGeneratedAttribute]
private static Era <Bahai>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static Era Common { get; }
    public static Era BeforeCommon { get; }
    public static Era AnnoMartyrum { get; }
    public static Era AnnoHegirae { get; }
    public static Era AnnoMundi { get; }
    public static Era AnnoPersico { get; }
    public static Era Bahai { get; }
    internal string ResourceIdentifier { get; }
    public string Name { get; }
    internal Era(string name, string resourceIdentifier);
    private static Era();
    [CompilerGeneratedAttribute]
public static Era get_Common();
    [CompilerGeneratedAttribute]
public static Era get_BeforeCommon();
    [CompilerGeneratedAttribute]
public static Era get_AnnoMartyrum();
    [CompilerGeneratedAttribute]
public static Era get_AnnoHegirae();
    [CompilerGeneratedAttribute]
public static Era get_AnnoMundi();
    [CompilerGeneratedAttribute]
public static Era get_AnnoPersico();
    [CompilerGeneratedAttribute]
public static Era get_Bahai();
    [CompilerGeneratedAttribute]
internal string get_ResourceIdentifier();
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NodaTime.Calendars.EraCalculator : object {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Era> <Eras>k__BackingField;
    internal ReadOnlyCollection`1<Era> Eras { get; }
    protected EraCalculator(Era[] eras);
    [CompilerGeneratedAttribute]
internal ReadOnlyCollection`1<Era> get_Eras();
    internal abstract virtual int GetMinYearOfEra(Era era);
    internal abstract virtual int GetMaxYearOfEra(Era era);
    internal abstract virtual Era GetEra(int absoluteYear);
    internal abstract virtual int GetYearOfEra(int absoluteYear);
    internal abstract virtual int GetAbsoluteYear(int yearOfEra, Era era);
}
internal abstract class NodaTime.Calendars.FixedMonthYearMonthDayCalculator : RegularYearMonthDayCalculator {
    private static int DaysInMonth;
    private static int AverageDaysPer10Years;
    protected FixedMonthYearMonthDayCalculator(int minYear, int maxYear, int daysAtStartOfYear1);
    internal virtual int GetDaysSinceEpoch(YearMonthDay yearMonthDay);
    protected virtual int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
    internal virtual bool IsLeapYear(int year);
    internal virtual int GetDaysInYear(int year);
    internal virtual int GetDaysInMonth(int year, int month);
    internal virtual YearMonthDay GetYearMonthDay(int year, int dayOfYear);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Calendars.GJEraCalculator : EraCalculator {
    private int maxYearOfBc;
    private int maxYearOfAd;
    internal GJEraCalculator(YearMonthDayCalculator ymdCalculator);
    private static void ValidateEra(Era era);
    internal virtual int GetAbsoluteYear(int yearOfEra, Era era);
    internal virtual int GetYearOfEra(int absoluteYear);
    internal virtual Era GetEra(int absoluteYear);
    internal virtual int GetMinYearOfEra(Era era);
    internal virtual int GetMaxYearOfEra(Era era);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NodaTime.Calendars.GJYearMonthDayCalculator : RegularYearMonthDayCalculator {
    private protected static Int32[] NonLeapDaysPerMonth;
    private protected static Int32[] LeapDaysPerMonth;
    private static Int32[] NonLeapTotalDaysByMonth;
    private static Int32[] LeapTotalDaysByMonth;
    protected GJYearMonthDayCalculator(int minYear, int maxYear, int averageDaysPer10Years, int daysAtStartOfYear1);
    private static GJYearMonthDayCalculator();
    private static Int32[] GenerateTotalDaysByMonth(Int32[] monthLengths);
    internal virtual YearMonthDay GetYearMonthDay(int year, int d);
    internal virtual int GetDaysInYear(int year);
    internal sealed virtual int GetDaysInMonth(int year, int month);
    protected virtual int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Calendars.GregorianYearMonthDayCalculator : GJYearMonthDayCalculator {
    internal static int MinGregorianYear;
    internal static int MaxGregorianYear;
    private static int FirstOptimizedYear;
    private static int LastOptimizedYear;
    private static int FirstOptimizedDay;
    private static int LastOptimizedDay;
    private static Int32[] MonthStartDays;
    private static Int32[] YearStartDays;
    private static int DaysFrom0000To1970;
    private static int AverageDaysPer10Years;
    private static GregorianYearMonthDayCalculator();
    internal static YearMonthDayCalendar GetGregorianYearMonthDayCalendarFromDaysSinceEpoch(int daysSinceEpoch);
    internal virtual int GetStartOfYearInDays(int year);
    internal virtual int GetDaysSinceEpoch(YearMonthDay yearMonthDay);
    internal virtual void ValidateYearMonthDay(int year, int month, int day);
    internal static void ValidateGregorianYearMonthDay(int year, int month, int day);
    protected virtual int CalculateStartOfYearDays(int year);
    internal virtual int GetDaysInYear(int year);
    internal virtual bool IsLeapYear(int year);
    private static bool IsGregorianLeapYear(int year);
}
internal static class NodaTime.Calendars.HebrewMonthConverter : object {
    internal static int CivilToScriptural(int year, int month);
    internal static int ScripturalToCivil(int year, int month);
}
public enum NodaTime.Calendars.HebrewMonthNumbering : Enum {
    public int value__;
    public static HebrewMonthNumbering Civil;
    public static HebrewMonthNumbering Scriptural;
}
internal static class NodaTime.Calendars.HebrewScripturalCalculator : object {
    internal static int MaxYear;
    internal static int MinYear;
    private static int IsHeshvanLongCacheBit;
    private static int IsKislevShortCacheBit;
    private static int ElapsedDaysCacheShift;
    [NullableAttribute("1")]
private static YearStartCacheEntry[] YearCache;
    private static HebrewScripturalCalculator();
    internal static bool IsLeapYear(int year);
    internal static YearMonthDay GetYearMonthDay(int year, int dayOfYear);
    internal static int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
    internal static int DaysInMonth(int year, int month);
    private static bool IsHeshvanLong(int year);
    private static bool IsKislevShort(int year);
    internal static int ElapsedDays(int year);
    private static int ElapsedDaysNoCache(int year);
    private static int GetOrPopulateCache(int year);
    private static int ComputeCacheEntry(int year);
    internal static int DaysInYear(int year);
}
internal class NodaTime.Calendars.HebrewYearMonthDayCalculator : YearMonthDayCalculator {
    private static int UnixEpochDayAtStartOfYear1;
    private static int MonthsPerLeapCycle;
    private static int YearsPerLeapCycle;
    private HebrewMonthNumbering monthNumbering;
    internal HebrewYearMonthDayCalculator(HebrewMonthNumbering monthNumbering);
    private int CalendarToCivilMonth(int year, int month);
    private int CalendarToScripturalMonth(int year, int month);
    private int CivilToCalendarMonth(int year, int month);
    private int ScripturalToCalendarMonth(int year, int month);
    internal virtual bool IsLeapYear(int year);
    protected virtual int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
    protected virtual int CalculateStartOfYearDays(int year);
    internal virtual YearMonthDay GetYearMonthDay(int year, int dayOfYear);
    internal virtual int GetDaysInYear(int year);
    internal virtual int GetMonthsInYear(int year);
    internal virtual YearMonthDay SetYear(YearMonthDay yearMonthDay, int year);
    internal virtual int GetDaysInMonth(int year, int month);
    internal virtual YearMonthDay AddMonths(YearMonthDay yearMonthDay, int months);
    internal virtual int MonthsBetween(YearMonthDay start, YearMonthDay end);
    public virtual int Compare(YearMonthDay lhs, YearMonthDay rhs);
}
public enum NodaTime.Calendars.IslamicEpoch : Enum {
    public int value__;
    public static IslamicEpoch Astronomical;
    public static IslamicEpoch Civil;
}
public enum NodaTime.Calendars.IslamicLeapYearPattern : Enum {
    public int value__;
    public static IslamicLeapYearPattern Base15;
    public static IslamicLeapYearPattern Base16;
    public static IslamicLeapYearPattern Indian;
    public static IslamicLeapYearPattern HabashAlHasib;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Calendars.IslamicYearMonthDayCalculator : RegularYearMonthDayCalculator {
    private static int MonthPairLength;
    private static int LongMonthLength;
    private static int ShortMonthLength;
    private static int AverageDaysPer10Years;
    private static int DaysPerNonLeapYear;
    private static int DaysPerLeapYear;
    private static int DaysAtCivilEpoch;
    private static int DaysAtAstronomicalEpoch;
    private static int LeapYearCycleLength;
    private static int DaysPerLeapCycle;
    private int leapYearPatternBits;
    private static Int32[] TotalDaysByMonth;
    internal IslamicYearMonthDayCalculator(IslamicLeapYearPattern leapYearPattern, IslamicEpoch epoch);
    private static IslamicYearMonthDayCalculator();
    private static Int32[] GenerateTotalDaysByMonth();
    protected virtual int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
    internal virtual YearMonthDay GetYearMonthDay(int year, int dayOfYear);
    internal virtual bool IsLeapYear(int year);
    internal virtual int GetDaysInYear(int year);
    internal virtual int GetDaysInMonth(int year, int month);
    protected virtual int CalculateStartOfYearDays(int year);
    private static int GetLeapYearPatternBits(IslamicLeapYearPattern leapYearPattern);
    private static int GetYear1Days(IslamicEpoch epoch);
}
[NullableContextAttribute("1")]
public interface NodaTime.Calendars.IWeekYearRule {
    public abstract virtual LocalDate GetLocalDate(int weekYear, int weekOfWeekYear, IsoDayOfWeek dayOfWeek, CalendarSystem calendar);
    public abstract virtual int GetWeekYear(LocalDate date);
    public abstract virtual int GetWeekOfWeekYear(LocalDate date);
    public abstract virtual int GetWeeksInWeekYear(int weekYear, CalendarSystem calendar);
}
internal class NodaTime.Calendars.JulianYearMonthDayCalculator : GJYearMonthDayCalculator {
    private static int AverageDaysPer10JulianYears;
    internal virtual bool IsLeapYear(int year);
    protected virtual int CalculateStartOfYearDays(int year);
}
internal abstract class NodaTime.Calendars.PersianYearMonthDayCalculator : RegularYearMonthDayCalculator {
    private static int DaysPerNonLeapYear;
    private static int DaysPerLeapYear;
    private static int AverageDaysPer10Years;
    internal static int MaxPersianYear;
    [NullableAttribute("1")]
private static Int32[] TotalDaysByMonth;
    [NullableAttribute("1")]
private Int32[] startOfYearInDaysCache;
    private PersianYearMonthDayCalculator(int daysAtStartOfYear1);
    private static PersianYearMonthDayCalculator();
    [NullableContextAttribute("1")]
private static Int32[] GenerateTotalDaysByMonth();
    protected sealed virtual int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
    internal sealed virtual int GetStartOfYearInDays(int year);
    [ExcludeFromCodeCoverageAttribute]
protected sealed virtual int CalculateStartOfYearDays(int year);
    internal sealed virtual YearMonthDay GetYearMonthDay(int year, int dayOfYear);
    internal sealed virtual int GetDaysInMonth(int year, int month);
    internal sealed virtual int GetDaysInYear(int year);
}
internal abstract class NodaTime.Calendars.RegularYearMonthDayCalculator : YearMonthDayCalculator {
    private int monthsInYear;
    protected RegularYearMonthDayCalculator(int minYear, int maxYear, int monthsInYear, int averageDaysPer10Years, int daysAtStartOfYear1);
    internal virtual int GetMonthsInYear(int year);
    internal virtual YearMonthDay SetYear(YearMonthDay yearMonthDay, int year);
    internal virtual YearMonthDay AddMonths(YearMonthDay yearMonthDay, int months);
    internal virtual int MonthsBetween(YearMonthDay start, YearMonthDay end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
internal class NodaTime.Calendars.SimpleWeekYearRule : object {
    private int minDaysInFirstWeek;
    private IsoDayOfWeek firstDayOfWeek;
    private bool irregularWeeks;
    internal SimpleWeekYearRule(int minDaysInFirstWeek, IsoDayOfWeek firstDayOfWeek, bool irregularWeeks);
    public sealed virtual LocalDate GetLocalDate(int weekYear, int weekOfWeekYear, IsoDayOfWeek dayOfWeek, CalendarSystem calendar);
    public sealed virtual int GetWeekOfWeekYear(LocalDate date);
    public sealed virtual int GetWeeksInWeekYear(int weekYear, CalendarSystem calendar);
    public sealed virtual int GetWeekYear(LocalDate date);
    private void ValidateWeekYear(int weekYear, CalendarSystem calendar);
    private int GetWeekYearDaysSinceEpoch(YearMonthDayCalculator yearMonthDayCalculator, int weekYear);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Calendars.SingleEraCalculator : EraCalculator {
    private Era era;
    private int minYear;
    private int maxYear;
    internal SingleEraCalculator(Era era, YearMonthDayCalculator ymdCalculator);
    private void ValidateEra(Era era);
    internal virtual int GetAbsoluteYear(int yearOfEra, Era era);
    internal virtual int GetYearOfEra(int absoluteYear);
    internal virtual int GetMinYearOfEra(Era era);
    internal virtual int GetMaxYearOfEra(Era era);
    internal virtual Era GetEra(int absoluteYear);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Calendars.UmAlQuraYearMonthDayCalculator : RegularYearMonthDayCalculator {
    private static int AverageDaysPer10Years;
    private static int ComputedMinYear;
    private static int ComputedMaxYear;
    private static int ComputedDaysAtStartOfMinYear;
    private static string GeneratedData;
    private static int ComputedDaysAtStartOfYear1;
    private static Int32[] YearLengths;
    private static UInt16[] MonthLengths;
    private static Int32[] YearStartDays;
    private static UmAlQuraYearMonthDayCalculator();
    internal virtual int GetStartOfYearInDays(int year);
    [ExcludeFromCodeCoverageAttribute]
protected virtual int CalculateStartOfYearDays(int year);
    protected virtual int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
    internal virtual int GetDaysInMonth(int year, int month);
    internal virtual int GetDaysInYear(int year);
    internal virtual YearMonthDay GetYearMonthDay(int year, int dayOfYear);
    internal virtual bool IsLeapYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NodaTime.Calendars.WeekYearRuleExtensions : object {
    [ExtensionAttribute]
public static LocalDate GetLocalDate(IWeekYearRule rule, int weekYear, int weekOfWeekYear, IsoDayOfWeek dayOfWeek);
    [ExtensionAttribute]
public static int GetWeeksInWeekYear(IWeekYearRule rule, int weekYear);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NodaTime.Calendars.WeekYearRules : object {
    [CompilerGeneratedAttribute]
private static IWeekYearRule <Iso>k__BackingField;
    public static IWeekYearRule Iso { get; }
    private static WeekYearRules();
    [CompilerGeneratedAttribute]
public static IWeekYearRule get_Iso();
    public static IWeekYearRule ForMinDaysInFirstWeek(int minDaysInFirstWeek);
    public static IWeekYearRule ForMinDaysInFirstWeek(int minDaysInFirstWeek, IsoDayOfWeek firstDayOfWeek);
    public static IWeekYearRule FromCalendarWeekRule(CalendarWeekRule calendarWeekRule, DayOfWeek firstDayOfWeek);
}
internal abstract class NodaTime.Calendars.YearMonthDayCalculator : object {
    [NullableAttribute("1")]
private YearStartCacheEntry[] yearCache;
    [CompilerGeneratedAttribute]
private int <MinYear>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxYear>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DaysAtStartOfYear1>k__BackingField;
    private int averageDaysPer10Years;
    internal int MinYear { get; }
    internal int MaxYear { get; }
    [VisibleForTestingAttribute]
internal int DaysAtStartOfYear1 { get; }
    protected YearMonthDayCalculator(int minYear, int maxYear, int averageDaysPer10Years, int daysAtStartOfYear1);
    [CompilerGeneratedAttribute]
internal int get_MinYear();
    [CompilerGeneratedAttribute]
internal int get_MaxYear();
    [CompilerGeneratedAttribute]
internal int get_DaysAtStartOfYear1();
    protected abstract virtual int GetDaysFromStartOfYearToStartOfMonth(int year, int month);
    protected abstract virtual int CalculateStartOfYearDays(int year);
    internal abstract virtual int GetMonthsInYear(int year);
    internal abstract virtual int GetDaysInMonth(int year, int month);
    internal abstract virtual bool IsLeapYear(int year);
    internal abstract virtual YearMonthDay AddMonths(YearMonthDay yearMonthDay, int months);
    internal abstract virtual YearMonthDay GetYearMonthDay(int year, int dayOfYear);
    internal abstract virtual int GetDaysInYear(int year);
    internal abstract virtual int MonthsBetween(YearMonthDay start, YearMonthDay end);
    internal abstract virtual YearMonthDay SetYear(YearMonthDay yearMonthDay, int year);
    internal virtual int GetDaysSinceEpoch(YearMonthDay yearMonthDay);
    internal virtual int GetStartOfYearInDays(int year);
    public virtual int Compare(YearMonthDay lhs, YearMonthDay rhs);
    internal virtual void ValidateYearMonthDay(int year, int month, int day);
    internal int GetDayOfYear(YearMonthDay yearMonthDay);
    internal YearMonthDay GetYearMonthDay(int daysSinceEpoch);
    [VisibleForTestingAttribute]
internal int GetYear(int daysSinceEpoch, Int32& zeroBasedDayOfYear);
}
[IsReadOnlyAttribute]
internal class NodaTime.Calendars.YearStartCacheEntry : ValueType {
    private static int CacheIndexBits;
    private static int CacheIndexMask;
    private static int EntryValidationBits;
    private static int EntryValidationMask;
    private static int CacheSize;
    internal static int InvalidEntryYear;
    private static YearStartCacheEntry Invalid;
    private int value;
    internal int StartOfYearDays { get; }
    internal YearStartCacheEntry(int year, int days);
    private static YearStartCacheEntry();
    [NullableContextAttribute("1")]
internal static YearStartCacheEntry[] CreateCache();
    private static int GetValidator(int year);
    internal static int GetCacheIndex(int year);
    internal bool IsValidForYear(int year);
    internal int get_StartOfYearDays();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.CalendarSystem : object {
    private static string GregorianName;
    private static string GregorianId;
    private static string IsoName;
    private static string IsoId;
    private static string CopticName;
    private static string CopticId;
    private static string BadiName;
    private static string BadiId;
    private static string JulianName;
    private static string JulianId;
    private static string IslamicName;
    private static string IslamicIdBase;
    private static string PersianName;
    private static string PersianIdBase;
    private static string PersianSimpleId;
    private static string PersianAstronomicalId;
    private static string PersianArithmeticId;
    private static string HebrewName;
    private static string HebrewIdBase;
    private static string HebrewCivilId;
    private static string HebrewScripturalId;
    private static string UmAlQuraName;
    private static string UmAlQuraId;
    private static CalendarSystem[] CalendarByOrdinal;
    private static Dictionary`2<string, Func`1<CalendarSystem>> IdToFactoryMap;
    [CompilerGeneratedAttribute]
private static CalendarSystem <Iso>k__BackingField;
    private EraCalculator eraCalculator;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinYear>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxYear>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinDays>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDays>k__BackingField;
    [CompilerGeneratedAttribute]
private CalendarOrdinal <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private YearMonthDayCalculator <YearMonthDayCalculator>k__BackingField;
    public static IEnumerable`1<string> Ids { get; }
    public static CalendarSystem Iso { get; }
    public static CalendarSystem Badi { get; }
    public string Id { get; }
    public string Name { get; }
    public int MinYear { get; }
    public int MaxYear { get; }
    internal int MinDays { get; }
    internal int MaxDays { get; }
    internal CalendarOrdinal Ordinal { get; }
    public IList`1<Era> Eras { get; }
    internal YearMonthDayCalculator YearMonthDayCalculator { get; }
    public static CalendarSystem Gregorian { get; }
    public static CalendarSystem Julian { get; }
    public static CalendarSystem Coptic { get; }
    public static CalendarSystem IslamicBcl { get; }
    public static CalendarSystem PersianSimple { get; }
    public static CalendarSystem PersianArithmetic { get; }
    public static CalendarSystem PersianAstronomical { get; }
    public static CalendarSystem HebrewCivil { get; }
    public static CalendarSystem HebrewScriptural { get; }
    public static CalendarSystem UmAlQura { get; }
    private static CalendarSystem();
    private CalendarSystem(CalendarOrdinal ordinal, string id, string name, YearMonthDayCalculator yearMonthDayCalculator, Era singleEra);
    private CalendarSystem(CalendarOrdinal ordinal, string id, string name, YearMonthDayCalculator yearMonthDayCalculator, EraCalculator eraCalculator);
    internal static string GetIslamicId(IslamicLeapYearPattern leapYearPattern, IslamicEpoch epoch);
    public static CalendarSystem ForId(string id);
    internal static CalendarSystem ForOrdinal(CalendarOrdinal ordinal);
    public static IEnumerable`1<string> get_Ids();
    [CompilerGeneratedAttribute]
public static CalendarSystem get_Iso();
    public static CalendarSystem GetHebrewCalendar(HebrewMonthNumbering monthNumbering);
    public static CalendarSystem get_Badi();
    public static CalendarSystem GetIslamicCalendar(IslamicLeapYearPattern leapYearPattern, IslamicEpoch epoch);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_MinYear();
    [CompilerGeneratedAttribute]
public int get_MaxYear();
    [CompilerGeneratedAttribute]
internal int get_MinDays();
    [CompilerGeneratedAttribute]
internal int get_MaxDays();
    [CompilerGeneratedAttribute]
internal CalendarOrdinal get_Ordinal();
    public IList`1<Era> get_Eras();
    public int GetAbsoluteYear(int yearOfEra, Era era);
    public int GetMaxYearOfEra(Era era);
    public int GetMinYearOfEra(Era era);
    [CompilerGeneratedAttribute]
internal YearMonthDayCalculator get_YearMonthDayCalculator();
    internal YearMonthDayCalendar GetYearMonthDayCalendarFromDaysSinceEpoch(int daysSinceEpoch);
    public virtual string ToString();
    internal int GetDaysSinceEpoch(YearMonthDay yearMonthDay);
    internal IsoDayOfWeek GetDayOfWeek(YearMonthDay yearMonthDay);
    public int GetDaysInYear(int year);
    public int GetDaysInMonth(int year, int month);
    public bool IsLeapYear(int year);
    public int GetMonthsInYear(int year);
    internal void ValidateYearMonthDay(int year, int month, int day);
    internal int Compare(YearMonthDay lhs, YearMonthDay rhs);
    internal int GetDayOfYear(YearMonthDay yearMonthDay);
    internal int GetYearOfEra(int absoluteYear);
    internal Era GetEra(int absoluteYear);
    [ConditionalAttribute("DEBUG")]
[ExcludeFromCodeCoverageAttribute]
internal void DebugValidateYearMonthDay(YearMonthDay yearMonthDay);
    public static CalendarSystem get_Gregorian();
    public static CalendarSystem get_Julian();
    public static CalendarSystem get_Coptic();
    public static CalendarSystem get_IslamicBcl();
    public static CalendarSystem get_PersianSimple();
    public static CalendarSystem get_PersianArithmetic();
    public static CalendarSystem get_PersianAstronomical();
    public static CalendarSystem get_HebrewCivil();
    public static CalendarSystem get_HebrewScriptural();
    public static CalendarSystem get_UmAlQura();
    [VisibleForTestingAttribute]
internal static CalendarSystem ForOrdinalUncached(CalendarOrdinal ordinal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NodaTime.DateAdjusters : object {
    [CompilerGeneratedAttribute]
private static Func`2<LocalDate, LocalDate> <StartOfMonth>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<LocalDate, LocalDate> <EndOfMonth>k__BackingField;
    public static Func`2<LocalDate, LocalDate> StartOfMonth { get; }
    public static Func`2<LocalDate, LocalDate> EndOfMonth { get; }
    private static DateAdjusters();
    [CompilerGeneratedAttribute]
public static Func`2<LocalDate, LocalDate> get_StartOfMonth();
    [CompilerGeneratedAttribute]
public static Func`2<LocalDate, LocalDate> get_EndOfMonth();
    public static Func`2<LocalDate, LocalDate> DayOfMonth(int day);
    public static Func`2<LocalDate, LocalDate> Month(int month);
    public static Func`2<LocalDate, LocalDate> NextOrSame(IsoDayOfWeek dayOfWeek);
    public static Func`2<LocalDate, LocalDate> PreviousOrSame(IsoDayOfWeek dayOfWeek);
    public static Func`2<LocalDate, LocalDate> Next(IsoDayOfWeek dayOfWeek);
    public static Func`2<LocalDate, LocalDate> Previous(IsoDayOfWeek dayOfWeek);
    public static Func`2<LocalDate, LocalDate> AddPeriod(Period period);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.DateInterval : object {
    [CompilerGeneratedAttribute]
private LocalDate <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalDate <End>k__BackingField;
    public LocalDate Start { get; }
    public LocalDate End { get; }
    public int Length { get; }
    public CalendarSystem Calendar { get; }
    public DateInterval(LocalDate start, LocalDate end);
    [CompilerGeneratedAttribute]
public LocalDate get_Start();
    [CompilerGeneratedAttribute]
public LocalDate get_End();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(DateInterval lhs, DateInterval rhs);
    [NullableContextAttribute("2")]
public static bool op_Inequality(DateInterval lhs, DateInterval rhs);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DateInterval other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Contains(LocalDate date);
    public bool Contains(DateInterval interval);
    public int get_Length();
    public CalendarSystem get_Calendar();
    public virtual string ToString();
    public void Deconstruct(LocalDate& start, LocalDate& end);
    public DateInterval Intersection(DateInterval interval);
    public DateInterval Union(DateInterval interval);
    private void ValidateInterval(DateInterval interval);
    [IteratorStateMachineAttribute("NodaTime.DateInterval/<GetEnumerator>d__23")]
public sealed virtual IEnumerator`1<LocalDate> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public abstract class NodaTime.DateTimeZone : object {
    internal static string UtcId;
    [CompilerGeneratedAttribute]
private static DateTimeZone <Utc>k__BackingField;
    private static int FixedZoneCacheGranularitySeconds;
    private static int FixedZoneCacheMinimumSeconds;
    private static int FixedZoneCacheSize;
    private static DateTimeZone[] FixedZoneCache;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixed>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <MinOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <MaxOffset>k__BackingField;
    public static DateTimeZone Utc { get; }
    public string Id { get; }
    internal bool IsFixed { get; }
    public Offset MinOffset { get; }
    public Offset MaxOffset { get; }
    protected DateTimeZone(string id, bool isFixed, Offset minOffset, Offset maxOffset);
    private static DateTimeZone();
    [CompilerGeneratedAttribute]
public static DateTimeZone get_Utc();
    public static DateTimeZone ForOffset(Offset offset);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
internal bool get_IsFixed();
    [CompilerGeneratedAttribute]
public sealed virtual Offset get_MinOffset();
    [CompilerGeneratedAttribute]
public sealed virtual Offset get_MaxOffset();
    public virtual Offset GetUtcOffset(Instant instant);
    public abstract virtual ZoneInterval GetZoneInterval(Instant instant);
    public virtual ZoneLocalMapping MapLocal(LocalDateTime localDateTime);
    public ZonedDateTime AtStartOfDay(LocalDate date);
    public ZonedDateTime ResolveLocal(LocalDateTime localDateTime, ZoneLocalMappingResolver resolver);
    public ZonedDateTime AtStrictly(LocalDateTime localDateTime);
    public ZonedDateTime AtLeniently(LocalDateTime localDateTime);
    private ZoneInterval GetEarlierMatchingInterval(ZoneInterval interval, LocalInstant localInstant);
    private ZoneInterval GetLaterMatchingInterval(ZoneInterval interval, LocalInstant localInstant);
    private ZoneInterval GetIntervalBeforeGap(LocalInstant localInstant);
    private ZoneInterval GetIntervalAfterGap(LocalInstant localInstant);
    public virtual string ToString();
    private static DateTimeZone[] BuildFixedZoneCache();
    public IEnumerable`1<ZoneInterval> GetZoneIntervals(Instant start, Instant end);
    [IteratorStateMachineAttribute("NodaTime.DateTimeZone/<GetZoneIntervals>d__36")]
public IEnumerable`1<ZoneInterval> GetZoneIntervals(Interval interval);
    public IEnumerable`1<ZoneInterval> GetZoneIntervals(Interval interval, Options options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NodaTime.DateTimeZoneProviders : object {
    public static IDateTimeZoneProvider Tzdb { get; }
    public static IDateTimeZoneProvider Bcl { get; }
    [ObsoleteAttribute("This property exists primarily for binary backward compatibility. Please use NodaTime.Xml.XmlSerializationSettings.DateTimeZoneProvider instead.")]
public static IDateTimeZoneProvider Serialization { get; public set; }
    public static IDateTimeZoneProvider get_Tzdb();
    public static IDateTimeZoneProvider get_Bcl();
    public static IDateTimeZoneProvider get_Serialization();
    public static void set_Serialization(IDateTimeZoneProvider value);
}
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.DurationTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.Duration : ValueType {
    internal static int MaxDays;
    internal static int MinDays;
    internal static BigInteger MinNanoseconds;
    internal static BigInteger MaxNanoseconds;
    internal static decimal MinDecimalNanoseconds;
    internal static decimal MaxDecimalNanoseconds;
    private static double MinDoubleNanoseconds;
    private static double MaxDoubleNanoseconds;
    private static long MaxDaysForLongNanos;
    private static long MinDaysForLongNanos;
    private int days;
    private long nanoOfDay;
    public static Duration Zero { get; }
    public static Duration Epsilon { get; }
    public static Duration MaxValue { get; }
    public static Duration MinValue { get; }
    internal static Duration OneWeek { get; }
    internal static Duration OneDay { get; }
    internal int FloorDays { get; }
    internal long NanosecondOfFloorDay { get; }
    public int Days { get; }
    public long NanosecondOfDay { get; }
    public int Hours { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public int Milliseconds { get; }
    public int SubsecondTicks { get; }
    public int SubsecondNanoseconds { get; }
    public long BclCompatibleTicks { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public double TotalMilliseconds { get; }
    public double TotalTicks { get; }
    public double TotalNanoseconds { get; }
    internal bool IsInt64Representable { get; }
    private Duration(int days, long nanoOfDay, bool noValidation);
    [NullableContextAttribute("1")]
private Duration(long units, string paramName, long minValue, long maxValue, long unitsPerDay, long nanosPerUnit);
    internal Duration(int days, long nanoOfDay);
    private static Duration();
    public static Duration get_Zero();
    public static Duration get_Epsilon();
    public static Duration get_MaxValue();
    public static Duration get_MinValue();
    internal static Duration get_OneWeek();
    internal static Duration get_OneDay();
    internal int get_FloorDays();
    internal long get_NanosecondOfFloorDay();
    public int get_Days();
    public long get_NanosecondOfDay();
    public int get_Hours();
    public int get_Minutes();
    public int get_Seconds();
    public int get_Milliseconds();
    public int get_SubsecondTicks();
    public int get_SubsecondNanoseconds();
    public long get_BclCompatibleTicks();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public double get_TotalMilliseconds();
    public double get_TotalTicks();
    public double get_TotalNanoseconds();
    [PureAttribute]
internal Duration PlusSmallNanoseconds(long smallNanos);
    [PureAttribute]
internal Duration MinusSmallNanoseconds(long smallNanos);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public static Duration op_Addition(Duration left, Duration right);
    public static Duration Add(Duration left, Duration right);
    [PureAttribute]
public Duration Plus(Duration other);
    public static Duration op_Subtraction(Duration left, Duration right);
    public static Duration Subtract(Duration left, Duration right);
    [PureAttribute]
public Duration Minus(Duration other);
    public static Duration op_Division(Duration left, long right);
    public static Duration op_Division(Duration left, double right);
    public static double op_Division(Duration left, Duration right);
    public static Duration Divide(Duration left, long right);
    public static Duration Divide(Duration left, double right);
    public static double Divide(Duration left, Duration right);
    public static Duration op_Multiply(Duration left, double right);
    public static Duration op_Multiply(Duration left, long right);
    public static Duration op_Multiply(long left, Duration right);
    public static Duration Multiply(Duration left, long right);
    public static Duration Multiply(Duration left, double right);
    public static Duration Multiply(long left, Duration right);
    public static bool op_Equality(Duration left, Duration right);
    public static bool op_Inequality(Duration left, Duration right);
    public static bool op_LessThan(Duration left, Duration right);
    public static bool op_LessThanOrEqual(Duration left, Duration right);
    public static bool op_GreaterThan(Duration left, Duration right);
    public static bool op_GreaterThanOrEqual(Duration left, Duration right);
    public static Duration op_UnaryNegation(Duration duration);
    public static Duration Negate(Duration duration);
    public sealed virtual int CompareTo(Duration other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual bool Equals(Duration other);
    public static Duration FromDays(int days);
    public static Duration FromDays(double days);
    public static Duration FromHours(int hours);
    public static Duration FromHours(double hours);
    public static Duration FromMinutes(long minutes);
    public static Duration FromMinutes(double minutes);
    public static Duration FromSeconds(long seconds);
    public static Duration FromSeconds(double seconds);
    public static Duration FromMilliseconds(long milliseconds);
    public static Duration FromMilliseconds(double milliseconds);
    public static Duration FromTicks(long ticks);
    public static Duration FromTicks(double ticks);
    public static Duration FromNanoseconds(long nanoseconds);
    public static Duration FromNanoseconds(double nanoseconds);
    public static Duration FromNanoseconds(BigInteger nanoseconds);
    internal static Duration FromNanoseconds(decimal nanoseconds);
    public static Duration FromTimeSpan(TimeSpan timeSpan);
    [PureAttribute]
public TimeSpan ToTimeSpan();
    [NullableContextAttribute("1")]
public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    [NullableContextAttribute("1")]
private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    [NullableContextAttribute("1")]
private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    [NullableContextAttribute("1")]
private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    [PureAttribute]
public long ToInt64Nanoseconds();
    internal bool get_IsInt64Representable();
    [PureAttribute]
private long ToInt64NanosecondsUnchecked();
    [PureAttribute]
public BigInteger ToBigIntegerNanoseconds();
    [PureAttribute]
internal decimal ToDecimalNanoseconds();
    public static Duration Max(Duration x, Duration y);
    public static Duration Min(Duration x, Duration y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NodaTime.Extensions.ClockExtensions : object {
    [ExtensionAttribute]
public static ZonedClock InZone(IClock clock, DateTimeZone zone);
    [ExtensionAttribute]
public static ZonedClock InZone(IClock clock, DateTimeZone zone, CalendarSystem calendar);
    [ExtensionAttribute]
public static ZonedClock InUtc(IClock clock);
    [ExtensionAttribute]
public static ZonedClock InTzdbSystemDefaultZone(IClock clock);
    [ExtensionAttribute]
public static ZonedClock InBclSystemDefaultZone(IClock clock);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.DateOnlyExtensions : object {
    [ExtensionAttribute]
public static LocalDate ToLocalDate(DateOnly date);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.DateTimeExtensions : object {
    [ExtensionAttribute]
public static LocalDateTime ToLocalDateTime(DateTime dateTime);
    [ExtensionAttribute]
public static Instant ToInstant(DateTime dateTime);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.DateTimeOffsetExtensions : object {
    [ExtensionAttribute]
public static OffsetDateTime ToOffsetDateTime(DateTimeOffset dateTimeOffset);
    [ExtensionAttribute]
public static ZonedDateTime ToZonedDateTime(DateTimeOffset dateTimeOffset);
    [ExtensionAttribute]
public static Instant ToInstant(DateTimeOffset dateTimeOffset);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.DateTimeZoneProviderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<DateTimeZone> GetAllZones(IDateTimeZoneProvider provider);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.DayOfWeekExtensions : object {
    [ExtensionAttribute]
public static IsoDayOfWeek ToIsoDayOfWeek(DayOfWeek dayOfWeek);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.IsoDayOfWeekExtensions : object {
    [ExtensionAttribute]
public static DayOfWeek ToDayOfWeek(IsoDayOfWeek isoDayOfWeek);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.StopwatchExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Duration ElapsedDuration(Stopwatch stopwatch);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.TimeOnlyExtensions : object {
    [ExtensionAttribute]
public static LocalTime ToLocalTime(TimeOnly time);
}
[ExtensionAttribute]
public static class NodaTime.Extensions.TimeSpanExtensions : object {
    [ExtensionAttribute]
public static Duration ToDuration(TimeSpan timeSpan);
    [ExtensionAttribute]
public static Offset ToOffset(TimeSpan timeSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.Fields.DatePeriodFields : object {
    internal static IDatePeriodField DaysField;
    internal static IDatePeriodField WeeksField;
    internal static IDatePeriodField MonthsField;
    internal static IDatePeriodField YearsField;
    private static DatePeriodFields();
}
internal class NodaTime.Fields.FixedLengthDatePeriodField : object {
    private int unitDays;
    internal FixedLengthDatePeriodField(int unitDays);
    public sealed virtual LocalDate Add(LocalDate localDate, int value);
    public sealed virtual int UnitsBetween(LocalDate start, LocalDate end);
}
internal interface NodaTime.Fields.IDatePeriodField {
    public abstract virtual LocalDate Add(LocalDate localDate, int value);
    public abstract virtual int UnitsBetween(LocalDate start, LocalDate end);
}
internal class NodaTime.Fields.MonthsPeriodField : object {
    public sealed virtual LocalDate Add(LocalDate localDate, int value);
    public sealed virtual int UnitsBetween(LocalDate start, LocalDate end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Fields.TimePeriodField : object {
    internal static TimePeriodField Nanoseconds;
    internal static TimePeriodField Ticks;
    internal static TimePeriodField Milliseconds;
    internal static TimePeriodField Seconds;
    internal static TimePeriodField Minutes;
    internal static TimePeriodField Hours;
    private long unitNanoseconds;
    private long maxLongUnits;
    private long unitsPerDay;
    private TimePeriodField(long unitNanoseconds);
    private static TimePeriodField();
    internal LocalDateTime Add(LocalDateTime start, long units);
    internal LocalTime Add(LocalTime localTime, long value);
    internal LocalTime Add(LocalTime localTime, long value, Int32& extraDays);
    internal long UnitsBetween(LocalDateTime start, LocalDateTime end);
    internal long GetUnitsInDuration(Duration duration);
    internal Duration ToDuration(long units);
}
internal class NodaTime.Fields.YearsPeriodField : object {
    public sealed virtual LocalDate Add(LocalDate localDate, int value);
    public sealed virtual int UnitsBetween(LocalDate start, LocalDate end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Globalization.NodaFormatInfo : object {
    private static String[] ShortInvariantMonthNames;
    private static String[] LongInvariantMonthNames;
    private object fieldLock;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<Duration> durationPatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<Offset> offsetPatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<Instant> instantPatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<LocalTime> localTimePatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<LocalDate> localDatePatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<LocalDateTime> localDateTimePatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<OffsetDateTime> offsetDateTimePatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<OffsetDate> offsetDatePatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<OffsetTime> offsetTimePatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<ZonedDateTime> zonedDateTimePatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<AnnualDate> annualDatePatternParser;
    [NullableAttribute("2")]
private FixedFormatInfoPatternParser`1<YearMonth> yearMonthPatternParser;
    public static NodaFormatInfo InvariantInfo;
    private static Cache`2<CultureInfo, NodaFormatInfo> Cache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> longMonthNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> longMonthGenitiveNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> longDayNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> shortMonthNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> shortMonthGenitiveNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> shortDayNames;
    private ConcurrentDictionary`2<Era, EraDescription> eraDescriptions;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeFormatInfo <DateTimeFormat>k__BackingField;
    public CultureInfo CultureInfo { get; }
    public CompareInfo CompareInfo { get; }
    internal FixedFormatInfoPatternParser`1<Duration> DurationPatternParser { get; }
    internal FixedFormatInfoPatternParser`1<Offset> OffsetPatternParser { get; }
    internal FixedFormatInfoPatternParser`1<Instant> InstantPatternParser { get; }
    internal FixedFormatInfoPatternParser`1<LocalTime> LocalTimePatternParser { get; }
    internal FixedFormatInfoPatternParser`1<LocalDate> LocalDatePatternParser { get; }
    internal FixedFormatInfoPatternParser`1<LocalDateTime> LocalDateTimePatternParser { get; }
    internal FixedFormatInfoPatternParser`1<OffsetDateTime> OffsetDateTimePatternParser { get; }
    internal FixedFormatInfoPatternParser`1<OffsetDate> OffsetDatePatternParser { get; }
    internal FixedFormatInfoPatternParser`1<OffsetTime> OffsetTimePatternParser { get; }
    internal FixedFormatInfoPatternParser`1<ZonedDateTime> ZonedDateTimePatternParser { get; }
    internal FixedFormatInfoPatternParser`1<AnnualDate> AnnualDatePatternParser { get; }
    internal FixedFormatInfoPatternParser`1<YearMonth> YearMonthPatternParser { get; }
    public IReadOnlyList`1<string> LongMonthNames { get; }
    public IReadOnlyList`1<string> ShortMonthNames { get; }
    public IReadOnlyList`1<string> LongMonthGenitiveNames { get; }
    public IReadOnlyList`1<string> ShortMonthGenitiveNames { get; }
    public IReadOnlyList`1<string> LongDayNames { get; }
    public IReadOnlyList`1<string> ShortDayNames { get; }
    public DateTimeFormatInfo DateTimeFormat { get; }
    public string TimeSeparator { get; }
    public string DateSeparator { get; }
    public string AMDesignator { get; }
    public string PMDesignator { get; }
    public static NodaFormatInfo CurrentInfo { get; }
    public string OffsetPatternLong { get; }
    public string OffsetPatternMedium { get; }
    public string OffsetPatternShort { get; }
    public string OffsetPatternLongNoPunctuation { get; }
    public string OffsetPatternMediumNoPunctuation { get; }
    public string OffsetPatternShortNoPunctuation { get; }
    [VisibleForTestingAttribute]
internal NodaFormatInfo(CultureInfo cultureInfo);
    [VisibleForTestingAttribute]
internal NodaFormatInfo(CultureInfo cultureInfo, DateTimeFormatInfo dateTimeFormat);
    private static NodaFormatInfo();
    private void EnsureMonthsInitialized();
    private static IReadOnlyList`1<string> ConvertMonthArray(String[] monthNames);
    private void EnsureDaysInitialized();
    private static IReadOnlyList`1<string> ConvertDayArray(String[] dayNames);
    private static IReadOnlyList`1<string> ConvertGenitiveMonthArray(IReadOnlyList`1<string> nonGenitiveNames, String[] bclNames, String[] invariantNames);
    [CompilerGeneratedAttribute]
public CultureInfo get_CultureInfo();
    public CompareInfo get_CompareInfo();
    internal FixedFormatInfoPatternParser`1<Duration> get_DurationPatternParser();
    internal FixedFormatInfoPatternParser`1<Offset> get_OffsetPatternParser();
    internal FixedFormatInfoPatternParser`1<Instant> get_InstantPatternParser();
    internal FixedFormatInfoPatternParser`1<LocalTime> get_LocalTimePatternParser();
    internal FixedFormatInfoPatternParser`1<LocalDate> get_LocalDatePatternParser();
    internal FixedFormatInfoPatternParser`1<LocalDateTime> get_LocalDateTimePatternParser();
    internal FixedFormatInfoPatternParser`1<OffsetDateTime> get_OffsetDateTimePatternParser();
    internal FixedFormatInfoPatternParser`1<OffsetDate> get_OffsetDatePatternParser();
    internal FixedFormatInfoPatternParser`1<OffsetTime> get_OffsetTimePatternParser();
    internal FixedFormatInfoPatternParser`1<ZonedDateTime> get_ZonedDateTimePatternParser();
    internal FixedFormatInfoPatternParser`1<AnnualDate> get_AnnualDatePatternParser();
    internal FixedFormatInfoPatternParser`1<YearMonth> get_YearMonthPatternParser();
    private FixedFormatInfoPatternParser`1<T> EnsureFixedFormatInitialized(FixedFormatInfoPatternParser`1& field, Func`1<IPatternParser`1<T>> patternParserFactory);
    public IReadOnlyList`1<string> get_LongMonthNames();
    public IReadOnlyList`1<string> get_ShortMonthNames();
    public IReadOnlyList`1<string> get_LongMonthGenitiveNames();
    public IReadOnlyList`1<string> get_ShortMonthGenitiveNames();
    public IReadOnlyList`1<string> get_LongDayNames();
    public IReadOnlyList`1<string> get_ShortDayNames();
    [CompilerGeneratedAttribute]
public DateTimeFormatInfo get_DateTimeFormat();
    public string get_TimeSeparator();
    public string get_DateSeparator();
    public string get_AMDesignator();
    public string get_PMDesignator();
    public IReadOnlyList`1<string> GetEraNames(Era era);
    public string GetEraPrimaryName(Era era);
    private EraDescription GetEraDescription(Era era);
    public static NodaFormatInfo get_CurrentInfo();
    public string get_OffsetPatternLong();
    public string get_OffsetPatternMedium();
    public string get_OffsetPatternShort();
    public string get_OffsetPatternLongNoPunctuation();
    public string get_OffsetPatternMediumNoPunctuation();
    public string get_OffsetPatternShortNoPunctuation();
    internal static void ClearCache();
    internal static NodaFormatInfo GetFormatInfo(CultureInfo cultureInfo);
    public static NodaFormatInfo GetInstance(IFormatProvider provider);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private EraDescription <GetEraDescription>b__86_0(Era key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.Globalization.PatternResources : object {
    [CompilerGeneratedAttribute]
private static ResourceManager <ResourceManager>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    private static PatternResources();
    [CompilerGeneratedAttribute]
internal static ResourceManager get_ResourceManager();
}
public interface NodaTime.IClock {
    public abstract virtual Instant GetCurrentInstant();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface NodaTime.IDateTimeZoneProvider {
    public string VersionId { get; }
    public ReadOnlyCollection`1<string> Ids { get; }
    public DateTimeZone Item { get; }
    public abstract virtual string get_VersionId();
    public abstract virtual ReadOnlyCollection`1<string> get_Ids();
    public abstract virtual DateTimeZone GetSystemDefault();
    public abstract virtual DateTimeZone GetZoneOrNull(string id);
    public abstract virtual DateTimeZone get_Item(string id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.InstantTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.Instant : ValueType {
    internal static int MinDays;
    internal static int MaxDays;
    private static long MinTicks;
    private static long MaxTicks;
    private static long MinMilliseconds;
    private static long MaxMilliseconds;
    private static long MinSeconds;
    private static long MaxSeconds;
    [CompilerGeneratedAttribute]
private static Instant <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static Instant <MaxValue>k__BackingField;
    internal static Instant BeforeMinValue;
    internal static Instant AfterMaxValue;
    private Duration duration;
    public static Instant MinValue { get; }
    public static Instant MaxValue { get; }
    internal bool IsValid { get; }
    internal Duration TimeSinceEpoch { get; }
    internal int DaysSinceEpoch { get; }
    internal long NanosecondOfDay { get; }
    private Instant(int days, bool deliberatelyInvalid);
    private Instant(Duration duration);
    internal Instant(int days, long nanoOfDay);
    private static Instant();
    [CompilerGeneratedAttribute]
public static Instant get_MinValue();
    [CompilerGeneratedAttribute]
public static Instant get_MaxValue();
    internal static Instant FromTrustedDuration(Duration duration);
    internal static Instant FromUntrustedDuration(Duration duration);
    internal bool get_IsValid();
    internal Duration get_TimeSinceEpoch();
    internal int get_DaysSinceEpoch();
    internal long get_NanosecondOfDay();
    public sealed virtual int CompareTo(Instant other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [PureAttribute]
public Instant PlusTicks(long ticks);
    [PureAttribute]
public Instant PlusNanoseconds(long nanoseconds);
    public static Instant op_Addition(Instant left, Duration right);
    [PureAttribute]
internal LocalInstant Plus(Offset offset);
    internal LocalInstant SafePlus(Offset offset);
    public static Instant Add(Instant left, Duration right);
    [PureAttribute]
public Instant Plus(Duration duration);
    public static Duration op_Subtraction(Instant left, Instant right);
    public static Instant op_Subtraction(Instant left, Duration right);
    public static Duration Subtract(Instant left, Instant right);
    [PureAttribute]
public Duration Minus(Instant other);
    [PureAttribute]
public static Instant Subtract(Instant left, Duration right);
    [PureAttribute]
public Instant Minus(Duration duration);
    public static bool op_Equality(Instant left, Instant right);
    public static bool op_Inequality(Instant left, Instant right);
    public static bool op_LessThan(Instant left, Instant right);
    public static bool op_LessThanOrEqual(Instant left, Instant right);
    public static bool op_GreaterThan(Instant left, Instant right);
    public static bool op_GreaterThanOrEqual(Instant left, Instant right);
    public static Instant FromUtc(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour);
    public static Instant FromUtc(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute);
    public static Instant Max(Instant x, Instant y);
    public static Instant Min(Instant x, Instant y);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public sealed virtual bool Equals(Instant other);
    [PureAttribute]
[TestExemptionAttribute("1")]
public double ToJulianDate();
    [PureAttribute]
public DateTime ToDateTimeUtc();
    [PureAttribute]
public DateTimeOffset ToDateTimeOffset();
    public static Instant FromDateTimeOffset(DateTimeOffset dateTimeOffset);
    public static Instant FromJulianDate(double julianDate);
    public static Instant FromDateTimeUtc(DateTime dateTime);
    public static Instant FromUnixTimeSeconds(long seconds);
    public static Instant FromUnixTimeMilliseconds(long milliseconds);
    public static Instant FromUnixTimeTicks(long ticks);
    [PureAttribute]
[TestExemptionAttribute("1")]
public long ToUnixTimeSeconds();
    [PureAttribute]
[TestExemptionAttribute("1")]
public long ToUnixTimeMilliseconds();
    [PureAttribute]
[TestExemptionAttribute("1")]
public long ToUnixTimeTicks();
    [PureAttribute]
public ZonedDateTime InUtc();
    [PureAttribute]
public ZonedDateTime InZone(DateTimeZone zone);
    [PureAttribute]
public ZonedDateTime InZone(DateTimeZone zone, CalendarSystem calendar);
    [PureAttribute]
public OffsetDateTime WithOffset(Offset offset);
    [PureAttribute]
public OffsetDateTime WithOffset(Offset offset, CalendarSystem calendar);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.Interval : ValueType {
    private Instant start;
    private Instant end;
    public Instant Start { get; }
    public bool HasStart { get; }
    public Instant End { get; }
    internal Instant RawEnd { get; }
    public bool HasEnd { get; }
    public Duration Duration { get; }
    public Interval(Instant start, Instant end);
    public Interval(Nullable`1<Instant> start, Nullable`1<Instant> end);
    public Instant get_Start();
    public bool get_HasStart();
    public Instant get_End();
    internal Instant get_RawEnd();
    public bool get_HasEnd();
    public Duration get_Duration();
    [PureAttribute]
public bool Contains(Instant instant);
    [PureAttribute]
public void Deconstruct(Nullable`1& start, Nullable`1& end);
    public sealed virtual bool Equals(Interval other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Interval left, Interval right);
    public static bool op_Inequality(Interval left, Interval right);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
public enum NodaTime.IsoDayOfWeek : Enum {
    public int value__;
    public static IsoDayOfWeek None;
    public static IsoDayOfWeek Monday;
    public static IsoDayOfWeek Tuesday;
    public static IsoDayOfWeek Wednesday;
    public static IsoDayOfWeek Thursday;
    public static IsoDayOfWeek Friday;
    public static IsoDayOfWeek Saturday;
    public static IsoDayOfWeek Sunday;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.LocalDateTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.LocalDate : ValueType {
    private YearMonthDayCalendar yearMonthDayCalendar;
    public static LocalDate MaxIsoValue { get; }
    public static LocalDate MinIsoValue { get; }
    public CalendarSystem Calendar { get; }
    private CalendarOrdinal CalendarOrdinal { get; }
    public int Year { get; }
    public int Month { get; }
    public int Day { get; }
    internal int DaysSinceEpoch { get; }
    public IsoDayOfWeek DayOfWeek { get; }
    public int YearOfEra { get; }
    public Era Era { get; }
    public int DayOfYear { get; }
    internal YearMonthDay YearMonthDay { get; }
    internal YearMonthDayCalendar YearMonthDayCalendar { get; }
    internal LocalDate(YearMonthDayCalendar yearMonthDayCalendar);
    internal LocalDate(int daysSinceEpoch);
    internal LocalDate(int daysSinceEpoch, CalendarSystem calendar);
    public LocalDate(int year, int month, int day);
    public LocalDate(int year, int month, int day, CalendarSystem calendar);
    public LocalDate(Era era, int yearOfEra, int month, int day);
    public LocalDate(Era era, int yearOfEra, int month, int day, CalendarSystem calendar);
    public static LocalDate get_MaxIsoValue();
    public static LocalDate get_MinIsoValue();
    public CalendarSystem get_Calendar();
    private CalendarOrdinal get_CalendarOrdinal();
    public int get_Year();
    public int get_Month();
    public int get_Day();
    internal int get_DaysSinceEpoch();
    public IsoDayOfWeek get_DayOfWeek();
    public int get_YearOfEra();
    public Era get_Era();
    public int get_DayOfYear();
    internal YearMonthDay get_YearMonthDay();
    internal YearMonthDayCalendar get_YearMonthDayCalendar();
    [PureAttribute]
public LocalDateTime AtMidnight();
    [PureAttribute]
public DateTime ToDateTimeUnspecified();
    private static int NonNegativeTicksToDays(long ticks);
    public static LocalDate FromDateTime(DateTime dateTime);
    public static LocalDate FromDateTime(DateTime dateTime, CalendarSystem calendar);
    public static LocalDate FromWeekYearWeekAndDay(int weekYear, int weekOfWeekYear, IsoDayOfWeek dayOfWeek);
    public static LocalDate FromYearMonthWeekAndDay(int year, int month, int occurrence, IsoDayOfWeek dayOfWeek);
    [PureAttribute]
public YearMonth ToYearMonth();
    public static LocalDate op_Addition(LocalDate date, Period period);
    public static LocalDate Add(LocalDate date, Period period);
    [PureAttribute]
public LocalDate Plus(Period period);
    public static LocalDateTime op_Addition(LocalDate date, LocalTime time);
    public static LocalDate op_Subtraction(LocalDate date, Period period);
    public static LocalDate Subtract(LocalDate date, Period period);
    [PureAttribute]
public LocalDate Minus(Period period);
    public static Period op_Subtraction(LocalDate lhs, LocalDate rhs);
    public static Period Subtract(LocalDate lhs, LocalDate rhs);
    [PureAttribute]
public Period Minus(LocalDate date);
    public static bool op_Equality(LocalDate lhs, LocalDate rhs);
    public static bool op_Inequality(LocalDate lhs, LocalDate rhs);
    public static bool op_LessThan(LocalDate lhs, LocalDate rhs);
    public static bool op_LessThanOrEqual(LocalDate lhs, LocalDate rhs);
    public static bool op_GreaterThan(LocalDate lhs, LocalDate rhs);
    public static bool op_GreaterThanOrEqual(LocalDate lhs, LocalDate rhs);
    public sealed virtual int CompareTo(LocalDate other);
    private int TrustedCompareTo(LocalDate other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
    public static LocalDate Max(LocalDate x, LocalDate y);
    public static LocalDate Min(LocalDate x, LocalDate y);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LocalDate other);
    [PureAttribute]
public ZonedDateTime AtStartOfDayInZone(DateTimeZone zone);
    [PureAttribute]
public LocalDate WithCalendar(CalendarSystem calendar);
    [PureAttribute]
public LocalDate PlusYears(int years);
    [PureAttribute]
public LocalDate PlusMonths(int months);
    [PureAttribute]
public LocalDate PlusDays(int days);
    [PureAttribute]
public LocalDate PlusWeeks(int weeks);
    [PureAttribute]
public LocalDate Next(IsoDayOfWeek targetDayOfWeek);
    [PureAttribute]
public LocalDate Previous(IsoDayOfWeek targetDayOfWeek);
    [PureAttribute]
public OffsetDate WithOffset(Offset offset);
    [PureAttribute]
public LocalDateTime At(LocalTime time);
    [PureAttribute]
public LocalDate With(Func`2<LocalDate, LocalDate> adjuster);
    [PureAttribute]
public void Deconstruct(Int32& year, Int32& month, Int32& day);
    [PureAttribute]
public void Deconstruct(Int32& year, Int32& month, Int32& day, CalendarSystem& calendar);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    [PureAttribute]
public DateOnly ToDateOnly();
    public static LocalDate FromDateOnly(DateOnly date);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.LocalDateTimeTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.LocalDateTime : ValueType {
    private LocalDate date;
    private LocalTime time;
    public static LocalDateTime MaxIsoValue { get; }
    public static LocalDateTime MinIsoValue { get; }
    public CalendarSystem Calendar { get; }
    public int Year { get; }
    public int YearOfEra { get; }
    public Era Era { get; }
    public int Month { get; }
    public int DayOfYear { get; }
    public int Day { get; }
    public IsoDayOfWeek DayOfWeek { get; }
    public int Hour { get; }
    public int ClockHourOfHalfDay { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Millisecond { get; }
    public int TickOfSecond { get; }
    public long TickOfDay { get; }
    public int NanosecondOfSecond { get; }
    public long NanosecondOfDay { get; }
    public LocalTime TimeOfDay { get; }
    public LocalDate Date { get; }
    internal LocalDateTime(LocalInstant localInstant);
    public LocalDateTime(int year, int month, int day, int hour, int minute);
    public LocalDateTime(int year, int month, int day, int hour, int minute, CalendarSystem calendar);
    public LocalDateTime(int year, int month, int day, int hour, int minute, int second);
    public LocalDateTime(int year, int month, int day, int hour, int minute, int second, CalendarSystem calendar);
    public LocalDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public LocalDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, CalendarSystem calendar);
    internal LocalDateTime(LocalDate date, LocalTime time);
    public static LocalDateTime get_MaxIsoValue();
    public static LocalDateTime get_MinIsoValue();
    public CalendarSystem get_Calendar();
    public int get_Year();
    public int get_YearOfEra();
    public Era get_Era();
    public int get_Month();
    public int get_DayOfYear();
    public int get_Day();
    public IsoDayOfWeek get_DayOfWeek();
    public int get_Hour();
    public int get_ClockHourOfHalfDay();
    public int get_Minute();
    public int get_Second();
    public int get_Millisecond();
    public int get_TickOfSecond();
    public long get_TickOfDay();
    public int get_NanosecondOfSecond();
    public long get_NanosecondOfDay();
    public LocalTime get_TimeOfDay();
    public LocalDate get_Date();
    [PureAttribute]
public DateTime ToDateTimeUnspecified();
    [PureAttribute]
internal LocalInstant ToLocalInstant();
    public static LocalDateTime FromDateTime(DateTime dateTime);
    public static LocalDateTime FromDateTime(DateTime dateTime, CalendarSystem calendar);
    public sealed virtual bool Equals(LocalDateTime other);
    public static bool op_Equality(LocalDateTime left, LocalDateTime right);
    public static bool op_Inequality(LocalDateTime left, LocalDateTime right);
    public static bool op_LessThan(LocalDateTime lhs, LocalDateTime rhs);
    public static bool op_LessThanOrEqual(LocalDateTime lhs, LocalDateTime rhs);
    public static bool op_GreaterThan(LocalDateTime lhs, LocalDateTime rhs);
    public static bool op_GreaterThanOrEqual(LocalDateTime lhs, LocalDateTime rhs);
    public sealed virtual int CompareTo(LocalDateTime other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
    public static LocalDateTime op_Addition(LocalDateTime localDateTime, Period period);
    public static LocalDateTime Add(LocalDateTime localDateTime, Period period);
    [PureAttribute]
public LocalDateTime Plus(Period period);
    public static LocalDateTime op_Subtraction(LocalDateTime localDateTime, Period period);
    public static LocalDateTime Subtract(LocalDateTime localDateTime, Period period);
    [PureAttribute]
public LocalDateTime Minus(Period period);
    public static Period op_Subtraction(LocalDateTime lhs, LocalDateTime rhs);
    public static Period Subtract(LocalDateTime lhs, LocalDateTime rhs);
    [PureAttribute]
public Period Minus(LocalDateTime localDateTime);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [PureAttribute]
public LocalDateTime With(Func`2<LocalDate, LocalDate> adjuster);
    [PureAttribute]
public LocalDateTime With(Func`2<LocalTime, LocalTime> adjuster);
    [PureAttribute]
public LocalDateTime WithCalendar(CalendarSystem calendar);
    [PureAttribute]
public LocalDateTime PlusYears(int years);
    [PureAttribute]
public LocalDateTime PlusMonths(int months);
    [PureAttribute]
public LocalDateTime PlusDays(int days);
    [PureAttribute]
public LocalDateTime PlusWeeks(int weeks);
    [PureAttribute]
public LocalDateTime PlusHours(long hours);
    [PureAttribute]
public LocalDateTime PlusMinutes(long minutes);
    [PureAttribute]
public LocalDateTime PlusSeconds(long seconds);
    [PureAttribute]
public LocalDateTime PlusMilliseconds(long milliseconds);
    [PureAttribute]
public LocalDateTime PlusTicks(long ticks);
    [PureAttribute]
public LocalDateTime PlusNanoseconds(long nanoseconds);
    [PureAttribute]
public LocalDateTime Next(IsoDayOfWeek targetDayOfWeek);
    [PureAttribute]
public LocalDateTime Previous(IsoDayOfWeek targetDayOfWeek);
    [PureAttribute]
public OffsetDateTime WithOffset(Offset offset);
    [PureAttribute]
public ZonedDateTime InUtc();
    [PureAttribute]
public ZonedDateTime InZoneStrictly(DateTimeZone zone);
    [PureAttribute]
public ZonedDateTime InZoneLeniently(DateTimeZone zone);
    [PureAttribute]
public ZonedDateTime InZone(DateTimeZone zone, ZoneLocalMappingResolver resolver);
    [PureAttribute]
public void Deconstruct(LocalDate& date, LocalTime& time);
    public static LocalDateTime Max(LocalDateTime x, LocalDateTime y);
    public static LocalDateTime Min(LocalDateTime x, LocalDateTime y);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[IsReadOnlyAttribute]
internal class NodaTime.LocalInstant : ValueType {
    public static LocalInstant BeforeMinValue;
    public static LocalInstant AfterMaxValue;
    private Duration duration;
    internal bool IsValid { get; }
    internal Duration TimeSinceLocalEpoch { get; }
    internal int DaysSinceEpoch { get; }
    internal long NanosecondOfDay { get; }
    private LocalInstant(int days, bool deliberatelyInvalid);
    internal LocalInstant(Duration nanoseconds);
    internal LocalInstant(int days, long nanoOfDay);
    private static LocalInstant();
    internal bool get_IsValid();
    internal Duration get_TimeSinceLocalEpoch();
    internal int get_DaysSinceEpoch();
    internal long get_NanosecondOfDay();
    internal Instant MinusZeroOffset();
    public Instant Minus(Offset offset);
    public static bool op_Equality(LocalInstant left, LocalInstant right);
    internal Instant SafeMinus(Offset offset);
    public static bool op_Inequality(LocalInstant left, LocalInstant right);
    public static bool op_LessThan(LocalInstant left, LocalInstant right);
    public static bool op_LessThanOrEqual(LocalInstant left, LocalInstant right);
    public static bool op_GreaterThan(LocalInstant left, LocalInstant right);
    public static bool op_GreaterThanOrEqual(LocalInstant left, LocalInstant right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(LocalInstant other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.LocalTimeTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.LocalTime : ValueType {
    [CompilerGeneratedAttribute]
private static LocalTime <Midnight>k__BackingField;
    [CompilerGeneratedAttribute]
private static LocalTime <Noon>k__BackingField;
    [CompilerGeneratedAttribute]
private static LocalTime <MaxValue>k__BackingField;
    private long nanoseconds;
    public static LocalTime Midnight { get; }
    public static LocalTime MinValue { get; }
    public static LocalTime Noon { get; }
    public static LocalTime MaxValue { get; }
    public int Hour { get; }
    public int ClockHourOfHalfDay { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Millisecond { get; }
    public int TickOfSecond { get; }
    public long TickOfDay { get; }
    public int NanosecondOfSecond { get; }
    public long NanosecondOfDay { get; }
    public LocalTime(int hour, int minute);
    public LocalTime(int hour, int minute, int second);
    public LocalTime(int hour, int minute, int second, int millisecond);
    internal LocalTime(long nanoseconds);
    private static LocalTime();
    [CompilerGeneratedAttribute]
public static LocalTime get_Midnight();
    public static LocalTime get_MinValue();
    [CompilerGeneratedAttribute]
public static LocalTime get_Noon();
    [CompilerGeneratedAttribute]
public static LocalTime get_MaxValue();
    public static LocalTime FromHourMinuteSecondMillisecondTick(int hour, int minute, int second, int millisecond, int tickWithinMillisecond);
    public static LocalTime FromHourMinuteSecondTick(int hour, int minute, int second, int tickWithinSecond);
    public static LocalTime FromHourMinuteSecondNanosecond(int hour, int minute, int second, long nanosecondWithinSecond);
    internal static LocalTime FromHourMinuteSecondNanosecondTrusted(int hour, int minute, int second, long nanosecondWithinSecond);
    public static LocalTime FromNanosecondsSinceMidnight(long nanoseconds);
    public static LocalTime FromTicksSinceMidnight(long ticks);
    public static LocalTime FromMillisecondsSinceMidnight(int milliseconds);
    public static LocalTime FromSecondsSinceMidnight(int seconds);
    public static LocalTime FromMinutesSinceMidnight(int minutes);
    public static LocalTime FromHoursSinceMidnight(int hours);
    public int get_Hour();
    public int get_ClockHourOfHalfDay();
    public int get_Minute();
    public int get_Second();
    public int get_Millisecond();
    public int get_TickOfSecond();
    public long get_TickOfDay();
    public int get_NanosecondOfSecond();
    public long get_NanosecondOfDay();
    public static LocalTime op_Addition(LocalTime time, Period period);
    public static LocalTime Add(LocalTime time, Period period);
    [PureAttribute]
public LocalTime Plus(Period period);
    public static LocalTime op_Subtraction(LocalTime time, Period period);
    public static LocalTime Subtract(LocalTime time, Period period);
    [PureAttribute]
public LocalTime Minus(Period period);
    public static Period op_Subtraction(LocalTime lhs, LocalTime rhs);
    public static Period Subtract(LocalTime lhs, LocalTime rhs);
    [PureAttribute]
public Period Minus(LocalTime time);
    public static bool op_Equality(LocalTime lhs, LocalTime rhs);
    public static bool op_Inequality(LocalTime lhs, LocalTime rhs);
    public static bool op_LessThan(LocalTime lhs, LocalTime rhs);
    public static bool op_LessThanOrEqual(LocalTime lhs, LocalTime rhs);
    public static bool op_GreaterThan(LocalTime lhs, LocalTime rhs);
    public static bool op_GreaterThanOrEqual(LocalTime lhs, LocalTime rhs);
    public sealed virtual int CompareTo(LocalTime other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(LocalTime other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [PureAttribute]
public LocalTime PlusHours(long hours);
    [PureAttribute]
public LocalTime PlusMinutes(long minutes);
    [PureAttribute]
public LocalTime PlusSeconds(long seconds);
    [PureAttribute]
public LocalTime PlusMilliseconds(long milliseconds);
    [PureAttribute]
public LocalTime PlusTicks(long ticks);
    [PureAttribute]
public LocalTime PlusNanoseconds(long nanoseconds);
    [PureAttribute]
public LocalTime With(Func`2<LocalTime, LocalTime> adjuster);
    [PureAttribute]
public OffsetTime WithOffset(Offset offset);
    [PureAttribute]
public LocalDateTime On(LocalDate date);
    [PureAttribute]
public void Deconstruct(Int32& hour, Int32& minute, Int32& second);
    public static LocalTime Max(LocalTime x, LocalTime y);
    public static LocalTime Min(LocalTime x, LocalTime y);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    [PureAttribute]
public TimeOnly ToTimeOnly();
    public static LocalTime FromTimeOnly(TimeOnly time);
}
public static class NodaTime.NodaConstants : object {
    public static long NanosecondsPerTick;
    public static long NanosecondsPerMicrosecond;
    public static long NanosecondsPerMillisecond;
    public static long NanosecondsPerSecond;
    public static long NanosecondsPerMinute;
    public static long NanosecondsPerHour;
    public static long NanosecondsPerDay;
    public static long NanosecondsPerWeek;
    public static long TicksPerMillisecond;
    public static long TicksPerSecond;
    public static long TicksPerMinute;
    public static long TicksPerHour;
    public static long TicksPerDay;
    public static long TicksPerWeek;
    public static long MicrosecondsPerSecond;
    public static int MillisecondsPerSecond;
    public static int MillisecondsPerMinute;
    public static int MillisecondsPerHour;
    public static int MillisecondsPerDay;
    public static int MillisecondsPerWeek;
    public static int SecondsPerMinute;
    public static int SecondsPerHour;
    public static int SecondsPerDay;
    public static int SecondsPerWeek;
    public static int MinutesPerHour;
    public static int MinutesPerDay;
    public static int MinutesPerWeek;
    public static int HoursPerDay;
    public static int HoursPerWeek;
    public static int DaysPerWeek;
    [CompilerGeneratedAttribute]
private static Instant <UnixEpoch>k__BackingField;
    [CompilerGeneratedAttribute]
private static Instant <BclEpoch>k__BackingField;
    [CompilerGeneratedAttribute]
private static Instant <JulianEpoch>k__BackingField;
    internal static long BclTicksAtUnixEpoch;
    internal static int BclDaysAtUnixEpoch;
    public static Instant UnixEpoch { get; }
    public static Instant BclEpoch { get; }
    public static Instant JulianEpoch { get; }
    private static NodaConstants();
    [CompilerGeneratedAttribute]
public static Instant get_UnixEpoch();
    [CompilerGeneratedAttribute]
public static Instant get_BclEpoch();
    [CompilerGeneratedAttribute]
public static Instant get_JulianEpoch();
}
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.OffsetTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.Offset : ValueType {
    public static Offset Zero;
    public static Offset MinValue;
    public static Offset MaxValue;
    private static int MinHours;
    private static int MaxHours;
    internal static int MinSeconds;
    internal static int MaxSeconds;
    private static int MinMilliseconds;
    private static int MaxMilliseconds;
    private static long MinTicks;
    private static long MaxTicks;
    private static long MinNanoseconds;
    private static long MaxNanoseconds;
    private int seconds;
    public int Seconds { get; }
    public int Milliseconds { get; }
    public long Ticks { get; }
    public long Nanoseconds { get; }
    internal Offset(int seconds);
    private static Offset();
    public int get_Seconds();
    public int get_Milliseconds();
    public long get_Ticks();
    public long get_Nanoseconds();
    public static Offset Max(Offset x, Offset y);
    public static Offset Min(Offset x, Offset y);
    public static Offset op_UnaryNegation(Offset offset);
    public static Offset Negate(Offset offset);
    public static Offset op_UnaryPlus(Offset offset);
    public static Offset op_Addition(Offset left, Offset right);
    public static Offset Add(Offset left, Offset right);
    [PureAttribute]
public Offset Plus(Offset other);
    public static Offset op_Subtraction(Offset minuend, Offset subtrahend);
    public static Offset Subtract(Offset minuend, Offset subtrahend);
    [PureAttribute]
public Offset Minus(Offset other);
    public static bool op_Equality(Offset left, Offset right);
    public static bool op_Inequality(Offset left, Offset right);
    public static bool op_LessThan(Offset left, Offset right);
    public static bool op_LessThanOrEqual(Offset left, Offset right);
    public static bool op_GreaterThan(Offset left, Offset right);
    public static bool op_GreaterThanOrEqual(Offset left, Offset right);
    public sealed virtual int CompareTo(Offset other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual bool Equals(Offset other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public static Offset FromSeconds(int seconds);
    public static Offset FromMilliseconds(int milliseconds);
    public static Offset FromTicks(long ticks);
    public static Offset FromNanoseconds(long nanoseconds);
    public static Offset FromHours(int hours);
    public static Offset FromHoursAndMinutes(int hours, int minutes);
    [PureAttribute]
public TimeSpan ToTimeSpan();
    public static Offset FromTimeSpan(TimeSpan timeSpan);
    [NullableContextAttribute("1")]
public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    [NullableContextAttribute("1")]
private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    [NullableContextAttribute("1")]
private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    [NullableContextAttribute("1")]
private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.OffsetDateTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.OffsetDate : ValueType {
    private LocalDate date;
    private Offset offset;
    public LocalDate Date { get; }
    public Offset Offset { get; }
    public CalendarSystem Calendar { get; }
    public int Year { get; }
    public int Month { get; }
    public int Day { get; }
    public IsoDayOfWeek DayOfWeek { get; }
    public int YearOfEra { get; }
    public Era Era { get; }
    public int DayOfYear { get; }
    public OffsetDate(LocalDate date, Offset offset);
    public LocalDate get_Date();
    public Offset get_Offset();
    public CalendarSystem get_Calendar();
    public int get_Year();
    public int get_Month();
    public int get_Day();
    public IsoDayOfWeek get_DayOfWeek();
    public int get_YearOfEra();
    public Era get_Era();
    public int get_DayOfYear();
    [PureAttribute]
public OffsetDate WithOffset(Offset offset);
    [PureAttribute]
public OffsetDate With(Func`2<LocalDate, LocalDate> adjuster);
    [PureAttribute]
public OffsetDate WithCalendar(CalendarSystem calendar);
    [PureAttribute]
public OffsetDateTime At(LocalTime time);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OffsetDate other);
    public static bool op_Equality(OffsetDate left, OffsetDate right);
    public static bool op_Inequality(OffsetDate left, OffsetDate right);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    [PureAttribute]
public void Deconstruct(LocalDate& localDate, Offset& offset);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.OffsetDateTimeTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.OffsetDateTime : ValueType {
    private static int MinBclOffsetMinutes;
    private static int MaxBclOffsetMinutes;
    private LocalDate localDate;
    private OffsetTime offsetTime;
    public CalendarSystem Calendar { get; }
    public int Year { get; }
    public int Month { get; }
    public int Day { get; }
    internal YearMonthDay YearMonthDay { get; }
    public IsoDayOfWeek DayOfWeek { get; }
    public int YearOfEra { get; }
    public Era Era { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public int ClockHourOfHalfDay { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Millisecond { get; }
    public int TickOfSecond { get; }
    public long TickOfDay { get; }
    public int NanosecondOfSecond { get; }
    public long NanosecondOfDay { get; }
    public LocalDateTime LocalDateTime { get; }
    public LocalDate Date { get; }
    public LocalTime TimeOfDay { get; }
    public Offset Offset { get; }
    internal OffsetDateTime(LocalDate localDate, OffsetTime offsetTime);
    internal OffsetDateTime(Instant instant, Offset offset);
    internal OffsetDateTime(Instant instant, Offset offset, CalendarSystem calendar);
    public OffsetDateTime(LocalDateTime localDateTime, Offset offset);
    public CalendarSystem get_Calendar();
    public int get_Year();
    public int get_Month();
    public int get_Day();
    internal YearMonthDay get_YearMonthDay();
    public IsoDayOfWeek get_DayOfWeek();
    public int get_YearOfEra();
    public Era get_Era();
    public int get_DayOfYear();
    public int get_Hour();
    public int get_ClockHourOfHalfDay();
    public int get_Minute();
    public int get_Second();
    public int get_Millisecond();
    public int get_TickOfSecond();
    public long get_TickOfDay();
    public int get_NanosecondOfSecond();
    public long get_NanosecondOfDay();
    public LocalDateTime get_LocalDateTime();
    public LocalDate get_Date();
    public LocalTime get_TimeOfDay();
    public Offset get_Offset();
    [PureAttribute]
public Instant ToInstant();
    private Duration ToElapsedTimeSinceEpoch();
    [PureAttribute]
public ZonedDateTime InFixedZone();
    [PureAttribute]
public ZonedDateTime InZone(DateTimeZone zone);
    [PureAttribute]
public DateTimeOffset ToDateTimeOffset();
    [PureAttribute]
public static OffsetDateTime FromDateTimeOffset(DateTimeOffset dateTimeOffset);
    [PureAttribute]
public OffsetDateTime WithCalendar(CalendarSystem calendar);
    [PureAttribute]
public OffsetDateTime With(Func`2<LocalDate, LocalDate> adjuster);
    [PureAttribute]
public OffsetDateTime With(Func`2<LocalTime, LocalTime> adjuster);
    [PureAttribute]
public OffsetDateTime WithOffset(Offset offset);
    [PureAttribute]
public OffsetDate ToOffsetDate();
    [PureAttribute]
public OffsetTime ToOffsetTime();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OffsetDateTime other);
    [PureAttribute]
public void Deconstruct(LocalDateTime& localDateTime, Offset& offset);
    [PureAttribute]
public void Deconstruct(LocalDate& localDate, LocalTime& localTime, Offset& offset);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public static OffsetDateTime Add(OffsetDateTime offsetDateTime, Duration duration);
    [PureAttribute]
public OffsetDateTime Plus(Duration duration);
    [PureAttribute]
public OffsetDateTime PlusHours(int hours);
    [PureAttribute]
public OffsetDateTime PlusMinutes(int minutes);
    [PureAttribute]
public OffsetDateTime PlusSeconds(long seconds);
    [PureAttribute]
public OffsetDateTime PlusMilliseconds(long milliseconds);
    [PureAttribute]
public OffsetDateTime PlusTicks(long ticks);
    [PureAttribute]
public OffsetDateTime PlusNanoseconds(long nanoseconds);
    public static OffsetDateTime op_Addition(OffsetDateTime offsetDateTime, Duration duration);
    public static OffsetDateTime Subtract(OffsetDateTime offsetDateTime, Duration duration);
    [PureAttribute]
public OffsetDateTime Minus(Duration duration);
    public static OffsetDateTime op_Subtraction(OffsetDateTime offsetDateTime, Duration duration);
    public static Duration Subtract(OffsetDateTime end, OffsetDateTime start);
    [PureAttribute]
public Duration Minus(OffsetDateTime other);
    public static Duration op_Subtraction(OffsetDateTime end, OffsetDateTime start);
    public static bool op_Equality(OffsetDateTime left, OffsetDateTime right);
    public static bool op_Inequality(OffsetDateTime left, OffsetDateTime right);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.OffsetTimeTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.OffsetTime : ValueType {
    private static int NanosecondsBits;
    private static long NanosecondsMask;
    private long nanosecondsAndOffset;
    public LocalTime TimeOfDay { get; }
    public Offset Offset { get; }
    internal int OffsetSeconds { get; }
    internal long OffsetNanoseconds { get; }
    public int Hour { get; }
    public int ClockHourOfHalfDay { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Millisecond { get; }
    public int TickOfSecond { get; }
    public long TickOfDay { get; }
    public int NanosecondOfSecond { get; }
    public long NanosecondOfDay { get; }
    internal OffsetTime(long nanosecondOfDayZeroOffset);
    internal OffsetTime(long nanosecondOfDay, int offsetSeconds);
    public OffsetTime(LocalTime time, Offset offset);
    public LocalTime get_TimeOfDay();
    public Offset get_Offset();
    internal int get_OffsetSeconds();
    internal long get_OffsetNanoseconds();
    public int get_Hour();
    public int get_ClockHourOfHalfDay();
    public int get_Minute();
    public int get_Second();
    public int get_Millisecond();
    public int get_TickOfSecond();
    public long get_TickOfDay();
    public int get_NanosecondOfSecond();
    public long get_NanosecondOfDay();
    [PureAttribute]
public OffsetTime WithOffset(Offset offset);
    [PureAttribute]
public OffsetTime With(Func`2<LocalTime, LocalTime> adjuster);
    [PureAttribute]
public OffsetDateTime On(LocalDate date);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OffsetTime other);
    public static bool op_Equality(OffsetTime left, OffsetTime right);
    public static bool op_Inequality(OffsetTime left, OffsetTime right);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    [PureAttribute]
public void Deconstruct(LocalTime& localTime, Offset& offset);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
[TypeConverterAttribute("NodaTime.Text.PeriodTypeConverter")]
public class NodaTime.Period : object {
    [CompilerGeneratedAttribute]
private static Period <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Nanoseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Ticks>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Milliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Seconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Minutes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Hours>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Days>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Weeks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Months>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Years>k__BackingField;
    public static Period Zero { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEqualityComparer`1<Period> NormalizingEqualityComparer { get; }
    public long Nanoseconds { get; }
    public long Ticks { get; }
    public long Milliseconds { get; }
    public long Seconds { get; }
    public long Minutes { get; }
    public long Hours { get; }
    public int Days { get; }
    public int Weeks { get; }
    public int Months { get; }
    public int Years { get; }
    public bool HasTimeComponent { get; }
    public bool HasDateComponent { get; }
    private long TotalNanoseconds { get; }
    private Period(int years, int months, int weeks, int days);
    private Period(long hours, long minutes, long seconds, long milliseconds, long ticks, long nanoseconds);
    internal Period(int years, int months, int weeks, int days, long hours, long minutes, long seconds, long milliseconds, long ticks, long nanoseconds);
    private static Period();
    [CompilerGeneratedAttribute]
public static Period get_Zero();
    public static IEqualityComparer`1<Period> get_NormalizingEqualityComparer();
    [CompilerGeneratedAttribute]
public long get_Nanoseconds();
    [CompilerGeneratedAttribute]
public long get_Ticks();
    [CompilerGeneratedAttribute]
public long get_Milliseconds();
    [CompilerGeneratedAttribute]
public long get_Seconds();
    [CompilerGeneratedAttribute]
public long get_Minutes();
    [CompilerGeneratedAttribute]
public long get_Hours();
    [CompilerGeneratedAttribute]
public int get_Days();
    [CompilerGeneratedAttribute]
public int get_Weeks();
    [CompilerGeneratedAttribute]
public int get_Months();
    [CompilerGeneratedAttribute]
public int get_Years();
    public static Period FromYears(int years);
    public static Period FromMonths(int months);
    public static Period FromWeeks(int weeks);
    public static Period FromDays(int days);
    public static Period FromHours(long hours);
    public static Period FromMinutes(long minutes);
    public static Period FromSeconds(long seconds);
    public static Period FromMilliseconds(long milliseconds);
    public static Period FromTicks(long ticks);
    public static Period FromNanoseconds(long nanoseconds);
    public static Period op_Addition(Period left, Period right);
    public static Period Add(Period left, Period right);
    public static IComparer`1<Period> CreateComparer(LocalDateTime baseDateTime);
    public static Period op_Subtraction(Period minuend, Period subtrahend);
    public static Period Subtract(Period minuend, Period subtrahend);
    public static int DaysBetween(LocalDate start, LocalDate end);
    public static Period Between(LocalDateTime start, LocalDateTime end, PeriodUnits units);
    private static LocalDate DateComponentsBetween(LocalDate start, LocalDate end, PeriodUnits units, Int32& years, Int32& months, Int32& weeks, Int32& days);
    private static void TimeComponentsBetween(long totalNanoseconds, PeriodUnits units, Int64& hours, Int64& minutes, Int64& seconds, Int64& milliseconds, Int64& ticks, Int64& nanoseconds);
    [PureAttribute]
public static Period Between(LocalDateTime start, LocalDateTime end);
    [PureAttribute]
public static Period Between(LocalDate start, LocalDate end, PeriodUnits units);
    [PureAttribute]
public static Period Between(LocalDate start, LocalDate end);
    [PureAttribute]
public static Period Between(LocalTime start, LocalTime end, PeriodUnits units);
    [PureAttribute]
public static Period Between(LocalTime start, LocalTime end);
    internal static int InternalDaysBetween(LocalDate start, LocalDate end);
    [PureAttribute]
public static Period Between(YearMonth start, YearMonth end, PeriodUnits units);
    [PureAttribute]
public static Period Between(YearMonth start, YearMonth end);
    public bool get_HasTimeComponent();
    public bool get_HasDateComponent();
    [PureAttribute]
public Duration ToDuration();
    private long get_TotalNanoseconds();
    [PureAttribute]
[TestExemptionAttribute("1")]
public PeriodBuilder ToBuilder();
    [PureAttribute]
public Period Normalize();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Period other);
    [NullableContextAttribute("2")]
public static bool op_Equality(Period left, Period right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Period left, Period right);
    [CompilerGeneratedAttribute]
internal static long <Between>g__UnitsBetween|54_0(PeriodUnits mask, TimePeriodField timeField, <>c__DisplayClass54_0& );
    [CompilerGeneratedAttribute]
internal static int <DateComponentsBetween>g__UnitsBetween|55_0(PeriodUnits maskedUnits, LocalDate& startDate, LocalDate endDate, IDatePeriodField dateField);
    [CompilerGeneratedAttribute]
internal static long <TimeComponentsBetween>g__UnitsBetween|56_0(PeriodUnits mask, long nanosecondsPerUnit, <>c__DisplayClass56_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[MutableAttribute]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.PeriodBuilder : object {
    [CompilerGeneratedAttribute]
private int <Years>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Months>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Weeks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Days>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Hours>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Minutes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Seconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Milliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Ticks>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Nanoseconds>k__BackingField;
    public int Years { get; public set; }
    public int Months { get; public set; }
    public int Weeks { get; public set; }
    public int Days { get; public set; }
    public long Hours { get; public set; }
    public long Minutes { get; public set; }
    public long Seconds { get; public set; }
    public long Milliseconds { get; public set; }
    public long Ticks { get; public set; }
    public long Nanoseconds { get; public set; }
    public long Item { get; public set; }
    public PeriodBuilder(Period period);
    [CompilerGeneratedAttribute]
public int get_Years();
    [CompilerGeneratedAttribute]
public void set_Years(int value);
    [CompilerGeneratedAttribute]
public int get_Months();
    [CompilerGeneratedAttribute]
public void set_Months(int value);
    [CompilerGeneratedAttribute]
public int get_Weeks();
    [CompilerGeneratedAttribute]
public void set_Weeks(int value);
    [CompilerGeneratedAttribute]
public int get_Days();
    [CompilerGeneratedAttribute]
public void set_Days(int value);
    [CompilerGeneratedAttribute]
public long get_Hours();
    [CompilerGeneratedAttribute]
public void set_Hours(long value);
    [CompilerGeneratedAttribute]
public long get_Minutes();
    [CompilerGeneratedAttribute]
public void set_Minutes(long value);
    [CompilerGeneratedAttribute]
public long get_Seconds();
    [CompilerGeneratedAttribute]
public void set_Seconds(long value);
    [CompilerGeneratedAttribute]
public long get_Milliseconds();
    [CompilerGeneratedAttribute]
public void set_Milliseconds(long value);
    [CompilerGeneratedAttribute]
public long get_Ticks();
    [CompilerGeneratedAttribute]
public void set_Ticks(long value);
    [CompilerGeneratedAttribute]
public long get_Nanoseconds();
    [CompilerGeneratedAttribute]
public void set_Nanoseconds(long value);
    public long get_Item(PeriodUnits unit);
    public void set_Item(PeriodUnits unit, long value);
    public Period Build();
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[FlagsAttribute]
public enum NodaTime.PeriodUnits : Enum {
    public int value__;
    public static PeriodUnits None;
    public static PeriodUnits Years;
    public static PeriodUnits Months;
    public static PeriodUnits Weeks;
    public static PeriodUnits Days;
    public static PeriodUnits AllDateUnits;
    public static PeriodUnits YearMonthDay;
    public static PeriodUnits Hours;
    public static PeriodUnits Minutes;
    public static PeriodUnits Seconds;
    public static PeriodUnits Milliseconds;
    public static PeriodUnits Ticks;
    public static PeriodUnits Nanoseconds;
    public static PeriodUnits HourMinuteSecond;
    public static PeriodUnits AllTimeUnits;
    public static PeriodUnits DateAndTime;
    public static PeriodUnits AllUnits;
}
internal static class NodaTime.Properties.AssemblyInfo : object {
    [NullableAttribute("1")]
internal static string PublicKeySuffix;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MutableAttribute]
public class NodaTime.SkippedTimeException : ArgumentOutOfRangeException {
    [CompilerGeneratedAttribute]
private LocalDateTime <LocalDateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeZone <Zone>k__BackingField;
    public LocalDateTime LocalDateTime { get; }
    public DateTimeZone Zone { get; }
    public SkippedTimeException(LocalDateTime localDateTime, DateTimeZone zone);
    [CompilerGeneratedAttribute]
public LocalDateTime get_LocalDateTime();
    [CompilerGeneratedAttribute]
public DateTimeZone get_Zone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.SystemClock : object {
    [CompilerGeneratedAttribute]
private static SystemClock <Instance>k__BackingField;
    public static SystemClock Instance { get; }
    private static SystemClock();
    [CompilerGeneratedAttribute]
public static SystemClock get_Instance();
    public sealed virtual Instant GetCurrentInstant();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.AnnualDatePattern : object {
    internal static AnnualDate DefaultTemplateValue;
    private static string DefaultFormatPattern;
    internal static PatternBclSupport`1<AnnualDate> BclSupport;
    [CompilerGeneratedAttribute]
private IPartialPattern`1<AnnualDate> <UnderlyingPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private AnnualDate <TemplateValue>k__BackingField;
    public static AnnualDatePattern Iso { get; }
    internal IPartialPattern`1<AnnualDate> UnderlyingPattern { get; }
    public string PatternText { get; }
    private NodaFormatInfo FormatInfo { get; }
    public AnnualDate TemplateValue { get; }
    private AnnualDatePattern(string patternText, NodaFormatInfo formatInfo, AnnualDate templateValue, IPartialPattern`1<AnnualDate> pattern);
    private static AnnualDatePattern();
    public static AnnualDatePattern get_Iso();
    [CompilerGeneratedAttribute]
internal IPartialPattern`1<AnnualDate> get_UnderlyingPattern();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
private NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public AnnualDate get_TemplateValue();
    public sealed virtual ParseResult`1<AnnualDate> Parse(string text);
    public sealed virtual string Format(AnnualDate value);
    public sealed virtual StringBuilder AppendFormat(AnnualDate value, StringBuilder builder);
    internal static AnnualDatePattern Create(string patternText, NodaFormatInfo formatInfo, AnnualDate templateValue);
    public static AnnualDatePattern Create(string patternText, CultureInfo cultureInfo, AnnualDate templateValue);
    public static AnnualDatePattern Create(string patternText, CultureInfo cultureInfo);
    public static AnnualDatePattern CreateWithCurrentCulture(string patternText);
    public static AnnualDatePattern CreateWithInvariantCulture(string patternText);
    private AnnualDatePattern WithFormatInfo(NodaFormatInfo formatInfo);
    public AnnualDatePattern WithCulture(CultureInfo cultureInfo);
    public AnnualDatePattern WithTemplateValue(AnnualDate newTemplateValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.AnnualDatePatternParser : object {
    private AnnualDate templateValue;
    private static Dictionary`2<char, CharacterHandler`2<AnnualDate, AnnualDateParseBucket>> PatternCharacterHandlers;
    internal AnnualDatePatternParser(AnnualDate templateValue);
    private static AnnualDatePatternParser();
    public sealed virtual IPattern`1<AnnualDate> ParsePattern(string patternText, NodaFormatInfo formatInfo);
    private static void HandleDayOfMonth(PatternCursor pattern, SteppedPatternBuilder`2<AnnualDate, AnnualDateParseBucket> builder);
    [CompilerGeneratedAttribute]
private AnnualDateParseBucket <ParsePattern>b__3_0();
}
internal class NodaTime.Text.AnnualDateTypeConverter : TypeConverterBase`1<AnnualDate> {
}
internal class NodaTime.Text.CharacterHandler`2 : MulticastDelegate {
    public CharacterHandler`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(PatternCursor patternCursor, SteppedPatternBuilder`2<TResult, TBucket> patternBuilder);
    public virtual IAsyncResult BeginInvoke(PatternCursor patternCursor, SteppedPatternBuilder`2<TResult, TBucket> patternBuilder, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MutableAttribute]
public class NodaTime.Text.CompositePatternBuilder`1 : object {
    private List`1<IPattern`1<T>> patterns;
    private List`1<Func`2<T, bool>> formatPredicates;
    public void Add(IPattern`1<T> pattern, Func`2<T, bool> formatPredicate);
    public IPattern`1<T> Build();
    internal IPartialPattern`1<T> BuildAsPartial();
    private sealed virtual override IEnumerator`1<IPattern`1<T>> System.Collections.Generic.IEnumerable<NodaTime.Text.IPattern<T>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.DurationPattern : object {
    internal static PatternBclSupport`1<Duration> BclSupport;
    private IPattern`1<Duration> pattern;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    public static DurationPattern Roundtrip { get; }
    public static DurationPattern JsonRoundtrip { get; }
    public string PatternText { get; }
    private DurationPattern(string patternText, IPattern`1<Duration> pattern);
    private static DurationPattern();
    public static DurationPattern get_Roundtrip();
    public static DurationPattern get_JsonRoundtrip();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    public sealed virtual ParseResult`1<Duration> Parse(string text);
    public sealed virtual string Format(Duration value);
    public sealed virtual StringBuilder AppendFormat(Duration value, StringBuilder builder);
    private static DurationPattern Create(string patternText, NodaFormatInfo formatInfo);
    public static DurationPattern Create(string patternText, CultureInfo cultureInfo);
    public static DurationPattern CreateWithCurrentCulture(string patternText);
    public static DurationPattern CreateWithInvariantCulture(string patternText);
    public DurationPattern WithCulture(CultureInfo cultureInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.DurationPatternParser : object {
    private static Dictionary`2<char, CharacterHandler`2<Duration, DurationParseBucket>> PatternCharacterHandlers;
    private static DurationPatternParser();
    public sealed virtual IPattern`1<Duration> ParsePattern(string patternText, NodaFormatInfo formatInfo);
    private static int GetPositiveNanosecondOfSecond(Duration duration);
    private static CharacterHandler`2<Duration, DurationParseBucket> CreateTotalHandler(PatternFields field, long nanosecondsPerUnit, int unitsPerDay, long maxValue);
    private static CharacterHandler`2<Duration, DurationParseBucket> CreateDayHandler();
    private static CharacterHandler`2<Duration, DurationParseBucket> CreatePartialHandler(PatternFields field, long nanosecondsPerUnit, int unitsPerContainer);
    private static void HandlePlus(PatternCursor pattern, SteppedPatternBuilder`2<Duration, DurationParseBucket> builder);
    private static void HandleMinus(PatternCursor pattern, SteppedPatternBuilder`2<Duration, DurationParseBucket> builder);
    private static long GetPositiveNanosecondUnits(Duration duration, long nanosecondsPerUnit, int unitsPerDay);
}
internal class NodaTime.Text.DurationTypeConverter : TypeConverterBase`1<Duration> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.FixedFormatInfoPatternParser`1 : object {
    private static int CacheSize;
    private Cache`2<string, IPattern`1<T>> cache;
    internal FixedFormatInfoPatternParser`1(IPatternParser`1<T> patternParser, NodaFormatInfo formatInfo);
    internal IPattern`1<T> ParsePattern(string pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.Text.FormatHelper : object {
    private static int MaximumPaddingLength;
    private static int MaximumInt64Length;
    internal static void Format2DigitsNonNegative(int value, StringBuilder outputBuffer);
    internal static void Format4DigitsValueFits(int value, StringBuilder outputBuffer);
    internal static void LeftPad(int value, int length, StringBuilder outputBuffer);
    internal static void LeftPadNonNegative(int value, int length, StringBuilder outputBuffer);
    internal static void LeftPadNonNegativeInt64(long value, int length, StringBuilder outputBuffer);
    internal static void AppendFraction(int value, int length, int scale, StringBuilder outputBuffer);
    internal static void AppendFractionTruncate(int value, int length, int scale, StringBuilder outputBuffer);
    internal static void FormatInvariant(long value, StringBuilder outputBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.InstantPattern : object {
    internal static Instant DefaultTemplateValue;
    private static string DefaultFormatPattern;
    internal static PatternBclSupport`1<Instant> BclSupport;
    private IPattern`1<Instant> pattern;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private Instant <TemplateValue>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    public static InstantPattern General { get; }
    public static InstantPattern ExtendedIso { get; }
    public string PatternText { get; }
    public Instant TemplateValue { get; }
    private NodaFormatInfo FormatInfo { get; }
    private InstantPattern(string patternText, NodaFormatInfo formatInfo, Instant templateValue, IPattern`1<Instant> pattern);
    private static InstantPattern();
    public static InstantPattern get_General();
    public static InstantPattern get_ExtendedIso();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
public Instant get_TemplateValue();
    [CompilerGeneratedAttribute]
private NodaFormatInfo get_FormatInfo();
    public sealed virtual ParseResult`1<Instant> Parse(string text);
    public sealed virtual string Format(Instant value);
    public sealed virtual StringBuilder AppendFormat(Instant value, StringBuilder builder);
    private static InstantPattern Create(string patternText, NodaFormatInfo formatInfo, Instant templateValue);
    public static InstantPattern Create(string patternText, CultureInfo cultureInfo);
    public static InstantPattern CreateWithCurrentCulture(string patternText);
    public static InstantPattern CreateWithInvariantCulture(string patternText);
    private InstantPattern WithFormatInfo(NodaFormatInfo formatInfo);
    public InstantPattern WithCulture(CultureInfo cultureInfo);
    public InstantPattern WithTemplateValue(Instant newTemplateValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.InstantPatternParser : object {
    private static string GeneralPatternText;
    internal static string BeforeMinValueText;
    internal static string AfterMaxValueText;
    private LocalDateTime localTemplateValue;
    internal InstantPatternParser(Instant templateValue);
    public sealed virtual IPattern`1<Instant> ParsePattern(string patternText, NodaFormatInfo formatInfo);
}
internal class NodaTime.Text.InstantTypeConverter : TypeConverterBase`1<Instant> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MutableAttribute]
public class NodaTime.Text.InvalidPatternException : FormatException {
    public InvalidPatternException(string message);
    internal InvalidPatternException(string formatString, Object[] parameters);
}
[NullableContextAttribute("1")]
internal interface NodaTime.Text.IPartialPattern`1 {
    public abstract virtual ParseResult`1<T> ParsePartial(ValueCursor cursor);
}
[NullableContextAttribute("1")]
public interface NodaTime.Text.IPattern`1 {
    public abstract virtual ParseResult`1<T> Parse(string text);
    public abstract virtual string Format(T value);
    public abstract virtual StringBuilder AppendFormat(T value, StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.LocalDatePattern : object {
    internal static LocalDate DefaultTemplateValue;
    private static string DefaultFormatPattern;
    internal static PatternBclSupport`1<LocalDate> BclSupport;
    [CompilerGeneratedAttribute]
private IPartialPattern`1<LocalDate> <UnderlyingPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalDate <TemplateValue>k__BackingField;
    public static LocalDatePattern Iso { get; }
    public static LocalDatePattern FullRoundtrip { get; }
    internal IPartialPattern`1<LocalDate> UnderlyingPattern { get; }
    public string PatternText { get; }
    private NodaFormatInfo FormatInfo { get; }
    public LocalDate TemplateValue { get; }
    private LocalDatePattern(string patternText, NodaFormatInfo formatInfo, LocalDate templateValue, IPartialPattern`1<LocalDate> pattern);
    private static LocalDatePattern();
    public static LocalDatePattern get_Iso();
    public static LocalDatePattern get_FullRoundtrip();
    [CompilerGeneratedAttribute]
internal IPartialPattern`1<LocalDate> get_UnderlyingPattern();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
private NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public LocalDate get_TemplateValue();
    public sealed virtual ParseResult`1<LocalDate> Parse(string text);
    public sealed virtual string Format(LocalDate value);
    public sealed virtual StringBuilder AppendFormat(LocalDate value, StringBuilder builder);
    internal static LocalDatePattern Create(string patternText, NodaFormatInfo formatInfo, LocalDate templateValue);
    public static LocalDatePattern Create(string patternText, CultureInfo cultureInfo, LocalDate templateValue);
    public static LocalDatePattern Create(string patternText, CultureInfo cultureInfo);
    public static LocalDatePattern CreateWithCurrentCulture(string patternText);
    public static LocalDatePattern CreateWithInvariantCulture(string patternText);
    private LocalDatePattern WithFormatInfo(NodaFormatInfo formatInfo);
    public LocalDatePattern WithCulture(CultureInfo cultureInfo);
    public LocalDatePattern WithTemplateValue(LocalDate newTemplateValue);
    public LocalDatePattern WithCalendar(CalendarSystem calendar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.LocalDatePatternParser : object {
    private LocalDate templateValue;
    private static int TwoDigitYearMax;
    private static Dictionary`2<char, CharacterHandler`2<LocalDate, LocalDateParseBucket>> PatternCharacterHandlers;
    internal LocalDatePatternParser(LocalDate templateValue);
    private static LocalDatePatternParser();
    public sealed virtual IPattern`1<LocalDate> ParsePattern(string patternText, NodaFormatInfo formatInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.LocalDateTimePattern : object {
    internal static LocalDateTime DefaultTemplateValue;
    private static string DefaultFormatPattern;
    internal static PatternBclSupport`1<LocalDateTime> BclSupport;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalDateTime <TemplateValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IPartialPattern`1<LocalDateTime> <UnderlyingPattern>k__BackingField;
    public static LocalDateTimePattern GeneralIso { get; }
    public static LocalDateTimePattern ExtendedIso { get; }
    public static LocalDateTimePattern BclRoundtrip { get; }
    public static LocalDateTimePattern FullRoundtripWithoutCalendar { get; }
    public static LocalDateTimePattern FullRoundtrip { get; }
    public string PatternText { get; }
    private NodaFormatInfo FormatInfo { get; }
    public LocalDateTime TemplateValue { get; }
    internal IPartialPattern`1<LocalDateTime> UnderlyingPattern { get; }
    private LocalDateTimePattern(string patternText, NodaFormatInfo formatInfo, LocalDateTime templateValue, IPartialPattern`1<LocalDateTime> pattern);
    private static LocalDateTimePattern();
    public static LocalDateTimePattern get_GeneralIso();
    public static LocalDateTimePattern get_ExtendedIso();
    public static LocalDateTimePattern get_BclRoundtrip();
    public static LocalDateTimePattern get_FullRoundtripWithoutCalendar();
    public static LocalDateTimePattern get_FullRoundtrip();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
private NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public LocalDateTime get_TemplateValue();
    [CompilerGeneratedAttribute]
internal IPartialPattern`1<LocalDateTime> get_UnderlyingPattern();
    public sealed virtual ParseResult`1<LocalDateTime> Parse(string text);
    public sealed virtual string Format(LocalDateTime value);
    public sealed virtual StringBuilder AppendFormat(LocalDateTime value, StringBuilder builder);
    internal static LocalDateTimePattern Create(string patternText, NodaFormatInfo formatInfo, LocalDateTime templateValue);
    public static LocalDateTimePattern Create(string patternText, CultureInfo cultureInfo, LocalDateTime templateValue);
    public static LocalDateTimePattern Create(string patternText, CultureInfo cultureInfo);
    public static LocalDateTimePattern CreateWithCurrentCulture(string patternText);
    public static LocalDateTimePattern CreateWithInvariantCulture(string patternText);
    private LocalDateTimePattern WithFormatInfo(NodaFormatInfo formatInfo);
    public LocalDateTimePattern WithCulture(CultureInfo cultureInfo);
    public LocalDateTimePattern WithTemplateValue(LocalDateTime newTemplateValue);
    public LocalDateTimePattern WithCalendar(CalendarSystem calendar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.LocalDateTimePatternParser : object {
    private LocalDate templateValueDate;
    private LocalTime templateValueTime;
    private static Dictionary`2<char, CharacterHandler`2<LocalDateTime, LocalDateTimeParseBucket>> PatternCharacterHandlers;
    internal LocalDateTimePatternParser(LocalDateTime templateValue);
    private static LocalDateTimePatternParser();
    public sealed virtual IPattern`1<LocalDateTime> ParsePattern(string patternText, NodaFormatInfo formatInfo);
}
internal class NodaTime.Text.LocalDateTimeTypeConverter : TypeConverterBase`1<LocalDateTime> {
}
internal class NodaTime.Text.LocalDateTypeConverter : TypeConverterBase`1<LocalDate> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.LocalTimePattern : object {
    private static string DefaultFormatPattern;
    internal static PatternBclSupport`1<LocalTime> BclSupport;
    [CompilerGeneratedAttribute]
private IPartialPattern`1<LocalTime> <UnderlyingPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalTime <TemplateValue>k__BackingField;
    public static LocalTimePattern ExtendedIso { get; }
    public static LocalTimePattern LongExtendedIso { get; }
    public static LocalTimePattern GeneralIso { get; }
    internal IPartialPattern`1<LocalTime> UnderlyingPattern { get; }
    public string PatternText { get; }
    private NodaFormatInfo FormatInfo { get; }
    public LocalTime TemplateValue { get; }
    private LocalTimePattern(string patternText, NodaFormatInfo formatInfo, LocalTime templateValue, IPartialPattern`1<LocalTime> pattern);
    private static LocalTimePattern();
    public static LocalTimePattern get_ExtendedIso();
    public static LocalTimePattern get_LongExtendedIso();
    public static LocalTimePattern get_GeneralIso();
    [CompilerGeneratedAttribute]
internal IPartialPattern`1<LocalTime> get_UnderlyingPattern();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
private NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public LocalTime get_TemplateValue();
    public sealed virtual ParseResult`1<LocalTime> Parse(string text);
    public sealed virtual string Format(LocalTime value);
    public sealed virtual StringBuilder AppendFormat(LocalTime value, StringBuilder builder);
    internal static LocalTimePattern Create(string patternText, NodaFormatInfo formatInfo, LocalTime templateValue);
    public static LocalTimePattern Create(string patternText, CultureInfo cultureInfo, LocalTime templateValue);
    public static LocalTimePattern Create(string patternText, CultureInfo cultureInfo);
    public static LocalTimePattern CreateWithCurrentCulture(string patternText);
    public static LocalTimePattern CreateWithInvariantCulture(string patternText);
    private LocalTimePattern WithFormatInfo(NodaFormatInfo formatInfo);
    public LocalTimePattern WithCulture(CultureInfo cultureInfo);
    public LocalTimePattern WithTemplateValue(LocalTime newTemplateValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.LocalTimePatternParser : object {
    private LocalTime templateValue;
    private static Dictionary`2<char, CharacterHandler`2<LocalTime, LocalTimeParseBucket>> PatternCharacterHandlers;
    public LocalTimePatternParser(LocalTime templateValue);
    private static LocalTimePatternParser();
    public sealed virtual IPattern`1<LocalTime> ParsePattern(string patternText, NodaFormatInfo formatInfo);
}
internal class NodaTime.Text.LocalTimeTypeConverter : TypeConverterBase`1<LocalTime> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.OffsetDatePattern : object {
    internal static OffsetDate DefaultTemplateValue;
    private IPattern`1<OffsetDate> pattern;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private OffsetDate <TemplateValue>k__BackingField;
    public static OffsetDatePattern GeneralIso { get; }
    public static OffsetDatePattern FullRoundtrip { get; }
    public string PatternText { get; }
    internal NodaFormatInfo FormatInfo { get; }
    public OffsetDate TemplateValue { get; }
    private OffsetDatePattern(string patternText, NodaFormatInfo formatInfo, OffsetDate templateValue, IPattern`1<OffsetDate> pattern);
    private static OffsetDatePattern();
    public static OffsetDatePattern get_GeneralIso();
    public static OffsetDatePattern get_FullRoundtrip();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
internal NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public OffsetDate get_TemplateValue();
    public sealed virtual ParseResult`1<OffsetDate> Parse(string text);
    public sealed virtual string Format(OffsetDate value);
    public sealed virtual StringBuilder AppendFormat(OffsetDate value, StringBuilder builder);
    private static OffsetDatePattern Create(string patternText, NodaFormatInfo formatInfo, OffsetDate templateValue);
    public static OffsetDatePattern Create(string patternText, CultureInfo cultureInfo, OffsetDate templateValue);
    public static OffsetDatePattern CreateWithInvariantCulture(string patternText);
    public static OffsetDatePattern CreateWithCurrentCulture(string patternText);
    public OffsetDatePattern WithPatternText(string patternText);
    private OffsetDatePattern WithFormatInfo(NodaFormatInfo formatInfo);
    public OffsetDatePattern WithCulture(CultureInfo cultureInfo);
    public OffsetDatePattern WithTemplateValue(OffsetDate newTemplateValue);
    public OffsetDatePattern WithCalendar(CalendarSystem calendar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.OffsetDatePatternParser : object {
    private OffsetDate templateValue;
    private static Dictionary`2<char, CharacterHandler`2<OffsetDate, OffsetDateParseBucket>> PatternCharacterHandlers;
    internal OffsetDatePatternParser(OffsetDate templateValue);
    private static OffsetDatePatternParser();
    public sealed virtual IPattern`1<OffsetDate> ParsePattern(string patternText, NodaFormatInfo formatInfo);
    private static void HandleOffset(PatternCursor pattern, SteppedPatternBuilder`2<OffsetDate, OffsetDateParseBucket> builder);
    [CompilerGeneratedAttribute]
private OffsetDateParseBucket <ParsePattern>b__3_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.OffsetDateTimePattern : object {
    internal static OffsetDateTime DefaultTemplateValue;
    private IPattern`1<OffsetDateTime> pattern;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private OffsetDateTime <TemplateValue>k__BackingField;
    public static OffsetDateTimePattern GeneralIso { get; }
    public static OffsetDateTimePattern ExtendedIso { get; }
    public static OffsetDateTimePattern Rfc3339 { get; }
    public static OffsetDateTimePattern FullRoundtrip { get; }
    public string PatternText { get; }
    internal NodaFormatInfo FormatInfo { get; }
    public OffsetDateTime TemplateValue { get; }
    private OffsetDateTimePattern(string patternText, NodaFormatInfo formatInfo, OffsetDateTime templateValue, IPattern`1<OffsetDateTime> pattern);
    private static OffsetDateTimePattern();
    public static OffsetDateTimePattern get_GeneralIso();
    public static OffsetDateTimePattern get_ExtendedIso();
    public static OffsetDateTimePattern get_Rfc3339();
    public static OffsetDateTimePattern get_FullRoundtrip();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
internal NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public OffsetDateTime get_TemplateValue();
    public sealed virtual ParseResult`1<OffsetDateTime> Parse(string text);
    public sealed virtual string Format(OffsetDateTime value);
    public sealed virtual StringBuilder AppendFormat(OffsetDateTime value, StringBuilder builder);
    private static OffsetDateTimePattern Create(string patternText, NodaFormatInfo formatInfo, OffsetDateTime templateValue);
    public static OffsetDateTimePattern Create(string patternText, CultureInfo cultureInfo, OffsetDateTime templateValue);
    public static OffsetDateTimePattern CreateWithInvariantCulture(string patternText);
    public static OffsetDateTimePattern CreateWithCurrentCulture(string patternText);
    public OffsetDateTimePattern WithPatternText(string patternText);
    private OffsetDateTimePattern WithFormatInfo(NodaFormatInfo formatInfo);
    public OffsetDateTimePattern WithCulture(CultureInfo cultureInfo);
    public OffsetDateTimePattern WithTemplateValue(OffsetDateTime newTemplateValue);
    public OffsetDateTimePattern WithCalendar(CalendarSystem calendar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.OffsetDateTimePatternParser : object {
    private OffsetDateTime templateValue;
    private static Dictionary`2<char, CharacterHandler`2<OffsetDateTime, OffsetDateTimeParseBucket>> PatternCharacterHandlers;
    internal OffsetDateTimePatternParser(OffsetDateTime templateValue);
    private static OffsetDateTimePatternParser();
    public sealed virtual IPattern`1<OffsetDateTime> ParsePattern(string patternText, NodaFormatInfo formatInfo);
    private static void HandleOffset(PatternCursor pattern, SteppedPatternBuilder`2<OffsetDateTime, OffsetDateTimeParseBucket> builder);
    [CompilerGeneratedAttribute]
private OffsetDateTimeParseBucket <ParsePattern>b__3_0();
}
internal class NodaTime.Text.OffsetDateTimeTypeConverter : TypeConverterBase`1<OffsetDateTime> {
}
internal class NodaTime.Text.OffsetDateTypeConverter : TypeConverterBase`1<OffsetDate> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.OffsetPattern : object {
    [CompilerGeneratedAttribute]
private static OffsetPattern <GeneralInvariant>k__BackingField;
    [CompilerGeneratedAttribute]
private static OffsetPattern <GeneralInvariantWithZ>k__BackingField;
    private static string DefaultFormatPattern;
    internal static PatternBclSupport`1<Offset> BclSupport;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private IPartialPattern`1<Offset> <UnderlyingPattern>k__BackingField;
    public static OffsetPattern GeneralInvariant { get; }
    public static OffsetPattern GeneralInvariantWithZ { get; }
    public string PatternText { get; }
    internal IPartialPattern`1<Offset> UnderlyingPattern { get; }
    private OffsetPattern(string patternText, IPartialPattern`1<Offset> pattern);
    private static OffsetPattern();
    [CompilerGeneratedAttribute]
public static OffsetPattern get_GeneralInvariant();
    [CompilerGeneratedAttribute]
public static OffsetPattern get_GeneralInvariantWithZ();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
internal IPartialPattern`1<Offset> get_UnderlyingPattern();
    public sealed virtual ParseResult`1<Offset> Parse(string text);
    public sealed virtual string Format(Offset value);
    public sealed virtual StringBuilder AppendFormat(Offset value, StringBuilder builder);
    internal static OffsetPattern Create(string patternText, NodaFormatInfo formatInfo);
    public static OffsetPattern Create(string patternText, CultureInfo cultureInfo);
    public static OffsetPattern CreateWithCurrentCulture(string patternText);
    public static OffsetPattern CreateWithInvariantCulture(string patternText);
    public OffsetPattern WithCulture(CultureInfo cultureInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.OffsetPatternParser : object {
    private static Dictionary`2<char, CharacterHandler`2<Offset, OffsetParseBucket>> PatternCharacterHandlers;
    private static OffsetPatternParser();
    private static int GetPositiveHours(Offset offset);
    private static int GetPositiveMinutes(Offset offset);
    private static int GetPositiveSeconds(Offset offset);
    public sealed virtual IPattern`1<Offset> ParsePattern(string patternText, NodaFormatInfo formatInfo);
    private IPartialPattern`1<Offset> ParsePartialPattern(string patternText, NodaFormatInfo formatInfo);
    private static bool HasZeroSeconds(Offset offset);
    private static bool HasZeroSecondsAndMinutes(Offset offset);
    private static void HandlePlus(PatternCursor pattern, SteppedPatternBuilder`2<Offset, OffsetParseBucket> builder);
    private static void HandleMinus(PatternCursor pattern, SteppedPatternBuilder`2<Offset, OffsetParseBucket> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.OffsetTimePattern : object {
    internal static OffsetTime DefaultTemplateValue;
    private IPattern`1<OffsetTime> pattern;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private OffsetTime <TemplateValue>k__BackingField;
    public static OffsetTimePattern GeneralIso { get; }
    public static OffsetTimePattern ExtendedIso { get; }
    public static OffsetTimePattern Rfc3339 { get; }
    public string PatternText { get; }
    internal NodaFormatInfo FormatInfo { get; }
    public OffsetTime TemplateValue { get; }
    private OffsetTimePattern(string patternText, NodaFormatInfo formatInfo, OffsetTime templateValue, IPattern`1<OffsetTime> pattern);
    private static OffsetTimePattern();
    public static OffsetTimePattern get_GeneralIso();
    public static OffsetTimePattern get_ExtendedIso();
    public static OffsetTimePattern get_Rfc3339();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
internal NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public OffsetTime get_TemplateValue();
    public sealed virtual ParseResult`1<OffsetTime> Parse(string text);
    public sealed virtual string Format(OffsetTime value);
    public sealed virtual StringBuilder AppendFormat(OffsetTime value, StringBuilder builder);
    private static OffsetTimePattern Create(string patternText, NodaFormatInfo formatInfo, OffsetTime templateValue);
    public static OffsetTimePattern Create(string patternText, CultureInfo cultureInfo, OffsetTime templateValue);
    public static OffsetTimePattern CreateWithInvariantCulture(string patternText);
    public static OffsetTimePattern CreateWithCurrentCulture(string patternText);
    public OffsetTimePattern WithPatternText(string patternText);
    private OffsetTimePattern WithFormatInfo(NodaFormatInfo formatInfo);
    public OffsetTimePattern WithCulture(CultureInfo cultureInfo);
    public OffsetTimePattern WithTemplateValue(OffsetTime newTemplateValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.OffsetTimePatternParser : object {
    private OffsetTime templateValue;
    private static Dictionary`2<char, CharacterHandler`2<OffsetTime, OffsetTimeParseBucket>> PatternCharacterHandlers;
    internal OffsetTimePatternParser(OffsetTime templateValue);
    private static OffsetTimePatternParser();
    public sealed virtual IPattern`1<OffsetTime> ParsePattern(string patternText, NodaFormatInfo formatInfo);
    private static void HandleOffset(PatternCursor pattern, SteppedPatternBuilder`2<OffsetTime, OffsetTimeParseBucket> builder);
    [CompilerGeneratedAttribute]
private OffsetTimeParseBucket <ParsePattern>b__3_0();
}
internal class NodaTime.Text.OffsetTimeTypeConverter : TypeConverterBase`1<OffsetTime> {
}
internal class NodaTime.Text.OffsetTypeConverter : TypeConverterBase`1<Offset> {
}
internal abstract class NodaTime.Text.ParseBucket`1 : object {
    [NullableContextAttribute("1")]
internal abstract virtual ParseResult`1<T> CalculateValue(PatternFields usedFields, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.ParseResult`1 : object {
    private T value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<Exception> exceptionProvider;
    [CompilerGeneratedAttribute]
private bool <ContinueAfterErrorWithMultipleFormats>k__BackingField;
    internal static ParseResult`1<T> ValueStringEmpty;
    internal static ParseResult`1<T> FormatOnlyPattern;
    internal bool ContinueAfterErrorWithMultipleFormats { get; }
    public T Value { get; }
    public Exception Exception { get; }
    public bool Success { get; }
    private ParseResult`1(Func`1<Exception> exceptionProvider, bool continueWithMultiple);
    private ParseResult`1(T value);
    private static ParseResult`1();
    [CompilerGeneratedAttribute]
internal bool get_ContinueAfterErrorWithMultipleFormats();
    public T get_Value();
    public Exception get_Exception();
    public T GetValueOrThrow();
    public bool TryGetValue(T failureValue, T& result);
    public bool get_Success();
    public ParseResult`1<TTarget> Convert(Func`2<T, TTarget> projection);
    public ParseResult`1<TTarget> ConvertError();
    public static ParseResult`1<T> ForValue(T value);
    public static ParseResult`1<T> ForException(Func`1<Exception> exceptionProvider);
    internal static ParseResult`1<T> ForInvalidValue(ValueCursor cursor, string formatString, Object[] parameters);
    internal static ParseResult`1<T> ForInvalidValuePostParse(string text, string formatString, Object[] parameters);
    private static ParseResult`1<T> ForInvalidValue(Func`1<Exception> exceptionProvider);
    internal static ParseResult`1<T> ArgumentNull(string parameter);
    internal static ParseResult`1<T> PositiveSignInvalid(ValueCursor cursor);
    internal static ParseResult`1<T> ExtraValueCharacters(ValueCursor cursor, string remainder);
    internal static ParseResult`1<T> QuotedStringMismatch(ValueCursor cursor);
    internal static ParseResult`1<T> EscapedCharacterMismatch(ValueCursor cursor, char patternCharacter);
    internal static ParseResult`1<T> EndOfString(ValueCursor cursor);
    internal static ParseResult`1<T> TimeSeparatorMismatch(ValueCursor cursor);
    internal static ParseResult`1<T> DateSeparatorMismatch(ValueCursor cursor);
    internal static ParseResult`1<T> MissingNumber(ValueCursor cursor);
    internal static ParseResult`1<T> UnexpectedNegative(ValueCursor cursor);
    internal static ParseResult`1<T> MismatchedNumber(ValueCursor cursor, string pattern);
    internal static ParseResult`1<T> MismatchedCharacter(ValueCursor cursor, char patternCharacter);
    internal static ParseResult`1<T> MismatchedText(ValueCursor cursor, char field);
    internal static ParseResult`1<T> NoMatchingFormat(ValueCursor cursor);
    internal static ParseResult`1<T> ValueOutOfRange(ValueCursor cursor, object value);
    internal static ParseResult`1<T> MissingSign(ValueCursor cursor);
    internal static ParseResult`1<T> MissingAmPmDesignator(ValueCursor cursor);
    internal static ParseResult`1<T> NoMatchingCalendarSystem(ValueCursor cursor);
    internal static ParseResult`1<T> NoMatchingZoneId(ValueCursor cursor);
    internal static ParseResult`1<T> InvalidHour24(string text);
    internal static ParseResult`1<T> FieldValueOutOfRange(ValueCursor cursor, int value, char field);
    internal static ParseResult`1<T> FieldValueOutOfRange(ValueCursor cursor, long value, char field);
    internal static ParseResult`1<T> FieldValueOutOfRangePostParse(string text, int value, char field, Type eventualResultType);
    internal static ParseResult`1<T> InconsistentValues(string text, char field1, char field2, Type eventualResultType);
    internal static ParseResult`1<T> InconsistentMonthValues(string text);
    internal static ParseResult`1<T> InconsistentDayOfWeekTextValue(string text);
    internal static ParseResult`1<T> ExpectedEndOfString(ValueCursor cursor);
    internal static ParseResult`1<T> YearOfEraOutOfRange(string text, int value, Era era, CalendarSystem calendar);
    internal static ParseResult`1<T> MonthOutOfRange(string text, int month, int year);
    internal static ParseResult`1<T> IsoMonthOutOfRange(string text, int month);
    internal static ParseResult`1<T> DayOfMonthOutOfRange(string text, int day, int month, int year);
    internal static ParseResult`1<T> DayOfMonthOutOfRangeNoYear(string text, int day, int month);
    internal static ParseResult`1<T> InvalidOffset(string text);
    internal static ParseResult`1<T> SkippedLocalTime(string text);
    internal static ParseResult`1<T> AmbiguousLocalTime(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.Text.Patterns.DatePatternHelper : object {
    internal static CharacterHandler`2<TResult, TBucket> CreateYearOfEraHandler(Func`2<TResult, int> yearGetter, Action`2<TBucket, int> setter);
    internal static CharacterHandler`2<TResult, TBucket> CreateMonthOfYearHandler(Func`2<TResult, int> numberGetter, Action`2<TBucket, int> textSetter, Action`2<TBucket, int> numberSetter);
    internal static CharacterHandler`2<TResult, TBucket> CreateDayHandler(Func`2<TResult, int> dayOfMonthGetter, Func`2<TResult, int> dayOfWeekGetter, Action`2<TBucket, int> dayOfMonthSetter, Action`2<TBucket, int> dayOfWeekSetter);
    internal static CharacterHandler`2<TResult, TBucket> CreateEraHandler(Func`2<TResult, Era> eraFromValue, Func`2<TBucket, LocalDateParseBucket> dateBucketFromBucket);
    internal static CharacterHandler`2<TResult, TBucket> CreateCalendarHandler(Func`2<TResult, CalendarSystem> getter, Action`2<TBucket, CalendarSystem> setter);
}
[NullableContextAttribute("1")]
internal interface NodaTime.Text.Patterns.IPatternParser`1 {
    public abstract virtual IPattern`1<T> ParsePattern(string pattern, NodaFormatInfo formatInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.Patterns.PatternBclSupport`1 : object {
    private Func`2<NodaFormatInfo, FixedFormatInfoPatternParser`1<T>> patternParser;
    private string defaultFormatPattern;
    internal PatternBclSupport`1(string defaultFormatPattern, Func`2<NodaFormatInfo, FixedFormatInfoPatternParser`1<T>> patternParser);
    internal string Format(T value, string patternText, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.Patterns.PatternCursor : TextCursor {
    internal static char EmbeddedPatternStart;
    internal static char EmbeddedPatternEnd;
    internal PatternCursor(string pattern);
    internal string GetQuotedString(char closeQuote);
    internal int GetRepeatCount(int maximumCount);
    internal string GetEmbeddedPattern();
}
[FlagsAttribute]
internal enum NodaTime.Text.Patterns.PatternFields : Enum {
    public int value__;
    public static PatternFields None;
    public static PatternFields Sign;
    public static PatternFields Hours12;
    public static PatternFields Hours24;
    public static PatternFields Minutes;
    public static PatternFields Seconds;
    public static PatternFields FractionalSeconds;
    public static PatternFields AmPm;
    public static PatternFields Year;
    public static PatternFields YearTwoDigits;
    public static PatternFields YearOfEra;
    public static PatternFields MonthOfYearNumeric;
    public static PatternFields MonthOfYearText;
    public static PatternFields DayOfMonth;
    public static PatternFields DayOfWeek;
    public static PatternFields Era;
    public static PatternFields Calendar;
    public static PatternFields Zone;
    public static PatternFields ZoneAbbreviation;
    public static PatternFields EmbeddedOffset;
    public static PatternFields TotalDuration;
    public static PatternFields EmbeddedDate;
    public static PatternFields EmbeddedTime;
    public static PatternFields AllTimeFields;
    public static PatternFields AllDateFields;
}
[ExtensionAttribute]
internal static class NodaTime.Text.Patterns.PatternFieldsExtensions : object {
    [ExtensionAttribute]
internal static bool HasAny(PatternFields fields, PatternFields target);
    [ExtensionAttribute]
internal static bool HasAll(PatternFields fields, PatternFields target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.Patterns.SteppedPatternBuilder`2 : object {
    private List`1<Action`2<TResult, StringBuilder>> formatActions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ParseAction<TResult, TBucket>> parseActions;
    private Func`1<TBucket> bucketProvider;
    private PatternFields usedFields;
    private bool formatOnly;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    internal NodaFormatInfo FormatInfo { get; }
    internal PatternFields UsedFields { get; }
    internal SteppedPatternBuilder`2(NodaFormatInfo formatInfo, Func`1<TBucket> bucketProvider);
    [CompilerGeneratedAttribute]
internal NodaFormatInfo get_FormatInfo();
    internal PatternFields get_UsedFields();
    internal TBucket CreateSampleBucket();
    internal void SetFormatOnly();
    internal void ParseCustomPattern(string patternText, Dictionary`2<char, CharacterHandler`2<TResult, TBucket>> characterHandlers);
    internal void ValidateUsedFields();
    internal IPartialPattern`1<TResult> Build(TResult sample);
    internal void AddField(PatternFields field, char characterInPattern);
    internal void AddParseAction(ParseAction<TResult, TBucket> parseAction);
    internal void AddFormatAction(Action`2<TResult, StringBuilder> formatAction);
    internal void AddParseInt64ValueAction(int minimumDigits, int maximumDigits, char patternChar, long minimumValue, long maximumValue, Action`2<TBucket, long> valueSetter);
    internal void AddParseValueAction(int minimumDigits, int maximumDigits, char patternChar, int minimumValue, int maximumValue, Action`2<TBucket, int> valueSetter);
    internal void AddLiteral(string expectedText, Func`2<ValueCursor, ParseResult`1<TResult>> failure);
    internal static void HandleQuote(PatternCursor pattern, SteppedPatternBuilder`2<TResult, TBucket> builder);
    internal static void HandleBackslash(PatternCursor pattern, SteppedPatternBuilder`2<TResult, TBucket> builder);
    internal static void HandlePercent(PatternCursor pattern, SteppedPatternBuilder`2<TResult, TBucket> builder);
    internal static CharacterHandler`2<TResult, TBucket> HandlePaddedField(int maxCount, PatternFields field, int minValue, int maxValue, Func`2<TResult, int> getter, Action`2<TBucket, int> setter);
    internal void AddLiteral(char expectedChar, Func`3<ValueCursor, char, ParseResult`1<TResult>> failureSelector);
    internal void AddParseLongestTextAction(char field, Action`2<TBucket, int> setter, CompareInfo compareInfo, IReadOnlyList`1<string> textValues);
    internal void AddParseLongestTextAction(char field, Action`2<TBucket, int> setter, CompareInfo compareInfo, IReadOnlyList`1<string> textValues1, IReadOnlyList`1<string> textValues2);
    private static void FindLongestMatch(CompareInfo compareInfo, ValueCursor cursor, IReadOnlyList`1<string> values, Int32& bestIndex, Int32& longestMatch);
    public void AddRequiredSign(Action`2<TBucket, bool> signSetter, Func`2<TResult, bool> nonNegativePredicate);
    public void AddNegativeOnlySign(Action`2<TBucket, bool> signSetter, Func`2<TResult, bool> nonNegativePredicate);
    internal void AddFormatLeftPad(int count, Func`2<TResult, int> selector, bool assumeNonNegative, bool assumeFitsInCount);
    internal void AddFormatFraction(int width, int scale, Func`2<TResult, int> selector);
    internal void AddFormatFractionTruncate(int width, int scale, Func`2<TResult, int> selector);
    internal void AddEmbeddedLocalPartial(PatternCursor pattern, Func`2<TBucket, LocalDateParseBucket> dateBucketExtractor, Func`2<TBucket, LocalTimeParseBucket> timeBucketExtractor, Func`2<TResult, LocalDate> dateExtractor, Func`2<TResult, LocalTime> timeExtractor, Func`2<TResult, LocalDateTime> dateTimeExtractor);
    internal void AddEmbeddedDatePattern(char characterInPattern, string embeddedPatternText, Func`2<TBucket, LocalDateParseBucket> dateBucketExtractor, Func`2<TResult, LocalDate> dateExtractor);
    internal void AddEmbeddedTimePattern(char characterInPattern, string embeddedPatternText, Func`2<TBucket, LocalTimeParseBucket> timeBucketExtractor, Func`2<TResult, LocalTime> timeExtractor);
    internal void AddEmbeddedPattern(IPartialPattern`1<TEmbedded> embeddedPattern, Action`2<TBucket, TEmbedded> parseAction, Func`2<TResult, TEmbedded> valueExtractor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.Text.Patterns.TimePatternHelper : object {
    internal static CharacterHandler`2<TResult, TBucket> CreatePeriodHandler(int maxCount, Func`2<TResult, int> getter, Action`2<TBucket, int> setter);
    internal static CharacterHandler`2<TResult, TBucket> CreateCommaDotHandler(int maxCount, Func`2<TResult, int> getter, Action`2<TBucket, int> setter);
    internal static CharacterHandler`2<TResult, TBucket> CreateFractionHandler(int maxCount, Func`2<TResult, int> getter, Action`2<TBucket, int> setter);
    internal static CharacterHandler`2<TResult, TBucket> CreateAmPmHandler(Func`2<TResult, int> hourOfDayGetter, Action`2<TBucket, int> amPmSetter);
    private static void HandleHalfAmPmDesignator(int count, string specifiedDesignator, int specifiedDesignatorValue, Func`2<TResult, int> hourOfDayGetter, Action`2<TBucket, int> amPmSetter, SteppedPatternBuilder`2<TResult, TBucket> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.PeriodPattern : object {
    [CompilerGeneratedAttribute]
private static PeriodPattern <Roundtrip>k__BackingField;
    [CompilerGeneratedAttribute]
private static PeriodPattern <NormalizingIso>k__BackingField;
    private IPattern`1<Period> pattern;
    public static PeriodPattern Roundtrip { get; }
    public static PeriodPattern NormalizingIso { get; }
    private PeriodPattern(IPattern`1<Period> pattern);
    private static PeriodPattern();
    [CompilerGeneratedAttribute]
public static PeriodPattern get_Roundtrip();
    [CompilerGeneratedAttribute]
public static PeriodPattern get_NormalizingIso();
    public sealed virtual ParseResult`1<Period> Parse(string text);
    public sealed virtual string Format(Period value);
    public sealed virtual StringBuilder AppendFormat(Period value, StringBuilder builder);
    private static void AppendValue(StringBuilder builder, long value, char suffix);
    private static ParseResult`1<Period> InvalidUnit(ValueCursor cursor, char unitCharacter);
    private static ParseResult`1<Period> RepeatedUnit(ValueCursor cursor, char unitCharacter);
    private static ParseResult`1<Period> MisplacedUnit(ValueCursor cursor, char unitCharacter);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NodaTime.Text.PeriodTypeConverter : TypeConverterBase`1<Period> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
internal abstract class NodaTime.Text.TextCursor : object {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    internal static char Nul;
    [CompilerGeneratedAttribute]
private char <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    internal int Length { get; }
    internal string Value { get; }
    internal char Current { get; private set; }
    internal bool HasMoreCharacters { get; }
    internal int Index { get; private set; }
    internal string Remainder { get; }
    protected TextCursor(string value);
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
internal string get_Value();
    [CompilerGeneratedAttribute]
internal char get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(char value);
    internal bool get_HasMoreCharacters();
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    internal string get_Remainder();
    public virtual string ToString();
    internal char PeekNext();
    internal bool Move(int targetIndex);
    internal bool MoveNext();
    internal bool MovePrevious();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.Text.TextErrorMessages : object {
    internal static string AmbiguousLocalTime;
    internal static string CalendarAndEra;
    internal static string DateFieldAndEmbeddedDate;
    internal static string DateSeparatorMismatch;
    internal static string DayOfMonthOutOfRange;
    internal static string DayOfMonthOutOfRangeNoYear;
    internal static string EmptyPeriod;
    internal static string EmptyZPrefixedOffsetPattern;
    internal static string EndOfString;
    internal static string EraWithoutYearOfEra;
    internal static string EscapeAtEndOfString;
    internal static string EscapedCharacterMismatch;
    internal static string ExpectedEndOfString;
    internal static string ExtraValueCharacters;
    internal static string FieldValueOutOfRange;
    internal static string FormatOnlyPattern;
    internal static string FormatStringEmpty;
    internal static string Hour12PatternNotSupported;
    internal static string InconsistentDayOfWeekTextValue;
    internal static string InconsistentMonthTextValue;
    internal static string InconsistentValues2;
    internal static string InvalidEmbeddedPatternType;
    internal static string InvalidHour24;
    internal static string InvalidOffset;
    internal static string InvalidRepeatCount;
    internal static string InvalidUnitSpecifier;
    internal static string IsoMonthOutOfRange;
    internal static string MismatchedCharacter;
    internal static string MismatchedNumber;
    internal static string MismatchedText;
    internal static string MisplacedUnitSpecifier;
    internal static string MissingAmPmDesignator;
    internal static string MissingEmbeddedPatternEnd;
    internal static string MissingEmbeddedPatternStart;
    internal static string MissingEndQuote;
    internal static string MissingNumber;
    internal static string MissingSign;
    internal static string MonthOutOfRange;
    internal static string MultipleCapitalDurationFields;
    internal static string NoMatchingCalendarSystem;
    internal static string NoMatchingFormat;
    internal static string NoMatchingZoneId;
    internal static string OverallValueOutOfRange;
    internal static string PercentAtEndOfString;
    internal static string PercentDoubled;
    internal static string PositiveSignInvalid;
    internal static string QuotedStringMismatch;
    internal static string RepeatCountExceeded;
    internal static string RepeatedFieldInPattern;
    internal static string RepeatedUnitSpecifier;
    internal static string SkippedLocalTime;
    internal static string TimeFieldAndEmbeddedTime;
    internal static string TimeSeparatorMismatch;
    internal static string UnexpectedNegative;
    internal static string UnknownStandardFormat;
    internal static string UnparsableValue;
    internal static string UnparsableValuePostParse;
    internal static string UnquotedLiteral;
    internal static string ValueOutOfRange;
    internal static string ValueStringEmpty;
    internal static string YearOfEraOutOfRange;
    internal static string ZPrefixNotAtStartOfPattern;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NodaTime.Text.TypeConverterBase`1 : TypeConverter {
    private IPattern`1<T> pattern;
    protected TypeConverterBase`1(IPattern`1<T> pattern);
    [PureAttribute]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NodaTime.Text.TypeConverterSettings : object {
    private static object stateLock;
    private static IDateTimeZoneProvider dateTimeZoneProvider;
    public static IDateTimeZoneProvider DateTimeZoneProvider { get; public set; }
    private static TypeConverterSettings();
    public static IDateTimeZoneProvider get_DateTimeZoneProvider();
    public static void set_DateTimeZoneProvider(IDateTimeZoneProvider value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MutableAttribute]
public class NodaTime.Text.UnparsableValueException : FormatException {
    public UnparsableValueException(string message);
    public UnparsableValueException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.ValueCursor : TextCursor {
    internal ValueCursor(string value);
    internal bool Match(char character);
    internal bool Match(string match);
    internal bool MatchCaseInsensitive(string match, CompareInfo compareInfo, bool moveOnSuccess);
    internal int CompareOrdinal(string match);
    [NullableContextAttribute("2")]
internal ParseResult`1<T> ParseInt64(Int64& result);
    private ParseResult`1<T> BuildNumberOutOfRangeResult(int startIndex);
    internal bool ParseInt64Digits(int minimumDigits, int maximumDigits, Int64& result);
    internal bool ParseDigits(int minimumDigits, int maximumDigits, Int32& result);
    internal bool ParseFraction(int maximumDigits, int scale, Int32& result, int minimumDigits);
    private int GetDigit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.YearMonthPattern : object {
    internal static YearMonth DefaultTemplateValue;
    private static string IsoFormatPattern;
    internal static string CultureDefaultFormatPattern;
    internal static PatternBclSupport`1<YearMonth> BclSupport;
    [CompilerGeneratedAttribute]
private IPartialPattern`1<YearMonth> <UnderlyingPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private YearMonth <TemplateValue>k__BackingField;
    public static YearMonthPattern Iso { get; }
    internal IPartialPattern`1<YearMonth> UnderlyingPattern { get; }
    public string PatternText { get; }
    private NodaFormatInfo FormatInfo { get; }
    public YearMonth TemplateValue { get; }
    private YearMonthPattern(string patternText, NodaFormatInfo formatInfo, YearMonth templateValue, IPartialPattern`1<YearMonth> pattern);
    private static YearMonthPattern();
    public static YearMonthPattern get_Iso();
    [CompilerGeneratedAttribute]
internal IPartialPattern`1<YearMonth> get_UnderlyingPattern();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
private NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public YearMonth get_TemplateValue();
    public sealed virtual ParseResult`1<YearMonth> Parse(string text);
    public sealed virtual string Format(YearMonth value);
    public sealed virtual StringBuilder AppendFormat(YearMonth value, StringBuilder builder);
    internal static YearMonthPattern Create(string patternText, NodaFormatInfo formatInfo, YearMonth templateValue);
    public static YearMonthPattern Create(string patternText, CultureInfo cultureInfo, YearMonth templateValue);
    public static YearMonthPattern Create(string patternText, CultureInfo cultureInfo);
    public static YearMonthPattern CreateWithCurrentCulture(string patternText);
    public static YearMonthPattern CreateWithInvariantCulture(string patternText);
    private YearMonthPattern WithFormatInfo(NodaFormatInfo formatInfo);
    public YearMonthPattern WithCulture(CultureInfo cultureInfo);
    public YearMonthPattern WithTemplateValue(YearMonth newTemplateValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.YearMonthPatternParser : object {
    private YearMonth templateValue;
    private static Dictionary`2<char, CharacterHandler`2<YearMonth, YearMonthParseBucket>> PatternCharacterHandlers;
    internal YearMonthPatternParser(YearMonth templateValue);
    private static YearMonthPatternParser();
    public sealed virtual IPattern`1<YearMonth> ParsePattern(string patternText, NodaFormatInfo formatInfo);
}
internal class NodaTime.Text.YearMonthTypeConverter : TypeConverterBase`1<YearMonth> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.Text.ZonedDateTimePattern : object {
    [CompilerGeneratedAttribute]
private static ZonedDateTime <DefaultTemplateValue>k__BackingField;
    private IPattern`1<ZonedDateTime> pattern;
    [CompilerGeneratedAttribute]
private string <PatternText>k__BackingField;
    [CompilerGeneratedAttribute]
private NodaFormatInfo <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ZonedDateTime <TemplateValue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ZoneLocalMappingResolver <Resolver>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDateTimeZoneProvider <ZoneProvider>k__BackingField;
    internal static ZonedDateTime DefaultTemplateValue { get; }
    public static ZonedDateTimePattern GeneralFormatOnlyIso { get; }
    public static ZonedDateTimePattern ExtendedFormatOnlyIso { get; }
    public string PatternText { get; }
    private NodaFormatInfo FormatInfo { get; }
    public ZonedDateTime TemplateValue { get; }
    [NullableAttribute("2")]
public ZoneLocalMappingResolver Resolver { get; }
    [NullableAttribute("2")]
public IDateTimeZoneProvider ZoneProvider { get; }
    private ZonedDateTimePattern(string patternText, NodaFormatInfo formatInfo, ZonedDateTime templateValue, ZoneLocalMappingResolver resolver, IDateTimeZoneProvider zoneProvider, IPattern`1<ZonedDateTime> pattern);
    private static ZonedDateTimePattern();
    [CompilerGeneratedAttribute]
internal static ZonedDateTime get_DefaultTemplateValue();
    public static ZonedDateTimePattern get_GeneralFormatOnlyIso();
    public static ZonedDateTimePattern get_ExtendedFormatOnlyIso();
    [CompilerGeneratedAttribute]
public string get_PatternText();
    [CompilerGeneratedAttribute]
private NodaFormatInfo get_FormatInfo();
    [CompilerGeneratedAttribute]
public ZonedDateTime get_TemplateValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ZoneLocalMappingResolver get_Resolver();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IDateTimeZoneProvider get_ZoneProvider();
    public sealed virtual ParseResult`1<ZonedDateTime> Parse(string text);
    public sealed virtual string Format(ZonedDateTime value);
    public sealed virtual StringBuilder AppendFormat(ZonedDateTime value, StringBuilder builder);
    private static ZonedDateTimePattern Create(string patternText, NodaFormatInfo formatInfo, ZoneLocalMappingResolver resolver, IDateTimeZoneProvider zoneProvider, ZonedDateTime templateValue);
    public static ZonedDateTimePattern Create(string patternText, CultureInfo cultureInfo, ZoneLocalMappingResolver resolver, IDateTimeZoneProvider zoneProvider, ZonedDateTime templateValue);
    public static ZonedDateTimePattern CreateWithInvariantCulture(string patternText, IDateTimeZoneProvider zoneProvider);
    public static ZonedDateTimePattern CreateWithCurrentCulture(string patternText, IDateTimeZoneProvider zoneProvider);
    public ZonedDateTimePattern WithPatternText(string patternText);
    private ZonedDateTimePattern WithFormatInfo(NodaFormatInfo formatInfo);
    public ZonedDateTimePattern WithCulture(CultureInfo cultureInfo);
    public ZonedDateTimePattern WithResolver(ZoneLocalMappingResolver resolver);
    public ZonedDateTimePattern WithZoneProvider(IDateTimeZoneProvider newZoneProvider);
    public ZonedDateTimePattern WithTemplateValue(ZonedDateTime newTemplateValue);
    public ZonedDateTimePattern WithCalendar(CalendarSystem calendar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Text.ZonedDateTimePatternParser : object {
    private ZonedDateTime templateValue;
    [NullableAttribute("2")]
private IDateTimeZoneProvider zoneProvider;
    [NullableAttribute("2")]
private ZoneLocalMappingResolver resolver;
    private static Dictionary`2<char, CharacterHandler`2<ZonedDateTime, ZonedDateTimeParseBucket>> PatternCharacterHandlers;
    [NullableContextAttribute("2")]
internal ZonedDateTimePatternParser(ZonedDateTime templateValue, ZoneLocalMappingResolver resolver, IDateTimeZoneProvider zoneProvider);
    private static ZonedDateTimePatternParser();
    public sealed virtual IPattern`1<ZonedDateTime> ParsePattern(string patternText, NodaFormatInfo formatInfo);
    private static void HandleZone(PatternCursor pattern, SteppedPatternBuilder`2<ZonedDateTime, ZonedDateTimeParseBucket> builder);
    private static void HandleZoneAbbreviation(PatternCursor pattern, SteppedPatternBuilder`2<ZonedDateTime, ZonedDateTimeParseBucket> builder);
    private static void HandleOffset(PatternCursor pattern, SteppedPatternBuilder`2<ZonedDateTime, ZonedDateTimeParseBucket> builder);
    private static ParseResult`1<ZonedDateTime> ParseZone(ValueCursor value, ZonedDateTimeParseBucket bucket);
    [CompilerGeneratedAttribute]
private ZonedDateTimeParseBucket <ParsePattern>b__5_0();
}
internal class NodaTime.Text.ZonedDateTimeTypeConverter : TypeConverterBase`1<ZonedDateTime> {
    [NullableAttribute("2")]
private static ZonedDateTimePattern cachedPattern;
    [NullableContextAttribute("1")]
private static ZonedDateTimePattern GetCurrentPattern();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NodaTime.TimeAdjusters : object {
    [CompilerGeneratedAttribute]
private static Func`2<LocalTime, LocalTime> <TruncateToSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<LocalTime, LocalTime> <TruncateToMinute>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<LocalTime, LocalTime> <TruncateToHour>k__BackingField;
    public static Func`2<LocalTime, LocalTime> TruncateToSecond { get; }
    public static Func`2<LocalTime, LocalTime> TruncateToMinute { get; }
    public static Func`2<LocalTime, LocalTime> TruncateToHour { get; }
    private static TimeAdjusters();
    [CompilerGeneratedAttribute]
public static Func`2<LocalTime, LocalTime> get_TruncateToSecond();
    [CompilerGeneratedAttribute]
public static Func`2<LocalTime, LocalTime> get_TruncateToMinute();
    [CompilerGeneratedAttribute]
public static Func`2<LocalTime, LocalTime> get_TruncateToHour();
}
public class NodaTime.TimeZones.AmbiguousTimeResolver : MulticastDelegate {
    public AmbiguousTimeResolver(object object, IntPtr method);
    public virtual ZonedDateTime Invoke(ZonedDateTime earlier, ZonedDateTime later);
    public virtual IAsyncResult BeginInvoke(ZonedDateTime earlier, ZonedDateTime later, AsyncCallback callback, object object);
    public virtual ZonedDateTime EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.BclDateTimeZone : DateTimeZone {
    [NullableAttribute("2")]
private static BclDateTimeZone systemDefault;
    private IZoneIntervalMap map;
    [CompilerGeneratedAttribute]
private TimeZoneInfo <OriginalZone>k__BackingField;
    public TimeZoneInfo OriginalZone { get; }
    public string DisplayName { get; }
    private BclDateTimeZone(TimeZoneInfo bclZone, IZoneIntervalMap map);
    [CompilerGeneratedAttribute]
public TimeZoneInfo get_OriginalZone();
    public string get_DisplayName();
    public virtual ZoneInterval GetZoneInterval(Instant instant);
    public static BclDateTimeZone FromTimeZoneInfo(TimeZoneInfo bclZone);
    internal static bool AreWindowsStyleRules(AdjustmentRule[] rules);
    internal static void FixUnixTransitions(BclAdjustmentRule[] rules);
    internal static IZoneIntervalMap BuildMap(BclAdjustmentRule[] rules, Offset standardOffset, string standardName);
    public static BclDateTimeZone ForSystemDefault();
    [CompilerGeneratedAttribute]
internal static bool <AreWindowsStyleRules>g__IsWindowsRule|10_0(AdjustmentRule rule);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.BclDateTimeZoneSource : object {
    public string VersionId { get; }
    public sealed virtual IEnumerable`1<string> GetIds();
    private static IEnumerable`1<string> GetTimeZoneInfoLocalIdOrEmpty();
    public sealed virtual string get_VersionId();
    private sealed virtual override DateTimeZone NodaTime.TimeZones.IDateTimeZoneSource.ForId(string id);
    public BclDateTimeZone ForId(string id);
    [NullableContextAttribute("2")]
public sealed virtual string GetSystemDefaultId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.CachedDateTimeZone : DateTimeZone {
    private IZoneIntervalMap map;
    [CompilerGeneratedAttribute]
private DateTimeZone <TimeZone>k__BackingField;
    internal DateTimeZone TimeZone { get; }
    private CachedDateTimeZone(DateTimeZone timeZone, IZoneIntervalMap map);
    [CompilerGeneratedAttribute]
internal DateTimeZone get_TimeZone();
    internal static DateTimeZone ForZone(DateTimeZone timeZone);
    public virtual ZoneInterval GetZoneInterval(Instant instant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.TimeZones.CachingZoneIntervalMap : object {
    internal static IZoneIntervalMap CacheMap(IZoneIntervalMap map);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.Cldr.MapZone : object {
    public static string PrimaryTerritory;
    public static string FixedOffsetTerritory;
    [CompilerGeneratedAttribute]
private string <WindowsId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Territory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <TzdbIds>k__BackingField;
    public string WindowsId { get; }
    public string Territory { get; }
    public IList`1<string> TzdbIds { get; }
    public MapZone(string windowsId, string territory, IList`1<string> tzdbIds);
    private MapZone(string windowsId, string territory, ReadOnlyCollection`1<string> tzdbIds);
    [CompilerGeneratedAttribute]
public string get_WindowsId();
    [CompilerGeneratedAttribute]
public string get_Territory();
    [CompilerGeneratedAttribute]
public IList`1<string> get_TzdbIds();
    internal static MapZone Read(IDateTimeZoneReader reader);
    internal void Write(IDateTimeZoneWriter writer);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(MapZone other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.Cldr.WindowsZones : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TzdbVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WindowsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MapZone> <MapZones>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <PrimaryMapping>k__BackingField;
    public string Version { get; }
    public string TzdbVersion { get; }
    public string WindowsVersion { get; }
    public IList`1<MapZone> MapZones { get; }
    public IDictionary`2<string, string> PrimaryMapping { get; }
    internal WindowsZones(string version, string tzdbVersion, string windowsVersion, IList`1<MapZone> mapZones);
    private WindowsZones(string version, string tzdbVersion, string windowsVersion, ReadOnlyCollection`1<MapZone> mapZones);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_TzdbVersion();
    [CompilerGeneratedAttribute]
public string get_WindowsVersion();
    [CompilerGeneratedAttribute]
public IList`1<MapZone> get_MapZones();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_PrimaryMapping();
    internal static WindowsZones Read(IDateTimeZoneReader reader);
    internal void Write(IDateTimeZoneWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[ImmutableAttribute]
public class NodaTime.TimeZones.DateTimeZoneCache : object {
    private IDateTimeZoneSource source;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, DateTimeZone> timeZoneMap;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Ids>k__BackingField;
    public string VersionId { get; }
    public ReadOnlyCollection`1<string> Ids { get; }
    public DateTimeZone Item { get; }
    public DateTimeZoneCache(IDateTimeZoneSource source);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VersionId();
    [CompilerGeneratedAttribute]
public sealed virtual ReadOnlyCollection`1<string> get_Ids();
    public sealed virtual DateTimeZone GetSystemDefault();
    public sealed virtual DateTimeZone GetZoneOrNull(string id);
    private DateTimeZone GetZoneFromSourceOrNull(string id);
    public sealed virtual DateTimeZone get_Item(string id);
}
[MutableAttribute]
public class NodaTime.TimeZones.DateTimeZoneNotFoundException : TimeZoneNotFoundException {
    [NullableContextAttribute("1")]
public DateTimeZoneNotFoundException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.FixedDateTimeZone : DateTimeZone {
    private ZoneInterval interval;
    public Offset Offset { get; }
    public string Name { get; }
    internal FixedDateTimeZone(Offset offset);
    internal FixedDateTimeZone(string id, Offset offset);
    internal FixedDateTimeZone(string id, Offset offset, string name);
    private static string MakeId(Offset offset);
    internal static DateTimeZone GetFixedZoneOrNull(string id);
    public Offset get_Offset();
    public string get_Name();
    public virtual ZoneInterval GetZoneInterval(Instant instant);
    public virtual ZoneLocalMapping MapLocal(LocalDateTime localDateTime);
    public virtual Offset GetUtcOffset(Instant instant);
    internal void Write(IDateTimeZoneWriter writer);
    public static DateTimeZone Read(IDateTimeZoneReader reader, string id);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FixedDateTimeZone other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface NodaTime.TimeZones.IDateTimeZoneSource {
    public string VersionId { get; }
    public abstract virtual IEnumerable`1<string> GetIds();
    public abstract virtual string get_VersionId();
    public abstract virtual DateTimeZone ForId(string id);
    [NullableContextAttribute("2")]
public abstract virtual string GetSystemDefaultId();
}
[MutableAttribute]
public class NodaTime.TimeZones.InvalidDateTimeZoneSourceException : Exception {
    [NullableContextAttribute("1")]
public InvalidDateTimeZoneSourceException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.IO.DateTimeZoneReader : object {
    private Stream input;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> stringPool;
    private Nullable`1<byte> bufferedByte;
    public bool HasMoreData { get; }
    internal DateTimeZoneReader(Stream input, IReadOnlyList`1<string> stringPool);
    public sealed virtual bool get_HasMoreData();
    public sealed virtual int ReadCount();
    public sealed virtual int ReadSignedCount();
    private UInt32 ReadVarint();
    public sealed virtual int ReadMilliseconds();
    public sealed virtual Offset ReadOffset();
    public sealed virtual IDictionary`2<string, string> ReadDictionary();
    public sealed virtual Instant ReadZoneIntervalTransition(Nullable`1<Instant> previous);
    public sealed virtual string ReadString();
    private int ReadInt16();
    private int ReadInt32();
    private long ReadInt64();
    public sealed virtual byte ReadByte();
}
internal class NodaTime.TimeZones.IO.DateTimeZoneWriter : object {
    [NullableAttribute("1")]
private Stream output;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<string> stringPool;
    [NullableContextAttribute("1")]
internal DateTimeZoneWriter(Stream output, IList`1<string> stringPool);
    public sealed virtual void WriteCount(int value);
    public sealed virtual void WriteSignedCount(int count);
    private void WriteVarint(UInt32 value);
    public sealed virtual void WriteMilliseconds(int millis);
    public sealed virtual void WriteOffset(Offset offset);
    [NullableContextAttribute("1")]
public sealed virtual void WriteDictionary(IDictionary`2<string, string> dictionary);
    public sealed virtual void WriteZoneIntervalTransition(Nullable`1<Instant> previous, Instant value);
    [NullableContextAttribute("1")]
public sealed virtual void WriteString(string value);
    private void WriteInt16(short value);
    private void WriteInt32(int value);
    private void WriteInt64(long value);
    public sealed virtual void WriteByte(byte value);
}
[NullableContextAttribute("1")]
internal interface NodaTime.TimeZones.IO.IDateTimeZoneReader {
    public bool HasMoreData { get; }
    public abstract virtual bool get_HasMoreData();
    public abstract virtual int ReadCount();
    public abstract virtual int ReadSignedCount();
    public abstract virtual string ReadString();
    public abstract virtual byte ReadByte();
    public abstract virtual int ReadMilliseconds();
    public abstract virtual Offset ReadOffset();
    public abstract virtual Instant ReadZoneIntervalTransition(Nullable`1<Instant> previous);
    public abstract virtual IDictionary`2<string, string> ReadDictionary();
}
[NullableContextAttribute("1")]
internal interface NodaTime.TimeZones.IO.IDateTimeZoneWriter {
    public abstract virtual void WriteCount(int count);
    public abstract virtual void WriteSignedCount(int count);
    public abstract virtual void WriteString(string value);
    public abstract virtual void WriteMilliseconds(int millis);
    public abstract virtual void WriteOffset(Offset offset);
    public abstract virtual void WriteZoneIntervalTransition(Nullable`1<Instant> previous, Instant value);
    public abstract virtual void WriteDictionary(IDictionary`2<string, string> dictionary);
    public abstract virtual void WriteByte(byte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.IO.TzdbStreamData : object {
    private static Dictionary`2<TzdbStreamFieldId, Action`2<Builder, TzdbStreamField>> FieldHandlers;
    private static int AcceptedVersion;
    private IReadOnlyList`1<string> stringPool;
    private IDictionary`2<string, TzdbStreamField> zoneFields;
    [CompilerGeneratedAttribute]
private string <TzdbVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyDictionary`2<string, string> <TzdbIdMap>k__BackingField;
    [CompilerGeneratedAttribute]
private WindowsZones <WindowsMapping>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyCollection`1<TzdbZoneLocation> <ZoneLocations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyCollection`1<TzdbZone1970Location> <Zone1970Locations>k__BackingField;
    public string TzdbVersion { get; }
    public ReadOnlyDictionary`2<string, string> TzdbIdMap { get; }
    public WindowsZones WindowsMapping { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyCollection`1<TzdbZoneLocation> ZoneLocations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyCollection`1<TzdbZone1970Location> Zone1970Locations { get; }
    [VisibleForTestingAttribute]
internal TzdbStreamData(Builder builder);
    private static TzdbStreamData();
    [CompilerGeneratedAttribute]
public string get_TzdbVersion();
    [CompilerGeneratedAttribute]
public ReadOnlyDictionary`2<string, string> get_TzdbIdMap();
    [CompilerGeneratedAttribute]
public WindowsZones get_WindowsMapping();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<TzdbZoneLocation> get_ZoneLocations();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<TzdbZone1970Location> get_Zone1970Locations();
    public DateTimeZone CreateZone(string id, string canonicalId);
    private static T CheckNotNull(T input, string name);
    internal static TzdbStreamData FromStream(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.IO.TzdbStreamField : object {
    private Byte[] data;
    [CompilerGeneratedAttribute]
private TzdbStreamFieldId <Id>k__BackingField;
    internal TzdbStreamFieldId Id { get; }
    [VisibleForTestingAttribute]
internal TzdbStreamField(TzdbStreamFieldId id, Byte[] data);
    [CompilerGeneratedAttribute]
internal TzdbStreamFieldId get_Id();
    internal Stream CreateStream();
    internal T ExtractSingleValue(Func`2<DateTimeZoneReader, T> readerFunction, IReadOnlyList`1<string> stringPool);
    [IteratorStateMachineAttribute("NodaTime.TimeZones.IO.TzdbStreamField/<ReadFields>d__7")]
internal static IEnumerable`1<TzdbStreamField> ReadFields(Stream input);
}
internal enum NodaTime.TimeZones.IO.TzdbStreamFieldId : Enum {
    public byte value__;
    public static TzdbStreamFieldId StringPool;
    public static TzdbStreamFieldId TimeZone;
    public static TzdbStreamFieldId TzdbVersion;
    public static TzdbStreamFieldId TzdbIdMap;
    public static TzdbStreamFieldId CldrSupplementalWindowsZones;
    public static TzdbStreamFieldId WindowsAdditionalStandardNameToIdMapping;
    public static TzdbStreamFieldId ZoneLocations;
    public static TzdbStreamFieldId Zone1970Locations;
}
[NullableContextAttribute("1")]
internal interface NodaTime.TimeZones.IZoneIntervalMap {
    public Offset MinOffset { get; }
    public Offset MaxOffset { get; }
    public abstract virtual ZoneInterval GetZoneInterval(Instant instant);
    public abstract virtual Offset get_MinOffset();
    public abstract virtual Offset get_MaxOffset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.PartialZoneIntervalMap : object {
    private IZoneIntervalMap map;
    [CompilerGeneratedAttribute]
private Instant <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Instant <End>k__BackingField;
    internal Instant Start { get; }
    internal Instant End { get; }
    private bool IsSingleInterval { get; }
    internal PartialZoneIntervalMap(Instant start, Instant end, IZoneIntervalMap map);
    [CompilerGeneratedAttribute]
internal Instant get_Start();
    [CompilerGeneratedAttribute]
internal Instant get_End();
    internal static PartialZoneIntervalMap ForZoneInterval(string name, Instant start, Instant end, Offset wallOffset, Offset savings);
    internal static PartialZoneIntervalMap ForZoneInterval(ZoneInterval interval);
    internal ZoneInterval GetZoneInterval(Instant instant);
    private bool get_IsSingleInterval();
    internal PartialZoneIntervalMap WithStart(Instant start);
    internal PartialZoneIntervalMap WithEnd(Instant end);
    internal static IZoneIntervalMap ConvertToFullMap(IEnumerable`1<PartialZoneIntervalMap> maps);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.PrecalculatedDateTimeZone : DateTimeZone {
    private ZoneInterval[] periods;
    [NullableAttribute("2")]
private IZoneIntervalMap tailZone;
    private Instant tailZoneStart;
    [NullableAttribute("2")]
private ZoneInterval firstTailZoneInterval;
    [VisibleForTestingAttribute]
internal PrecalculatedDateTimeZone(string id, ZoneInterval[] intervals, IZoneIntervalMap tailZone);
    internal static void ValidatePeriods(ZoneInterval[] periods, IZoneIntervalMap tailZone);
    public virtual ZoneInterval GetZoneInterval(Instant instant);
    internal void Write(IDateTimeZoneWriter writer);
    internal static DateTimeZone Read(IDateTimeZoneReader reader, string id);
    private static Offset ComputeOffset(ZoneInterval[] intervals, IZoneIntervalMap tailZone, OffsetAggregator aggregator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NodaTime.TimeZones.Resolvers : object {
    [CompilerGeneratedAttribute]
private static AmbiguousTimeResolver <ReturnEarlier>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmbiguousTimeResolver <ReturnLater>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmbiguousTimeResolver <ThrowWhenAmbiguous>k__BackingField;
    [CompilerGeneratedAttribute]
private static SkippedTimeResolver <ReturnEndOfIntervalBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private static SkippedTimeResolver <ReturnStartOfIntervalAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private static SkippedTimeResolver <ReturnForwardShifted>k__BackingField;
    [CompilerGeneratedAttribute]
private static SkippedTimeResolver <ThrowWhenSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private static ZoneLocalMappingResolver <StrictResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private static ZoneLocalMappingResolver <LenientResolver>k__BackingField;
    public static AmbiguousTimeResolver ReturnEarlier { get; }
    public static AmbiguousTimeResolver ReturnLater { get; }
    public static AmbiguousTimeResolver ThrowWhenAmbiguous { get; }
    public static SkippedTimeResolver ReturnEndOfIntervalBefore { get; }
    public static SkippedTimeResolver ReturnStartOfIntervalAfter { get; }
    public static SkippedTimeResolver ReturnForwardShifted { get; }
    public static SkippedTimeResolver ThrowWhenSkipped { get; }
    public static ZoneLocalMappingResolver StrictResolver { get; }
    public static ZoneLocalMappingResolver LenientResolver { get; }
    private static Resolvers();
    [CompilerGeneratedAttribute]
public static AmbiguousTimeResolver get_ReturnEarlier();
    [CompilerGeneratedAttribute]
public static AmbiguousTimeResolver get_ReturnLater();
    [CompilerGeneratedAttribute]
public static AmbiguousTimeResolver get_ThrowWhenAmbiguous();
    [CompilerGeneratedAttribute]
public static SkippedTimeResolver get_ReturnEndOfIntervalBefore();
    [CompilerGeneratedAttribute]
public static SkippedTimeResolver get_ReturnStartOfIntervalAfter();
    [CompilerGeneratedAttribute]
public static SkippedTimeResolver get_ReturnForwardShifted();
    [CompilerGeneratedAttribute]
public static SkippedTimeResolver get_ThrowWhenSkipped();
    [CompilerGeneratedAttribute]
public static ZoneLocalMappingResolver get_StrictResolver();
    [CompilerGeneratedAttribute]
public static ZoneLocalMappingResolver get_LenientResolver();
    public static ZoneLocalMappingResolver CreateMappingResolver(AmbiguousTimeResolver ambiguousTimeResolver, SkippedTimeResolver skippedTimeResolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.SingleZoneIntervalMap : object {
    private ZoneInterval interval;
    public Offset MinOffset { get; }
    public Offset MaxOffset { get; }
    internal SingleZoneIntervalMap(ZoneInterval interval);
    public sealed virtual Offset get_MinOffset();
    public sealed virtual Offset get_MaxOffset();
    public sealed virtual ZoneInterval GetZoneInterval(Instant instant);
}
public class NodaTime.TimeZones.SkippedTimeResolver : MulticastDelegate {
    public SkippedTimeResolver(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ZonedDateTime Invoke(LocalDateTime localDateTime, DateTimeZone zone, ZoneInterval intervalBefore, ZoneInterval intervalAfter);
    public virtual IAsyncResult BeginInvoke(LocalDateTime localDateTime, DateTimeZone zone, ZoneInterval intervalBefore, ZoneInterval intervalAfter, AsyncCallback callback, object object);
    public virtual ZonedDateTime EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.StandardDaylightAlternatingMap : object {
    private Offset standardOffset;
    private ZoneRecurrence standardRecurrence;
    private ZoneRecurrence dstRecurrence;
    public Offset MinOffset { get; }
    public Offset MaxOffset { get; }
    internal StandardDaylightAlternatingMap(Offset standardOffset, ZoneRecurrence startRecurrence, ZoneRecurrence endRecurrence);
    public sealed virtual Offset get_MinOffset();
    public sealed virtual Offset get_MaxOffset();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(StandardDaylightAlternatingMap other);
    public virtual int GetHashCode();
    public sealed virtual ZoneInterval GetZoneInterval(Instant instant);
    private Transition NextTransition(Instant instant, ZoneRecurrence& recurrence);
    internal void Write(IDateTimeZoneWriter writer);
    internal static StandardDaylightAlternatingMap Read(IDateTimeZoneReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.TimeZones.TimeZoneInfoInterceptor : object {
    [CompilerGeneratedAttribute]
private static ITimeZoneInfoShim <Shim>k__BackingField;
    internal static ITimeZoneInfoShim Shim { get; internal set; }
    [NullableAttribute("2")]
internal static TimeZoneInfo Local { get; }
    private static TimeZoneInfoInterceptor();
    [CompilerGeneratedAttribute]
internal static ITimeZoneInfoShim get_Shim();
    [CompilerGeneratedAttribute]
internal static void set_Shim(ITimeZoneInfoShim value);
    [NullableContextAttribute("2")]
internal static TimeZoneInfo get_Local();
    internal static TimeZoneInfo FindSystemTimeZoneById(string id);
    internal static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
}
[IsReadOnlyAttribute]
internal class NodaTime.TimeZones.Transition : ValueType {
    [CompilerGeneratedAttribute]
private Instant <Instant>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <NewOffset>k__BackingField;
    internal Instant Instant { get; }
    internal Offset NewOffset { get; }
    internal Transition(Instant instant, Offset newOffset);
    [CompilerGeneratedAttribute]
internal Instant get_Instant();
    [CompilerGeneratedAttribute]
internal Offset get_NewOffset();
    public sealed virtual bool Equals(Transition other);
    public static bool op_Equality(Transition left, Transition right);
    public static bool op_Inequality(Transition left, Transition right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal enum NodaTime.TimeZones.TransitionMode : Enum {
    public int value__;
    public static TransitionMode Utc;
    public static TransitionMode Wall;
    public static TransitionMode Standard;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.TzdbDateTimeZoneSource : object {
    private TzdbStreamData source;
    private string version;
    private Lazy`1<IReadOnlyDictionary`2<string, string>> tzdbToWindowsId;
    private Lazy`1<IReadOnlyDictionary`2<string, string>> windowsToTzdbId;
    [CompilerGeneratedAttribute]
private ILookup`2<string, string> <Aliases>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, string> guesses;
    public static TzdbDateTimeZoneSource Default { get; }
    public ILookup`2<string, string> Aliases { get; }
    public IDictionary`2<string, string> CanonicalIdMap { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<TzdbZoneLocation> ZoneLocations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<TzdbZone1970Location> Zone1970Locations { get; }
    public string VersionId { get; }
    public string TzdbVersion { get; }
    public WindowsZones WindowsMapping { get; }
    public IReadOnlyDictionary`2<string, string> TzdbToWindowsIds { get; }
    public IReadOnlyDictionary`2<string, string> WindowsToTzdbIds { get; }
    [VisibleForTestingAttribute]
internal TzdbDateTimeZoneSource(TzdbStreamData source);
    public static TzdbDateTimeZoneSource get_Default();
    [CompilerGeneratedAttribute]
public ILookup`2<string, string> get_Aliases();
    public IDictionary`2<string, string> get_CanonicalIdMap();
    public IList`1<TzdbZoneLocation> get_ZoneLocations();
    public IList`1<TzdbZone1970Location> get_Zone1970Locations();
    public sealed virtual string get_VersionId();
    public static TzdbDateTimeZoneSource FromStream(Stream stream);
    private IReadOnlyDictionary`2<string, string> BuildTzdbToWindowsIdMap();
    private IReadOnlyDictionary`2<string, string> BuildWindowsToTzdbId();
    public sealed virtual DateTimeZone ForId(string id);
    [DebuggerStepThroughAttribute]
public sealed virtual IEnumerable`1<string> GetIds();
    [NullableContextAttribute("2")]
public sealed virtual string GetSystemDefaultId();
    [NullableContextAttribute("2")]
[VisibleForTestingAttribute]
internal string MapTimeZoneInfoId(TimeZoneInfo timeZone);
    private string GuessZoneIdByTransitions(TimeZoneInfo zone);
    internal static string GuessZoneIdByTransitionsUncached(TimeZoneInfo zone, List`1<DateTimeZone> candidates);
    public string get_TzdbVersion();
    public WindowsZones get_WindowsMapping();
    public IReadOnlyDictionary`2<string, string> get_TzdbToWindowsIds();
    public IReadOnlyDictionary`2<string, string> get_WindowsToTzdbIds();
    public void Validate();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <BuildWindowsToTzdbId>b__21_1(KeyValuePair`2<string, string> pair);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.TzdbZone1970Location : object {
    private int latitudeSeconds;
    private int longitudeSeconds;
    [CompilerGeneratedAttribute]
private IList`1<Country> <Countries>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ZoneId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    public double Latitude { get; }
    public double Longitude { get; }
    public IList`1<Country> Countries { get; }
    public string ZoneId { get; }
    public string Comment { get; }
    public TzdbZone1970Location(int latitudeSeconds, int longitudeSeconds, IEnumerable`1<Country> countries, string zoneId, string comment);
    public double get_Latitude();
    public double get_Longitude();
    [CompilerGeneratedAttribute]
public IList`1<Country> get_Countries();
    [CompilerGeneratedAttribute]
public string get_ZoneId();
    [CompilerGeneratedAttribute]
public string get_Comment();
    internal void Write(IDateTimeZoneWriter writer);
    internal static TzdbZone1970Location Read(IDateTimeZoneReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.TzdbZoneLocation : object {
    private int latitudeSeconds;
    private int longitudeSeconds;
    [CompilerGeneratedAttribute]
private string <CountryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ZoneId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    public double Latitude { get; }
    public double Longitude { get; }
    public string CountryName { get; }
    public string CountryCode { get; }
    public string ZoneId { get; }
    public string Comment { get; }
    public TzdbZoneLocation(int latitudeSeconds, int longitudeSeconds, string countryName, string countryCode, string zoneId, string comment);
    public double get_Latitude();
    public double get_Longitude();
    [CompilerGeneratedAttribute]
public string get_CountryName();
    [CompilerGeneratedAttribute]
public string get_CountryCode();
    [CompilerGeneratedAttribute]
public string get_ZoneId();
    [CompilerGeneratedAttribute]
public string get_Comment();
    internal void Write(IDateTimeZoneWriter writer);
    internal static TzdbZoneLocation Read(IDateTimeZoneReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.ZoneEqualityComparer : object {
    private Interval interval;
    private Options options;
    private ZoneIntervalEqualityComparer zoneIntervalComparer;
    [VisibleForTestingAttribute]
internal Interval IntervalForTest { get; }
    [VisibleForTestingAttribute]
internal Options OptionsForTest { get; }
    private ZoneEqualityComparer(Interval interval, Options options);
    private static bool CheckOption(Options options, Options candidate);
    internal Interval get_IntervalForTest();
    internal Options get_OptionsForTest();
    public static ZoneEqualityComparer ForInterval(Interval interval);
    public ZoneEqualityComparer WithOptions(Options options);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DateTimeZone x, DateTimeZone y);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(DateTimeZone obj);
    private IEnumerable`1<ZoneInterval> GetIntervals(DateTimeZone zone);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.ZoneInterval : object {
    [CompilerGeneratedAttribute]
private Instant <RawStart>k__BackingField;
    [CompilerGeneratedAttribute]
private Instant <RawEnd>k__BackingField;
    private LocalInstant localStart;
    private LocalInstant localEnd;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <WallOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <Savings>k__BackingField;
    internal Instant RawStart { get; }
    internal Instant RawEnd { get; }
    public Offset StandardOffset { get; }
    public Duration Duration { get; }
    public bool HasStart { get; }
    public Instant End { get; }
    public bool HasEnd { get; }
    public LocalDateTime IsoLocalStart { get; }
    public LocalDateTime IsoLocalEnd { get; }
    public string Name { get; }
    public Offset WallOffset { get; }
    public Offset Savings { get; }
    public Instant Start { get; }
    public ZoneInterval(string name, Nullable`1<Instant> start, Nullable`1<Instant> end, Offset wallOffset, Offset savings);
    internal ZoneInterval(string name, Instant start, Instant end, Offset wallOffset, Offset savings);
    [CompilerGeneratedAttribute]
internal Instant get_RawStart();
    [CompilerGeneratedAttribute]
internal Instant get_RawEnd();
    [DebuggerStepThroughAttribute]
public Offset get_StandardOffset();
    [DebuggerStepThroughAttribute]
public Duration get_Duration();
    public bool get_HasStart();
    [DebuggerStepThroughAttribute]
public Instant get_End();
    public bool get_HasEnd();
    [DebuggerStepThroughAttribute]
public LocalDateTime get_IsoLocalStart();
    [DebuggerStepThroughAttribute]
public LocalDateTime get_IsoLocalEnd();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
public Offset get_WallOffset();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
public Offset get_Savings();
    [DebuggerStepThroughAttribute]
public Instant get_Start();
    internal ZoneInterval WithStart(Instant newStart);
    internal ZoneInterval WithEnd(Instant newEnd);
    [DebuggerStepThroughAttribute]
public bool Contains(Instant instant);
    [DebuggerStepThroughAttribute]
internal bool Contains(LocalInstant localInstant);
    internal bool EqualIgnoreBounds(ZoneInterval other);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public sealed virtual bool Equals(ZoneInterval other);
    [NullableContextAttribute("2")]
public static bool op_Equality(ZoneInterval left, ZoneInterval right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ZoneInterval left, ZoneInterval right);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.TimeZones.ZoneLocalMapping : object {
    [CompilerGeneratedAttribute]
private DateTimeZone <Zone>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalDateTime <LocalDateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ZoneInterval <EarlyInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private ZoneInterval <LateInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public DateTimeZone Zone { get; }
    public LocalDateTime LocalDateTime { get; }
    public ZoneInterval EarlyInterval { get; }
    public ZoneInterval LateInterval { get; }
    public int Count { get; }
    internal ZoneLocalMapping(DateTimeZone zone, LocalDateTime localDateTime, ZoneInterval earlyInterval, ZoneInterval lateInterval, int count);
    [CompilerGeneratedAttribute]
public DateTimeZone get_Zone();
    [CompilerGeneratedAttribute]
public LocalDateTime get_LocalDateTime();
    [CompilerGeneratedAttribute]
public ZoneInterval get_EarlyInterval();
    [CompilerGeneratedAttribute]
public ZoneInterval get_LateInterval();
    [CompilerGeneratedAttribute]
public int get_Count();
    public ZonedDateTime Single();
    public ZonedDateTime First();
    public ZonedDateTime Last();
    private ZonedDateTime BuildZonedDateTime(ZoneInterval interval);
}
public class NodaTime.TimeZones.ZoneLocalMappingResolver : MulticastDelegate {
    public ZoneLocalMappingResolver(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ZonedDateTime Invoke(ZoneLocalMapping mapping);
    public virtual IAsyncResult BeginInvoke(ZoneLocalMapping mapping, AsyncCallback callback, object object);
    public virtual ZonedDateTime EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.ZoneRecurrence : object {
    private LocalInstant maxLocalInstant;
    private LocalInstant minLocalInstant;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <Savings>k__BackingField;
    [CompilerGeneratedAttribute]
private ZoneYearOffset <YearOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FromYear>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ToYear>k__BackingField;
    public string Name { get; }
    public Offset Savings { get; }
    public ZoneYearOffset YearOffset { get; }
    public int FromYear { get; }
    public int ToYear { get; }
    public bool IsInfinite { get; }
    public ZoneRecurrence(string name, Offset savings, ZoneYearOffset yearOffset, int fromYear, int toYear);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Offset get_Savings();
    [CompilerGeneratedAttribute]
public ZoneYearOffset get_YearOffset();
    [CompilerGeneratedAttribute]
public int get_FromYear();
    [CompilerGeneratedAttribute]
public int get_ToYear();
    public bool get_IsInfinite();
    internal ZoneRecurrence WithName(string name);
    internal ZoneRecurrence ForSingleYear(int year);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ZoneRecurrence other);
    internal Nullable`1<Transition> Next(Instant instant, Offset standardOffset, Offset previousSavings);
    internal Nullable`1<Transition> PreviousOrSame(Instant instant, Offset standardOffset, Offset previousSavings);
    internal Transition NextOrFail(Instant instant, Offset standardOffset, Offset previousSavings);
    internal Transition PreviousOrSameOrFail(Instant instant, Offset standardOffset, Offset previousSavings);
    internal void Write(IDateTimeZoneWriter writer);
    public static ZoneRecurrence Read(IDateTimeZoneReader reader);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal ZoneRecurrence ToStartOfTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.TimeZones.ZoneYearOffset : object {
    private int dayOfMonth;
    private int dayOfWeek;
    private int monthOfYear;
    private bool addDay;
    [CompilerGeneratedAttribute]
private TransitionMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AdvanceDayOfWeek>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalTime <TimeOfDay>k__BackingField;
    public TransitionMode Mode { get; }
    public bool AdvanceDayOfWeek { get; }
    public LocalTime TimeOfDay { get; }
    internal ZoneYearOffset(TransitionMode mode, int monthOfYear, int dayOfMonth, int dayOfWeek, bool advance, LocalTime timeOfDay);
    internal ZoneYearOffset(TransitionMode mode, int monthOfYear, int dayOfMonth, int dayOfWeek, bool advance, LocalTime timeOfDay, bool addDay);
    [CompilerGeneratedAttribute]
public TransitionMode get_Mode();
    [CompilerGeneratedAttribute]
public bool get_AdvanceDayOfWeek();
    [CompilerGeneratedAttribute]
public LocalTime get_TimeOfDay();
    private static void VerifyFieldValue(long minimum, long maximum, string name, long value, bool allowNegated);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ZoneYearOffset other);
    public virtual string ToString();
    internal LocalInstant GetOccurrenceForYear(int year);
    internal void Write(IDateTimeZoneWriter writer);
    public static ZoneYearOffset Read(IDateTimeZoneReader reader);
    internal Offset GetRuleOffset(Offset standardOffset, Offset savings);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NodaTime.Utility.BclConversions : object {
    public static DayOfWeek ToDayOfWeek(IsoDayOfWeek isoDayOfWeek);
    public static IsoDayOfWeek ToIsoDayOfWeek(DayOfWeek dayOfWeek);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Utility.Cache`2 : object {
    private int size;
    private Func`2<TKey, TValue> valueFactory;
    private ConcurrentQueue`1<TKey> keyList;
    private ConcurrentDictionary`2<TKey, TValue> dictionary;
    internal int Count { get; }
    internal List`1<TKey> Keys { get; }
    internal Cache`2(int size, Func`2<TKey, TValue> valueFactory, IEqualityComparer`1<TKey> keyComparer);
    internal TValue GetOrAdd(TKey key);
    internal int get_Count();
    internal List`1<TKey> get_Keys();
    internal void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NodaTime.Utility.HashCodeHelper : ValueType {
    private static int HashCodeMultiplier;
    private static int HashCodeInitializer;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    internal HashCodeHelper(int value);
    [CompilerGeneratedAttribute]
public int get_Value();
    internal static int Hash(T1 t1, T2 t2);
    internal static int Hash(T1 t1, T2 t2, T3 t3);
    internal static HashCodeHelper Initialize();
    internal HashCodeHelper Hash(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MutableAttribute]
public class NodaTime.Utility.InvalidNodaDataException : Exception {
    public InvalidNodaDataException(string message);
    public InvalidNodaDataException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NodaTime.Utility.Preconditions : object {
    [ContractAnnotationAttribute("argument:null => halt")]
internal static T CheckNotNull(T argument, string paramName);
    [ConditionalAttribute("DEBUG")]
[ContractAnnotationAttribute("argument:null => halt")]
internal static void DebugCheckNotNull(T argument, string paramName);
    internal static void CheckArgumentRange(string paramName, int value, int minInclusive, int maxInclusive);
    internal static void CheckArgumentRange(string paramName, long value, long minInclusive, long maxInclusive);
    internal static void CheckArgumentRange(string paramName, double value, double minInclusive, double maxInclusive);
    private static void ThrowArgumentOutOfRangeException(string paramName, T value, T minInclusive, T maxInclusive);
    internal static T ThrowArgumentOutOfRangeExceptionWithReturn(string paramName, T value, T minInclusive, T maxInclusive);
    [ConditionalAttribute("DEBUG")]
internal static void DebugCheckArgumentRange(string paramName, int value, int minInclusive, int maxInclusive);
    [ConditionalAttribute("DEBUG")]
internal static void DebugCheckArgumentRange(string paramName, long value, long minInclusive, long maxInclusive);
    [ContractAnnotationAttribute("expression:false => halt")]
[ConditionalAttribute("DEBUG")]
internal static void DebugCheckArgument(bool expression, string parameter, string messageFormat, Object[] messageArgs);
    [ContractAnnotationAttribute("expression:false => halt")]
internal static void CheckArgument(bool expression, string parameter, string message);
    [ContractAnnotationAttribute("expression:false => halt")]
[StringFormatMethodAttribute("messageFormat")]
internal static void CheckArgument(bool expression, string parameter, string messageFormat, T messageArg);
    [ContractAnnotationAttribute("expression:false => halt")]
[StringFormatMethodAttribute("messageFormat")]
internal static void CheckArgument(bool expression, string parameter, string messageFormat, T1 messageArg1, T2 messageArg2);
    internal static void CheckState(bool expression, string message);
    [ContractAnnotationAttribute("expression:false => halt")]
[ConditionalAttribute("DEBUG")]
internal static void DebugCheckState(bool expression, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NodaTime.Utility.ReferenceEqualityComparer`1 : object {
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(T first, T second);
    public sealed virtual int GetHashCode(T value);
}
internal static class NodaTime.Utility.TickArithmetic : object {
    internal static int TicksToDaysAndTickOfDay(long ticks, Int64& tickOfDay);
    internal static int NonNegativeTicksToDaysAndTickOfDay(long ticks, Int64& tickOfDay);
    internal static long DaysAndTickOfDayToTicks(int days, long tickOfDay);
    internal static long BoundedDaysAndTickOfDayToTicks(int days, long tickOfDay);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NodaTime.Xml.XmlSchemaDefinition : object {
    [CompilerGeneratedAttribute]
private static XmlQualifiedName <NodaTimeXmlNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static XmlSchema <NodaTimeXmlSchema>k__BackingField;
    private static string YearPattern;
    private static string MonthPattern;
    private static string DayPattern;
    private static string TimePattern;
    private static string OffsetPattern;
    private static string PeriodBuilderPattern;
    private static string DurationPattern;
    private static XmlSchemaType AnnualDateSchemaType;
    private static XmlSchemaType DurationSchemaType;
    private static XmlSchemaType InstantSchemaType;
    private static XmlSchemaType IntervalSchemaType;
    private static XmlSchemaType LocalDateSchemaType;
    private static XmlSchemaType LocalDateTimeSchemaType;
    private static XmlSchemaType LocalTimeSchemaType;
    private static XmlSchemaType OffsetSchemaType;
    private static XmlSchemaType OffsetDateSchemaType;
    private static XmlSchemaType OffsetDateTimeSchemaType;
    private static XmlSchemaType OffsetTimeSchemaType;
    private static XmlSchemaType PeriodBuilderSchemaType;
    private static XmlSchemaType YearMonthSchemaType;
    private static XmlSchemaType ZonedDateTimeSchemaType;
    private static Dictionary`2<XmlSchemaType, IEnumerable`1<XmlSchemaType>> DependentSchemaTypes;
    public static XmlQualifiedName NodaTimeXmlNamespace { get; }
    public static XmlSchema NodaTimeXmlSchema { get; }
    private static XmlSchemaDefinition();
    [CompilerGeneratedAttribute]
public static XmlQualifiedName get_NodaTimeXmlNamespace();
    [CompilerGeneratedAttribute]
public static XmlSchema get_NodaTimeXmlSchema();
    internal static XmlQualifiedName AddAnnualDateSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddDurationSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddInstantSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddIntervalSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddLocalDateSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddLocalDateTimeSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddLocalTimeSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddOffsetSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddOffsetDateSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddOffsetDateTimeSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddOffsetTimeSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddPeriodBuilderSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddYearMonthSchemaType(XmlSchemaSet schemaSet);
    internal static XmlQualifiedName AddZonedDateTimeSchemaType(XmlSchemaSet schemaSet);
    [ExtensionAttribute]
private static XmlQualifiedName AddSchemaType(XmlSchemaSet schemaSet, XmlSchemaType schemaType);
    private static XmlSchema CreateNodaTimeXmlSchema();
    private static XmlSchemaComplexType CreateSchemaType(XmlSchemaType baseType, XmlSchemaAttribute[] attributes);
    private static XmlSchemaSimpleType CreatePatternRestriction(XmlSchemaType baseType, string pattern);
    private static XmlSchemaType CreateEnumerationRestriction(string name, XmlSchemaType baseType, IEnumerable`1<string> values);
    private static T QualifySchemaType(T schemaType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NodaTime.Xml.XmlSerializationSettings : object {
    private static object stateLock;
    private static IDateTimeZoneProvider dateTimeZoneProvider;
    public static IDateTimeZoneProvider DateTimeZoneProvider { get; public set; }
    private static XmlSerializationSettings();
    public static IDateTimeZoneProvider get_DateTimeZoneProvider();
    public static void set_DateTimeZoneProvider(IDateTimeZoneProvider value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[XmlSchemaProviderAttribute("AddSchema")]
[TypeConverterAttribute("NodaTime.Text.YearMonthTypeConverter")]
public class NodaTime.YearMonth : ValueType {
    private YearMonthDayCalendar startOfMonth;
    public CalendarSystem Calendar { get; }
    private CalendarOrdinal CalendarOrdinal { get; }
    public int Year { get; }
    public int Month { get; }
    public int YearOfEra { get; }
    public Era Era { get; }
    internal LocalDate StartDate { get; }
    internal LocalDate EndDate { get; }
    private YearMonthDay YearMonthDay { get; }
    public YearMonth(int year, int month);
    public YearMonth(int year, int month, CalendarSystem calendar);
    public YearMonth(Era era, int yearOfEra, int month);
    public YearMonth(Era era, int yearOfEra, int month, CalendarSystem calendar);
    public CalendarSystem get_Calendar();
    private CalendarOrdinal get_CalendarOrdinal();
    public int get_Year();
    public int get_Month();
    public int get_YearOfEra();
    public Era get_Era();
    internal LocalDate get_StartDate();
    internal LocalDate get_EndDate();
    private YearMonthDay get_YearMonthDay();
    [PureAttribute]
public DateInterval ToDateInterval();
    [PureAttribute]
public YearMonth PlusMonths(int months);
    [PureAttribute]
public LocalDate OnDayOfMonth(int day);
    public sealed virtual int CompareTo(YearMonth other);
    private int TrustedCompareTo(YearMonth other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
    public static bool op_LessThan(YearMonth lhs, YearMonth rhs);
    public static bool op_LessThanOrEqual(YearMonth lhs, YearMonth rhs);
    public static bool op_GreaterThan(YearMonth lhs, YearMonth rhs);
    public static bool op_GreaterThanOrEqual(YearMonth lhs, YearMonth rhs);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(YearMonth other);
    public static bool op_Equality(YearMonth lhs, YearMonth rhs);
    public static bool op_Inequality(YearMonth lhs, YearMonth rhs);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    public virtual string ToString();
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[IsReadOnlyAttribute]
internal class NodaTime.YearMonthDay : ValueType {
    private static int DayMask;
    private static int MonthMask;
    private int value;
    internal int Year { get; }
    internal int Month { get; }
    internal int Day { get; }
    internal YearMonthDay(int rawValue);
    internal YearMonthDay(int year, int month, int day);
    internal int get_Year();
    internal int get_Month();
    internal int get_Day();
    [NullableContextAttribute("1")]
internal static YearMonthDay Parse(string text);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal YearMonthDayCalendar WithCalendar(CalendarSystem calendar);
    internal YearMonthDayCalendar WithCalendarOrdinal(CalendarOrdinal calendarOrdinal);
    public sealed virtual int CompareTo(YearMonthDay other);
    public sealed virtual bool Equals(YearMonthDay other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(YearMonthDay lhs, YearMonthDay rhs);
    public static bool op_Inequality(YearMonthDay lhs, YearMonthDay rhs);
    public static bool op_LessThan(YearMonthDay lhs, YearMonthDay rhs);
    public static bool op_LessThanOrEqual(YearMonthDay lhs, YearMonthDay rhs);
    public static bool op_GreaterThan(YearMonthDay lhs, YearMonthDay rhs);
    public static bool op_GreaterThanOrEqual(YearMonthDay lhs, YearMonthDay rhs);
}
[IsReadOnlyAttribute]
internal class NodaTime.YearMonthDayCalendar : ValueType {
    internal static int CalendarBits;
    internal static int DayBits;
    internal static int MonthBits;
    internal static int YearBits;
    private static int CalendarDayBits;
    private static int CalendarDayMonthBits;
    private static int CalendarMask;
    private static int DayMask;
    private static int MonthMask;
    private static int YearMask;
    private int value;
    internal CalendarOrdinal CalendarOrdinal { get; }
    internal int Year { get; }
    internal int Month { get; }
    internal int Day { get; }
    internal YearMonthDayCalendar(int yearMonthDay, CalendarOrdinal calendarOrdinal);
    internal YearMonthDayCalendar(int year, int month, int day, CalendarOrdinal calendarOrdinal);
    internal CalendarOrdinal get_CalendarOrdinal();
    internal int get_Year();
    internal int get_Month();
    internal int get_Day();
    [NullableContextAttribute("1")]
[VisibleForTestingAttribute]
internal static YearMonthDayCalendar Parse(string text);
    internal YearMonthDay ToYearMonthDay();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(YearMonthDayCalendar lhs, YearMonthDayCalendar rhs);
    public static bool op_Inequality(YearMonthDayCalendar lhs, YearMonthDayCalendar rhs);
    public sealed virtual bool Equals(YearMonthDayCalendar other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ImmutableAttribute]
public class NodaTime.ZonedClock : object {
    [CompilerGeneratedAttribute]
private IClock <Clock>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeZone <Zone>k__BackingField;
    [CompilerGeneratedAttribute]
private CalendarSystem <Calendar>k__BackingField;
    public IClock Clock { get; }
    public DateTimeZone Zone { get; }
    public CalendarSystem Calendar { get; }
    public ZonedClock(IClock clock, DateTimeZone zone, CalendarSystem calendar);
    [CompilerGeneratedAttribute]
public IClock get_Clock();
    [CompilerGeneratedAttribute]
public DateTimeZone get_Zone();
    [CompilerGeneratedAttribute]
public CalendarSystem get_Calendar();
    public sealed virtual Instant GetCurrentInstant();
    [PureAttribute]
public ZonedDateTime GetCurrentZonedDateTime();
    [PureAttribute]
public LocalDateTime GetCurrentLocalDateTime();
    [PureAttribute]
public OffsetDateTime GetCurrentOffsetDateTime();
    [PureAttribute]
public LocalDate GetCurrentDate();
    [PureAttribute]
public LocalTime GetCurrentTimeOfDay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeConverterAttribute("NodaTime.Text.ZonedDateTimeTypeConverter")]
[XmlSchemaProviderAttribute("AddSchema")]
public class NodaTime.ZonedDateTime : ValueType {
    private OffsetDateTime offsetDateTime;
    private DateTimeZone zone;
    public Offset Offset { get; }
    public DateTimeZone Zone { get; }
    public LocalDateTime LocalDateTime { get; }
    public CalendarSystem Calendar { get; }
    public LocalDate Date { get; }
    public LocalTime TimeOfDay { get; }
    public Era Era { get; }
    public int Year { get; }
    public int YearOfEra { get; }
    public int Month { get; }
    public int DayOfYear { get; }
    public int Day { get; }
    public IsoDayOfWeek DayOfWeek { get; }
    public int Hour { get; }
    public int ClockHourOfHalfDay { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Millisecond { get; }
    public int TickOfSecond { get; }
    public long TickOfDay { get; }
    public int NanosecondOfSecond { get; }
    public long NanosecondOfDay { get; }
    internal ZonedDateTime(OffsetDateTime offsetDateTime, DateTimeZone zone);
    public ZonedDateTime(Instant instant, DateTimeZone zone, CalendarSystem calendar);
    public ZonedDateTime(Instant instant, DateTimeZone zone);
    public ZonedDateTime(LocalDateTime localDateTime, DateTimeZone zone, Offset offset);
    public Offset get_Offset();
    public DateTimeZone get_Zone();
    public LocalDateTime get_LocalDateTime();
    public CalendarSystem get_Calendar();
    public LocalDate get_Date();
    public LocalTime get_TimeOfDay();
    public Era get_Era();
    public int get_Year();
    public int get_YearOfEra();
    public int get_Month();
    public int get_DayOfYear();
    public int get_Day();
    public IsoDayOfWeek get_DayOfWeek();
    public int get_Hour();
    public int get_ClockHourOfHalfDay();
    public int get_Minute();
    public int get_Second();
    public int get_Millisecond();
    public int get_TickOfSecond();
    public long get_TickOfDay();
    public int get_NanosecondOfSecond();
    public long get_NanosecondOfDay();
    [PureAttribute]
public Instant ToInstant();
    [PureAttribute]
public ZonedDateTime WithZone(DateTimeZone targetZone);
    [PureAttribute]
public ZonedDateTime WithCalendar(CalendarSystem calendar);
    public sealed virtual bool Equals(ZonedDateTime other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ZonedDateTime left, ZonedDateTime right);
    public static bool op_Inequality(ZonedDateTime left, ZonedDateTime right);
    public static ZonedDateTime Add(ZonedDateTime zonedDateTime, Duration duration);
    [PureAttribute]
public ZonedDateTime Plus(Duration duration);
    [PureAttribute]
public ZonedDateTime PlusHours(int hours);
    [PureAttribute]
public ZonedDateTime PlusMinutes(int minutes);
    [PureAttribute]
public ZonedDateTime PlusSeconds(long seconds);
    [PureAttribute]
public ZonedDateTime PlusMilliseconds(long milliseconds);
    [PureAttribute]
public ZonedDateTime PlusTicks(long ticks);
    [PureAttribute]
public ZonedDateTime PlusNanoseconds(long nanoseconds);
    public static ZonedDateTime op_Addition(ZonedDateTime zonedDateTime, Duration duration);
    public static ZonedDateTime Subtract(ZonedDateTime zonedDateTime, Duration duration);
    [PureAttribute]
public ZonedDateTime Minus(Duration duration);
    public static ZonedDateTime op_Subtraction(ZonedDateTime zonedDateTime, Duration duration);
    public static Duration Subtract(ZonedDateTime end, ZonedDateTime start);
    [PureAttribute]
public Duration Minus(ZonedDateTime other);
    public static Duration op_Subtraction(ZonedDateTime end, ZonedDateTime start);
    [PureAttribute]
public ZoneInterval GetZoneInterval();
    [PureAttribute]
public bool IsDaylightSavingTime();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string patternText, IFormatProvider formatProvider);
    [PureAttribute]
public DateTimeOffset ToDateTimeOffset();
    public static ZonedDateTime FromDateTimeOffset(DateTimeOffset dateTimeOffset);
    [PureAttribute]
public DateTime ToDateTimeUtc();
    [PureAttribute]
public DateTime ToDateTimeUnspecified();
    [PureAttribute]
public OffsetDateTime ToOffsetDateTime();
    [PureAttribute]
public void Deconstruct(LocalDateTime& localDateTime, DateTimeZone& dateTimeZone, Offset& offset);
    public static XmlQualifiedName AddSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
